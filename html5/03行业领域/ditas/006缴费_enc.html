<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d8387bb4d4ff7f94868df9de34029a4ff3011001157407c86aca754fe4a20e0971e068d5ec9e8e80c25cecda054a956b10196b63893c8ba70455af7b88ce709e59003ed2d60d8de20efbbd14b96eb90585807d721a0c8a39584c03c8e1b6d3d631c74a13e8b12c7bcefc163489217d10f27bfc1c5dec61a388ab58941d1a1fe71ad7559408726552df74234ca10d8ccd03d4b433b32df84d7935e68117b9d885eb3ee4b47afd7f7006f39cf3476283281184dc62663e2ef083f7148c8d76494c61dbaa923708db2dfa52fda10bb20ab762cc8ba27165757bb46f3843e76dbc0e8c2c6b81ff543db96d6f4cdb8f3a8634af6c82c2163fe8e5365912d6447dba8793eef320474ab8e0c95098c4980869a59b33c4c1d390ab78ea7e42673c95aef250de042b2b834cdd32c29813c3186b1891962e1bfa46ef8fc25e5e54eabb83ff912c1a8cbf992d3a77aa993e51b0604671ab34725906bed50d750e6e4f7884b5248973910c9e3708d511067a439d40efba75f65bf4304611573d2094102ad9c0a35cdcfd8d6bb1643da9ea79bfec3d779823db33c3c19cf3d265374e0507652692f013bbc38f3544b92d4c7c5ab29b29ab6e4bb3879a0338ef0cd49f7838aa957da3f1ceb48601de1769ed74ec3eb4e406e4d559761e4b8dad32a610ccc82619c98bb39f2322c4300a12a83e1448fa1a3176ec7d485b7ba89cbab3019fb554bbcab51f5863f5bec00f6fc272d7526bcad76e8a27995373830a45216d595c091b16badfb2c951e4b5b67a53f0936e5a8735b7a4a1a4781a840334af3b7a35c960350d4feb2ec83a0227136e3d8d01fd617a852c103c013e6e5ad9f86d92fa4944c98d9587ee3a713a25dafe667709564529b02334767b35d135e4e0bed626313107da52a9bd01adbc8a038851b143281f4cea1b14c57bb584409c0528db86538690b6feb9c54f09f36bf6a241d812da1589ff892db380bdf4c84aa6ce639d1814daf10231451eba1d8f66cfc2350a0ee8662e1df33134b9d58767a0bb2dc84bf14657649052af6c79ad7e81a6be2ee6c92f3c8e4e426c5701567448c87aee0865d28dc9b4316a547aae06a3ca329973b22be5c22b61e684873dc3d6458723ae31d708684f8a43c050d0d7a543ceaa68a31eb53c968670e0e4800429120a9cd0e8aa6bf677f763d64dc64a5cc45fe6bd29b9ac4d76812ef721737e3789577b4808691528121cec771fa3cc269d58308942653ca477e6b465d34f36a723021e3f5fd6a5b95a7b339ec708729bcbb4b4a313c5cfa977ef21381dd80b246f191ac33f0803f960881598445b50d9b14c20b72f22d6fca6bec22a3b1f69623122ad71a3621ce7bcb8d5a4d7d6b48b8d9cbd83f5479a5d35e2eeef32dbf1aaf1ba0d8753af0cca5cdebdda278612160336d59d23d61f18f26ccef434ad0ff187f1fd162a73268caf3d108198fb9569f5e662ebdd8e5f617050ae996ff737c5c2975b5217118f59bc9823faaf3d765d6eeb222b3efe3e0a78a59be2250b2587051ba1919a519bebf16d08ce78568b5ec0868af17df6896ce3d362da964dd719d4c5ae351c3da6c0ce02abbf5d7eb27ebd8adfe44d17a4c42397499c7ed6a53f665f3d2754d14315c5de2fb85a0f326f1b83cb958277eb694836ef08d48b654505d3236b2d030d6d02468b538a9b58dda9d2af430db4df9c2728885e625818c1b246b7473812b520cd06f4ce1133438a21e24a91cadad7dceac8496614e29c517392dc31388d50850dc7ca4f8bceb0b4e2848345eebbb267dc8249310b9c990e482aafaf36d83ea6743c7fcedf7bee0573745b4fbae3fdcf4fc962ab4ce4278a4b0366e0c0acf3aa8ea593530a540ae196b68703145f9a416f9aa74e31061d81c2142bf8c437483a8acbbb1b5a81748fbfc6a943c2d6aa8c0cb8a01c8369dcc5e884b82d1bd8b53a4fd434501337dafc202d6c40b1f62c0cd257df5313fe036991b036868633719bd4b93c05d7949b308e9c36dc548cc2f814c887085b6662651273e01cd0296df1a5415b7e2ab63417efa9739a2f56f4825b9e0fcc4d72dbc3729b4bff4134f25ac6c705a37e48ca7078abee19e067cf2ce962358513dc53ded59dd4d2dfeccaa93dca461d1522367ff2f861b812d48362bdb90c436fe84c378e10890e748784561a01b892e9360f42bba18ab83b62815d56fd4e8c96d8fa3ee0f9fd4b611cb482181093beec4828c9e481a2b81038ff24c612de5529931c597833015f6a0fa2e36519f59028828233a91bf8155fd55fb3184747e47909c897cca2fdd5168e4cdb21e00767ba1a0a2a75624a33650a7a2304603ba01445b2434a795c3461e04cf2976a9215cccd175da0695fac8f5852ce605a2e1acc361a055e8fd56de28cb51c115ca0b7e4a284955e44700761eee5ae37e98997be9200ec005113535015111e107da40e5142892d174a0d6f3b4941fef7028b2741de20a066d3a1dc157af0574e14fc21179d023113bad1090e91e3092bc16d02bba05dca0f4ea9f7157f502debfd07b20668bbd5fd3d0d9e3c799da0549c7e4b9b4d3480442c76de35d03da190823aaace0c85d4c000a88095e3ba3848458806adf1148c3a6d81b1f5a4b9f1e8ee9603f74be17845d42fbbdb5f6c5410c4d03b97efa38b42b9e5e1f9f516b6473a277d08860edf77db826f3d10af2b6a529151a6fd72709fb2fc74ee85e7429223a7a0be8f29f988ad09437fd7bc4b761d9f8ae9e51267b1e14f5ad0e6e2c56bbf62d85a586718b31543f803b41c7ee922dda55c96101885003b7a8547b7879004dadd88d2009e32e757e0c943af66ed1678b4f10fb4a5b43b0daba6235806188a87924176013b1a31e6e164ac4f178e98fb03948e78c16973a457b80f2dbf91ec67e7cb22ef72464fa8c49b448385df4649ef07e023a62ee897cffd54362d211758b551e4a5689feb394ccc40c7d184796986505934eded0978953efb8333b31c42e08ae1c8eec6d29ee7cc548792ed913e69f2d4a880cafa2ad0e89dcdb5d95e400b83e7aaa85f05a0977b7c55182b55f4378b2684653e6671e09dc370a4db7bd4268ad5dd49b0ce757703b609b64e00111d1907bb165568030a10c0bfbaa1d610131d0f9be3dfa296a57fa22d686cce88007ec7edaf820e14fcd6886a7fe37a46746bb1fbbc65b4e183104ab592a00cd7f5a230f5cf222c277fe06232305f9fc1f3e922ed8cf212ab6732571beeb287df56904784e1a4baf2b6235275a66a27f3b8faa43ca502b9378ddb275a837fcd22c47947adaaf03c2ca80d68b221c664922cf98e9ced97805272230d1373ab2ce445f73a5fb206386ac5b7988e410b89e9379ae66304fb32c0d9d9756104fb5888b02ed63c76186e1a73e0223e9e7071de7c93b81f4b5e4b832d90ea60356eeb92cee7782d0c01ae88840c13e84363235feb03074756c75d3edd588528cb02ab3d63d8deb8e97d0483a5c709dcea13cdc413c11f4d450f76872b1c9c0f0c8ac2ef3e8b58cd5773013df9e90b20c34500ba2937d75b16f39036c8da6c7f91281eef0f84d3e8785e173ece20f2c7d6a51776916bd5f1bebc1e656bb8d2c5b009bfaea74f5301ec94a69882dfa9984bef3e092cc8395591de05a8cc0dc08d5c046471bf40078fd3b90b34d9954809f25fcb91913c70190b54e82becf5930b4a1a96245bb10f121d8b4286759e787cc36b00f55841f81cf742087f74e8242cf0c298e8deaef85e72465b53446d8cd89e4fda47ffb970fc251eb4f14c64f05adb6f90e3919c48d0a2fc31f65efcc208262aa5714232ff27884c2d0659f49734e2464086bedd54a51a534155efaa5174160e39a6ddbe7ae7ec7f4a20bdac38448e05f9a6863b4b5a9ec23f73cc3110c7ba29b4e8a7719d70b295970ee019b0f977e61bbe4b7e2fd8f660a459c45a810fdd49be22a50323e480c74ecb7423d926bc10617badaeb0c92eab3e8860def9629515b20a56c0129c4e2c07fff4a96c5adf73c0b2b9792721a4fa4eae989a0558256054947ae8cd79c222ee5b5ba4481f2f95904d84bb3d6a706dbcf779f5859bfaee64d962b1fa6f979ffa4cb9468290354d7e370a32fa253eabd2d380f9f39f9e9eb71d5fd1ff88a92904929a883e6879c763b5f0a488f2995574d72d29860545c9bd1cc7e9e0dba6e4ab50e6979d02c7ff28815a50ac11b03b05bb71bbee338fafccf2764b890fef19c052064f2a344514729c84a2b980758a7e62d5053cb8111410455b241d179f188f92932ce23a9ed5a3a8e167902d1563051d473f2cb65863f0408706b0cfb5cab0a694dcf56803ea70ac33ffdc74ada79a79863270171687bbb2115fb788f9fdf641b244f95d9c8bf7780773186e7b0b47c6c968e2f45f25bb0c7f3a83db339b373fe0d5ba334bfa4e14e87e85543c3b7d6afb023d1cd2439c78a0c0993c6675f6c60ad87dde990704746b52b898401ef9d89f22f85c1e3a488dc047147e601591eede75f616535d6382a254b077561350a8cea3a0c1661ac54a8abcae101870ef50957f73aa1d7ddce2c65f46103241009c9d2ec27d0f4a20a0c2de74085be9530638ef392bc22fc2d47fb586a59d818bf4040ebcc32c379c39fcb25399a27ca08a3f31b87e6fa2778c2c8172aa267c9f59e57f60f94a75fcddaa2d74f74bb5e3338908a5a6ea598f1cf31e65a05c9af79de8ee4ac8d1d09b9afcfee741b6998ce20a4dd9e3175076849a3d69e8c6491f73aaeca6d32f866c57a68707fb733a159c9d21478670ab12eea13c4d10dfffe7ef055834f4046a71759f7bda708c9a9b2dc3f5dbf8a60521a3be676b582af4e9d3987e9c5a91694538e38e8cf9a1ee0ad3facd102baf7ea6d5a1f0b0e5be773587da0e7f668e124a8d85a759e51ec92dea4a3fb670566833d8a58c88611c132002d93e86707665e1ba666b6f9b6671c9de2f4798dd766e34fab086809028c6d313856829efb7289cc2035b8d01a07defa9fef62affd5c61d3c8f5b7bde4a3b68fdad1073e47080d0d9f54aa11c03696c38ea45b8ef8de95b424d2b4895b20bd7a9b70d68628fc75e2df9a716abb56729ed36b31b3022c7d371e73c58a358ad6a4b49a3ad5415df9bc13a7d34e1d80aa75720609cf7965294bca90dffa2dc0c9077f9349ac0936c1a0bd6dd4a5b33180e435a08c7f5ddc3516fbab2aed7eb5826efd5407d931e9ce356e6a03fec00ffc9b408258918aa6f4f7355601764cf6dbc4a6bfbdded33143bf696b7258b91a3477ecbba78a22336507bcb5e40178d95afa0fddc53ea909a7678bc7af00b2f4e4744b22d7133ff0b82b1bb916777d7e35412851c774cc8a50e66d1e82852048b7078287fb5e6eed37e8c0a0e095f008eba69803306ec3546ebcb783e924971f0eb50c5db3ea0f974780d786d2eb2a90b705ebbab3696c642d2987414de09bd2b48ebd14bf5865b38741a2860ecc0368f263fb66e1053ebb77710bf7a6f0aa7c8484b0cf09d35e4a4591658a0433849c2859bb96fde1f7f9b4b57bcff7d785bc790e120666b5efaded85f6ce3f1e5bde13f99925e2604385b8a9763aec3b46f6dca91e436e7f5906d84f47ac48ac9996200ecf07375e2ce2375967b300ba5a510a0c0df6de382c68d41c136b2b1a8cb64d600dcf86f8576679b1081529f9c1d425ad5e7aeda7cc97472a2e867bfd83f8590ebede67eb1be6719bb45c030df4f0fd56fe40378f6e213b005dd2b83397cfbc8ff6b3d2ac62bc789fd35db936e57def973c390e3eec2e2a3afa3c520ed5d61d4ab2d939a8752d1de3fab23ae38b7086211ceeb7015f9a70fa41bb7396bf59b4f0395c54544eba61ac71a5df42f69d5daaa37ab1ab59ce229bb335bf6fd9a5e1f7ff39b6e35da50d739bd7986ba0f51f24e83effd57e7f0b72f0b8b7f29058039d71c151f67283566049453c009893df08cab3cce5985f4fa93adfd33d42b567fd2df927540664d755dc3f8929467e420c906362d73fae1a2374d5ccf86c59fe1e24f8044b7e75098baecca059d06de5b3cd19759ecb4f824b37995b4125323da65fbd1c97ae7365f191eb7c8348128ef4db4a81860a7d1a4e12dba844447ec3568828aa73fc938142a51803bacae88fb9d5532946e8caa439d9efcef468b78ea79d74f82383c23a8ba90e8427c7d5887bfc2de93f00721d9b62655974b47a0e16561b4cf594f12d42a4b58f1b1e8f45ac74254bd99a91ceb659a2e4a3c7e65be813446e895e6ca3e735e7b9dd41e3a18e501efa062f85ec868a8dc3eb35f8f1d3602697030fd32e9773a2eea9d361645e43253e183709e9a6a8e1b0ce082f8af666e5482b7c494deb20d64dbf2edea291f1227e5e3e1aff73872bf1b1bc3e4f05db339568f72e3f6111fbd19d40c8d3a68f1a24884ed5f590c8e9d02f8264af170402b17f095b3bdd83637a2a11690bd86ec53fdf49c68eb194f69687066ce4cbe67e9102ea3d67dd9180a91785e68375ef696c542adeb9a2e1f4cc2081b068ce67fdb3c2fc9e7f4516f4b61b875812ab521996be2dc4fbac8343e87582c579891b764075c81f8033c9b019ffffa0c375a4e2e379b1bc20723c050eb8fe59ba347fb74237fd97c7ce4d8f6e544cfac1170b74cb62eb5ac3df146bc832ba97cde20fce8666e03b5ba6cc9972d8160e3cdaa5cda216a5a42a4ba6f2018ead96ce4f7ea79a56a626e73f0c3224a0aeaeefde3c7ddb7e6ca5dd8e8774214871dc5c27a6d04051428c41f8589f93978142a0fa1922e8c2a6fddc6c2e7f1b53e9cc4166f0326b5918ebc44d50c5fa01450fc70642338287771cc519564ba16d337689c97fb571279237a1e64e8d11ace4a427471cf1e5ec063e9358f9da99a6b58358ca7f5bf822b06164273399d55c6bb1dd4e3f1a8cdf8849fc995e58e5b12b6026699704a04f83329b42168886ee6ea27f362d461bb9b754edac18915d699ba229998e84b4e16c1b7064516b66e9fc756e63cd0e6b6ee359f00fd51e5c2afa9ea608052e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
