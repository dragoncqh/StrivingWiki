<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9b20dccc36055157e41d9bc55c58e3f543dff1004f14adb77f01856a7796cecec008dd426a61c515dadadef1248a642fa76ac95a8754459d2e92ee385713cb4cc7ae74213840781b85499eb8e46bca7f691ac528ff2d918f00250c86b8ebbb2b4a548f0771eccd6f0e2c6ba31a34e9426f02e4752c975871de3a69ee869cdb4ab0052c5c85db439799959250041d2d03f51eb0ded0cd6a456a5d42e2b3b8f77fe718e8b3c708e5f9cf944ff9ebf6a931af477574b0ff0fb30e5e5460bdecffa61437b99bafb7ff602a37b3ff1d20163146aff2395cc8c057f35a9e8c59b19add8acf218a729642e2a092e1161a920160b0a79d623262bcd6e88c1a32644fdf7f6b57f78aa4a96c4af5fabcc61bd303fc84cf23374330ec183d68ee3f7ddc7e9b6848b77f4d5198dfc63ec0615b9d2956dfd8f32b371366e23758ab2d2739ba6de626ea2aadccd421d4725bb685c0968db9b453cd6fe40759cfa12a8aab5b0cef6a98a4388a96dcaae24fc2fb5741c98ab690ccb512a4a1ad955b57908c81d9c7144fc01ece14763c7961f821d88c9c5a422143ef14ef7e43f88047c3c82507f757578aec79f340b075898efc27f6b142a8cbc3a1572a9507646a3624bd87c503b0ff11badb5d4567bb06ae4563300014398a1b60c598ac24b8bd55fcbdcd021733cddcabb6d0b6069ba1ac9ba2eede7d17c73da884f0a9c6edea662fb2f97f3d8ed9766a5b742835aceda9ed80bedcfe91b733e1f2e800db7b546fd3f3bc93584a9ceacb3e8469d24c39d5a14c2e668eaee9c91df1552703fe9de57f4a338f52b0b87b50d17b70c366662dd4531ed74f106ef188466564170f0a92558c5310b8c2c2e289adeb73617f083102f1ac7be3a973d9e9415bd89620abadf6c1b5ccb301aebb7f056572d3ebe8c7f10a8c43067dd58fcc7f350ea44d07e25a40af35d478e38b2502e242cb858f859df9eaee80f36d52763c1cea126c2cc1b0b78a53a0cb918c286b598096cbd5ba47df10c7eac810cd6f6d1a236402fc7394b64217f8c20a67aec7c4791b3b53bc02365e9a9ad02d28cc802aa3a67e7d8fa9627b432e36cdafdcabaf1ec4665ba7e82afac6faaba38a421cc86dcaadee10b91af844ddd8f2cc3d10faa799a27a3156b3e829d5fb5df279e24955da0839ca9aa98b32e35983590233549607d62219127d146ec42accc04577341d2b0bde4afd6d1ab148e2f58b660292496c8335f2ae0639c76ffce161e54fb0ba5fa5965fb04c98a1471fd0f855f6c7ef6288b7f08af564d6dbb4554b67366b8131ec25038de01379479996a35f4883f77754c3dc2e8f2e70e3e78fa6d576952f0f735ac8edb81d1826d6f2c37b65633513554118798372360e71ed6ea0cd8344ab9cdc34f716e996d687fa02f15665ab8a29145e2c0faf8257de6a0a72ef047f4ee34a7ebe046a0656ede1676c8915a90a092df86e9586ca130e913a72b9c38a338e32501010ce9a687aaf3038da59140b14d8a7489fc2f7fd147d0566f625345d15ec744fd9fa60e1530f72df14bd18d3617de6f662ec14cbc56f656f4e78b846df14abe99202f02f47c0746b100ea6f7bec9eb4fc51579d20979eb60efb47c944701226913da27eefa1d1dff2d61815d857c61249f3418164f8f6dfb58271548ab1f708015670f65b155789a3137be25fcfa246298dd61a8dab52a15ad4eb64a409a6da5b1d87234810a35cd455b5377558ebc2d2299703b1dcc469f4bc4921ae6da010b20191c62b67171259f3a85a53382fbcff3c3feda45a01fb170e0417b3800b0f8d65e0729969da62745dc3ef157aac1478b45b0182578cfd8916c04bf778b5b060ab148d1b4bd978748bb117c74400db372ad94402da42b08277e17ad2603c1b901a5eb3fbfff8c4a83f85fe7aac50ba43bb3a19de0a3da97d3a8408cdea3179ff073067c8b4e54ac6802b8254727aa455265b0bc6eea2cdb7582b1266a5bf890561074c264ed88d4e97a166322dff8b39f9042175b678a00c05348e874628ead890430107a495413fccd016f8d225f90929527941601beb9c6fc87a6a145a25536176da46843ca1effdd409e108bcf4ca064ed44611d5b55f9bb21ff10ba5640162b33eec1a5847b19e701b91aeae285b36f891c6381744130691a95591f110a69e4b50dddc88c7359c21b5c9e8e7b2ad256ef811e24af0a73cb92af0c725285658fc1b8cd1345e250840164641f10bb73ca0545ca103937110eecf87c34d2576fad608bff937d801c2669da1654729416599a1c0dfbbcfb7f1b991103d62563b4cc9073694b7f6d672a56d811e6c328da287eb68a2e7a4ddf28e9a2f243a9f4e3d5bb6978d988cc5c2b864d87f5a201db0e4a782797128751107ac82600aaa4b0dab8a3e60562bdc2d61eab112f9d4c3daa28411e398a42da33a9c8033460bae854ec4a1d7ccf20b33fa56bc2d23cdc556e4f9ca799205ab0400733fc5776804a361b0262e1818611d31ddaf841590f462673cdccd5cd98c7b436e86185089e5b53b45a4974ac2180a3e5957f1e740aae51b2ea4a4c10120647a59c258008b59cf604ea3ae35a8d46420eb22c147b91803e4c90f98a4719b11539b522cab2d9bb85732c7d37f873e1ec96727abcb81417469c21e312e7a713e04f0101f8a9ecb1bdf9c67cb63f5abe0f08b082287f0e79f0972372b8f03306edff1405bdc6fde434c057b1496b24c75991628d4bc497e7291144f148e8b49e124e9886e32261933ca114db31d0d2231dce8fa0f140051ec36eec1459ec86562beb67fa0aa79b6da83d54936e756343e75bf29a9f936fccd48fb2ebd7af03dac47e1bc9e6c042f167927aeb4c6e82a88a3c00adf4c946a3ee72584df942a186e4817992fd56425c46fc28f4741d126b5aef0005148dd6714efeefa4f6b33dfb370985650f45ca442c718f338f7a8575eab19d95a713f7c8d4b4b57bf01ff31f3ddf1d1e117dd9548c996c9a5110aad679da03419a98775fd3aa1d0cf815bc1c3b408619e5bb864f72c213118ab20994da42d5dd5a0b0aa13cc7bde1c77a18d054245150d3ca2b6d2fd1fa8eb330a653116adf5b722258d914b80b6ad7b22e613cfa29099bc9b9d763b8eb3608944d74fae84d12cf6aece54b43d62c3e6c8d5b6dbc1294e1306a3c5f4550d83c41089d4fd147d81b9222dedf34b507f914cfec3d18f038683e318bc51548c6fbd421401efa0be4b5631cd9daf85f3cde2619d1c338d84010e1ae61520c6b3c3ab04cd9ef4ecc4dc6cd950b4b72a717f3884b7c746309a6ebac7b7f96e9e7f7ae5d183cc1b7335049bc93335ceff2b998162b6da0d708ef2fcac04a6a8888660f634d20fa5525b29b4908c907aac01bd74cc5b1ee540235feed91b0b47938232b42c1f01bdc081c88d0cb33b724bb280a142261de4a2bd1e2a5b3ea169fc222784bb43f3dd0a16f4a448f011cce6b9077a400ae2bc6a4e54ad260a4a9271e1c1fc94d12764a4fead3bbaf021249fe6b1f820c5746481ab1d5d8a345ccac59f5188abba8579e7ef4c60f5181d309dd1aa3864567c59ad1a1aa69a7b425c19257624cc122bd6b8a97c9c77718a53e1c5021ad67c315f7cbaf248f6adcbf232b447bee1b17d35c9aec8eae37ce59e1df431f3233ca8469cbc5bdc7262a2cd5523a3524c4c818b06063bd786a6a3c4364e51f5d635794459f3ab6a11c9bbc34c756b8d2f42b1a1f0ea1effb62fb6cbe0b81140f3407d4d46756cef405043d05274784d442030ade8cf66292c329b6da7dda9ab750495cd9e53b957b4a9f5a847eca5953f672958089379b823d1b42af1602c5e5c165d7e1ca0dabb7e980dd44ab7cccea63f53213569584eb83a3ee58adde9d540d6e1e06ef7e401e9cfb3ab61ad0944f1b365c2761c72ab583bf26ed4bb78907f5ee34d4405b68286c3490f5207cd2c845bff5850701035fdda183ca7221a69ca5322b9a09710aa4ab3c044bce2a5a26d7940f0229c4c385944d78eda90ebb3a239cfa53e68a2922c53362187f8be03dc7cc4f35d9b7e7415782e9a3c19d0712ef0e84ae2b8177fad3dbe10f90dd04e06e7ded91f32a89229860666e98cc04a67f891c73f447e8c2baaebaaa931b62f3504b1b8fa0dc9d8cb2a03dc1c301ffe005eb3411a17cb3b7c8bcee36fc99ae04e4b4bdaf5acbc36528a390bffd5a6d3df9e6ba129c32da0dd2a50459b39efb1f5834742aeca41f7bb3250b1e3d63690315cddb189ef167af3f4caf46f3fe062b40f06ce79669b18e9cee5b39dee9552b4f3d152b2683f5096c1ebd2215e75782fb5f81dbc0e0c11e783ea7252320d603578421e37c6caa44e7540740abef9c3ac40ec0273add99d416ec7f4d14342ff6114adbab28f97130452d7116d447e605fdf1c7364a7506fc852140ca097b62b798dcab2788744e702e3bc62ff3267ef35efa79e5e5e5aab58a8605d5621089f88983b8abf015e0d2a378b15f646de816d47280e47828dcee8a6ddeb7886c45130053b06c9709a9648fd5aba9290985537b5924f6193a67de30697a1e590442f771e35f522c5ef21354436fa3d54998840b16063723cd8a0af164efc4f985df2427534b56a2192c751e508bf8e64653c2b3c2ab0498469e4fb81342ee82209d8df4394bb1d5051dd4821baa33cf37fc86c6654f834624c89effea56fabd0e7e088812c82231be787bc7eb14ab942e509102eab32e00e1d890f386fcf74fd219e27f85d4cdfd368ae94435ebdf376f2025234d6e6eba4a2484360fa124affc0ad60099d1c56b9d5fb3c3e0a5ba04f8cf90f983416f468214cbe265245920622985020352b535d1cfeb57005d35c6e1115ae880ad7bbfc36fee7d56b7307eb68b8af57e1d948a7847c88dbeb7b50007ff7f2d36dfebdbc4ac59f8dfce389cb7405b73afa796a29f3b2befaab313b85780a04bbd6083e0722672c48526d358f31daa924db9d67b633fa1e1ff8770ac32a424a9d33c6b6b3f5340a937712494168b9e394f94ac136d84f94af961157a1255bda22b3219e5f3a8a570c6e0749d1a1deb6b79d872c98ae492af4fcf97ce69aa74888950e4f300dd0363171df8a621ae22ff3a0e9c8fb87f8e8bf0930262f8b99ed53aacc489d52ca9cdafa0aaf1b98263d6516882b16178e719d520f4517fb63bbe2949898d260a9dfaade6a5672f96bdfe73fc43c1a41dc66701d9cf751ef137a8456a7d55de4f70d61032074da8d04d4221cbac70729dedf11135861c03b81db51778afeb4548686a113eccf71da3d75bdcbf719c2e77f9465e160717e905275073d78a77dfc1a16a4577f69af27081555168d176cd89ff834e6e006cf3ca6c27ebf34b28fc5360e811fc80d3ca39b2f4e107b47256ca145f32ab14f9b4c8ba2414df283d4a012fe204f2733be2358694a57f7750f8075e973dacb63c14d98fa162ecedca06b5316e0c707672c979fe859f84e2b9c0a87792816af313798d4b2c9228b49b88066fc5980044415c8948e86a9ba2a4d22fbb58d4e42048701e0e9e71a517d2f6ce5826daabd9733a51c88537ab749d668dc471ee68d70fc6e0250fbfe880e0de241eb1e30a3129671701c622a5bb1d70a06c742d49c86447cdcda19b8c0695e564a39fa6145eb7f15576b0af6e3936f1045e59b6bf32d77fea8030f375023892c571ff475f8a653c9e1f93233763b12fa071c69e14ac5014fc7737f9c8e366e6544063de63a154f7ba38a013d81b5bcdde3ff400337906cee52bb826ea5169b7667f64429c5210aee2749991fc3f7a62616af6ffb8fce6bb0aa1fd95b48861886ed7c0a9a7c0cadac9c2eebaa1f725d18be2089188e7599228f8da9e2560d16d5485ef3af7fe5833167f0bdf338595f138b0f96b6e943e2a44718df00cba677037e6c2240db9eca8cd9c49c09b812e9d348e846adefbc0e36dbc6503fb08d45ead0ff2b466c97df4401c619e4d1c60f56fe002b91529c0883cf386aca0a9821903475c44a48c67f606e51a52efcaa739d6150b069b17d0b2cea37a58529d7da75655a7ebcdeb3db50b6bc77c0571202f77cb825d8679774b9c9c7c0889aeb9693adc0e6b5d72123b57383430a21ac0516fcc8c20e3139d77e2b46dc7164231bd26babf611eb1ce48c355b26af56e3a5499d4387ea08f444352e8c72e13a931a38bbecca4b2fc23e3dbbe0bb5678d16de195f2cc250e1429538c96263eb11104a4ca0190ae23f10ccb5cbd8b265263af6ffca79138f29c88c6e5c246973fadfa82a77303dc540d1a643f151f890c29008d1e11cad1949114d9c584e218b0f215b8300cfc239a8a39f70352802639b2e3cd9283196df88b8cf2f78ff28a79d2407d5cdf6f080c13741c49feb3c7db5efec4832b0ca0176729f28f72746e780ed7c9f72deedbd07e1dca4748a6f3b8b728c7ee8a10dfb8611a265ec721f887634b470a65b5c825f12637c843eda2d07272a6b280ba4fd84ecdc1d0dcf5b002d2be900d35dcf5a251a5b4b10190f45b03b35ee65b3b5afba2311875ad1fafb2a8a867b6be46f955c698ac8085ec0e5b56cf53d66db3fb34a2d950ee4d3693503e60d49dde79a4d761b5c2333fe636e86ede9610700824955351b73936b725b5862260cfc41fcc7d3ceff7c901db6e2e716ee903e96d0bcf09e2f1cc1697e2740a3690986ce120aa842f36b708d035055e7d1cdab5a3ced3bcb05a9fa3bbc8870722b45dfbe32f119e7c3b3c2643fd375919301ca91524338c079aaf513d2969b6c3dadcef02ffee70afd5a73c48a90a69320b693e4cea37204df798f901f30523862027bb3fcf37df34e1edbc697db9cfd4e5849c32944ac6132fdb818a3863ad45b063d478dbdcdc8a1adee5268c69f513717f865ba9c205e9eb8afd5c1349fecfc4b2e8358f85fdeda7f5cf052d592c73e200bbbd79956766952735a4512cf0221e1ffaa871fb748f0677850b12ab63b5311561ea8bbf4ac8a0dd1b753d8331904b998ad064c6d9758ac506550744bc9916b385e6b934b22035db667a15f7448c06b86985ed25a5b20f4bbbdbd9c707c04be576d77ecf8925e860405ecaef85582343182561be4e9881f551d6f8ffe9cdf714ad009bff16faed065faa0f501407288db98f03498d90e4a6c740913028a2d0fda0660c7c015b89bae4a90254d19ac8cdd21452afe71adee0fef12309dbcf1edf523a9d88960522f3ed5a52948f8e3a85bfcef186696a6f389265d6436d81019c8c572e48bfac72db6af29e389167440dfcc4e7ae5e29e8786383c3d287ee73722d85c165c4335320c36f7306a34ed051f9e535c6ed23bd79d089df8144fe75f6ec8f3defbdc84acb6f50a5b2ea84d8d2e41a30d809512b96488e3bfbb6996a24be0f6f8fe28c0d5dfcd711f8994f902745bd94594f3446d6f19c75eb01d16415557321d134695deb52a91dad6587c5e02b86f40cf2f390b1846028555c848d2dbd7cff1d35070dab61f83ddc6642e9101590ee48bd458e91d74d982368e8768cadd887b6b0eeacf67cb49126755740cc115d4bc12b887ea09f9f3ac37b582c5beb8e35676bb27246b22eec81d7ea8ed2e8ab1eb498e195d7110029b562b63208cbda170b26a17602d054b95c752167303b7799d4ba9cc90e7813826704e5c18ab0f60551314660d241fb81d95ea10cb02deee80ae98e7c8a5ea51a76fbc9277f4d353fa9e1a14e08c2eb206513acf88482420d0ab949cca6901f35342eb22d768468f8d1463feb4393d972249b8d6f622cc572d97faedd610f28ec35fc3b1caf23177529b3d44b71488991f728ebf8809ba5b02fb4b3035cbf20e96dd5e110c9e1c39b297ca3aa8aa6afeeef7a6a48ad37508ba8108cc78165da4378dc342fc87e5d8d46d565ba06b6c8459eadf2541ede136e6320f078d9dcbba00e60db8b5ce6e90a096ef6a13b6c5f5d5694e82a2591ac761236111cfae83d3529114531ab5294ab231796a56d6d535ea719a782a5e10ff7ee74285891684ffa54336b2955a3b1d96cc6fac3213cb2ae1bcc79d33b6d3dfb865ac5ae02ee9b8599cc815e477be7bbf77de296c74bbc26e5e15ac5ab2b1c5717a64b4796ddc5d19d4312c7ad32210d7226ef14b1c3d94d806e8958950ebca0f268baedbcf1ff780426580da0cc2353f2e5cc601ab155e94fedf605d37fbb43fe028a606ffeeb19a14e6669f76810437512836b48c20d34ed0476dca351a29182b0d410a610673b2cedca8dcbb48b16609871404791f6d48018ba1b426eb539bb6c008ffdba8fd44b1d3847417a64a8b146d6008dc65f0e9a0421186ee3b3c877df4a08d2eaba86b61fd945c8bf601fd7fadfd1b0139601cda998be65bfe7011ba44da059b6a68b85672759c7b9ca5869db5127bf80acd6791933d86a7c4d315775d0245d209d5421bf886ab79b3b705a2ed30278ba98d5bbb0fb6caf1accd20a81a17261a561aa1747634c8eb9cba9a6171b871fc9639ade07755f2c9cafdc899a9e7be5f34ad3570ea8c4e4169dbf80264c6c6a68b00091e3fa91dd2a333760e6152fe38611b1063631b056f5c3f360f483c3a0629fa994ff77acf0336eadb46352795a1b50bcc993b8d99b178bad71c619fab3bb1dc5285c7baac40d63db299c416dd876f7fae7f29fb806b58886ab0fdc649e12052d46e862ee737451281ead4fd398dd75bbcd8f0aac7cbf184fb981cce9fbf409344f3a21acdce3aa0320e694303247b01309ea1e1beadf0fc1381f8f6f618bc66b8fa6c8431ad9ac426b5d08783ecf31f248e45c28780b917fb37ddfc8d2fa8f69432b161b9b94c2976672bfe057e91c69508e1882188a7e477c54df67f9336c838301fd4503d98895468bdb1d04ceb383fa4b46af25374cebce6f214ae10c0df56289f91b6c68c486c9d03bf546a16068c60e43297cb0c0ddfa272c2e0a15eed90e0b3e3eef7488aca5d74d79cc6f8d0e3284b6e4a41417a999d28f5828f63de84757a87ac7d4806b33a3e1f3f83f77022af87dbf51f7b487d7034ffc768aa360572d2f31d1d09a05c30b0d3e60fec04c77db21f56dd5473c30047e25d6b2ed93b40995c9a86bd4048e641565ef2f88122f00308b844e8be8b1ea3a134ba23cff9c3e683cea417ad4f3c7adf2202aad5c9608b728817f3eb32ecea114461a7f25831298580772c6a26fc1f4bf8470ac7ed2693d61283f39f278a70067a5196dab4fb9654ec7a146c88a0b4cb1934dd8055e54ac09341d983078ff7ac4dae24886a544e232d7f45bb8914afa2e897ec0dd5ca493a272bfa78361b9b393ed337b2e4723a2d1a910046fd6bda76dc4f5813f792ba4c565b5d5f8c108af98e72dea24606852b2da3cd2f8ae33db66e45f8dcd98d20fcebd4f6823dfc35cb5b84960b21fd952770312557f6fc1207ed620b2fb0b74b136bf86a9ae5a70af9ea956a6c408d1ab0805cf92b95e9c790882bbda975269123eb8add713a4e1398d95b830a2a5a73c678b834a0fec30d0e152c14bca9133d7b67941641f21fc84e283b198d31557e806f06611b4e22d3add478381e2e306bd089fb4f6e9d12125d667b98ed31a9fd410d8cf103975c9af922cb6efd346e8d3e00645d7c60cf86eeddebbf28dce3262feb25e9d61a1bdb52e5766756a744e2a946ffbc3d8e9ea646bb1894560cb119b1c23093a97c27f9b21dc80253c0fbcfff42ed22166adf474030cc340e4416f30ac18dfae695935c16b3524bd99d4b2c6dbd5e2b85d449d69e73f209d5089186c4a72eeab7f821d7fa3a3434af0d2f8787156a4e84e1d01a554afa604bb155d52c55f06f1a40725ec05727d60e3c4441996e88ec6c31ff1646fdc4fa1b5a30a362be9ed22760d94d7d7ef1a85865ebf2e7f1c611ae822c95c1e68cb59df4d99fde8615a2bdc80059ebd32dd8513541a7e634133d090796a505d659e043b70db0478abccbc6943037c147060be1c55eac8483499b4574df061f4ee403ef6a4351bfee12ec931f44c2b4950c11bbbf656c9bfc798475bb465b94ce2abeb388f4a0c4e71f741599b94fe42185e5170ddf49e1226dfd5684b7007f34c10d34d58b4d87d6f41f880dba9ff422f41eb24b832c8466ae9799ff99567acaf09f120ba8888694cf966f5fd0ec7325a9ff838d4b4a9bad40ed63591c1b83f1f9dc3cd1d54d3d0ee40fa98223ac31a866da2c0776b1e5e9b95181c69047338de55d33b589bd344295fdbd16d41690d7af0c82477d7bd39aa1a27c0a028d390dcf1858b20619bf674f99f5632fb94485f6b3a1172ca621c2e1a13eda70ebe64a41ef5c9834a9d7d3d2e091326116bcfeff2905e48c24715289211e67c286aa95083bc862978d9c5d73c89e4997e875b865e5a2c27bd477fcaa733e698d42e818189f5002bc40a737931ea7b90b494756c6843b638028f0ed01352ce60774d778b7051734128c67be8175f0886d4f25701215503f8d22a6595303e095913a63359c1baa574ac53c34cf279f3c5a660f97fcdece5190e2682f057c0b336aefccfa0f296584994dcda9105b2c6a139bb6fc3243e3acf72bf7d035b4ad7ac63949f033f8e51c0f8ca02ec9a6b271208469e50abf67c29b98e60534576762cc0dcc99674870f9fc8758a6a4fd2623412109f5e9669e5ad266d937c24b50ef1f3734090aa5a6c89e9f03affa02becdac81e317475dcf57641d5f46ed7e484ebc1612b8bc7670d8b37e78a84cbf09de15a9a8400cb8466418cbcba13bee2bfa0ea0fc967b59fc802bc948a4b5491addf2f55cee45b6628922109fa1eb2c607f07136773174b7c1d5271d9433fba8b3e176474d1c51a23a12946028ca1e426aa8d8c9b65faf6181368ed0c655ef6c3e698083e2482b9a4e0ac4b039bbde2d90c20971cc2c2553bdb785467a62e9c60f59d22293bddf58ef77e965377c2918d9d461de8a964f5bb307963458a6c8ed6f20e9dcb1eb05ffe7b6a72d8b18d81ba4560923878f8a40d92ac04bf20aec490ad0bd0aabde4ecad620ec581f19ee4f7fb950494b8be9d35db78b7aba6485b1480f0b468ac87feef89d46b65cd455d310642f5ada47c44c82203116994496f5e1b0cf550214bcfab2650c92133772db2c107f26c347e7b62f9c46ac66bcab1b0fa8c5435945da3dfbdcfb5bd30d821edb9d7004e1ac3f5eba939ede0259cd22d126928cb7998976c031c964958bf52adba999796faa0c73f4825a50b7c5d6e337a7472be04db9a5cdc86f57a295e463029fea52f03f93c7942c6489c8887a185c1fe47025d49a36a7f5eeeedd6fbe463d23ebeb1085ecbdf121cbc220c5b2e46b43dceac7207566da4056c601eb8b068f5ea1f90d522921d907fc5675ffa8b934973bca1750622cc1d646941b3f9ea4ad640339cdc223ed51dd2f1b13dc6809123cdb1594265e140123ebcd863bd043d559d786f6448685a242ecc0cf8c6dced892f57665a1a541e44ee3472f7fde3c46879ad2c4ac7fbae6ebd8da615902eb483b21cb0996fd408dc193066e277f461d0e7a8b4f42534223a6eff42bec6d6325c77fe8be85c84f83a1ca1d3040a4daedd2a8e500f2ee5140d5bf9234a949136d9aa0d8e9f50dcb98ef3edf460d97a47c8fa381baf2ce8e27f64c3a3571fcdca17eb31a5248d99d2881ac12db7cb6de48b81d69233ee167e0b420a5c55a69fdb9d0d2f4ef59fe7e8a1d0372c0112c5a9c68929b2c8858a22753ee92666c013632b36bca4cc36f41e00e20fc46772062a930965642850131ab1c32af8c2a41c745a1e498fd6de015ecf266b231b24cad2e176fe79c7ec617d5b234219248583c00ad67e84c95aa6c94dcf9f5990b6c319c411f0c52146764f7ad102c8498db9c2420cff8f60a8c7332c0c66535b5697b212dd488fc31420feb82eaaea0c24bcbeda69cc833c30a949966cfdd008206dc2899713eb5cf01ccbc63a371bb949355e39d05637c48891fbf4729650a55cb704b3527ce40378c32253c982b034b5fd152d659e45a0adba232212b441988e5ec7300ff9c3bc1fb616f9edbfd85ee5c88550d64c869ca329d0c7e0ee1519e6d5035e05665b86dbfc8d31e85c37faa5ebab436308e60cc1089d14d9e11c391caeba763ffe768d8d0d6599bfbffdcdc7181dd16eb6872fff5d1fb13718b04a9cfdb44d0d0e47ebd9526e64cec7efc43af7fba92e4cb050d61f307774cd6aa235b2549aa43d89b79ed63fd53190b4c2672f0c78bbe8ba65ca5ea26059f2f958a7862f79326299b0423d644c3bbc81e32fd14767e7a57cef4accdcdab2454f79040685fc8d1b1857c5f8865b3ffe29aba3ad6b5e2ce47674c93ae6d8f6fc07d88e431c00d477ea54ebfecc9c70daba1a2f4351fc5b9dec2ba8bc11632a1a00f74c6ecdd74f1af064028c4444c4092495484b053c482b63167dcdcfb765e51542c5b69e37ab33952130bc4f80089d3b939d0b9d085adbc9d2b60a86d91a1a835d9550c69b8c715202f56b4d43107ca357314177f6ee5bff28fb758a793cd14003a3bba6778e8982846404a928daabf908a62d8f4a2a19cdd5d13bdcc00a0d161621804b041c87e0eba81cc8d51daf7acec6768f21bcfcf02b6df6890755c29fba43cead2af41322a98597c8b0ed7b64e5f654f5fd987f899a702c7a0989c4a2d9f7754ce580d7d070a84f0881037b15f9196cd36d543676c60f93a85c05412e9b05b9759777a6b72992d2d8a50759abfb3b720cc6fb527b58cd1cb710f5a5b4d869e35e976ba41a8e9a7ee46bc06264acf86991e21f32a38431587481b3560a9a6390294ad1290340e7af42e6eb9c8dbb9ff978b41b5fc918fa354b40e037e81ec4dc1d058f5fe40e6cd5b4387fd5a557d7dd646f6d08f5d49fdee6a65670e4bab9c67580bd857a30823f374c10009aaee0fa6f8215ff32a9fccbfe52ca67c28e45466703f0d9c79badd8b06528429506e14dfc2633e7f50686f35826bbac5f5246a12d4712866f84bd82cfc481473fe1bff02bdb24e747436d366efca367c006a2812bb9a571ca553a80d788b62793fc3791207902fd40b94006f41c4bdc2413e50cc46cf527145cfcf864a641a52f0c416a8acca15ff11160ae1f3367678f4d3f3d2720983743e4c11a83b6a92e9743d3171c1bddca7af9d276869785679cabc9d9710f1f2287dbec42efb74d9b51543242ab0c14daf88004fd1cb1b6e96f9272a173fdd691d7b13d382c9f87ff8da1d52ad62c6e8e7c9074058923d3e5c7ba3240b462d44aceb10d561b1a51552b9f3fcf08e01c29237bf55d7c8342459b36ae72179749434375e7e26ed8d038b2e943735a4a9f09f344fa64bd775acbc52777de485074f07d9bc9ee1ceaba667a5b35b9da827758e789ff744d8cd4187bfd43d2efdf0391aec25ad4771a185853393f4077ce099bcf0fdc2d213b8caf9c9576ec15379f9be3565863dca2bb329538f6abeee9e8a9cfa5f23701160aa3d1e6c725aa76a2e5da708f1689edd1b8422091fa9bdcacfe8d4ada1611a2b3fb27e122f4f723f5bc55045d6b700e3211d8705ab0e8fdcec7447e9bf677e169660ff7dd0a783b9b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
