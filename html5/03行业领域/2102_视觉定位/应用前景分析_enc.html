<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68222ae0cc8a5c8594df7683bb509369c9fb0f5e8b5e22eedea09e38198b62c955a98032cc88f224dccc8f6e7a5ab467140ca575bcb7a1b76d8c7808eadfc6ac6cd7e595e088f6176071762414012aa322ccc7afb02ddc7d2a8d77834f902aedf4bb45498887779642faaeeff77d86a5fd97b8f7d9b80b7eabe326dd7018a4ad50b2ce5cc7319f13fc98959dd7d83e06515787991ca44fe334b0ff3e6c8c9035782027705e1946372f0d92be9be11263abb713826cb1c397134fea9fa300f0e11863564eb6cf1a78c73320df9efda00c200a91ee070334512c48189a8b5c13176f02a1d94618f166fbc4f360e69f203709ac696b2300d49fb79c80c3f7786d9d6a0a254ffaae70d95fadac79de61e99ce9992a17e19a33745cc19ad222b4771b3d818225259f1f301e5f2f61f153a72518feff518e12bfc4b8e40ded902b09d82d2ce14c548684a16046b4de3c508dd0e5d212a89d87e07f7abc16292f847f8a36a2d29f8871c27135e932c01535c59e360e10f25d677f7d448303858a7347443e55464a14b5387c6fb665f25d777d34fdb87e88c494252ffdb1b36c31f057f3343253b4eef7aad3cfe6d39eba4447f111d306e6782d175351c17201316e61790b9dc84de6266316f9d326245955044abe4bba5d9baba577b0fc0e983574a833faf55b76a0855ca32089b17c0347c20684162c4df268531056b088270d0fddaf31cb731b7425d892808976cb36186615cf02c07b8e0afceaae16d37472f861f0fee3887efaf7e9fb612ca6fb5712904a7c407148f3673b93251c0887e1b922bd0899257976f17384de099b4853f468b4cabc560c674b79bfb19dbccbbeaf7dc346583333a11fad098c72ecc7583275e3cc2b13ea4f8b54ef94d321740440ec63a4816a8246dd18f303a53eb2d20ed913544d55ce0585da4b723cf78a205fc0ec477af0aaaa12d798bbf833651ee0efb212b788b7bd13d7429fb6fa3a42b6af1b4e44445a64f8a4a5c0bddaa42dee2ef9624895cb90f4789010b3cb83fc6bc23f91d4d56e3d8d96581c19a8852fad0d270e21aa5b50e347ef59da09ad552cfa23e0dc1f0263c70fcfdfb479e207b3370f7ca6b1d1789bec19c7ebcb7697a3d9e3dc0607aaf0fbd5cd8443d30756dcff31886d89bf413fd52f309eba4df069eadf159d65015831700bd0b2e376e15f2356df5a1add84f0271b64ee5ff2b0e31284fda6054258050491321a4a94ceebcc7b0b89232a1a3940831d117d45ed0b89cd823c808676d1b10d28b4333c1b099a3f53fc8e08b914ccdfe08f33e3473a63503fd0aadbe4732a432b38ca0e0e0f94ee2a0fa01a122b4385c32d5cb111af1a08f5298ffcb35e2a4d8f113f76b5c85b4618dff9de9a22e876e5f2c5b449378d40ca8532e0ad25f745b6383b22e4e30da1606649cec7f6050f4a1b4f0b1cce7771501f6590d72b86862a9b6e355ed709036e5b913b53767a6d0469087f2d47a57aeb4cf4bd79225d88a730696b86a584891515fb225b7acf68983dd84cc6fe1eed0a6eef2f10ec8d49b3d7c7405e4c18271e577bc92d6588901303fe07538d689cadbc32175f373de59df479de5865acb47ae293337ab1e01716c60684ba3cdeade05479b709d5370f507e22da06698fd717471c50ba37c1573ecbb4f9fd2644c7a952050206e53deba6a4bebf79173517ba8049e1527e41118b965959f07cd70169fe353cad010cb1c5f190bdc2c2f19c7df2fe3c4d8071439424a58fbc427c17e26f77db33146f7988bfbadbfeb7ad582576dc784f563cc9bf3d0a443e6a2f25e5d3629b0914b6b0279ba57c993ffb6dfbf4caf70c6ea7d577bda4fdbe4df5533346afd095216849add769ab4a5d72693f6bf78f18b64cf6c401cb1d14efd5368e0dc8d73abff73ceec10b7de7b79d0eb7e48c36f3866e10a41f25027a347a1d7e40d2fcd8a64150aceea5f8b88dd5764f5b50c89054fafc26c72a66545cdac50fdfec8cf1e4e5836a6b474966f8769f0370a91337b993951865bf5bae05732dedea4e3a549924cbb7a37f6663ae3648dce02cba232a9bd25610f90bd58d28777617d224bf07fdd62936fcf436fd4fcc97c13b8c1310193fe1f1a1576a837b418e259cfdea1bb65f19ac0a2d6173c840bd50677f7dc268d6a86f20476d4c02bf636053336c6aaa1470fa599432a8c2adf08c18ab5314b03ec115f07493f9b2c98c713a4282c3f37a565696115d9b1d1b3a839cc79dce2276d09cb6f18d80ac944a48b9d1eb0d6987309ea4d148dd252855731b3ba9a5d43d92c9266546ce497c0cea57ee37dcf74291ba845600484796b6d94ada9c2d47b3092faf341988c8f4b2d50989b793f0c8724f4657a3573177c3b01ed30243e88fc3c99f11a463c90d44cd29088efca9813f8ade1bad71cd8a21718e88fd28aa598689eeda11fcaa2f716aa2638b526d3ce5027f172f36f49a261a775762a14f6580a85074c68f9d6bd997edc430cc49f95cd2d523e38a442fd25b203c0530b29fbe39058aec3134a4ad1b4e585c78f2efef4d3cb7b60adb1cd70b60415b4ee9bff0177e3f35543de8d25e5c542476088ff36cec769ae91893eb88d1af252b94232e031bb53ec60c983cd1f2d0d08473e993a5cd84fcab1e198dbfa2ae868636e9f341ff476904fe55c387b155515af7e4da9c7ce96c75ba4d4b669fb6c0e21fa2ca1e4a333ade2bcc329f70f90d0257e8c920257e4f00eabc21db2e9931321e89486e4e5652cb3c80995d40161d9a52e01134a3c5df8ffe5dfaf3ad4cecc6cac081cd7f30f25e38fcbb6b276d0502b0143004a9b05dc397b7311013dd85dd16e4fd833bace8d3245bdfa3fc0730e71ae5eb6619e2f43561a91506d720ffd4815d29a06992578f46a18a8219c9d660733b3da1a300fed4a09fda3844ecbd5c8f8ee0b686c03f5f47ae7c1fb0be40837bc884ff56fe2c437dd3cd69230965acac123f8bae0ddfc483c1532ff051885426989f1079dc6d1645cfd35ef396bbda4b04f9e27c11b26ae7b0fac44d6c70c20cd1b1d9854acac26b1e82a79d6d82090ba05d50355f258981b8ceb1afbd22a55066a4d3a179a3220200cad7faaa77510965a51d24b5fe559c4e1f7c9fac8fcf7a120a4991da93c58db28e1fa4c8d0e7b4063e103fc464d6c3ddfb8111c0ca7762a67276dee5150b433a4daaab49cae5dfdc9f30ee31285dcbc849d68f99a038688dac8b86b7ca905397a20aa9fc09514aa3b343c0b58126f89ee807fa17807b424b068daac3fd5a8ba8b8dd7b028e1df5c4e4c560e7d8e95c80d98d762fe5980a79c1b71963e53202a3629320a51f52bee5cf484302a5a3c457e8e16a13d7ad966d4ca4fbabc8c51c60ffe9b68681975cce533fbf530f171abb033303f6c26391e93a38ca2bb5b5a287adf2e205c090c666a43f3b53918b6033d75dd4d3f748de189768e40988d69fd73835f2150d87e52014ce2cc5c3e605a951166ca0cbc25d60678902074113f21fdab9b03e3fcf6fe8135e97d27be3e933447ec08faaa4e4fae9e0ae9e72b810afd226f3d5e65fbc7469266d1fc2a9ad943c92cd7c8e482881c1329ae73f14bfaae024e93d0dae428dd59753594c6305d93c60710f1c55bc5160a9baa88af6422634026aba7c9e7a45b528ae0f99bf32114871000a0d91827a6ed0eef7a8a406f14667b7af042a393ad9a3c430e32ee0fbf4a652a944acd8244ce899cb60d2a8a5c69963d5e97c5e25a1414b16a221a0ac70c1450a64897c824535b799b1db42bfc05548284f05126ce3335e2b6800465d3b559d48128ec607b17b1e375f6da258e4ba17e4e68c8c575f6bec7252bf92b8a1053672b6d4d28dcd551df16fe84c396ddf212c55cd422228cd2bd33863b725a81599f360cc4b8f911559350594f9891df733d21a6d3792d930e44c844fe7130030f6df244b21179f9c8312f86f9babe060d516d93e9f29523411d31bc50c222299850676d3edf85cdc85efcf18ee46d8f7f4e3e7f3de017b40915eef5302be795aaa832c4d86e414422019d0dfcb16c193e388269e6096872efe852ed6118a0ebcf0159a1568a7fea92004506bd5a4e23630bee3c1251944bf91580293f69986876d48aa304ca6e85b04b9591a6997bc891c898178a885043c2f09ff71b743241fe79657524ca00ae61793910e0f518b8f9233d32b771927248ee074361efdf72c10b748e4e95db81f63d2b2ffeeb67b4af601b043702e3f63fe6a4dffaeab0fb96afd35f182695067bb0bcabcaadf49eb3c6b0e7097b673a2364bfc5bdbe1c11089299e6daf734ef0dd74af93a458cacf5ad654b2465f092b08a9a958d0a394bf662dbe3632905fa2b9ead0b7ab2a31e7f8e7696a782b8f5e4f8969da0c7fd680588519ebb5395bffd922541e9c5c0c346941ec9cc881f0061e8af95a586632f33d2dc74ab15202307a48adf9107015ce35eb6062b7dfb0b006ad07e1006a467cfb6fbb6e2c99e665821e9f3952f6fa35eb01379c3b997c76bdf3695440982fa632451e1287bf1b8059e189b763b34c098b2bafaae15d9cd253aff1ae39d9462653e8be3ef6fa75560c66b3c0291a75619451d6f1a89c4db34f27a414c1583044479ad6085c87a3167b89656f21708e59647694cc98e32d4420b04926769fed84ff65877ba95db18abee75c5f0fe731f5234b5069471ca467d01a1b871b821c094882e11c3c7bae968fe13e5b1cea971882ff89f64657732fb44b1b2aea3a90dae94692de8f57b7fc53d2bf91b2e4cbeb88c8aab4f177e05e26f18f2b5fed18b4ad5407205761ae9ef4c07ee8e7f3e5d30ae84b48858243a7a1cab2fc652dc2ea1babedaaf215139049f34fdb7a5f807ed7c8082750970eee16fcf060cb83ab019c8ef257790865a103ac13a880f1381bfc7d479e5e215b54ecfa1344620ff2c1a8cb195296dc29ff25e26132e2a7bb0ec9bac888860da6027157b28a53b778406a51448d4f0c32a66f92c0baad0c55cf76212d60d1c535944edc8a3064420a5d163a0c70085329d6cf9e5d6ed97934c3f6d06c2083fd14ce2da862ed508fde6317e7930945114c1de0ad0f816eff7f517dbfb49b427200090d398555a083877e9a824502fb4c48c002e641519ed9802b4e63df99d396519aaec456b82fd132602d0862aa1f84682706dee730cd36b8d7f2c92c2cbd3e227caddc695c0cbcbbac72baa5a6cf1c9729e43369bf408fdfd5e956fbc3cf25d3b154f84d7003646c5869b7ed97c7c312f509943909299558bb1481b26df91d2a8e963518f2ecaab5f839941935cb8e009123a7ff3fc21d19a30db006a7c16912fa60ea9e743ab85be501dafb0777a2572bb7576499cab5fff1bdaf1c706f0d61bb7595c3b58025222d2c78fe2c495632c57ae9f57cfbe65fda9a9946c1708bd33ff6d3dc9176473f02ea6188a2f7d3c08bc55ce835c3d81161142df4f70b79e2df4be99725aefe68a4423d9cad69590c4b7674578e080349cbd15a6285b9f4f2d9095a1690f0a1c35b61b3751678c8645cdc3b6ec04ee605b0bf87a751bf0df4076e68716deeef9e16ef6effc4c6548fcef4d785b0f94cd47e615d16d01a56cc6bca899a1dd16876ebfb1d35099de2b48644da877ea146d69e10d9e75b60dd6ceaa0f9deff008b9557d5e0dece8bba6029eb89bc45d1f776809417ee5532f78a22fba3424221733736c74b0b2a4584c70ff0e848010fe89442c51cae4a09db6b9f85cea40e06568322ab6b871537e507b01afef7aceb99f3d20e35af8cd3cffc799c4d343b72c5735b81f321c22d9516a8ebe9eef3614b745d03abebaec4c83dca275585bb28de5d81abce0d44c3a831c4fc074ff0052c1acf7378a5f92176dceb32c50753ca9c3c5275e8d05fce289ce68320a5f1758a4ed194348a34ea4f47db260f152ef8127a26073adf87e092e9d87d70711574722c05a9d74f0c9be012f8d59ac00d9c86ce3d8d2fa6f53f9f9483247f27e8400ddc2411ab4019934febe9ac119c9e63557709931b7e20dfce1d5ea7886a4de1b4b9e7777850a7c940cc6f60e36eab2c95fb8d4adf9df4395df95ea484616853b9e57a38d13f835f6cd2eb2f7cef6d577c073922c8b8a86a10cfef36d5fdc980351b508c9f535c1e4a0059eb213152d52f1d3b9cbcad8ce795a8374d1ece783e59e717fbf5510e355db6e9d51aee76e3a6dabf173fe3f0dcf6e1d21c6c9a1929859222fceb176704de40a3ede47f8ea71b0bc50cf2d2f8739b18422adf8325680263cc5912f418976f363cd27f17c58fb04db0516d98e0589b97a1e32b4bc940c69cc98c574b1e51534b1ed1bb68951682ad6e7daaca45eee924e6bdce2d3f9d91bc66c298cb984432aa68f532e957d0be31e3d76988e7aa314076a2960bd06d9590055d6835ef669635d07b4c6f3d9f934ea3bf5b74e06c1b1a0bf1fbf6ccb757145b0f4d864744d42c56ad0d928f3c46f3e3fab3e23fb6415b4f089ffb4580713fd128d01d5fcebbb78b95b29623a77276d2c0bdd73fb9a4cf4a8863503dabbd1ef865c24ac3fd12163c982b903dc5bba7d89d1b85f48bf0b5ae5a1f39b80072d8b80c4f91bf5dd1f34b2c9d4d83634117a2d7280829310c79a178496df8b4df7fdc275f5a8c23296c9bf6fc9c75cdcc9df880b5762f331d3afe34113643415ac50cb064b40e513affad6eced5b6e5aca5df626cbd950730cdd492eac263af44f8a0adfee7cd6ebf8022280cfb3b5e8ddbce5063dfe4e41bf7cafa996187cfed8c0b1253089103adba86970bd73ef68ff151b625086f62405351cde5b2299f513a7aa1cfa6a8ca69e91a692f059f27d92ef8b4aecc377d1d7e3bd91cd813bb784a2904d57efc14183a0216d43c4e9b971a8b2fa0f1b7a168e413318e8894272f80764c17068a9f584376903c4fbf69b8f45e88d7ac6afacd0ae0e579b42ba2937d3d0f44c58cea6858a7417415ad0bdc6c831463ecbaf8fb1f16c1a4fbdc5eca7fb935ddefc894449af0f2594b0021a503c5ae0351bf0761ffc99ff9da026e911727e8dc22dc77516fee7945d67e8f168bc64ca057970287db6f37c14ddd56c572cfdba4277d64c23f3165d0c575872f48aba6ff3e1ea912cf971e683a7cd26d72009f2b6b1319ff77bffc677051062111933050799f1460fb40d919f3768122079853e84f02daee083579a52299ecbe165eb96c87537dd2d0e09712660d203cb851f98873913a3d8d62ca643d18700bd253e4ef24fff3bf511b4fafa649c6f6f99b67b5bea39f147a085d3b8e691af4b1977d9bfbf28f8b9a65fdf30ebbe2f6eae81f78286f93add4196a308eb59cfdffa62167beeb6d4a61ef81b8dec2f90882154afb704b68f6d00967970258f5b9b4e6fbe8b7af09f7f00e17a385597f14785ca17031ec98fba0cba382fd9622f2ec405b029c4fd39b02958d7be72bffcbc6785e805e14d36527b3997486e19d0e5f982eb8f5bb7336d60dc4ea68434eaa872dc0af1c32b5dfbb0a8de3c4227a63e6534a686d833cc358b3f2a14efaf5b1313ec2d20c6f12dda34769e5d170a50b1e605fc34caf06026598576572b3165c5c014d7801acc893ceb2f8006bc49ee38fbbe60bdb5cade725d6ac81c9c2397bdcc0796fe0c8094485dfa643bc796e9fe97379315d2ec6f19b917c98c5d6602306532b68834d0ab233a43b2fde1bb4ee0bba80a78c5ce90d800a358393542757aedd08412c67f943f728678a54c1024caa9f2c6eaae3eb058aca2be9b099f93e6e223f3b9fe7ff10fcb6222af8316a22503559e027c41e560875fd4e4e5115fcab5269131ff3896299ce9105169895feac3c74ae6c34551179f124ccb877e2a15d23ace03b14c070404eab5e8385e00e63f8151e7bb73dcaf362c9e1dc012383ce9cd81de24c03ab4f4fd4f80514d5538774a747c3e93fee1f05eea3dc5e83190b3f31a3e9b0b7d8d5b61091c9e69f84f3507345caaf3cd9d633a641a8f5e087950f5c881053f5b4b030b52dbd29090e6d203c43e9c093a0de9f130627b243857581f4bb695c6b634eb696a23b3fa8c26b3b535425a6bb7db08d607860b0fbed5865258d635c2eaf361a9003012d69b97ce9715897303eed4933ed6d31774ea8f986598e87f92d5715b9a92b7b3fe43517ec28883e0b1af7a7eeda74ca17503426466d8ee13f13fc73d41cd255d23f3bb1059659dc30ad62adc162b65f8b1ea3ed4aea2e4976209e9e5e87c7b5241545ca08ee46f5a6984881b26bc2abab93f7a07128ca86540ec2dc824a22755325a78a13eb3aaa211b5f8854d5aa2169d2847cc8280aec009823f96d2c199c3fd65318470d085c01a3eb066786acd650854bba55580290ea96ae8f6006ff403e8b13bb0062b7d52d70f74d63ba279e143ff0f29368179f4ee74f9f7c1d17db31a584d8a3de65c28d14ed454f0af1d7168c9c3cb5e36035697521e852d678ca59a3bcce2da6bab81b49924a05883668a65b9b9a6fd9b955b53252e84ec1a6e69d96cea6610c11d00967c38a078e39019c034750d048f75e6f60c8dad49b4fd3aaab499d3d3328ebf97a41a71606bf7b1cda259c2fe80e9aa8e1d7df99a1f299ce66e2a5de72a72ccdcb9b8b2f8cfe2aff78cf7c1345b40bf639308d5528d07173f3640c2e3b32ab62d1d99316242ac601fa97815be46c285c50ce53b1c6f969eb5c5ce1086e0e46a102c5045e4abbd6479cf8b60209e11ffb4770a8a148c24f992d60a17196c3352694f278795c5716582c9bb94cc52f716a41539a8f8363a74a6d1399567ac5566f8c536cc5d32a1739f9510c044cb8e57ceece7859cca87f3cd5ccfc8a9e51152481c6acd5efcd70d7b651148bbfc826efca5330aece6aef74c2567861f95d12cf8a4ae344b7464c46741372a5f4780bdca81f3c390ce4a83626de64d0f5fffa2217d014f96c62f9832c85c1bb0bbb18c390de6e3a83c1a6444d0c736f2c32e846ccae8694e1dbc5d15c455ca7984c1b24a59f35cb8acbfccfd1e21c2c6c18c69beb9e4355844c144eaea1569dc2478549547463482d25eba6634b9605794d59a4ef77f2d4aba40e903770ac1e622d1a4bd0fbdfdeda72d90b674a758b8f3a93d3c491ef36cd013625a64ba542c575de069f168246be2c7783580ec452fdaa5027d63eac9e4b4ba7dd9f781a6152f989f07a35bd0b1f8dc8242b3cb56b14bc7a56fc90340186ee71e53bb4fbad455eb458a335a8be7f4e5a77446b2a5e2729d014fa95f61a3ae0942948e238f381268aad0701a75628dd2ea5ee0a3462aff6eba53c419cf30c1353a0fbea05bd7e5d2a628599d1a543583618afa1e8520deb6cbececdcbbe02a3e538ac2fdd61240ab259cf736b027aa17c81ffd141f4d807456e6bf8a701dabcd5967ecd232bb50f9ffbb4a3247cc89e40c4afcbbe55cf1e459e1cb55b7de237ca64d115717dd0cc58aa201c1895d3f0780038e8e0ec876cac47bf1f1ca7e8a1a9c8081720c334a11de89ab72ccb6b8c7e09a1f712c1edcdd2382f1d0508ced128f2a9f41dac70001d32e5ef8fac4fb7bbbd03da2990e64bb2ced31c3bd0747815512c2fcf45ae5128f448f9d0b3ca35115b24b53cd34ce775f244032ea726b8f26a75afc98015609cabc69758a2af32ced867a86a095ff922b427cefb6136edfa682005954b37020e5587c0a09e502440597d0ca58013eee9ea82e74d2d626d3b5a742e3f59233764e25388ff172536626c798ba6ba1a7c61c4aa349f6e5f5fc8d734c4f9e72edcc7bbf4c69f1a42ffc7af5fdff4d434e35314892899eaa6b106e9dd6f9872944e748cf74abcf6e7eca19f421503fac784a715117a7e261dbfcfc1c3e8dbbf8b873da0d51b3effe41cbe8f6bbcd642c89d8e013a30769f86ada5254df92706f86c03c3ed08ff8ee31e4b3c11ba4c6556bad1142f9303be35a3092b182e0806db7c675c4280f8de36058cc89e142074b4aafa3b62c98bcbcac12db2351c45a0144e3280416f65e57de77b5e87ae1b81e6af5540cc15da45dbc50d2f5f566e1dbea7314fdb1c94642df21f7e10396abb69aabf5d192c360d1f361d2dfa221e037b7a911c771b9bb3704330b077c1f7f331ac9e0f5152150b3fe774ae0db256b1b0751fd3a0506f4ab432295fa05757e419c667bcb91aae1611599ff2397977350731dc72af333b9524325af839f4c8a8dbc965de5aba49f22129e0706109d55868a5cfb1f019773510c7797336d213eb96600b0fb01d523094ce4b81d2c4a0dd78f0aacbe2f07d0cf5e456732cd2695e27e7c5406a8daf842c39c353cf123a33659c63627c0b15f21f22a382aaa3dd53b3e2a3908cad6c4ad414dcbd74c8459fb833f27baf50441728c81eaffb6b4363c09427422a7658c099e9a43182366794e4ae48f1982de4b2b9edbe220cd81dd9d34aed1358f8652f6892731bef16c64c2632f765bbf5777e6da36e003a5988526e8fac69de11fcd083e8c44506eb0fef223e716d60527619ed1e91335e457122de3f66844364cbbac6064efd7e5161b51da96c0b0eb41b1d6c89032d466c97ada4e35e045107835a065d189ea7741bcad5f871ab9fbe87828839d74046769cccef5d13bfcf8d6266cb624668037d3af3e506050231207c2bb7b588bb7853a775256ff01abd7075fb384f17c9e536a7c0ff43bc66ef895983a6022b3debc560ddc9dc59f14533b4ee992d2283bbe10905236d805ff98d6f8d71f3dbd22c951d624c3764298bbc43cd0b13c906ab3e94ff6eb4ee8411e2d2d72dc8d2f2b19530e92246800260911803cdc6063f46ca22b2f41394518f53d8202085011f912a673d892a2311a820772079390a3c4d704d322c9cd4ab8e3d8e7566784e7ab01eb27c73425fdf12eda20c0df4ba3459ec839f2b3d70d468d8f0e0bfb601b8b8a968b7b8cd99d0f610a3c584fd996daf93bd88fb0fba18589a7a1ab7976a01e52741d8609249102575511e5fff077e34fd834d9dbdd165e58d21ba6991808c89ef27d7a5db5e8642429a8cbbe82171146c23f159267bf48251253bbdab7b4d10204aefeac9da47edc8779e54bdd8f34a7d85854e0f20970ce10f228b1c2ec9b8580717852719fbd236b8b66c840792ef5b9ee9a1eb105377f85e0368058e15c3b4ca0ec373ae6daea1cf303ec6846273977a3d325da597ffe4fed9c289abe52d05954d383f275c59211bfb2c3c1f247463c52fe4df2e168d348b779157da7c87f81b5134318d457b8d06b32075b72cceb0975e9c1b3e98ed4dc66bd0ab3e8c447e8ef0cea46b60d38f7388508863389567f198c0392db2d3da8b43119f1d1f461fe081f07613dbfde3725a0f4152da87ce289b5cb3a651dc4d4777efa7c8dae0e894ecd67127b18e8c85708c086b3be2f0a0345709304c8d98e7a5d04639d76a28a9c05f86f525cdd5fb6a9cf60c41fe7e43dbc7099be01b6fd830050e042b4c6ca560cbdcc6e4f6d6702b63cef943d53c80979b177745a4db0612c334be1c9770e081dc43b4a5b2cd3656d3015db86b51c0df7813267897df53b1bfe67c3960157c911a24da748d787577b3f8bfbf10aea1b4a45e1f7ac7332e4dd4d6cd0854415589e0877c2b9317db7ea1043a5431ff3c7a669420032df65bed6ebae3f1b9d13bca428e06a83cfc5904c120e5ff28056c5143d8489476bb9b7cbdf794c35d4e0167f32ea995bd82b17d4a838f07dccc689f4e92a11923fa9a56843a6476b9e348f40bf03a9fdaa278249fd95f4364a2c64cc6de277c8d192779b35c54256458a62196b1cefb8049b4e44bb36ae0cfe58b593e5db5c3bf9cbd2a4054a063f4be2f6a55a1dee276b12c04be8c29c95e8016b15e4d4489ca9907403d4e2d6db153a4487ec9d14c25055344aaf7875d9d7a6bf6d4f42e67e4a73572dbf01e8773e747b1f8e90ec9750b045aa0175edce61345f6f9e6d5fcceda0bf31ffe27d8838b3128c6137aafb06695ae6cffb9c5513203a7fcb85e69e95d511955b2d6994070003846f00b3da6b84132619c2522c6b2821dfd8b69bd392067105409490a4eb24ceef4ec7214c7bc8d9027d7cf4dcec612cc5dad283a7ae58c1bfe154e2ba67593b027b0ed3e934d016cf84f3e3231d3c8bd33c29fcf482f4f08f2aa76faf0fafcd1e9e84dbd2cf0049cd018bf287933ebefb53d59b2c1fa26af053944f0afa728aa4d7e3f0ff0f13bb05d675ffbef7194d6c9e6cdf2bfc3d645e53e4dcb72c73821c7bb336037c5851ddb37694d73bea9f74dc77694d775773728d195c559454f30bee3bbbdc745d48a9b8550bcf8d426b9cdbe77ae8f5995f7cdbc25cc3a94b80aaf5e4749dadc815e7277c16bdcef45e6e4944138357642715c6339a66e93264d2a5f00f9cfca74b4f11a91728447a8e164fc44530f1a5fd43ef6db04a4526a5b728e10f9edcc8d51af097f5256946bd8647cb74b3ea5cf29542493a615c0bb6f76837bcd1af60b2f7f6a61d8f4d9a85b7bc136463897488abed2c93fca83279820d55a8fcd8d7d9d5701e2fe13a628f4e031b57865d36477614a4883ce5c2d0a818aa5456bc30915a8148c1a9f64b1da8f6ff3f4933dfd8de606f5e570ce6e3bba6b62a42964e5562119cde22c9d6514e9de3a36d65b69d3f2ff0e9e59ac4e71f06ff9b9ba2a007f330828284329629578c37d3b4b2f4e0f18ca97b2b5486f59c57b7f24120e9b38c973af6f9397003fd69a364a60915ac0e4dee82b75552a49421274c8e03f7c86aa77149c35c20ca5a58280eb743dbe90b537c6f97347ac1b417f970bb53f94f285bb2d57a4672514bbabdb035116c2f677a3643adc0d7266156f2320076edc534e3b121e14d4ded8859032dca10a21a8ff683e24a63a996921b04c4bfa1ae4a84ed570d41f3e2d33f952ae476a7bf6b29ffa6204598ec43073ee95176186cfd95896dcc93bfed942bd4f516f8d1c59ea9ebe760a805afad08be39c2f003a4d16b3d0d5c1a5332d89060ab8494ef1519703f91e78299e032e9b89b63f6c9990663d326cefd7a2f233e102958fc2129bf28be97e228d5be2888ee54fd9e9b63b609ba27df2685d74a44e38c49860e53e8fa6078cb871af6d18c44f2a0a296a74bb691cefad4532d9c828dbd375f55709427376b68f7b7cb3bc42473e2b870728e61e19d90c724cc28c07f934bb73415c1045d6302402859f7f2f6232506a941936c5012aa2a78e7b67d95c5275cdfbfb5d6c5ddb7fbb6711d972da711860e385e2baabd219cc0ad9e48a4927f43f0c3bf4ada6b3bcfee153294e6044c322ff5d06939de1a9ce558fddd478e5e1dc478c072b2283ad147184bebac55a297cdb8de047c3008ce4eae291a8cda4033136b99236473bd52be9c3d3cba08efc3a310b45d04410210672f477be88562bf3f18cda522ecfe5071eafde6d5354fbfb8de72cff10411955a7d93f7a3118c5e5e93fb5be9d8786f1f186c4f09d85208f78e005d1d002e1854c4e370ec92ea88887cf8492ae7a19018c5464dfda893f79aa7405825a56f8db7a8462dae339f522fae0f73ab3ee45a47ec1ccd14dd005bdfe366d77eb863a72fad119100d92eb93f71d3023182da9305c6cb41f5a8b3a36712545fdd3b1b3c7c4ac92ab2e22073fbf122a245a6b7121d101de6f145f2b7cf11977b540fbd77fb1a177d149faf160c1a147ca8ad9c42efa4398502d567b850f4090fb70e5e26fa698f4798c1542836d8f18aa580c7ab595fe741473f4091ae75ec448a972e1ee4a47e3bff6b3b9ee8d0b311b60b3bc95837aa35878f5aa3d19ca24db92c703cd095bcc601989a187a7d5f3fe696520f44b5879e03fd6d9df0b6302499140b9ec6d72f2dcfe5d55abab3839d517693d123690710260a948d3e22370272001d61b0af9d4bdd38ae32ff2f45179bddcf368ebb8715f96fe44adb56c8b022da76bba76c1e1e82afa0c9c52bfd8ed203efab11049a85c5573bee201362ae10775eca0faee7fd5fd6412df75b09af4ca5d3d4f2009c544c353224f018143a013d5ef3326a177a655b2b0f1e987f90dda9bd44b2e8b63fc42576fad2369c3ceefa1d3f4ab7dde41774df9aa3b433834fccbf7ee28dff9bb0fb856d1ac86e7d780e8a8e53ad603a229b54b4fc8716c733aaa1a3b6e409152faa8c2af1d92c84e52a0e9c33cea7a649d7d4535d8d26a50bd4cdc45f379818542d571b02786a19e5e397f61bca01a5d3ef144ff7d2dadfbcd65060a92aaffe3202634550e1ccaf0d6162bb5197602c26c5e751c478f1e86551438f7f264b39b5c0cdf313ef4f65baa4b293bebcca25e318cfda41d13df6e9773993363ddd28260abf6032442bbab5f9d92d7d3b7d29453cd216df3fb9f7e15b393992331c7c906bdd00c394bbe871b1b65cdda796a8536c1abde0ef0f69df5d12f61fdccbde3db5f6e9648d5895c4de9d50025533093f52a59a3f35a42d39c02f2f11ae479bdbfc4bd0e8a397f77b7cf1fcdfa2398e4a8801509c0fb42dd92e6380dfa84fb4bbb1c91410b1899c3eddc4aa98006e4f1b869d8f0b30b9e328891a99fc3f84906770e55c58ca98c69d0064e01e9bf1b7bb328977875d2eb0056191f719670e85f7589f0a767d1145d1694fe63880bb4c3256f52424d6ee13f366525824cf542636137e8841f6530f6d3ee25934cfeb02c04663fecda65c76b148810a90693344b84e4c92c21a2f2229ccddf1b46a5dabfb42af5ecfdf782169d87afb95a108823d97e957eb90180bd9d8b3bd7e5143c48dd38a99b542e07272c2a025b8d5b001e3c31b21e65ba84c36529ee197ff8851cf8b5b6ff5fd6d77a23a33009db70a818661e7028ecc960516c72360576944febdd897f92dbc95ca6c83d7c4b239b0e5b2fe21c38e9a95ac492b9340116916e88290717c5bbaab001af59bbc135ac06d31391c67512f721836a28f4a5731c1f73261a9df3a4dc70650245f09832e5db945ff9024d0278d7e5e256555edbc567c8d5336acafdaab6fd56a52b27ca159d8fcb8274809efb44ff0c8c5a81573956d8fef1e84a31c573d3c8ed600cded2b478ffca6f1de96fdeb9d8f64b19d969fe115007b2d0b848cc2540761e6eb3e0a504d446b6d147481cad5ce914d84b0f9efc8c48c8c91f55be7faf41098a8dbced105f870bee6f8e736b7799231591ec133005a6fe5885e0717d6ffecc014fb316749fce36e6ba29534c8a90ed275643ee30bb5a8e96ceeca4d56baaae80d925f594a8498bf89a0415a7faecf3ac737260bd29e335b1c914f843b7ffa55e5b16fca16ec080052139b8677b92c1fafe1c991527cca2619eaf1f78c05c274dc08aa248fd00e77c03bb4cdade03a635b37c9394f2f0cb7b62e765a0624f63ef63b5c8d3cc6b25db7c250c8ce751b34d2c641bbbca561b0da1042e532d741fc5fb920d5a8b985b2b067910e2b18675ea15dc59e6834f30d5d286efb7b2173433e61835c1de6093e2063895ec15cd17a040c0d5ed502ca814e5d8637d5f3be7ddd035e7b3d428d8eb31475add63b9410e6b319e677a630187ac901c1bac16125d1cda3d5f5d169d4c940c6a6d00439ef7c2e6dcae29d9c2efc4bc9b6a40261c0f6dcf880efff25a21bdef2292e51aef1533876a2a96061a3c01b63d713343b51140eb468684eaa6c987c57b88efbde45afc0ac2286e2197f0c1e8b8805c3319ad275bb1ae48564314309c9bded2b35fa3a43a5bd73c83c4f18602ade9807c4728d71c27f7c8e0f0c6ee5f2e8e9dad1887631e573314c8f56955fe62dd3bde17da47d6e5ddc1756132c893f66c33bb0b1c0b4f20a49dcb41452322398f84edbf862b2afe43c3731a0a16600902feb0cfb5bd5fb6d5bf38f98570de238b3d7901378367d3eeff0c6718caf8f75f4027f63fdac463a2753c3be2fd18b2616a0d0cef4a4d9b945d97465802adae5ec944884f070e196e81872c52f411ada5ccedd469b9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
