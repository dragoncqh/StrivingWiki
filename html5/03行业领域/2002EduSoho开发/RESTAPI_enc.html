<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ecddbb555854b3777f0d7548dae5ebc7e99b9809690bfebc56fa1ba726298f7d896a96eac54840f426aa90aa02881ccc561dd2b31c31cebd326adfda9817357bdb873f3848c6d4424c8352ee240979fab6036a90485a396d4c2307473ce37bf8691660d60947d5f80756401190dbf5f40d52fbc9f4a9eb42ddc1e4ecab9a5bc4d3bcb5d65dcb9e5aa1e19a47d9616d86da7c5d858778c6fa75f6a29091eff8750aaf5f48539d4ff3effbf36e03df69f5c66935eefe012475341a84f9d6ebe54b02afcefb6ce3e56862217dbd2befc07dd4ef13c46ee0dc247799169d14a815b06a80fecfa7232fc84b461b72dac26b38ec471370b32302ac18e9f16ef18375e401b1fdae65bbc17dd6e763cbf00b261c726630a1a6f855aed0e429ce2b04fcc8d28444285e7357c6e130965ec571d707614691f664aec30ec1232881801c8eacfa762094e676bfd7a59bfb09cfe1547aa0312fe5fca2a8c5504b07fdf53dfed9e297c02b4c5a6b39f50a85cb8823801afe05652a3bd63502e1da93ff264e508ada2d1dcc038b9450ec98344c55a3636966312aebeddf4f89cd36969fb6f3c3105e05a3aa5bba953f298f8f536ad08541db2608a61973b4e687610a95b5422e2a40787f8ac81ec66e3993105a297ae31a506403acc8773c35f1f12ccd635aeebc607729b74bfdaa4739232b9ea7dc83334bbeda231914bbda1ce18394544080fb81444c2c75a095725da1d87ca09f94e648a9274ed99ba618bce74eed74aa81a1f8aeb4452e7d018b8516c3aa01cf942b285906735c7cea7176ca46806b3e86030ae45f794ba40adab6fd51996abd652b88ff8baa391c9196d4c127868cb05599773c625c29150082766397e83f7c10d4ca6a29d62020fae99f37443ac9cdcb6931d390a2a65415c1594b447fcb1cbb4f021c3ad11673a0b66769d5b027df75d1d1ca66a9b6326d19a8fb1b77318973c349ff0781eb0ab46dda2ab0798d9017d2d253a9b2d399e3d6f338e683b52b8a8100dc6fee55d66844dc7a10abbe42de3714051a292bd9a9b3db1c5d52516e90908eaa4c34f58433bf14819b37bb4d8ac73cc951fdbb3b3dbc11875cf4020b339b7a00bf200b3ba6ecbae65ced0ada1f34ac292d144008f0bf1b37e55f0dd095703b283044007cdc584635a743be0eece7dde3aea73b1745cbbdae1ac87865e6530799871e550522c564b8c3746c850c7610e87e2d96a812f94b97ab2895fa378c3fea233c9a4ee233c98d4aa7c269f3d99d12f81507bfcdf314cdb3600495c426816f2a064ee2acb65bf0192692babfaf58bbcb427a3130eca4c2eef7fcd53dd19731ca8b376c3473a46ad0deac18098cf657e7e94c6865b9d1e96ab1b169a6c8b7b06bbf6c16a3713e7ce0e4e8a987bbe729c6da22930b8abfb13765fb503fe3d5ca63f2fb2c0d67f8251df2c05fe12a5491a33ef376509dec5e5b41023df0e2f78fef84ee223ce0f3a868820d6a25e1f7a33b45069626d85e90315bb77fe8ec7605e5b2627b660bd29d6e2a3f8e48716d0285d6ec1c4a0bd7dbc69887d7100f9314ffc4331c1e0b508035dbdb3f6235f9767ec14e2aed9aa514b4bfd98b36397adbac3378a4179f0e9d4d086313d5d2acc4df4192565c3d0d8d42d6d36c7d707abb2bcaa57e5ba1bb473f689c2d0ef3c2b4e39b0230faa55d4903fe8f69b0fda67b2d0084c6c9e265619acfa982c3e318c468919c25c7d4dd470e23b2e818f58c4cd2eebdeeecbdda6c97e233b9a3fbd8189990fdf5706bc326786bd776c1eda0cfa7e675ab52d97684c9068bef283e1a54db8a66979d67a1550a1013477efac78c181af5fea0e0787f30dfe0412518a3b58d1fa10f2ae6a8afb87ec7dfa1c16ebbc3cceb62e4f05e332119420c3acfaf480dd1c54a834111fc569ff9a4d2f410718fb522a6b0dfcb558f41118536c100b191e508c307fd9a282fce311e1ec33c3fe42b56c231a0d956242740f03851ff10a35bd8d7674edd6e7afff4ab51f6f80edde9331f64538e04f062dbc14397419a67fa08b102dc97c9960e432daccbfe750ff0bfd4ed9a7808b8f66a668c63ea2e8aef51b827cabf55cf1a07b322bb6157c016f443f9c1f2e03720c12348028db6b468627b45894bc1cf2d0551f29226bab8d44f34ccf51c21e4aef44536cfa5774cd943971186000b65a4f805fe1a727a57c72faef9376ddcfea339326b531b7999e70b19684b82bfe0bbedf7f63c7e264c928dde37de62d821a1f4f796266793996dd7e0f11bd2fd437841fd9ecfab6640d675545b60e7945c8b319f6fcace062be3d5c11f2e85731fd34916354b290c40b89041af4617fc6eacb661b3e9c6fd4586aed879e366f7e0f511fd10d165786f4e31fcddb245c9da28fd8eae096f62468ef3469e88b531061d35885cb02f379acdbccedbc0ce50fc33775f5993e92001496c7d9c33d600fc34b66c8a95553773b4cd9ef72f22bb24029c4da1a2ebff04fcce30cd6d651efc31dd79e9e327f067c627ffc0c2d1a023c198d3ebad06f0f2f30a4577fafc1a9a59571561230777596210a4da210805520aaecc768535d71a78161c38a0bbd8f9f7403e5e47ca0082e5acbf57eda7aa12cd502d98d2ede7ffc305e837bb729277b73ed68718ff7fb727904a58fd5d2d5150e6c6b46ca5a1d740d98ae63c8dabc13aede029252984573830bf293676757338affd9706febacbd16b04db69dbfca4187d018fe23e35198cba929de55f0f4529190646cabbf0db0c151b52a228a93e61c18798964c1bcb230c4b9695845b8623d11d0b4e076ce112656f7222199d4e921a40c8842eefad01d3a4e5c132d193d542e1bfc7f5d2c9e8cfe0af37aa14b3726f059e0d07a3ff79f1a58c8b830f2f840c7a88d95904002ee4d5d26f418c951e90da8483670c72be288a73939f3b72cd3f8d66cf02860ae65e7bcb43bf74e18fda3826adfa829149b54b05d8a164710a71bf34d5a3a00602b2aec01d516c8f99672e5f7bfa05a5efaa1de925f8e4fbbc083fa4f567e3e648ee6c825ff183d29d953ca000a52b5982baf744aabf803edad236a175b0096da8a06a635db7046641da63d88a1a8d64baec4df5b7c32dedade73d5a49d91a3a986e1303e93fe6c21754bdc4d9b93557da349a577aec42a81f29f7f1cc775498961a5deafc3f65daebd43339f364b6ab8af0245fe059b509f33c3f01eb5bfd165032b9dcdda9edf2312e099b65059abd438b070ce72ea9e9ca759d5ec2e4a6322c6abbd7f814ab0536b0b9296169a5d323e7ee3c785be3652d922b3da4fe25c70213b99a8ab60efc081ef31c374b10e5e3accc45f8ef24e52a2f32007eb81205d02ca3e7a6e8a690d9f8266da377de9d9812a191e3856756ac524699f6ce17c3bd05bdd4961df35cadedf621bc61fd5c31bb9381d7033753a45c78a038445eff9e679526a834e0a73fef92bf3418acee6aa43436ad32b3071695ff8d3f529c36e191b99819fd6b3d8849cda1bfe507e2d611fe006271aa5968eeffea0ebcf2fab169e520cb74f00150c38fcf2036e51af4b883fb4dfb2e0c75ebf224370bd836adc7d6b3b744423c4ee729c0757e7047ac6fa6a905a8bb0352840726c04d1a522e619d07395e9fb699ccde7946e641656731fb1d8bfd3eb38357b149435d56b18b5b558a097c6f32020a98922eacc957270a64897d792792d2c7191fc9bc707d9661b571f0cc3573acf812bc557a51a04d1b5450b5c8faa456a1e84ebff05972dd703bd4aebeb79805fba1fa5b69d2f9beea1343820c7eaabe28eb5f3f5e3950f4eb6241a324ca0a57f185e9e4e36b047bd4b2af26909d8b46180300cceb73d6efb706ecc83610b3d31e0cfc708e94452de1d469e139e7bfbb8fea1d26022833be73587cb9979b73ddfdb865622d877ff3fcbe099d1355b420c4eb8abb23c709231e6247a5844598919267876435c1723279a7a3afbed3481d38abf1d6740d8b3b2f7faf573e0c2ef31caf7122ab7584b355ac2bcb62a958789c3a76e8e4f41bf44f36cb37441917cce4e8b517375ce26d7fb622be6e344eed64992977c8dd26db2c707d7ff1bb43b925734a2fbf9c8f4c3d2ada5eeaec9c41ea793ff6954c535c021a77cf1a6fe7f89d7266700c71c1e585c26b7c08732c762b05b485e3c4d7ad72bf2b92f7b59fe9ecad8c9c5cd9ae6efd5bc51d6aa0186d97e9df75361defcbe9a6584d7a2ee0de4d3d3c3e027d230e6d114bca45a8e7360c9df8c0c7a8577ac56146490a00e7bc213900cdbb75c67ced159f6201aeaad4f6ab5c1a20f1d7b756a8a25ad2347554abdf7446ac2f86f92b6722e1b19b9ad840b26e00de6b94e54513f7365e6ea2e2b1d56f22338b7595bc8cc0e6d2c3f18d5aa4961676ab03d128b4e28294d84f493a7d688c85d66a6713e88550f0f19c151151a95304797df7543e72b5fc37409c2911cf440f2ac0f7a76a082e522d80cdce4d6237316a596d4ffa346cf99a9ab4e61e161648d94faf84edd10724108c7737c8eafb58564b15dbc735db59d7bbe1a5779144f2e96d024cf29a7d2cdb377062444b3cfbcd76710b32c04271a641186830ec8ce3bbdf3bb9f05ba5b9e70e5e6e1289e84e38f400e7dc73720180a88d94895d846a953f803dd448306f89def3892c61dd40649749612fec4f6dbd382c81aec4b259aa46bd41847f312764b61973f14ff87993cb3b3e23609cec87a2e0d2c2b58e3b02d546eaef9203cef90fd0cb1944234aea5b69354b7ab19882d8cc17c4999bb5b267321a64afc2cabd0e75ac1c77ed45b31002ca76318936069bd0b5e6754f142b20f26e81fbfac75de988c7039091ae73d6f1bc5e066ecfa9fb47da60702410faac06eaf832af3a04436805b4ac320e7281ec7c4daebd03d0566999ae4dbf50edb2156394443956f3b0b7dbca675ce59c8e7ab8aca1cd801fcb9b35035fc1e3ac4ab7103178080f8963202ff347a8958e138ee2238dcec97bf3faa865c8ee9373602a4e5931101c3f8e526437dc05281a2971068f20d82c7695e0ac5ce241b3c44177dc7502b6aeae027423e47b8d5789096b64b4cfe7bf3b8efef394663b2f8e4e58c97c3e41aeac9e8733add4abf55eb36d38b3e8576c27cdba613858e248ba43fd0a86818d02cd13ae1de141e3913f7fa96790f221b767890c430689a6c42951e7c8849f78e03d07f4b3d9ddda1d3c3d1d5cc5c03790cd64ff1b6e678ba2e1f20789fbf453d9cc8399329625f39272fda2b8fafe9a3a2daa2275413ee38ee36b3b0b49e9acbe5ccd3547fd60756f9b4db266ecb558705d3869d7f2a5be1efaf1582fbe6a4bcf634476de5e137f057fccd5e6018209283be93801111dcd2078e399d417889d3c267fdda0ae7ff10d83ac82a89518e63f7b33f87e322c7e9c1a28d7e5d4d74d02e25d974656431c9f300dbcfe61113c411e9b562ce6bbd56ebebb7e933712ed323a7272d77683ccee0e17ac091407512b3c514dde58962d0f61ee3c9a7f2b2101b57c7a5a4da4b780133e878240043f949361a3b7ab89ea067c6564c3691a7f4a7affca266fbd195e6a53665c00ae4201d4f8929bacd5a91fff7cc8ad1df0c321ffaf970b67d32c90b77816ead076fda7ac080f9e78534cda8404bfb1b83933df1a9365318fab70d4972221fbd2138b5229a3d03a327cbc7ce5d02d41dad0acdb7c0e70913896ff4fef2e1f288ae47c0afe3d699edbfe4e94f4a355829108540e702c81cd2c96f972afaf30ff01a54b654560bdf9934bfbcb5906a3a9c610a6114d3d2902c19dac6d2d41def258954e31b35f7f17c831c4274fb340381782f171cda14ceaa824706c29c828a6590853dca2bf3e42c4b75b3828f01cf75fd69490fb91e8707a99d7fa3623db0600f89722444c721a47a34fc5b675031cd502af2d1e11b76cc7924cc61cb862e246e7a467f4535e29c43f82ab75836ea99fe051e6bf947da7f48579ce289ec8e1c6daeb03b11898cf31a65e62f8c1df4ff590e1cd256d083b7a4715c7f018b112a81d1938d7b1bea7958d62296f5900c477a20686118f842ef56b0496c87fdccbb2fe9660fa61ebec8079f5e1f080523927985761f7560ef1809a6f5497db330b9cccd6a0bccdd152e56dbd3ff76e847b54f10d9304f2f7522988bb339b03b62046067c6803ab29096904c8aad9ecaf6ce73249f18c4ecb6c4e7d663a478d44f036cad69af01d51d5b4a760ddb887c5054b4f2ed9fae8b3a68863c0e1ef0e59b9d874d45f77e6db4e06a749c29c806e926b61f179c874846c65571694e2bbd9da68ea78e671bb2d048e1c4a48ed3377ecd0d1c9c39a573ea27e21c972ecde3ef921749be9450bce3a8c12c6c523c9075331a51766bec281ae2edae5a88091d342af4bf8a5ab3215cb8e8eafdfdc13636afbdac9e673a4e9bde7bec58d2d185285f5c01caccef681ad61c622e43a2b4ae1ba36c05ce6975cad31f96af7c3f98a1d19cb57b1ae4e36cb2d4c4f20ceccd9f62ce445bff447179439832fc97f79762e398173fe8c17074322faee0ac9a27ea721df4d8a4cb9072c3bc7d406bbb6dc273a450b0b1f73ecead05c22bacbd6c89f9743fecf709b21bdee3482baaee2da4de4a879e424b5edaba921aa2fb24462f9fd9919367cba6c21eacd1445307b777da8b47effefc1b3dcd543b04425638cfafb354eee94b8a4a2c3c2ec94e373e04ae6f0950398306dc409772f7309185d7f03cea93e28966910031d32332f799562251d70ba099d650d449a007b5041ad47df7f45949fd5fe4854e7cc90f4fcb802f00bc40f2bc954b61e6e4e76d6e0ccdb9fd0aab4ea85b00ac7c6df4c51fbd43a723ec092d8000d8b4e7ad4e115268fc13eb06ff95092c7c420b2414c6105df9baea99e47758f22c86eb8c61607ac42f453bcbaf098618e8039bbae3994c6f588b5d073971318ca425cb8c04c40c7dfc432614ef4469e9be56bc77ad55e964101698b8b028e26f5ba0f7f71f2cbc697bcd38ad4d74939f193bb4dd4674e376addcc9c8104a64eaeaf64ba7cfdb422857b613715a173ef2a8c520b9896648105adc1fa307b272971f2db1300e437c152b8739d74e88d391692a1225438d6d820add0683840dd594cf078b3ce5f3d59cf344ac93b53d10e8faf4f73092618d554c30b3d0ab5373cc4c5b86d72f886638ea575a743f385a1faaffde7331cba9d00ac27f5a38cc25780ac8cee54ace6d171c55e66053e2422eb156924f7f10c37e48a08e9b61791b235e067b2ff03abb5afe1cf9d13f5764345d210170dffb1493ad53206711f373be32404e0dcbaa67da67b5e70b76c76f6ca56a7c44d812fb77dd5a06c8016c14167713700883142776cf2c60c5a6823db4fb8ccdca7005f16b08dcc3a70ce9e8a38ca34420cedfbd3ed3cea5960e78dd7fa68e0264e2e2c519fd4863e791706a1d38f8ba7d7f76327c33c5db4e827972f68ec327bd783ae3778d85d63371f2728a271b3fddb440e50ff5370010cb75688f6cdb0635fc76fc33f6eb7fe7cb8b70d6c14ea254813af6d7e96184d817217f8e8305b5f8e45c424dded163c9d7cfe6c1f20fa15c36fd3f0c8c8aa43785cd84af66b3f22434fb8ce560a7e4051c29dd75189fd94b1f777aeecbad8299c95ebe810be7405a221e6c253e769bc88657487df1c21eb1c84bed6e35802f19474de110bd28cc24c871837161fa92e5af8ff9b47c694db7294360f53d968bbc0e1b0a772eebf264f651a2c80c8e922fdb9d9e482a0ff15157c666f99bb9d3677cc85802dd2c9eb8241672279d48fc0e28c93a69581a900bca4f15448a0e9914b654ef61551cf85da9f8b034bf88a4ffde6fe0913d7da12c9b054ec4c5685b00c6437db071279c5404cb9764c32c1a62359e6519caa57de905a318e4163784cd9f398097f1095c2bbbd6b7d50f5431c54d16c8436d520d7b75a7c110687cf99ab6a8d552adf6d090273306cf22f44b8d195513669df1d1d39c2f1684d54bf877c5b5e1a69261522356d012a7bfc127a4014c3b5a7aefd92aea497f1a5625b870899f29ebae74ec011ce6a46074a5fcd85600a1f0624389e1b123ac5a62cda5e7e45e8cb1752cbdc782997360e0ecf69fbf34c90a0c32681b576f045b1306d5e789b31d6876edada09647934c726cca3f2c484f3f16cf56e09850e5ec7258de30eea516bda1fc1357a0b039f0e9cb9472ec3d5fb38d992ce731c9d354fdaf0453a91b957fa7788f86338c1639c78d1f62d4ce86eea15b0a546ae4a396e4f05ba1f31380ed819f20e8a2ad58ea5c98f990873930981e2711529ced4e0829b6d6143192df19158dd03245cc5fc2267ee88c799a1fe6f21a247d72b6dbf9847e01679734e24471a636fe77899c9410b806e93172449c91c52717752e2b7cf30df0917f7ff379e501615dd93188a47d125fabb4f550faf6493b0c569ac2f2943a1d791941064abf3f45e90165ee7d26b61fce7102184614cfafdcc95ffe5dbbae61108a6946759f25bb4af69965f54ef68b6f8c27874866fe9654030add6b1aaa3a0f9e9f995290e7c11ae31668515d817f9f8df64cc19ad1b41e2777e166d253fbe55c6417ddc262b43bd13bc1aad1418b544b0628353d87a20485a01c095244999de0e2518dfbd9922fda3f152a93fbc10c6b217a4696074af259e6c6a1257ab01e25134e57083e6e7da7af24b209c29df6a26f69ffdb525f4587a076aedf67361a58966b0fb37ffc4e924cacf821115a08ac022728d499e4783ae38659e29182d3f480b089615d86e96658d46830c404ecd8c3cf5d64b71e31d4df1dce0faa527ec5755188ae645eb0912130bde1a7684028147551acaba90993551952eb88407967ac538f9732dfcf40d6cb49627830b99aa19162b669bdf29501d156789f12c94b193b89493187f6a5105aa0e5723d217298053f57c1367a2cb709e0c81de415ffa74098b2798beebe647773af231fb22e3776dd20c02fe58bbbc67f2f3fe7be273c2e0b9d722f006170034989e514893d2aa86b99e28b8fbdd661cf0bdb39bbce8b3541e885fedd2c03e34322d5109060a70bd9284a3f9f0aebd0d67cc4b08375b46d580666a2ab81d21000106f709b5a65cd6f301770cdd156c80457db4c01272cf7a6d0c5fb3d84311620202b288fa2896282758284eb77d65dda89cf09311d71712732f324565e1d645cadddf5dd2a71f2eb318d77005e865104e403e1dbcda616b2af6c252624ab041222b46337009ab568023a0d0e298a82842ba8c67a88b2142589c3caefa47ac1c6339bfcdd34f99a8f97300c1c8b83443e0abce070e3996330fa386cea78d14892e84e1e9ddc195bdcbe3c4c03c3f1dabd2a151912910c4f01734328ead2ccf099e7a80b4bf44ec20df3c08fe724d0a37cec0f01322b03c060a1c75b570af6edfa4357decc4a0ff09e1aa78206335489c5ad9d7ec7f3dd1628cce9f56646e75f6d2438091fc42f29169e86938cf94647341ddd9f1de52729edb42f09c789f7d04d70f51aa261af23e645b4fb9c799c1752684f511cc4f00a96380eeeb520d804e07f56bcce6521181c6390212de025c2472061999f64987ab87cbf560b0a207fc734f66a8f879f2be93d1577f413c463066e51e1d5540066599ac276f650cb0e6002b898faa12fbc53e422be6e4d331e14f0adb255b2c848867cc56894719c0dbf71865a38b6dec94da3d6309574f3069cca5e875b29835153e836468fc3cb622f68562e075f4c9ece5d4732a597235002de7f3a11ab5152dac92c0c9540c26afe1e03c168798f4c3d7148cc2d3dcc1f9afbb43898a5bd7a365c3c6e59f916033ab3cbe5e30921c482cbf37ccd4f7f076d80077e2e10d99e11920082cac6991126518d3e5975748aa10e78237c2e3b68739ac21e962bc339a36e4a16690c7dad71d2a12c949f9c35b96d7582eda99170cba8b46328a932489bec746a9529c823f004d5f54c44f25a255926383f62c3b344563e1822028da09d163af80da40cb07c0850aeda3242f6eb2e4a2f17b6f5b2b31548587baad58f02bbac552d5539b881dadd559e61fa6da78d04e99b2471a2eebba6d38a1c59ef588a69d04e581be5170f1488cf4a3d8ccd4d33b71bbad8d1dce63d9c95f26e695c2f8004e683a9f65a3f31c4a340c3f704c06fdfb8bbb88b78948056555375399e4639db88892b9f946ffec57f050f5fb3541e48b8a284627663d254e956cb3125466753fa2eb7a50dfa4e6603d597e6c95797fbd59ea81e7d5a8da9899961dbfdbfb7b5127b3751222626bf3eac01cce2eb5228a23f7d208892528f74dabef0dfc5f347e336e47ea6a07cf453c157c642059292465ec04010ece62cf8bae0fcfcd576f387ada9853300b2a72eb968836769c3fac3745bc5c03135c017ee0ab627b64de20c137cddc7d77e1f41e6b0d0126c053b3241dd39639f604a1b60c74e0f0bcc5e66e72e2c233b86848e7d454f7e2e71c265effc99c211712565f9dc6f742277c234dded62e43ec34a242fb0e998e09efe51b8a0aa682e730954d94d63e02a0faa38bf4cf63d415c39775ee85f9ce2184a1af6c03819d58587eb2232b5e42a2c7dac97f3fede62bc1763897c33ad2af78cd2afe2fac11f3539ba74051df98e15dd7a497fa06e562c2386e591e864c14fab5b0f373fdf9c827ff5336a32370f94adb5e2582f91ec64212f81f3b9c1897d837d81541d5820dd16f6c820fb7034c3ddc993dae439aea1c4d5952f05a4ee725a992ff233f786b61de19cd4bca3c99d4c4639cc1e317561ad756e98c5f891c705273a2bda535ec8eb4fe9d8ded9a6a899e4b6dbdecf054d1c80d6b0aec888ccb13feb2c222a2ff5e30a10b9ae7085e79f7c33235735ccff15d27cfccead0821417216f3cb3892be9d3eb824853acc759c39617a1b70018af97211a0b17bb50267e271e338aff26de86a5806e1e91e5a4b756a7c41b2accf3e9452224a44922106161e24202d46db2a73882cdf756bb76b38165b8879a13e092b286b3783a83c0c3695bbf1ef2a0ef4ed7d7e2aab315d090c52eab59a4aabd2903c8cfae640ba4c568a053a5fe295c88553db96dd1eaa39027ee48b5821f225cf2fdef4ff3565cdfabb13a62890fe675d864cccea3dcc35800753559a4dc6e0e9e4fb5665f9da0cc703588e321200fee4114a331bb5810eb3c1a4d3c2eba7052825d940feeae13eab547194644b597d693e0070e465f2dadba4cc4a904d0088a027f458e0615be72da306fe7b7a77a009a1f8c866e4fe7764bfc443ee6f5c5c229206fb57335fa4ffc38baacee8ac9238ad529a0197a9aa8cb3b4509ab1731160ccd0c30824cb683f5afd3952b09d2f2850ca185fe8c962c26e4729a644496e102a9eda1fda37156633709a9f7b5f15ffe536f84cef9c08bafccd6488c2b4e157fc62afeb84ae6ab79d730e05ff11ace8dfed4c01c709270f68cf0b383c0c779466a2b187426b60b712bcac2f8e1f7d52c171cef8cbf83003775280ef3a45d38edcb35520b3822280f94cb07fe8bc0bd6031d8372741e98ae5db9209fc07f85d4f812d8b6326b5a32f4553ea556b54afd71bd4d0c783a8a3c0fa0bb734f1682403e91e35c306d782c9911ce707ee19011a9ad048f8980d7ab11f2610f8170383c32f2f1eead44fde7364d4b78b02b3ad7566939efa66fec5804bf215cecbc442699c2cf313afce66382c94f3117f75b990e493e5ef7c83aec12cbc0b5014a563a8044b52f06c615776e2a3a895fad0421bfb09d6ab37c24ca502cb0a7aef192497284bcc4292632a9a1dfa8a7a3d4c3e2be92635e427d15e4563bb9563eb82b49388cc8f80010d993568d1ad6f86f658e4f2f6cb92f5726a8680d5b1753451f86db524fa509391c8ac20c2edacc6a0608bc9d81b2f441614d03aa582a010c373facbca2a960312aac902096d1c21adafe9f03763263940f5bf887d053221b851561ee6f62da371c5680537f31be538afda6f163268636814f4460ccf9d02254547d34c8e5f38b3c5282996a26f31307ac6d94a772664e58b555d500b0df00e78eaa433a432791ed692d00fb0f3bc274cedd54d2fcd1c67fd0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
