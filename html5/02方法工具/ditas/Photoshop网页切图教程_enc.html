<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b9d8200bbdb6d314626469f90a5098db80700817d71b55a38ca885233c4a398ff12127f0d981f36e73db02e2b39a3953c9ccd754b58293a37eef50b715d2c50a1a212fee9c2521687e4c85e93cb470380129fa44446da96138754a7e0159aea4f99926e645d91584cb5eec802c5821751f06453a31a2462c0a29bc2aa18cb4cbc45dfc5df9e10a01653023e3933e9b1919547ca0ba2447a82335f82ca92070822743af77bf36b6d3444590c9730c43eb24b1c227cb264a53448e756964755d4013fbe4e2405f9db9ef24fbf0b11ef4c0a30f4f0faa011d4a79d44afc70dcfdea38da3281b3c1c28fb0f7c69077461f2d5613da7a51c3293600a715c5872f661078499591958a0e95068175968a2ab25af793382d5042543dd38ab0319889925614f7584c397e83b8df4714115fdcf7e9c06616dfb76d6cf45ef9dcb7dc17d3539c397c839dad0a4eb6382918aabf8bc2709ae3452345ebb60a4ca9a01758ea99727cb60f7960101164ff00e0b93db9216debde3f8475551298817bf4c0b8b9d206b7e3894b98c6eb1ee9fe5b7b895ab6d7ab7203d3fab41b162ca0b2707c99dd01587a9f35028b90df417d0813dce6197d0e00d57ef486f99b79abf753865b890cb5273cd0f5e1181b6be929381abc0c30407d3c8617657a00d8a4221ebaedae70f1a218bda247ce46bf89f13d553bd9291691512df38dbe518ad27c6f8dbe76325aa12e23a75b2182516c658114189435a8b3f33fefd7d657f136347eaeeb358e2b50aa19997656affea364750e85a7cd92485b80e18dba97a46c1e01d07a1261c6245be81dc12ccc7d53af6e3e05b8ab51cd1f3440431fda10d859918ca2d513470be45d45c3aaa263d1b2514361075a4f181e571c8b6adc493e72da23de847fc4802e0c4a2597fd7f37c3ba1aaa5ab4309c624e8b768013c4e31aa375127cb2d107d4fb22c312f3267493f881c6e71f60bfdb284831dabfb1c33f84ff736636aa0b3195b21d6c2435ac47860b545a65feb56aa7eee800654421d86e5421196f20cff37ead08f4973ab38506419f35964dfac8fe99f8753a5c0c7e0465073b8eef9d3dc5314f9ac5d9d7d3143581e92d8185e7385f1f0f012ab1295ad1ae23951121de6cc2905213d4be5edefdcada9da9d77d116d5c8564df6db42b9ee9c3e871f0110519fd4db775dafcd657e4516c7284a7dd7e832518fdc0369b0e968b3e77e529fee11c3d4ba1cbe6cf076c6789b8675b43980095077ef445604de8bef252cf0d21b0460ed3535f08790b3e9dd389b39bb3bccbbb7b53d39b8c00bc0e93620012e60219485faaf6ba172941e19e55c3d0d8f5b18ff50f9b39c3007cd35b587e274d30bc1eafd5efe15978df852476e29c74c2eda3aadad5c2493bde3104be0f7710f244303b9ed01d19cdb277d6f39adcf064059fa9a647b3f8a656f759349e5a01083162c90e3e0d733ba5e9c4dac3adaba5e2b913c11ef4e8b992dcc1950a56feb8960e7ed535f7eef222611cf04eb20727b2584bda7152231ff813b4f5df6411335c7ea316420ed2acd3094071305c6f535fb885d0eefa6bf384d87c820d939a54f66ba9da612bc45a27a937d43b0da968eb894c41465536a16b4d498a8d871b187a7242e099612615a28f1ef3fd70838af2b363813bb6acc2d7efa8e4a1f72923ab1e3abd47896e3d3d3e9ee606d7317e188b8b86624a3a4dd9b9028a89da057afa0313358c0c72af81fec09d1d9843d759a46d4349e15cca11dbe608bacd1bfb63ff92bb4a3c946830c10535eca726c987622e962569eed12d08795df29813e07bd6e8d5737f62ba20236570594690e4f9ce6031daf1ad43b72ebc1f58adb582debb7f6b194c7eeda78e134a30dd758bfd75ca777d407fba6e752cf9be871402192672efcd81dc65d6e7844c838d495aa1bce478b8596ec0f459200b5589002182b5c5bab18a039f4643abc3f3a8228d51c4e2440de6aa86742c069a7370a15e76b64771fdbbccf142be42e9e308cad7eff6f660bea76a6b79e0162f492bd95f7299474f35cab6ac44e057f8bdd1da359cf4167a9e757c61e28025c5100cefbec2b065465e4f337ddfdc38e90801c05b1e917c4efceff78a1ba19095bf79fb91eb7cc72bf57c1bfa69ecd273a1ffe4d4b172dfc6a5e1bf57cba9e0b23cd0dc44104582b3d2d483f7d7ec5c37183995655ff264833030ea9e9c209662a561ba908c2615f86f67bf2f2f7b1a16e26afbfe2b579d9913e69f338f1b08a5c8f94297e71e3822e19624746f9c48c4d752d4dcad0b96602858b3a7bee39c8a99d3796b139cbb61b2d1cd5576f50823a783e21ad82d8700430b0c6ecc9c09f306b761aee52a56d3fef734d73d7baff3e20dd695f7aca8bffc9d5a5212f797150a1cd244b4bb84003c9163d9935efb55f1645629c0c2146d4c2ad94a55faf9b7937fa7ef83ddbbc290d8f84895734e32103eac6c743786d3663b2f102bdfd33073ab2d057001a420ac274e008d26a9f6b53de3c9e5880e9dff7a3d7d88d80da6dc6b6f7ba5fe6ab6beb1fa409200174e47a877f1237000ca820b3401feee24ed5284d0873591cc1af7f68b957aa694f59f7b96442dc49797fabeb13866d0b02398eda5b81b18748e347760834cf336ed3f1b06e3aa51a576c1cbe1e25583e5cf53e3c52af0ab95d16ef139684e15196dcbb45e44aac1d875f0d9a9bea65d19fdbcec07c558b629e2490c688ff69220f52690fa658679fa613b615a5c8607f3ca65f61f2582d66385b87e43bb6a1ec578dc4cc69ee8262fc897d1a15da6125f01d84e5f9d2f0f1da4d818ed4a9666a5c7ef91b0c61e2c203ba400f5aa29f6dfb6c54ed0e144a670f746c25dc36f13e69caa3e79bc0fe62f52d48f83f67da7ebfb540e751d242dcb7447166d60c71527311a5eb820392ca8236d460c8924bbea2758671627510ed117a0c3e47cfaf602c9fca0c3c792b0a27855e4774fb6099377bcfe03b10313c48c4dc199acebb1fd031b25da5a57f130d0eba1e420f7a4be73924c527df95706ad3752e87504c7b2cff8478a5f3f6da41227694fc43d2e9d02fe452c9cfa9ac5e4c149881e5f2c00c91a327ad4a46e86f6fe0edfc21763058bae48df5b01cfc71d75c22affa2b25dd10ff37267504e266ec0a9a4c99b672b359a57377ca6a87afd3c2fcb572659dec6cd363a1bd362569b1c6adf1f29a49c69958f30929d44023e5c298e3af4b7d1943436df0b4cbe361f2838de4fd8de09cfad177ffe2bf0381bad614b5c4789fce52d6fe6ea5ba53af4499a5ea08abe14c936c767d4a97f0edfd597629c0db26468fc7f972576b3553b44aec61313e3a28e1f10b68621dec1ffbce44976077a49faf1785d9738656e3b743aae588a99fe87c70400802592b5f55287b44e4030d92e78cd2b83502bbb79d721cfea525b6b7cf1f828164e4d0066355a25c6b7e8aaf4a624b9e36f8426bc84c4fa36a67a33e89f2a4aa5473940be77acbd1076d5e8038552757f9f47e6e82858e4e38a790984e5280a73b2ce5b7c51e7d0382b5cbbfcea82641146475497a7fa54b41b003b0e022fa22605dcee342c23ce3b452c4166fa6ec00538e33f1aa68a6b2272b3e4f566be03f5623e1b41d7f8ed6b9c9deabdc8a5534de30cfb2d826754e53d39f6524e2d215aeec509d048cfe42db5a67d14b18e3dfdeb05a021b11a63c5e97fa767b32a34ce1e569f7473ad9e2aa6b2e6dbe3d0699212935cdbd635b6f7a46533277f1230be757a90a7dd35a183bcd7f8f667af81a4167aa608db9acaaf0dc4e93ad2cd538284ea3b4f558d0d0bcaa4bef159352e1fbb3e6f48ba65697aeebd2882e8c83bb197f3e3aa40175f2d95782e579ca05392aec7efbe047229aea7ae8098c3cb78e4e52c967bb813934219d51d4eb63b933cea29bb91d5c022b0e14145f0c8450e682e4106578a53e6df430f54ead695b59dd29b0c7903e80351ec5be49987f898c35eba16b145c6d395c30da3ffd29b1d13114dc5ccd599b5478d46bd8030a82bb7b624b2425b61e93d5b9e5dd45c5e127e4cc3e81b8a2cd8b327cba1bd201b7d004174781fba162901b973db457c2293661a39c42b7925e877378ad506cb1651e74c653888169e8992b6b91c76cd9c9292b0053fdb64d4742f9b23e9a0868965c1b02b7d4bb955b95931ea9f13aff9d094ec617e4cc31283d710370206465f917ef94d308e7d56cf79c291d952a95eb4516e62e8aec09c28609a5e6bb41471221c7a04257434b78ed93ec002d2e09a27f67ee089436643f8328f752802b5c86a848e7b36bb9a17f2bc78cb5dd4127b3c36a03f284f209be286236fa45ca374f25ed01dcd2ef2bb4cace5302e4703a3985ae80383cb5dca96b1c0ee735c852b8fee1554935cb004f9055547cc91f6f043666c9473a4d747ffc7e0db3a9ab940c15d4372cc7ebb36c22abcfd46f91eebc189e205d0a803cf3ec2c8d2a6df87835937ff4814a8e5bf632a05a99b329916eb00de2b36d61a184eded80f56304f31a729281b41963fa256e83170a7a7a88e23284fffb018f056cab459836de4e74e331f14987d9eac169666a74f277c1aaae03e5e64c5dc842e254cb160927be3cb3119fa943e2f02ba18805aa7d663687fc4c43e9672ab21cece466510ecd4439213a7b6203aa4a51cc6c7b00ff1d6c99d9b0dc76c2942c31bf6d5224f34960598f4f1b2a4d9311cd9a8fa1dd47cec63f6a4ba572e1962e86d52862edcb4a03ad84d2d1bf794b57da8b39f627aa9cb4ef4b3ac90c4b279395c98bcd02b8d8f5e19c2a95b70f8fd7023d0680518a0e49770012db2e6fd2f64cb24aa0d2306d715c68ae2f9d9e3683bf4704fd11c7f34d31dfa06259f5e936709038addb448578ff737a0f3570c17abd816e7b858d5bc54cc808309a8a6c78512fb7ee23e168175acb84f2779a06a1fbe84532a45e7b6bc02e9af05189051f9c700ddad33fcd86d45fa3df836d8afb53176af159ec6bdeb86722040ec4ef34d4d3d5701a7762bb77c4c8351a8806aec8608da5c4186dbb86cff32bf1156a98f1cb574d52bb4db89650bb400a7780492c029358e4039ea5b306fbdccc45aa2142e31e52f79e9b16f93423883f2eaf78f7c2d0768989c38d2cd98094a5481b5e095466662cf8ebd07ecb81f956299fe5f5dfa967d9bed979a872fac320e2441db5ffedc6d099f244b88269f33268bba51c80ca054eac0bb7132f72e5df345013824a087d63fea5f20f0d6ac414338f17e4c4e16e3cf50aef3839811a2a02d0f5acaead76a19cbb69e6278ea43c935be65ebafa2f9938672ae763df8fbf072d35cd0d5cb257689badd3e2b418882e94d64e8260291122c517b71559d466c2272e90ce1c68b1c2d136542463497b524bfb9b315faee93f574a4790bb1973aa5104bc104ef7eac5bfcbf696b1abdec2e4fb9200f55ba2c6a72cbab87d762a6310f91cc4d18f910ed6783cd569153e5df10f1dbabc8fd3fa3188c2d1135120692f509fcb9145c6568fe6e98f83e851419cd994269f4fe5c4bf74a0a9d3b3fc20fc88039f6952639d86bd3fae906ad676d83ffacfe0e0399d909e22cb28fa373968881c48ab6d31177737f5b8605c59644c08e8fbedd67ccbef5ad21968fd0661afaaabf0e208355dab03d6d6c2b603a9ae0bdf845bbf10a7d99d1400f03ada5be5b27e4965408c24e3a659079ca56a50c3956c3f27c793d6201c3d57f1fba73de96eac8f3dfdb1dffb4117ee3eb8d746cabdf3a2689ee86e90285c1453c897421cbc363d70fde9f5c53f4d7a8c05f1fa151a54ce5446f7f2f3e98312172579c1f928ec0619325a6c9e58a7bb1cf6b78e585907d8b63043c92f0bd170538269e271df9d595a93c6afb8848c14d63708fd624c71009bfd272cc765668587426afb013459846a72865ea5ffe01abc242e892751b3afe9bdbf68b4561d7bd04076159245e60635ea82405f1d042fdd29c188cff3831abe009fb2bcadb486d6a297955146fb3b26fe25b0ca896657d34505487c802f60837a4205291c9036a0659aa5965cc9e966d99667311706876b565f6dcf230246fa406ba2ab5ac052e6566c7a1d93bc0b4d1f8bc84113ef9834f23ce3d448b9673a156e203908189c0b0714ed3cedb8639e556f83b8e8bb6872d324ecedf50241c3de29511004a0bc2f8ac7b7b95a347a3a60cb2db793012b694823438238eeb99d1749a8d75aa9528d425c2851931767cad6415f3e3dc8a30931603c4106fc025f67a8165aaaa32914c2fd5a7921e736ccd2b844cdb1be9db9ed6e0fe9bb7794a0ff911c9f01f68ecce0d7fd8cd83cdc66e974a1b96e4c096eac03a623a9f1519cded8a8411b14b35734f51de10f3c4b27d111fa5fd7d817197181540a926cee9fe28c62b44ca45ea81bb7992e8c1293ec1c4c6377e3a99bdaca20ffaaafc52291fa0fe0d9fafb70c93cdda696d18cf0a90d4eb584f61d53e5788b2e186a3e7302591fc9b1060ea94ce2f35edfa64dba4731f116b3369f120dd819e19d13a06dcc9cc80c9a26379a2a4787e5167a8f5146daeddefabcc22afd46d4eb2e645252569e41ff6eb6f80579859a69b78907421127e9d152e4cce6c69c289025b50783f065afa6cb8323bff69b033899f86482372fb4dff7734b3ba52d782fbb230ae8cb01bf991d295294014179d1d70ed36bc6cb1643d38b3e52b7df68ec50b82f7e50bd84d247d0d755e88f0ada23af7e93e22bad112936403d220a772e6cf1238b75ae6f60e793a5b1b79c66913e50e3d27c297dd4983db6688fad0f0b65ef0e12832a26e6abbbdb0ef30480243053d47622dbb0228c69aee78c6bc6e84ae0951dbbc7e1e1c05eabffbb39a0736055f9df4388014ca0247b6f205bd8b2ca313dbf6008c4ec0d83b33d112973ce9dbce8bcf147028c8b78e2b315b32513366a9bdbab36f2a1179a5c9b8342d85c5183aa6aa3ffba21f4beb6e9f482ef6fbf9b3c539bb857786de2d2378ab3e0dc08f2e60f73a6ae9298ae50b4d77e6d8b6ac9b40e267911d442ecffb56c35ea00b87300019e5dc0f92a33b07459ffc98d1d4aed8e8889c1bf8dd1c2c6cfeded73163d82c65f412bd8227ee10d68f2f621ece792c13f7aadcac5db8f4164d6123f79050e0096c123ec3759924c75708414eb53dea852d4ea3a5f28cdf6ba61309ed4b031e211e5396d2f9c4e18a54f3e0257c0309241cd849e21f61de627ff0f1f1945a30d15cb61176b0e8d0a786e02dc6bf52789f0bd723dbf8c2c5e00f147b57b0ac64ace4b68dafa4a31f77247534fc690bdcd9911dfc7739e8ac602e0de13567a4ed7eee3c8b7446f70d064531a6fe876493da9ac1317539fe5994a24f28414f41405cef024e7c36d5871eed45437e9ecaf2f8a6fd66dcafe073b0d89691f75fb4eb02256faab0f4ecb9e6ab7105f350fdbbed39b703e08277b751068c496bf223353fecdf25b1d73752550b8b0040571a20861854aee038f7751666140879952f23a4ced17322a45481374014ae7660ade163679df60ffa77ac8020f88b0e25630474448d897816cc58877b441a83dc88965356c0225e49e328f94573283c1daa1337d7e2374a63def94fe594edfba01fa799b7abc833059a45b4467a18b9e26aca5347dea34d631e6f27965283276ba3939ba0ca4640efc60066923e7a7bf98923c1f6e3f488af788742e076049c823b2557741a2893aa1d6b23ce8fb1825be7d98da3f7dddcaab69ba311aec9c72746127a0e7665fea6a6c594d090c4fe8b3a83fd40e9fd37f0b1b7c7e5a2f26ed89cc73024cfb293c78ddea86ad639b039364b126a2b732075278b3a6dd8f9e3ee31621882bc5c3650462e03255b9e30418357f8881165b211f4aec3f8036ae2958b5035c01d5b8beccd5ae18cdc3846be8e9b0efa37286beccd283f3fe6208089052eafc20249f6524d073d6800eda52bcf8e71fc28741f3469216b24b93ea786220991facd2895c76e88b50edad4bef062a49b456be827f4e8fdb8830c0eb79b9b648a1414bafc2d5516fce5f727b36c58bfb011f6c38a4cfcdf17ed47b5a708caa9faa993bdd8932c3256bc4d72ab24b5fccd278b14e43e68a919b3241ed525e1cf8c89f410bda026d0fa501db1665b90c7f7188f88e0e84524149b639d8e93b298bdab20fbd115cbd770e04bafcdc9cbb5f4927f3c18f09e0220443b2a84dee4c19a7f5e906ab0f7b084c63d33c8a2a91346f7f626ebcba9718b9771c6ae221ce4bbacb0e0cf54c056ff67889e43a0a567ec46b83bf54d5b53cdd7f84e7ff4d94938de6610c838357aa661449e6cbe4d3d8eac41138d946e8f2a74ee4a40e2142659309a26e91a07e4944fb1b431341532125d635b1e304a7d77a6c0641c2ee8ef62fd6ebb6f82dc3b6c5a459149131fbbaa8f6a74f7c07b1f11a5d322e420c87a7ee7f5fb5094a00af3dcbf520f9ceefaede0869eb07a998bef3aaa9c6b218c1dea6efdc146cd462829090d60a9e71d6950cfeda98713f3843ff58c817940472cd5c4aac9179a0a4fa0f27bf9cfe60a58a1c9770f07f35b09df1dbf5abc97b5242bda901c7111cc423cd53f51f054d8f8c82415108c338de91ffaf57947fc8df0c00b722791c6aecd47d3f5fc35a0126cd763fa15a24f2fd50512f9a27d2f46decb1914678332b07f1360c31adc3df4b15e87972634318df26f0dcdd3ebe0f34d70cffea3d8787939201fcf6d3af4cd274788fc06ee52618ddd6524af55bf0cc0b78afba9cb83af22e07498b28977d946e744dd2c03bfca0baedc0bffaab5c4b890bf852b8e95acadf2b7a2d93c263cc11cca3bafb4bfea22fc9760795c239327045afabdcc3272dfea3af6337b0f675339924ccf6a86701fb2a7076041c7da0887d9ceb2e3e0adba8af9fa0ca1c2a74bbf3b1dd8aed448018ee27b582ec8ecdca58c14fbd99899db28860ffc58caa982d0107887058348efd7eea37c23738a2ca5690bdbd2cfc50acc8ad3d1ac73843c4f87e7eb8f057df4815de451dd76ba29e40ec0afc54ab3e83c302d4e005cbae22f78896633f1c79ba84220ac39516211cf3de93754df80a7e432fe8ec2019ce9bf99730e83c73fe581876dc48f01f02f4bdea8cd21bb331bff2cf12af88c53e951f25071e6df7879af2244d127dd5abce312eed2cf7ca65deb09cfcfe71353fd9bccc76fcfc4d3ea08861c4823de279c2ecee6ad64ea36c1b854d4f4919a1b1f1a5d9924e6de70f4d1a16dd4a71f44e844c944317d5104d0a006fcf81b349e9f374c0e2ed45e6d53c6f4a780fb09ebbd24dce2f5d9f81cae9387ab7f91073b5599e867ffd32077e575955965843620e66cef63fcfe46fe12e1512feee5aedc43329115c1594810634debd46e0e7eb139576336d8cb177906e9cce0ab67e23e33945723e65e1e9cd534223aaef051dcb5ce427e05470c2af518435c96b36b919b4d6dd88d3a17dcd7c5303d5f5cff60025b7c3d69b26a5867ea81ced28be2dacbdc049dba1e1affb1c4651e76afe3cdcbdd348b77fc206fb4e657ed6363cead92c438d7cbfac5ef8ec9d9a9c50b896fe3f6da8c425ec17c352f7bbffbbee5fab65ad97f6c24848fa0e36f0ef34a96fc0f78dc2226fdb89e1da85336fa13a0ebc9161f9649d5e56ac6c74452477b110d882c6c34f42f43bcd797b258cf813114e3561f9c50a0379ecab75c16575158bae525128e23c9a649e52fd706dfe43fb5e98a7d9ceb3e48d032d6b1cdc340f7e633db94377077aa9a5ac81f757a2fbf88fb4eb804a18af3494536a1f3b715ef4f880bacadb45da595b8f942228bae7816cd3ac27efb1fe759837f7bd9b2dff9f46a92a39ac516c1093f6e48ffc563505ee0fdceb31586a8d00170b0a8bb7ec1aa1dbd7bd9ec50823ed80d19d2183ebce6e04016f133373b851bd190235768e8099429ef6b07b2f7b135553f9a574511ed3172ff077f3e4385cd7330aba73663e9e499c302e8e382acf2e41ebb919e23efc2ef18184e12cb4df614c7cdeba05c1815a8e15f55e3a27bb2ecf7d45bcc1095b6c399873d81f82dd55a919c6b1519bd55beeb82398fad2b8ff1e6dcd388dc124f08e8c0af44090b076e884887ccb94ded866d8d8191e64ba74fd193037fdfceda95d1361a9a641b07e38af4b385a9506e183b13d79a12347d61c79c9bd5c27d6d5bf1edd4bbbe13477d0b03be2c845a6764004c80dc78afecf781e2bcaa6138d1f8f0c8d2c1eaa0baaab1ab9ed9703587de77a7be10f15b50de143e5bd5642311de88675b090b0322f45e0c360b4303f565f90aea63035cddcf18ee526302b765f35df246d31f4942bfdd6c558bf96039ae627dfa45880323716eb5f7e3abc9df591fc09cdbb287725d41617ea7b483585d6e7095402259d21e6731061d976462485dd5dc0513d89f2072aea3b51a4dace0a91153c166eee5afd6b22b8fdc6f58dbec66bdb34ed8ceb805b4eea8807c7358f71b8ec674c00b23d2b2f50c8903a0e75641c76982e26b9dddef462581714bf0342f1d07c5d462bd359624e2490148b16783db3e6678e9b7743fd55cbcbdd4762e4cfbe5baf18437586137c91086902c19908075e269159beff03571e8faf6158e83e98714c3c92aaf5089b8ddee2643e7225c8a41c26c9247662db57700f7b0caa81f31c5d27b98f9434e5dc931b58f2fb6a44369ade56a5055f7d73523b89b40380b20d901792ea69bf3c9adc8660ddad528d23ea2eac63fdbbf18a0552fdb708ca40b5172967cb91856606696f10bc2057976a781518b174ea745f6069716d8e03011d2841aa7f2e9f4e7b0deed3f21b7641ddab7da97314749db71047f983d81ebfeaed4ffc186345f7f51025e6b8fcb66ca9d4da8a2faf5c3006368145beecf5a1a9ff75d63bdff9b5630bfec204c8a2b2801933294cf6855beedffadf71407d842ffd3fcde037c5101e066fc17cfb5531393aea90cea33e4d9653dfa2e18e921dfb50ad515c31f66aa314af480fd9f7bee02ab76952d2b6ee93eeaaada85dabd92d4ac945a534ffc711df780cbf3ca6069b4c53b35a1c58232a63e47fb23960f2f4a9f0248e7eeb5cc245c21004683e804ae825b07860a622c3253b60bf5818f7d6e52f95d6cf5a553e6b459786d34324a2d4333accab965dcb417d65f5b809171d445262cf85bc478c356289c7756a8d815c8803e5a786a4d070de04885cdb61bd765c4f03888b5af80ab3d3b6c07ee3114b9805fb71f680dbd8153b48077d5ed5e239f24e987c20430de8ba861326447a28e6c46b22856df11ac098f1d47e5aeaa3009b6e5d7c417ea4de7fd76e29563a66085d6b84f669a9a2133ef106b45b8adcea2af6e617ea7cb230da413737ccb980bb1eb2c17b933749e1d678d5cec079a2bda772dfbc1c1519922c0d5c23f119aa43d9dd75ec2333874c862462eb14a8e20941b3b9d39b8ed4f6d9f77697cbede2b6e7e0e501020aa795316ebb3892da5f22be60ba4a37bbf78e1a8df50a8939b50556a40ac0f428a913f8da14171b643dff515edc76210c7e30efb5ec9071cbe3f6477ac588b239a499670e603c5a4de04b6a92346b2f49afef1843a7b1f8d4b44c8e2676ff093361d236023779312bfcc9e05ca365f0794599c6d0ae5f8754fa38ec030607546a929483f236c7571fe9794c8ce29950beddd329a8ec3d29be054a2374614d885b9cfa4bf56344d7c7ea76c0b3962f99a321442cd33fb2569643f3bf927220ad31a57358375ad1c46f82c9f0a9f226631f52375af6800a4ab0427f1992acf5b68f6277ab467ce0d2c5a6ee1c2273f4639c043b9073621924649d0a77d4637587061a8d55f88dd2bbcf8795b100e8849864fb87912764f82719fc7c03cef68bf33263fab58885eae0ad99e3f8ddabcfccfd8223c9481677191ca5b959b26fc7b30518209b06e5b0b84ec93b9df470b89115067a94d38b95bfb241e9921cd802b8a0e9c84e944c9ae5f0f55147d6f10774137cf5e7b95cc7d175b3315d89db6b684b07bec1483bf3b03460eb1a2a157d42d61bae4b181e111dcb9c64dfebc0a0e8384119e7adf3851ef4a12e594af8dd391b070e9549ab23e2ee4931c5798582553364305579fad99e370ee0d14f76f60f59ee21c8c6a2c9c8cafac0456e609446fa335ec29276daa0881603f7dc3f902903692f4364b0d7bb94e19dd8bb9ff0283c54dc3ca6e75314bdffc0f8e985e171d8630db7e317ed2c0b51b0b5e32fbaf1afcb2c8a916db74cd75ae8c880341e3cd786b47ea9e95d0833fb3bf616dec7a0182eaeb232d6cdc2520e27752079c51baa310d081564c5e16121d5fd20d53fc3563d39bf2b342376f9985569b5b14715f9a4a3a05f6e571defee99ae97a5d50c25ebb68952d98e4b6fb6b4fcab0f168cd0e234984ab1ef8f0605a349dd38285babbe525e0cd7782599ed7d6721073bcf7d89c8f517a71cbb488851d8c338ecdb19004cb7899bb616b5aa5d594650850ea3f6ac8342a03b87759db884276b99c480ebb7ab624c2b02703bacffca6f0eba40dbe118daa98837872ada303acde6f3df4f44c5073144ff8826d5497d243c7c5e1bc6cfb179cc685ff9999f3e09bc74784dfe788593d6805a7e12c6ebd89b5022b02feed05da4760984386475729a9b655e355bac8a49d5ba9537e8d24efe6688802330eb37fc4f07953d484d9a11af306c0330bf7b86bfdb6574926c57431861d02dd17da7d772a2295ce91dff5a0d84ef493db62727d62eb6c08d5c6f8c8ff3a4d88ed4ec99c4bda58d5e823c604042ed364d1da0c7abf167f13fdacb0d3bc976a3ec1068ad06efbde8b25c138dc1b7d8af1a929e513436b5c8bf8101471023831be38ecf1f149aba4c0bcb6b78a877a65319ff45d488ba2bcfea996de32ad99a8e6eb8f20049a85b1d290a9f54ce18e087786b524b17b550d0b08f7a75fb4ed84239215cb4ac1621e36a39970d3223dda747f38e0553fa15274e8c01de1ef647eaef5dfe7e68dd3f91fc3916e7eaba7ad35cb5dd43de0bfe9e8fa472223a0c61e6083d9e46a56868418fe6317b1f67e65c27128914b1d88ce05373ff9113f1d799a9ac3a21d933a408daffbbd9ea1328c501eb66b2439d4eb839050c0c4bdd9485975dd8ab32046a1b52f247e791ec5e6835e715adbb126da1fd2b79f2d25d52c1bab884d2e0b66af1f8977b3bbb6a246cfa78246dae828836dbb7f72eff79deaaeac155d4357f4b35b1620bfbb420012526bcd95b2e0e8f80d8c39e47f1d4b6187964de76a9bb6973b752fb294d464f771744afff5e1cfe3c076635fcc2c16ecf63e0a8cf2e06c99e04659c15e5b4ee4ab3595baaa34d8a9bb1d29635ae64cb1394aa10593a65f534d5bfa7e2a86e24ec1f0fc965a571105655dffdae131c8d085e4987d2f8da039dcd44e8cfc1e50c147be85caec21474ad2939162646c6ba995dbf6af337fef25139129c80e4b2ada334929d35f38b53af0aed95bea98686d78b29f4e985bdd48ff6b3ed314a19555c444c44b11065743a2ed0af50ee284ed5a08afcb2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
