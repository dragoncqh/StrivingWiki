<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e58851e3495076784c2bf182fe5bfeec6dbf82935109c4b78a328cac22792968197bb457a68b2e4d4e9255923ef26bc20930d6e5e9832cf4ed0e6ea21430635f8a7cd8f1e14e14c422151ac9525b2ba15e661f411fc822aea3721c0dc763bcf844abfc5b743925c669358a49c6a265dcf5959e4f65495e6d012d04dbca7125a0730b2d05a2c043d62fb3e70eef21d23281f9a2c4ea11e798da2399da3952b8cfae168919e8359c91d2221171ebd432c16e85531a869a8aeb5fc80f192266262f8475860a46301844a40e812fe48ce6355d3dabeae54717710c212db06120630d5425fc13f9b6031bff0942c767dcf2a4248b4af2a8067a8f776212cf107fd57ac5708dc9fd22e10fb789af0e27edba49a9376b9fd7b2579e43c5f4425cac088a85e42f5b603813de06c21a8114175330d2a31bc1323278d356d41ed0fda0c36521e5daa270e08f5266ab84875eaadc4fe57d6264cbe8867c6de4e236d78595462122997bafd4ae532dbe050cf258b08aedaf603572e71e13487c62ebb6b2321603afc51e75e10b89ff1ae47e95cee16aa7b86d63113781ddd64170efcd30194efd9be72c26299f848bd9e973cdef65346d9c337c0ec585bcbd9fc4af3461e41398338c96f0ef7bd65c3f149c6bcb20b42b8a30d0eb83a1d8b5a76c05fbd4b1791c128ea1c8c3279c2961861610d9c5dcc913c75ac702be108ae85dbecf1a00c1bcfe507a674469c499556147e359454b8efad2aea608a456c063f8ec7571ff1a26be45a3e7d2a29b6b63f76f066fe0da188e2a2d765443aec739fec934acd09256253c958cb6edb7ab1b534bc779495d303bd203330d9d9951e2625b9164cd0397d914f9eef25eb131f116cb836596599d676b56b0e800b11c849d060e895ed90bea6987ec1819b6be18c209c529bfe6a4f12641342839732eda0f445da96b0573da3cdf8b6d68429cbec8562ebe3de3cfe2e69d6f4fb4cd4d4a997372175d7608b228528944444bde3148fc2cb865d7de0ce8479ef88f1b244a7e1853b4d372d572aab1c2b37c5a1b51cad38f14e57d036a561672a036a0c71cf8776a87b9c31bf350d4fb709bfbc71e07c9af3ab54ef0430c39430eef00976bb3bb77648bb2d65cda88b76696b3cf46977a2e1cdacb91b705a588648d15e3b1475dffd47832d0f3c095515be8c6737a0b3396c559f1df486fcca45128116da95f5243f4b45134d4ba9e6a9dbdde5e413a0c614b4c0fbc991593e4d92fedc92523c507e189570759438c1a8369b0775ce74c89e9b2d15835b01c86a931746766020fdc4432b9a3465f5b082dd9760516c1ef9c914edddd9f5e8e2024bf6759491472e88495a22d667e81ceb11f14e2e32d5ec722e98861fcdfac941ed15c0178118893cfaaa2079a51ab54740ba673196c5469f99be3173284c405c208ca17903aa77332c79c977bed05b061e77ec33aec0f727e6b9a6257523aae8c3b28da6199818dd54cb21e2913f53f9ca2b3a3c230219e980d7062833beeeefd079acd2a7bea2429d590ddecd32fe22a5f77198645dd1bfd3b6d7429235382b791694218dc63f6c4d9a0cbe507b1355ac1e1ffb7ad723eebd5b26734643675a282503696c81734c724b101798fdf95802f98e0ff1b605f593198e84e97277b91b804d260744fe6e5ae2fb544f0190eee2548e1694a9708e6c109b8a00daef26e71758393ed3191e96cdec7de04b6c65d9f2241a1da5052aaea511a73b013d35309f8ab69393a6d006fce9f3f5f95f0cef23e9d10494efbf65ad4da421e666b7ccf98bb7bcbaf4cacb746b5d64cb6dd436d110f17847b70a852ec91ddb7ac93da6a8becabe71f85f286f9443f55e3bb49cfbc3daa97a2ee1124ab2158f1b41bfcaa05b3958a11a3801c128cc2cf34dc4b8525a716a85971916c0a09706edf97dae935c29619c2141bc3a18d263bad47e61f167e7f68cf14fc3469e25d81a6372ecb0c21545818884c6f33a32705a90475ae2f7252fcf3afa87ae0b9b86cdc4427614198736e12bdae8a1728642ea1b820309387f74ec17bb5f188a0b5a3e17ff3299cfb83323540ed8db812efa32104fb5d3e50488ee8421cd244bb4f2b50e50f31d16f69afc432632d36f6a7201d57464914e7b1b3e7cce595219427052f41ec9775db7b54631d1265d98291df471ce381e6c169aa20f74dd87a8301c7159dc86a2d57a5dbdf893dab172be8e7491b80eb716e958c13f0cc3d2f0c712a524c2f22329a6489d2b7960211193f57143d04dbd25759526ccacf1c9faf60ca02a7284875d4657c93d84825685f6ee84b8669c3f8971a858991d8c4592a44d5c74a5a20e846a90719e46832d05f8d3ca3ca51d38edd57ac04a4011d8749a2a64967494cef46e656d07245868fdfc26a4555754ae53b5a74776aa8c7099b17007c7f1ea7adecbdc7d3d8dd1dd9d8771875b90743b384bedd0f98f03742668503823145690c2dfce64fd5e12c90146464390a4476a41a8cbfae20bd560c054fa6e0434b63c61000a6a61dc9d2a8906160d8392451e3352ebe7508eba8cf9fa8708825e64f50bcf26584eb25c273fc83ae8385f4553d15933584284f92606d9fa83779960f2d212b03320fb3278f3641152f50728be99ae9775e01c06eb5c5f719cdcb756f9247f1901c621c1f2069294b35220641b887cf438e545a63651286181e012c8001884035230ea68ab1d260c16ef6ad63b680a33fcbec783178f5e1abb859c834834cef1323d88ead20715ae0ee99102978e0e8300c7d525e0baffbd63ed8450f38fce2383a0f56efe5b0d924bb713ff3a63abb04c8f8a1d8d34acad52d3b8267bb1a6f8619dbae8f14fa857185467d124f2262ef7914e14a37ed329259d2a6a40dd68d74ff800e04a260bcd381f2d5b53e98205282e4329d742aa8ea58c239fae8c537f7c17d0453b40e10d37a8a25fcfc13506db58437c51065f99568550b7ef33a316b7c373bd3de8c6cc8ef2c47b23ea6efa30077fd3c2761dfc40b4ee6e451e7c57c40736bb3f32ad366d5a2b3149cc1713abe0a7a4fe11b5bd4aeb6e7374848f0d80c085710373e33ecaebc18a74c0a3a26478f59c4dbaf0895f7e1faf9553c3d9accb2a54633dadbd85c8af29e2ede5efb95f5315f98f44be47bf8bdbf03abfc1ad0a0c87a88ed8aa15df7778977fcfb3412a3ee7eadcb19a508c9883448cf5b30e4f89fe6f091573258533537ec5477e7aee7c9d2235ad797c75ce972081564dede6199dcb6112e7ed058a5b8d67892999a92a4e0c97c55c62ff713b12bb4fcb9505aeff745f9c2df1afb1b88b06d66f1dbebe4bdd3e57f7302f630db9b0d759db470a76a55f62684349638b16cbc0ae70f4c8fc11eaf8531499fe3d1fa97387b41bb4894ccd30b165b65a96cf4338c5f6e7a65d627b1ae738d6d45597ffcde752c4905f233f6f1b0ac6e8476752fcc439cfae57b27140a37111ba7dd139cb727926a5c61d7bc2bb875a823810807bb0f09062d696a8c477b5c94f52da2f818f991596a93d5f1cd15daba550c4a681eded4186d2b8391cb3f804e1d22330d705860e32708ad9e021fba07d748120c82eb8bb636cc8c787ad01a8dd7ec9fde8e8bef45bc94f83173464b649ee7be16f1473d4c910a066c6496b8c5f2e280e53f7e344fec5df16052f6a01eed639db5d190e476b3b6ceb66856c41376d1ae12cc70984f5ee5f069e841e925eca8b08ab7d42be3f840678f3ab71c24d8f35e881cabd7f52d04bf3f12cca73a0b67c83842f7d7bee42f01eaf9f4d2cf24548e133e753135416ada34831e113469391213b018826043c2642986804704e449402bc3d00cabb18ab1c08317cf7161ea9254dc81001cc58a32ee21cb029dc5d5e543a4fa77e55994ce7740a1097a51c5200142231d2442be512e8fd1a9896172ab215917ff477c55c17a5efa0efca15e7f23281532b10abd67804823dc850d09ed91f20f5ba6f75cc3d3f0d5ba3e3d14ce4f23cfc96a4ec5a375aa7f02a240b2a7f86eb45b38e64af093e4bad862c788f528438f3541ea8df3c95c79aae34623197039f6e108dab0a749a3b94cdabfbe5c2063fe457019fbdb39099b577d9de6c1001ab394a9cbc3d1e46fd379b0e4d2d4e729558a922de78a965e8ae08e0deab639e596521c8eb68d50188d49200f34ca4ec8b948d8b80cbc8807e08fdee781e238bba60ab6e0c580eccff3565e12633d13e920f00f0c5d351fa8df074b0abca65473db36319a8ba32c7182c07787c7648ccc7744e166200e7a9fb67bf4a417fa892ba140729c307b980003e3ded093a594d64ea6e84aeb7431e297e6b8553dea599101b2016ac806c7afd355807bb29a7e70b858c04ddc4e9bd1bb208ba1d5eddd5c6359ee3060d1c17557ad125659989ea09910ff70f172a67b9c5915c599676dfe6e0f7e2c57041146e83f8843ad8c202a87ea291de7e1f425bffbfd2b226372e238149f4eb4d8f1d7f7ef8e287a3f285ffbf15249569f0b23fd076e15ba8a97362174c90e7e8cdc7b037bcd981c933f5a34d3018a03886d44e563b57ed4c4cc07122428d9ea06a990274e28fddc1382523676d4bc5bf63b3a1dd8ce73b73761c932b4bd69d8692868748f121249007d9d648acc55f5b7bf555a08d4fa04100034ecbf3fbce3d84543fc360517c7b2d9de8b5959b01568b94309b2e2483829fdfc88059361dfdcf31999c92e3a5de7a1ea589a8c990f521a10418f8e29f67a248e68b2896ccabccd1d81f2ff243c59b73ac05a5d174c6b5f457270321cbfbbde8e6f95ea164db850f9c0ac91e9b0ef8f5cb6664941f8ac3119e9b7bba281898f29e38b013f54f86e70fc35bc7fd1718cc3bc8c0b7f791a0f03575c4ce05be8d7bd4786ad395c5e620074f9c27bee80e833383385048293cbe35c6a52e72c27c49df9d79c41b6316def911dc77061bde70be40ef978f6e7ba272ec9bc082941ac14ec4f7e04232fc847875844ea13bbaa7e634e8a9071a29a7859e0b7f50c77f76d9debed92b42c1ffdf8e63c1c8717e72819115d4b5edb0219b3f29668aaef50ff90f8fd21537d51a718654f391ab0703dfda07e2faae7bb9c87cfd8ea63ea9050d459c53fe196d17f84998746bc58ae1681db6c301de0abd987fdc328b659d767228b9e92db15b940a2e7f3b3c0e52e61051664f807ae5b12a2fa5c9c801069b3fe16198e2c94467e4543fd636133563e7b786cc84ca073a8e8887b4aa761facc2808ef7a4b85270ea3a1c751b15cec94042bd1dfcfcf1a852cf6c38038b123a581f8809879d8f42e144bd6a974ccae67b12d89fe81fd012ab5ed6e70e7646749530b99740e9872cd3ed3e195df7f0dd36b309ea30bd5bf5bebe184c454eb3f8d370aa869d5a7ada3c03d38edbadefa68fb5cfb7b92218d014ada7e77d77d2e15ff4f1e699bd4209714d9e075127e235772197b3f3eba39ce3b5e813a511c7812ffca5b36e9cb730a1ab17ade56b4eb3c69df5b3292ef49716e1d5e5ca88d3cf367f133898eae7db92cf8689e070126477d55700b713e2bc05ae5184ad37fc6a3bda0fcac4c447dbbfcc30df04e4ff8e9e8c7dc01e452570f0f78e92142891995b78ad43e870ec49e3a6c78092d432affa6b026371d8b48e472e98a14fde10da7a4c4107708982ff97e2a3240834309eda8442144690d54a112602fc264f4d71a14e6ff99eb3ac79b5a878aa689a6edc6cdb69e166c929275133cf10ccba3c7e3f99a14276306ae59a49969d6b07f8bffe039746418ef9a65161da87abe90d5305275608c75fe978eb76ecaa4a5a25590da31acb02dc0abe96fe600417b19095da417e6d4ccecef323b6f560fba1fff607bd7d9009f6925ff17bd620168515ddf37b81fef470860bebf83d5f632e83ff7e4b48ddfce8946239b14f0fad0bc7b927e4b2847323e5ade083a71c8ab8952bb63372a0eda088d343c1cbfe2b8765d594f484d719ae79ceabdaf45c809ac102c3f44ed872c21b38e40c1f975e856a7b136bcc5362106d356bb34504a893bfa293dda031207108739f4a71f5d446b0a25538f8f53d6b6eae1b62ed32a5b41716ee6435c0ca61640efe4027cb041eaed0bd2090a36e85d8b7b7e215d619b34c550d7a94cfac5edfee87dd1eb8842d32675c42cbe78f5e6abff8ca7a775dd494211fdf3d259b3cb4ffe87b5c43d4164ca3598c93478159b4c0d4232076ee7e6366ff18d7d7ca31603581ce29dd5d9546d859642f5b3cedfad46c52013b810aad078d905b7d9585e7cca0cb6e70ee81c38c22d652836d3c5d4c5b715293bc357a587c3a28025dbe9b78b2849d86763a8cd515ee38825940649236de36d77fce4a148b25c49ffc671f21687c8d13b2c1380daab54fe97fe7fa470c4d0979538f3de1c427b383c2952713f58e7d74a40fdeac18432566b8c59c2617c3c031ff0436e90cd9fae9b0ea2217370eb1d903da374a3b9e9f2b91bd757a50667ad0d31be7b0dff70c935b8e3a81f2ab3c96600d4e437be9e21ce30412a2649e3867d7cbda749a8d3e88aedd4f77d8ab33ea7b6619849be75f000db7330cc3ae4bf65da0e10b2af7d3788f49b7b2f90f3c38325e327fc202e552c6dd9c7810ca37639229267972405df61396d94327671f37d7a8417f78466fd09bca7125ad9e1929030c53f1424bcb655013ec9fce8f85fe277d55c20dfaf5eb258325b63da85d05eb1ab2b9140f51b8f103fd5d03c79fa11efae6675ae79de8d364badec639d20b9e6f8f8b9efd31d047708ce28a3d9bf7aaa74f73405aa14e3604f5ce7a9495b1b0b8b8793fbb18cc9904409fc3ffb6d43c7f69d831567cc7a476ea72134cc087b2add33dd293132051e0c60d7acac8db68b7de6c1d3075fe02ea2b85040a26c82d1cbe9322f7697b6062073d720d47e71732ae84b0a813c95c44edde909a5aab6022a68ddd209b25550838a407ba1801ae2d135a6586079d0e02392a1b8626a8a0486316f3ded62c4dd20107fc3b6678d430292e9ae9387fe73f6d9e677a0725da9e7312497222d0423b712be12da9d4eb888ff1880a9a85780037b9c348fdbeed9adf8ea5f1f01f660c9878dbafed8bb92546bef366ecf004e9b9cee19ec6d43c9ca16b23f69d018606a4b83817606e1dd3bf94d58fb7a5f25fa0a1c620372664112694e44ad04d4136e8b3150ceaf15c628f25de84e88f8a4a1bb0a87ee4e60505c6928fa0816b3c69d0e45084acf21d0c51ebabe620bd6e71a05c3e4d506f6dc467bca83411ec3e0c757ba5141fe56f9fabd74c2f93d51f43763df01fb647abc0cdd901b7b8144b91c6f6755e6b8b5ba36793258135b36b4e6803c72381309f6104eda46f6eefd1f034390a830651e2c2900f065c9479e02fe2498450dde59a7a319ac3c547d7b9de2c9924af9279f5117a8cd6e10743c1df4016cc6da12eca52df400d87926b30228b979f4fd9bf3f2cdadb2ec3f6c6fe7e5369831dfc3134023ac31690465d037a1769f5b635e3501e7dcbbfe3229c7df90a4ee63e7a0ff21b5abd9cb8c601a386ff3216b880cfe24015b782d01136f280d80675ea111d3920c9f41c53da653db6f9583d29471a02225d896de211bc13005da4ee5eccd3201976e090956dd7f2d51c5c00e916148c3d36e435087de33652a0d00dccd4e7532083f80e3067f7f4f5953027d41e26afec679286e175e72b0f121f6675111e437440a055e3b9f96762f1c4a1af5d16a4f42357531533ec5209bfb8ccac6b37a1fef48921055328ae0c12c46fc59ce5d73866a48019dfe50ad678dee7d41a8933c64cd6fdb29afce67fb0099d8d7866d6eec2a7562f2b245f2fd9ee9ea8048eb32bd30b7310e1996ed3ba134e1bb6658ad323a4b86c1211b980cf4362032cd29dbc4fcb0d5083b3313104d568c1285db1848addc28fd3ab1480dda0e1605804b2bc86210c1ef95d3bc75ab8ec23dc6a83b259dca83984ce0696ea4eb48d7223894794e67d46d06eb334f9c920e5d71ac066723c1d15d156cae7046118bdce70336d9e6de48bcf1fc19260f5935fc52545aa87e949a0e511336521472025bcc588a52730c6affb5f3814ba82dfc6622571f3039f6953d9b669129b5b06ed55b3c6555ec5e4b297634f2d60ca8774d10d05985d57fad28a27817d14a617db5f4848e58998a35f91671149d19619e45fa3fb38f634c4a76eb5027a075d6eb81d390a84b9fe85b686621a973f2f1375bee0db2e290dee34b4334599c3fef3b2bff84efa80060c2c6f45ccd61a1babfc3e85a8be3a5e1dbf90d1bde4ac85f3517f3f512c6f5390570089a4209f22dab4abe6a989df2da67090ab77331d1229aee176b688f452b4f0d99770220fa41390832dc62ff727a4fd4954eb8eda80dd65b8f833222545d9cbc5928be6c89b32ac89ed86e708a626c0e7643e6bc7166251450ed3a44ccd99f6cca8a832d743bc3c0c91112d20c1c624b9571f6a2194f1a4519843997c883b69f029f7fc8b7c7e3aeba480f8c7b969f12dc5a0cfbe6be0a4dacffb323be67c86a75fe5094d7084a5183adf2d457c02ffda0058a0db15c5f6e91ee289f569e58927d4233d42b959e2de87dcad32154e9bd966a5406d93e9562ec79d0ffd07bf78554dceeb1f80de101639f0cf2c46e0ace71dede16ae465201c814d3152efc2cc6131ce0fd202bb16ec7245ab744b1e9c79c31b82ff0a8ba614581646b1ca216aa8cb101e0aefd4f6b58a2ff24cd1b92c32056c14e2c82b7c31e9835ab92d8e1fc86dd889afdf341bd644d5c5f2d286f93f4653fbd82e21020eeaf6d9d6b1e42c15d0b8dfb6d73391ccba71f8bc0c82e082cce1bc851cdf58a39a13c446f79b78ca8263f465ac2d80e4ad70fdd0edcd55628b2d7ad5bd8b606dfac061ae6686ce3f641badf660431fcaca1cb1ab49f223ebaa177276f8399ee32738d6338254940cb22bdf2a9da82761cbba0f9a65422f9e156f4deb7ebcc77d3439fb7e4ce7f82a668dca484f4786087fc4c22bcf9c0ec36259b546db033afc43475f194039fc5aa7e97725e8a7c8d2713c9536ce48e796ce10b6f89b3ae448f7d9582d544b59ecbe34b226f76039d719fe5ed5009ef738d17044cd68d400ce5b62dc113684b61875424d86bc983b7f2c22e47af0113c2d5395e8d6a725daff767e94edcdb05e58d0d21187cf27360aef78ba218ac4d654873ca7db92fc54842245d0957c38873177601ce8bd14b6e4f606ec6379b22f8fd81fa26ed7f3536b3e17b3f6d3cbcda2b68964780962474035f04c0f8537cca9562a455bb83d9330e72c8897d1ba012a901fca7e7988ef90f3d0214fe25145b0eea49a44f3c299fe6a4212d527da0869464fe1ed7b852b3b529d2951ba4a3da4164855890ad910fa0d864f125353b2892055401436c8204cacc4b9a55bcc77dd229ae2f8dafa3b299eb7a27565f29c272c646a9cd5e41af645e4203abfa04aa1711b15007823ade78e24c77e6d7c16c8a9dafb3b1cfc1aa6cb80e05dac3c696881829de3bd7d9591f5cb287f3dd30281bc449c6778ef648f14497dfe1310c04cee593e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
