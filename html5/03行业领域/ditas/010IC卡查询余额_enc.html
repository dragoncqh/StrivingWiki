<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e2407a6769c39121740c766aa6c76ece5bb88f45b05876f91a21ee9c15d783e14482fb3ab0c7bb0e91402c98fcc61b2a8173344f8821963170e4bc4d6d732b4e5cc76503e1279d5f46e0a60dc8f3d8a406f3f3c0e5e3c8cf59b71d96e8bc412a7efe2acb87ae3e286680c95379baca51189b4bdd5a0a7b579ae64f4dfc347ab0b1dbd10aebc521277e55af83dc66ebd1bdc3cd2f2559d72ca9d38db1ea638d58fd789f73a893e6a35a898ad7e3fee5c6b38103b931e059b49cc90e20dfb601f7d56811aa40cc0c9b145c5486f399ea74d2997975f3cbfabb4bedc975fee5d0f79e2795dc1968c1bf616cecc6c506b9d8ba86f976604b42ca85e36985e98bb851d8fea3845e8f32d15a5a551ac16dcad453d1a15ac1866bd5e15a888ba9d4b0759d87075f04ff9c0e34637e6a7a4776000e776008908cad4198f5285ed035ed9fbe90a861a1877e2fb9bcad4aec6cab65743ccb186f5ddf2bb160beb9c7745a3d9b6016a0f71ad798179712888149afd2c6634f8c60d9de92288f43b586c18ec873d48ecdbca77affacf78442e34682395e5f4825d1f0ba22520aa3758cf9005affcd41b9654fbcf290c2ef5adbf05dde981b3c6e063d7bfea268319a659a9c92bf505418d607e69c4fc03bff98c352784001ea5391c5b05a1980ca276c22550f3a9e46922b52e599484be339ce2037db8b167597594f0fa60e524da3def61a4c2adcd524ad37c89db5e2407c793a0c8efe925bd911b664d754e204dca358d6f51f7d0d1c960a6f1f51ac7062f2993e2aa538eb7ca55ad23036f1fa5a584c287141379662df9207ecc6b5d4f7dcf9af4650b6894babde54eb1730bde9964e043f6e6ce2539d61555b8cff68f00ff520e362640f6a068777d6076a1a1c5958c30fa101abc8700d3349b7addf13449bc587ca6a2254f4771b62792a978b35272868d0d3acb12f5df23f418f365cb6fbca4f6e1d755985b9fa4d2a82d6f9d98b5ab46f099795af99b17ebd8c394d61e8ac36e1851bbef3f060a02a6c9d57434511f4ecf1d555b4a1bcd68fbd0a36a3143685402254c6fb49946f9b512d3b0536a7d0d3f47ae4b43f50c85f4adc73746a4c814ae91a11952db36748f1891a3facd49814d711fae82541068834fb06c6fa2dc329e43b1f846d369d4d118750b54dd7b844fb9bd2609ac13d1d079c2b225fd0a4e88473ba06d8695d24316e34d125d91dc325a9a8f00c42d3dc2b2be3d087932371bb193baf357c95a31810ad7dbdf104084a3df64726f0e802d7e6776f2de30141f1d920a241d535fdb6086ba601579be58abecf71a17aed235f9ae6f66f16edb4a0e3cc229244132225719d2608879a551611bc2c68c58220890334ceb8920be2495b336c5d7c0aadd2b46727a86745b3e06abd31504573b46147c05d934b9c791138e96e87a4e5d87a169237ed10ad2f78162c1b2900476d644c0dda63ba13fdd5fab1e86ae5a86bab1d78bf4993b25686448c734553d17a88b2de724b04e70616b9d1b00c67a9419426d2a7e0b79e30981d9135dfec2bd24b88c56d1d736cf6bc658283554ae5cfe0730d1ed0f581dcc3cfab86e29a1f5dcd9446e7597936110386d4afb3341318a0e37bb9ddbb02e5c543c34f5f1c2d2a090da44b0065149470017dcb0cad68bbfaa21c2d7a46105cb8383cc97fc532087caa3029f7eb1bd55f3f5efffcd635afdf986064ab205083239c0acec6b4965dfc4d0c3708c7115eca45c75e4ef96aa041fb6bd8b946b141ad7c042a2897d902966eea82825010a9fb40685e64b7f12bd3cd7dc7705275de3aaea9be173f1f000c0a5d7ace17316548fd0f90f14dfee47b45c80b3e5550613e485dcab66254b96dc481b2b47e172d4d5108b8db69284827110e3d580a3a1cd736d2e649591a08549b80e6ba182b9856856e211250708826af49dd05422a816c0559ec24b7cb2dd6ca46373775395d3d2de152aec6a50e75bd198adced8a7ad50ea3ad390e551cb8a4823f3f51b2f660ea48a00efbf913fa3258fab1affe53e9a3d5e4ed13c629c800e3232fbeac3797b32d858efdca5f9a8c406f093c1561f7cd396a91caaf505cca7d1dcfbc0ee60826b9311cdae607ac1a5fa57819e6f3f6a582181b8e759e6ce7fc15bfee2cd24adfef1fdfd5bcc3472b1226bcfc9fa382275d06a59bdcc4c697ccaedff52587817ef036f55c07fac1b5ea86978bac48b66f617bd2732d2af0a5cf0956b057f9f86d80379955720e22c235ecd91b701b221c4931d72b55075a51b6e23955b4ed1e223b4251eb9f716fe09c916f4dc40b3602ea60be82d8ac54d61e56bedf31277e96caee33e4e1a3394f4d7959f3cb2c5ca8632d78ee01655a8c7004ed4e1a3d1ec4816f6b3422448f6d2cdce6a1c6020400dbdcf3d58e6c25380cce4c1ffc04533f44ab40621777955991b6e301625cbfe98b6fb5cba76e4ce410621e7b7bcaf917b854ae224b91970df2e2eecbedbe63bf10e16e0a2d6d764743f428ae266aff0c6906b0ba1277f253d17ea497af783536a949fe12f72561cd1974d4d5610d89389fc0b8a538f194bad59aeee9ad8354b38ed6f94b9f8fc1772a4a0e1cfe62c7e5ca4c5fdbc903dd1473054fb17df3b98074748f6cfa528ad2016a921a86babe316986ce4dfa8a9e727eea29d666fb8970ab808fe5d234d5cca90c246057c465098e1eda168526c0f2209d31493d5d75d8075112f871dc407e52ba5f6593970c3e40bd2bf8db9bfa6487ca47bb882092d5a419c9020ebc7b205a178c713b5433ff155ad227927dcc800d595bffa3b57a9ea789cdb2ded8b2e05b72a8e54cef4e86548f1759517d395116f7a336cac502acd546a2e4e1874cf6224cbc0634bd08d5cde3bdf5437888f5057725f6e2ffc3f9d814864a2e102faf7f01cce71fba8956d9a4da2bb2f672a079163a6d415367014a8760e8e00dc82b4cd14a9e6760d6a95a398e5303e5388d8b172ed912f2d1499da29508322b460c35ec51dbd84f431807c39751f6bd3f22992ad21ca7be56f9d7828f4fbc8ca0c20d8ad23f6d38945d320047295c7a40119961d2e4c0ac9ac6cef099ea9ec70769025212faf64bc9b28ba6f6de235929bca0c02942f96ed2c8a4b1413bdb1c040fbd4798cb716de867db23dbfe91d725db1324f5920ab5f6bc2edf5fc2935412a6a75047a73c5e2f38609f9de69a82472dce1b266cf49a32462fc380316439b724d7a52f7d5a1f22cc1f61575633942ac91d329ffaa0a859ff747a4414612c36ae94e1069dc5649dbb8f973b6c4b362b09aa9234dd9004763b028ec01ec87b6852095c521f9793ed987d4c4a5148bebbcfb94d303a3f8dd09899507849da2ec2cc60aa3c55cf90dad34d3653de1034f0e4007c46a85a632d66130d9b6df27a39c9b1a41b047b611e17073ac07b06b8cc829107fce67497fc7028fc4261373df3ba7859962bc5bf701637760d061f1bb067370ec4845e3df4cb4b31cba15feae385e0efe2ebae0721d218e895efd12a99a8b21a66d53169f68b9b1a2ccdfc92b77086a7b0b2a2c9afb39a8753a7ce237f1b6c09b670e38a45360e44f12d333a78e174640149b0ec4fd49b224d9a98b4fbe4e6595774c86f79f9406053894ecea1eeedc91ea1f07d272ad78c373c661d6f7bf376d766d7d92cc3067aaca1544082304f20119a015860f4adf7b9e88873d4dbe6996ff08561ba806e799800e3a4f294a801e900696118653fbc2ac0d09bb7478a500ac6353e26a06adfbd9cdd2f5afa953413a56d26f49a2c655369bef01eb3f3190bc280a4ab451d23ce5f5afaedeea9f6126dcfa9e15550a5307c4c9a58ea2f91c54ff844e839d0ea699ca87c08b9f4ad4dd11479a35b92806d7680a41c42be74fc867d8a9c88466c3cfb607ba3f8cb51d67f1058bd7b22f577ae3a2fc0909b196d229fc3e5604aa598aa29d5918cd253b0474bef73fa0de08303b0ddd0ed14c0ef294aa97f455ff1e2dbc746e67f157aa7371ca453f0bee75aa38fe337935e9573f56382520d51d6639ee3f7ab6500203ac5b5165919a305f8dadb8a8f7a233a70c85cf88f33ab82105d00d20517be6b9133dc369f1222d8d46cf12f5e9e1c36040751686b9826ab5b2e2e6e11007778543920e25691299377e68efc7ee48c1dc65353053b8fc2ccf422b61f5c5a16f7cbf249ca6f633deb5e66b09f158bf14d17d80a7d1101f8f63f6a7b23d157e57a604fffb624fa7b14101fc6908a040bf717d678ab29e37034d239f4c61a4d06396f0f643580cd374542846208b75459452da81dae6438c24e85cced3407784a3c0286bfae12c95ed3d18d42a620a1d3606108aaf47e12e081ab7ef51e940a6f3288d82f703ac2307ad13383fe12b174755fade860bab2479c36da6ac9193c4685258a2c6c3eda18009999a636a7a08a08fa209c33753d9c70eadc3f559402fb6602d55e0f404b6f87abfc2ae4e5bd5f39f6d749db26edcab285b8725a524fca8d93548373ea3f676eedff62bf10f72eb3b5eacaa8ee9f4be45c12a9965c5a60a211b2f3df71fc75729bf9210b6cc9ce0975aa32cab8808565274d85bd07d988e3eafc693bcb124a8dc23c284a7df5559336bac72e1e4610ab8a6f9309948c701b7880121d95e1a009d84269abfa119932eb8ec1a5c90a95fb139ea8420a67e7ee443dbed372f09c472547e75103fed578ece9ced4dd18640da3ad9bfc0062fc538a3cd23f2469af1335c5833cb6555c52d5cb4c2b545be81678235e7af0f961e9d81e1f9604244d9ad5c743c3fdc2b517c19133f91c85495d2d3c7377e15c102dbbf3451a9ec33f29328844263a864fe5f1512b0f5a67732d639a35c3424998396e7d5d52e24ccabde61af7e7f4c2023f73d1d36d6bff44fb7e3a4a943c8722376a856055122b462bdef516c6c129296e72eec5b5301299ee3e5d204206d5c7b92bd1ad0401e2c968bc387c79e05f65bb6be706ddf27f3f8084ac4e4fb10c534cef6c47fff4c5f232a16d5ffbd8559272e8171f4cd32031fdd84ba266ad714e88e663d57dc46015a752406d4aa0cb9a44667dfa8de5451c79db578eec7878434db5372239436d55c2e29ea03fe8c167904a63cadd746d5fdf44e57ce24149f844aa1e32bef2a771c91664cb302985c9eb11c55381c4817c95c33630bb76776de5b5cc5d3fd73ac6f5d5437e0df5f17a4864e00c1548c0fc81c6adf4bf7bf4428b6c0a865f687786c8983b42c3178749045dd980766e43414d3004ff76396e1d9c90c0591c2c3370a70e7cc96f92e38c4083917c668707adaf79eca5b0549d9e6128df8f84949104854cf058d1ecc83469523a72cd3fc63514eae6d8cffa49cb4f430f425228b101dc8724f71eb72819946a8d1e37c2ba4fe4609475e16f61301868c6899cdbc6d50ce12e5701154f76344a849d830cfa448834a9add9b2dcc83082c82f1899e0bea301dce0b628e2fd93f8c66c4eaff7ecae27a284f7413f0c1b6247f4bf845f2766b672f7c6f9a0420c148796be9d3c19c827096467ed0086848bcb3fdba88794f5ef0fe4b4c82fc88330ae92cfb7829e29f8b8dadf9094bd4834ebd3e034de14ca5cbc104144286a88771119b1fcd3258477514a5b5ad33faf2e7d6007c092ac77f47b60236110db1236a4f5f2918275e47b94cb4d63ec320d734d74bd7255e3a3e17d50d26b1019d2bbd699d86d8804d67ea334afcf6604cb2c434f522986dffb1c1a3a426d3f09a9cfff87c291aa7c54d07ff18a93dffbc0252b8b68ac3ba1cc6fecf3362e8077e08c115f5b695740a5cf0274750d65a148c1f67807ae0ff205c28802f977f65278e945a0b0f16e71d8db3691b959065c5060a5ddd89942f5289c102bf9cc0c2f5d2bf8878eff29f5a10de4928131ddb2a22db1d051d3be1390752ba5711d79f887d665a9b1223294790a483a43e89a2557f8650ef5cef269fe75719889485223ded3ccd8aeab0275f71ce934a722417979a2993b847c72e209976d04f42b118fc7f64b76bbd65e05ee03bafd28d28d34fbbeb71d356078c782c5a029912e2176118eb2783d23f9ffa5426000fc8a37983c6619b37c4a9f67f597a555b13a9a788008fa37bcac44746905f65d3b00da395d66b2d2f47b83b9177456fed7d1f0af3b0ea9a7c7813ad02a5dda51299339abe694c37e5db0040e28055737fdcb64043cf5a815e7ce382f84a59b9c77d01ba644da8b67fa05b8c4503d3f66f260886fd07316bf7ac94cc57f779647abb1b36ee08f839327d70c44369bce2010b002710e8c5b4767e321705cc9f81f8f97f42df8463983ecfca8de736bc658329f302c898d1161a1ff0dee89e3ea69d10b3152cb6d71668d61860552be3c45a33d2902dc415f3604904ba2bc23ed8e50c867bdbb9bbfda6012573617b85358af5482795cec13c1b56079fce8fcbcc0cc80cd3d745f86b73c0f543b0ffcd5e09292914f07566fe0a305691efcb5a4791cd80e2f04f464775d7a0d87055d8e22c6c62a46c4fdb0946622e485341f8d54f0f36bae4ccbc692af453a43c486a0323040fe92dc808056ccf00e7ee9f26d571373cf4451a3acedc4c51dfc97335b99297c98c8ebf3f3e7336588739882f4ccc5e05b143c8a2a4fe935ea829606259b31b08c9250667fe43f0dd5c2bbf7103f65b02d7e286687b59861d6472c6ac5a0d2b839e6a3b09607c7d2401522a9fdb4469ed1fd6c83a57a8fa8867e36afd4853735748bec3473b31bb7f2368f066106c70b6039ae0c9f99609465deee85a770fe91dfde0026cbe671cb529af1f5cddc6db083dff61fb6049e63d9c8848e60aa205ae830393d8ff35d948ef0afb72133df127bbb0e8c49e033eef605c3867ae039d4eda9915355b89a7904ec476f667b253ad6509755f882273563e3f6b8500bbdaf26b0d9457f22542d558ed28d1929a8e572001d03a37d5362ca169afe7c3d022eac23dd96101e265879d3453b3ca7a0ee1e33f470f365e27f743f1cbe5208975d377643ed4bc839e7482f5eebd462160daf8ae180c0462936fde99fbe050e83233abaccbe9d7aea5235a4b27085943f316f28929d38e8bf5e086af638b221c2b0b864e2ec6b37a31f1d868f43c3ce11195758f949db24c92ec9c24b6027983ab20a7120a033b6ae8f8b951b805419b034517cecfc1c76447f516a682177cad5e144d3f0a53c186f82a47ad9fe2bf4f397fcb651d9977b374b111b9799809e4e6faf9246f8a33486fa02aa7f0bb77ecc0c4c7f397854f8be380ce4c9ba9dd1db9ef154f71165b8aa67ac48e87ad39befae62c1561e5418fe5e1b89a1e905254d570b1be82988661b2388ee3512272990c59d1e7cfdea220c0c383b266977b39d6b2122e1ff9fa0260d45f1cdb93f711b012c714b3dd358e73964d13b73c67764a7b715d872671b33c5be018e64521a01eb1f8d452d6437c9296c073804aa0c27fd8726be4f2da563aafd0b6a8efcf9c67946b706357e0b46ae89e53a5564fb6314ee7de72efca9838448e2a0dd96f5e351aff213c691f9c1033f1f77ad64ddc11aba84309ebf6060bf4b799d07944ad64d2eaea7446ec4adc2c88416ad43e856596ee0eacecf013272642557239459bc8cf93c65df968e71a00070e293a596b5c31dcf02aef7f2518de561b035ad5c85bb601d4efd7bce3d6553058559f8fa7673972cf50bf3a8a1c9480d064cfa0d5483f6de861cbe334efecd8ad9ac1e223a97e27662a6cbb72cb445e6edd3422c24d5b9ad8087b9914fcacd24fb79b967da632a7bbb636ee70efa57e4202ec8e4537caecd6cc2129481a313f3451c84ba0025cb183f89f9b15469843539f39eaf46fd48b24165cf7188929ad2e551559222a8feee8393c58d69aa0c8733592b861aa49310cd09432e591b3413f1ed674de489acab8e9f6c68759b2aa1b500553cf9005fec3a2fe49567188454e0cb40d23564b288e38967510bed4fb61fade9a6e65bf96f93b02b6320ca23250c672b01b2f0cf69ab3b84b00ac4edfed1a3f47782ac921175d9ddab3bfc12e9bbfda96baadc4469b0639e51a8d7b0801a0db72bd71a5a3e2aa29124b2b9290b152fd0d48bd4c0f1b9d25b6025a02718c05f88fdcb6587108e0584225b96e98fad60d1221a389c876a9974c1ad3707047b982be75aaafdcdaef6238a1acf39e4ca9c2f906b61547632d1ecb3522b67a726fc018728132ad76d12b84b3fde69de611cf5330f646d66fb125508ca25b8f25bf77fc50057ddae595c4034903525b95a8bcdcaa60d1d5419bcb9025e3753a6657ebc971f83c258754346eb92e41b0ace23383fae13c80135c1a79f11fa6e2b2ef7edb9a8c5d7f850ca1adcd4135cf3ed703cdc9128679b1b250891840fd22f73252707bb384f0e0c6b4463a1456172935b0dd39c27104cb3a38c48ae87c5934580f222e027ae05b7d66439c200d535cccdda09120f06b73282a4aba9c23e7ae0a32babee0e726dd0fa7ab4cc079025dea727a9b50b498e7f30988399eb0130a9180d613b1e72b966f4dd6173f0f3407fe890f1fbc0a6a5d31ba2f1fa783acc06e038a096aea779ec406172741e23aff64bb94e48c11a1c110e7ce7619779079fbf974c3426459f5bb15982417f209cd3d30206698d90043aaa61c0a81bb1016897883b9c1e43f3fb6edecd175e22f16098929e9e8e0b679d5b61884201d3550c61b717461ff44f35114eaab9bd90f0e80d674539682a67c383215cd8065d10e27694811f176933727fbdb75483b6e4dbbc00277606eee2c8e01fcdf44d046a38805a407d648c5a6812283018b12881cffee207762babdad1c0bc49c264ef09492c28bd94cd27c0d793232a2fe991422d6e6aadb4e915aa95e19e7b3e010c33b3053ed26ca7296461d25437eb60d76c6e0a1098705670f4ede3e69396686ceba4d58db1dd5b866b2c6f3d9689f3ea4b421f1d0acc5134e641db6e6953f7b4669584d567011779a84399c7b9c10dc41894b4d32c58d4000321dafcff26f61e33879301c00dc878bdc00691a5a6cec220079c3678ffe8fd9c96dcbf1ee6fec563cfccaa11245d3e9d4d2a0e45d5405fc6bea0b66a5199d54b03419b26e23d5964cda9d32d66a37525bce326c1f882b7bd8b88fb93d92bf26d5c92da2b7b1705889af5049c76a85077c211ec514469ca4074647b9fba71d27b34d7bd885fbf7c71627c06ae48a7625da6257197baa49c1c51f22b66935676db4aac564fb15534d412bab74862000a50c98e681b58d38049b4154d2585ad21809b93296397443b2af0552a5e2d4c7da782132981eea7f82993af66644d2957a2de82a6fc2638a425038df71a20837b989131416abd44607aa01c1fcdc55d68f8295b9f0d729407277c859a43436de6d7e2834ef896933baf5c99fa356648b9b865edbe73521bb602755f4aed4761fa334ee33a513950810827bcc4fd8736025d5cc92feaed98a910e769419a5a849726dafa53d183a1cf5532b4b5f5e8200f76d5c9d29ac9162a25ef7f026d91503209a0c9fb3d8163eb58361b9c8d079d8a9691c4829878a136dccfe938c23f40017301d3907d46edca3f63eacf18e0d197f6d4048fac11899a264cf0336969fa9954617f0107239bcff34ba8b126c78f159200b77cc9d243bfbedc349ac1f37117f7ebc866e143c41d84ce5a33f1f1ba1d73b16f5fa35946f73008264470d8ce0c72a9aac956f052fff364c02cf5122f810d3f6242d28169d990fae2f0f24bf4eceb8188b05646b84e3da8d2f8108dfa79a2c590c29b2e3d337eb26992c81613aac88cc3451fff9272d7f90462c55d11f1a7c23749048b848a0613e16c488dd9256fcac7b4da8352b51e715ef2fd8b27c0a808099a5a61cd98b511d46281195eaaffbd99e6c7da20e9bdd33c24afb5b2118b32a4300926fbb14e94cff2740cbc6504dc363fc2a13b682edcf46ebc940ec20b06f45026e368c3c97745811fdc10415b47d85da4a1786871f98f82bdc2289807be7bda2ca1a9a819a03cc55e1291bed6e1fca5f564705d8d6b1c3c5c5ce34140f720be646e28ce54675445fa1df7631f9e336caf52ebcb237c34b2abee442ebd07777af3b2580f8b59de9121b8b71e7caf21baabd4147a5babfccbbad96a5b74df128cbd7789b072717d5828c7b90a67aad077408d1d5eac49a1c3103a5ed2d7b0a98e9057081f04b5affa1b12ebfe44c53f31a4486207029db8bbf254cd6dfb952248864a68f534c5d78a9922aaf5825b9b4df1fe1c5c406d336209339a15ecdc4740a7f6fb4b6a9da32342247a29b3fe8ea1f68267d23215a421fd3ae48d0629fe525b6b006185aeadcb9e289f86c86a9dca45d16ae03389bbc9ebbdf2293fcdab35f9afbdac02c3a25a280ffc4a512e11365ae03cd6f3a2de3786ddc79f4e4ae30dde35d7ca4228558298f4da0bbddddee29370b5b0471937857792f5445112018b8c54e5fe0b5e6ae2062334cd9f1abd4b3fccdfd325a0293aa30d148b056598adcac283589eb88523eb8f7a23027a995154a51920daf255f08e8bcdbb5c7dd0d317446ad0e264d3c1b3ad81d8bab594ed014983703bd33d1d293d80f6d1cb5b35e595426acee704394292fd035f977a139d2342876ae5a1ed6e24df3355612fd95036278d7454f3f7c51b305d9a04b01b34200714f55da07f544b84121360efd67a0211401f5dc108ebfa14d99a551f59d847da543c45f808264e2b8aee6f233ddbfb2c86c963f5618e93e66ae36b8fa2612e1bb71aa13a65b354ed982c5a317fe276fa2f506fe1da7de4a3d71da199930dca504847825fc2784ae063f2837a7ab5f4b996d44f581fdcd8d4b82bbf70a63a99b8974314eb9cb4b31fd86ef3ba9ebfdbf6981734933ecbc01bd0a86ee8b079f859419b7156b437292456eb53ff1d107a30c319f8c7abe774850e7bcd34336badf36d509c2e466c9c14fe6842bc81bce86cc70818b057c3ed001773a63bba8b13e970709e3482a97f70d24f1c1b2f0e987730c53cd5a8fef22d37df3f5c0ae97b82ba7834cc88bb39a104fb2556952e91b627a710821ec9a014f75db6d94faf12e05568dc13c9f0f6ce5e7315e2b2c24ce9d6c4b0c41e56ee71dbaa196c127feec089870d5d41c81bc66700feb4e031b791511fb60cbba830cdd366a2b642e0852c66c25c29dc78fc9ab38c75884fe4a09849048ef18ec1c9cb76e3b4dbcf89db4aa8a21fea7383c9d5c26687b42762e2c519ef0cf47ceb83f10a1768de92fe05d1fb4aa75a97805e499d06b01f4f63b4b8c38f49e4a0e1abad3529f3b0878a12e18913cdbd2ebbc16cf53b8c655613762d4c2d0bdbfe50854a1aa44c138536dd6b4b22eea1a94c250edb1cc764b4de3caa320cf996db1e38c24e2348bc6840886f793e922811898afc10b5154b9063411ae643f4fe2f34a88d98aba8102f38202cb0c626a55d336871be5ab5ebdca24c16edf56fe972631e15d62320a908088a69d80c2599e32204d0c5a046f668ca64d25173d351e3caa508fdbb679a83c4a6031d3b242c42b69edfdadf4f8853bef3367a4a4ac0877a6238c858aef045b7d7ab4861f79f9796a1bc0d3724393af18da0fcb1478cfba346096fd9ae753504bfd20562d1d0561a8a595c8c39beb3d9e8bcb446cc2af69d66e16dc302819e2ab76154225b238589cd9588aacf3f9f2ef7c31f62cf63e4e903b4bd280c2ec2342a6199b4e04dbb3e403451f9a85bf1baaf41aa01dd1d354194988fc32fd002713999859f3c08d1bc92ec9d8b83ee680fb1013f4e35220ae38656b6b915781dfe04ca9b4a74e503a443c2bf6638a8129655d74da3b5e4377eba43669ddc72e118d70c333302b6d0122fee937177fc42bb52902dd60dbea04235636137c308a1376f2d4f8d33820dc674b753daabfb86321f8dfcf76d63af3286c34c29376910ca76035f07cf1b53bc0c83a4852e5d54e67a9b9e330f72914b1969218b7ca81c6a71142118254ef1d12bed8bce26a6fe7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
