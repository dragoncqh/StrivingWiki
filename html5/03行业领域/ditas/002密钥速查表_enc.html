<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01c321707af3996849542d700b0ba85995a59bc6ae041eef4d9bf7f36bc94073a4384233aca8bbf0d8a37292bd34a944da29e92a470d8222367c5508e65a380a141643684f9c49fb4fe2bfa0111d51c66a29925fa7326f0ff69651f75c3e49228e8cae0d87b2316e5e4f37f3104acf9f2065c807ae57ede1ca309ebdd975b98fff67ea8eb80a1e69cdc67f3d80ca2ddb98ff0d65ee77dd736629d6d8a582d82beb820667ecde71f0439c014299a6722099912ecbb8550a0fb3d0ad1111bc8c1cb873a176178d6897f60dc99c18f1cbb4d00b578f25a6c06f25c5176e8f99164f6b1eac2286b714d1eb6763d99be01ec3a9b79a09271d6ca098289a21e76ac1126ed0b889f5f76ba7b6013a3e90d5ab7dea42471dbfaadb3d9dd23ddf4e8c5a7ed5729a641b05c5b657a1f7d5131b9772caf37a84ed519eb104bc79200a7836e3aa5ef76c25d2d4be2c9a5fb332db8b0d3508cdd2c76cce1cfca7924706ebf1c7e777ca7e85181fbb1379569b70f561c02c44c0635ee666c86faf00a5270af3fb63b119415132e9f603e81ab6a36850263511a411a25e7f4084aed8c0daa91d182605365c2a70cfa5d9c7687b3c6a024b5f66655b23a64517920e38349395d6b31ceb06bc424f7cc427a4fe35ca8b7b8e050cb55953f6aaeacef20f539b09bc1b7ec324cf6f85a393acdf8b05fcbfbdfc151888cef7db188d2ed8f593459ce4d3744e8530fdd6696dd6ed0db49148671e082ee98497c1ac95bd70a99a1bc01648749cc4e97ca6b6a4d80fb40ddde1ca1ff71a422f01befed5656aa645a97f31f457f3f3fc30bf4241c5e5f14dde17e64c94eb2522aa615cc04105c03a42ae4051af56f20e549a7c5a7c42fdd5a2e7ee68c6da9e77bfa7e1966cf13d7faaa38edde4065c6a0a461597915794e3d835cd58bef74cde3b9038f38a727d022a01969a1a7881053e7f9225e0edf67f6895afde95039583eef4000402a34c3492eddbe88e6a1202886a3feb38d09eb6ce001d4c4acadf07661628f28bb6576ca6dcf3f6057f67c9ae5e3ea4542d860183fb16f9f11fa7cc72487bfd5cc58ebb39e44c9dd89b1e098816ffbe7c7666501e4b08d98453cc6e0c53a0b856ddb3d0e0da22e40846c7e56c2ac9a7ea4c100b030b691a5c0cc96a2571899c6019c91ad41eb58796daa4ac2e22724d7e97f900f4f86adf49219375876290995f9fd154e878c8b44f5a7317dab248925bfa2d71ac086c8c260b858c4daa7d74f53deb3fb49253ac8488fcb26b7fc2d17ad87223e1b8c01df8a3bcf4b5b862ecd820f5dde27f3f7a02459e6f8f12533d6a85910688441dafd2528753fba0892d7012e0cdfce0a4871af4291c301e1fb0f371bd5928bc7e0cb2190659b0043b65ebea4fa5bf3e74656e30386104c27bf10c41e9a307a10aa6a5cb5eed9f2f16049503de9a8776ffd116db584443306d54f5f8cd01b444defed87753c1bc327cbf7dbb61bd1cd10a508c18f16027be3eedf0866949b891e5b47987810eb13e325615f54bbc33761c7b52cc0d0824e7a35ab4fbdca669c17c8e8343a140ec3e8b3206dbb44105682e9f1e2264640aafcd7ef09fe569a03464d50cc38b233ae0c4286dd7db6ba4043d7f55b40374595a03204968e625041bd5a8d042d2b2d52b699ca71d5fe1e1010ee30e80bb92d3237dfec6136b72b1eef32012aca7e02eab74eee484d747e46844f464c12a11dbf780aac808d130f8adfaeb4dbb908233e02fad5e3fa701fff9350ec98de52b15bdebba9c3779d288462d78cef9073a9698bedf14b3c9f5ef8e1b598f5f4fa398809b5894453c48a1654e0cbb0c35ed4ddfc038bb461b32885377f51679aa68debbb89a82e939ae0ad9f5e5ceef16151c6c7e96356b00666f0f06eefb6acb96dcb23d4acf2ebbe11b9255dcf7bdb3ac1d212f48e2b46876d7e8829f18e505d79afc3d420e72c3a4d583f8fb94c12b5294ec3acdca9e1781f1fab8b97290cae9bc0571af43848998578d66a0bb0ccdc101eb61cbf4c35ce97ed6ff127594f1c0311934a4627dd4c40168f7fe8c78e4496b09790ba323c627314fc6d221ca6f95d4a57a097847da6c4fa9363cd5cda0d8e4986bcfffd49f81cb87b6c984faf0b2be8f41d2a780e79f1646c9e80c6c7bac0d41a744429f7cc67f8d60173f7fb24f3f0e59beff89fc31c9100e176889fe66cee16a52149509770850c74f0eb817b526e03bf1f4821c6785214ac145a6e604c5c2a8eec293daabd715746cbcd6b2a2d04bad81bec62f283612f04d1f849e8a0e909c57b896fa7c59f493481bc9e3cabb279bd36db41306fc0ec2c17b0f819f4eb579a56f5a7e9c4cb5a747cce57283063e7b474ced92770de84af58baa8a091c80a73486d66a81cbfec866f9db8bd22b8fff663c3ac02dcd749b795f70f4df6510e8503484c5057b74d524a5b7bb202f637d47987dc8e519a37f45c48923d085895c78ba6d1b140d55ecb1e756b676b59b80065b76b89a107dbe7e901c99e39a1a8bef6eaf9058be6badb8a176d278ac80a6c358cf2c50f5a46bd036dcf5d41a9f8bbea994e0c136834ec0522219516a334b860db2e4f1e3ed6113fce41afe095214d2b72cac5f631d18748d1594f2c44598bd6049d7c5948e53a9e6ec0e01f13876db32fe2c01e3787027cd49849e41667b325d5c1e25ce74e19f42151104944cf72dd87d56c0c31fbf0738f24149df587be015a7407dc47476f184ef5c0ede59bd0eeb816dfbbab809f6abe105cd23c8aab898d787174cfe6bd4a87d43fa446c7b2f243cac86652ad2ce9011dc43ae2deb7218c0edf256521919c4d81a6eda2391cde12f578da2cd944d79d0aef573ff4f6a5dde4b452c5aa96e84454dfdb2ffe14b2aee39e5a265ab9ae15844cc7c75b21c4f2eba0d8f19df403b86aa8454b16104fb3c4eead00932cf54f29447d69490a11da96fd660534ef4ccbe27a15ee331ead884fe6d99ff3042cd9fc8b7aab8783376fb9d9fb78a278cbb5cfecb6f4906e301d43427c0880816fb73af2b416a7c101bbbd17ae9330b117ded2afc14d986cf54d82c7524491e7c269e88a16708735220704390c6f3c97d45fc3a35679b5bf1f0c71e421e44bba5e0b40182c1586c978b019d97b4ecced0ffacccd29626fe1fc3c522ea333d5de6cfb653d895c4cbf09011494b9b7dd2a91a0e68a023f189bae64ad558cbc17dcbf14a77076d35a4f14fb5d37d44a5213f3abbf6d764bba68dc6d63060f0511d8457d5881ce14d63640ff4eb79effbe6dc1f69d3d48a38f71e8e9de5db9f2641c15833ba617d2dc1e8b3c3019357f443d2588496b2ef823e11768527cd1386ee4cd30f5a9922433eba7d2fa41c23fb0a6d1a07675a3593f8c4edc1c7301efddadeafe2f27836581140b9a6e70b81e51271ca9023a12c3c54156cb6b36bdcbc18eaf697a113343caec365f42e09facb4620e6f3b1de40a1e3e0b17208e857a673a5a3bed5efa064f899fdfcee4642f88965d64a4267a6c610e400e63367a22a3af5336df7678229d7acee5839759e539a57d7ab44964d116ae0216198368b8312543eaec9b6aee1eb3756bd722d27230d123e6e662a614717044752b6e0c15a4671c225e4837833b2d29389edbe3aec97316c7ed1da574c72661c2ed0ef57bf45ecdfd08e75141afa19087e72d85cf5f434fd86d3f784791ff298f4aec4ce74c478e3f1b20a11878a07c855f92bfd8e36e97e92552ac7f010be2f18b8d55b5bf0673c15ecbcb0190dd6df1d7d3f551c71c96d0d5ff7b98925585d6930ced058892a26479249c2467ce18f5df64bd55965e87c9e5415b36a60191453203dd0b26e9853686c89c3c2128a4711723c3e90e6cc3cbd208d05cff76ec9588bca06a54c3e76d39829949fa950982321913d34f1fd3d4ed5a0182bc7fa4212eda4f00cf4c88208dff8f22d322c6466a598cbe7afce122f5d9b37539c042dbd628ba734e7ae142a5cbd91e44c475250fa90041967d2491ee5e16cd4c90d8508443cabfbc06d3b3c30f58af42c1c31aa2b3647ef0eaf110b0940ae6f0c3890abf10249a3e6b3e5fae756f13a6867ab4e156b1f3980f6b4988d688f9385bb92907af20dd88896d49075154faaff0ff828922738f87cfdbda334a4b3fc391acf50c7e681b77d4f592bdfb99252cb8901ef54728b24a3a0b42d1d7a303e503219adaf445aa581773ff5302c537f80e9c7cd62ba82555acded54761e85dd38c22d5183686f6d3e3f6b93a422656b3d6558de2260b13c3cc78b0a776e9e6cb5557df4e439744acc07ef0071ec8735712e16895dd7f14c93f7909c1a2fa1d927503cd8adcccfb77094e1577710c8e7794cbd7a3ac8ff46d48e732b1d65ffe01f288e31a0f55d8684a9a454c1c0aba2bd9944f3f4f7722b4f15d6769d287a6a949639d70dafc487fc6c0e9ab7a84b6b5ef70ddb7e4dfca063e692a69e2951faea8ff00282b7945cd63124ad9b01f5c29434cacb214b275fe3f1b34baccd63ce75dd4e5c3927ad010b33be0945e8d8d7750c92960b55b17683a3c0d08aea3db6cbb357aadbb31ccd277233e803bd31706fb720420ab1174dd801e7e1f58e8e9e909b92eee4b2902a7718475a7da798bf97f897862f5ae257be4ea97a163205ffb0687da50273534b3db0823b82cedfd53929215962066076c66188ec11ac7591c96093029f068e9a4b85f7f1f8bba7fb5d2dafd45682ea2e0f2faae024241b224551f295c86b4881e216b819b3bfde00f2c55f1bb74bc60fcfa91bab75b9dc12be2f2e16def3c738b79d958632fe4acb857a51ac553b8d10602d7c599684cc848ef4afc31d650cb5b3e3fd6b6fabd89fd2362c5c27debad9dfc658750b8da2d9d344d9244148801c813b9240e06dec375b7b6424fe205652dc3796894aeecc70474e336fd5e718a1cd022ffb1f43aa61c682e426d29f0d5de18023a891b1a5e887ab5312ec9dc1e03328b702a70fe3d13e0d047cfba8740efca5fe07c5abfd833ba51b0975ce06828032edca3f290c89d54c16ab1f086ac31cdffc858c1350126fcaec4295c121c9273ba51b43df9a8744c61032d583c7f8c87c12d8b59c9bc5db641e3162ad2e3e474732eb2426ba071b5ec32d83ae95395831c2129d818b56c1052dac6e4f65154d88f58683b517887e111932bfb66506b05890778960cfd64ff66e484baa8572d2a0273bb79e20138e1f99069f06a655b82804f33f51b7ce67c897e219dedd4100a404dc50f27cb7d40aa9153d9a4182c08e07a9ad5086858271eda9abd97aec6987aa1e202f518669241796c24355942c616c8b3ae401971c8d9ad2e5dcc909135b00faece97fb431d3bcb26ee3f68f6856dc5374d7f6410b83b2be452406210e70762cfa95e25cf1029b4c3b02793c0cd1726b343e02137df7d0fcd0e882cb5d1dcfb09488f0efa98cb309ba54a440993cf682cc3fd9a8c495d6ebc80032ff8fd903d245a33c24a8b0420ea365d89ec11614110f2425c34bf4f81e5f199d74029dc217cd43365d359c43d68ac4620ddbf5f143be62060c2b11786f6005bbe90387023d9962fae60e2f05db47b19001a343fec65856a2a0f381349fa67c1a6f30072fcba4d0991b67f283dc33df66d99be211497752a9b0ab5cb55344001e5591e263360b3f32311fed1f2bf8eddc638480930eec384cd95cc0a91d25342e19f5951c2b4331c99ecfa132566a2c0d0106d8294bb0ea993e2ac13433234bf1576c819d363ae22b9ad04df61ec9a9f0e6bc13539aa2556a801f880cf64d0338445cafb4e71bc7f5d182740e2bc5e9c2857307319bb0ae7e2814d268eb98e8331845c943b793275dfd81ed9915fb4e9aea445b56616a68d788a51213f868e6f1cbce12f69ffc1c265a491c517ae7140cec917bc77abf7650a793a36d38414884ecbeda2a04030b20499f49f045fcc23ee55becd03df25cf2f29d587d0b4765ca34196cf49a2cb474054eb61e6ae6a6ea7b76826f57f0e2372f6f737ea9bd7cd07939d8c7e896210f2fc504b732904538447a38cbeb33f46e8a0e266ee59300b447ead9a95b8b820d025e54c56e500f4fc2b70229952c0b1d8ad6ac05cef6314e768a05a0f6bdd297a8b896e90d7bf5252b74f2d787e162120e9ec26c9934a760fa968e9d30e18b5273c46e2f4d234516ec25c28c750c418001eb95c053ffccfba5b3f4637b60e8bf9fd1bb4acc0fa9cca711d32a4fc425d20236be5d7f3e25a33c700d22bfd71bde059b3f3d9a9438200fe7a3a9d381229b944c795d49c29c0382fde018fac1a63dd95847f5a4f67dd5f6a7f6291dea6d3b29143ddab62e04492b3e58d76551f31a55ad27684c2916eacee9a1ffdcbe8b68b1f8dee52c87315bd3be2989e17c026e6038c13c26c323ba61da4e34a8e84088b0fe8b428766acf503529a5e3b66e0cb3cc8193ee7341972dcb430e7c36b711b8e4b504f58ec4524930233b14092dbd358d6620c5d4fa3ef3d59cd2b76f03b6a0121b8ccb7139d6eaed7b9659107e2f4428317691d104883f437159da8c95391370192376916c5fc01ca342b80d133900a5d441a7065106e7101838544e7de1d702db8a6ad4e6223ae6c9de343d714f2103a68617118f01a1a06091a8f1208feebf71a05cff1e5d4f839ad3b8f2eb1b7238f11b835b3b2b8ff314a7a049495b80b801f245cbe74ee80cbaeefd9907c8e5b604be99e583ba108eaa6a07ac58c7c2584c16f69e43ce829a55f08617f924e4766db4bf18189da867b4780ed206fa8bbb69cfc53730e97b77fa79a3c894267c6e93d4ec1052e96642346e0e37c3daa86356bc7fc1c9af0426a83c018a86e1eb507aa79078af8c5ecd5b1cf162a0e27e5ff11f9118fc99e4ccf448c2d88af2ec66e63d2b1358f9e681bf5da364bcbbfe94f3d220f1ca029d5f5a60e5533e48d80122dd98fab12b3ba0cc417086a2dbb96ead021fd48af647db2011e5577d763098675bbb92c670e34d3f0e8b946656842290670c11617d6c832cf6b754c5d066c32a4573782b2d3c3049d1e3b53f2560617da662116446bd0bd09c1a54322f40125390d5005dfee3f6416fcc4c7e441a70089228f01a054e0d22f5ab93a776974ab6cbcb2dc8672d3fdcacfda752b82c4a8601942d53ee9a89f5714f6cb68d342e2d9b84ad3d3b4dbbfc89ac0c9ea5342df6e1a88804062681ff8739260bdb9d1b77e093c6c27fcf3fed28427aa99b7365675cc926fbc7a8ee49f0d06dcbc2197516c62a0db7b846ffb05799f485d54874b92a0d5e971ff7a071d4176e62f08d561e227237919344289880834e13d02f4ed0a786a51339a9aafa93fa64a8e46bcbc36bfdabf9b1fe6f37d7db9977142a73d5eca58ffcc532791d94d3dcbe3d85352c131b69f65f30e7acaa6e3524a9f3e9265218c4a6f4fce590e98955f0f20503c1d7a1d18e1dc925b766210aad1ac6ab9f2c2bf09baf7403f1f1d9b72a1b75ac06f99da914f70cebf5ff009fa8a9813e95a82c1d4585f3b08cd1c7f6ae2ad17197760e93a894b7bab71c114f6784e6a2a9a3adc075aa5b07d0ab3f68398d2a783a29af89ad7e23dc64395a140ac86f3234d1262e00e0b9ded05deb4c2381feb55771165bac7b654b8cc5de865852ddfeba491d7d7e78aeed4130be67e53fd7102dae776cbc5522854bd2bd2f94eb53fb546e2775b0af02dca86399af14d3e996612fa533976b08a509a16fedbe68d820cbd9f5a0116d662261fb4c133abc8792ddf3874d591deef2830728d0e557d85e375699023f68c882b5d973f81704a19a26f94c1c7aefd56c9fa3988e4c07157332c143e05555b666a7fb22323a94b0383b91b45458631054ab2ffff258d5d91ca7ed602a7567c1bfbcf10ad49f649068595c5835ce9d2ac7396b600fb32cc5a9b78bbce437e525ccebe58e871df8bf6a65f2c390e9d0e74a6ba7449a0409afaa6849dd40536c5fc18c3239678f54e8a702c243696211039b098379ac992b0b6c08aff574f33e51c5939641d63d50e48d6d0ad4f97ff86fa35d216fa5ebeb3f62288991755b4e4150b6a2cd4ca7e11ff41c0e23601487f3bb4744efeb99b8a7202194afb8d31cadcb851e32887dafe75097bcdaf6788e5379372cfe511b85ad1da916815e2e3b9ce5fbd522d68745b2be325505a07e0a198082296ca0eda4ecf8e13f76152386702c32c3f62e9b51751b125e8f4a71eb1c0922978eb0715c969f44cdc4043eca62da170c0eb33d0ffcfafc7a759c743d8d22d604d79e4170edc2e62288da20984fc24ea72b9ffc870f039d263669084563aab569d36255e8b3adb88c06ff2c4aed73b1d958cf18f2ac6e253924e3e8959fb7bb7b16f5168fa617a51447176aaa67ab5cdaff527c8c43857e1b84440efacf962c577572cbec4a98966b61cc82127eb8e45a6b9f2e4ca1982c5b16ae12b6ad31b03eb97b957dedc3f585817194bcfa184c0ed68b078616c17035c5a4423f9073442166f49cd36d9d2e854b424986f3ee6d129c49580eca9eb877f38581b7a160f9fdd1d629a3203c66488fd95e3e7a1188536409ab097be8d36fc7b32a1eda5ce26344d2342593ba7fc624cd5307c7cd4fdcea791a45c5d88a3210b8c769c387d387114c3da7a9a76745b3fb63de4de054f500f0b6394b776c5ea24abd611b4e54d5b2b5e3a525a96ab2e4f8eed58817ac462e67ab1705d7561d56798c6f791e2d414340a8929b5551909a54efc8e068c3b64236220657efeb97d09bf88385d1a1be9bfeb77730ebb2e629e6222928f00bb940410dfa68d8577f355effb4ca78b9d1d9e8dfcdc548c11a58f256df33b8962fcbef8e781f27095ad6af0961247fc2f91b1c0125b50b367df1836130218919257c1b54718bbcded23726237b974f2c97f07ed09149f1cec8a6a7f20f45af58fadfc5915bd9dd00028d6259d9b5d33fc709401d87021f5be03edb0a13a5ac5c21057c7488c5eeecd51d2f971e59d5026816b898bceb220869dd576bf3d270674136eef41247f6bf612fdd0650a220855034ddaad83459c4e59aaacb960596931eca69397799604e058a09830eccac05ba2ab0a5668b018d782d7a94f4c27df0a7d8f81007f4bcc5dc4cca0030f79e25d1c1d76ab3a369f1257639aaab452ccf1f9b8c6a1f3aa929b487a4ffef6214d441e107f8b40786d90e3bbeb849a54c686ed703a084128c90575be1a2e8c627adcb64e5050ac0864bc81935ffd7899ca4bd828ce8b543c9bcc2661c5001013762115300a003a7341cd8c0a2aa78a084af614f3c9bc0e8696f937068e65e6f0196f4a46d7c880e3ab2a86aaf45ac09ba43cb496a609f373cf7e5fc6549e60152b02fd90fb62fc93eba39667594435fe7377fdffa82940d568b7e14fad4bea030e05d9ad8c2a119147197505cf60bd75a500e607226799d27c8f2134e14df4ba7f8584360ff02bbce07d1b954883b002aa35da69df137246cd25fbd67dceb2fc29562c0eeb8fa3bf1d5fd4af3eb4ff8de2f4b6bfb4205ac43251ac213b2148d301a8ef65dde65eab2c333f7b7512a5cb20fc54fddcf34902663fc2737716b853e2dabe42cb3583236ea99c1444d5c15a3aae79b4d9ac6dad6003eb018efd30c73d80ac59c284dce229de939e105048471855dad284a27c8baca54894d82cfdaa78a18d6c1daa7113b355d72f2e883165a2a5495b6366bcc4e2f2f188331dabadb8338f67e67086ce8be9aae06800686879200ca9dec29743b5f6c2c2ff8928f2dd84c8dadeb7cd502a1ce969881c8f08f880dc0ef3e99e903f4ce914500037bfbd9475e29a6caa9fa4b7235668c50cecff88b3677427d87c1e171378eff36cd6ed58957884041a719d09f9ec62491889261bea6fbc468f4222021f4cddfc8729012ec89ebe192abd26312e3449a22b27019b5b4f44fdbb24ad799941b09972fdfd4b4670372269a46696dee01398907f895ef852e998ed0989602cd7f01e952e3dbfad0ed3413c924128c2a152207a419b5f582b97e322c51c5381edc65583cd8c4ef412c2bf8539463f8c37a02bcd9f298037fc3839d3799c981c321878bf1c3f52c52ebc781a5fdfb17b6bdedaf223299cb282135cde6cd691d1169567ac8cd2e6c8ce21cc178a6def1106f80fef1d820e3ab32f235435a4cf38ceead61922d52bd31970c1e79d6ad859a507e608b6c4cb023ce133bc383ce994595330b7f3b901e8a0d419950e08240ae130f17c86432bd8388a6a499140a62b40bc0aba3d6bca8d72c3ef6cacfae2850c8f2ea5e661a3c15c6acd1484dd6ec6ec1698046e4a083cdbebaeadeeaf250ee157d14598aff027591a801591e1f13eeb0b317eb0fa10836c4f39a2d485156928e86a5e39825a3c07c9e953fb9e628a50785d1d03037c118ea9df5b55becb81c4bf8e423f6216a073ea9a3b2bd7cbf836f376c0bc2c29f9a20e61aba5b4eea18f8f800ec1d721383a659d510a4c2af29f97057dc96817039415eff330e79ee0c89c8eac1e888cf1ecfecfbadd4d1936f32cc08e2c4829572ec6ee5abbfa6e9a8b776e5dd80b678c05a015288d70da738512c6ec0f44b9420bd19c89e6b01adb40643d5a17a3819eb1d289e20bba5d2f3e8924f736b3fbe8c16201d5f9a8c8503f009858b3a8bb383042bf59a5f6a07a10337724d13cb3a2e0533c9b1bf56c91560e8986348df415ee28ec830d57b8f444e38bbe650d9bfe6d45d295e59ccdf270d4a99d0c5c2b56acaa6dbddd0a33e3ecba3a76f85418657ff4be97b91dd032c4828477b015248ce9be7978c655dea98f38d56643b8a2c26c37222a22ac28ecd4fa867831f60ceaad37f46c7c6168e1fdc57e08e1b90c763775b97cc90a2b3aaf22f3170f14f1675871a721a2699c41c5af6f8eeb02f1bb283dcf01a8db9896c31614a0eb5996115e96964ded6a89179b5a4137565dfa3c8ccc4811361ff3453c7bee0be2073ff9c4d3824d6a3dddc7c978ea6f30d64ef015aadc235636c70b6821407366e4df05837e2c68fc1fd375935861f040e17591ea15f606939b90728fee716e674de0fa56432deb7b7e16127f9d597d42cf7c7d3fa0672d4e720e073769e37523122a4e2c092003450892b88d18369d4b46d561085c967da7ae9e1161e3b33e8833c561f30a056b940933b99aa7e4354eeb3e64d53cf3d427a88213455f6a5afa01a271ec873b4963bd0b8ed1f7ff3b17fd7e730c466d0495742fc79b0cf6e8e22ceeaddf05929d6da1ba1942ad4465ba4f8f64d069f5b84a6da1ea1892e5fdceaec7cd2c251e6fc473fc6f60a3c7bf8ecef62570196c4937d9778e6fd574b47f6d2540002bd466c4d294ba851491fbdac04d3babdc2afe3cfdc26e16bf02746b1f13ae6f926a5736345fb776dbc2e8c999d66adfe4be2bf216f8c4a6f3d42f091f21a52aeed22ea3979fe2aedb83f40f9f2268581447542918afda7ccaa4b182148e7480c50755cdb3acbd73ebe0f735498f121e22111c12a7e4f1743fd6a04c3e04de479a14834579f50948f08ab1f45b36ba1741e6d5e44f1fadba22ea83373a5a940b4c1d0bbe36c52709113b30b893171decf7111e52a63fb62ff9656fe03e0a27c07916ce509a7a4e052f223cf9d3126dc2d3cdb77797f081dd24f9b51f36c49a4fd2584ff5a15573847d10ad2f9c05bb6091b7718b10da0d1cc3e73cd180d42e6f71f2939ccccaea2624b77c82dc51c262a683efbb0ec2d0f6fceb194d3c1fe1a91f7a8f73b90153630d4c2a158d3bb45f071fe7fa74e82da3316a26b13458d570f4628b3a18d801787f312133c74ad1dde8bfb11106338e615cf998f9564587e700b6d8f5ea638b83afe768594e5780fd984eb4d8bafdcd925bedc2a986127a87b712caac863cde8f74cd501f82f3a1cd6cb445d72d1ce2d2ef5feee58545ed36836d79fb37a884cef16607227f8d174c7ae5ea459f2b1f88fffe68fc835a645894812e5b2983bee8718a144b222071c2e1688040622e359517b65ecf7bb7279459e57477bf2b6cbfb3c01ade08c310ca6297082149a7744edf7263614648d8cd9df11212be9accf44a1f0049ad0d9c1ae0c1b67ca30e5f4f063d36e331f8c4e631574220dbd8ebd243249053963d07ebd3751bcc34f398f2605d60163a51cec198a93629ac65ec8b694cc7e9451b63b957cbd376bafb457c832fc2089a14c8c48ff6780c30e3130133cf674606cf1765d04e271c6a2cfdcb7b22935787ddab02cee14b28ee1c6da924429114dfd18f1bbfd4fdb1bfbf288dcfa4cabf3d6f462c62721df887306cf3ba59dc42a89974abdb974f6ee6aaf40cf95cfc3ce4806e216e50218180e237bd593a1d975ea0eafda25416b5d20410ad9bd77ed8360962db1f1e79f86131b2e9e39ee32dcb8a51f2a4b27a537c1218d578b5a55598591acd7ec288154303ecf75cff7c053e541e9b23f03697bc8d768b1d1cb5bb3febf479fffbb6763f86261aab77178ce0f4ae08f62f862e49bb4d1371107617bdd2c6636280299ef960ccd841860deb1f0e6e0687ce7dfd319e0457a4d51657bd04f01ee5627567688c9490940ab301d3c92a7fbc5b69cfa2ebf5dc118df178ee7b4132cdd72ecc3a32ab9b8ea7655fb4127da4c03033fbed9576790ea3fc23034c0b81fe5a3b0a5e0a0b116571674a474b07b09db270957237ada93021a9430628f440a92f8c3f8f173628526966036a03971e0eafbe71fcdb1ffd8c496788a35eb7eab93d6d2b175119e7ca6a31010ad98c4787baf4e76460ca42a8393a42658487210c19cfe8e29fbac94762fcec16e96f2a639aa88198faf37c9a729fb83b2d2d19d79dc8be7383108f76bfc687772d616bf1eedc4b1075fb962dbbbb8ceeebc900aa48cdf992ea20f1498789a3c25ba5bcbe0a976b9b6f7481a3557e73a3c4caba66641999c955bb6978f49f5eb0ed356590f6be4732ae6ce0a42eb3d3bc94de4f7e1c6b8db3e27de1578397633c118adae14982a1e00b4d4a21ee11fa29acd5267409a379c268265c59bfc75df900105086350e0747bfec8406c1c3efa5bf16b117edfe42741d0770ba89df5648909c3cd734689d19581b3aa946ae0b6b1de1171d27722bd279b5cf3417067a4c865d7119a42496f96dfa4e41ef69bf248b1c04e623118e629fd6ec795d224b66e4e39174f51f4d17f29f3c641a59ccb2d265a582a64f508b494a43726070f495de264d115ecf1465c9ad1a6062f19330960a1d6d4db6d8cb10ef2bce7a862f24fa661715f9a7a69aa7fa44d3a02fb5c06d9a16279116050c7452d31d43c22c0895ece53c09313bfe780074f1cd20ee2fc47b922988cd891e9bd29fece555ed2c536b32a9d93db9c8a328ac53ee3f93a12bccf32e89311041d8350d1e6aabc10541dcd86d5b080e2a84880927043a8cd729d2f2c1999bd7eefeb9ad2c75e1922dd957bb1ef871ca2aa3ee2aa751e5255fbee1dd1ffdc4d64f9e7e56b8b186a50e103361edaa52413e3a68b004313adb74104d67d8b38d028baf5c78441aae1dc0e211747fd2b25476deccb8f57f376e91b6319823c7ba61102087baf479ff55d06f8263ab85876d8ac7fda950d089b7385c23c40750d75c32d7836728efc69155c1493d4f6bcdaca7f1d1a5aee8602c13df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
