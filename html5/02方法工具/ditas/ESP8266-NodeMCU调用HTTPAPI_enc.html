<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8acd12f905baf95c651453c8031260c0addfe969273c536a56f1ea9def7ebd8e1cffba07620b5d659f418b8eae6a225f4a4ae25c575423224caa23536bdb4051f0f593e5f2c6ada8928ae8d0f1b02dfc9a4d98f1e9f16b97e48b11ab27bd87ea7f0b874b93c4062644682aeab173be76fb592959457428366eaeebee4b8c499a68adfc4a2f46e9ffff0d92330e7a2086d979fe592055e0f138df89dc4869f208a0b318e78148cb27427ff8c6a5fcf499dd7dc81c8540aa972fd28a4e8abe91dd4f44d36164af7afb2218735881b7a7bcdda93dee2267ea44c283ff92bad1b441158f0a37e587d05fb448f5616fd19b1af00b0689dbaa2cc3c0ebcca26cadc254be4934242d130e5511638fabf7e65f5dd7e53f2c9c51c7576ae1af6261e87d2ad5923df665ee97ab998476eaae0e07949826dab161717b6cfa2145fdb1d0ce9a5717c83fa24aad6d816a0a1b472dee3d0caec0eea9a176704981f924f936a6b8e6384c659a1a7ab8fc786bbd7ff4693c89bd87a8251542d4911aa0dc3300742254f504487a57b64ec30a7092b00595e5a596dfd548f33d3fcc469e50338d9d1eea05a01f5d108b72acef92adb3fa1700bdc6c4a85575eb7dbfe4d79164e7f7e90b8378e0574b7a4bf6b01a41fc05129cd929ab731505736d2d18cb4c24d1a563a448427a3aabe6ceb13a4055304a0b8beece203bb5b80cb338ea0526109b63d9fceaab2e46dfa6b62054e369d3d2e5909f13d8dd9e95c062c79e30360811904a752efb63f581d1d34ffbca7618bbc0fd1b8c0bb687b87baf1e6bdbfbbb66d1d77e33d43c267d32ddfd2167d1c096aadbf50d8d31628fa1c291dcfd8ea77e6bf067848874be2e65dd6f4a8a893d094688eed9d4080cb63c4fbdc320e9fc27cd75d946ae31afae972109686be478fc5c6c6ffe2f557be144728153a4072c222c10122d1a2693ab473e75e99da3b7d20114f4e0692fc2a219a007bf5c5bec9e0bbd955e6c51c68ff04d0e410612852db4f78422d08f7994f65dcda76f6a2c3a242dfc9e56fa3abfda2a3f1e5a45a0766ea86f165a7e1f5019736cafd1d7408b142ede0c729821b5bfe563ef5a99035f8625c2da4912692e539266efa2049a178789b0a9960cdf87f2f6e1333e7c9cd81e08377c781f06ac23f0fc82db76ab6685c30d1e948c7630c2f9eca98d5152045dd9032d5efa8901cbe8744935380311006be0589357fabcfb7016cf6e55fd460f53365009a5e066a2f5a178c9f06118c8fd7a0b6cf555cb826be4caa23b72dbdc878a5795ba39892b8bcea385e44c1841fed6156c692ee172fdbe313d12239fa3702ea209d5ade703b3edfc6843afddeccf0ab87e7dd4567d649c3e2ba764cf586c4aba5b431320f798723de78ef73d504bd6870e12a932f1f8b4ba83d8995dd433e2e0c5fad5a08361fea7723b4a355c9b618ad3de555c12196e2c8831e0e1ce5354e0b08b7d9648cd3ddaac990e5f263b8469d5a8094d45fd997f3db320c88d936779fc5183ee0d4810461b3c90cf7f9d284ff58115751401c6b55746a1f9e01f8cfa8bf5329f23569c5e2276c38b9a524a424a4d3b2c123648dfb3272c55693a0ad9850b87cb8107d1341f7dcc95791d0a548d6cfffefbbea301ea86e1ecd845ab85cb550a50bfca340e22cbae8e699d41d27112babe5edcbf92cb723833de1672f0d2d3125ff38fa29e15626be5fd61a758b19cbcf8e8b9034b57bc5130971677d75b87e8f18a49d33ef4330e20cba2b3c95e6805451348296c04aedd195c881a43195abb46414744ea27e8115f1cae599a95bf5912f5130590da0a125df07003210395f67f38d52a2fe10cca0afb9128087ed0c7ff779afa07cd2d4a43fa0307a861ac61d859943fa8bf7205d935a12b30f16f24583422751b45c86c1564e324e1548c392d8c6b5153d66a0db683ec2816381b1b003715ab6b5723e3ea9d55bafa9ae262b1a40a30513734cde4c9141d321ed65affbb08308d2a30f41f5e0de2901d7b95b828653eb0ac713412857ade4a62ea186b34e7942d3a430d8718cbf2d26b36e1828cb53d86def83d25c0631d3a1a2c8aaf36c191db88993e8fb28369f3d551ca26ce615c94b3e645ad3580cb5b9ea4f77e0a2c5186d30a9f33faf90dcf40041e443197c53b0d5ce756d3cc71c9d7f4401799ef798d809dc7f89309a6660a3be42af4512278e860f01fe8394590608a0be0649c9ba9de215b334d80c3d704b659cbb88e6555db8c3fc874a9027b25258443f4bfca3152615edf7038332e3a3dd4c8dee418523f72bdfe3f7040db8f1cbb1847488fc73f233efe7101b3d589f78fcd41252f30659eb76568937e63fbb19b8b804105f34eae85d6cc6b1d987b53c23047c8dc106d040f8c54fdf16ef1271630669e91387b50289ad25e02294d8cbe733cd274a3289128ca822f4f1a206d95111d89cdcf8572e016d5edc81f2d4208a9b4d12f268aa809dde8dc436cd77e2e53b504628691db1a2e495ec184b533c9182e25dab00e1b555d37d4b4d2f6e335f6c4e0f89733cefbadb1450652235fd434cf10017edd9800d8e0383c84f27e758aeb4d3aee4efb470c48101041ec3bb6f5c86e9fd850b8daf7ede6cdfbc4ecde2db1ee4a1fc88c649fe1a921ff1d968088290e0f3a0e5bea862302ee6bb6e2641dbfd9f4f381543f5105a583f38a67e34f2e6fa329f8d5d8ce410a8d44e1a7014c085929fdf73019a61a7911d565fee3c966f0c69ba0d94cb311409c1dbc16ac94bd52c62fc5cef91d917eadef2ea91f2b311329140ec62d367d1624e47d63e102f3163089a150b5037786bf04d7b3af4253146d008e93e0dec9fc68e83571d8d7adc364b6eb585b26defd4b6a573ad0c36c59011248b21f567e47c218ab9e2b963e51c54352efdcfafd758f19fa20723065e7026f6d4a6740a6f2ebbabfc4e0cc20c520a1da8861e009e3eb7e9a194df269627c56e4042c2ff43d9cd75b5b63e1d8e2c2d666f15645f41bfa6cb9b54cc4b94e3864340d30cbdc6e93aeb684a173e9118f173fe0300170af6b6bed3524c60fa1aa1063ab9204a6adcd6f1290502b43d9d37b51ec4b1257d688681ad595df9216dbbbae90dc819cfad4e79df7344b67be0139f35f5473cfc2798801c6820260ac5e58d1b5a78e29bf417cf39e4c83153718fc14115691e26f9f8c7887010d9beb62093f7ad171cb8119e5447a9a20a665a43de26339f8c9b43c4b1b973abbc4b1239ad87a08e65e113017e46245762a4e096dc6b60181b4953a69404dae0d7ce982c7bb52860d7f3a8d08258af439c14409e271b61206c33c6c6965db43006967682de085b306ddc4c63319bee4ff318d8bddf074516186c935ee9676b41533550228cb460a3f14b473c35836fda3840e26394861ae57f2c1793156321f49b276003fee66ea37dffb7e7e9d883650c2ecd3058097c856bd4a4c4d220a183086833b15716584faab041f48fee1c08ade53104a0adfb28b578907e4e295135471a89e691ba2bf5091f721497d264c8b595739ea5e5cbbc7a1480417cf451565656542c02c86c325f8408542cb0de31fead462b206d04573fb1b54d17b0b92ef135525b9834f976a1981ea0fc9aae1e200e94b02fda7b9c5d59dc8ead479f5e76040df23994d5a5e890dc7cc671f9456603abe52d8a0de68eabb3f62c9fbb008f1dc95bb8e4803afa5dfeeb402f3511aae440b087f990ab34eb695c7f34d189df7ada6b25efa9b85d2b2b59907f2785eecff194dbdf947d0be97eae86520c1a6b601d9074f8274fe4fde2e8ad42a6af5e54f68b7d91b9ec5dc21b9048f83dbdef389634aa66d6b38b26543a1a8b4bb5491fcf7ae0224370bc8910e286f8b553ad971d96e3a58f68a5d426ec4f10ea5fc766c08929bffc46a393d98bf0d2657daa741d87d2667b7d2eeeb634152bc4accd0c74ba7b34698734175896d1f213a2f8cd58688d426266b7f5b3a7d432ca214983960ac050b4ada882e7124d566a58ad883d3ba6fde9ba0b439a0ab776675ebd8c28f72f832bcf2dee4b130bf5bdeeb29476fabc9ffab5b6be940a4a7b75e54eef8173486ce95e4cf6f67d51c823c3a41614c384c4c19071fff0d19e5b375dd24ac8b28cf4ccf1e0f7245e20fb35b4df8051e87ed4721577b39106a980f62a2db35ccb61d97f91361b9193ab3d9657092fa0814dda5e282a24e053a60318e0828f250dbbdad0555d6f690e0dbab5ba4bf2db6278159c746f4b1331481ce7803cd91bafa06f5a9c8fa515ce29daa5ff0f5db0c48d10a6f529d07005a2cdaaf7e8d374bd7024000db1924398e34adbfe44cc1edf6d97403fe704363a98ccb5ac4acb2bcf718193437ff3e97f34099189362ed4bf485543eee35ff23f07b0713f0f3f13fb2950b4ae88f48478af60b7f2fec56f5ad28a0a999acc778e0d0d5605cc3bdbe5372940fc5a7ef66eec4aa26ba84cb48ff649f3b49fe7cf3da4211480656ab3a816ad94696eec374166b8233576486249ec9e63539764a83702a2d1373cd6a7c725342228c81eea87aabf846f2ab3f11f1f2d3703350a76529c483de88ed5e6fbb0d360d0953764520c9cff112f83bdb83dcaad8f1104774f68174e1acae4d9e78a25e8bce225d31b862542859373974bbea9c1a2d862aa8fdb9a94121d6ccda9191250afaa46726958fd8f99730d95b02fe0fbd2be83703ad561df7f5dbaea43f4ec973e498f60a29141cdc14af0cd0aa2e692be7c8322fe83fabc31d34ca3a730a12695c080a12929632d13093496d5e88497fb30cd088e2b086459ad4dcb2beecff249f6c6fbab19e683c6b280503097ac96d35fd53daf501a7f0fc17274e831fd21ed59366a24bd4ddf7168cf54332b9aa6fa4ec5e1cf6d2000a20680b0d05ff22bb7d1be1c4cb88eb4592172a8af6c26f10132cfdc7e4737d0e4bea4a1b2a06136a9505eac34379acc5f26d291f0c3b4bb401a1855bbaf12229a041bc471e07936ec1cfcbecfdc4fec4b3ab1e2efc9366390020771b330c66d9b9e1320c9a873e7565af9889f4c3f101bf9b67a92343a8e5c10cf3ff283155f71a3336b9f8c0d12c8c705069afa510ba9e2c49a9f7da85d04640fdf855ecdb9e139770ec363f107f77f8a4621e4cdcf202bc423d5f4e60497c73c51c46098d5fd31d14f76fc912d5a15882b2f01ab2d102e36fc1233aded15691d7c8ddc28438d42b6f401b602978446b375ac6c1a85c6b23b35415e0dca5efa48fcf5872eec2bc824e7b840f10d25754935e8bca8422dd37eb25902394350511d3501dc5cc86dab5cb7e1d66c21c1f096e89b03ff8ce3b3a1c8499101adbbfeb95fd1c73b7930f7f8115b15a06371e19b1959e29ae9fd2b78ddbc23ce58e8f1f27d0ff4abe05e426059264d62d3325027ce7db8bb698557f7fb4677905a0f050745a7d0567f3e13791f5961c764d287678aa038338460f77bf7f800759ecf68776ef9c78f54ae2296172a85b7ca84c59b05fb263059a3b2da10d93618301f5db4e6527dfab8513eb727340c0cca6b11499f76be4eada013b367b090014104ac7fbd5dab31ce6003907fdb95cdfb7c61c4e0260f2397fe270ab40000e4ecd9fdc62ad15071e2ef667d8b5a35ffe4ce6431556ace32fc0c4be441d83fe0a0e591c16a1328c2b81631a884cda283c13c57f4d061cf95aecf126d0740158fd85e7c42b2036ad8e61b3d5f469ef2bee80348308da3b101326e719c18be8400efd7b38fc19948bb668321c2e9f80dacdd4bf764969cb6529b5e183a313f8647d58f35da688f080599a65e9b295cadaf758be8642405cde3c187bd831709bc96e8a17de807480087416ce1abe1fe3ce1091d0f9451cbff9de3b9cdf4604fc34f7bd458478df7dad511e37417547db11624f72d4bc96657101afc5bb668bb5c977cd1a714bb65ea7abb650c0eccac4287e07361557511938b3f5ab4e777ca81ed477af468aa96dcb112a80ab86199071301dcf4a8fcbf3cec60f4a12651b703277340079431fe0d0911909f90397b88e93fc19e630155372aa467a8b2ddab5ae69701e5f386e4d3297847e401c165a568a691a985c32aa70de18d5ed00a2e07a306bc31b6b5db1cee7698e430c20a8d31a0b010d78dda2ba09692fbd05198799e1a5b86031c85c78c430fcb719983d221478a7d447553c5dc42bcb67c73a0946ba541dee0880425503448fce967f1e059092ead4172aaedf02e3ce81ed5d856f25dfbd339674ce23147e9c571b520ce2e9bff405fd4044996b34332e017981f7c10f55acc9e60dc747364657a9f2d45511c8eebddf8f1656e65509ba2afccaafb6da27bdd359e3dbb7574cd2986ee50c6136fc6e52fa49b1539a38e52a4842085bef12e4e48e9c5348dd7cef5305264afbdd669a3f6df4d5dd46bb9ef84f8bba81067cf9c43f36c1e2f0743450f8d06a28c1f991f5dc0e8fd423bb2e19946d6c330849ca6910097063671d2e2519188d67ca8dbee711c0273bc6d84d152ef81ab05a56bdbbd79bb233734a010d7f5eb4d48d22b25f521e4a1c208772c5e908cfb516a771b2b15801e223d0c46dccc0a065670bd39f46881c6a64157905ba0a91e65354ba653b5b60cf53d67bfefa35ab93552fe7774831f1934c9a166d614ea2239ed68726bd5b3136e1a48df700e797d394b2d2cc39ea04f5b0ce5611ca0be3ba05fea5115b5ffb0c46d7cc269c6be8dccde1d6da42c0151af8561f12432909da1e4659b9a07d1c63454c644e048f63d9b21c5648a6d4367fa5b99151da1f7521afb5dfd3b66ba0820db3c5aa2d9904a59841e077e279c13d328324518b8beb982abfa0baaa1b5c33bd84ae18897ca5381856c85bb70c8106dc9c261e59ab92fc5938cac964701b63e3da82d12a70c01f9e9f41e20c4c65bcdc44496cda4e947a2863c69abbe998478fa9c17c7c6241127a349a5126be008c317ee40add9000fcbda65207f7d13f3fe08285cc138d88fdb9ad4efe09a6415afe59f9f691253de5b7c1f4037403f797be3f213eeb31ee3167a65f228557cfbd1bbf9346272635cde3a2bb8f6358e71077aa679649b675064c6b98aece0135882145157d8c88c22e80697979a844bb212a9eadb2616b4f9e8f3b9f6285f12b9266eb14b032b9f40d0a57e7758dd248185f300b6ba68c79e4f8357b984e32a3b5b36e04adb0a668803b26c7a59a9453cb24cf93e400ff7ff27c5845a6841a086ac0b00c5242f0c697bb75d5987caf8e78a12d1f04899c7550688eef01758ed3710ba38ef636a710039bdfd4db8685831101ff549c79804ccc815e31b6ff94782b6c3083667e2055dad8bd22d23374c4b74736e2ab83532215bb4ddb7f42ebc2403ee387937e1e04147b9fc8f6d4133d8e38c597b6907eff63618f48216cfbee0d64465bad7348101953425bba06ea2b92186c0e9f91a491de42b9fd426891ef2a352550de0ecf3c4cd0fa257ffe725ebca82c70503a4c41352c25684e34cadf6274cfcc2774f62df6b420d56f58dd00b7f322306e96148e13169de7a4b4e435d6bd097945778d017cadf2db5f27a994c99fb39f71c325b2cdbc0523292ebb627f844691f9d2e80e63b0cd72f117b2028db5e1de274c7e675d8b705715f6485d8e9130ab63de278808a13d1baa28cd3513e6e6c94e4c0ffb3de5ade15b849948c2d2215de098de657d42eb5e74bad5a8bd7fcb0969f8d512fcce7f4402b9ab04a4e1b4f767323ddeeaa38278a9532c8e0ca8f538b34ac6f708beccb7928383126e88111c0b1bbdcdb4fbb877c7c449c12115775a71ed90cd5cd213608486c5068c82e25f343f7dbd2c4903a5eddfad3829246e016dfd5f595b750a0c66696d8e46339fbefb14cfbe296db129e1b17ae03bcd77d8f288da413a198496166f03f447dcf80d5e844c7a7692a296c86d09bf9887e20ba8fc8ed98d8b2e1813072d1384c3fec73a57c26c696a1a2931515c266472d14a61dd800586976af0eb7c237221af97e24ccf6e4ef73b0a737ede4db8558f9ce6b7b66f45768edc4b0587743bce03a3ef67c5508bf47da43df843cae3de9e1f3be7dc9cc3d87e1fea0557b0bf602559877c914d58d46b4aabd6b93578bc32aee8ac253a21b7e39a53ab8ecf94dad19c66a70636ea3bd6f72a5b0c01a4286791e9c3de850b64e55d07cf9e93e0ea9308b447abe99b9d2bb78978a5fc72d7487af0db803ad534ac39d9912c277a3468a256f21fcaf65cef7c4231e1848e19260e8261243fc741097cf8769228c1eacc8e5d2fff9afed3887c4da309f3dc411c7257b0ddb6257db2dd6052005b17e172bebf60f563a98081f34554f59c7cf9e63be3dac76b5272b4f31ef345c3bdf6625f4a94c919a371f7812f4605e18160d2ba393fc1397feab785d8ef52f27e77ff1f1d35f73e905d3e7dfdb5dfb8d9691ce21fc5747c011a58529cce387e09cf425833c4b9ab91e72c0d9a6c374c45cac1ca79bb9368f7357c86bd88ce7785d259093dc881974704bd4e16a6e12958eefe2a7cfd830b013b65bb3ae140e70f5c75b661585ec9b449b291d4d22432e778cf782c7b48885604b34afdf85a5bd038bbf14e66bafcf8c1be9ab2a8405b0206fcc89dcebd7ca5145ebe3868b6d88685c0abd758978785fedc821bdbba150e1a3b0e82cc04f1c7c58bfae1c8556527bc6b45e71aba40de13a169628fbac2651761c5bac6fd72b60befac0abe3787f883a49fd2b3eba0514e93e3946e35880b621fb7e03135ead56bd161c6d9c25f504ecce8e59bc198acba4a533c3dc5a51265b6e5f998ea68ad17cbeb2f0042dda31db1c842ae1680f31bbc4ba5ab55d511101f6abdbafea14f92c37ab5fd0566af8522a0a79d4313dfa5f06efc4cbb34586647f8b5bba6f5616ff910b77d1ff1ce5968ae59de25a40a2a412a7cd48450a0ed22ed3317d3c70cb92f085aa321a377d8be0db40e7b62e4dbba3db208906b61421d5f61e4063a8aaf8881ed18d20dfb6849a097450921d4359024ba01b526e4d16714ae360a188257d995cc55e506e3bab234ec7ed3e10d1b943dcabac1591d3f35ed48a1f48cd7ff64df29bbd32d60d9cbe23f3501f29bee05838275cb7ef3ceec63ba043735110bc3022a9ada94291767d64373d7986dbc458dc1a740d9c5dd6b97bd034e676a69d4c6872b55c5b4f5ebd39859afc21b30fb9609f41ccdb071090d6d7e6806c6f396a53068aa61afd6221d76f626be88df1c45b4fd1f87066ec336957bea4507004ceefee58586037824ba1b83a4f0adac7b270a51c34d67dff94a4a204b4f2d8de04abe528c32c4ad9cf09b801602314bd3cad2e5e093a15655ee5bba4f9b295c05d6cf18170b9fa1dd306240904a6a4812d09e87a252001acb1c04ce5b348f4f44d1381a01cd8ddac5f5a7ed3b4ddfdfdcba2758add2f8f1370a6fb1a37177aa34d735e83e18566e0c085ab7fca52a47ef9ce1446671ff38ad70d4ccc9d6933d5c7d2a47c41f034ce3efbf4c390cb9c217e2da075e575729c65c49bfd0623a0ed9a4ef72ab4c4b6bcb0b16517e6e41f5f665a08d9a667ab271ffe1257a85a4b72c5d95c6e09d1141a329e91bbf278c8c37a4678da1c3951f30e66f57bf48ab8215f303857955cf48fe50e036d28af10ec862b30f12f7bdf20f165a7bedea684295db8ca14066b7ab2d8e354dcad074ade2567ad3b34904f31473704e954fd98301c3cd504d7bc40933c8e9d97c0abde47ce105a900ab30b88c0cc47e00e6df87ae6ff0078ad36addbdacd12bd55d8d69b9a22c68f02609f51c56e6f795d9c56d108deff05f06f4b2d06c1c28713f07107bdddc1ab416ccc228d78bc4fa22828e88926d7411cff70f243b349d73b4cf863152996c9651f5fc4bdbedb6ff884f392ec3f274ea1a6d7827ee9d768382fc83009d6649e6f88616f38fb2ea5b9df89fb5402f4ef51703941bcb2f3a36a31289ef694f4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
