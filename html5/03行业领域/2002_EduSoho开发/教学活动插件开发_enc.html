<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f2f20d53fdeb083d46ecc806cd28234bf36ae8864579760ac76afacecc905ab24baa601832c1ff8bddf3ba39dd8a0778cfdbc1875ea6c8903490bde69ebe2b66ff912583927d911f6c12d7c02b3e1e2e4b8d99baec52a3b0bb124e2ea9d8102ff15bdb5164dc376caf17b9ad289f367b6e1c15c6f6a41d1da101817f6cb9032b7b6028c90eb5c7f7af478040ed96040ee3490505f947690e2122384cc7c10bda2fd57d7cbc1d60673be3af4617e9d1cf3a9dd9fb1da7a9552c699dba52f1ea7dfdab8063bd0a7a25426c904428af16b22a3e9731a4d6bcb37cc7af04b829cefeb3a5ae6218ab2ea0d7ad05eb3904cf4d06ef76ef8f286f27abdea9af298715f650d597071ece51c52c410b3cb479cb3c7b42811b30c558a606469fd7a7b3f37530342ef464abff3ef4251b1757ed90f7dc5bdd439fb8f9ee4fa2aef1c4d78183e78c9481e5175f710be6a82c8e15f58ea55a85e3186d7692428d0ff7a50caeb621726a981b554a8a65ab8d93bb9a697172057ef09c2a0c181ac3536c8b2967e3d83120c050490990bde54f69a16b9a5f230401f9efc663b2581680fcb71c6e8109d1377fdb1f27dd84df6d7af02d2fba130afd05bd6e0ee0dc56584be3f7dc13c396ebde33907f32d56a3b21e344f911b8d5038a6da94f43d5a24f0eda32aaee01957babb3963a5eb788b27219bb8915f2fb16bf39dbc1b0950a2bf944daf055e9479790977df607d3481f217ef5250c344e69c6d1bfd4414df3f2e43d6164522c1d8415d5c026b248bf7f74f4c9d2c892314b98637b6d367f1977087814f9ab46cd6c118c5dd78855d6c12a2eafdde4944b39b4ee5eda91d933edc31899b2d0b5ed80a12ee521974bbe11480cd35313a3476371e74e755f3b0ba64b5443e65e5f05e65373d3468fcc06440a180c05933038a0381bcad96f86570aab3e8d7aa09e282305def03e95398b6ccbef110705b130362e512040506b6583e3963f79e46b0a78a21093ee35a35390fe30958539f6901a45d6cef46f7879bba952d1bcf0b936859ba509e6876de437feb4d0be80fe41679ad753a154cc552529a655b5158dd2afc368f0f3c688719bdb935fb5557b3aab422aa9f223492d45ae69826755f00f8b9fcdccf40d10d54bbca59510233ae0d347c44cdef9a94aa5afe845696044ea647b905df491af284decf11f4f931fc22efbb36bf4dcc3215d7aa7166b7c112a88e694d160ef5d89a492c5ac8660c60ee8cf3a8c555d06c92effe93c1e8ff9d0aeb7861d707f01dd30bf0d9c1a58fb39af09311d00cc5b0c466b75d1e47f8e11e8c4aa3053d03ddd91f1dc13f9c77bff190856e4ef852aeeab2f5a4b6d902c107382b36695994e3ac673f1cc7d3922c66b4d9fe19707bba29379d2245759927de682a0627b71e855a56c48d5ac36931612430749c653aa81a2864b889de73dfce794c805c14b11e229fabf781e8a8aa3f1af595b77227d8752367db4c10baca35528fe91f22cdcc1d4cd9b16bf5183a0ea3dba6fc54ad2e2d45c90eb1ba398a46165073dc56f08568a23c03f5a11b092947456d022c6ca3c116fce3bd438f34bb84c522cca711cd178dce0df643b5313d8b984ea0395db11fdf3c2f9badc24df8d9dbaf7b9b3541e2f61a3d9f5101535876d8c445a4beef4402ec0164b7bbe03b29da3040ce7b744307fb89efea6508d3049fe8f19d988cff7d270a29ad3ca260ca447e5ab975f12fb492d66a82975b83a065826ed33b5eb1a3e483c85bd479c1ec7b1b2b040a5e4be277f1dfb363be87ca9baeee42da7ad644c7a4a7a0443b96ef44d77c8df1a64c1d51417f9a0e19902e026999c2c73054570c39b00e4cff2d3e415123fd9b501fccc4526e07f56b08e9ea6b3627b6a937f1d71177b5252b9644a088ec0b634c47c3f0c525ba6a05ef09e96726aa4f512fd46cc57b9567d415e55a667ef303c27f405c9b07a3c51c8e6a66a84fd8fee17c9b95ac2a257b81ffd06cc90dc96ab01bcd5d935c0d00710004be87f0e49ce6bf7c017e7c250fe284645568e39f1b42a02c47886ae06e71da7d736e3c326642aa4cc0c45cddb8f7bb8589f6ca56f12aa0b02acefde610bbd331b8a08dc7b911bce0bf93e7a43a95305b30ce110a54c82a15629c60dbaf3eb8382a0977e66c9d5c5781ed9c7925472c3ed003607c761ebd5eade3c451f77f56ce4fae475dbe64dbd6c82f04faac65ce9da4823a6d36a0d71fa4e3d49f2433ed2f112c5e5f0d95541dd4e06819fd5112af2aa88f6ac22f2e6b0813a43fce0087e0a0207872bebdb486d79c8260f98f9f463a1eb092711277b74a2f857a2f522fffdfa5b06ebbc4e5a6b053ba47c2316c18f0fb1bfdbbcc3aecd61008cc630e870e44640a768ece245b9d0e1f9e34297e54ec2bf950e3dbb9c38545a63f658ca006e8241740e39ce21da95eec43f788c3bd62220371bfb6f6c39ab024432b04162bcc1f61ff1c027fee689c88ce9c43c193a70b3cad8882ae9ea53228d20b9de082ff08baf993ea395a81e35ab3bc3b29bec6622b42276319cc5f5a7e9b69ee8061f8333e72da5f513d0d8d459d48a375ce73036bf564774d6e4529abf931d11c52771ec77a62e19c14f1c2b5e92d6e781f6bd1283a1c69091e057e00faf79aebf9384e3b3e8ae29ed6290cf5d907a3386bccabf491acde6b161919680a1cf93658740c84d9d6b3ac021dedcfbfe0fb17791635aec8b8c81ffb092f93b840bb6ae2c97a885f7eade85d25765e70801a0dea12411fd147fe0086b0107eadff7105dedf1bec8dcdadc364779ec8a5222090490afebf31c4eb43936d2ed8c8c607243cccaba375ffb00e8b8f64a1b6695c54fbbf47adb4e7d93b1e23df33336eb3f53e602fd8e1f9dbc4d876cceea16f91f695ad488e5e2fa2a550d6157a8c24de43c6c7c279c253a7a505ee8e8d067f6c97243303706f5c45efe8ac55b3517e614bda791c7b6dbabcc88d856f81ccf8cf73610b25e2caa40464f76e9a8dd8b8f29baa76663da96b864c679577172a824dedc0bde9218e80e9869acb442ffcb423a35d41cc4724432a745fff5fd02fb5e44f3b5ee7b069de2978105ac7fb079c6fbc0de39441534d494d185a60a753576526e381ebc2ab519aa9f142e8c925c122775a3fe4a8a3c468ef72f74d464a8edece3f7e7cc5995c466683985ae3b2161b02120fff43dd5e25f196cfaa90feff126d12e60877a0ea01033d3971e6bb71d8882615fdec253ad16119e97cefc45f2d060e455cb4e1918c457be4230bf24ce968a1dabe6ed92f6eba416a3214026ba5a381f413accf1f21d37a67b95e0051c7080effe3c6f280fb8e0daed95dbb3234a412496204e5651af4fbee5b460f4a678f13f13c6c5728764bd9a8837caf753721de6e53e87561db8d4b7ec978d15d7d6d5485ac7968ba9dc311d103b29532a8a6868e41dc09b481fc8d01d61aae6a435e12b164de791fc23a4356b8d03011fd09808b503a6025651eabd4686e0eaf5c65af0ca3c0b5ac45b2ade5a41d1b9669a45f8d8ae75b41780a71bef9accbf9b22c17f7b6e589ab9bc6f74a7ce5cdab7a35b1ec3b8f2c9ab42a3c0045e0c47d66d049957db17fa50cb80958d0decf9f25cfcb063f19284d94c6de65442b83c00452bf0975688879806d1ed17dca7371b897ae5e2b6ed6988eeee79a31d472aa8869504cdd5b416f3f75c71f5721cb714f1c5c4c645db9cb913aa684dd668b67cc04ada2bead43cf6a07d71607cb89acbed60df3ffc341bea96ae5322b5c1c4542458ea28e709d9d5ca30bc9aebccb34ca938f13564766a290ff4d3ba8fcd9625389ba89bed278c23027d0f6016eb94595bf95952ad2ce33f066c5d1d0bfc6eb67458e905ec980dcdfdee7d0f3910e8f401202529b930f7aa1eba0ee0c2c10b53e832c6516e6df50e9df3fa0f8da23a5015b5d3f448e8b962df21798d863638845f8e3a6100eda8d07a1aeb124b37ae98ff46f6e4e8e9504839bbee18437e773751afb79397ece1be1e8356e8b80d9b38916d8c0c7cd0474e0d6e997f475e0a492e4e453049f33b3fa5af35bf9d703842716e755d851285a6e8e0a891351a6cb990f5a133061da7ce2cd757329ccb79a9737ff60797e69c33261313db8e37e3afbaf7ef9bf601ca93fbf8a801dcbc9b79545511812cd1999e58e1f7451fb9cc5af80e07aaae7093bd38b293cc5d52c253cf6349e7568b1edba6aa056d3351b906f83d7f14c9403438460ca469f32c4df3ec15f564ae24142c9be930e24d201fccb7c653643ec6837180f5bf0c9efed7d00a736fd85c972e67d1e691bb4d58b77990fc6c20c1cc05be5e686ca21b6155fc40dc7b42ef7e3bed9f808c4c5cc07b5434e4612b5d829f42cbb9fd0737c0d44065c360b171ce2c370c90103e642a23c27b7b705199b659689dceb6a9459c37aad576d5bf0967e5f7867065814db3d96ae80f7ed0cd4b04af0f40447b2eaf6d0db0b471b1b5ffdeed17d38ae29fb530c0e4ec38a808660898c9182a92d6d32d7dfaca31a8071a70f519aa34e83582421fc36d658d275b9bcbbc9508f23ebfbaa50bc58d29393d421c30c7b58ac000d580c4284317854a3328875822ae2260502493b99d4a1fc775008fdbff3781ede2d40a0c027f37ec8dfd514b759bca955233ddc3b80d4180a4a2c883a72e50507071885893b2bddee642d63ff594176ed79f3c8ddf1857899d96cdb60d5fe035715ab2cf8b2e5fc3a5388baa6372130c4aa750450b886a5ef45536d347c47b92a2dc3f5e3de020a9b99799c4c023180ba3eb436c94665e02234aeaa4151240308deb88f28cf0405e954587b9dfb16d2d0cc7c7abeaceb5dc10dda7098ed21775c3dbd87f6dd8d61d8f2b1996b0e78768f0da1a4d6e41c97a5ff0e3d85ca0d65389c6716cec714bb39f71d193584243fcd9dab0331a57d8e1ed79ed183ce9e56d78c1b46a3874931d6f9b14343cf62da65815876feaae4967c8b8ebcbe9a1881096d4cd68d672563a666a4dd4157eca997d18c70f1a48ed9bc3ff2d74c034f8870b559861facfbc45796cc63a25742020053f5eaed4ffe8cd1138997ab7c430a977d2d8e4e1fac5eac6e4c51ad4c57ee3fc0e7d72c06bd7cf518d5f68d64bafe0f183c9d043b4d74d2d4c78e2938fb536f9c31c08ff35ed2582e7e7c72f4031c9e2512c913e738900430fa098e035846aacac65d436c4d9a9cb80d8a2e7e2b9a912976e3611150d0072f033c22f0f757ece2f7b4ed9792582fbe0db9ba162e336a506674fc9ceca3c50bd509748b08ce57465e20544a24ab49ba878c9777bd88baab738cf78fdab52c932bc768587a84eeeb610b79d9179368b02314fe0cb34a909b4e5cfde0a0458bd55b82d5b32b914267e7af7d50ba16a19a11590b3caf6208a6d5caef2ce83aebbb2957103c085bb3cc932b570340d88ec0ebc763454a2cccd0877ea83d48e79de070e7e5b1bb88b919b58c93781cb0cdf673f8d5d8ff5872c4f058254d9c9eec9f4c86759d33eb804b9ef6c1a3aa611fea6da1fece6f9893a97efc90281857ea6ecaf29f77bea2867da1abc565f88300ff919e79e93bae38dc50341ef298da59e747240712400bb1499e42bd04b48539eeb27939c99805badd6dec4ebd828b2ec665d6d9f09f36469d4bcae1a3713120723bdac0d6dd29c945082c08f0ad6af2406d091848a2fbc480d5fa86b01bacb80660a90c339173bd0198d04b242c0494332c4e1eb410e8c8612db5731e14c5aa920aa934e86b8c276e86e9b3324d863202892e5358d3cc186acf3d6b2144f174d98fcc6023d6d046470572f193f079807131bd90024265bc8e304c210116dc0d3432498e21a3d4908f1be2e3e8541c0696eaf836fb440bd1947992fc7418247fd0637075c01f59ac04fd85f375cf7feab079d3c99ad59d2a784895bb4a998ace6a7910d56d3b1adc4db8902760826861cb9299b1ed4830fd289e2fe4a8f4227a6974391d454f0d5ecf9cf184393a4a4cff36089893bca4e93f68d85e3fe1dde0b3226274afb148967bee9164d112f9a01e3bc45ab3ec5c914867ce0958471b93f81f5300906b8b3fda3fdec604bae42bea12da941c74019954176604f965531e7dfdea3e5a76bdc4843bc6878c877366d56b775e28e5b578d69cbdb70d91c8e2bb12a9daa69e404cac30a77810226b73e7013acdfc95f7bba741ee06017b44153fef09254d4f8e0e79fbdbc6c7b1e848d7e2b417f8b72757d366c998a323ccd142d074bfde9f6b0f287973056743695509c028a414d0d458d038c503cb9a17abe0dadc5e332cf08c0fa93128f7da223d24dee1d262241ac600f3d00c86ff10f6f1e52f83155f6009517af1449378876cc37871dbc10660dceb2076b2d60d11ee89089f9e9e82bd791888bdf815889aa450c5704c509cfd836b6e4f21c13b2c9a5970eb09c1fd30679f10039c7b5381a30f0e0810ab84c7d27ee26a8279c9c27913888580acdd9686efd1e947de7f82b2ba5e9d3717575bdfd741af5766d5ed36544ae80798c7e81efeefdb330867d2e5980c10786536f18aa455f57d0ce30d56a2a95f9cc1ed14ce64a8b8a84c563b3e8e7c9563ef1ea1ec12a0ecf35b9b2760895b07325c5abae49a298110b719271160a625916fe5287ceb887a47cfef4100f5507ee0bbdcf0eb0ca807583c9546e31d6cd4ab01761045a0be26d09dd8372123b5d39dda82b14f27aae22e61fba8a06947d04e445fb482d282081788fd2e6611c528e060f19ef454db4efa6be8f50215ce94d72e0960272b355259790435f064ee115ff81fac7297ff1eb2104edd86e3b7d39df5d765e8d396d3279c0633ba7fae1a495099af982c5cc567c9200d97efcd7d89181573aac328826ac23a89cefcf36a44fd4b8dfd4304c8e8515af0f06bb39389cda7cd34eea3ece92bacf52d5ad0c20966afe81f13faccebe39e7aa6177514959ae1a39d4ed5ab26e263aa3c8d3ed7dee6c28ae2bb9c36f3f724dfe44027366cd23a536d22449a7b9e1ae694d1cb82f7aa5f13325bce829922fdac9b395dfc0560fa817e77ec82e3807ee338c6e55bc5ef5ec23e9e3a82d17d24adfb48b8e9d4abcba89559139bf84d8c716527215dcdf7c026dd25ed3e3e23cb187da4f24a9f3bac3853f0d23826fb98099f1b88035fa0d71b82f021c517f167b74cdc7e9c92a98f9ff9a262c29bcb3b54b84c52c4cafec1aaa9dfbe0986288b0b712f2d22481f57bc5025845a80a50382423b34be9db56fdac26dc9331e4cd616134be458af94ed506527dbe3a8995e5af370817f01aa3fd657cc3bd83c896584136f8699d735e583b2baee97a054a3f975f286b28ff949f65acfca0b1a6d594049aebf6f3b04e8a5bfab6d047203960589654fa49f77d5e3738b7fc63a7949b83715a031721ee6d663217523f545c296d8e18932c9a9e419485c4e96a8e43445229c64a91560d3b234f71e74f2ea08faad90c62fd39eee6a0b3e4405247a9ffb16f7770890e6b05b57c58a687d9f74b9a998713f445dca1e825c4afcb81415059cbfb1666801485b3b5d606b9f4abc5a05f3376a347fb4368195827b1e39c8fa4a90d5369b0644ef6a90e26091382d42b48247bbe2901108f20d1dba8963bbdbe9d87c0b49340b469e4f6e7ffcad8bdc308b1f2969690dd5e7fcc02b6b1dbc5c27461196f967f9c53136b53a7f60d0d2e2e6e91e65672cd0fdfe8f1584da678a398031a21a5ad1440d2cbd862a3d760b123adaf358c2adf3c3a381771214cf7620c188e205069344d1685e4b2eb1f42aa37510cb0c210c23116cdbc76c3243d3ad3535ccd12729b0a589dafbfde7ec48bf58a296dad3688cf55b970f9bc962e0124d0f0ed173541b52b8c6558a404b5117c7f5e7c31e1641c0ee8308f420c9ff7a4ab28436763fe564ab253676a48a833bbae22276e3257d84c107eae27a5f834a03426b14ca442623ef9cde8ef43dfef5d9f5ff446bbdd70cf40af1ebdc9b8ebcd155c432fe3e954adcfaff1f9e2595a79ef4d7e7bf380b58bc6fca19aeb64262492e4b3be9f84ed6309007b1bc4151faa362e49a9a4cc26647a80a7f94f7c573e652dee37fd20438e36dba7881000ec3ffbcf32e4e42aee201921e2b9ee7c0cb089f9667cdef2200c1e8a799fc4cb6489af6dc6c584408dda9ff426f2fa6f5d726a6dec5be7c0fc53bcc9c4629bdb7c2827625c0dee505f494345e20990989fd93561e7312a98eb77a5af844a999173fefe48ae5c1ac21593dbecf6e8b7d1652988c7299d5812af4e6f5d963714d61aecdadaead391c9a818218074b84ac8d7211549c2f115d00000705edd2700fc3c6737c99b25658d13fc135eb531144a2785c8eda2e2f82b85c99c6da9b65d9b3c2c3d9bcf62e6a0fca1cb51038d6d9321f2a98722b225c3fc79566b9a9aed02c805257f7acac74700b299d26f0cec76f7f0264a4c0eb6666fe2c9b5dd8a6312ef7b8bf47223a28d6d351a1c5b343cd1d8aa8e7d8d229fe910f7fd4a5951ff59f02c5847ab4c8bf9fc5de7af1840cffae0f6b712043aa84f8abd196ee4c439374baf1096f70626b95ae3edc22aeff1712488fe31035417fa72aa99158fb5875688f988df61fade7b6ee8daacce5cc34c7ac1774be855f28b4fb19f624b85be078f0570db792d7c35dd3b78e382012a3e522c76e25412a665ce99d7672d8b30c5d3951a6d10351eb2624c555180772be51c58e1303544d9356ae8f2fd64b6f472cbe59487f88dd28bd407f32c46c7cde66bac77e938c54785ddccb8fb517afc824828b6231678931e375e7998257743ada81de03fc14546c2b3c1a79df43f0700277362237af6866d796d78c5a7478742781ae06b3295f8b5d7e10f017950bc2e5dfc70261bbd6b4258c7e0d05b820b0b52afd87341ffebf14e7a735d3feaaf5c572d3d9687264fc32c2f82805c0ff6705bb65fdd284b07b980fbf2c68fd21f05cc788841db9373029414365d3d0ef4faed5339796e0ee10ee6d76ae5d3a57a69c891c455bd16c76abc4c26f397a70aa15f19c462e0c23a337109ea3e2790abe5611342b9557d1411c438fb574af5e96e276addf36bd58e9c90f93a6e2ce808517382545e7ea02442e395f2081d91808b8f801ba33b2c15e4e17e893b875f5087980ea1ae84d3cabdd8bde443af6580827534773a0f0ce295389fb5557a1fa33bef05b6084f63ca659c154c99aaaff053375bab499a37ee54e2bdb5263c69c73510c573b08071b298d01897156dcc8005363fb26b09027aa811fa3fef8313aee5d24f7ac031b2fc3a2dd2502b6568658661b7342e5f6035c69bdec5ccceef9e94ec787b3a5350f5d6ee47d0161ff68b767d3514ede68bb7bc1f667061dc01c9bdbc6c055ed00c55718078afb1eb01bb0dd5487e793936fc3c59b356c216aa50e8bc57d3a6e7965d8e22a06e1973af90e107e032c8045e309005dd16e5b015fcafacca1f09569478985febbe653c6120a87671e2b681c31f054f71de46d4ae45245801ebba4401b1d8976e0254a2bdd551029f0b5470abf461d508b2c325358c938a67eac44fa29eccd260fdc24ab3b9a593a1835387332ef224fa3db3183db58d8a1e7aee8ee9ca402cd7e940037c1564c8a072c3df0203acb0c4253628a1453b02d9f2965d74b67ee1cdab11f440b59336b1fba6cbbce775e555a651268056681750bae9438b4fbc74348f31fb55e8ded833fe521c5175afd06c7b2761ec7dfe2772c1761b5caa895a73a4cd21088251785b7defd67f52489ad815ff60bbb73cae2551ac6a76a4200fbd9194982a2c435f6b1abfcd20dff8880023b3685b16dd9b54a0825153ca7d720db7244742f804b0c344c000ce35151778a6ae7861e59cabc41889a14c913be6714a5510d6596dbed043eec1756ef7427f72cb8746b176a600b56060f0f9b874809ffe1dce2f4e59738a09b10f5e952a87835db3798a8d1df2eb4748bca471cc42282501b22b3a8fc1fe66e23716d873706b19b7b42f7899eedeb70cd1203d95d561f02426dd4e3a96ff94e759965caec95862a16ad804d6f4693f29239944a88f5e9fde9023d7042c7a36a3de5cb1025ba62153730b314e96a481fcf8d01baaf5e83fd7819cc77d5c6f061b145c3c392cf71a21943605a34f8178e1856354a5a9bcd20ebfef61fef84c01ffb06c3e199327455e93f4040b2d11af0147604a81b62fb93357e252aa10d57aaba9440c7dba596eccfcf9e2e0542de28ce19ff61a0c3502f0ce943ea9253fde0d4d55176f33186d8ba99da6bc2c621bd604ebe13bbd1620c1ff634f13f4eda9c9f1ea12cc9ce8dd46679501f649c4b3c9710e7deec89e6a27443f3cda4badf634f3f345889ed89b9b8cb2d61f89fcfb37456de9b88ad9d4f39297f396cc0f5800129394f25196d3a5242d360ef6caae91c861a59d1995691e2e621898481e23cc9ac9988c6753be18a6a4616710814045aaa8d78eb987aede4e8b4af19856cdc907914d3712fad4e817edb027329a25154c2d39312a786872f9e3f6443036ea7741b2e123228e73bfa2bf20f9382d860c273c9e95c99c1dc52e5c4aef9aa83c419ff9e860d335b0f68e33e371c9b41939001e7fc0e5ea84bb034df761e301fb6dd8823e647001d5d767dc611441d83b056b5e78b82f08e004480e5b0114a736480be2d58e9ea68ba0e5c997577b3f4fc3db7da2f8c489c2683f59234fa073182ee69fce3b71c2db6a1587127bb2003902d20395dfbbd55f872b600bcf55270d0014e528ee9eb5ef5ef197169105c55d51c8fd4375e903124a9b469413338d5b4df3b4f63de371e00342274d3cdce721334dbdfaa7f1c59d023390707e4b850ca3269659de1c5c3e8dac65e6c8d8dfac03e8db6a37fe29800ebc691eae8ca11f144a24516a526d2acb04d092982f0efcf202ee4eacc89133e82033e560897ef03d50c8f23f4b23e6b72c4a2fc5b51c2f0b52fd9814d9efefc98636b24afc5fca92eb0287bf36486e5da43df322b00cbf24fa3e1574b18692c431bfca9080274579fab9ac10a10db3adfb66270a649c609974dced06180c756fb926ec92dc79ad09367e843bf8729dcbb38322b38e136c29c33d0bf93123bea0fc85f218dbad8d9142a8ab8dff0a4940b7ee7d546ba1ebec6f924d352079a52da59c1669d05a238cfc6d3278455764a8bb6e1c48cbb90ad2e2c4922cdc6b6a95bb0a8c65467350029ef213f0b822fa1262ae2f1050b924b79a6eb5e5909668c87bbe44ae708681558f64963a0c31099933c3bd234a1bdaa3d7b727c6874fd0e588db39fb2858982b8a6e9a731a524783e6393d8c3a25e5bc624a70b3ffe0f1144eb74f4f5e7591ff04df4393eb59006faff5e86705cc708ca116d5acdca4bd1131f86cd7253cb493d786f2d6f05f8c9cbf34af05bb79cbf9fe7f2827ee703773ed565d4d9b66eb63d556867c05a4c145ccaa4cc5b687e33005cc093af5329d82728c7d13c392ec8b51cc741199dae54985c2c14b586022ddd337f386fd6c3bef93b78ad8878ca7ef9382b2404a1d11875f3c2e4ded5ba26b0129961181b53e3bb3988eb0bc191eec156671fd305b21bdb7659b01d32d5d47be9386d47a9a66d0a6997778eeada1eb194435787668e9520c15b214d54a1e7db8669811e8ac0c0951150af58ba7f6c4458d4ae09f4c8b710ed5333948c82384a33096461ce9923f586e11359eff8eae798fff17e8ad0a624886e72f8a9f5760d62ae22d62264314b064be9e31f037020811a4e9867ece8edddb9701ed4f2432fb1269db22b3c221d7780f1a197756279a1ffba20fd252d13e0600112be6796d29399c76f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
