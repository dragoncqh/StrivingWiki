<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"894b968f66543b050266ca7444f22801b3c8535ef3f2f714a815e71aceb6a93d62b9889f36014d0d6ea568432d86d816fbd385ac2fdaa5884210d8ddabe90d303b20d68a8b1cb71470400054bc90ff6c2b69ae8e1942d3606f8f3f21622299ade3a7240684f80eaa66f78af901b325862fc2e4ff573cd4396810d08e8ff3386aa4c55dabe5a28044ec0777b46ade032ee8f829f3d9578cbd6762c7b98befef655a1bffccfefb81226083125f8108639d83ad0ee715d558036ac07ea74aa4af4a44fd9d1f434d02f4ade2b42e26e92fd3e00d302bd101c29314411e3f1d1e706d322dc8c11191d26e3937ca70dd04b43b82faf1332917ff3c38808d4a2d3b8af12f1b80d9a7c115383d964f00f64d9748756cf325ec8938a5bc3ebbb5321116e61185a751f49969b208cff12d8441e00daf95a5114cfd238329d6b5674e88fc7efc6226770b1eeaf0ed4dba926812ebb42ac00e1451bf65da470202076ebd3b87f0be8bc67fa61fde70817390929fe167811d99bccfc610dcf6ff9fbf7d8dfeba7a7fc891e5cf1abd6b5cdce31f5a155979dadb8eee8320bdf184f0938486ff02d5f72948fd7b8d90132e7433dab07b19f2551d103c1d3c20ed38eec40a31ca40bdf86d3f32ae1ec50eff8c12b02612d63b539938a8a2ae0ff684e95a7ead215b9ddadff3ae7871be69c05a21400da4b11a18e4eeacb37d13fa598ff5ed479df175bfcfa2a951c78818181beb5a11c930f74cbbfd75aa3a0656b5ee2658f7dbe7f5ccb39ec9bde6a170838eba1395238429fc79c5cf29de7d418c2a6ce03c18ec068ea684e2d80c1a7e6deed7b0f43338889723eb9db82122b930f266dcad604da256f308c271e6dd1c33932d6084c1437d59ff2e03431fc5fed0265608762ed8bfc580f43d8033ae87626ff662efcbca7cc231af61f14c0b5a48a67f3b1fcb8110024f1464d7ac7e15abe999566fb55c2ab674d80cd4073c1eaa411985d2030300376bcebd5474ea7d4805039e4b0bf49f3bc0d82836d2d0d8c5e593536cd12d051388ba3940ef019a0cb6b7b477a861737999bd6fb64b73b94f3864a7304b00d81f1375e8b91453e06b50e5b4751accc8ffa2c72bb43e1ce7d3bcb93a0a85a9209aa633ff71d0e7a40c12153d59f8483769070994983eaa9bb22a3f27925771fb47fd975fdc47ff0bdcfbbe1edc8856584ee57681ebdd3f36e860254b3e03fff1d17bc45e28c3d1d44d9d78a42f2e289f50bcb3d020096bf26696e16433501b2e28498c287b5aa45f78e71c06bae2f0e329e2da10abc4b179978bdd4386dcae539b6089bad00d9c188ff16412f48dadb6e727e52bfa2a267ab829c2202023da397262d1f6d6c95a6901d34b68836c1d0149374ebe15e27cf1d38dbc91c952ba6710a9a2040812123410cf316f869f5ccd2c0136b6e9c5061dba3e9e31f52d14dface3063a5f38b536af414ba425e50bf457401a4e8b7d7def0bbdd570a40ade706a0bd552147fe34f1e3902b4081efda0bf793e08cebd4a476a6de31b8a56376650f1c96039951833980c46b59265353fa020db6d3e8a3799b982037b87884a7f2829c034177e5895571e305be99888ca31be38dd2ebc3e3e1eae4a6f838a1990a2a2439c551c44a83598ccfebcd2bca44b8579a89dc1cd6c6b01e9d721806a67832b0e7537500d7f0a126570b46b98a54695d443d0da4b9082a36b4589fd8d4eb59124de83fc387b510cc360413171a4395b67ede988653ec32de6162ec0bebd1666940529aea650e84a0b4d296e958ebc85e52deb4a012c8be4d2e36e06efee4c66302c9ef8dd98b7aff119fc1aeef69dd9909134886927ec6275f0d3b2e70297d7690af4f56a67ad8021b33ffe29aebe150039f0732be93ae7ae9376eb81b66f350f250212ec14f4a150cdf143be9a821c6d9bc8dede6b56278d3ea05986b65ebe5834e982ef760474989d4b074cd8678887f2e36d28c0f5cd2cee3a412c19ff0e05187761086bc90118bff3b1e391207488a624ccfdbf6ca99b2309f55eb49594e36181c312f6d0c7dee57048ddc271d7719403163b04d354257229940c232dcf40ce66693f4df1e3d1f989a2e35aa8ef43852baa7b25d6558d9d77a6e8ad1c777ba713bb0fbe93d0c78d1866c6d2d5f585adce0e9accffced2aa5251e7e15b58d1885361ddfd7fc7654c094648bd9598d269685874acd413a4fc7f91d9536b5b0669214293b5a282122b2d91a21e2ec07179e26a6043bb3afa81dccf2e131543072195c866250d3b6fa18d61fa19740ab69488c92a7e50bafc38c7b1abc3564f03cf5461381c57ba027ede1c5acedb376257432e314375ac108cbfddf46a49fcc8a0b1dd048ca5ad5dd83bf4d49209d797536865fdb2d57db2f4553280ad20d0c63df509a36d217bc0d8da82a82e38baf23c8f627d9aa245d20ef505438687de70f5811d5f072b36bafe406dda4796ba52a3e0984c0f276a50f3bd55b7828e6d7f37f92142bd709d6ce9957e8379afe71865598b41b7bd2aa08557da4de686c090181c735513a0826953b9c133d2384b942d003b3bae63f6e565b1e11853750d9a0df630ed67c5a888179d7a1254ec1fffa53087b0aa30e976efe6a90f99dce61735d3bf7c9ffb821fd8b5707c4ab7023455034ee147729184af45c56423e19afc6ace057e1d8ef0973daa489c717f7e8b69f676deaccc88d4d140f7abc7d67804521b20003483b47c659efdeefcee8aa36e32f193890be3aefcd2d5b902f7d1a7325505466e07e96340143237f4b359f8d1fc8867bdd24f4aedcc2fb76d7ed5efb01c5ad06f1a8fe79b1a82b48c93749b100419a19511ba05303fb8743e90583dceedd9b35cda4e515aca59752f1425b8c3101ba5fb856f1f46f9369352c460c570f572ce24bc901eac56b1cef24cbeeb7eff294afd7b6719c48fc2a9e98c909580acd578e372da4e045beac4d8cbe5c5dc5fc5839bc34181c16b478187fe7410a9630dcba290c77d806725c965b963fecf13ec78fc0949b601111fe7f7845371dc25b59ea2dc73987d1091b60cd795ca270b71a34d62557d150e48b80f56c2c1e991a3a1e7211cfb7a644c59e4a83521624af1b6254ea21ebbe6135e01ce9098d274028a311d5edd25c883fc8f620b3959718844b02ef59ab97fc3a23b01bf5b8387e55372aab1682e4b9606f9e7937257c49e6018202c20a723b28f4227c694c23ee979754f77a5b3b3901f69c0cd8163809c43ef5d6445cb7b8de905b753114023329f1eb866781cc6fd6be23ea7864d2b9dd4310cda501232a6bbc76906688aff8984bab3c37c3e19217458cd958f80192d16a1fe8db5243686638f87fcb5f275a125ecfa574b6f7843aa2b30aed2af88a04cf5609558610b8940d48185bb7c3daa44ea71f0eb32ae6398e3d5fd2c3c41f75b8e2df59a7354e2dff918d02e5d6b1b03115ed2be017ea3f052d1e80bff80daac058f7f78958e7217bd4fdb1bf9d65e2c10d93090d3d48f3b76e9032546ceb7a987adec55b65692b25c13bb079d5cdc144128fbe3d1450ea0a7ede92580ac1e281c1b2dd7ab4122bc074c59b1067a171646570f84b67401701a6eab7bc1413c6ebf48694cfa3f05c164f62972eb5710a227cfd5c6ea95d7f466612e4ea900b655f587973ee49411d0221cf88c3e0b57a3a3f282113a76128f5beee373076ce39df6ac3346c7d7bd705ecefd52472bebfde4ec0b354973b7fd941d65999dd2965c46cb2727e0ed44e0dc9059cca08e8d95b47fb6b1d725e769cc4a7b3a4304f5d0a31bb33a39f1d7f8af0f6a173d7d72dea13e76d1d3a94701dff8d81f5bdcc951ac133f4dc37cd794c3124a85b1998acccd88af94c3e9d7926d7fafe7365ae18a25e0cb85f22e3e2c73b87260b2c46e210e4261eadcd6ae0638a07b3aedb066b079ad04e2196260f923b381b889025964a8dd4513edb4a075f718b1a1627ae5e68ab13357c1c8fec66849ea030297490a2e3bdd5b4e430a4cba8b631d9b0542e6a60afeb1e5fdf7cb41ec8ff6408662a90bfc652c1916c9c387025055bc5ce9b124a530da07b0c42f9bff49c562dba604bf3c553c25dd29fd1d76b7cfb354524ef0682c369e0fce4dd0c3197ac955a6e42f6f888c0d70efe74ac42a0f5403c3920d6df662c1d94c1a38de58c478a96d8cfb17b8e33d48276d7e5d2273ea3a26330e53d4ead4bd67d3a9e0bd2cfc68fc6874ef54ebd9ca88c3886527e989836b8469d7e08699496575817ef807da5d8bea0fef975916032b1eb816a6d44c3791af125b45bed287262f68722d096eb3c17d806dcd2251ebc87273fa046fb33e84b8ad9acdbe53de9eea1fb9f8bf96294bad5ee4e15473433a134526e6d7cc3ecc9b2baa49513d4a3731e0d152d8f72d5df72f1bee2ff6a13fab3659f03e79dc0661e9f7e58b604e784d021910de24f94ef391bd7fe070d90adff24c2b93605eff04229a35b64de31aa1532025eef3a51157894d75c08de5ae67346d93d7c6401d711780715e127eede00f15b30ef518a56df3ca1aa55d5cc581f29b71ae0bb7f6eff5083641792ee395c851c319f8ed3d3b20cecc2398c4417748a74a1152dd793c9fc7febe50ab359e9297761355f368e4707face55d31de93ceed6e5b24fccee44327a651d3629d7de0175e70e8ea73749b44c7ee7304bf6e600577b24727234793d85592291952ab6487d560df609bea12856742a09488ab88f92804ee89304e5cda2f87f6adc6ba547f274f1946dfca5c3e1b35f6af446fe3d5ae32e31ed88b4907c5e59f90971c2d79c4c0a63a56d47c081ac7525888520eb934dda4f43671b64dc4e9fb19a866f343ff383efb0d2db7ec04eb48d1c3bfe5a457cc27bfcc87e51921089a5ca7b986cffce0980e1089b0e947c2b88b390173b145e4401317bab7f260000c08595cfff7072c284f5d4d3d726bedc38b8f37b8ec1a6053c7f1a938e1d84d96451df1b3d7b96424e0721dda3d4535bccbba0e7a54b6d231bf5e69c12bc243fb1af05255136ba00b748acc32b78d98786055e128b211655b74a7ccf76865e8fd0d802d9fd6d3a0466cdc41c43e915ff997151ecebd62dca6cf09c6847d7cb484196bd89147dc5637d72096fbadf7890c4f2bb6cdf74a26221eb80ca2a92254b90f4d5eb3c5da5c47e59a67626df00c70f8a9b146cf25b9552812d5b2bfec2598f9c08d4cbaf9437c2527b3b3b69a29d523a7fc8e6edad11cdb785cc22285e8e85e995bdaa48c3aba2e6172907d9d41a983a9fc9bccbc7605ada4698d429cde4c60c8f3e5df5e159e30617250e3b0c3b9c596e821d82d4b26193b0f74d15ff52dfd6260c27e95f3caa8677c3755d788571db6f95b1b653706cf49c94206f4012f33596f470640f571ae3d9a926d0dfa13a8cbb16c047210798e14732f96cfb31445df6eb675297e62330e8b773f00bc30c9fd4cea9f8521ca18c2a09ed2ed7c75dc620b13e8766090f291e87ffdaf126a35036da7bc88eda351dc84a036031bb02757fbfda5fa258cddccdc0dd84382f08a48d3fe2eab255f0f4b3874bdafdf0da4164286289f8125febcc1741ef2108a56c1d6ec676fbd4a1e266aa1ff4aebab4a38506cc319eabe5bc20470a8f4c7d638b2f050c030d67751c27988794e9e8d91aed9f0157f1a71b420dc7a6ae4a6507351c814c641172268846950ba4f9b8c0a3f53d89516b4c24199d86fe4dd87c69849b5882801fa0b067d7555c39c581a647df87068c114283c6f9b73184342477a5174a6c0245770d3ba132b0c8924b106582ba7a08bfc7fe304b7daab428d45acdea3bb70180a7840709af9045a234eb7a49e63068883764c23c9057436ac5746d5d37b5423477c4bc649e009b742e5c045a7e538ad0d72702771cebea808fba9f1ecda5c65d1148e4debe48e792bc573d6f998603a885b76f4a2b0c94329013dad0b58b4f74a145da364b0434ed21ab4d22fa05f9f7576eb7998fa20a67d8519b02b56bba768668423e59c556c382154a084062adbbb230f6378f6a312571ab62d40ee53e001fb6abe0385798b40ed1e938c3f20e828254b1b82d7c6bd4fc5a00dd9b32679565d25386cecebf8073278d2490151234598b46bbf5676948ded3d95fb7ea533bfce12cb290820ecdf8c42ff8781c1975bd4461b6fec1e2df7e68b08bb924b33e8d33eb19c56adcf0cb207f380e63435173917dcbd8685490fb3ac048e2677350b67ae15c714665f5d194a9584dbcba35b8378f62b29cafc72c2bdd3f7fa2573398566c9b18a3d5c3f68a20658eb891b1ccbf6862ec34770104335c800f5bda42af76cd6d737141e45545252faf8b9ed0ba141940b0159f3f78be73ed54a70fb6af34bda55af69f5b983343fb6d43209f62248f879de0d18a3faa23e356d04a1e52f2f65603a8dfeb2d5c7ebca94d64e33ff068ec92c2956307798856a127ff8a143ea47d11ffa3af294ead3036563f1d358dbeed27a79ed2ae1f484df0f10c065f6684b6e15558ec0f1f5a6874639dcc5b8cd095eb2739c976637e5d1bffa14da3a3dc592b89d8da097cd398b2a77305816dce1be29a62d0bd820c99450264884d4657df8a505b9527a0600954d08a219cd6e9a0926a567bc35a40cf4c536d6899b2f81a6ab19c27093e534d03859d9ec5b98bdb1c048c2f8a8cf3465b69bc6bab28391555a5f480fdffd69031b973bb54a9069b6ff0346deca229cb418535e2da144082506ca4d1682a5e96a78dfc3b73512b0f3260841cadf7f3287db89f88a7144a3d5fd365bbc007261be6d467748568ca5a25c3433dd07cfa7fb4c553734f785b66290823e063b74887b844b22737639e08212bdec3bb9f71bc112deda185ca404589257475a105c199e5247b308663fd38b635db27199785a6409cff6d13bd5a4b5ab032b89049cc97fe817349df766b75da3bcc96c90e943831ec35388b07f082e145a19f130809c973dd9607d2ef67aad8127ee5f72bf154d75f34b1308d73d0ba0f335e92dc387c92b9a11a30e7bb6210880094a940773bf5441ecb63d9eebc5a6dfc61b7db7573752b4465936da5fc69053afb14bc3727d29c453779c97d834a0598361d26b2958ce264c3403b42c31b23c7f890de747fc7104619bce3246836cd86174fdcf4e9fcdf928579c798d72ef7d83f545e680dfb9e2a61b1379a214712ff68f6b1802b8cf5cb4d7670f9ee003cde6d118be1f9b0356e87c2bb1fd284b73a8bd808cf143b790cd167cd1a4525d231f1387cd371651fb9ab1cd1e5fea2dd3b7affcc6de89915263c11f46ca874fd50e53b43c07f27f3179fc2de6eaf3a29f8115ba852849474cb0085867049fb8f252c23dee5f4905ca714a53e8c85994a36b6088ee0046c922fe5fe941ca0158b8ec0e5de7d1db6343d17eac0dab62c204fefd00540d85142bdbb080599585170ef48b6438c5f12e3720b39cc3c6babe89024ed3eebf190b9d2ea10061d3572ff7fd1fbd7bf02346686925a1e56e9050b645ca983570c0b5ade69ac1cc3dc00277e152f948d4bd303c1bf4e153480d258764f0ce5e93160c71716a9401bfefde3db209ac80ebf5a0efdee9411fd40b4f1d722e88f7601eb58bbca4d77c30ee8852ab7504c36edfe7d305cccc608741df6c268895cc78612ea6b7385a293a543a47d3c6ad811e12c08d53b3a01f8c8b4044f85e98f284618f57444d9263cdb9d1f2d463df2a1c3eb6f8a299b091938bb1fff54edc6cd4e9ff61ef2939c0c4af577a3946e733ac2f4cf8cdf573eb438effb98874baa252ef87cb55b0ddb93fbad4b4d1a3f88b78064f8be54d7b5acb13fa990fe48ca50d90edfedc931fefea4846da4c0d2ffea0e2ba003de88c241ba099934f068ab050f67cabfebe61e4a7c5cf1d6a9e92568eec68158d0766e6eaadb97d5d6eb746bb7e8655a2edbaf0361044d9757a78a8fe225f31f213d646d256a6871a0398d0af35a8fadfcc7e78a1ee279c2753e7895862515e63a3c422ba815a4ed1c872a65a8f48400e7b6814276950bbee532a5e2cf5fccd3221f43a0510f691d93b3920cb694f0e80f559e32566001a861efb4080c0e8f5355a4df93ce36241e54b7a141539294f4bfdfeebfc7b022aa8cbcb6167b1d37d9b3968b6bfa5b3ba44279c1d5f9a9dd0a54946dddf0b4807e0fcae90a5592c21e2e5850f7abe79acf9be47e15a19bbe9e046da0f73e3ec04ca842ee0788da39953fbb4615661854db9152ff500b2d9db5c69033d780a0d296090bdbe68ddfd510303fbf42503bf7e5873b09335ee8635e6f7293424a4bdf95d920c7f61dbb0171072d3aea204f9c74f361e49050e27079751f93a62eeb3d2af6c3786043a0112bfff767ac2e012e9c830bb2a535bf544b93e3496b3938d3893c3280251003e22868e515ed88b7b17d30d08e539c911d89c67854962aca9f8bdf58f3852af9ba8b13cfd382bace96aafbd154c82905eb5ae4f27b265e32cdd2881a6b9522a0e73e110878909cd6b65d456139de8433944ad7b74da56810bb17a14fee1e7962ce884ee2fa00aa1ffe9331ba38f1c3ca8f2c494885385130a3b79e75ba91981b630b3d3c872a8dd7e5a60bc22dbd5f8d74ad30877b39e2e5a09f74b6b44baa9b3a93018a499cb2a7b27b549d2c40d4b227166430efb9be3097138180a72da7a016a99d5aa777debdfdcf58f516f713e3ad12518a8f79ee56889b87d1397d434d84995ae4111208d1e63fc57683de7f073ae35e19d6445cd5c8f3b399fd085f0ccba4c47bef31f072f8f81b253b91c3950b4b98cdc4946f649d89afe87cdb6a57f1809b9c6501633ac0023ab92215fe969e676046cdd280f9f119da8b0919c055b0ed1c38463aab62320c15015e5bc718e94b25ee5bee31ff4d4fafdbb4b24e3a891ad01a6e1af75f498ac38a9cd57770cb41a99edc3932082115bb5b1e493b3f80038fd084649bb5f22767fe4a6ddf4155ef926db2367ffa0b898bc31bd1e354533c4c3d3a9684578726ae9e6d318eae5c56f326acf4542116b3157e718c7bd7ae14a918e573e5abd1b8260042a6d02a9d3f63c35d8e345f082b83343d067a0c4923fe5f1f3c853458d77c27bd77f8cd487f4ab4a01bdbae9ec624851502bd4491b81c81991ab97e52199941b4df95500200a242b96d3d269a2c448d0151c3e16be52089b80ccffb1e04201ed157e0ce08d976c2c13c4ca80ac0dd2420e0d3a4c2fdc1b8a9ba11fdc8d17153d10c016f1f899bba3de7ad212f1ae4c6e238486fcc638acfea77757598e131ce8d33bb80eb9f3c7165e42b32a85cff40d05e06e5c9f0afebf27959856636bd0f6eb0f14a4e1c5c4d97646c904c016045e24b158bbc158cf2e60f206033ff2380c63b745059d15b57374f1e76074b4f0cf4dccd360a63e5048d2fed7d7699196232d00b81f68386bb15137d2ba3c1db9ebf40fead19012e9d2051a941311ae79c54b27d9059881577a9bc78629c3466e369ed8c4a6f7d0822074ef5f25cd1016ac715762481a0ddc021977404191db451fb39a7d2646dd72763b3d69e5fb119d9dbce5f1ddc513ea0b6d6ba6fcec20dffd9d4befd3c6143d7149adff4e70cca176f624b35f45e72943685c47270be8331c0e18149575293c87d578dee4e1d6ee2e001cd541c433fc4e94ec2bf2b7ba5954dab37cd1a66e800dbddb015efd0ed5fee8aaf0281145a08826f0e427606c7dcf0a2281174cf9fa9a6528e610c8088e0a7e75290871553ce1c47326e4c19022f18352e627d7dcbdca57bce051ab63e42ae1be88e8d15267035a798094670ca6034a12e6f7f5247ac4fed9d96d8d3f73bd470ab2def78239f12f7b2dce319ef1e3773700f0b6a04de556b2510a302566d7214dde8af1fd999c523eb9a9a9bff6881c4bec746012be0105799e1d531ff90a72ec2811c8208d9dfcf801643da435b4bf976a8e3d52b1023782b999904a76324fb1a1eceb7d637e4e098839a9e464fc4691c9a05a564634d6ed9bd8391731a5919798bd722bbc5ac045c20fac9046cdffb15f1cc25bf2df3e6ebeb768cddbabf424557b794b92d8d8427ade70a1749c6cad0f13664082d362097d4348a7bfec9a08622cd9ed337b8015dd7fdf33768c2794b841b17cfbf1448f1e0e480adc245cb260f5f594800c4df05c518cba3df1a387f012163b99b92ea7bc59216f02aa314d01fd50119c8bae7724030dcd4883a2299b48d75595b37b85d67ce17ef17ace52336d7f81f95dbf99ac549360354db5ee7c63d909dc7fc492b16a3caa88cc59e8abb81190926928045e9f91d48e14487026f20d25d35e8e3c839ab2c7bfc7ebe0fd735701451f49efe1cd76ffec1be4fc79fdc6d1f6c1fb568f69d8c2d7e8ff9d675d2b78c28ef18e9195b3b63bf3bbb0a35a7184559ee3643c7c96d2c25f49f32738e19813bdafc993ed1a77e691740430fe3f4c0fa2f64eaf7a7b2df8d72ebee989e00508ef39e1cbac585cce9e0633f09023b0f2d04dec617558414df24661cab52c3735cb5dd93fd5c2d10452b7a2412575458adc79a725a87cf4037bf32d9514c77f38eda67db89d7cf1d2ac4cd13533f3f78c2754b9f114b1b635a389da0a6adfef9fb572a5580a282d28a25fbe23a9c2e1be7791459c320dcf33737201bbf078fe83ba37afd3a8a01582829b4973659033aae707e1329ee99af108d5291d167b565243ae37eb1300036edff253f19d9baaa806a14114ca22e5f29100a9528d34062a09738411c9dc52e9c8abc54d2904f38239cc95dc0e8191987f8ff146b0739cbaf1f054285b89ca1006af4d4c4f29cd50ae4fb24e469911aa4dfc0d49fa5a163f27a56fe07cef2eae772c3b75d89d7e2214743e1e94ef61009da4972ad536c5474291dcede390562d906ab216c0fec376d00e5a49095cce3d4eb1395fc2593bb4fbe148e906ddf306b31bc14620c59650ed284e50addf3ba552459e177d0f3e66fcc8555912d2c2cb3c30751ec9e7ca979e194901046288b07a6a9520113e3b23c2eb9bb634bbcb4535a7105f5a3036e653c1cf9ec9a03dec18dd49635e3ab00ecf3ec902aef18c2a7b089bd103fab754bd3cf2707e76be110f3171cb1f9f3340d2128436337526fe669bd77646d8c8a2cad34bb5c568b0a9f3b5bda7dc363e94559f87ead1a8e419e1ae1af912cbeb2109bae60c45d40440793b7e8d9359a1748cefec84d687ad4c49e4437a6969aa74bb7ef2c7e4f7ccfb868df45028f5fc26b07d52eedfed4a1cbe323ed8f845fda55606b46f1be87b3c1d99586c380b713f6107aaa3416de27a990ef82c5794840bf2b8f3c3ac5cefb3c87eb23060cf236515a82c31bf6113d88159da0899bd1e3426b74d155a9cedb04b87f6ca0fd9046dbfd4eaf021088e6a9a990a72d737e859e8e1d8ce3dbbf364acad508ecef1ceba7e7d1c0b613c653e2eef979dbb70ab58fbbc5528fe38a514decece30da8011abab8e40110a0cba9830b20e1077414d380656f47070230ade68366a31de9d1876882c754b91e922d2ab427100ad2e592952c98dfafadf0a420134e4a662dc8d801926830206692de40dc1373413f451a798123efde6d59c4bde132878fbad100afed334ca91f980b903ad43f453a761e925b9994935e83839ad3c6810d830c8b4d6c57888f6f90142f8d69a0cdf2ab2f3d522cd9f4e9df1fc151e44f88e8a265bea912346d67de860f551cfd053acb2935473293a1505552229299ed87b8e7c67dc85e76619340eb9e40042e58da454a15dfc2515a7b8a0738da9ec1e5d2b36eb49935b2d3c02e4dec10a1114bea32c659a12203093ecfc3921cdb06c1456cb2c47f05e24fea73d3e142c4608dc0ec7deeee0021460ffb793e51a4eb320a524cbe5f44edd623c9466e0c31d1f008832c7f02de798e7dc73beec0a43dfe9869a3a71259a0c97c699502fbd24a79a907e59e75cbc5b9db5e09f4474ed140c292a643b909386db2106e59b1aa2edb73db92902298542de61c29496df614620bd054474f990a0e1d72dd6b524b671b1c570a8da1f09b5a85522a0133729aa951fe5869fd9d979a9c422700010126e3c88f854a607bf347a96e4e7d5a56966fec5a191166ad99440a88a118f84f53f71852c9d50a6c54246638e1a02639cbb5a5bffc362c4c18d4dd3a84d5b8254daee319a111363f677fc62aa37f0203434b9c553215711ec2cc79c5b297f9722807586fd759eae5d936bd2070c38e614d589e2b437d826d7a482f117cc13602dce929c5052ef50422f2ebc957662f7faaf396c71223537b190c16410ff3d6b3142041a14c4957b16b1dbec5cf58059161a6171eb844da8c8a876b10769a6a0d0447b2c77301ed53ad990074567958fa819975c1154ffb6f981b42931aa9d8941c581b640ddadc4ea7c84011a6a91387b4b8b64b7e0a9b38c347c4ad4d40424861b650f4d30cc9dd2f7ed315b0fa328ac5f5d9157f11d49992bb58c75febdc8df86c8e6533c10840b6a754c19040806047871cecdf3529cc458bfb3645076662b18d7f58f2bbe9c99a0f31d0ccdec55489805ab8921adc4fb52b2f7c82563b9a28d00a30609bd2fabe2628e6856a0b5f9a4b2d8f58d32949cc561cd721f01422311a337e9a0a952a3b6d0e53e579cbf6364f7a2f0c48debacf09c6e780756575092e69d444ad23fc8cfaea9af3b91f673756c4c5273aa78035f9221974e99e736a8ffa3aa8b5d62265d4162d2ab68c9cd1c0d076c560ff689e602b97643dde0da395daa0db9da120c2c9efa8339481ad33e01ffa71ddeefa779f73b7c0c92289aac7b9d4a9959f2c306a64cd264dbf2ec4d8224903f0abd19db7cfa471d098b45f7cbd51ce78747c9a88135b0524189bbff9fb58eb2057c5a72542138a6173c501a200c610c3a7a92955837e315d2a3b0fe5e4c3d7048052a5aa689ad413f28a7ce158675cc4a5bb1bb2a08c231dda02abb57fd70e112fc8f4da96f5e1d4121a6a1b72d86f879d6271b98079c942afd7d0d535880544b2296731ae3de60140b9af2d7d3a9e13e5798dba1422df10ced1e4a4677eb4bffb75f69b443c98783ec2829b0491f77d173ad209ad361f2453c4211fcd25f83d9441f0c00755f973e05ad1921a6f98d766a65770bbbba2178490370a9b9e20d0d77d79d513e135b640e65ce7c89a19a07d5588719d850671e6f6c428105f86c27da1a9d16aa028818a5814fdc279035462af1c23987df36ab34e6522ca4c8f6465e5b255f5dc382fad5466486c8858b2d206962c40002432bf26a3fb2da92e965e3f39371b4694e2b8d256cf1dc21f1f3e772e5f8af3090e0d838a1d801ce22428e31fb2e9e5be13def32971cf967048660936bd87484470012f10e43637230e783c89c90176d48fc67187958d49fb167d3682d5e3c762384ca14ebd51c2e7d59397c52dfce8743575620058226dcf495be2ef8b5b9f6a635748c7e9535e08ae2a4c195b6f5c962efd3c951b59af2a9e8a2f98cb7e0e06a625341bde4b32aace4bbecfa792da8dad94b87fdd93bbb27d9277a74e5ce82d174ded4a89b62fdb87f3e249e3c8f57babe4f00d8bed1edd615bb0f79e34ce48ac23896d241376b8a4a8e4eafcec664b85ed91ea7acbf56c99981f3248ce0e6817cd4d16e49f4011586cb3b199a471513ee8bc25b07b928094d0a277f8db3ff90f7440cc457bf2348dccdee9624b35400810f446f85c61f1c86fe697cc73152ab8606eafc3b5165c57c2f87f05e995e651006768bb2d65101ea8435bc252d9ef823dc56fe1797b2e859015683fda8d57a2d962e7deac3d29b80e9fa1b8d8d9d0b8cbab6e7691b341a5bb640eb889d8557958ad62ed90dbbdf27f84c0bc5abfe5b013b9d476a488d7f75dcc4dcaa571ed912ee216c08e220196298fac3934712bd772f04851f84322a2c6cbaf90e9b1f1c5262d67e1ab535128acacb94ba48191a449822b0e3102225ef6bc3fd7a75afbb8691c7438e667bbc64450826c3da73f1cfbf8f30894d3b3706bc3cb30d8edfd9f50e4c77afd2ee75cc5fa1089dc1cc7a5bf00b3667f73a4ce8bff7167df3ec52b169ebd7d7ce06128db4fd05e5a731befe9ff61d705a3dbf75080b774535a6f3f91ac385338f10629264a715836b19a37ad1b3ab1388480e51ac04097bacdb8e2ebf0f2e5b185e2aee0f8ccded927b839f1c0a0c8c66a21332bc24865574922353262b2d4a1c0ee5efe2191ddcc05601e8d16f20b31e97e4733dfe96b6a376f5da982fe12b8337856b58a9a849556a937d23c9cf32e85ea4037ae6489ebac14e8c331691d9e71a4d8874f4860c4b5012b12bfe5834d4595dc1b1f486eca7531b9b1b192bb055d6d1946a7ace3f5cdc9e5f6b53843ab7b2257f4f9d85bd277f90c39cd51c8f5e3859a269abb6ed98c961fd1e360766457adbc24aab474b2c92168cf8d5b76fbaeb002cd2ca4fcb8a33cb7822ea424adff05998cae8d61d777737a6cd8136a74e2c27e90a960b644549b0059451f73b31deb29bc94a333a77142b8a78a284027333334a3c105818b6e5ece249172a046fd8dd2fa04be424f891ceb6a6e3600d4e5ac71aa3525d33dfe3bcf24d2f4929d9dd9f52df64557543dba0f5e1998fd7aef746ff77d1236a4a190a10acca48d324c03a962739fcf945ee67d83d664f43dc6b883c9c1628356abe2aee9e7d0b1bd60c7dd89ff05c399031bd7da2f88a655f7a1ff6ca7efd9e9de3846348e7e8e7ec6fce2fe2048fb14f4518c51f431d0b4f83625284eb74d4c02acfacfdfa72115a9427f65f646c664efda634a3cf62d44526f3b530de7ceae053c2d1dc5c6a7b940a3a947d7a56fe0f52361bed3127b11b3d3926e9faa5f4b85030eb811edb39f8ba621369e65fdd20f4e16df1ac58dbb57fb2e843ca1b1984cde1bc6b2cd5800f474f9a4c3a9a8e4e33b5c27e63df023a86342a34d20b18142456f384836d05b622be9f1c78ecd5bcdaf68143fdfdc0bdf25cf9b4dba447d12870e84e15336e89c22b0352292c8c03376380c4d96fba5b0a8f6da23172f600e371d2b7fa2181063763c5dbe57608b15048c6759d637a2fda629e3ba061c054ce8cdd45a81db950f9450f5d2092ce8f509377ed6e9b321623a061ff20db5e6d1385d1ca2bda0b6d1e56d75495ce7dfbfad787a1cea2ce1887fec596a844961bd165c9c544f88c7910a602f95830c501df272641372a0e0d818124619aa2a532b1176b097d479f1878bfb5ba0d400647570308642e9bc8f5b868ef9a361fa76a659f05d459b96f12e84b9c7a0c15edebd83606f4cbfc275badf5ed81c819fd51444a01a47e1e946af7735be18d685392e44792ede4b6eb7ce389c70c463768f8c367d366d459c648a7db715c23ac706eeabf46ec51bc0dac6527be19ce7b9ea0b584b3b212c3d45b5edaec264efa9c57171cbc19882f3d0e258208faa18cad24893f2cb6b3526c56969bfa976eae263cbf542c6e84467783acef2a4966a56e7925827be998425c8c9d582a0f4d19c8041f895991109da4bf35e10276a9947bd381f13b5cdda24f56295f3426825b24edd6498f9779010cd614592f75c372c695d1a63552e1ee44c82b1798fdfe315c87b52e5b90fced803ec490322c6c0a099c537a8ee4c289c8ec233ace9c406b7beae555fea5ef8da30897ba67d68683678afec86fd36e694e76a9d2472f9c6f10d57193f3fd8c5dd25c4c4655822c8e63c499894ab98b87d3db7d059b19ec7434952c4aeef3772d6b5765b02b633c6b78d9fa34683272db1c0ddef980d535409a6b05441a739cf5b27b0f55cf3aa34aac76790cdbcf90646815bd084f05c616ec3321afc78f64703db9bcd8f500f00e756bbf3cd2445098b411f36068918c5b0884bc742b5860b4a098549e710ad110f4fff9ab4a286a7c0cc41c4565452eb5bdb14685ad42ac3c9e5b7cbd6e1c32d5b4709eec40559bbd47eb97582ac5551c63f1da4a044889b4fe44c90175d11a43db7832c7dc3e72d40c0e83f67b2e09d2d79d8e83920424aec57549a945dcd64c9ae7ff1a38ffec0d502fc0e7fab54aaaeff61c3d095a788656afc75b67e4d825a6aeadb3b3af15dfeed61ce51ff2abd9c7a59cf99c1dca8925e8e8d099c43f6199756a3358cc15f4323b0998dd34d713c8d9072f33e8f47bf26d860d3808b329e41ead51cb7b2a544c30a7153dbaf7a30df2bcaced92bb1594f4188776113f4b5f1deff4fee00d630b5f8336b517b618b143951b397c8ef05338efae75a898ca7a517b7c77943ed2954d92261b0bd757a97993c298901888d9d0a6356a942106d486d2b0639443a28bb552f4e0b0188a2a5c5165ba1dda352e7111af734e085ac90e403a335dfa7510eee2ac3528375485198753d4b50e4f9edd6125756237f9609bb7bc7af8f46f305aaf3274759ff7647c7001c760d363","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
