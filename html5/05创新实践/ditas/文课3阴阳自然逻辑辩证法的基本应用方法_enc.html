<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c3920ec592b244629fd73ff1057d11edf7fcca472ef6758b9f3f06dd8b3b90e0e0ab8e573409ec2a29f6aff9f24ededae78aeb8fef1827d8c099120dd008d1296a272d9903c13b0812e19e82b2069cb7e6657fa23ed7d66f0058cc259cd789249f41fda410839990e341562e08f772b484f392e40466185a2e9b0632c999a60fed33d955addef8581b87ab147da932437153e4c7a48c383d2b426108f4833d452f0f4dbd14e7e667fb20b9e9cd57893c9e4390566c8691583784ba8cdf2cf69ab1b42041081ea9beb7d9259ff2c2c739820475dd957e7ef52e5489fff9aab6114672f453a3a0bba2dbc599b721c9fb2e49a74876969fc9dc0c615b4079e1ad38ca5dfae77e2aae644f83e987c49b513f4c9f247e8baeb6638519a5842f2887020d21d58f7a19a51c3279c13f0a3ed2f4732fc2f9c5464ee54ce4a58d0f146a3e69c2cd4d2973bb96b71f2341a4f6cdbda2498b62b2f3995f150b3a204df3249991d0838c725226f67a6ce1556fad63a33d614a7f89d6f857c593a0cdb4d6a61b68539fc1e62b6b848b9980092867ae03c422d2808c9b86d47177f99d9239d45ad18f166dd8b7fe51234cb122eaaf84c6a00c0c779070719dd38d3b6cd256ba42853df439420f57567171758542cfd2156e4d91a5e52e316af626bbb8e798b63c14ef783edd7d871f1fc43d9e92fa9bdf99fc5d7e3c3c10cd388082bc8dd128ea60ce559c48e2ab0dab7cd3bcf74c5434f56fa307fe703a0a37cb2f155089bf256eb7c4b614299c7460fe4d42355e0676462c3a62b8eae52d5132eed5de4fc10c191230e70ad0fc6a8a7b3a166ca9312384d88eac596b14148de69182f00efe88c082c5e7fa81f8f547910846f9993af6eaeebdc99f638ae7fdc776c7e9dfa54a18a0d5e830d0cb440d1f3994b301b64c50fb05899fcfc8b76e45d042cccce99474bb820953c0436e99ed780d601857fb63e46f8a5504c76bfc8616dc72b30d09d2a44fa4cb1804d0911d3ca5b1ee331a49ae855e84e0cd698be40a37cb7860ba5092ec133d2578084b801c011edce7b91d3ac55c9fd71020c0c0fa4bbaddb14f5fd50f3c4144464739b14942e876ef817911a47e86605e8e4ad9c7276436be4f6d02548787c8bb92212604aa4b02c5935ea080cc0cb3eb09d7f9a396c7c940d517cdea5924b693fe5edd94a6899b8f678624dce0e985610d3f49c6075ee9449bba56d19a2bc7680feb3b607f151e8af6a1215af7e5373207ffdbacc2ae77020d0bd60f71450d0c827f086d83eff3d37eead430bc9f66234910a5b14d61e332703513a98f9c250dc39cf8a8e668d7ad1ee64f0dd560633706be37c720e1aabb10ac3a81963b49a7a7b0bb79dd06531a714f715b00995d6405b63c76ee76158c8c00a2c157eb661ba8d0d7e146773d1c3455920c79d015a408baa62c23a5f09790102c6031a3180d3e97a2ccb9eefcd2dc415952f8ed80d4b778fab1756543f75dbd24bbf39dd067e5dc048a283e38296e983f92d4ef690b4ee257d0513136e20058e49bd9349b37c89ddabbf27d92e4bdb740aadb99a3e4c58fd94a0caa3e18d582c2cdc10542eaf821f5b9d09abd14fb5800669a633c43725ec677fca75aeb3f50fafacebf62652512e840f0c6fb8635b96aa73af0fe597be643bf09e2e2fa739be534cbbf1c7c6baf5211e10816e1018ac0caedcec945572196fb8e98b3886e06fde3f9078af68721e314e3b21d97d36120e82c0213725942d9cac8d012d25535d26178a062bd80a3d8b3774f8462d6f550f9da436c1d31d0f1e2f02df93828bb6617148dca85c49a4a89778d3556cf6d6845fac6614f2a2ec13a4a630f766c74f8bcf908cb8f149a00db5b9f2fca17800fb059a8be0c8e29fdb0a1e2e7d5dc1df39fc6526a76d5c1e6300bb8a567116de517b48b1d6a7d05d7e5b72e05ef90396825798abd4eaa7919e05aef7a1e46ee3475bdaf498162ffb533116ee19ca75fe2334c7f7b6426d1252b7b2bd9a4d00bbf811101f071cd49262e1d638346d07385e3cc60bc2e493c57a66540fd3026adcf007753c7bf4f4ee44a6f4780c58500d27fa772068670cb425e87d3f87775468a1b892acd18f060550b944f8701ed88608d1ccd2307bf7550cfadc7b6cc42c8dd315a99188333e0e0f0e21fac19f3d849d8fc62db5eadf2e8a0c5173d89f4d54c11678fce0987ef680026723e0670da369897f9f6322f035a7255250f72235e6b1086c3db33c9c40cfed5df3c52fc750bcf72c4de68d16115be762563d613aa7aadce594705a38d4dcb813a8cc75356abec2d4d5dc642ce7634f6bcfa24d6ecfedb10551334b368525bf43a150415ac93fae0ebcfd41baccd5b0b69873050f60cc4ea74ef63e7441ed0fbc00f2f5fcf875e950128fab704cd9af82e1504df06b0abe582452d6f36f9521ef0246589734511af1a17106c56d042012f7689e6c290809db613aaa54a174cc41cc6b920e1f84b9b515113598d297dedbf4eeecb63ae070892290406ede14b9bec809708096767bd4cfef8deb10516d13ec77c58780d6c8ff888e0de974a2081d0f9a5425d219ff200a4db4d692c6882dd4a1603842e842c756c3b5c8e62b4b7e640cb273c7d8b3bac949ee965670701c3435b7e7e5f76341294f3a848081ef7fb975c9b7da6c147cbe45b4c9b4d42c5ece7ad561981d3df8c52b5f3ce33799c541ad3e2641062c19e565fbb74c4b6a00674c116e6797f90f0e1fa223f857d3844bc5a7afd467cdac162e0857dbce3d42913f8d74b357b7520642f91d2a2a3b72bcdb1765a59fdb8ef39d65b3852ced636960025b40636cd7c4940280579cd40c6743273babd9b97d6b1f124c3f4a69c58d0d9e0a15dc5368539748331c112d7d719966ca5955e4fa05dc9da9c8becc03a85af8be62cf9e68ff22e5a834dd34c802205786eebb77a5a694ace8f7fa1b8fb72444ec4c9e7837fdf217f909fe3c827e7355e392a72377ca1f242f111e70ed0aa3a09e7b338b38005db908a6b4fc6b2464f40a7c436b143a5a4b30313bfaff0f8771da4314dcfd5e2e2ed7c138ef18fa7c7891922968ec862c3516b78dc4ef1c04465fc7fcfcaeb9c18745397d7b6926caf6f0f56e4d21479339213816c0608cec8e9e23ee81a081868153e35a3ec9819f67b80a99fc9c01b6d1668140246cb114147570c6d13a8e2d9c9394c5cd805708b08ce76c09cd4823e99e5cecce7bb38401c4291a5f03bedea6dbbb6ee453ee14d1a333b101111991a545643b8ca9f863c5c0819d5f6043c50df1bdca7451379d3d38930d070b80f987ef33fb0b2696013b821ca432f5afdf1efc82d57e4bc15bbdb12db550d8a262c164e9d90c4e6403cbbdbc0c3acfe88c1b9bccad9e6d9137af715f75f27c3d726c09ab06f533520bb23898f535c133a18df6bdebac24be37f87ef77258d3a99fe376a88bb4ce61146ff86704cb197d2f4e81e50ad4258b7531109b4e9c727c996127fa729a39e2cf945a132d917a65cc2a9de48136294e5b2e5f4d56533795e117c29a9d124a6c90633de23b2cbb636eee055ff42e24ed49a9f7cd96e7e85009bac660e77fe6d7c051dfd5d7622f567c35ffdb47b2dd1b6592d8d8566bef92ae28882019d2caeadad2cdd9028edd3f59539c10390dc5b189fa6f46aa96b41aadd443cdfa1295965c19cb8c66c6558a5c38d07e6286fa9660c4d09afb75acb4647b524a0fcb99985dd683dd5fdb70038c24e72a755bb2123115da508039220c2ee154f79200481e2f950a391c6c35e63c4d49540afb8331489ddc9d715cb765cd5d09db32ff2e782fe16569eec93eb267c5042795969bf39d062b43e4448c344c14b95cb0689568e2abe21e6cfd35043f873f8977e20796d0adcc3739fa0c3dacbe3b2071d5c8e797e53afad9d43d6199f4f23dff05dc4aec98e3a70f99b276e848716f58b30cfe20a213547f3fcb6241db0d280c6e41e56f86b40a7a28109ba3c1381b980b7e5dbc2a01ab3dbf5212ae12e3ad2d5cf7ec5dde0872640ee7b478ba4ceb819bb4a31b90673ba011c65933df47c519774407ff978ecc33870d08852252c274b2baede0b508e836e404b7722bc05330b6bd01a5c11394e2d71469ec1a7291f220ccde6e19d10a0d0fde344ba97db5e1f3fee3caa73962e87a7cf68b64632f9a1d70529505af4f7a03792a86aade39846e6b26d877345d4a17690023fc7f620110d6e9cbc1b0052dececc19c5165fb443018b2b02933cb445e702c500d6495084695ed3298c63091c6f4b08f93839a165da85350e74efd33732a75bd96842eabdd98f8aa73253aacc4df2338085392303b94cf1ae24d923f643383058ef1429d3038d1ad62c21ebe1ae753e29cf07601fe44cccf368da591c1768ab3fabcaad0caac1f56d68b8070f57ef018bb3b602b4996f1f63182cd01019cd08b6dbdf3ad9afdd7ff2f0a34cb3b472fcffe7ead5b863043f20cb448301e951fda26b78f0787a1aa5af61b85ea7687bf6488c2c4299364d26ffae5c4489c60aa1dd241dc0bca76053e20f05c2314b36a8ca944b5e43353dbf29353ae99029faf5a0fea270a8124d8c424f1383127c6deec1c93e973119a50ba4ed1fcae9352a3627c6af7d451503e6157d89c94f6a248d3fc804deb97434cd38c552394d8dbecb027ddb3377ec0f30968fdc8eee7bbab8526156671000b356ce3ef0fdc5cc81aa0db6a1c1c4b1c913ba09332e1853ebc54887eba73170e9931a47e983dd8960252a01c7365cd2df8043b8cbbf652e3ba83b8cf4eb9e79f00888b6f768609efa53e128c189f670732da42c831b4ca6101ee5e58e34ebfc286dd6ecfa952ba5e6a46046b3642818d4c3e9abf447dc53a876d92baa1c9b706fe3d06376f2f225ef89867c986e2abbdce318cad553d13d5924e0ab0983be7afbeb1423cbbdbae3f9791820be7066a4a3b6ad66aec96679f48565f2a24bc4d9f825d99b79b7e83b76ad3ca351747b772e1a30c1566f68da8934802bc73277eb5b9bfb6f508dc079462e71ccbc48ccf48920822cbbac33ba190df78d4a5d7a0df0d25952f8c8484125ca790b6b2f69aadf8af699101eca7edb5f2af9354ad2aedf087dae459d43448e52c9237de9a2e9828f7cb71520a24659dd7d3662cc393d3fbfb0a6a42aa529314a691a263414e97a7cc52106caf974f9a228c7619bf30539138011f9becb83ab82e99cfdcbba3e838eb117ea66b08f6d098f64779e23c4d98d12f7171f224cb4b23ec4e0d61ee07dcd2fbe590041f9edbbb5fb751fcee8c928ee9b7ca5e937b456275992c40341128562a641d83a0278e6712bc3098a280e17ebf75b7a3926c18acb639b0111363bfb8ca4563ea40dc5ac6970d3af112257339a9f3da68dfceb7811c549ab12dd4fbb68f2f194d80d2cc1504ad4d7e2e31e0dc6852ce8b81edd28f8e6253a41516f198300bf645216e8909239793464948cfc790a5f43e20865771100360154f269892c6b64f468c3947aa30de5922fe2277fc85a8ed0685ebd11a80c3256a42dbc57f080de8c12541ca58729a90f08a2598557632c45082cf28f4f1988d697fed9268416a0f35dc1393303a61e1c36deefd1d7f34a2218220dc1334f4c214dc877fd7c432fe8a23710b0e9ad022453b2d277a25641fe47785dbe887787082b6e85b3525c7f64945fe2b92759da00c33d1acedac1c76453504d4e8d857d8da17bb7c760e1d7ddc608a6a6bd3474b45cd31a66091cb044ddfbea48a2613fda518e904d627e5ec9011e83b20b5bb65fa773ded3c2e03355d2bf7ecf9ab8807cf1242f93296f95c3337fc77dbba2713185ba09f8ea09355a5e4ba1f729ac6bbdbab7733fc1ee1b65e63151ffd88c000f6b2e25be01e59d5770bf35b8b1e2b21860cc3e7ea957b8fb682634e9d50e21836806cc7255e8066dfd9da0da6bcc992907d708b043e4462e0d48fef5e326a2fd222058cf65d11d70d36d4cc8d8f2721c48320bfb43710c2079787f4614cb9a57e2cd4c710d29c38df18ed181e7ef69e6f07fdcdd6910ac7960860348f1b2bf13fad74a9c1f7f6a9b37147a9e7b82484fb5e31a520c771323985e3817522a080055ed7587db4bc55949e850ae1266d91624a6798e5ebfb09c511b12f7abd9edc714486e7877c7882b26e97ceec2749be4c455c6593a454c1525b7ab059743028ed8c13aa8bd038f212886539b4170af4abc1a5564a6992f3390c35972b32c7b30b0badebcdebedb170397878e38bd6efb9d226673dd9433a3eaf72dd06ea2afa454e1a5633b8bd0bf7c21029973090da1404060a61ce3eaf53d474bec4b3796119806f48433e7f54e6c44107ed0cad63f86eb06d20d3165297f6e57b1eada6588e1b76e9a426f971cea86e05ae471d095167107f1ccd0559a00c988b33a0298a5010c8c365cb13ab92fa6770dcc34572dc3255fc9a2be7c139a003aca6d5f16dce8bcfa8a90a7964d1fd647fc4a41a0ab909488dd9bb4cc60510f4e4c4826a29d8be94085517e81e6f2935a0b40a722ee6f7a3ca242f45a1be18f2683d1dfa713d507732ac324cefe799bcd0a74bead1ae624ab52efc074296ef6035fda308f35774dc58840fde434ca373a65c0a9913664d3203ad23322020e30baf5cc3fc3c681c2a92cb754c7594db6700e44c6f02abc7d811eb0170248545a234e4b42f3461b55857956732c6efaf86f6ae6ad128a099eb24247099c18789804ce83914bf4c9af26cfbdeaaf417ce4696d99f906d104aea2cfc88900fd4aa297b5d452efa550cea5534efcd5d96c88f660a60a44d9b97e7ad9c1a833dce626d5ada253684ace805f82226cbf5119cf5ffff7d507cb4400196c4acd62ed9021c148b70c6e675c92a5a50005c5d7a78d7b997fbd99c9dff93167756c9fe38f0a74f7c67ca0ffd858c0f45c75056e56acb752ffcf8d0f1d418a1bf2049da5d1bb05e78d2797cb03abe2e40a0060eb2b3d0cc7eb2bd2073ef24a07db4e6bdffdad98b1d97a96e83145087f084547f750f81e71f10149fd02ca09961e5874aeb39a4b94c7f5d8aa69fd0cfa1645b3d35c7215e8b9291b6e57a4030edb8c96fe9f46b7a05d33c1859c0fd8a8a1f0034df9b5b85fb0f3bd02f6535344980b9f54446765bfe90dc230b4eef72a64c151b68f3732d773090b87b25787874d0502eac1669923f529570f20548738bf0419b5b711d39b61b5c66e28080e5f9becf9590ea70ae1b3637ad18022f743f6d6ae3259bff3f71e61dcf4453ac61061b5fe5ccc0bfc0ff0ab45754837196d3526c0899a2cd912ecd038ec57a151b18b1b2ab583bd6e73ff76ff4d7f8512bbcc007c1beba27759db778c8f9f13bdad6ada2afd12492b06bdb536f66eb21bf2a29c9be4beb99539d0e4299d40edd88c09f13777c59704b7474908bcd942198eada45f44ea2e42d8438eb6abc8fe5cc76f743a483f951099b168310a9b9532235be4ceaa2df0aa03cbf1f100afe989c7fba3d472e33160b2ad718e3f1b0b5c77aa794b46794236f0708b474b26d6f4b7f4ab4d3a91172a19dea30c2ae53bca76a8155009cab5559c23c31e174344cadd96722613800131259454d389ab1ad598397e84c563dff3ae81015a381016eb8013ba33cb4259a2a48145f9d286b1f9e83865f7735516986b268c113112e3dd0d9a6cc4f86c8db71c77f016a8d1dc159854208566dfeb95d38dff7da9143ab8f2a0edab5414d6447c75a6a7c42e66fa8ae416a39fd2e31b5a3e435dfcde3a8e0527663e3a8e6edae0a213e441cc2331b18678639f86b7c19452224360afa716b7a05e37293ec8de00827847f98a969ef95a1a1ca2a22810852b861b667a0576daedcb07c4c0d8e5b1a960d9d5efba2c879449b33f840e36e7cc8420e582e8e6424c7c127379de00206f671e05a4a032248d186dcfff619b08bf70313bee65ce0abfc7643f48b0e0a9f267f2d3f3959d0fd8c7392b586e4ef3e23887a7b7c25f751c4d249d8a919c3fc8e79993d2396e389b16a67bcccd377bc87fce5fb5de3386f45c9c0d7c5b5e3fed7c32f86aebc55976f1c40b10fbf6c67e5919a27caacb405c742947425aae51e2fb0ef9cb96e3b8a6a6b49057f0f366a79e75da32da5e543eec404202cfe888ce36a8d1f00eda4b5c107d4714fc9a0158e74cea6507d1f522a70d0dd58349f90217d676bbda7eb2181084b4197b99c4751c993be05be6247fcc437c4985f8e30673653d9b50be0d00b863c2d89a520e22484062d1e48dbb8216e0a1d09d41ef10175a086ee7a1f360d27480ebb22ff1ae3a9c9618d302b583993d4f6eca77921301f2fec1cb13d593027789d0acf59bd5a462578a9a1ea0c8f4818199df6eb2ce3b2f60a4036f4ad9ec60b2027f056d01a5651ab6217d28c1238bd39988c514fc8ea1639b151bdacedc020e80e0d1466588cd32a0c3a9ac91b791fffc3049ed5e0c4b0b9c7534be256fdb5684fcd83e39f8247f36101938cb8130e8d00556f8ad2045f7d3f113f2264364574aa13238ffcc23172e06540dd0992393961324d957a7dd74459b6911287743c544a3782fed7674dc4e6d8cb3cf6e85f5fb10b287fbae5b415eaef57c8efd8a8d37a748c0c2497c7e284ad6fa55c0664d17e5b7beb9c3c05e030dede6b577bb7fe1ba1a4131a1b810e33c055057fea3d82642566d802b40ad4f83805ab03e3e2613342b8841544fb776c12ddaa86b7797649ae96fcdcad18bfb1214a9450409237c4da1ecaa23cfbd5eadbd59f00b24d5ea59b6c3c1b3f745bccf8626030db07a345dee38dcd63fc3bca313d7a3991d4ae4e3d983584034591756b2b90c4fedc5ab3fbe448ee63f2ead269419ed586ca5b8ba95108753e5dbc09d483e2550f2ae54ac2a16f34e6777a226e36ec5e48f82129e1a458ba497283ecebc9b83238f8eaed10d89fe98dc4c0aad4a5b49fab5b97a6d7e479ef8acf65fe77992ef6eac21c752ca9e4e330677fff7264fe77b351c74a2e4916b26331bad19d5396e9d4f7ec73ab8e0c0d46177917710ab2209589c7bb3a3e9f95d5495d36c2ef363d6b94a8306197c76cc0e5d68f0ace483cd059e74130e0e8120323a6713e77ed68c6bd269d1b0c2574e036aca972e998701b66163eb1c58a2fe83778460991dcad0eaab357f02a857876019256db1487d5c300552044b56fdb454674ee2e17d221444cce7ef1b646e29107f0bdfd8560428cf13945224d1d52a5c1bf9564914e3cfa64a3a488eadab3863ba4ce8b87a5a35c2e40a17027159be1ac8b7543c9af6c94ce1845b1167b72783d77df2bdbd64c9a4ae9236303bedc62ea1c8fa74d1ff1778c132d7e33c73ea0529b17205f206b978712cb73962c7b2e763af59e933872dee5d491db117416501d1f7bc597e9ddb4a3279bcd3feda307279f175d92c133aefb32d1664d46e95b37a95e07cc4c174039d63ddf3171e01c7f62f7f84b7109560ccdc88aefb59877c4ef3e7a1ef65afc72d1e785e12ec48128201dc0ff9b64555cbd5897a170cd60d1be1f73175213b7b332155850cc4af759964e88274eac0335cc841709c0af650b959e7cb3e19d78754e893a373ae3013a2848f5c4816eb8f60839e541f0f29c4996a58463b71c31b9652f4f256a301032b7b08c2592b2be0f6479fb12595afc0fc67f500d7434534bb263744ba1e06532069ef25d68cb87c4ab6b6e9560a8b65470eaef27b9eea81bfec3eb25816b22e1b806447dc45ca352477f729bb0569d969b31bd2ff94ceb2600f27fdeae69342ddfcf203978ed3a6e9f1e6fb5a58c5c62f3e568a3720787ba612d65c38348b7b972f6ecd216caf95d8b3f32c23308d2159a47e449ae991a72dd777149d3c90d23e1d6fcbe48636ff7aa6444dc097f16d4c496e28bbc088a004c81c04b6ba42a5d560b17a1b0a69a8eb9befdcee9811c3514ccc2e6f098373e9a816e6c962d360b765eff554a51af1f7e9a6a07b34f9dff7054880052a2c4d96568b789eb76529ef2a5f578776e4a3ecffe96b277b4548a3edb12e0895cfb2816269a2c532c48542a6634566efee9bf4a558fea9b0a395a111385bfafd560b4aff316dd501ae40e87c037d55b9d7b6cb0fa1e2ab8f69194b7009427d7e35c46d8dd3be6dd1b42556e6764e441841a416efa13c29447d8b1774ee471c6713ce4b659aa8bb00009f8177bb36e88a7515cd495e7f06910a8fe4bd10a18b1fba2c4646bbdecb5376d9f14233c983f6386f20c531c477b1930167806325be268028560b3c7aefc1b13673297dd118065af0e1bf4171594b94bda07e43faf3cab59e17e0ac8ce2397390bd5a9633f8be44f368305e9e357f8184a3f561de19ec71e8cc30f8f78daa340f9cf0ad1f49174bb8de4db17c916fe0e8b415ad9008cf82aa36b64a90470ead5c7543e10e47c2b16a2d5f0b9805fa6344483ac83ed9df6963e3d9d895d9073f841104b6958fba51e4f5a4f13e2c66afd64e230d34f3d5ef6f6a2f50ae5d1b698082ec78537aff627e4d89fe17cdb1407f5a9a53701f0096d2912303e51408af920e89f375c72b278719dbd98cc52dac3b98e718f477557d9da6ed98b74726d92c823e1a9eb851ff1d8ac152988bd5d68dbe4536c616445821fc0f4f99d0bf38bbc045edf7d18169abded5214ec96f53a1f0fe8fb986a99c4b12bd7991ecb1c8657e4a1d3155862af627bd79b1d6ee6fafbf8fd48cae12cf7b35a80fb321f3f1b71927833d2eaaee231aedfe147c3f3b934e9a4578452d1cd9dfb2c8bd75e492adf3ce69bd98baaf663641db3efe53615e1fa46adf4212bda4a1794313fd46fd203d0a9a441d251b91587b36a07fbea0a49b7707bf95f700ed8013a28b8bca36aa8f170af471422c1f6b0ef644bd93f666f24e30875feb182dc222be7701182e11350b60dcc3b8ee84b671874be78a147b7e6047e2b0e03b45db6e413489ecfe6a372c2139d46c4ee09a7690d0b9db04259317248c69298162a462a5662d1b4207341621675250008357dbb76ed60a31a766fb18db5684d2820027fd50908e350cd219c05943246c0972b601fe5eb0859b0f48cb47b3ac602f1f43daa0b67118c6d75879ecd4b9fcde4b79261accdab24703bb46845153c70f027c995f7d91728c4d269d222371ba110473311b469780866404f71cede56f70be2f791e7a66d895b3a500f2ddea67398005d1ae5069ba866bbc59328aaa66b1a4e230a7d5d01154957e9fcfbe19f32d7cd4ec34209dd279387fde587c6cab4cb506c7cee4c423461ca7e12db453e9dd490896ce0167d1f0cf8365998616440beed1c4c467df9f0ee58f92207965c0dc0e3858e1550a1ed01ab160bb5d9af9c06b55e1561e8ff26f43f7030672586fd1f4e36b1153b7ebde37d2b792693707010709b8495ab570f28231561dc3987b3b4a9e60876bd913612e448891b1664293377309917477c69d8cc3f065bd01ee33aeb51287c4e48cdb3a9d9d93acbab27227ead79851b2a280253c85ae503d9107824ce5ef4edcde6caf43f19e39d667ff55dd72c885b70a37a53126a328065c9031f6a83820701480207cd848e42924e7b340b4a62559f0fc687c67b4bce5192c7131d540b88ec31a0df60ecad812d4d4819410832495bd7d4b53baee52698c258ecf01c6f86c79249bbe3fd18c23630ed0dafaf529884702f670b2eeb67c844158205092e1f823634d84e6fb033f1e24e41d0adffb04be60fc10b051b29f8fdc0ed95cd975b4b4c7d9a8ed79acc1527e5fe490f711fb888d273d07d31854dd486082af69f54d69df56c8bd9376fcfb3b19eb63dc51ae933d91ee13f115f4086fcd3117947ef78fff9d707ca76574569bbfc557a1a1526c0ac1ff1287baab509219a26aaaaddea21b993f7b9f39ad987bcfb808bb7fbafa5100aa1b000646e2715cd9f478daa4ea9825329599b3a10ea57df785a12a2283f1b4ccc23a5d9b0875d41a6253a4be0dcd306adb8b32241fe5e5b57193ab24b1b24d401fa4af77b206fcf0940d78ea2d67e71afca82aac62ade6049ef952e855675893a333632e8b1a1fc9d4fd669903cd871cce102ca191075d359a282eace9c6f72f05df5ee09851bfb737167f5d31e613bfb2e1ba08d64cb9672a7c2f703f02c2a9f999d605e3a64c2c3b25d310fc2579bd07b17e5bac60ebb52e6e6b6717da504bca2d09aa4aee54e05bd9ca58b34c1e7d81c67b2b6d2aa0265b547bfd04f34cad776ac23036800dd20aaa74655c4c84085d64bb41d521e7c281f4cb952fcaafa7ee484171c6b7a3110d2f2e50836d4761d00f05711f326cb046655c23e7cf5ee4815b1d1337ed8bae9aca34868fb2b2d2ad7a24b09c7aa37d8b53a15360189f5483daec20873b27e481e0cf91f613cb0e235f58f894866d92559e05912de7212f4223b4d1c177e315964ee12f5ea6c93de1a51704bdc4c27e2dcb6cc7f0ee87bb22062b174d6fa61ec89d8691110e3874fd2afb5f7b584b21563f571f994bad06c4360a710f58ab77c5beaa7a6deb70b952ee7b144be3eab268bc7266442697f70a9f4c32efbdcaa3bde9b0cec21dc0f93bbc049098dcbbf23e14f7a355fb7636be32cbb3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
