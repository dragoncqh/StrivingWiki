<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3cf7a9bc1dc991aafa0fcc75f5f9411e1e239eb643201d5914001be41b8d646e2a66ed762757056abd3c7a1e1d0b6cd0cebea16217e0fd7977286e9b5443a9d62bb6fb18cc58d5c07fbc009749a17cd3a99e3d085c7127aea2e82634a307d7599e50e115978ecff7d2103e60c96d23113d81d6b5dc98f8d282663108b350e6585afe4870836bd5e21747b29da5878724307802b159b6a1355a9c21733f5f2ae1b9494a9f69b8a57584991dc7c2d5a06a4744361dd551488b44799efc088ed850f9367558cd1a4b756ed34f612d666eff4a003ce0456397e2960ccfb7b78e72d6d6d1159ac71befa5a2cfafac9078ca2c1b1c2e0f6d05670803dbbe7cdb796f927c89f849fee8d98c3a599289008b22600b238059bc19b0ad42f4f15c630f2fc57a312ab66198f8d98063f746ef0e4ae18f51eb6ffb130614df466d7a665b9b85c4f28d924f5633ba18d36c27cfffe2f6a09be6b007046a8d96e3293b1e548e884883809220f484d6f7b5cf9661bbb81426e55aa10f65a5c67fde2005d551b7d4e9c2dd34a14e0bc53b0cb462b5be4e25ecc64f1fbde0c7e6dfc7bdcd6c2305b65958ae41189fb196ba692d43e053f8776ccec29ef42728ddc3e21f1a16d0a925c62ba7cf170e3250b32bdf447fb030f516104d9f510825fd6e15d94d8f3d77d3f67d5b8e63aae8710a87e69743db168a68a011c63092ecbc0ac76eb5147530e355ab70d4e507d756405ff484997ba4416be548d7d06b3f7d08009b91392b946fe5f2356db9e5047f10629fc617e35342f1ad682473bfbfd27f111b53c09627ae7a9c349efb573e74fbf8c5f49b6c4043eaea6b12ce3578dad427684861e8c9df841d87e3e1890a7c6aaee6d60da9ea2271bdae46473b65db90ceea9c6b751eb9621e0f99584d2c596e54d94862bf0086d12d3b60349b6d62bc3fed68b67e1ce3676f063e23603ac80d5870f890d18da800708974c442dd916db034e7cbc10bf8fb60c5360a97c32fb86fdf83eb85e2c7e6930c99a20e4f3b5698bafa1078fca56d83b630fa1c4b000847deed9876c7202e9ed20eb0479bf8767e859995fdcd6ec97d99edeea2ffc07a85a6b6eb0f547831ca09fd4807a4a5ee4c79d9dd368b706e1d2aedb0d84bbbac59a3d2eec3eefe1da64bad0ac2f51bfdb3a914500043c75978313471752692f1f2eb21eb37cc83ca661c8bdc06ac3942655b786c65af73944dd1b060f3be6621531f647a040872bb69ee14ed3ea2f25769e91a40d514656bebaab03b2fe9a4af3842d10b5a4c20fded42307300ef638763a4f10fdcd4a90f36fdfa6f7dbeaa7282963981cb97312c608d3c606289a3fa8f37b0f00684825386560cfbbe1d8783cbff9c07604573e344db6f15dea11cea17e79444a019d93cebc8c4b3d5b2a1cdbe3107d712cb45d28d40cab39fb75a0474f52b1e3626cc8d194b428b092b28b921d69dfc3e7e5954fd663c1db2172e3d92d771f410f5869aa703ccd622a8869960386071c31ec9388a1b55926cd4f95ac25523ecb33c6adeb21aa444bb2e28ebd60578064abc9465e61cf10f6457abfd43ccf3271ebf5d8cfa3adff949e72805daa1fcd4e0d0bc5c133d624e3fe052a013ea1a122d9b47974dcd6231737af57c5dc00fe3261d828badfe2470e3a2345aec9aa77ba9f6d9a7481ecc901dd1d793ad4f08cf8648f93f71c8e58afbcdad44fb4cdbd12fe89cc8b41e123e238f19e9ed11ccc10eb6433832b095ea807d5af1ac0e6f3b785d9f6ecbc3d1089370b0a43608d672fab504241ccf50ee32bf632cacdd31ef421fd981f897b25f816d0c8c34cf754aeb3de2ce5001e342208f73035927f9a284fb8f34fc037bf1c0ff25424c51e6e8f2ad5faa44df793e083523d4af5cf57519952d5c34e994c2df4db7ce6f0fc120d65b1c43835cf987075e9e19fecc354383012ba2610dd5c6d2041b7fac753f3d9e3a7c6be4f9c82259296441c2f9187e7a29d709547f9613b94fbd0d48ef0043d10b55269d81fc1f5e1a3b64826899ecbe08cab44e29e93cf24b0f66e466a22fd10c476f03d12177c5ac26cd241fb6169b3875098bccefaa1c6d3eb6f5045946ffff2f218268f06d1e1f019a47991bf998841605a19389fb20d47a9750c3c429433e5b446bb9323cd7987d1fbb1e88e618eac39b89a840e0348c4f69a2ddeac0c8310ba95374361294bc6e9bc8f9ed9bc63dc4c9f5edfdb3947bafca20454a98c0091a937375e33ad8bab2f4acbf65f45448b3a63fcd2a293fa192022aea211063b31fe7be5a412d7fa6a52e0cffc5a4cd15d3f130ebd39a9009fc129ac98126bf2254eb8095533b2a245fe7b017b6ffc3b4efdd97e949114bc697c6afd549e644b4b4aaf3b1ba3f6683a210d794e35782de7c186df1f78aa56ec05b1abc2e5bb82ed60eda6e33e203f98a8895b298b0d7e978444d08df9da862f7aeedeaa77c6429119b1efa721f2403eb677f144b846a18ff1a7b6f0703b2c5d77ee4c90cbdf86d1955d36de1c7e02d0fe66d44f366796c32cfb1fd8363550db3f60992694652f7bfbca8b45139183314b56ccdc90b4b7426f5a598ce6d5d09feccc8e436b7a4fe257ddd392bf73bee2078deccdea49893041131dcffec0aeadf48d700e8208e51e56001e9637c056acd68068c327346c8b4d829df498109f1fbe0ef4ccf1a045b405890ff1a98f0e4ec9760252adf27abecea7b59219a08d4d8b8133284e63cee1c9e27c0a8a0d9fa50e4ab3c693b5cdc355072ec55a003100d077bd941d6aa5d3e713f27e31a8af164528eb357bb4cbb770ef50ca5928d00d7f3452c845f980c367206bcfed38d629258146e0417113a91e4dc11c5b2234379eb53001127753042818a7c1842021079e765dda772e1c91ce076513c33c135cd774e1e96355d992094e770fba7a882930dffcbf8bd66b8becd8301fc886fbd5e8b48b3afbe3c0f40b2e27bf81a810a1f86d451f9140ba47d63c64fedd373b147f56d3f42da2c45dc2f5acf0077e0c521be48bea6ddbd10859b3326a969e2a12031ff808267a201724a2d398d5506bbd733008a14538f0099d389b3f5b2f6f2df0e8f46ad1f0a6e3ac9178292a5fce8a1edc344e8e026ff641f30734ba87593deca888a0d631b055a7e6c16fe7ef944d7d8395952ba8685f31f02a15109d38f0ec3b88da766d72be63c7b484c2087de51f5330a902815b381d4cbb7be7ef79cdaa6e7bce8df0ae6a27c35f8a920b6ece0f150c65e8625e67041ef64362d2fbb19dfe5f4951b16f2d8e025cada23db9ddf9ab20868cf6201662b13c6f8a8bac8db7eccff08c13b4c8a3fc5e8f19b1f970a8311dd28668ba0a918e6948e69c585f25be981b76574e7fcf6284c29242b9e7ec227d6d232fdc124956749038e26da2259393215fcb715c8f20ede606fe08185683a1742831659c84879a8d8725f6d5daf9cbc6f6b2ead5dff349004498003cd057c746829a0cb5b72fbf74b6d10587ae3c461190637711b88999064999152e283e902bdf28473a284ad91215b66ea45cb45bc35a71e8b88ae0df6e80aa3d98da6d17166d0d6da34ead0bdb63cc1fd37205d8830d1c55e1d28954f54439ef4a71d5fe3b65accf1037d6de8063c0543e00664e5e87595eabb0f4b98b0a22a3c5c8ee46d681840010ee6a9ffcc05bf628123ae6621d0d6f5455f89cc5d9bced174fef873e1c7d56348331098e42ae53beb1d8f2203d71ce23d3ee6fa51e928fc42f1c80b5ee96e80a90f82fb402de6a11b5efc4d5113409abcd4a49b0ba03f9bff1c27aa4dbecb99e10aaab67b14a262365ccda1078e68c36fa4a61d0bc4e4d7b97b462747af4de1d403c7d6761aed0ff17ed21e00ebc91bc56dfda7b77e30e074e107fca653823a5456630a1f58579d19753ec6f9f761e081cda47dfe9b97c2d3dc3adeaee05a0db5a712a60f41a6b288d69bbf7ec1a472fcf92ca1fb327be9c7aed21d8721b1e7e795900014391ffd32220ef41107063db0941e8706599d12bfb4e995cf82d77dd6a9cd0d008fcbf97e0e8d9b2e355c5ac2811d538b0410cccc7af055131aa22a3a94581ac7e2ce2d40f707d05eddbb30566afdac564bf8bafffd99ec18f6890be1985876a3462832525ad8764ad3f461bcdedbea08e3af42dffbae9bae7bac4f7eb534a10589939efdfeb606cdf70e1d28726788d8593d598682dddcad412422860283d6d6661f1a101343d38e1e5027d5fe9057b2dd2cde43040334affd1677bd6efa0272c9a8464c01f9558e68db7149a36e2350dcc2c20d70ddde1461da89aba2b8adea8e2bbd1c489f3b2e58eb67230da1b9cc5b5b8073cfa640390d7df33e315f660556deed5ea30767c2afd99e5faf872cabee9db66f87427ae8347be43a8dd8d0a204ed1694f5e4a8ead420e5347427aecd106bd88fbc4067e7b2e6cb07de8866a26282c3b3fc8a1691a17221d6e0dd3d3a8300ac13ad9cb6974d5122e60ca599e9e4c5860e872a313b0d96cdcc56964f1f02367098f4bcf63e8d048702bd13f0b33fb0cdedbdbce512448c07d58f26e434d5d0218573e3396491a17079afdec54837d93ded3add97dd2c652515a8ba88cd441e6303325196d1dcf9ed3ca00d93f5a5093a3b0f74f488dd589c7e9b439cf1aa16808214eb6ec36bf54a9bc12b0687bb6e08d2e3c42d19011a23116a260e4648fa8893d34e940416a478f0b18baa5c8ec454e8787291447b4f9863ef13d251ec76611a2419d2c1ee905b963ed8dd619a576591fdaf850250c1ae015f5598564757c725b35ed3f86ebafcd9d56880024a6d7fdc9cc2426d7028e27b4bddef5f20aff3cec3c3d243e8b9f9376e25a60b4abd4623167309ae1134e773aac2228be93de0059d8ee8bcd02642aaad6bf6c46d321937ad4d5b4f6997d6953d1f2c93848e282580f5122836f9cc6f4fb5e352ccd9024b28911d3953115fa761a90b01f6888e14780f3b1482ed0600d29f68ee1df4f77e36398608cabb8a2fc86588805c537cf2fb73a19820e1836eb2393add719183915693b8fa063047eaebc9c9175076a8e8b740b7dce36e080a376e4519baa12fb1141f322d185a94ed52c3caaac3ee193202acbe9c356c85fe29b62e53fb9b49fd0a9ce4f1e843e5464b2021451b23952cbc8575c8c423c8fcfe0ec469c485396941067f6b2b2ab8f9c4ce1eeb9a9ece8d9d14a6db1dc56faf569db6f106013c4618f42248c2c5ef79b15c2e81986a38f831d98f4815eb05cbcdf5ef3241fd65838285780764574a4d9dc19d4bad9d2942677a488f9b183857d61a39365fb8199f6e7b5c12b3cea3fb4a9bfb912e3539afd27c207c2f873ab4a6e7c6ffad0fc9fa3bc924749521f0260e27b054726505113b4d2f1664764434231fe857bd6ed7da09073363ce4d3cbaa109639aec16eab9ee6625701e0fccd2c7ab384097ebf864a5aa55788ef40004315c004de44db29b129721420a0df7b759084975e0eee0eaeb7bd1bf96083b134a927786e788409d7eccaf5df8f5b98267db95fea20db6e474d8057447826573f8ae288ad6b55f572b8d24a8d07e25b75f17ea7e77a0231f0f2da53b4590b910b720299cd23efbc7717cb51fa4f6588ad52823707ca5880acfe07c314352bd650bddd0a08db42e910eee45d85b842fc99e5ce3d1d64a91908c5eb10596556dbb13c851d24f2bab1cd508d55db697212e4ded49477af68c035d0b1b10d5d488f4c87a264cefa980637e68459357ea05e18cfc87416afc6548d0f53a87b42ed72a1e568fda1b2075f3b2638318b3ce9bfce066a51b0a88b70ab3a7cba11881d99c57fa07ab46ee12cb335054c46219c87e8d99e2378041f687591aaf91e6b07fd36bcf37e7b002875b4c0010d2d48cde0d3c027eb17049178b0c67a307355681a3ebd2a842a86b4031428bad7ce53de97fc215a4b62d64cca4c47030b061aa0e5109f188695fb0c4d8187866ce8c2b7ad4194a01855f33ccafae67cfa9b43c91b9e747a35356ecce4a74d24b8311577d845085c7cd8bc56ba1d587354c496dad49a7cad97963fcde4d5ba32aa93ba668bca32549cce3edb6593cc4c6336745df10dcc814876a81736c7dad228348729fe85b96e2bb3a01647cf679cffdfc97582c79387067834706c568f313bfbeb1aaf286dba604001457e0832a2b03ce18f48bbe8593bd2258f6ec3a8648f0c54627308d791c9927450fac1dca75fedc09a021feb3e94d85524414b3b831ddd5d567585b6eeb1a838e31d804d4ab2805da82e99e50aa1f818677c0166b8e48b5b0f098a7562321adf450c9b5b04ba8fe639ca3a1572c95f8a93b5ed8995a07cc51832041646f44095f3d887956cc64bf6386763d7bf55df94983d052689952495df96bb0c803147166c418473caca2446b25cdd1215e603dd2dc6b38e3567f0de52d332898ef3e50f90297f8bbcb253759cd98ab2b7fe85d0a3b6596b508e3280b98037d2bc9f02cd961f14108c833a9515b31bd57cf4e8e84d97eb50fc0d8c513d1f3862ba2a80f8f6647550862bbb9d4fbdeacab9487a4558ba5eddfbe68086816fbd0a051ecddff304015bd7bdfb0824a374b5e16a11abde4db229c9930121235e500bd215723e8e1fbd43a08178ba4625da6c8020c88c93a9a36ffaf5ee9a7fe755264a390a51803dfd5b49edb8eafa02a8540dfd9dccd175b5019c3c5264df6a6ca630dd90a613f0bbccc45ba3c66a6704b9caade6c27c5ac91c012e8eac2bd21ee48fe7bd89ab201efc274c7c526bbd65a1a0f5a9a6bb760e24928f8bf5b18df1ec4b6798ec1a2e615b1b469533d923f2a0040439355ff43001c2c362c62d484d3590c7a8c40cbb719ac179c320d9fbab047e64ca72d5dba8662a53bde73237e4143a7b1e8ea210f33f47e37630ba68cf019b3f1b9b24bd9d62332bfcfb6efe3bd44d5e0e233169a3c07f2763181837b290d52d0872bef7b70620c0d6eb2538a67eb66601ca828060b274c506fd6129ee5873718dd0a35b80635b252bbd7b1433643bf264c0a85ef7d428291125ae150a84dace0d059c194d3f8a010c96fcdc17779e947f991123feb1e9ad98de448ebac126cef3abe18d6b9e0b5bb02210b4c37b0fe7accaa522a0984b84328e9821a8c611fb3b755392867d7fe4a689eca8165920ea07b4c1bbb56603f858bf1a30485fda8461d74c1d845352ad7e3ea3673df8d5844ce733f21630d4ebeb900b7d4fbda142f0ad2787bc87b5938ec018e4b41114db54b3a77cec3123d01f6c5797ccee3e538a2c59751b41f25f61057296deb8f7b560b6bed1bc9af42bcc066db57ad68316f6220d72cfebeacc13ab1aacc6cfff35877863e283a87d1e753db094a5d3766b7ac3a0038b7fb4370ef5f69618a89d301c92ad2162ddccbdbdd3fd729ba42a412c720c170cc8edea55e666c78ea23d464bc24f43feb95a0790c3310da855bdd466e725578cca9ce287ad8a4b9fc8f6ca943ee6c03d3eb882e9ed81ba174a9576e45a7aad4c0b1cc376d0c302a7136d91ce355709c3aa60535255cdb7ae329bf58b4707373ca451591d73cfc421ef6326fdaff542b10cd038d4114733e801602ec3fdd09520ca3bba66c03b91e049f7ba924adb7d001014923f803e086e480e82ae39a3c173ca0c0e048c71e2b3c9ce67feea8d0473f8326819750002050d237e42c66fffab349a8a2def1b7da0e605714929ebe1f6a76fb164e7ad55f3fbd8d8842eb25422db090e7eb775bde5162f354bb57c42d1f22edfd4a7bbe42dfcc04aa5ad65bf841a74a2f7ced49fc8f3a859edf3bfa409738be97533f9df577d7e70ef0b2c887a91c50fe43fea404d57fe16f8a46d82ed19c881e397e89e87fb799afbdd8e06117d57dea5fa6b3e14a57f11c1ddcbe7d212db9a58a793301d6b3ff5aa6939a4d2fedd897db8ce9ae334c58b3e86ce40103edf6f7acde410fa27d41859255151c1b2919febdf642771639c498ceddb557e66aab31d6d7bf955a871d8ca977af907d937c8a2550e8e68e16081f32da853e674fcad269d79392f7b088e02c2be3949e2c6ca64cbf8f302f8a10ae00443bb6c73188b209d9c8b78573ae65463c6d2900d5b3e30d3dfed52022c68bd890f97e361f4d1737ff567667cd07ff6c098ce6250f4ae9008bb87232502201f26aa535120ea81d6c9b5381e0a7d9bb821689da8abc221419a882d2b1716554a1bfab95b414c45d6bad616931761f0a18c5e385731f82b1781717e1b7d0ec6be72a0ed19d4e73664d93ebbdc99f5a1a3989d03bcf6d89a24dcfd11a3c631df2b83cd0a038ffb3cbc5501080ef88f65845bca783b2439d5f1818808747ba9976ec93a5b6ceb835c0a22f80864a0c1a5313a89cc37df125a41d208282b5c6490e0d4e84a65c71a4f96e326edb9ec049d97c5213286be2de10c240ba8be1762d6df93030c5b2654954b357113a45efda301605a79320746ef9b01466cefad229e78bb995746ae368aee649a94ace0fcf55217d759a6bffdc11d72d542d2d584bad4835af069fc2cb7fb36bb204496e140e9d6477515b8f4e6bbaf5a75ae04293ab03d1a4b1794a0394efdb175450983ada7bd3b1fbba0a3333c99991711c434cff7f253100e9ca04cd557024c87608a4adc1bd313370536412985a17423a043008856bf9f2ccbccdf2c4a2fd1ac706fb9b71b7966d9fa72b670328abfca43236c55021786cef151f21a1c3027c96a730b43d2792f5f7c100f72486264c3fb9b30d55d0a5fa3015b921682d54b9abf554bf5b901e58e922089da8aa9b33d4b231d4957a926c031afcf22260ee5941d04a07e42dedeb8ae01f4db9769c6dbadcf9129834233d5f90af9e27818cdef944df7aab89de184f1b2bdbf2366ed0784e63f0cae0fc3e869ceebba41609d0bea85f8368ef74e12b70c685d0585997d80f74d071077e335e9f885737f36d97d837d5d69a1a79eb1d5251d713f8d437c885413aef82682cc2ab51c20ed588a6860f876fd213d36e750434ba6208f4d87cabfe8377dd7d6e442f860d369367f6843167610304ddbedade9af389b2decf6567d699d3e532ac53031fd058aa1e09b96f499c3a29034fa4d17964c43c66360c2d957ed5922169e6c44d3deba326427ec93dac7cb827b85e40ba37d0127cd9786b277b8a1b7738e9cc5ed776b0cabcb28f4a1aee0231db869348a05b2e7f27f7266da7e60c3ad4d1a3cba71cdd9145d608a511eff192ef58e6d062bcf640eed019935e0bd981bab772c429381a8aa2045a1a03713de0f7e5edfa1830e10adf3458a9e39d4004e3c1a09ba687e59bd73d37f50dc0542329597e1a999e35f2f24a8bc3f526cd66e4f5fc710de99825b33d97a1ec27a903d7e7ca088c3627871c6d3a2babcd77aa27c37ed111aeec3bc073a850c728be59ea4fa0b112db35145731958a7cc6e259c27f5e766bbc3bdbbceb4acd22633ae09f664543ef3a332340c0d2c0ca5ec649361ebac89a4c03f1f0e9054135155849f44cf1743720e1a2f5c3eb4e8855b55b2adde6238f855c5a82c44326f74b31caee1febb32dd3398441ce4590ab774fbece1efbc37eb933720c6de18d6b5c024455938f3800341f28bbd5a8e52f73f6cfdd12a679d53f9022b351d3f4d65c02da249b8cd3be5e7de81d2422220aded0cd0b0d46263ccfaf113f1f9abd909f67447ecbf0a73b08d16297595438b3e6e0919f734bc1532470fbeb8dfb5383e5a66493bd2b7a1ca4d2659b2727a26fecc919175f71c620327ab50948657b379bc4467dc9a4d69b394196a993c269db89cd0704a1e8a0ea0c0adb79b3c66ea339d1d541a82805a776f43dc1e0df0bda533c36e09cedd83f58f3eb4195aba7edfedf37f7a0ba2c12ca65185ad300938023ff01f070f448dc7f83d5d9506fa29c1833f42776e087c462096408e6665d76627c3e7bf57c5c1a95c91bab39709ffa5dd559dc5c01628cd464d4c3e429b035147d12b91be70fe137702622f752c2150b9ac5657723827dde6589f45cb3ebb29bcb5c1c41c1e289c6ecec03807f67d8be9b54c5f95fea43907584ebe1e0583c296cfa9b83d1560897122a89abcf477bc055843fcaa323f9524f85d936a442d4eec69d82f41545b3827e74e0c882aefe119f75b381c10d9b406425d1c3a9febfa46031c2859a2ff5e016f12785dca72166011afabe17f7dc8311f7f7eb7e178620767ccf843187ed8261e353c67b8aed360537fdf9b7466fd7a42bc60a839eae4693e87cd0ef392cd3213cd35ad7c4bfd74c22995ef6058a2833670463946e0d47dd803d2d8b644a05d8cc3eeb1ba5c33d3ff50707f95f55b57bc1fdeec91a33ce12585a785e5a33535c4a6c44cb08d6a75c6aa4fe10c891ade715f5b8f453caffc122e395d9299f77431af53286a1f339721b9e7eca0678d536b2c603b56d9bf410f770c4e2a8e3dd58cd0a0c17f14d78efc8dd324ac360d458406b247e336083d54ca60b3eac883bb48c2a7ee6d0a7c2408ec7f48848941252627a1bf157b5ff6938eed578b33486d91812b5487d35c720eb2db8bf88ca66ea3f2bf4ecc9f08dba4c2ec725008eb4d502b17850b4763e9752642c5ae5c343b9c08a43c0dd05d94b99549b5d9b4e34119b8edcdb5148f54e07e241366e3dbb4f98a62a06d82dd32a6baaaac9c78d32954e22327d34145a3d374b24197fb899990a1b96e7bb9c49d961280861f516e9554b92f6a1f9a99e8f9389bd4c3bfc31da2e4a0691ac0ae942d7ea8add679e71c088aceeea55a3f75df3ccecfdb14bf5d22dba0b9112f18303c7e428416820a12d0d7c6243339fbb0815c06b74c99ce0def9369481e143bfb54db4eaff7a004612514c6a1785031cdc3afe36415077aa8691b734adb6fcb6b69c3d50e6fa08765267303fa03bbc24aff63dc6dc5b3945a35f401cf943488437c194af5c373a0d3584347d3d59aa2521500428e106be9db1b9b2e55aba3888b00af258fd607efac9b13e9ba97f51888381d84e872f086cdc25f22c4fdaba13878030a0adbe82b38ec45f2533d3d35a71ef4755a74acad0f7a7a35d0ce4f981b586f5a1f69382e331f6793973936cbf0ce9d5a5bc5d81dea304e0f8b10c2adf8128c194ee3492ecf59d5823801cb8390b67354f1bff6542fb5ae71351d91a6d9697617e9276fee5ded92d60ff5188cedb212bc45772aa43d68ced83f37c119a13f67480a5f90436d70873cca45c789a81122d19f78c3902f46ad7209b60a0b5179aa86fcc2af5a85a06712f8a71c904418a0c7b616efe1673d3a11fed868ff59b3a12427faf51a437017bae0fe9afe0ad3a420b78d96c1e1100ae064841b4955b95219f4abd6d9e8250824ba7a8b2fc7e80cec1f71850f5c55953b4fc5cad6bd7855e25f7e3d6f35c691705752b329ce6e202e741207679c199fcf6bebeebecd7c2aea8e962adb55ecec6e391c99025e973c4d4a62482fb3f4379d274b1106a8d33145de905b6d4698f042b874e77e15179220498b84127f43dfd8a21bb8f458fa228f572fcc2e9c47a960ce22d594b8b836c1555027aa63d5d8e87bf05b8fd5baff168f2ecb31aea8b1f23e7b3792b61921c6d04f875d61278aa3c253367355ab4d8678c92addbb173fc081ccf53f2268e718c567dfdbc1caa6fafc383f6f6f23216f490a5049d0e43123eb576be6252099fafc0d9cfc233f659062672959bc54503a91b6c60556f858aa273229f31f4c0153d60ebb9f9b8ef51b77da5a10e69d283d54853b729cb999388e60132ec4820f1937d4b6ea138752826655a7f638d4bb497e061c934ce16dff481488351ba60effa0bf2e639fe524806d173fcb297e16ebc705a28b2ad49c3b1d3ed6593e280e3651fdd2a18ac6968e1a773cc1bd68488767baf8ddb5f5ebf8fe7f8d040561df7de24b6ebab881e8c80ec2f7b91aa4f74837ed5c00551acb7736bd3d403199b490cf786a53caa53288e9e4330b5905c2cc07658b7f5e81de70d85b6d7a4887cbb21d28d9f94e7d3b897cca28491d430e3eb5a4f256d86b61acfc143eb06e3e5393dde3849d097971fc963d7a00ebd7df94e24810e2ff0d1baca1848d1d4a872f858211841e3ea637fad903b3edd8d2952b1fbaeccd855609f5ad493c33b5a8ba0712482477d555d9686d413f74a184a83ba5dad7ea22f5ee244c523e13833ae89d612c66ad65093f882ed26f78392cc32e683a2684e79d11b8c5a90617c9de1382fd1807f6c935338f3a4a3c6916967b6847e4b79dbe0b6df31ec054dfd1e33340324d6d31a567b16ec5e04e86691b9faed9f71af6c18ee1832402feecf12dab4b6f14f481403c72ee71a70909c848211e606a570004b25c800be9042cea48e27b10a97cd9993358cf1c2a2722d79b6b92fa2ee23a21a43d3601782275cf7b1e8d2474c8f353d5f70be28446b3e2009162b63d1fcc34638e2682d778ede431d1a6baa942c94c39c058049f8e17ef74cc4ddf37069361df4f93794b1da16a073fdf598b75d84f3588e8b727db6cdd9f651381848ae9e03b5e538085c7872b80064c8c466467f3ca232a9bf0004eea4c31632f740214b8e5bdcec8c56eaa854031fb1a47e8990d10a42d98729ad21e4e93af69b32fbbc192dfc8223a6d42958c41dfaa314e2996de8fad0b0ba8b6551310c9c1f4bf74df0d5dd5edc13cc1723cfd357f81d1661590b04d8685009469edb65c0b0c2aabc654da82e369238408541f47869671c9dd80323239a58a9a86be122e072e017ce8bb5dbd59276912749f04e51d9e4c9a29ce3edffe3f7a466d597a60fc19260a6dd5fe584bd542990831fa7c70a52d696b3df82c704de8acb6a8ff1c5241c9e046859a12f05598d85a412226cd91b0ce90b42c7690dc2ce64c3a4ac9c92915ec922777b77289aa508d9eb48b963a1c04ab9c7069dd547c44e223e977201eb29c323a7b21cc19e9636fc8a11e528537a084ea9ecf74e604d3a1e9addd83787e7e3b98f6d1c4a114f759cb73fb3826c36f08366ca96fd66a915a7b72c9e65ab53256dc34182fcabfd54627c50d71b14787f5c74e79006d5e5cf7912b8bb9721cadb323bd8cf3d6f908c3e03cf248994060c5b7caaa2f9c57fbcd7269bc83fd72a1cbbd87b1a9a194ec3473f90ee61f1727e6b28885af78759cb5b965f28585d7f0f948851f59efc6c75a44ec28adfae44163245eb9aad52668169e83357be369c319c598b6f6b0fe3bd9b5a579c1ce5f65feb767d3d9ccadcfba5063abb6c027ad61b73e8b85e2312bd68b617689785590e25bcc07ebed0f31fe484aab4a02d1bbc1d4e6436b3257524a2aba1afe76faecb86a09aa1b47ab4ccac655e052af5328c1c2c9c659d73f1f4f5dfbe6d20949f0903bdfd82fa30b2f19aa271d070a3a5e73d5941eccb94e20db427e0d742b9987837bc033041b24cf268df01244151e0428f3b55b71d3a0d49b9f52c0be081e6a51a4dd03b4ef4a429b628374b3b1ca24e7c501db56b2a4e3639dd5e7a2c3a4f5335698dca16b429b059a0e1af929bb4c852079aa025b0713f00de035e443111cd45820d7ce0d960bf59f7d08d602d7d9e3a4948bb570d15ba7143cbf16026fbe046b06cdd35d7938a79fe0a8b069645664849100bd784ff27a8cb81d0a4b6c5e6e8c2a24626c5093834cc42fd2e12292db9cd3f7324c04f2253c5f040bdaef8fdfedbd33bee9162a849ef02b699786814e9d0b996d5881b4a9cf13630eb0ac844221eb1e499e34d5ed559337defe6766ab081d56dced31d37a3786a6db9d54f2a1aa4417ba3395d5f48a1bd7003db5baba7eef6f3fad3b246c66c06370b54cfd0d74f6722dec89a1bf925083ba5ece03a1af0b901cf967ea4602e030f99188b1a1a6a5b277f373c5d2a1d7805ca2d32863ba065d413c3d045378bcc0d734a44529a35f36ebe7f454025c10ca6ed87d8301a0a1c760956e38dbcbb5a56a7c686feb9e6a3091f8a6cb53cda5e0fe75a8d0302247d76a205c7354639ba0e68c3a75328fbd86df3829c665894167b947c7ef0ae33e261e025e856ef98585c14563d3b9da0d6b9086a52aa5b261e5bd7910e11c14faa4bf2e668551018be3d4c718b78b0727a76fe0362c90f3cd2e14b407f20a72d2724b9a9647b7c9d74d8571dbbdfd482e727f8b7fb117dcc8b563bfbcd49582926512dd7c612a69fe093ea14a5d1a7b8d51d8150bccd8141716b1f7c14da51ba029ec253dba649f5fcf881793620e9a4adfa73f5f8beafaa7a3344a0d4fecb0f91ebf072657f3c7dc37965dfda5b1550df12b5f172b4108b2ad1dec52a5c5d5dc1fb2c1cad984c6d95ceec378be286b3bbe52fd0fd94984735e6a893ec8c29c3397f4ba40dff859a29b01ad9303e5e2e2bc362675c329cf6b027749b97a2145def73f252a626d8e7d9986d86613689d7f6de53e7600593e6a855351dbdccf9e78a771f70f874eac4fce46825942b51a7d45a5fb8eaae1ac9f361d4c325734e3a76858bc5afb201eb1f90739bff10bf962d710511a8c8f60137470fc1e1c9434516f1d86bfa4cc1b1cf248ba9a13c5befd429c572476373ffb97e159062059246792528c4dc58010a0e7d29bfb71f1ee027f6a7023335a5db5c682b98b8d9d58fb4d6fb5cb1b772b449b4a1143db52265d3a1e7585a7c88887a3b49411c8045e7a5bf70641ba76a72f479bee186d8cd1ffe19f1ad3864b239514b976723a653181fb06589483ec7881d0a14b4e387ebd8fffc9c301d4c29dca4975de5d2f7c9f9b46882343e2617d4969e6f4e81900807cdfcc7713bac60ccfc08b304b070886ac40caf28d82770ab10b51149d99a63bbc28472976e89e38ad0ca2604628a6b917135d9de6d6b816ce63243e2d310d77c1d1742e88ee659862944f9cbf49ae3b11c80bb5f9b3f55ff48b30acbe80ddb9ada458c2d22fd5b8ec72323d9c2d7360c69b9fe972956b52e7950d25a400ff46ecca0275c2402c15f45a3127182dd6f55a294a9008006932496c68ee01d57b5678cd66bef5cf601b23591885f0706ac6508621f571e626469489fa7541f551e625b54db7d0658245d8b19e2982bfd330cad640e3c6fc0743b1fbea5c0dad545d31e0e5505acd708d8752773f51f7e9f4306e47022b8f64f29e427ad13bfdba2c69970a527f2ba8586689f6b741ceb7f8f9395ba002869fc64b8e8e51d23baab16d294ec0f483cb8d6de0c2aa150bcea4ddfed11c2f9efa09996a9f2a6319121299ef0bd8ee1d6e550497bc20cded56ad77a337e086129e5710145efc6075cfadacd2963da18687c6ecd7adf3648d387b501149e1c41860e34021d79aced066f0b754a39dc45b937888bacd54616588bd6bf43f5da22e01e7b4f2d324ac717091b97db8fca93691712b281085957500f76ee6e17f7c61fc6d46df95d51dadad644384a4ff3ff099e75cf92788f8c68d282500c6f3d23b8f4c71aa132ee6832f5b005f5b1bbad0bf022eab47cb611ce012fb79354a8cef65b036f39b32433ea3a322a9de71920ca0fe70dd6f046cd7e951eb0b9f4368f983fff5eb1f72abe6e3e1c6ed21b5d0c590c6eb4e7baf18cc8a13a66a682490e692589110639878872d709568b8f88b6de89db772469fdf81fed6b7eca9b4ce149bc04fbeb41d1d4e09baa8b20f5a7304f28f093788803f4239efdf272c03125c04349239e92a2a7f31bfad3bdb79f6b4d92a1a0c187829d12dbe8fa80a1eb666d230412f85e79f4493186e20984e339bf33b6aac0158be15a1418f18abe3385736dc48428646ec76128a99d679bf86b691306fa7b8ed0d2cecd0babc747c7fd5d88adefd9fad1026c244c2c88a3a8e4820e040ff8e3e526fb7a9bb1621584a686c9924635f38db53476fe87b2a919cbf5b3d8d4b0a8031cedaa32803e6027a6a95094d2d2e1130021602fb7195a9a46294474a4d5738bdf469e060b6498b4e9775548bf62b49c784df0c434341e9c2cd33cf053b4c29a6a0927758726027d452ab6567a708bb0ceae5397dc5fb26c83ec178b2e0d65c0c4d4750830acbb9dd2ae8cfcd2851454d8b042d48348298a36655c2bd859b49cd593eb7ecf34c69370413a4980fdb870b74068214962d2a18eccd773e64e84d1c38906d49c6e94b42cd336eda7a682d9bfd9eb4f375821ef47a2e87d9cc28e9d06c6f1f1946a8802e6682820feb17f1e0b263fc981c798cfff7d18061411d3115bf3bb9feb1a1cc294c9526cf28af18ae5221afc7389297122f3ecc857d62f3fec867c5570a9b9a3b5268610c7a4909e6aed80e374fedcca561f7a1fd445dc5cb251f8213ce73a02227348be3a7529fee3e87b9d958144fd6281e3452a251f11378dfee099d0d6fc97d690f837827fd33e182a50589ea019fa72604badfeb8ff39df3b3a31a6bb3c6b77524a7b448a567f5712a589529a652b08597144bd56af5e710efaf8cb52cb832b6a83c03138a2c04ccda83ace8ec7e543022f2f31bfc177e064c7fabee7a56315abc8f0e466003fdd01fdc03cf7fda7f7dfaf22c62c164b347f4544f60c868e2572985f653f5586795c9c32640177fdc4f459406a80595a5241c0b753c6e445de050e81a631b201efd0e8eee2ec151a2f549056456805c5cb49e98ac2666c299b33b06bde697d5c8c872893401114dffcc82905a7a32f9a185650a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
