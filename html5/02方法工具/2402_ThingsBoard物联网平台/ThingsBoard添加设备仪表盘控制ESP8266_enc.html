<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ab3c16a09689edd8b118f28c324ab20baf1a91e74f0edbeac62519c515dfcb595cfd2db5c1e7c0314462c2e1d9253a96c2ed132b48fc9ae3b72963baec9ae3f36da465847a741e52d548bdc8785049df140102713ded8af97e328fbdffa6cf36d250a7666f51043d09ee68dd45954f7eddba91eecae83a4e86307abebbfe06779dc501661556836310e6b08dd0b95c082247a1ed2ad10036fb28d78a6d2dee634ee626acd3bf16f5d5aacecb86aee106308421080b8d9ebf481dd448d1ff8ec489c49257c9946631f33447629059f146b2fce44939452ef8ed732cfb5986f77f6047ed7a029efaf69e5ecc85df62a5e5e4acb494b789d881096ae646eaf02445fb597513f5a4be7c15f0bfc66c467b40b1f2606654384270cb83bb7b9c6c63f48c1a75be2babc750c2cc9a546913e390830e8123ad98d23e28dd98635f5b623f4397b0ac7547dbc2f243ae401653c3f7b0074c1b610551e6cf054a5bc6e766ba6e3adc2e9f3becc80401b7366ab723e0e4d5e93611f5ebebb4d074c660fc0382d18ef23025b117b868fe41258ad2d84be8b5cb7605f5e5d5eba975a376fbcef172caf2b882fd3de4d2ee366dd5dc75451e5d906807eedc483ab94682868cbaa798b9308f72d84f32239975a20e7776ddbe3fa3a2e421b1bfa0393e69fb38670425d1eb03cae0b694255747b63e70b75025c05bd9ccfb77c7d4192a6935e07734863073fd214d6287a7f6c89b4e2c9b36b0c1cfaf39c4b82970a6897282ea6e3fc101570ebddee922cc693b48b3e1a433bec23d84d2b617c198455c7a535bda0877c6b9ce53c9bc3f167b0d442f2c18063cf4c1c50b54c4607f7793519585af67aa55380da23ece3d86d8cbe07728f5c5fea158b410c0a8316e04c2f3ba412c4d0c49f65ca5af73cbdbd27caf43a8eb2654feb36e80cb6baabc56b79f2f1aa41d6fd36c08157543e771267ef63359b866b8965b91127d34d667a0ed850e289bc7d3c58260b272497fea4489dc22099e81cbbd9e11d2afdad9bf3d77f984fc2af8cf36ad4ea54466ea763c0f6c6c73e983852d0d7fdf8d85fc0545b8386d3f83577b825eb339416a7a19fc4447fb6c13d54d45355fdab80f676c0c7e016ac593319cce12d3bb0fb8f24891ea12a3778ef32081b6d41e01ccf18add058968bc36a2721545c72dcd383f4e36601d6ef562922581a2c278e252ccb7fdbc2bf1e8beed8c4947cb1e70ebb68b13d7b13cc651e02d3f862f3272efdf8144f2262ac40e719d10c3124007b074571bd308ba2bf17ae9c233421021d2a61e3d6e0a9992ebda3a5f3f3ae555a163581313fdc926a4e21f58b66db029438e94a6611f8aaecfdb85f23f5c57c7f7d4135b0a4705943d2830fc3743c5f7acf2e04d4aaa3ea174786ba8b08334dc6c28a52e175c4f69195da0b54211bd46458cf218599944cb76d839ac0b40849c70b509716538d640b025c642dccc527e11c0ca541f0eaae5f6466fc69e2ed8b8321a6435628abe9d4ac1b9ad971dc6c49c0c30f5b6be611721ae2ce506f68d22f27b6ac19c89c5248d549a2f34483cdf4af957ec844b0871cbf18ed55331a47dcccded0f542fc39a92b4536026a95e804f80115cc4b0ec97d1c9d70bda99f0dd1beb71489b50b0fd54c09ce9108cb14b788eb4d7508d3eb3862356631fc7f8db189cca787d52c1ae57565afc5b11c533648e5268f8db0291fb80ee6f11accfb01f1e7ef37bb87448d7d7cae701988639916b668df96598ae75cbfbb12097b0736794cbb0a6d9c45d10aa30d8fe6847c6c849e09ba831ada28608615a40269db379767f3e3a0528a5893b5ab20f0c4c990b3eff45990ea0e0aedb25778bc2b89104e34a36e0c5de2e196920ec84e3301a7f272252b14cc0aa19b7be1494529adbd3ddc7d7b2fd0042b33a773cc46fa2e4bd3aeac11d48e14969d0023fb83b746fd5f26cf7e9d89edac590905535877e462dca4093225cde8cdd8455016fb7045c287590e1879299a1da900c4b485cef1a4fd5086fa5fe4f3fbad0e4d77aa38ff31b058c879543b5b9ff4170fd073dc34f8c056859475bed2a1f107e9f3e2ef065d62e6a5992bc7ac41be381ae49cac15dc50e504f7fa8fa523a1105b5eef486ebbf91a4a080fb41a0c7381a2beab936bb0d517662f8a31af3f5d637ad977f162ecabd8e514a68e990fc080be2775d573ba69bd972f8055cf3bf46f281c19ca3e0a69ac757af6d0e38a2f6149b1dda7cf1124e49047df6baba3c9742648e04f055990cd56c2aff305ede8ca1109b27fa863063dd0b1781e7aae7a0b1c06d234ebdb5bdfc1989b4a40fa245b6ae2125edec8d62bc6c5811ec98440372c8800813f2db63cb6cdcecd99440f00980471a8abf944c21c21125b13db30e87fbf2d601229c77a3c9625f4261d36bb1c94bbb0083af0ed6d5b11313ea733ef2a29b5ce55206b68d002b98697a811155f6682c2d1dc3ab480556b13680675287def3be4118af24d25215e67c717147f9b7f73fd605bf437027b8af387b6bf37d373437bd32614aeb5b1d64c80a1d8b24f2281b725394b44f84ceaf93d44172a5f32141aaa1f2a399bf8cdcd295a2559775d42e6090cd470f5ce1c02e8227507a121ede87e482625fbc0db7588759653770f1c446fa72e9bd2722154b7bd9f1dec3bcf4c621e72803b5570d640ffbd7992a7534ac3f85412fb5c78e803816528000dbcf2f3bf0d39fe8854533c2397eae995c5cbce840cc5787a17cf9a029723fa23958aaa32b0fd37e8010e5b9a4358a413d27044a03f454ff563c772cf0ac490dd75ceec54162bba92f798619266316d805e1691d1a0e36b6c28bae63807d032d2bafdf1bed7c3c8eac18362077eea13026676050e948b8855a96d6b1f1eae16fd4ab6a2134511fd9a8176c7adccf8b8e1a72687065e55777efe90ca42476f42a31fd67a77f4b26e0985ce387031bcd7be7e7709a7305999786948ce52a95e19e54accc3c742445c121a8f3ae4244d8e99963c69c2ba8191c4f111fc990ecf48a00e7af3c1c849966bf6e2eb37ceda0190d75cc958ce4f2c4eb227c96f2e8c179c135d08b1e3ae4a88874ede03b94a3b9e5da0a2ff3db931b2a0ee9ade917f9c5bb084df35a92f9e7c8f19ef1ee207e74742e7c46f29e39054049154409194acf9fe99913a58948d55e27bf93f994b19b0d6bda10d44acdb40904b01697a80ef284542c7a780f327ff5f2dc5f39491ccbe1244155defda9fafbe265f637181b770902ca14f4fa6d7fd8c82579c80e45bb50292351b28c58afca323bda18ad70c0dd7f5f17105e4963a6ca3fb147a1cc38beb7b52b9575ddb9322470cc03e451f7508e394685f9777714875ede51286cc2103547db2f9a669d5a495f26ede0a769386d8ca6db44a6b8925039c27e1806da33bd437ba00cd51a366b6eaf1ed6f9cfc637b3242ffdd2d43063bb04fae8ae01b4659644ab128fd85319b3bc057f5c761bf5e0aab0f769a2be9fe884d5304ca3c3abf85ffffc2c4bdd1e577d2c81ea7852f9f7c1a14c7ca4dcf2527eb20016077ce295d3fef46e8bd184031c90e1739b093eb9aa2a7b8e93ad23830b3965e101b0289a862f5df4345e8a2e5e6975382bbc9eb29a16e01753f2929cd019f93141a0e4a8fdfaedd6a82edf3fe069533f58dea311194be07dc27205d3857e4e189a73d4f5d2681bce4ffaf5704143efe0a1f1ee3615d126d1657b724fc903a41cee0dffd27f3d6087124a983fa12f1a06f53f8f139c411306acd2b8f51d810621697eeefa99b81ccca233a18cc18f515ec5f2898f9acc371779e2ebe84100078e7a8061e1a4a72847be579233a116fb711193b7af620198b8bfa3dbe2aa9437de4c7a85e6f30e18bbc9c3992a9316f98e90f89ab778d0c62751d89f2e85a2404336dfa7b23ce775c930874747eff02fe13d1db049bf71d2a1c734694bbcf8cffab912829d099a6d9b368986d9434ea372beb8a6ad4cfe3b027ddaa5ae1225a1b7eda4a37a261fb43f62abc81c44df6be754c5f7b4d7dbff38fc98b2e1130a3e028a9b82727fe75e9368aa1082c5905eb68bf9dec627d8e438e1193fa77bbe08452d7e3c639c62c05d0d7f600a38df82b824e6dca12c5235d9559055655f97ae36eb6b6f3eb2cd1339c54488f7bbc51e54a80771e46a0e0ba0be494df0689bbc2d93e77090ddba15fb183378c9e333ae5c302e4d3ed546358617ed1bef3a99d93c4b8962bb1dcb80538fd16f2bacb29a7442c192b6d0cc34dca5fc931dca859495198861043d2e7f1881ee23e78f8f0fc9b9f3316455e4db84310cd58ca35070e5dbf89a11e42cd150ec7c178d6a5c2090579c9480378dbb97c3b1fb2389bc1d035e955d99f5be0f517f28b64c31d2c2b2dd914473078d3ee94ebe79f17d9d697d5633fb9587c18222e7b05d3358ed225f6635d25f8189760b6ca1ee0105f1994a67556ddc61069ca1d1e0e6fcffac3c4195b5d546a0d2f39eff375e20f4d8bf7f86b4f70b7679296a97bf5fd148a4157bad8c63a779d1ef9e9c95fefd9348ec694000904af499eca243fecf4f89ccec048dd49a26721f16c7cf5b3eebe42b37fa2d7187efcdd6dcfd90fb01328b9a00af5b2ab0d9fba2db2b54d014163892e95657252568ea084f6f6b7905d15d43e938e51a6a4f4e93e845906b30eaf40637ff14ca7d846dadc5336048b7773b4310b778bd80d88cfc186c6e24edb6ec56da8820ff740819a49bf0a10278299a9a1d724dd877d9f9c1b01f3a85eaa7086707ab6ecfc9c0278c0d899f0497b0ffabae4478f701863e382b794119445c8ed03efe68a0027dfceda42aa4e711de7bd6032decc9f932465f87d6aa4c346624369df43aa6959a23e64e8e3ebdf2eae4dcdafdb551ec0bbf25b4bbf02d5aa8845f92579d2408a0666f5ee56e4c716f5c8535549a30e7b7d3ad4c6e930c1f009895fa9b661c25f236bf684c36c1768367f9f0b2c61b20286e4fbf2111c4a8c546527a91db52f6cdcfcb525b6d7cf4df532a86eb44407f5071cb435bf6339006abcd3f07f57091fafbe0005c9dd585e575f7b2ff8632703de092b71c77cc3fa01ff35a0cc2b78a9b9f5399e96885be30d659c3b7e462f870ba0e436d3cb27f5b8d80f0290b4d97b336d3f0ffb8515c629ca47479adad8cb283adc511dfd110149766527c5078f46d8d83194592d11d70767a2d6190edcd727c7028d3ccb777f6d23dbf5355bb7610eb618bb5f82d6c30fe8e2364c11e6931dc43e628f52538da0de4113d837e556d31be046b49641625e1c136517dec911ab2e9892c9d64c5faacedf389400317989b27829e9c6530ccafe5bae912b99ec6c1cb9ea8cd4302d03d29de1267a5360ff683922740b870a1113c1ae7a17bad347bf75ea4f70c8f1c44bf828aa9d2da1524e48e0c751750cdbd90015fdfe921645f6b6e092ebf4ab166c5b1b1fee3aa87d59f9627ec39b5c7c26b2c809423a2e74679b3fd2679ef7036d6f2988e0ae062cea8512732f3c6b0a63a73adf33e147a4bb8ab53c9c585bf98bbdc73f6b1d27940348075e156360b664a0aff8a1cfa96cdcf120e7e8feeb978b7f4b0ebf8cfe6c5aa2e7d7651cfe0c5c468e4960fd1454f43b3778e283c139520518b927e788be619b1084074e9e0b6ccdb221ef8f67c25469ede655727b9e9eab4a1be2b66e575fa25592a015282815870b329096211a300f444e1635ae3e05db8d49e7037be62e487dff5cfcd665be2d82e27d01486ab0681927133fdbd20a3a4ae84498261cb0de423c84496af32c8d2c469e9730fa68615f858baf4d569f0808f0c0436b0cb5350ae0ca45b5ece52f1c76d827f5c63fdc8c3a2b73120b874d9f1defb335743c072e84af6fc85d529b491a3ea23dbd7a25498a82e926d91d73e43bf0b24101350fcd67fc264c580a5dc553558b21bd2daec69dc5611f249c0b2d2a3f4cf9b2be118ef51cf3e0cc324e5d949b72f35079d2fdf8372e82753529961387b4e81784b6140cc2446a8b0ee1e3579579f8dfefd594eacef83e26e918eabb7e411511f3f68eaedd117a452d78da278ba27f187c7f5d0a0af2a3f7ebaedc7f42d5c8c0a4663c8a8ffd7307a8e56d1a74f2225f21f887fb54d15b89df263b4b743ea1b7f563ae5f32ad2c5ec8ffde7fea6abc440cc0fb4caeea17c6e5d8e136c90e795847d8be02af491a07b14aac352924fbfca6aa4de0a703a3e787c2004299463e107451f335f84edc12707c49b4748feaa48ed08ec5723805a625830c99e80c452ca1e02da5adcd000113e8f335f500ccd3f8a3438e2c2636259637e02e5cdc2e1a2b40594aedc0ef535552e00b2f77d91cd8cb54617327d1bbed83aa933800110ded339b34c1ce0e9034d48f120397bbfceb901ded4e8761086a928a90d4ae2115ce75e87bce95a581fb094efa87b9bd472f77928d4c1ba06d787e16ed8f2fed7caf1d6ccc61906b0174cc57a987a9fe5f0d48084b48674481c9b88c154223d93bd1132590c2f7a491631fd3eecbaef50995003a423fce84252bba086099d8afc685dcf8b4676e003fea57ca456530d0a6038e702da5263c11ca82ce1989577d6f9fd9d25b8102a64f27010998e60a43de62b62198a0eb053c5b93c5547b9b5f9a815b7a42f0127cd084542b2242ab1e6af28d4e644919c8d5303717750dc9e938401aa44e7cbf1868cc1db36a287c8baf68955be2cc621a983b95dfd82b79f9b927dfe0cf6619b0a5ade02aebc0c593156d73ee4da10b9976ff1e3c718cfddb8048480fe0408547ce3a8aa170823f3614843f7094c11d2be8a7e543faaeb3d9bfb49e21ad39879c9f2f68eb4c31777bb37d4bf08f08efef3fe11a57875bfbd282df5fc1e3797068f147ec4f79b47dff6a351c0a6950582b09b9a24f6b44a01a068e3c2a01de8ed5bf3d3205c69d687d4215ac7f2eae9be746b823fb5f1316aa2ab0b8fa525f131bd8f97d0f49fa47b4a2d4c2e4e71dc7ffb8ed33b75e94aa06785e2b176c1336c664b65c98def62e25e11e979efd321ecf96aef9fead4619e63cc7d9ef77ac53c4f61caa807513d58cbf572595ccfea48296d1430ad256bef8c1c2b424e5901e5912abab710cd77700e78780f50b59fe697af8ae5904e10d7b0aeaed96945b4ebc84d5e0da7f70d92203a7f45ca3a24845a2e50f544d731df515af21fc23474c5f5db3f05aab0c4329f10aa8492d3594f27a4b188cb6f3b547af1afae7aa5e47bf75ba1cef7fd079bc23826ba6b3f2b27acc10fdc5121dc5b6c5f2ee24fe03d89abe8b82a1c24cf65783c89f5f53b552385f49c055c2270270cbbc4a9891fa5015a570a9a5720aa13a86c84f7be4563bb42a21ebc4132dc27fff7f123264d12d7ba3fe7efbdc050eb296289789a9b1c0ed8351bfeb135406673e6d59316ebba89caf8766e3ae3b132484d598ccae0a7c39e119a8155af35f524464e1a5d449256b4e27771d9f5ecb0cff002da09791ee31b86a975d3b2dc80df925f2c01ca2511029d6f6cc4b65d5c85bcb4654e125b6a26e115fce54bdd2d07b1d3a32a99987432b091fa341ac9f2d1f505a7ec5b2a3bc8011a4118b452f8218b2598e087a145b3caf993e60d28fea530241b100ea69593d133fcd4dd595238b29b5002c044486bfbe4de3cb3524f5ea7bc28c6bbdff2f378eafe2f712531821dd6393d4ca6ecdaa8538debe9f347976874054ddf086b35654d2296f0d6bb02b53707b25c83427b47c0465e9eb90b8067f73907ec1cf796d3313c4194fcbcec471869adc1d04ce06504d0c133c026015c77bd50ec36a9226fc9eaead20cd29a9c1897c27d3f7720a7acc5d9376fd5a74f42b8051a23f2f6ec372dbc5210d73654fe66609d510f7776aad09f3fb68f1cb00f535c7a9cc75c5359ce23a8989e0c10780b0f1917e83fb65847e524a9288ded572cc0c472313e6eaea18c7a2a1c6590db4d6d9e68bcefee5a3d1bca5f764d343d073e68ed1e33a9e6e8e66ee5c6f26e2040fa842bf7038898c7b588044100416262716dfd541b228d8c120de182b7a882001ff6a67e35eda2a61d6ce47813a13127578a7f378abef708e6622ce312cab0a0468c7f94bdade3c6c726351394e27576f081f468301946a2afbd69795756c724b9982347f127445ce92f10678162e66e4a729499635cddbe3a85ec2e11ea5e9a6f5e3fa3cb3fd0962779f3bbde6ec89217a19073a68fd5dd4160713ec9fbc694082a2e4108b16ff9ed30d1ff5c8e0b862318a47828ed158422a07594ade0ed452cdd46782283b3c7c74cfa02144c0fde3fc0854bfd06372d2836811cb649210b2824ec621bd035ed0fa5ca5f294b79850f6ff2d223148121afd2c12b50bf4c217cc95e4e4b1d768949b6ded01ca002815961064926465ef433f3b8ae70ea31dc7ead29277c0dc6402334f1194b00ef33f081d9070867f6a02257646c9082c02e8470553a38ddcf15fc8d92db6cc2e13434e13c574714208e53526b76bb160749716b7ce28ec668753bf3d75f4d59544da97f0f2c5ede735e0433f6baffa41efc24f4e9818a385141ba7e91fafb0523f54a05ce2acbfd1ece7e300a1687b104cb940b7b6a93d70d2d243c24d549ed16822dd913388b6000f94f7c268b17f94164ac01d4373c6628f12bb48fda55e2523628d0041c65a46f12f3fb765de2e2703e6b0c69c1d626f82eb26477dfe9abbe37085f2cb1ab344cec81c349666651ef85aed5a5132da0e56596f87e8d9636b859fe08b0faf9d0807285e4f4c56224d5db9b517d6cee6d9c711ceb6ef131edbea2dab537989f8910189fa75b642770b419b5f0676b72b9a7a8e3f0e2468d89fb665283fa75dff0c69e3d7c7fde7d30cc3cdf9042355fd479525fcda88e52b4b36e1858bdbbb4d9ce6707cb78a15a0eac8bdcc4b3050ba2180627f71a8d949981923cf5d3faa1e5eb36b97f1b7d86c45c8b407da8dcd8508b8cbf1727c63e2f05ba4b475bafef68d1f433fbe4f4a68a7faa449261c068535129f5e51f61b34afd10f1a3c41fce896082517f2444ae8540176100595be7937b087081241979558e3d8fad1627451c86c11047bc845e70e02301ae85b4e9ca7b7c4950c66bf25512e3b72c4618a69e786919113e7462c11ba1d24a78cdcfb2045076569ceef7750199c4fd3eb426d6a18e1e593bf228e9b7655f57f391107efd13740d69df25e613cbba3c0e185b4d9774a4e547056af15567155f99d227b76d9c16ca86c9c85818047b677367e23d41b0577648ae4d4a003e2e85ae8a9cd020104fc201832b6a98bd992a4458590e5649f24c57a4ec687022ca8a4dff9b65a0756a5b0f08b5777953597a6123ed9d3cb5e83f0f851a4f09981ec11bd7d94a80994f87ed42668e44290cbfba1cff9f156832ce7099a7d41abdd68145ac2111ba541926a0873885d74f50c285caf6809e37c2586be66cd281ba42ab3fdb3dd4aecba31020cc6d623be641bdea56aa897055a1d607cc69fdad482b1057354aec2b87676dfc237a6825a7081009a6ae7d18b654c0582cdfd9cdff759f3459282437f56027bf49532d9804523391365437511f9d70c4d59c4d3afeb627d5a5338ba0ebc7ada1b2fe979e557b6877a950b9978f49eeb56a9be88eca00477dea3ff472ffeb404b16fea3d3b11f1a420b84bc6fb28504a1c42c66aa3a027ff7e53fa1b5d961f3b3e1ca2fe0e9c1840562d128944c112be93cf256b5666ed596da6e6147ab2b95b19c36dcc01c23f3085d37052b7abca8bee8ff7dda31bb3f6a818346f5eda8848e94493a55d07506c8ce35532e3c690ef6197582d9e71da05dae326d003e831c8c0dd3b6b32f1fb0ee5810e17f066a29b1d2be0a1332cd9a5488317edc7eead1526416829fdd8548c3ad6b2319a9fb65078e5ac489611797b78e001bfed9c796b98fc783f7a326b529f1ccb201c8455987060fd3b8de0902852582a3258bb7407906c96b65879f7ef03f93e79fc5ca2d101f1b00b9005fba41243cef876ec922e9ea6e4e62df602edabd86752e19ffbb514f7f2163ef3e378e3561635702d9e4888a610fd5dfef170c5504395d5ab82d93cbfce586b78227b0002da988559a1cc240e54719429fdf332870994cdb14043ec0cb2499bc0559bf5dcd9919ca2385e7aa39b806ab217b7a67ab487a7315d659f8249372e4aae11f7a14d61f2ef3d38eb87b55ad3a65218a38fba92be472da76b06846c5e5c91ff3cacd51612600789eb19a91d49d0217d847eef3560253dddf73503cae7ab2dfc86047ebd18fa4b457bf255b87fa818c76d2afb8c268121b0f78f1893f2a805e6d822902874b726a76cc678b1ac6f4aed0f347a0d223271ffeb92d55c48abe21870b603e05065b0509374e3173dfd8e598ba29d7f337dd4aa3ccdfb5bdf51cde52ba2949ef15f5da275ac313a7ecf9818fe7fdacfa8a62498481557c533e267df671f2f2c5c7fcf21a36cc42871cb9a5a886a421bc697568d5164b1d7ed6c2b057db504baa1140ca86f2c7107aa0579ebf58bd2e8b873f606876751549390a13607cb481730e757e027b3aca411cd09dcf12f47848fe7254489793d3f00c7cb3c5944051217dc78cf9404a4fad61e0353ba30b88fdb905c5e7c3552eaf594b536640ee3299656fab5d90959d4938359f8e9e4f4c159bac9d8d8a17ca98ac5c86d3ea536344ee6b4c02878ed78c6aa599f989ed4e225b2421b5f83566379f9818d3c0beb4df97ee279ef3e2b2496a777493c3d7b32ba22fc04f900f2e5a897d65d44dc5b79076dd23247856e55eeec498dafc2ad29d1168af139fd674d6ffda6a4d96e38009ce2124098b770d57eb201365388ed2db570e0424b482408063ee774a507230e8a3b7e6e03112432f7a2b1a816172a17348eefde9de6bc56260ee269ff54ef29bd48ab7582de80d7470a1445b8b64a13bdea76cca7b26e4a99dc19e533a826a445afb81b27305562bdf39c73ef5665d9458b3d2378fb79c63b08d4c5c6d3df22b5ff0d4b8719eda345964511f6dcab826751a9036590298d28b79d6677422e59ea48b28243496b43c4abb25253ac76f7682b9513f4703f24c487fe0941dc9d874fb9129f9cef2cbbfd47a7537d45a2555f71924d4eec4741ef9e6a4527e461cb6b05ef71b7f0884037b054e942014db797b2dcf8f856a98e55c07cccdb6b134cfb5ac8cbd462fbffa0024b9a13d0bc8e84af2b10915474f9f42942b7bbcde1f8b6902621d2fe9b653bdbb6745ba0855ff14117844ce7633868f854a1cc8f9502486c5318215f0c04d8363d6b0927b48d0f165b481f8c51c9503926a9b0faade34979b0857d5d069e69d6202c778dff9382e8f3994a3a94d909aaef04d62309375456885517fd3dc3e8b401379321380e93ef6bb0a261ba55080e7134502b1fe809b3a153eafc916c6714f05da746ee45cc079e2918f6dc69c607f418f4999edf1cd739d37c35c23b083cc393d7639df8d24a86c8e257f2a2e6453173413c4b03aa3395f8eb09f8384760624b5d7df24f3f0ae41320c53bf561b2deef49ebf7ffe3371baa1c63adddf3d71305e23d160a5050127178f1621307767684a651ad24bef6030f1cf7aafddd3531d8ad0757ababfd1e286f7472f376a1d1b80e46a88a6d70857934b5722449c344ca5915b9905566827b90ad3598e60d4c65bb7144fc6d9e690e73cda8d24aa6f4ffed5128df52c7d9e47040d658362877f44bc7fa33770af016a8d91797f0dd6c9f78d43bb8d9822ddb5bfe74a109d2783e73b3bcfb1ec233042828785933c30274d50111aec18716b85e38ab58ce57b9cbe04d19ebf01b71c2b465cf281f8274abc3a9f18ebcec1ff716cc4d05fbe3a5814e7b7b8c4799061dfc1bf2771ab31ebdba0a3e1069afe3e1ef78f9ac852788f3b03779b3ab478d840c2dff357041213c47142cebaeef148f0c14adc433b80277788866ab01adc4d9b4f6777fccd460a6fdb68f575f430397fe2c7ae4a6369ea49e7374b54b57cb1773192550c00baa0b8f31d73abbb25ca12582d0d3b48802826c7eb8b4c77a92bae6b1be28e4cd681b6f42f94c3ef896df8ec286a7776b86e02a7cdd228cb36cedc52d297f301c52f3dd478e0e4b5120430b68b3af91a998f7846c48baf29280edb56b04789d3fc5290a27130eb65298ca55f7065c778af9bde9bc006ee198c631ba4d9bfdfa370f20c357674551582dc1eb84bbc68c4b8956353c7972a1a2c9f47c45d94f70d3de1e2fe441eb952b12a9a5d74caed5608cb89d3328a65d5411272f34aa93ebd9b1268c986924cd6e14634f8befc3a80e33ca79a55eee74354a899d862e3df19dbfeb892f9a1b29cf78dc8e0eb5551da6db92681fc75e697bde7bf695d1e108b410248be59f29600282059f507616c82737ccafa9eacc05f050c0f35434d2108e0df68a2a327703291fb02c3223633b0910588983fe98102bbe9bc2a3d9d8e0a669b2564b0f2084c639f1f12179ede5e3849babee23a854ca9f134547b4ccd41ea28ae4e443b7876edc6ade83ce2784d51c53f20f33caee6c8f3a98265b57dd73a315191719c5f80ff542380ddb55ca7728a0a1bfb1287e8292a0a1b5a6c69de7bd757fb6947b4babe5358c1068125e35b984c849339fa2829e2f576a99f720d40a304952d9834e362636c2ed42b8387014b3be70fe98563f24111ce390bbce2eaea20d0b8724c75c0fcc7e57b372acb1d0622fa8eb581b0c0736cb38cd99fdeecadd45e2223a5ddb0fd73feebfbb9056d84852e920db295087a6f14d97dd0affe830f48eced8e3daf81414a4bee5145b93cf3e68597ef9b26552ee1f7a82cac62d4febbe644501c0fc62a82d4ad39d56db5b026f12e07b5087f486be1582ef3c3e30865da09e39132a6b50a3b8f2c789dca9344075b5d1771bd2c9f224afeadbfb77573f6c5c6b2684d5fd3e9373f9d428f904e2be61caae6563092180c7cb870edf6a72f5cbe6d16a4d6e66218c81a07f915627f74d1b47a4719c4e83ecc73894d1a36a621a61191d2faf5317df844c3ccc97149d31f5a45194afebcd0725f805a42b334353813b89af9f66cf40f527ffcb8c8a4fc0bcf2a2344898d566ee694181002a4fe871141721053667426eddf48c4c87356c6d02f525c230c8decb7aee21c042bec534621ecf8da1a10dfd3681a46bdb243600a0bc02944f07a733470b606a538554bb21fafb7a43ae4751c204af4518450250e7a104b8239ec7eb5105bac85ea8131851db329805cb6e3778e919caa82e6aede3a1e9da7656aac754daeb9dbb251e14072ee8c27b30207932983c0668833ab0023ebbbea45b6ed842a73187167725c65af1ced2b9d3d7a897c968c99c93553a664c81a415a1b2c2d1c650a69ba2df61cabcb2511c61485925c7987c98272a35dd1766d57b3e4bff04c10bcbf542e3c73b72aacf0334ed31a565190aec717a75065c6e97156ea2bf5e7894697ae610a20fdcf4ca7bf0024f38191371000b74ab5515b315885672176af1f7582cf3afbf10b8ceb37f72f74b6e5e80569086f36aad961af1b7c88a9f6f0dda453fe2207c6286f558b97efa698aa52513f1d74bc00296865d625ca3351db69493f4e1a7043301c5b457d721354f1dbe5f06ee2aba19342e62c7a6eca9ed46f9f5e722eef3482d97ae079bad6dd409ee4c0ae0e848c490cca56b55b93e735704575d3e503e59e34da9a49c3fe1c73096609511a8324cd06d8aa5ac8f86dda0ce288336f2e7c1b53ec85f002ac25e90369b54c086e6345410bae3a92d7134185b941266fd18970fbebea8c3b2151f0393585cdae237c7a554b197e382d452f8dec245aadbec8c236c3f79e7167db6165fd24c63fb73a148bde9493beb5e5aa97b16ad5a12aeb7b6f6004b8bbad78c63c9c8754dda4daa8edd13b4a0c3a678281161dafb27156f100539b422d3b3390923eb92dc0c9eee094862e3c85d251f1b79d524bd6cc97132779a6785cbe501a8fb8abef174f039a208c66b674a4f3b52a4aab5eb3701ce4ae8d3d2161979e9b684f5b4417af2890adfd6026934a6b9cebc780464629774b42b0288dfb1026cc9f779bf20f6e8f20f4b119679aafad17f7ac0178197e3054cf819a0870f79da30f76344e6e2f60cda23418a662d207f7e6a6b3cfbe947c1d148cfddffc29e52d9b1be77f547ea533bcb0c6ae0531a5dbd7c8d0280cd8be68d201cb1979b58f10690fa5ee152d14407d5e0c7bc6b03afb676e0d92ab83706bd48cba92188fec8ef49e5d0991f1ca0b0e76debefbce91f3e2b3a8cd65837f35d7157faa5cc8ddd8d1e9ddda98635686e3e0a740a702644cb06872b27f4ba65d152b5515ab93fa1b03f0289ec65be7f6fc125c86f2c8886a3b4e1ffb6d3d405604edb104f5309fd8d06cd8c06da8777e276cf80aafb0048738c76c82e0504904964319be88faf527920788f763efb723ce343bf7a2aa37ab3f75fe34c39453aff0f3731d1efde596f68a0709eb664cf8f45d9238749f8e2c1ac79256c0a18ca3f1d4ab81a33ae51e3ca527f9d1c4c3745edf0e5ab3f6bbb5166efe3dd3b4a5059e1adb3a7332a007121e71a00c75cdb7e7da5a8b4ca9a37c499bf92405bcc4cf691bccb13d06c98cbe021aa66281b67e8b86e28c9a5b7d00617cf9c18f08530fb4ff64fc232945802bba3cfb1b015cddd2783b516fba2462f314d4b661069665cf480b6cf8f85feef8a4580ca3f113a0f4b0449fab818b21237ac64983c71650d87537729ae4c086d4b527e477510416f5b3bc870d7d6f0a38a679a8567e2fd0adfc5f5bcb55f0db2b3f54b4c735ebdfa3b41c3bc7f7d1a48d5fee79b8ae210a5f91679f4f2601e3619cfc6e642c5d89bed34fd5b9e4ec42f5cf67179bae1a4da442acc6833e1a5d9410af214af40d128582405636e387dfa8d8afe78112a8efc11aff78c96b9e6be14f418a8013a2d0eeda3dfbe8b4104953d8248d0dc90c383a3d1e57f8d83f753a9c2ffdd7b9fc91dff800a90422fdec224d55b824b62f72ddbd5fc5ef4467a3e00dbaccbb33fe011cadc827a43e96e1c86b63e04b13bcaad66d0ee10006689bdefcfddf85f5d8481e0d36b6b8ef0e500f0bbd068be78165a8240d1b68281b52d89da6a54ca0fb46c6a7cb197fd60ddfd4d2fcd90b517ff2f5959a46496a1c9e5adce78a9893c65f573fe34a6651da9a30c2c3c85018c117689c18eab0d09e64cad7236d97705f40c4aab9ae9538c3f22d61af404dfb3dc7c4e5dfff52b1f746f97362598a4c80779a25f669c018011998409cb04264743e8ecb51777dce5c46521b1f53b1dddcf07188f2887f73efd157b60d29bb54974cdfdb393cfbd4b120134350e3d8636db7bf3bdd4d2312634c85f49b9bfe7717df11fb4298e527f1af0eb4031f98c57dd328369528ce2df2a2b2986675dfb548a2264010b5fcf0bc9d05dee9be10a6ffea740c6c46a71d18eb6460466280ae5f2fca6f2a669adc4b504de8f213ea9d7c7a9a65e253c0f5ca7adaf92e5ce611efc2428bafe7da81a87630cda01cf1cf024448f028237463abe2f916574ed324f589bb5ad028927d4609017116b8ea30f9aee01566c2abddce02b908d51840e5cc5efa0b04408d12cd3362b86d3417790fd5b146a7e47cfa4a3eb3599f889c97c5cf5e03f65ca509d901ba8813bfa0b68814fb72f7b3f3073b11ceae9e7e136085841058892b4620878491c7d15de76a84b709844091e864ec2c07e8caea49ae0baa36edfde32ecf386bef1d4fbda8410f24fffead8de9912bdd1f1cfa5ac2d3569d1c14a29f7a1b38be6fcc831658f072c5fc64daeab48b8188c2632bec4005e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
