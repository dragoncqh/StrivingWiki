<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cd6e7f824e366f096c75bc659a75e19d4876bc455c3f93148641de7e5b77bf955b97bb2e3643260cb1741430c7446959c3713be25277033b648fae066ccb13969dde64d50cbabe3cbe4f9ca5ecd49149eaf8a0c595f4d263113f58e57eba5a321e21a05d0893b76fa13fb92df861312cb8ce069e393ce9e8a6891b9cdf5a48d3bbe7df9fc7cb1a5badd5dc5488fcd6e4f8f1e4c8ed5667850e38f9241ffcb3a6bda7e56d19f835461a9109f9371f1f56b8820bc05290213fa0a3b18c3357929439ed1c398d24905b98eabb99c52f6e3d1d2634f02439a9e803d4f804982e7d365e4c91f86b87d01d4eee63166f1c21fddf8b84779a14d052583c4aec6534473fc099d564142be16035a7ddbeaeaaa52c53699992e8158bea65fbfc2f6abcc34b54253da845d3bfcff5e334444c90c4fc65e7f9d5ccec383d6efef7efef5f0df4160349701f63363589c6e43cf6ad6ab4433e87d8969c06b3b7c5dfafec20261e85a896336aa17d0b68c6824c2582ce8d473a87f742b49215963059f763b56fd5ad369ed52c9abff37d751cab2227e3b9b9c33160e3b9b2c5190608841ed0bb207f4c80fca097c4847bb80f9f366ab18573e0c3c06a323bf6b38edccbb7def8b70ce7816ee9555c12a210c05e7a0b68437dde6e86bb9163ea1f5fa251d276062ad14ade2804e35b2c1368bd423c6dbc7c08427f77f188e631d9344cfbc359857a084522f394f755e16d66afe1edf6d4e96963bbbd2459f279c62b7113899367dd4b581bf2b45f5cf0ef2643d9aabfef2e9f8ed4aebc574f0caf682f25549c8987591416c60b6c8a8618ab15c044d2300ee72d8aaf45459eed4d961507c00d5e2b54de7e7c54b9756cfe342f4094e1d5ff4773f9ece75cc4138954628f2e50936f0d043725296fae8d56bb6769626f65fce9f45468fc1a390554d4fbb7462ae94e092bcacbe4fd8e22b08e5dc0c4ff88b672925727e5127dc65515426ae2816e9eb12bd038fe6637d70f763f87571766bcfd6291fd268977014e28e26aab2dccc482bb17bcb391aadb27e6291f292be4d6532d813200baaf5eac82387b7c386887661f6a28cfb04c0dd93eb3da63637712890fe2c10c7655563440ad3e3682e7a50193b9ef61208d8602fd236d0d27f49f47b4939b98113341ca29c8ec8d65fda9b909d25295e5ccca85b75d9489803ec7af3d17b5709e09ad001a446031c0e8f57b1b1b678207fa6b06b0f3497a573fb49abf0dc64a441adf49bf97a725ea6ff8158d52314bef94f84d38059ef6203f8bb8c530ec6706aad28412645882b59192c9d629291f55dc0437e7bbf1d6b31574f3bdfa6325225e5049a48a79f5b3359f9fcdce0e3144569fe3234c7d402b000c911d6ae9e6e85aebf4874eb66260d0b61de1c2292cfaf7b8b9d64f2cbd69a939c157583631ade5c7ccde516375185c3360d7009bb9a1e8ba1809ca0160f71cf41f3837dcd1be26a9b6b025ab54a103c856756b55c9fb9db0f3179d84652ed21dd73be1de6508aaf01c05dfac621a9ffe7524c55a8196253f92e7d9121f4e160017f75ad2c877f48caaf49b77b2f6cbcd16c98d6a4567ae090d854771fce1afa5cc41306bfad8f461388fd7873bd82755b259da2a4132adef02348c3a27fa9b7aa8cde72d880c10dff7fcd962e72f06b75908971c012d9a0d506d4baf718011f77fbc03cc83cff2b61a8f390c369506f2e9276a8dc3062300d1e0ae732930bd6281b4940fc6eb514e7b013327e3a5016b4a14dcc4d95e1a48150ac4ecb702a727a43b9dc13b9f9397b4c269af1ead3d3de11426d68be0113199262591ef9c1416443054fbe7d623ee28ba6b6e6a2b89daf25c5990b5d89f6f39832bb5815a5f9c2ba8ff9fb71797d5bf4273035b32d58a3b97525a5e613f901cd8a862024a8dfb93943673cecd3be3fc0b61893b56670b41bacabc56eca3d0896eca4357caae7d1df199eec533d282591802ec17bb2720b508729ba3795aca8c9de7ed71e23258652957702da2363ed8cbcc62b336ffa20b1a83d221aa8d8a976cc79463ceb1bb9518ec930ccfb12a5e46dc62f721e7f253c48dc08f5d3967f9d5145abbaaf38d8ec8d91cb73adfecf1c0a17e08067d282135fb35025ecf81b86e715c10284a6c3e80327e7bfbb0e4564d36724de51d6af16ae0874b15e2e97d4b3a73ad55e0ed2065569753e728b10a46c0d49d84c7506e784ee7b0530942b5ed77ca1d75c9eb1f61cae18a0a8d231d54664027b9f669a99df7f4fdae517c8e31f25842204ca07d8fafa4abc0109f1750df2222acb08119907e1d2c49d8d3ee526a005243c3cb1da72affecc9872217a872e4ef19ca5d73113e7f6e6c9113193710d417432857964b7b74ebf11afc3081cf8cdf8044f76bce09d05f722c8d604eab215c007cd8ad2c072c2f07162c38d216976bb956e3d5a3aa1c987583135b2877249d8c7ade3a56a6412ac5143bf03e5b312ee757430216f6d3ac94cec54416e25ece755cf31c6f2cfa22e54d06f6a70577e262322f315b24bf0c5bb80eee07b595f313c50bc46e7d46c5dedca24810707839f6a74cedbf57c29908ed823eb70404d0796a5f635df206107e40f90654e0fd696a6fb1beeedd5626a5880109704093f3ab79095b0865795ecdd0b6066c4c9c4318ec9a6f448eaee77a639765b703a35f908ef4edf142fb27fba37ddb507b435e9ba4ff0b90f19f74b3da2465074acbc37d80cbb1eccb2f3f0ffb2fdf1d344dafcaf795a477208916c63af604a8d9db5134bc5d94e63bef855c85376540bbc60fd94a7ab6ac6de9c3c35d7e1484eb3308d4a12bdb557562ee36f262f80f5b6fe0aafe01df8a30475600c17f9c040491785d11b83d7436e3dfb7942f0a5d0754f5f6eca54bf536313d11cbad63870f6410c5982811db0586851e4820ff457e49f08ae596be35ff10fce2292137846751a147f8699157d067c6637fff8174a2b9dcaf8a5fa748a9dd337f931c1ab0384f9ecd53c479f1893ff2425542de1da6bd7dab91db8712c10e718a05a0228769d10fd649212a5975d396f0288ba9907632355345e9cdc4ba55edc09082ec527baab2bb01778b09c88ea4c27eb5eb4aaeedcfe6b3f46438d901983f525d2b2f5ee28f475505f6c7a79e5e273ba67d0bae34d60bd1b6ed58f841da199833f0d59ceee7c82a067c7be25915822306c3693dfd94733cf54b4e4e23a455ea60b4d81619e3b5d5861960c5ce750b25d270fd6dc53c721abb8f9a1c0df7f844e34513270f28dcfac5a8a94466502a71e7dc10ef5ce5fc2ad291a86cce646ec937f5eef92338935dcc0d9c2ccf06b17b5f91134aa25874bd332dca8b01b45870978f4f43dc0a11336924622907fa61bf58168986855668c215fe7c5214523d405e9e8182b83e7092459992f041c39cfed667cbae6b7c11e3f2907d57a9f15933b3634daec84e8830f3c480115e6fd9276b21af0a3fd0276d9e893e924c5564bff672ae0d32ccf9ede8313a6e1c56647cbd9b3bf88a096235bb94b2ad4ea2a0026b40390d4c2d3dd61d7829a3dc0d86f0069c5cdf8d95b1430f44932f91c00e6b3e25cb85273db1c90d616c015126daf880eb2824356afb3db16d1d966fe5c354559fdebe2765169b2b615abd0bd8925a9070d53730ce7a51f1606c4b43c6495db004f8b31bc2ae319059867d0fdaf454440be198b46b8897987f6ebc660f282c66d6284980ee5c30874ff911ac28fa5470d6194f97a5f66d8ff4331ba3ef2ad847ff02e070e44c7ccb53c1af62c27749039491473996eb05e624e94f5e497852c8382a9e6f10a589301d2f4f3bdbc2fda2acb00d4d0ab5f1c0c7b567cf1b006a48d21aac0dfe32a6c9a1e835f257279e88e9b2550ef60a2fed8e1bfe93e69c704c282e77796bcf063f5676981ff939267652e402a27d5c2d6d3e0726d1acc8e6b961d9d14f3790affc30dcd8300803b56d1f8914c48a597bdb7eb14678cfe09d48fbea0e7f23a003b663ce97aaee83a9e8d25ab3f63707d430afd89ff2a6e0dc58e382adda99522420c172ee50feb83310d768e9a7a2c5152532178bd3537a6d701e651e87b723058de1aeb4213c6bf9b96c83f20d30ef1d75150684215673bcda257eb4ca2d37e5d813b3335bf2fd32cc46397e64f32ae5407516394458b720a148b35ccc35c38c3e1d104a1c09883b9d8c481236eaccdf1d58bf0168267d321add715cfe524d2252f260aee969c128e34124e7b5971dc26e4030f11eecb9b76255e29ad12928aaa24efcb3657a1069f2fc35411c8fbee8d153bacdc7721f76dd7850cc59e6eb4fec1218b0a71bb48ce4f23873c276bd9457b691a747d24e0b1f8e287f0deae3363ae13785de84607b2c28a2822cad3f0561171b99c644f9c7d7d892531605a64726ac9b4938f12a2f593cd00a866c219b8cfcade2839dd16424bfe00e5ce4655965986b485e3622f27cfcbb728f587b22620cc12050c3a6dc46c3247b9dcfb4ac13b3128996a6ad1df96351cbdaf0a6dc82456841a5df8f51736d05b9dae0da2ac29d916282841aa9002b8276bec2c4345c942319090f3aab0502fb80c28a89b4bc75d3b6d2d5877c6a9e2f15fb7bc827db7181fa5930982a77e10e35dabd62208e353a6bed4d5e663a3efc44ea875d33d2bb01c2a7499e8d00b19deb68dec689440ba5aa716ca5a75c71a6661717b82596a5366de55551e4d4c3807fdd99be6f67ad783b67186c0a52adde819513dc50fcf474166592e22707a09f7e7fa935a3effcc7e5b001b4897eee6fb6bbb0ef45f78766d500e31c32722fd3fd25decf9818cfddfac9f5689bb440e400e6ef9c961c2d5d53250d5cc8fe0f1f45cdf5a863d06afc79aae75e3cfa844de10cb4150346c0371d2ae26c202f5a9009a5978f1ccac8710c4f105765bd4d439d9357f14b8bbce8a6bc3f99abc277003c6cafbdab21fdd3b79bc5dcc28391962a0bc168b0c41c5511547ef7b499d28237b661bd238548373d24062956562132b5a0780c4c9b9d3f5716e5d204f155415e0103b00a2a4e7fd17c11b1cea5691097ae677a95f309d7182d8df0830b6e66168aa70d1a0575448e5fe7d6f937e0320e4ca704759c5de37eb9110d07d99bb1fd61c9c836a75a6a2631b2fd2f6b6cce91a6952db8f66723b8deee984c438cd4c46cf99f414a82b995992a8fe2fa74bbed3a94b5ae31cfa4f2c1b40434a3f4d790ea13a5707b6b7a851925d1a2b83b6594cc683b949cbab541b1a9f780b03cbaa7e2f914c50a7e67c2411e8a384f476d023845f4770f21be29224cb4c0cf29a3b1f69b258ff981fbd4f8b8a403183b138e79bf7a853c5f17143a58f6598346dfa02a48b6b1422305937e90ef6db9e288cd860c26edabc1ba24db0e0c5373df25c3ed971030cb34a954221cd9f4ccdfa3b22f94b6634937e7528220bf9ee7b1fad5208d0ea1d0e21131dee39b77563487ab6fbb5e8c1bfb497353704b76b9215d74e13256b2a3c172e88214bac1bbd699fdfa2dbd3fca6ffa5ea55ee21c139a60ff9e7b0fb410f14df34189f4316e02b10ebe8e71c4780b572877006319938ce833579c116a541df4925c46bca4c6a36710feea901529ab2f3e001fed4543f9b0c13cb230855e7791ce39489f1394d237a098a0fb333daab43f8fb8e50d5881b1ecfe3a8dc2428a1e93a549e965f172f8254877bf0ccc9f4cc5e3f78f7720e12b58e2eeba4a65523d2887b8a9acd2a9430933f6b18b86d3809831bd84dfbdb6bd39c25563e5ab1725b6490bfffe151b22d3a898dc3a533f694e085c1c30b369ab1c19d082bbcad40317d845ba8e37f7904b5d42cfdb8b6df3dd071efe1d1e54f0d1556a73ba18b17f8b7e995ead0518f4ad7a62adc7a3666758a5732ec31d6b68ecde455e90799cc5f2a2bc81dac9c85e5bfc8dfa8b45cd22494925b08e2744f0eb6e827ee16f87a3dfc749ad40280bc2855c11eb02b3bc650ccf492cbc8517fd5f542c6b9e589226ff3d849a1b869ba28875fc3819b1af77fe3363f1fad54c3f40d309c0902c2542c62b36ca4e5b41506287ab9b49aaa8e1316d49747e253a32a64fc2d3d76040026f8e756437175aaa0c8e7ac522812abb96bf67838afa02e5f6d84af1e5a28b6509cd9463ac9f33166161cf8d0eb5e5ef842785dd1e386fce2285a2831956b7bede1bf11030842f6ab735f32e8a11c2cbf6ef62ea947f1b3e6c86ca7678f0312bcdad0a185042c8a7baff7d3fd3b4fd6e8f9a6b0a082a4709a939189b0bea986a886be614f450f30bf1210d4e27e485a6088d40c39fb9551e24f580461cc4df4dc5f55f3a040e636fe1007e964e9fb0ed829733b907bc0f6f3dd00ac01d4e32d23c36d682a6cf8f58437422de3eec1666d12ef10694c09052e48e36fa6d4704a3180fb681e74a19f36903f72b3563f4bbe6864d3932f97a732b471e445afc4686358aba980fcc41c2d7c160f184c925d00977a3d093c2970b26e70193651222baeb93eb5420bcd3f3341ff3950bc42d9117932878626cc6104e991ae3904b8d20389d366e518eeeccd13a843e6d02281b406d580009420495c54e40c3ffa7208bca3d865cebf4ee38bc81c75437a7d08619492643b2b533b3fa146e18345fb66fe665d4142758fac2c8973594dede17ecea972e168942a78c1fb4c2e0b1767b11d5cf9d2c7beb45b1cd73c845e204ddceb8617df38cb452f052f27b663d2cac32e7969c5c2470000fc9ded7709755aee7259627be9732137a7f264933862dfd1dbcae2ef36b66120c244ce63ee2e2793d8b53ef0592edfa0927d67964155bec99fe29f494e9413e0be73883dfb86817f418233ac9017afd980bccd5ba091ea923c460f3c428dde48ab9f6c470beb94c1eab2fb5fd0c47d418a394a531b064cb52f51919fa77d4281522628e6ce933d81a2cd90758127615bae6eed7f871f6386d98e069becfe829eb1f47e963d41c3f3cee8e1f1457540a643c0e877752618966d4cff43999cb628cfe21619e9a8041e7dd15f40fd77b3ac31a7c1177fccb3083150b5daf98f493003f08f79a680b9a5965752bd9f558541a1a5aac2c0d60a60e3e679e7a301450e1d07fec2204c464451e1d99380561ef53622b4afe31cb9599c1c0bc8e9df067c425be4a19ae6896a5343deacd96898f6d71f261165f0e057d7b32e002afda21a0f195a5317cef4e8768feb6f3f524951b1d476ccf67f13b8162427e8cfcb7ce9d2e1a7cbd44fbd04c9b80a4b0b1477311d1191ac142f2d9eea60c28a8a792a2a2d0cf429cbedb6421da12c0d88d383d1e8399d6a3d2bf8021e5b45ed96ef4b9ffddab4719ddfd054ccc58b958cb3d0ffac102b1d93eb940b5f6b4597453e612c05beddf179b1f498ec70a6f3bf8d2c3932b8e4182962190ad4525889a0526cf0a64f9871f1b148017ffe951b90728dc520b3b4184a2219a474f305d137fe28e6a32073e08c6577124ed5d9a9c181ea2d3df56eda0632fe007e5697ca0cae329b0eb4729c31d9269f82c0397e1fd724511e9695f462b1e37643331a2583727a3e54eb479504ede42c6b8734928cf65efe6048e4ce00c389944aa94e5c31a8ba11781a370a678ca621418386598b5eb2d316b9c6cdbef0c85a8669fdb4cf193c636853dcda6bb2ebda54768668c66a453ce5d35127260eeb01fce2fa06c38fd4e50e425c279a5bc6c10c309efdf625dc91d709984758e1dba2a9dfa0a08901110bbd54521b99a671195408c0f03bfff2ea2b86566c6f1450cc103b110eb6c77a7e9cd5d097137e43fabe6158ee027b9af9e6c4b97c2d115dbd1230c8b27c9162ac0533dc447dfc85d3d15405e2569c64a5ec79c9052c2f2d2b0b1ac0d30bbc56536c5f74a469cb03306fe34d3500c5ef6f52d53238691ac7446441da999f897c2eb28ccb058354bcfba468fe07a59471f28d4b36bb296512bcfb3fb9300c7ea6524d06f48344bb22b453f16c113d3b2476e9eb4003709502d2642609fc800e688497ab457db22bdb59c3a7723da6ae0106a64d3563fb947b44234585f57bf93c744fca0ad0b5300dd1d36a5e7a80a94f0834219e28b522c434c54a1202329433d69b089f1bc97b1c609f2a4ac2cd7b2816397d6a12decb71ffebf91c44a44077c5babbcad5a36cc80964be599145331d6c16e48717abba6d057c7dab356da6ed93add827faf30ee1f235e0118219cdba1f76388cddccc8f1e5e70e2b5b11e3f4225bdf776c18686aeecd2af0cfc3da22362c7926dfac0deb72a52e7e6facbdf84ad776efd5a616a75e6198095336720e13ba7ff2d9b98c553be48f25e54007f4b6a5bc9e671dd5d09d997d5f95e16e25a778d133db3945fc561856a8333ba424b145037a3a15e71ad7460455ef930d0788762b66a80cef87a0093f50a19f4222e43d65e033922bf4a476e8ed4223a6baddb2cdd0392e1862bb2191b0f76655189881103c34ca1a4e76deb0931b6f1d1612566325e160685f45a351fb164b3d22df18746df505f121cb0a042618d14465051902baea04a2f7e5e13633a75d8d5be5f35c033721bd8559c878c73d7e12f9d24f052fcf74dbb6b215783b00d7ca0189801e1490b700337323c5babddd7c7c0477601780432378c7a20d16d177547db3b3c889808425f3de9491f07804efbc842afb8ee5e9c68f7022188507138685660f735f6ebaa43c1398f565efd73e83cac23e844c00f4347c58c4d15a1477660cebfc90d33ca81e088fcf29c22ee675cdb093c11eaa61405017a4f5ffb00e94421e68c97e1cd3d9f9ff478beb66811e24990a102b727cd996ffdde87b6f6d62e3458d44364a5eb34f1110d5cb37644fe6ecc4be5a39c1f17db6e1622c20fab57b3d0a47c8e75b674bc2b9949df81cf89da9524c1885d76f06c511e0845359212afddba35d77064ede18acf559c8c1c178230496794c26495ba2ba09273e6e024129b1257803251f2d4a6b3ad7f53f8000e856cbcc40c8ad1c6fb660d4ff47dafa5e79cb3d0ff101d4855370179166770f1f52f65fa2d1181ef7a2034425cd9641816b6a134f711acc0212006f4ef68ae8c39142da203a41d9b5411ea64601e5ef865dd457dfb544deaf5218d9f361123029079ea20e7916e399573901118529c2993df481a86d70b6cbc7d03c2232946517160d9ae46402c413d9eb3fd309a0773dafc9b199e21fa3f2e61b671d24c37e5ade2b7b1d61aded7be987e398cbedc053fdfe034e15ec93e67249b0e85c63604ccbd900fd92bb4f9883459909dd51de2b8c60b130aa0b9f74fd9dfb35daa026ad68ee7eec053c26543f94364ca457ce39692a06a95ac9d50d300bf7d9d0073d19b1fcb78025a0636f0775ff72a3c37b9abfffae4d93051374047a5a060ff803e52290e5b6ad32793b57df69fb23095876c2fea0f6ca065f4c869ab9b7600ea0a3104b6be9ac3c4209db781e89f179a369a99d21e43aa9e9c619d074512a2843c973ff83a3598df3911dd6b42ce87d986184076c1c1940ad1223854bf39a6c78f17eee7e63e6fe22220ef63548725814bf790db9db80ddeb43c2150fdba34059534b05b46bb3cd2d7145510e8cf0ef2907b35cfece54efddd7057ec2e958f7859c7d026755e32b0837724f0585bd6c893f8362ec987db9b28b860a9be23b94c9e4ff1ede6df5f67b20823cde85167d4f448415ff814c439bb937d5e7cbba50edefb3a34cee056e7e6ef11f9e558df405ad0bc2acd0c9eddec2879406643b68eb38b0b9df64de0fcf4b8fdea3a7f349c2b8b9b1f31b324122ee6f1fd76eee9b4f913083f788132b8cdcfe699fe11187c13e8c1594e4a77a31c49d8f7a655ba76a383a4bd8e97159176a578037f841560ad3a6b59abe52748be4def5889a561a098ca1674010c0fc90668cc79b18c90167f081059f39fd3ce1b8df9a71de7bdadecc293c8d14e7b8b7ffe5544ba3e14b71dbc0525043f2b2920a0610376ceecffe9b3faf1b7ab52537a2cb874b7c60d7ece75721a286ac142765193656253c71ff50b26dc3bb794b911f80358497f0d7f43f15451c313d94ed2813e90e8124a5beaf715860c3901e311763dd6a33a06401f8e9ad6ee02970401d723480e5213459a6b2c5ebb912ec24a1a8c9ed847e38e2449e491b174f44ed6b344ae2fda96284fa229b432c7c5cdb2ffdeb91c4dcbc9cabf045b5171191262f4a61fc64326e278fb16529e828f79b22e2e4ff8408da533ee229b07e099b06bde172347d060b7c967e96d0439e82c7a9b43d56c544ceda5e640d5e2f4e0c907970b0223b132f2ed6431a57ed0b74862d578bff15c8aa1d389f95211e8c8f66a95fd65e672c8be6be3830dc9742f50b7ec5574d6d297cc87253acbd243b8071847a54c654f70f5b4f03b73846fcc71a355b9410b27eeb0a32d915430cfb304e73c86265db61e569ad78e04c69a7ac06d405ff2c8fca0b586cdfb41a6e08f5d1a1be4ae8530adda9f4d3faf46d72a724a8c04ed93ca534d3d9e526a56ac060d89548f88883bac48a1d1fb487a9842842ddcf481ac165673405230222fcfe90e1c84c7cfbdda597d97cbfa1b3393dc0ed26b6a42b0b601d98b15bd76f2642f149f9f2b569a68eb251603cf52f8bff9062c01772a8c628fc475a3c6aaf4cb35960da741ad92a0d3edea2babc369181cd8203e90630e52e7ab145f19cc8985fded9c0197b8d552db28bb8fda23cb009d788443ad73188a96208f91a36f8c158439bcb46aa4bd223db62f347a2fc64381dcb27a209e1fe57833ce23893b096e543fdf613f4e5c0b2653ab43b093705f53231ee5d006bcb5252b1b954fea63da979108b1bd54a10b42304c1f1041240ae94d2f4c17c8f86750b25abf55d03c9003ea5b3ab2463f99e4a7487714bc218772acf8424fd3222f4a8000090c3a344c11d2392119e441b7795ebb1e2470d35c367054c1f9114ee0f5d2265259f4705aaeab593fc87e0316a4c4875917130058e67d7123d8268ab2676eae1890a17f2a484a216e22fee4e2fd956c3ff5d29fec46e4ab2ae0694dcd3b652df06b77bc3e1ec90451169aee2900b73c572fbbd5addf21c489364961100789341af282e0dc4b912eb1f656c4ea4ae38ea5845c4a16cdf63e36d8f65eec1fd361cbc2a496e523bae9c55614183507a5f6f53794bc4c073fbac0c45f40e7ce032b2508fba4e3b2a5e24e247e7738a36fd91de1e09ee880737310887c7a3e195908503d0cda172b3fcaf43273f41d74263f15af093a0359fb4a7242d59930d547e39443b0f1e5fbba189c5ee08aec6954bfcba00b2ceec7d9d53c3e6d087961bf30e4e806879f33384e5139f92f4a3f88b5da1c10429411cd19e0487e8d0630d94afce4b9d637cfbbde8a912a1d123b244994db2a5d3834f1a4e0552c64f007e54be50d2f9c1519ca1d802106fb2ade4570d19e2ee58c6a98aaea65b2ae18639574ed82cfe43599487af564f3546c7f0a78d52196dcb7f48592614113877ac42cb7f6e3e2b9ac2deb47c6645f5c9f27b95e27b46da6332e26498ed5ce704be402c8efb9d55d7422e888f03c71261ade68ebb8200d61dc26cae4c8fa624fe794e1e2b3bdfd5bde341efa3a1aabe8538a997e9e526b685bd7464d3a8ab32056ea2d7846abaa00eb87f43ea09364136753ccce7a93a6e45363ccc20080a0257a39c9bd7acfb5cf4324213a733e7dbb9743ccd50d0a1328a46dbe3aa495fdb3e4e156139844a3669ef014a7c848e94b94e97559e5e96f4d4563a1772589f0cb50d0dcbf36a5901532b5bd562cc935a1a1c3ff2d52d4b2f0fbcaf3f25be320cf5063697cb2eb0c7f18b3c6a24db830579b2d9f9253647617dbf45aaec8e092f78474aafe728625892a52f334be8d2623e4861f4763b4bb0d7303af6651cce5bf59188f61914b532f40a3c49522e5d904b8d489654d21739b94e85df9c2da6fbf204033390d6a9eb61908dbd754be052d044a577d7101068e71ff0b0111eebdc397f3c11a545c7a1e0a86032915e031500b2b9ededa9ffefef105be9acf16d02b6d81470215b14af68abe421a1850ebf45c9c09fdb401a777050768039e4cca6449a15353752eb5deacc99a07257798ae068e99f6cce6b892b09e3aef6dc940aac54ee44c959e2e1bd3aabb008db9104d33318a6108778e77d42106e132f92b429ab49e908f4238b6cc3ab32b5e1150aff62231297c598d2681fd6461455e6fffbfb3441939f56c006d5de41d2994539a8949e9f0f6da2c89009d6da73446418a78eaf5d737816ab867ab3549fe1a93cc3a1a76cd1c400fd6482502c29eede2297266cc10e4f1162ccfc5fbb4f3029506a1ee8c36d3cbbe2ef9df1495184d40cccee2d07c96d8e2f59b8a3aed7ffd1880794a1f2ff98cc02699a59872496f7c206df3e5ccf139e2f5cdb6b9ab44007940677a2a508789accba3cd48afbc5a357487b62708f346e34891c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
