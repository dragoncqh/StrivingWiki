<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ca8a7a2a22c183bf656644410db39f5500b53301998aee04817315921fd4145bb10f9b380fa4216442ecd44f4ab325921a090f572a4c056407f1fa846935c9ee042f3d1705117df0aa71842e32d1944f7145ff8cd3a8473fabb16a79073d992d040dcc067cd04b5152ff2df3ac047eca5d93e74ebdc401ef2a22aa1e9903bbbb991b04e2a892ba66cc515c52fd0372c76a83f5d6a25e513268a8ac6a18be641a273e0efc40e1a58361549a744b97a43e1c7333299b208218d0b2442ec27d0c4d85779c999dec92ad2f589d17fe85a0130e47f23f447f8e7bafc54ce94d60385897d6d442df448240fec70fa2d2be3ebc9e8f0863921139b24b0fcd64aa5f634a76058e95a1a019bfdfd5f6aacfde9c6bfd67c0b8124bd0f57cb28e93b7468fcd65eb58067cd59bc544a4ce1412f6002e658977a08f849311be78f6524b8d4d19ac5054957a6c7451dcc88f843e7ba85cfadfe6da52e2fb5313dd97ecc1f02c9bb0de59386bc409b34a5e89a9e67f4317b4cddc31d7ef7f54997370de69d6502582552b8b068fba31165e24fea525828c2f8ade2615bfa268f087f759a7bc64b51770c3818fb6641c305ff31a882577a63919de87d6db390e00161b68ebc3b727f69b2b71fd98fb01c0260eac98dc845dc6d3dbb205e76884045a7dc34d02bb3f89218fc2a9f2b889ec2fa379aaf681e11c43e7e45b456b29ba57203f0047d3511619af6966e692b27b48a393d9bf8224e9ea1d67a00d740a58020eaddf194f794e3b7175ff16037d1617a4ddf79e3ebf3348da4f144dc8f527f16a4e9b964a868f83c251b3bc4ae4e4dd381f76c047a94772b9b26b9c0485dc7472ed103879239f5f021b33b1959885191ae93b65a2b4fab229086edacdd2118e24de1211ee14e50314baa096c65ccecc4094a10fe2cd4f13e9ca5daeae2cb8c26a296f40e4f2132be46272b1c5efdb91465d2628312cf40efc6b00ac0ad26a87e8d5f6106a44c84df039a68b115074268a04d8d7ad9871a54f8f8af0cb31aeb43ffa6f6b89399fe8680d1b719ab8325e78703920c5fd76b0f2cfa6740774c8d52803fd2c87b7a283399937e01c7806c3e0806c594bbfa1f24d7cd168464e35c015be6d2fa86a6edd98aee4adfd505a739b9d50059ebb6dde0fc0fb06e68530cff34795078a83774f281b7523df46084909ed463dd9b15e58d68a90e0b50bd29f50d3d7ff4af9484aba8f228b4614fcd6ac693069e02e53e9260b6c57e259b43d170d39a0c6d077100560cda25d2ec5dfb4ed95b9a99f56446c30ad3802e8eeca562815be1aca2259d1c44aaffbdbd97840021a26b85757a8de99179dadfc713328319e878ce3f314f9b3aa4bf2044e67c2f691ec77933e872deb79a833ee307cda8f48f3fed4ff0bf0285bdb92135672a1d787304e1661b82207444ad53f28b87a6515de00655f2d9c5779f9fb515f0b85c926253a21691e5ed132f02d657a3edd394d0df1eb60a6995972f60519b6445bb0ce6b166871d72b09980c11aefaebf10f863750c1e4c3cad5279045a80c60873894ca130178e798e507a8512b4c14ef975377422a888f19308f044358d897713f369b8996b5e95d38e4056ca011d95947216fdcb18eda8d578e0ff7b7211679b508e5c506226ce8d4b7993b43055c0d219688d48d22077648b9e19b7cca034e40f597d2fe84bd50eb6c9d021564a3c3308722b8dfeeac03d0bc1ff474815dc762da63838eb1ef50ccc509c6cd789a80f79471f9abb185432ac3648056af094ae895e2c8964769411cbc8b677247eee8f2a502d8e887a81434df88b25ce3949dddbd141b295a71638c5af336a347be31a12e73c2e7819c2fb8a37646376b8edea98fc6e71b7cbabb529c50188bd16c8e21cb0ef69c7e9a55d73aba9da8bbc1397a71ede0b06d111055c2d1149bef53614c7a82f1dc344399a7e8b0a3ea23cfaf68ef358ff79765cebebc559496384dfb666d55a5ff9991cd827c9f8e1dcf3ce55067356e8f001aea2705a9bc8d34a5f54c3cbf4d5d50c6c775d8fdb703dee56142869d1447ee6f5509795d3a667c277940feb21ee7034e23dbaa4c0d8f110e2944b9e02953e372493429007e08cd020602f680afc7dc5deb90d8ea5fa05b4264e4c971496153b241517f9225d1103eaa2e81baa23d6ac02649491fc533de894a5e6e374f7b6c2ff05e29c0f7b55bca24f0c923135045be065d2bdcc1ef7495f32392f5bd5bd6f390803bb9de828a84817ad3c58c46d9741121c4bf2a685065d4fa1cfb7b60261e4e55d263821c698bad1c4746f31332ef57626bab99e64d2fd1ea7c416b0f9c9cf42f88ee432c89ccd0dd85881dce3a282f2d963c6f3c651c899010cdc2c215c0588d2804c1629ac8e956b17555e231446bb5cbf7b9e9e65f1945686b0d24d14d608bec8189342ab6adb3e85906205dffef6cbe0796c29cbd962bb275d3e5f3e7cc2f987e4d6c995856489cd3e73774a5984b2b2a7ff260b7ba97d66ebe8c54b5c7f3a428ee07b9cc6362db7ba6670f1bf45589388d0021cfcaaa4c32b3d01d5c7dc9dff4094c4cd0983385d09bbb9bdbfdfe714cb738eb4dc81e5dd32647b1ce1341044441545c7fa3e9210c71e74d4e482fa180ccd75ceea5387025a95bdd13ebff9b125c4f96c17a91bceb3dcc3d6a67945c9dde0d3ae1ae1a5abcf9fd66774229f3a826d2d42de7e7f296d0cf26bc8e800e249a5a5c497e73aaab4fa1f654fae3b87de4918ceb87fb6bc32ae460b1e207e9d7b1397338e016505f618e76eaaa28e55407edcac30cee57cbdb50ccf1eae181ef360058d1499c30c5aa8a347904628fb6ec2cb6832c802469b56972f8d1d0fc3d6c6b4384be9e7dca74df94515e74927031e0e7bea2c9c9c13ee00180ef8a4dee2e9f0e2cd7e121240c96b14cf1881ac899b7ee2be2c90cb1dc30c3813267930a16906f229bbd07e80b2bf83ec2a63d62e86e5ac1d040d0f016d17ac83b73b7ad8a9b83ea31e1a79060bad13571beead7035d836bd19dbdef95d9b34ee50e8d172cc12e25e1551fbf8e1df61bca691ceee0841ba8dc38148a08274aea7e8e8daf63553175ce9ecadbec976dd14d6ab340d395f7109651e8f5d7e37718a7967067313b8c01472a2630d8882143203dda146c205d511f107cb8e87d78742439f414253f0a362c74941d076c470891234277207aa33640d330dfd17c71014f566fdfe4b4edd1c4eb100c577b3c1b8252749698ff9d82af5f274769d463c8a3db8956535cae066f1cdb3872bbf63c823c9f2c5b5f7a2525973f3b1cc3bbe5be9f788dcbbb67ee0bb4596d542bb1255a20e20526b3514692db10805ac92d9ce232096bec9916dab14d8996ebe38281c8d9d80216ef78d36f1fdb853bd64b6376b8de10f3e8e833b7d76f4e58f86192ba1673077beaba174a4ad55ece1b0588697ae5e05db6a042ef04ab020974b61c284000ba8caf360d91d74d47cafa0e815bf2eb12a2d4bb142f2a3ae0cf0812ead19d10bcddb8a4b15e99e8ef08ed10cb46f2cb1f9857dbb16e9594ef7dcc2dd61898420763fc623f09e0a94cd771af9edbac826d4325c8a6ab825a9ada7fa7ae0154dc98c7ec55714a994bdc1dc0baab0f2af0d225bc20070245a0704e4da7b8b43661d3833aff2b55142b17f9bffb4a689a1f26993939cb9db9828bf3dac80fe0cdffed221ad50e6cf3ed4730690dff16d71e94fb3aee801ce874486c8ad81978e3b5992f1dda682b2b612ac29263c88c9a0b88012edb5dd725377552a73a05959296f3e7bae40b4c8501f260560519d5d2e89bd7f24956a8ea461e8e4edd3c17455b7196de75bbeb54e16e1a11608175d02c6bffad917ef3593ebca2e5ba427678089239bfadcbc086f470e5fe88bca5a706970fef3ff41841f8ddf6f7f73f98311579a3617331ae64e09ebc72d28453e6eaf54dadc04d187bdee4ed8eca6e036c0c72cae35ab70722dc55daf5861a9b0be475258f6255404c2388e19e2cb035cf9af9a0680e8ffa5256432c433707744167c363f5e41be7e68cc562e10fd3e911dff94bc323179631583fd1ef35a62e2bd7f4aa6a3e7b1883b42de63ee5e491b0592b22bdcc4726aa47d9b26a875889b93e235cb32ad7efebaee4a24eeaabd53750edf1a7d6aa0fc47fcde507b6ed2e2982a1b6ca56ef82d2fa683d1bc415024a0a85da36a2dd32b3be3f7fad624cd426c12c1e9771d166d94a9e105f0d9d40e070509e7b27b5d70cf8b080fd0054768e748b321060c368233dacea70edc3f838df1c8ccf9cc43d9ec9f3bd7884659f891f839656712bcbe6158bcae438770f4fba67f8bfb7da9cf9556e4a1a7305677105e7b35ba604cbde97f09bd6e39d9a822f209c76b2791c9768b961755b1125869d5baad24db5330aed08ca491451eca7d8c8e687fb1bda9606e2d023cc6abf9b218424c1dcd440d4eb967da403909d74298417a26e4a5c5d2100579aca5a7ae56ef5bcfc0eb0f458ce66fbb72869fe2262ebe9f3d9b723f59866c7176d239e09c8305ce0a072792f1e11e56d33a42795ba49fba0c5b8de71bd17aca03c5764fd35c9196114312ea393def4feaef9daff47fc42e22014a8cd46bd2b2a86b45cb4272967617a74939d50d73540834283eb57ff0f80b6e7388344c06db92a95b1115abfe344e54a161dde9e6574be05ee0a9031d4305aa3bfb236d0b077ad51a1bcc38cc24b7cbe251f932d11bc9d1dc7cd9a7a045f8c44dd0ecfdb8fa33f760080a4aaf7edd0658cca31ab6b1afb600984a46f86ca596727b1fe5b81220fbea02f492e5f3a0f3ae06d66ab906a4bab1bd6dc743c2ca636a656d0c3e65563fbf7cbe787ec41915643d3b8f53f368a9c9f097398767d12d7c3f281cdb85407e4fe7776b5d9e335c124814ffcefba65f9bf6193707d1dedee8cd9592bfe67a4e1df9714c895fc699074933c0af2587eea5a5a4e0818b7b311d44589f0c4764f73ab001b6d88b8bbacc6b9fde8437e283039a4f6844ea453d3b27015e00960e9b8d1fa2e289cba6e352032f3669859d416f4510f3c9f426032345325a85523362c34e8d2943c152987a0b878634a830df49397a8161121345ddd4077adde1fff098192dfae1dd68a694981c0ec4eed9de9e9e879e4e2cd4176a04ca94d4b61a96257bf4bcceaf86032531d1689cab99196bca7f57766d7c231a01219b6dabb7e458ff31ba1a13672aafbe3229c817555ab27ef9cc564993cb6055635bc747277c54e6f0244878d79c3e3e9222929f64a346ec52a574d7f584eabd186f3af381abfc1681a794fa96e66d10f00e95ce7d0a0f2d429c5ae9b204f021d3e4335aa2851d41c066648c19eb76df4a1c991c3109f6cf597b2aee93180b1bf45783972498cce0a10d5591051ad8c0cd71b7c858d6edaa149a13fb09ad8ea2c8da3fbd573c06a24020e96c889bf53fe20833b419784316ccf3c31ce785dde9687d4f1508c44ce609140f5ae5cfae282fea88476db955f23d0c1866eca6916bf1710615abbccf4c31191f775f5c4a8d8725ea591cae6302539d71e29bbe753ec88e8b6bc0469d29689b1cd860e5958da2ac586d9e52c38e13949e155b0f36a0d70989ed565cb8a02766e6fd27f2b1cc85b341a4d0cb82b766ea3f2542040c99443d874ddc411ead79efb1441fee8aaad9eb8b91109fa0bcdcaf4543c1d102eb17c847421e9898812911796897007307d6c499c294934cf9cdf5d0f056152e4270f6f453f0185aabdb2a4a1bdfd46ae475318d14fdd71e6660b12ae0c71830f9694da9968c7eb031377121bc67ef0e790fcdb1991c69ced2b5caee4cd77026a9e7fc0e722d6aae29cc9cab6d01d76bf55f69c635da947759bf46c8c2e5e3b389fe96de6165317cd5413fb73171291768bdce94033e72a5682ce062df9bcb271e59b55dd3a30587eea03954286c551bcd2db0a50435352fe9199e93b66a80c8028688134f1cd28a07d864aa7e95c14671b670f1d372da7f531a43eab0a9a44d7d919835213b4935d7e7ddd38b03508be01f2ebbc5300772bf596b46229f3d64609a57d445b3508a4a41be15ed28683d685c40f8ad3a93227f6c2b51bfa806c12786f5b2beb1484712401b07dcf38106da3aa829356630138295bebf2b638f1c9a6215baf07022e7f7b46f3d0791a22f1139e5cee3084e1befbbcb7e6da13d6a1df7118cb5cdcd8f4eb64b53d8034a67bb5e1c19771db389fd0413a3cf357ad1fbf4e271b9c7f1b9c727071c0c60e83beee337e953be135b3880fc58228bcc0dde902502c184834628c37e2232592a229191abbb01449a2c153518d2b768c67d5e74eda2819ac10c32e61005dc5b38d80925c0b7b3e85554bd86b69acd3c8feccbdf6101a1ae6c4efba733139f4496702ae95229b4ff795bbcca5b23c81e38bcd7f78d5807403ee0bfbc24b47819e70ef203904f6cee9a6cf0d60ecc445cb51ac0a1aa1b56f59d9feebb1221c3fc06e8aa276c3a5765df57c56cdae5fe03b7a8f8135d557dab1859d3efb799e7dfc8902767d349fec742d0a6e6106cd7f145381328e8772c218c26a01b8d485c24346830896b440d5716f2aabdd6741fd2b45b41f58cdd750e96d19096d6713e37bd34128383644da9faa431b6fc0e7908ae2083add1ffa91cf9dbd0f5efb64cc4e68ce07bfc4081c9efae34cbfd0d6466646e7aa4c407d13130a57879819b9cf7e4027d5dd6354af509faf0b5bb50f6df90ce60f5ad22c5688c3b4929aad5c586fc24fa3d297656ecb81251696394b8a75be760417191599ef5583dfb3cac497383c9cc9ba09100f5271f7e0b6ffe0af4991c07c0ad0bf55eeec3794f8e0f964bed0af144c3b2de74a96073d6f22a4d4614107f16a7f08b81996b95d624a231eb01085132e6c9d060aa237f63c47185eade089199a0ad24e939ea3c43e64b33f32a58fbd148141c625afb022df084ec52b6146ef5e4c4c786fe3b67e80dc4ba03bc04bd3c29fe8b4aff0b05937d2d2b072d461bd51175fce8d018ff23173359a519aa3d29dba016103307a998469a7957ccf8cf046dd1c4cd46e6b0550fc09ac046bebc30032812ded2ceb2722ddc403813171dcd101e187fa5b228fb79ad0085183d78c0b4462dd069e3f272b9077c998785dce451690bf1b09b63191c575340ea6e9354443382ff56960458155308337f7afbf6698a3b5f6421f611f4590aebf948eb555bac6ca2508483d4c95e79c4022a7bb6d42f640dcdf2c01b7c9b68ba61b9ea108f12acb33e480678e26b6a863e4bb336f858e554270ee296de7c84821f4a55f69a9afc248df29d733ef5b4da57e69dd7db435b25d62089a333ae44d39a143edb8387421f0c79de0c634c7022f0183b59f12cef2ba1dbed1c9bd97ace27e3031276362c7d06544f7a5866af5696a39afa2c5310a750e2e591d81d080a8190b635f51479dcb7c4f9becbd9d60b86a2b8e721ab1849d37afc4e4e71dc3d2f1d3e04d2c994abf33f107ff6ae1ec348b271109ccdebf86a16fadff6b7cde87147433939aadcdab88d555ca70611d8ff04efb65cdc6c780e7383ecfbab02228974caad4f3fa78b0a8af93699791446a1a44f5d87eae7132c59217684cb6730fb3b89344f55c61c732a5a22175e117ce4383b55a7351cafca26fb912d29ebe582c9754e91a3010094025598f82a37c80a1b8346d8d442a4eeec828913fddb9493cbdcd7409e4c5281593774a65b856cbb327ac6dab8fdeb8feac21c16ad7db21bb8ba1ce0eec459025d68c01fd639f78e7523aed18a046cec193449f71473607a7edeb1b6430926e65005f66ccf7880fb3504673b2f8143e6c627a757204b22b984cba24d27e6719f3986ca692c52c415034390e27e3c88148dd0f9181ee0725b9e2a57b70d52f719b7114b74c3c90244a900189ac364e4f2df4863513e18e7f413bbd048e86431690977f898c287b25caeed4f1587d59ae3f2e2e44f3f0e50df5a0f9b3414384cf6e0e340d498ff2d4ab566f93b621e0d911d68d551c272b29ab78a47499b0c6129106dc64aa4e12200a011ad0635b34bb8ebb06e0b82508e234b78c4e58266323d32994aec9c8a7f6a69cd697dc4d4d67919bd5d2e388835e073d3b508c5059c997fe6a6486ce533c8a8404ca81a770d8f14dc555cabfd1665ad5792a8afc8b84359d58a85abcbf2762122f363765b3ae6ff09d2c8ff8b466cc1b14d9312c66754cacf12d1256c952740defd47878140b61f2d67384c3c94d054bcd5dd98558a8ae4a25e6fa0548f024609c2dc0a90cf27ca1f02cb6678026f9a4d27484e1a300914268edab761eee0b12672a6affeaceea672ca2689eb36e93134a4ee8599ab2fea386e8bb944211b0ae8fcb274f370fc02d34e1b61206fb646784cf528e971fd9c271d28132416cb47bce2df6f3eb5d9fcc403c3e83408485ff6481dac71ab6463257202a70cc5dfb73f948b101d15154c4c0eb906b124a19f6032dc9b4a3ba4399535ea509e8ba10e4e5f55ec15575fe7c565f4473603d8858f4b81be0873f1bbe66298733618e5e6106438e82c93c3df3a7c78c2d2a9cd662d79c257c6f158b77f15154f4d97022a169dca8f62fcba52df6098f31e7f5d3bafe17f97b90ba4e5968626f4ee6d8d8b7214f2f73ed40a1dd54aa8c48ce6bf182087c2f85fa5c655303a40cd13930406d55209f2c76e78a6559e8258f05ebdca1ccc46f22d866fd5876fc1132ffeea7d941d7c392ef955ae062695ec58cd214428c4bf1692ad3865ca4682089b373d22e7cab37880594be7d64327ab6f1a831689272a02bbda58f29acc682e15d8c65ef785ea79afcc7e532b0a4302ed152f34576e8d27b4d1e5f67d76fae0f3c1490e48b2d57cb19ea4570c1cb472d9500181b9fee53cbf08cdb8aa8bf1dccafc7607c400f41a8f3a3910ad3e9f357891c03734c4426f5d86df8ba619a08faa93eddbb7d55862f7c687119ddd2b76a688acbc14acaf259fb7588689dd84d6686ae4aa3cd5114e346b51dacf2e7c6626820aa4d111215e1e311925bdf731cf4cf8ff06c9682f8ee7bfcf650c8cf189a6232486d4f31dcff46a1dea161ed06185d00209b2221af07d5484ec62ef7791fd8b93334025cf35f2af7de84e410c152c9d23130f5638bcc7f46e3218c7319530efad9fa955d27571672fd992c5ca81f793e34be099f21eb1e42cd53af58a71f83d825c9359d472b3213b8f494d54863a0853824c52c0dfe221743407d9a6f164690b283995a4bdacef2aa3078e84d47566b85d9479a89d4dce68994f7527e910ec28cbe49becfdf9d8b9802654709badd250de1a631f248f3a3d8c9aa05d46e2ce2b2539d249af1ab2f1e07ccbe639cb7cacd6f06be8121c3e3517173f31e094bf2efc407e1a0ea7a7b9e07be4d3d9eef1bc007d93dcab54d10b0b453eaf053b22f02f3ba106e576b7c87d795cb562b930779a64facd1589c6d41935fd4f6a276024f167932154eb0dffa84312b0509988995869fe10336166c18536a40015bb2077bb51ab1e6d0879f159b9825cfdcb6688fb0d936636332bfebb3cc6a271a6396c81d500865bdc582cac443f302bf9a1b81d86e69947dda48b6e0f4c3b184024bd2d0dc3419da1c43e62db1a34a11598f5c86c8355de55a0cbcfe57d401552346b6774926a02eb33431da2285b9f821be553ab4b60471ad6cd6c115bed54e16244a46a852781046df8a5a9d32b1568dd868d41bcf781f33cf461e1d4253a1d23ac8259d64e2b255d43896d8f7e4856f2d90b78df70113ed1ec7469d6aae98ad81fd33a74bc813a88cd6b0a7a59f0c6f0f5fe36db8549e8c537977c39fc76eb17cf6bb803c5a0f3622a78eea55acd80d1d5811dc9b99b6702f956e3f96601a84c4ce5ba9328ecb0f47787e90c3832550a84831cf17623100476eb64b530dfc05890c19926480df5b46aaaf4e9497fe7df4fff081b74ccf7640cb75155e95ef3e64e32f874fe8f871e0d1c32f5eeb8f79d4f79acc6f47c979310790a5810f4f98e1f5751bb15db3c3a80b8a56055b097157771a05101320bc6d523a949542e2401244375c20cb16e18344a372cd49862c85f970b338346eaefd830bfd2c2916f6533a5f1e66319fd1f7ebe4eb4802b810eb17dd7d996ee8183a8d811a2564da951d127d8a2fe24095ab0b649b5297339da5a1d0b85a1d55ad8ddc130c50de14ce88253a8c11ef6b0e78d6c17a5baf01121cafed7eab666358846719586adcde7d9f242591e551f51910f9a5a551d57368ad8fa10f79f25b0eabd058795a281b677b2d301c0751699b59e81ab4fcd409b2229a2283adc65addcdee5c7a8dd0535b1bf42304316019714f298b4ef6a6b7f6efbb898262f8996a141a48ca6dc4f2dceaf3891f24a753d7d0e628af8dd94a01a40c749e3efb20ffab6549bd660f398ce2352a89f47ca90a55ed4aa9cd4dfe832f0a4e2cb38d1be2cfaf1d5a400e4cb93a71b8a93903b164baf757a8d738d651938da28ef3f7e845068775145a08830fb9882643889e933b87a6b56951f8b480720cceac1d4601abc0b5e8145cc32546babac1cccaad404e3fdb6aaa994666f1a2a01606470688a2087857eeb1d2506a6c7cda8eb7c978903165f34e43388cb3291749fa7828fef86d480c9a05b59e631b1ad0ba83a38db9e3acf90204d7f1c2289fc981f214c3f702a24a3143030d9788ba9bdd0c6b3808eb548eea6338bf185aa9920ddcabaff85fc58132e77953867f733956126421297f12e00d5d82b8e3255cf69c42ec84171103b9cc30532c2f6dd9052c693d3c9e7901e0ea9806395fa32af0451d4dc43485f8ffab6bb359dea105c37c7d0a6c40fc3447539e3f51c2908ffab01102a7cd8854477d2737bbf6b6e31cc7891ed6ed3f9a058e2e574c132c723218589bb6cd59b0729403ff76585c03d181f23aa8657fcde2c5ecda9ba6bd1e599c67ff973b15524e317219aacaa8c6800e12f12ccafd0b23f6a3be6159b47e7e1743b38373ac824296ee5ff8b213a7c8a31f3850ce24a155d6498d54626f7afaeb958e29d78433a2f2fdbcd21eb9e2ed74d9b5e03623c8d253a2522ebe198314f3ce70290e3e5a7487e849e0cb91cbff21dedb4350a032c26badb31f05d704e662893d0da2488f61cbaaac318eb949bae5fab270e7f6a0460c3025754989841b21dc7cd17c7d13a42e276d4949e1784f09655c225106d0b899fa0728dee18ac5a30f28fff3d04ab29923ebc8d60bed1ca346fe7259948eda44a5a42aa9b23681d69fdf803216fa0676d9b1f53052530763d8272cc76a190f09b8003bff229f5a4d332da76459cd4fb99a2a109f23cecc1944b64db263bf76e267d3feaaa55c419cbe92978c817dcfac30f88fa2036bb9646f23296dada2c6637d8ede896d7c0ee2c8fee81ed34133584f71bc3cacba7df6a6c977a6c9ab161303c0073ddc213293b6d3e932e7e7ac64caac7d2deab148eafe0bcdd3e5145114ea6182a1594ab9f2e01f35c72e5c4bad9d6e269b7651d5bd95335b343c743bb29d7566ab593612b42f6ecdbf8cd4980372c9e2c058e820d49caca7c87c2a60669fabf4983e8a98e6b980e68ed122dcc7348c17f5488a0e1be84f87bfa9aac912e226b21d9d553aea17725372dc224a8abe89fa8c23ad9f6751adf275ea5f67541624250e138b550ef4c7d133ed3c985150d1c2faa0d360d8475b87b23ce1e023736a0bacc9a135f1bea914abb5d0575669b5db0b71126e87d432003e34c0f62848e49ff3ff018374ceb3c16e36467c367767004b907a37c490f3a7ae11a7ff76e13c220812bcd9d9715922348d7dd9eab721bc8a51d10c1b4ba8b1b34fcd5c87a3279615145e196cba53a078e3edc78ff4218523377695c9fafa36dabbd35ecaf9ee65fbda068386c50bf0c1b9c1892613759e31f2203fa5c84d7d7e5622a8e2b3e4eef6af5f535fbc41ac12ea52b2b4f0617aea68e740dffb8e5c5874186117615fda75f1b18a5a506642375464751368fed261be9a85cac3b25236dc20960027d132022679a0fbb593f07d68cf386fca07ce25d39084041926ba96d33a1ef7b24313363aa45faf97706695ad40416e9e00bc7c5aad344f3c1d9f125348d61507ee8e328c1a338eacfd43236109ca96cade88f3dd9572fd32f3cb72ae7f4f63bdcda462190cc9826dcc6fba498df2aa1ef8e027f6eca086723e95546037dd658a69082099529b5edf52438281b760f548dbc5a7586a249b47879328ed19b3b4a6da795f43064dd9163b819a8d18450e5d0474d711eeb0c3687998b4749445e674b5a5439c15fdac6b0f13121ea9007dbea28aeddc66610d6c9be9c8e62a10c80493da891daf92fde537795a7ef341c7063ccf194b04cbb093fc07cd224d80bc918f624c39a23a0a6e8a9ba4973fda689b31ffbcf175d791092f43bf20684187ae1a9ccae88cdcbd75126ef8627c30e573049740a7397ac336bed81b1fb8d1268e3abd28bd7438987a01be0fc45fd466b250230a2fd3be8319bf296352b7970a34335b99da7afba7149603c4d55ce80401258c512012271694875d75c2c9493268e3ea464f4eaf3774ef44260b2581d4ff4cda1f5c07a8b611a54d3fb0223cf16d3228b3a9effdb67c063c26d3a4b38e5b7f053d42171a3aa080f2454e0065c20fbd3977758b6993ee37f421a61a11026cc83ab3aa26228381c7ced28764cbd35fc599aba7778262578fea5ee79ded2fda1c65a2b6f7cf59448e7b44b8830aeb0e0ac25fc2a3f64b874a27be2b1766bdab9a8903154e80224889ccefc1bc9f1f4008234e387a32296f1c38a4e6ce46cc16bc98a5f4fbbcde62f31d90b3d3b9c02b6321c8c48929b6eb139752796a92fd15940a3b2567ba9ebe92e7f7097b6411cf2c30bd552b785de3ef6b70289d6a2de5864ee9db3f931e2713d162b1d4002077948644c4b293ec4d50deda5f9cb43b621557ce7327f76b6136e48a48bda4957993f468a47e0928c01ee5b959001069ffb36df12b7b28ce3123cb4e0b0e21a5c2fc88003ada08c710447baf7b779901cd3a6ae5ea4b5ced3c96fc43ad0c014c1241bd22f03f753b909a3eddfb217b36f3a136ca37bdbcedbb6c9280e08970d020c6800d18aaf6807c9e7b9e13f85ef9dcac0caf6734555014709b30802247f6f71b6106e827459ccae4f6ccf012b9088f61dc4c998c8f2eaa61604338941895db241ac989e0218fe68659fe4e00a60165d912564ecd882e2bd21a283e40bac38074f6602ed4b57062d1418f2aff332694150bfd9b1a383c7d643882bbe3ea490e65c468d0c1edadfd4d2bebee433c26a4543b7e49d04d3dd97a7ca8c5a0f5f6c88e2e3235454d92e663eccc1b52370d12f6f6fb36b728d7d854d522c1c4d318fb1c18d02cd99fd86a4310a6cc23453c84e92895e4fbe7274162cd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
