<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e042488c62e266b0e0ca2987ea08f61b0c16a6a73d8fa7c275e09077643e310099077d8235e9d9eec53d243dba098b08411d7e9e9753d30ec8b92beadc171ee157ebe7f2a6145ea980e47359dbde42d2a8c3ed835b897211ebde10521dad8aa4f4f8104d5b434cd561281344d44963a9ecb37241a40533a7b6ba1ab04544d2d1af7970c143cfed304b53744f66526c8fd12cd146c9c52fd726d74bfc3f48a80c54e31ba20f86a8a4e0bbf2eb5865bc805e46b1ff1316913fb320c12703fd321e88ade7a99567241e2fdb55d36db72955a29f9dd24028f5bc05ac4d8173b31e4ac829d7200c9b88508308b48098a3e7321fe14b3c7d7134dcfcbbf002fd9328447e497c78955d01dad7c639adc3471d353a0ce68b74ed9500ab4306e7a5e5ab08968d600dd2ec72ea0a51cd8b5548d4cb23906ee8686a4abe580820502427563d8f68460c04585961b172362f64f6a4b2258aea089af4d4272b7a740a567a04b54baf074b9038580598d8a062633eb204ee2edd8a2e45a13fae9da2ec812ee1ae8053edc3273cb21bb64654d8726b501faeb0918e86d05a4bbf77ea85696e12cd299e7e2bb2326cefd5b63aa1d1d623aa83001cb44279b4e6e23c08be0cbbf8bcd348a6e1740d7bd0e4f870482840200ca582281d6c7627f04655cffaac464c21ced755f7af4cfa93c62364fc08cb125f4a1b73f33e6f58db2d87bdef8969bb1419ecb4e6b1301a8e0b285e212e4d7091f6716668ebbf909ceb170d89d9da9bba790ab1310a16683f08544260ef4a39b11cdaf41e5e4da5cf1c8e5b7221657574f8e7fe3ab136c1c0f927b90fad549eaff9ef65093bb431263763515f3d1b2592bbb0bb03c0f48d28d665b64267268b34bdd0455b59c58cf43a79d73e617666243affddb52272d8a411b4d09ff12dc4b68725cc1562be23e9908d844b45623501e98beb192df69603bed458ff4570e3bada53e94ad77c5762c3e6dc6f6b766f29e6539677893f4a66f8860e426f38917fa9ae9c50c6f1a9793215397ff50eee5e7951c41222f3cc3a097778dc3368b73831885ee6f6edf90e8b99b7ddc4b73fb597a13ec3f9da5d9f33128663760b2b75a8ef38df650b17f678c0f292bf9dc91e8e1cd1f3eaf718955e196fe97d5b7c3c5cb74e3517b176af9066eb45328f7970f89f2c267dc6aee6f1eb549ad6e76acad3950acefab768d307882e3504a830bb8a39fed0b5f587f408b3480c5d13b526184dbf1a873c8493ce229c9a394d080b2005b899d81c68f97e2e685be7080cb3fe34b40c501c0a29cb9bccbf81707acd8c10abf909150df9fcbee02d7f6b6bc778861e49786ada5bf3aa564556067f0ae76033679ff80ecf84b148bcf88a4924dce35bfe46340f555fbd982be54212cb4ad644b19efdc04c53b338906062a3d28b51acf6739f56df99de2032d790c61388d22800207296752d9af6ed105003a23653f88f52b7962648b11a36284ae418bb9b6b584ce800adc1e889e3f0022a408a043fcc228780933d20c282777db863a2b6e7689ed22d30e123f2060a61c29572e89f276e4716d4f1a742b2ec4848aca60653d7a34ccf769a757a1179640bc98f9eb1df973cf13858248294d8cfd24265e9d73cb2ec913680769d316f3ded8d9ba21caf3bedd046d294aedf3a0b7a97fef449ddb74606a03ad7a5ed55b010fda7472801289d1de6c52e57cdb047e9e3820cccdd5048a712ec3112664a61560f88c19ac491658b6d4d35a2fa9728ca8249f7148c0eb78af2b77e3444cdd78f98bf789a8f9c39e4f15b6fa1812ffd9edef1dd83a05346c597d860fda660c80690d9fb350e7fc963c20e3f403164895536fed97a3a40cbe3d2eedc82e6c4f9053788eba6288f1d6f29c82fa485010584c594d9f56022f3683d0482725329d593c3f58de22ea71a5c64e57aa0ef597a8a77fedcfa85c35f0dc0c4f6c427d7897cfe2245cab5b7be9dd42226e2952e0a75c32919f76e7408a370f7d80285164be33dd70f0acb2d219aca45af7527548490a72022f3b9b37b5036d80018714c3371c5ad8c20dd51c84c44940a24d963e56d21549ed742cec6d3c2e2a1466ad1949df0a8f426aeaf9d64445ea515fc17a48bb0780a435b8e1b6d2da2c5fe68d191e38eb594d74cc4b1dcc4fa9d8e208db4843c68a930dc7d449360b7a31aa9dc9c31a2bc1ec1faa2bbfb6c04202255e60522632014eef389bb97fb9f0ef5f7511eaf17ea8ae918f6e3223ccd491d6b1ab14a10d64a372c81dcc69248dbb13a8b3cd2455279daa762f94367b3e0405f07d6dd625a6680d2cf87a4237f9f473b3601b73d49b878c5558fd6b9d4f0ceeece7f14b7b1864d7b3e9e89808a027dbf86486cf903a4fd5854ffa61ee9f764056d75b192a2c819e3818852aa8888d7770ede8997a13f5e1ef2e4baf106d62c435ed7d388d06125f106d215411749ec8288c03b835795e6e60706e4afecdf8d294849c16b14fc8d138fbe0969cd5872b993d4141b1d55a8684b803e6b9859ac5d7ae5652af6ee1949c5daeb344eb5b0e784dca88f91bd4abf2ce0b18090ca75f92f6026e27b86ec87ed877671ef9fd5941eba424a7ae0ceef96a703cb437f6d0ff7d1e1a01843beb399219c2e5727eaa952379d4934ee05fc0883d532ce8c8e95252ebde3cf90d48de0b2225b4ea6b9c7dc9f76f85e7feebe64b935a4173e3d8da6e2324a662714be513dc4e72955593a3c222f5bd30894dbea4373046cc402e2575ea12b88c2732f8596bc7117b0a606e79798c763b1a5df9c633443d187fd6813410ea2b02e66332be1dd7564a1c17a40ca1c58b5c6c5cbb1845d569ff657bc0d6bab4e6b8eddc7b1d952950742db4da48da65e90ded52fe834b4c68b6d0558666c7a65c04cdb99aa2f3dd330eddfaacebd5434f5e20cdb03d70513480a29efd81214ee4221239cc20c7892529403b0f299dd9872ccb93dafbed23fb56c2a8c079dc67c5b1b4cc8861699909bc0e461ea414cad161f6d217a88b42634c11e7f46344039ee45400614dca34b631aa2f090044bd3b3aad8384c456d827daba53dc33a94cae6e54c69b93e907fd13e50cd38e7ee9a1205e4789f3d0de22e79a3293bb7ce5b7bbe5913dc6fd1ce9546c6b6d46ee372bf4b548d2c01fcae1e1d41dc5758f9c1ce093e40b23121fd7a56cfe0aa2ee649bfe6ebfcdb04de449e89e24023004883e0f9618d35184c94beba37777cb3ede24bf5aabb5ae50ecb0cce163bccb524309ac4093e5c54f14cc05e9beeef32057f6b4d997541f779d9c5bc2e0877c25a1c7ec1b8e87e301ba6f865ac48bb46a150830cdddfa1d1b2d22af83ed2ced5a70fccb0db0e9de5bb44eed9d067b98c28a8dab1aad0d698f16ed9b57bca857bad6f7c9f82297edcaea8e8c7407491dfca44dc4dccfe1489026d7b2fedbbeeef3e76213c26e99daf1ec85461df674a5c7ef559d088844cfb04108788d22ebada73c4e71e11b0c59d436db73e0bdc644253e8f624feee63e90b7ab743d1037ecc3bcdab038bc3ceb60535245d6b86f41fbbdb96b949a35f0c7f3915b70135f2776fcfc29cc38edf1f485fa642ac445c33f635b91031018a2a60f4b53978bc97a28e0aebe2ab234d8da6ff8c8d21cc95cf20d94c413e64cb6a3e8ff4da017b902d5b69d0fcc84812bf9eb0c4b10eb17cde444950fae2fe27f03fcf6e87d0c7bae95e7c55fa530bef689f5663c87cc05c258281c5f5b4b524b66d6ed886934acfe973e03972bd710c62540d02dcef990a875b7cea4173a7a3796a5b36318852e154f6b64f3e7da640c61f83d2639365b09814b200877b9b626be9eaebdfe3383bb9ce9651ebcdfe9a11a15e8122acde84a578ce17913fb2fe8ea159bd3e75cd1c5768fddd2f9db53faf15ecd88f82bc363c3e6aae894f3c3a2e9aa3617b9ed92de2a57b0d56f6094665ee5d08a9463493b9598cc8b3f2b25d01db8e2716bfd9ab3f7304949f3584c12299a92a8985ed864165524603441104d1752218f8a9c61d35628d95a7ff93c78713632a1b5f9ca6049a6f7b54c50294d1034e15300b6bedcf71dce1190ace43d914328d522f54e6f623bce28f388e32372302074b83d657b8f833b4522a63112a36ac5ab81c8f6b1255828a6deff06080bb261741ad5a91ecca8a535ec0c03f0b36ebd73271c7977ed3b712092bc7d2c7e26d053f18465e8d464888789e0f8665aa16ac7ee7906d8d116c6c16dea9b1944fc26c865cffbf1a68be2667ab917a51ebc7f92ff818ad8330d98f97524c1e9b4a32212f0727ca9033d4a0f4eb9df1ad3ad833863c6890e23cff3d8e05f453c836400f26bac32d8c863f5549f7d30355426d5d371d3969b7be594ea834e6dd4b245115cbe6bd96b53abbb3862fb0c048d3641d0304ac2c431a9e1c650b75193095144b54e573c4a8467be18013ba1137f309ddb3ad712bb35122b20d44390683e03f327d008e9864555e7397a6577e4a22788ac82f17b6b074e0990330c71de1750df11973e34b8b947e348c472dbbdd4ac3438090de48aad183939e05bd4a7723f857e2d3139be3a3ce22b09b76e9e222b4a503c2b1525a4c27f3d631d88e630f3ad611760c7c4b5f398a2c2f94e44de6c4be72d4d2856b0acbbad070377353734f33e032916cfd1199b4920b5994eb39e446302ea50653d4d59ee5ce6163ae0d9ca3d1f2d5676fe207bd9970b44dbf83ab1c8dda927dbe3ca1fd6c594cb993fb7f502d73803c10bde18fed92461be30e7524e1e802bbad2ae20cfd87f378f2c2ca0b87469b231bbbd88fecbd8883752a2a2fa36b70e15709557a1ae37bb910f3ba9cbb486d49646e7c92541d722211f9cfb9acf82ba32f731f2dda7dec7b3eb74c5abfae029924a086f9b79df07d5bbc93b27a8994f70c2df5cdf8af1cb84331f36796168b830f19db779bf0413617b158dd81271653cd41f114f6649bef38e0d9d29eaedd862ee0fd871b5f5b998c2e613eb0f57ddc8a64675eaeb95b07aa3aaf6a55468b89181393a47f331715dea980530198521cac45ab5906f984cc90427cf6d1bd887457672f22de247749d1357d79602fde4528e9838674d4b492c22ab191fa41e4fcd093edb5a2c70da2c0734f4e1ca7451dd8b2c1ba71e5c1d859512c31e53f88318f48a2b3dd76c6d1bed746878c160ae7c625a12aaecd98ccf9633588b18dc9fa5f1d8fda47349f6598acf88304256b792ab6ed400ba9916a760723ca98eba0d8e7f1f9c93d22ca88923cdeb3837071a86a151c332e7fe4b231155cba46f2b33b6f3c38d1af640e6d4897b31df35a26bd5057cc824cbf2177d7d1f1069a416d611679f00b236349666f92dc9d9dfcdb1407d0fa422657566c18a6efe301121a4bb24ed9c99dbd41c25df9916dd35a03943a35d543f35f82c6812ad0700b12aa00a455dabd1ed84fed3668d7be9d3e17c68968fbb4625dfa82279274af8f2fad202f6f022cffe6c78907faafd8755ecaf501589eb3ccd74ebe8a3900129db6d378b912f21082f1c5137ba746c49fde8fd407ea1d77cd040796ed71c78ed457af82dd337f0f37e21073c4cbb14c5f8b8cbd3296764298ac3fd9c6cd8e4bae8a62fd720c64896bfa0d53674d9597bf7813650b491f08c6b675ec7914dfd025cf6053dc1847c8fec2dbef4522414228ffee87591293103c3f8ffc685b54b1223321e335973d323a0aecad5f07aef76822eab3ae46e5f89e94ce64aec918f9e16d2ac5617d4a62fcf23875ff5deb41fc4841b386f9e85791e778f47ec214c6f950b4a41225e1f768b0274af6691a9e7cd07b15753a4df447a12f69af41a06491013cba3adc0c573eb5b18a8c7fea662389121e4fa2ec8bfdaa87e91b4e6c2c2c2214fadf4f8ed3a5aae390b4cdc99ecb8c75ffd401ff8c5a5ce3f2eaa64effda3a5437188a738a6912775333d6046dc0b4186f9ea8951ebb77b795732bd3d9b51f428ecb2c94cc59640f3765eb8feada30a8da29502f1c68692b6ae60145a70081995846fa5854870397cc483799a8c0fb86bfe72851f6d3c2ef94cd4a8f622f088525f2cf7169fab562d62ac0fcbcbde7a5222177f09bbdab4850e6d93a5d4c1a423f72e3b797068c426ba0d86de05e315c6a039ca8cc71493d8ae2df5b2c521cd274227532894042398ae288df952f883576cb0b08ae12fe3b43af27ebe4e952028e46a56b75ebb74ddaceb9caf4ddea5dfd6ebc218b004145c16d5e99bb528ab1991deb9c57b93c17645c1bb5c00d0a444749512d18afa90f72204497edafe4812d569516a0b28cffe4a13f9764fd3723f8a254c07b8104a94629327ea6601a21c859c4c96315c38f733d6f7826f84f6a7f66dbbda358bb69aa9afac8a948ed2abafd297a756ed3a10626f14ae0e3b0051b80b41b6ccedd8f2f4f05d4551950e42587f7a5bbf4aba0560c653abe07995e23526d688cf720d12a69a271f39b23ebae860b43a057f52ee7bdff8c869d7068ffc025e88b6075e7e31ec2425454ae3ab81595276f9d7cf7c8bebad695d12c7fb4befd55ae62c1248472f5b9fc5788f0f4f1032e1b3b568eda09c1be78bad7a1df0fe984d947fe89d90a7edb396a542ff6afb8f2a53117f3b5fad34451e40ad12c6b9e4c8ce7ace6e67bce1179b2a705c67fe55940527ccef2293ee26c3a128b1af95cfe3c2faa7da4525a4a514791b018e179225e9c5f373434b5ee3ae5e6534e50ba7be68073eef082873264b76a29d863f6284f1edccef75bf67a51ec155bbb5f8a15289efafdf2ac45d87aeb1e6f7c585d25d5cda358ff1a2573e88241981b9a9eb2ebb016ec31c805db041ccfe36a1bff09c691050051e4272b0eeb7ad87a243b0b75305044498294d24bbd858c59f5e983b57320263abbbd74e7728f90c22eb0def5c26b4ad9150975291022a56dddf01b555965e31990086abb0bed5e930d0449e301f13d9b2b44543ae1d753290e12905d8920945422b414cd6d7f5fb9921da250b310ff34ff3d2a51d91c6af3425088b85221829bb5bee9a850a60c604acde3c60ca5c9d4bfa8de77f3fa1b75b37deb64a4d4cdec02bc2234b309bc811a95248b49b983fe9dd0becd2ad7552efb395c008bdabc33371ba5a50e2e777f3f724dce5cced24a014dce835235adcdab7962ac1fdf30888510ca2626b96ab6a2d889b1edf7e4046a0a457056575ed4616008c6cd044cf0fe24520640ace0b86a6745e01a2d864834d46c7aada84a9817eeb9492ea507d7362a5210e157c4480ce65af4b6c4735e8f0b2d89995785686dab43fdb950f60c9aa44c6e5b737fe3e20846ae6216105140de495ebdbf4eff7d7a870f0deea3d6daec9fffaecb4250f79da33004531d2d822e54c119a6684067a6461acfcf3c315a122d284ef37e2b0ab1a3fc26d1c031e88c2d5ca556ef9792d42232cdaf56fa3da1ed07ef30af8632ea994cc7164b2a27c79f9ad9c78c1981fd16cb6c0d58c3ae5515933eb1bb427543b05aebaa55aeb407970ba2b3cde90ef9f14adcf2418c0aff6780c4498a5e2164277039d0c59729b2e066681d485bafa3dd8c1f4e7915e7a0fcbc02da11b8ed2242c0010990fe78649f89623f0ac3e334269243c8c2425edb966c222ba93617b63a8aced931a3386dc1914e40792be08cfa80ebe8383cf0db852020d3675705023deaa586b77795de6cb5b31d76431bd11c7448e5186b97f22b8f1cc29cf1c1cc89e5ff477f321f9f60729ba825a3d1ca0c0ce87b72a565de4325f3c2b58651faed625a6354cb35080cbbc6daeb84db5f44715f66a8e5169ce85a04a442323e33cef816c559237a31c53aa00fa5052e2021693d0c2b0269032f49b85e47759b8be5aef15f718318145890144f52fe34a46eca19e130ee62e69b470822a4c3308196","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
