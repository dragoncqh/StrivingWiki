<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df263e137cba1e57e2b081cbd8ae2a45655b8ebf9ee1cfbb71af7025b232df06332b991bfb2cb2c048a06292f4832dfe48d3b27f1aa2fc931e27f380fa5badcf63b840108f8f9aeb996419b9b61ec9c43fb8bc11d5ee4c18bd78425d41e0cb897b9e65977e579dc20fcbb30743323313f8381c4488ccdb99ea4b477894385cdaa08ed52279154d3862ed8f5410ca470954f9f2ec863e23b83d4f8a9d9cc1f314cba6a29f7f606a99c29c9a7dfe2a3e9ded0b4d054e0aeb449beddeb759d011a46cece52f4bb147cdbccd95ef53a7b0c7b0193ed466b9df3552936dd571f42d6b8046426570782ee7b5daee097cd1603251cd34da5e98b54c591e959730cdeea993ed1a02d0c86e962c8f1cc0f74b09d2517410e99c4e633dd43b0670bb7b01361d97d33ae454a5141cdb1d698a81c3d562759c790f4861300277332d06f6c2231ae97e450237bd634b255a71f8cc59394bbf83aba8f03ff6c25214ed9c4bf5b9816b3daee6f86a227ae45590e0a4d07651b0194c2c6520e70d8185cb2e0fa0073bee264bb7ad7fb6b47ac4d94f7f3a8df6ba645f323cf95f209fd868d96f9a1af44bcd2352e512c01df44ddce935850d1d5725ecc214c1b6bbfba5f13d70f40db482fd27845b6087666dbaf27c7aa35641d1eec133b03ff4075f814ae4cc2b855b47d7faa3575372035f805cfdacf0d069f13ba61256fbe1c8c8f3a2adc5d223e9984bd1fcc478984f93a9c9007a0a57249ac6a57cc5d65852da940301e2d577f189702c9d712ab5207fa9aa96964ac53d123d79ab758e956e01fa330451626b14fa64d8f9860cd70ce6e40787c808eef0906aafb066aa9d3bba79e3c9c70df2d3c458791605962ad33737284d7c9e3711430672aa631f3447d84d4e4b4377034ca5a145710a9ad1f57fcfcb076b1ba89fe3ac6be20484fa4267f963986d76a68c19b6f9d907d0f47ef715303b8f4896ca9f47c329b8cc4d9edd7d5fcb2c08e039047253d464677c1f00301e20919646331381f1a479aa3f54307e5b272b731377b18b15c94290e92da57bf755d7739841a440c9824062eaf1686debb286ddc56b6c20140d38b890e5b989d6abac602dbf94a9ea40e23708117277c946682398a3febd918842c780f176133341aa21b57a60e8197d24a259647c6f1c18b5223608e0fca805b5bf1105d630beb24ff62acc8dd4f16f2e075b9c82d51e623a8cc5ed9bd699b92ff88b0c84b9b32562aa286694a25d3ca2942b511546f8c85fa187560d1220703336b6b21c376483b88e5b4ce3ddc7c982139d3cf6974cdfcd9faaa71b938d38f1f868ecb0dbe0fc4df34f9c621cfd19ec1d6ea5f4fc118824458341c381bec7c0f463311ff1540a6fb24d5346fe0d8a4503e89e1ee8259db20f5748bb2f76ed369803bd810abb43769677f5a3dbc59531ba41ba2ce08b401e468bc787d12d09becdbe1ddff307564de2fec1c93c89719665b9e26352b6ad5dcc99a2c36601456b876ffe758dcdc1bc79c90f756b01750506b5cd1c98f955a79ca2a9fddd6d5e8bed5179c50367a6e22f72e556d771b489230edc32312984445d9cb99395a8c9b393875efa1c764444488aba1aa0bf8dba1afca9329b72c2c79b0ab6d2fac4117d14f01a580b3e99e0dddcd9dfb5cd79e991abbd4cf575d8b1f18dc3ac866ecad944b1f7379c1869c2cd88f8fb01db1d3ad1dda7d6f8b4a05b2110b0af900113aee2a94dd9eb8cdd80545aa983d0abba392ee0bdd6163e7894d8e5eb4bb53fa80f0fc71d2cd4bd4836626d7c1b983b0fb011f249b90a576c8ec8199d283edaa40a7f8df07fb4ecefbff6118c015cf05c2119ab7799528d41a82cbb7565b1019c4bb2f85e8d5e209e57751745f9190a9d7a2544c07144a8ec5542728fd873c2e082b834eec5bb8f7bf6dff8c72713bb8bc4ab36e097e7905fea5459d4f455c561a846cfcf309be8bcc1f6fba8ef7a6a79bbccc48279dd797415307beeec433d41a73e1cbe87938dd6e580c20c101a94747733ecd8c874c29806f8244b3eebaff1f1f2c5a8bc8f8fa72d3092f3465e5af3c8f117c5076e4679586e089708c93929d197441fd98b5e659ccc7c51e08e2ea5021128354c10f37b8000ac613112c9438d43c8ac7f9502d3e5f654ea7466a572ba20fc8c6d8ad458b107ed354e8226ee423cd2a203b2f448aca572ad2e0e3c41b35abc2ce07f243a438918eac56a8686781b4cb8449010f46692eb4856c2de867a1df9144e708e4bfba3d409562231048f92bad50b20d8954967815dff30bf969e385c27f65c6561f05313f0827e94d011697b5017b123bdfc21ad91d9e66ace7da67bc3d03e4a154af5a3e302106d2815b4e9d189e42d97ec6302ca7da738710f91bc645137df6e75026240e4b2d80ab10f75c7bd4b2533dd72c9d45de5de5373d0df05dd17f0c34eab2ef723cd9de9bd742793ec2a43189629082982a3b40a5be1e007399f747e28ddb190fc5aaf96273d928cda713d8588daa7a3ec518bee4dd3494a6aca1d011f84b91b7a56ea4d72c3eff063d76a73ab560b800429ede4f819de2c25a7f2833f140f069d1f6ec5e66c700ae241741f08324125bca5198dc85aca59736c047b2918ea90de25d105f53e6517c1be2bf28ef5ef3649d4b18c6b48474c5add296dd681850534abea28b37bef8c4dc7bb7bfb73e95e567542028c1e4cc38a3c4f995e8e636a342deea9e5df15d3ee52121f62075510f08bfa7ab676186d95d757a80d09e155d4e90fa668e51b0997b3655c3dd75d366cf8d6b042d88d48d97f029b05a638b19b82acd946f6bad643bc2eda8c253d5b9ff6699deb08bec9016487166f775066e3c77ee8c4e14268c443f42a682e0c31780f38e957f44df30c3a51806be95726409b14a83de2c048977c340b047f39e5eb953e1cc446cc0eb5cf4a7baccd258b12a94f7e3275e8e3b7b81f21846e32c5927b1b63f3be725b906e93361122b0e8cb6b3bbe9758b41a3f6e2ceef971c8c0f5498a4842e851111528cdddccda301f3358e565dac601c8a18651893153949c62afef7a29eedd6741cec0e2605ae90cd5798ac19306d78f05f7d7aa2405ce9e68d570ad92d72aef9d792e9d7d34a067dce36474a1d13f5b0d99e8b410d4faceb83dfdaef9b2f25680d66d660ac925ebacafb51ad9beb546bee48d064fc82d8c841cca37273167ca5cfd09be22934b609668b3df923dfcf763868e3f364bd461805f8194219199a15825bf5e3cf1aea31ee459bdc511dc53d3324c84b9809b678cb91cc8c90c48f5a80e5df1e4c64f451cff4aee32341926c50d2d0ca26f4e55ed426b8ab29a1e6c95ae46d18a18ea294ea6054277b6813fdd79a9704e36197dc31e1ffb4a0f10b86446a44c2de39b3ab2490f995585fd806aa1be0c4bb65ed0b84bc02599a9acc40854678ac9018c46b3ec2249472dc9447cb47b6b3f9c3783a7671c782ffe0d9f49328efcd13287131dce432cd4e4fef022a37a0a3dbe8bd9e2272615ce085545206fb8216b43af2ef0fcf5d9f88de566058410c24d1909bd4d99d815f2fb3898dcdb3290e7019c1f12b3f19f51b18e4620900eb04d0d7de0975be6f40e793bb10f9179375d17a9e374c368d1efef6fc31e31bff90eb56ecd5aa122bb7203550731affe836d120e7c5d257af7ee8029e3d37ab8b63eba569e0de783cd9750c5ffb87b19d0287480228d42df9ece6ca9f3bfdba39ff5468eb4d73a371876dffe968c7b28927f97e5970d6cd0d6cd2ac824de377403fcd8e38a06ed941033a4b98df87d8a59d2b2113a0b676d036defa6e8e5fa4aae629d7e01840e0a53080f2ac84ee6b2b6bfa0fd637b5ec31b6227f826bddae949f69ff16483bb9f0b9bf184678c5c5e87cc792e51ef04f9e9bf03c9beec63fd8db59fa907159bb6c557d77c4d8e9ee4ce01c790c2f00854654c4c2d69f43bca09b9c29ff1c17b6d0d3a3d6a215fa906c3d335794b45cbea9ca9d2c1a74427e7f772f166079a3108ab97606756a3e20f8667c9203eb01da586b52bb875303051fd8a017dd0fbb216a7e89e1773d9ac95c56f49b4e245424dab0f426f5545df1ad735827f491b343b76b2165b6659f20ebf8b4048cf183017febccc49393c5d64ad0b9f294241805b1474137253ce67ebbf755881cdd39ff04360badfc703145ea8e43c55d46e0f5b8559bc096220381c1ee3d079afe571b320692c9fbda1f16253eaac90994a3a519e7714a3338026f3c86b00939ab88966043980c169cd283be862c719ddf4d4d09944dcca58cadeaf15cefe8d73cf44146755584951b6bcda3d3733fb5bc2f3f4e5769885ef40ce4c2f824eb1320db4c6d17e663e74f644d0dea869612288e9ab3ed34c93c43322be6034d7c90b9cc518759e8c9332f2dbee6d4f044c12dea0065f2456bac7f95b017b1ff8c53fc2e8656c2e1048399e297d8e43ed457bf1b36adfb205790f8da586acb7da9821405f05e02da086c6bae2e142a0c44119f729f0f816022367c465f513d27ab143f5503f2bf4e9a9b04de97c4ebf7e87a0dab9c2e99887a2ef81e056fc59ae91e26b0a40add34f6559eb5a2e3223e433492369a846e493a41ee029a7ad8cd5698dd8f67221a7cfd573e096bcf83da45ceaebaf05821c1329033233837d8e60c3e3873749a13270e85b95e251ef3e5461cfc869226d7c9c7190b5fea18882df3bc500ce0e80dda802d3b954b61c55c67142bcef9ab5c2ee72ab1aeb700c1eabbbf08b64956f7a03ce413e4a74a0e1738888493c2368f7df6c782467b0d8966466603f4f006999bd7784e154fb3e1f94d2385e54467ee748dfb9558da3f744ce35c3f79f349e5654486260ad86eab16cdbc2a478e4d5a9ed3b9136576553a312ae08d3b2b6f1b3d1c91638be5f965cfe108fb699bb5445d336e39699279d8da7a78cf2fe2d1bccee3838b2102929505739f72f047dc20cb521787995663859d4088e721eaf662d8f4d8b87c06bfff8d8708e0aece8698eda260e61380780f1f13630b8d324e40191c80f5b585152e5e4f7f2f0d464faa6c26ea99175874ec336cf461edec7c31b08ba9bd837bd675d837c6f45d0c2b49a32d02732f0c2b101d8f28e76529f6028e9b60242cd183f5bc20b6a131d386d6a3ef7db25ee18f954863542900d987ee547df39f0ffb7a6019a683017a5adac5b4c8c0ed7d230536d9f29bcd76738b2e4f15ff54270f2873649daf7d2f869b8560f3893bc3178ba4420879a3cd5ecfb8229190bd00e44fc21d211938d1704e1a3362061b129c2f42ace0c28e4a11ddb0e23f041bc61be50f2b7a11b703643c7e607931df917f3db038dae14b8575897c84c8cb1d86e5d4af9c0cc3c0fb20c3ef89d79bc490c317c0c7a3e08c56250d4b0d3d147100efee9c45dfcf157476630e8c85e57bfc6aa946e14e055cf9b19cc7b3464079de4e62d76a26d04c60577d411275c89fa203907efb128e23127ca34df3a6dd5fbe0bf701dde154f585408aa126f8cdae9cc86780ce5263dcc589eee88550e80b80e22a44271b7481f3335eee1cec88477f803f61e78729706497ba366bf9f828155d1eacfb92e65d98e25732b220aa78c4be21879c6f38ea02725565c03a5a2fe9a9ba7ac373c4e5ede175f7d9f75e8ef17313c727ea61ef9a0bbfc253fcc711dd191881c17fca51bba67b0b01ed583c7202298521d125ab49099e9421b5a397a1102fab0f7c17814bebd4d1cd6baef8ae4988c6544a3d2e8556ce2373673d554e7a256edc764c6732656aaaaa2609f7731ffb5810157d7527c8c4c9e6e5bfffb91583814d9ba932bd9331c0b46b6764d2569c40f278334f9b98216e3677459619b2b3303b0be49fa26ea7bd1822c64eca49ab3b8db2584401e8e49f0b1ed95b232bcb8281638127066a8cfdfadcdd93bab2c0525814b193d59ff3e54939a262008c6c33470f37ff1f85c76ca4d88ad877c5fb1267489f8f4e8e472cbac88f90622b6c22853cf6b00c98b1aee6193ce252d2741b7e042d86e07ffc079b59aa99cf81db276b0d6aebfd4664e237f8ccc6f378bb1646af2f4d3b9c9d8ffc7aba3c13e8b99a9ff9b3685e2fa8c9c4d3d185eeb1eb3665682027179fe4a4ce5ebc0a4ea5268d84fee2afc37aaf34480a6d37f2909f4b966ed2c44152466260c83b123ddfde0ca64fef849dfa17224dafdddbca8cebdb0fa9c2dbacfba85b72b0d8d419f6c30870afae0a8f8cc4ac75ba3682873df1c197ccf6e9a08df209e99509b888f8b86b8755b09f0e91f4d0abfd821b42741ff12417f8a646818a7e81bd2c877e1fd716cd186d70d23e614367d49349ff42db046f2d7aac05592d914f33d74e311005047da3fcfd9372b982c2c2f8d9c42376ec3d5dd647b57b4ca0cfbae187e564e49c5c91b23d450b7056a5d3474469f2cdf535007e8645098617ad31a11eb0f55fdcdeeb867ad29b51c0cd377d7a06944b71940f35b654e55a0f042eb4e8959faaa0a1e340958e585788d673cef93fcb80ae232f762d779e4be8d29d7f1c3e1ff5b22f046ae04c88ec2251df1015665dda1ceab6aab53ba4cb7a8aa8ab1486e73667d5bf1f3299e141ac661a7ae0473457902b7e693c277bc28efcf07d05c2d980b8b7dd917db6de8192558e2863f8a97dd0fc80d5f3f7b3d6ef0f0b64d33001a5581a9ca3b060402ca52ad0d94ab93824d7d1e6c45243254bb206f627eb500be3333a418781724e3b33a7321fda380e77aabf5a52f9100a4211e345063511ffd06e4dadd60f10d1a4c75247e7f4511fd357ca8d63112f756468f4551c45a8754171341ac5704fac93c8e5dad69a7656498102eb8036d9a551cd11e20608d07b595f9fd9cef3b3aa8e84b41bcc1a5d8ad74f2e22cfea77dfa4760b54ea4a2f106af99caa568c2b5e2c30e2e03c4619f749cfe3123c556f678b7e84310c18f3a536255ad273ec607b903f62972534b512260b69ca9baeaf2c9fbac35676c0299195a03f727daa71d0c62efc6d5e28cd3eb2181b0fb57806542b1d6baf232482fa90f7d8bfe6b143b45a1d3076a4b5b162aa47cb266561a909f429389a536e5e6c493c3ce79383e1e89eff5593d813acc4f238dcc249a46fc9174cd317c8e9fa291825cc8c4e17b7365b06274d432710d76f671d203d6f11ecf2edb959940e5362dec00ff6b5919f4bb2ddd6fc4593f997483d0964925ca793bbc338f6c14468a5eaa4aa9ecad59c178aaa4f2a420aca955c07f3cd80160694fa3cd4344e78326e8a96ed0287ce1fbf6189fc4b610d4081e779ea9256feb0a26152dbd234aefa94bbe68a9ad7eb7870b0b0e4a0236a46954c6535d607951e7f54bc394a8783e976ff193e98df6a3e7ce3e2758a1d7a74dc6574d38469e68751989d25916933f5b3b0605e95b8c056024a8596cc1c9a3734b1a03449de9242803bee0c70569dc6fb054249ae54fc9d0779f48947317fff98661ddd677f071ffa3029833d1d51b44838db06bd2baa979a73e290445d62e88495aec792a86ba66e7f99e999f3aa068f58c20341c7e36f2aa835e283a03c190c79406cba01bcf26a5573cb8519a37c02d8640f6415bd717a136afe397cd23b837854b9a12b208a70a1009a874dc92412a46dc423582b7bcb3225e6e6d8aa774aef7bc41d7305e2e7c5470cd3054893c384f7ce6d84a4fc03f3dea62eec7ad82f0670b8370f5039899cb77708bc1f81cc3a0112ded09e078494ed17f6f2fabad4cecb361792b5ed1815f6b1f1b51540933d137fa8fafe9152171531a23d68606ee4136a2fbee4562a39cdba510e5409ebbd9e4fe13200b76f6c74f4f237c40d3c4fc4fd47f3865e6f5de4ab39fb2f91a897e35431ad04fc6149c17863bd73f153c75b4fec65d0e82958c8951e9aa7273a50af5dd648073cfc4926c1b0187a1ce26877283ea1f32935c0b9f8251c66cd825cf3dd93c84d307db7b65da9df250349315f9cbf34b3d0dc32bb656dcf401f5953ca5d7ea2da8c59f732b393737d48e27a46fa8659cd23bfeebad2ec4ec5bdbfc93039859af1a8129504080ae9ef2cc645421023725e475357b7f9e093bc9bbf93f402d189c2b7c8ec04cb38eb2c56d2c74841f487cd51b3c28b31ea5e2bf28b12267aeb0acd344b4a43d858f04cb73a7c0c04300973e32cbc5e04b34ee77a053849afa517fbf23c61ec779da050ea712c91818308966b82835486c29a11149304b53237ea7fba5c10d2392ed7c2328a97db07e5d5114eef886256de818a75c50034ca0785fc9c3c0fe0f836e253f8aa3a158b26d9e52eb36924b99bb36aac062afa3a904b3fe197734a4939fe995039366d70e2cbdd6613ed194357e53f575533bdac1447b74bfe01f1ce57c1f14c981aecdf0a08428700275c5c9ee04962d12356a0e4976a8e8e82b292da9aa344f962728f42f73717215336954e04c373a8de5e0567608921e195797e1b4ddfb48de92de98134e834fb9c734115e7bf36573be24ecc345a44c3b79fcc8043dcefdaee1b206a1e61a3bd9676d6c978c2c5b5d55e15584f562d0ca59f7be76209fd98e90c3b22b350663d7e8ddb70e84b9134d8639c2da385e35c16290637c106de0a8494744fcf4a6908f501d6f9d9df430169cb6a2172324aad1db1b924a11b62c60ffcbe1012f974ee772df2a2559a53d4bc1387dd46d7bda866b770235f963ec7abce99e740d7a5a8fba85bb7416f8620d21462e97dfe3fa9f8857345b62b7defe8fb057385097f654c79abfd123e66fbc8c7fafb60679bbac19d42f2ab7037fb0cceb33de7c0cbf212ed8613be37534cdd8d0c3173f70bb3c879b521aa3c1443b4c082cad87278288102942b26d1a77f358857e210717d82ba5bdd6a235757bc7dbc0d8c7da6b63ee3ca654b393ed6e039768f9f2e55e4c0b2e746ed3ab615339f591990f8ef7282758c435a9f91eb825508c0657c3e7a2200cbfd6e5f95a1341056636d818c50776a7944600e37c9ac4852f22596a3dd28ca2967d03e66af1b52addce7ba71285c58fe2a4b43be0ea91beb96623fc88595e80905a4ec38e9eb10f8616cd5f03864c0af7ad91b2bf8f10ac33bf681512c3bbbc8fdd4ac758af03db4dcb6af0bd1fdf5b6c1c634de01c3e1eb2298d54a5852807332cb1e032c247658b3f7e74bf411a3adda8bc60c2c54d449a1ffa100c0d909b8f691cac17bb2cdd04739c9b1e52e6a0821f43e8ed4acbacfff21ebc01dc972086bbacb17645f3e8a3657038c92e545b24f08a66bdaab70e56892f4a548bc22142caa0989badfb0f3a8d43e1fe225a4aabac745733ccdc5ebdae7d2a079be60e55938904bca16478a9f23ab0f5f6b1056369761f76c72a48f337f945e2b2b3398c55fed0e652e3a32dbc18479b6daa41ef0b7435b15a54f95094dbfe630dfcdca72107eec9d70fca1895f752ef531dac07468d4c1ee4db72933a2041257ca02ebde9271a9eef88b024860fe4eb7486aefb8991729f5d72e2bc056160b52bf905954db95a73aa0369ccf6bdb08f112199b5655843f60a6c62a80d7b0726d38d2c9ddd36ddb5470f2930d55e2cb070ff164beae7ce71fa565341ea20c56ca472a314c4da7d31763efa6f267b7665ef1301c39b0e7a9bf29225f9a0b18f6479ce21909145d3672e420a37fca37ccbe4392ae31d40ea469330656b8d56368c6b9fc0a3bc39d18f23e1ccaae7df707773af22fc6e1ea85d393084d4b3443b22f6a95e0f42440cbcaf1dc19c6a8832118d8dfced8cd9164054009fd4cd94e3246916b5372cc5c7b77dabe0d0f2ebd909b425d9f8520b886f4bc5a0d1afdc4aec85aabb10a030c831d4cb7e8d188f3e0055fe386bd2845603d2da28e0363da3b990aab7b6d4d1a257f7771602e1a1ae991bcc74c6fac8f08e9ecf4743d00fc211c9739a102a4e5fa2fa968ba6971d052f173889aff59d241256671aa86ea03cea70feefd08f2701e1edfae3e03f4074bc2eded4d9a7ae5a624510f4aeb4a3dde8942c5a17c0ef60048d9c3a3d4b7726e1dfd892c43a32117d4d206f1986d48343a4ef66220eefa8abac492ca00c2c8af0469569bd5ac92a31a84d262ec59a08dbdaf59e4d03b00a0066e4ae1f949e19eb390037d17663d5d042872ffcce69a764ade3e02aa56abc6255d49bd02a679b1c41fc2031c8937a129d9faa138313edc2d508b7e1aacbe17b3de1e93a988e1c19c1201fcdb98aa260c7b8d5dca23d046d633e38d55c07d8b1eef8cf9302bf2109fd5a00b1d8d4bc7c0854864745c86d679caa3a906e324c27349a9bd2206f68f5cff97a4417682faec46633cca5de63106e58c52be011667009e8029b9439cc51558f170348c7c1a4b9fe539f6f365362d89168dd5bd72c713c90c2849aeea404410e7e85a2ead10e5226c0c1d54b96d909430d44b0870000b22a8149912dcd7c4f55ee98a39f85d811fd6560094762dea4837b03e0f60fe1a8094e1bc84b111b7caa0d2a18759ce779b5913e65516fcabb04075ade5b457bb6d70645e6292b9f95ae2d88a7dd0d0f3e308c8c5ddf48e83330479b7736a4091b2d71d2d1d2609a9aeeb01faa854d2ba3b23b3754e03a5bd22b87d76872e6946b4e3fc8569d395d78cac6ef1f3ace8014eeaa42e7730258e6375e5c18ce3f688a0c9f96135c641fdc9d4a28633c60da1b7668208cffc5212478ca14af8efe7328072a3a048c06eab84e459763eae10be7170a58e5bb366e8afe6b3cc5e57eed17e5f14be29aecd41a39a9b8a65af62fb74c8882a168238e373b7d40a7d0b919c17f628a371c7f4dae71de670db9971fef0bd808a37f8cafa86a80247e36dfe4bbf18df4701136c282b95c2af49cb167b1ae1a85f36564d3d248e25329999410076c15e27403835d48e96e9bc47ed6844a63ac184ef52dc427bd90cc2c94ab76c5d84016d234b15d26336651405a6f850e320cef3dfc7d17dde7f4b9ad588edf31e008584b49e282f098dce3cc03cd5ba0f12f5a8b10f6d28ab756509e864a6c62884e5492142d41e9f92dc049ff7c81e205666558463d385b1b6a51b3f5928efdd7b6d025c144ac1968cc699c1fac72f795526a4ce1e07e341c274ccebdf176cd1c5c19cff965b0892762dfc558c32c36264f1be6302b2d2195861be7055ede2ba46ad2e96655bafc892ce687b3f368388ce72f619612a74e804d35674db586deea58cebf98fc700003d5b099893c437cd84c8762a905c538dfece41ad688b2302d5d7bfd9267135f572830a94a35cc382c0ebff80d4e3fb3cf8f8a09734202018fce20ce486f9529e8965c7804ee7e659f5293735409a83364efb867fff097bd296af6f818a9ed07597e656badfe977f9d831f5aa613df8e91ac500879e4264b16e1ac34982868032f1132bb438b12d6983ece4e951204d23b36c102583c482f0b473e37b6e76692431c283de902b8e886c78db321e767b3ae4383207f44460502b6ccddb569501103a69d346bc15e2d3ec91d3b0477a3b36d467f848259ec0323d6f86d6b11f56cd395d63d05657d3a6b5cf913e06aa8402bf0b1345515775a6357fa07a809e8339e12218ae1b257e837e0c97ca5d57dda59e7798c5f7f63d43185d9dd325586299736a8806599166125b35cc716f960125581d0562ab0bd709fa80d8e855495d74423e980550b50d5db5f9bae0e856b6252225e5dafbaab7e790b331dc0c05b917c3c460b6bafeed8141585c8701b8437c7d4967df0a0b9125f1512b1717e4e289064e5f3cc499031115caae656c6f399ac0f4cecf3d08952f58c640114f20ef87b69f3b6718487ddbffbc6cabc7c9e360785664d81dd76a54e25a7c64a20040f5943c6a89cd81b13605788a4ef64773b361e55646c8fb978f68c5fc2650c56271efdbd579e6a589904d9334778973e78108f92ababd84a616c79720bf2d3f655b0b03706ed82fb8c5a20bcb93cf2b9d3e9476995f8d6bbeedb4d9b485894ad6819c42f3d59c89b8a89f01cf6f1875e8c91d18afeda5595dcf1e1d67eab6312fbb851c4151243a7dd81c87cd171e1a8b0315e8ad9ea68a9288c2998f31d18175f73eca39563b85af434d545a6b6125616287d8efa0c5011af59ea4e06e40f6e25616b3784e7abb3c88a5ec30bd45867bd38681bbdfd4d8a6ed2b3cff5e68b8b06b9180f79dcf634b5a826d3773153453e876e33e4b5d616cf05ff209629da562ea8ea591b0ced563453691a7e8cb5fdd2170c168de8296f55ef4885832442c3f77fdde10b0c816bd20051a1bbecf2b7fe7780822f2f3a9c7b1c65af45e38a700677ecf090d13e19102e9fb615cfd908a88a617be6538d4414f6b9bd21589458be1a5918ec63e8793d4072c01a3459d50d20aa7e56aec949b08497ce58c996a7369a9dd798f16c7797f9a5f609524e593196d799d9a181d2157324c5c73d92a9c78c776158c4f663ddfb5e63071649fc95b4077e0e652e0ce64d58e9e323ae47c69e579f5befb53a72e8d216ef63902097175cb0a0adcd66443025278d7ed889dedfb9dd488117058bb0e5d1c3f315ef3dcfb8e1232f9d17aa092aee79aae2cc8ed341f583dcc2acd8776960e06f437e70771eec7008812db59e8f80b10d08084b3b514adc17339fb95dae1e42892a2142bc6e4029fc0b621ed0c9ed0a9167f07cbc002121c655279adbd548ccaa5460f4e6043aa2c8961c0085b37d2d74ac40f441d28cf1daabbf5d52c7bcdb3ef3c19303a4602ad8b6fbc56ec2c3f6ef25bb4fc9ceff0a2863d842ec07a6a189ba8a97041652b87111c89cfdcff8620e0d3bd37d9da072f218fcd97d70759af44208314b313b73c6e199048deed34e54c113fb91a890b43da18f1d0c7c413cfa9978090b7d8e3856811b2447b97588758dc69290686e14a07e123317cb3ac5434e3ec8558980f13eca8cbf7a31248432f621e8402c18f89f695233db246cfc9b18b24e01a47dcc89b521986a036e1f1d1933a1fa3603517b35ee5909fb0b0318b651462ec4ac5d9fd78dd702825a451f624d934e2291ee7c0144afea2a5d2c4d8c86f5e3e4db792c30bfe6f032cb18227162caa9090217d11574b44a3e9f1b9f72ce3c2a421703460472db7c826e1005b842a03f051d331db317b981b7199ecc98fed73baae1208ad825ccad030a619838e5fadfc64754c0bf6251e2d211326a97e7e742aa25a337bcf628f7875b8ba3e592965a594e42a6a02847a29eda412ad0e7d671be468eb833c5afca83c235cba9c74a7045857389ebae0cedd75ce1b06fb662bf8a21c3d1932371875fc7f6478163c8e25a9dc8edb98e9f9cc0f5ac1d9fd576c92e64594f530b1837ab00d8d522e876f6a7125fe47e7ba7084dd0be66d2e57ff471163f550701bb7e8cd519eeff760753477743b70bcf35cf178c401178f9547df358f7dfa01b6551d8bd38157bcfd65849861cf593945cdc9032586d2087cf54994ac3a6a1dd23cb117b2bec62dda5eee94dc3b046138a9d0017d2e9dea92396d1b18c4c58a1d8432acc409fb8ef091884b164137e7ce49aee920259ff30d9c094080bd681cbdaaef7aff6e65d68045d3d0fb01cd4806b98f0149d777e702d7c3508ad66fa1575c289005af16b1d5c7b9cc273f0bccb1265604a2428","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
