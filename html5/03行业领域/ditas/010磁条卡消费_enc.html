<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf6bc8777d6a9341f289444a79ecd0194b3d229fc65bed4ac00c13073c365d30afe5932f2f541b1336d3b6a6c57f0c3a305988e8f275638d9a64b928c35ab499806a1c7dca8ea753616fd780d082b2b51653ac5a4a4193a693b6cb8a08915e2a42e0d1e00202e27185657c7d6819aac32bfb22463bfe164f63b2f2f6b296491dfe2f2f8adf3a0d9519c40c6a51d0f17c523a3765ec5c50623b3d927950df49b3fa1ad1bf8cb47534b4f303c070967c999d2defe6a29fe5e63383d0db1cdd6074d828fa43dbd77762255f6eeca938ab4ac04babe523970881c1abaf1fc66b3d1a01d8fed63f9256c6746cc1535d92b93e377011365ef5f414eded75980581e3d34da3d754453ef90b2cb67ab882ac759bea3809a39a032408555c6bd4a03026bc33a5203949d51eeff64a60dc40ba6d35233aa0fd0762beabe911b73cb624a371b07c89c9e42c9afd93ccb444620fe7e30a793b986b2a9564dd4efb05676443db0102e143915f3baecda49eb347e9fc45019ac3743dec3ed037eabddb62414946e6c4ec23063018288b3a1fe9cb39f984920e1fb6398bc25300e17717c2d1cf1c4629c12cb10d189abe278cfa19f3e756c1eb593515315ce0b9a4f96e1314e2358a3dcd54fc4c0025a916ae1162615b6389721e4efd152960227f3502a1f1c3689db626895b678bd934b71e5e0d55a368ca9e389fbe7edd37b70060f288855e6970677b2dfbc1e5e20dbd85defe8cd558c47111777aff3eec5b19fb3ad731447f2597d6d9fbe05eb8f2fed4228946b16558be542151ab18ba6a9770f2671f1e1b152d9689e255504809d3c454acc57bf8ff88b54b9f8e452557895912d7ea94e97576a99d99e658ececfc4a1459472fb8cae1d54ac20d5bd853b619f13be4b2878ab6027cba24bc10537fe21eeaabc4a31cce6edca347d1eb98e6c4a3ad38f4f2c82ca7fc3c736efe56eb44db9e6d6dbc73402421b057cc9a428799680f4ce2885e0b60818f9d2c6e4c82fdc97a2bf282d97da6adee813f4a1913c3b3b23f3a3ea6f1602e383636a520e8fa4ce9e12abb8a8f6b6f896f8cf73140572172c45a6a86964d9e90a2695124d0d72e3561e70c37c9d96c567d7ac1fd2a6111af8b5b83944a30dbf37110094cb914442ab983d6ba9ae50c5916dce4fee38ce2fec845d9aa20c1f1a69d835a1a84f22ea29a71f0deacca01717f1aeb94f2caad6402f3461fbe43be36dd92ec5718f4c9d68b2ff7bb95ac13d08d5b3ceb48e6d93ba9b0fac582bc691abb01a01a58a8dab0571c081020c38421c5e90725b347cab923435207a3ef85944a8f5624c54bece747f7eb50ee18d041ae2f9708424b3ea7003ba7b2c2f2f8cf1a15258aa3e4cdef35b8280d8e5d046df93735e471c0188a5c9471d52ecc9c39f159f2ebbac2da38580fe949bc1bb8288f49243853dd4a13dcc1925af97f252e46a267e66ea21b120662ee6367e81bd5206440b0ab573130cf6b5208426f49f391dd3d949d8f4f30461d319ee34eb1a9fdfdba3bfb5265b446a35b24690f334e7e0986fac69ae71038c2db8687320676eddf223f9017157958796502df762276ce5036dc5a66bd659aa6ffbf9dad615883f3887a1834af28e823b48fb6798ead078fe9f7acc26640363cb54507da0c893a4ef01f24bb1f5eb033ec0077720a53296587b5e8b3745d57f0fcae94707ec9bd51f06ed7aa315ff5917fc58571fb27b02d786296afe204ee26e35a69fd7bc6a1f3bc29b44e4003d1bff1ee27bf5a9b90d56288589bd3bf9e9c4c8dad4b1b9c1f3abf8cf796c15e271fd304ce429119f663df7dd776d6f0ce186370ac54cf10de4207c5d2009a0980b9a01cfaf41ae0158db2967508e122b171430000ed6f6401e2ceeda3d6a883a42d02239b722f31f2ff0ecbf4bceaea455b5346ea74806c56d0e3b4b73290340d62568a9c9b10ae0bd14f4cc8d7f2c2a75a55e9ea4317c2034e6e026028879a4d6b5f80b1715f39f186ca6ffd107398ec3b57e0dfc99cf6744ef63f2d4e38ffb0de60c6451666fc3d282d0075e9284975361d62bd89050e935e95351c05b510fa5608404622570d48be230731098ff53250ef1a502f38c5c9b9e22c718a620b84cdcd3633fef76d2a2022b6284ea57ee68a9f2e125697d4d80a09bfad5a08e075a099ccc4cb4d846ea94d4e9c61982eade9bfc646c733e1d93f3b8b8a710121c013a3f49c3147a97a1c1278bf0bfc2d7c66d19210cdf03dbe44e5e7f0bce1610ae70cf6187447a7a58b0b81b6d31d2f6250c032ddf0d12fd511ba10e665c9786c3c19e19739a543ae88d1e9eefa21e63dc8774409f857673428ca05a5ab74dc15e589e8ae6fbe10428f4fb967f683a90d4190fd799d3feaaa67d1c9a2847b9f8ba99115e1981fe848307e0357c01567b7d5e27f608a3c653474d73a0ccb5c6c0d3702e3ba5994920ecce0fbf4b1237aae1fb80f701357a8664de9cfa3350806c875e72ed9d9a5c9d3ad2a3be0a74ae2656637162c6d38eb3cc9870c7bff12f49c49e32dc8103a824d7e0f054d5c577ba44b28924c94db77535adb83b5877702820596bc19b2e190759734801c3088b0af79ddfa966a4da9b3de5c6de911a2096115c32061037c097da60e5b5669c3672396a6338c75199dbce55d8545840b855354ff8153297a4c405da3f852565e6f0beb337b21eea76077e971daf9dd19de7e260b1fe0e6deef2787951ac49253df0639bc1f4445e92228b31bfb0cbca9445f2908fd0c7914e03c7be7cfc2482993ca6cd4bf3f45aa2e95f57a071be58aad085f019583a599f56071682872c26a2f7d96c495d59105b7a4a01d7d660929c9a337ad5e95b39b79c824c0f9a5d387ecf5a85680eb8434ecd4ab65a13bd64ebb32e1963ecbf276f9711a2078e5f5337d5c3efb79b8e8254501a8c7f720254f94da905567de93aab82fda648af46b1f5eb57a11f4a54627643a1a9a6d41e6f82434601a28b130e043bbe8ac323b9f183f05ba18be67f0e582ff9742420be821011f4700295bd8d0668ba7091c7315464c30cd161e88cb93f3edaa4d838f7183f78ced572b6c0ea0e37650e77ce163da6a9ecdee0fd848c9960124de0a8a9ef524e35031f6ddd869422a85b581c34badcf53826563d8e30bee8b59ea2a57384a8c96f93f100648780aec189cd833d562323304c0d4436141e215bf35602fada1969a9b7860e204d0b47d77bc9f212bc4aef0efc6415372d4e873f49bf5512b755692c79e2b152f344fca4c5f40f1f4d4c7bac7c59bd9a3f2f9b38d399819da73d350c9f5dc9ae9d65c0a6b27df437b32f0abd9d57664a4c085608416d8c7cc248b8879f74f34dbda21f302de8fea9ca3320997a0840e1f73a7a84ffdd03e6ebc2cfa97e1b608a439ddd265f778415c5f57673ec3bf01f498b172ec6bb3f6bd0f4397e53bc28beafe6b235b789bf86e360a27d8d030ff78c2174d041c412b4091c70efbbdd99fca5c39c1f15b4b69a08f477a3371cf10c961a2d7b9e2c8cd16c0470c008e3f060799883d839495caed300bc7f4937a36f50cf1d9ccd0f23708116ec1ded765ca4cd922bfe012430a7f42b42f00c3466cc68880178147ec868ef5b466faab898026cf45cf4a09aef5562eed32a02c04fbe7a5066565d0d86fe3f7129862993684512fd14d59f5b7dfe545af19f2709ea280a29b12b8abacbb30c8929435169000b62a1b97e0de4793a07a7ada50336deccccda3f7e7bd67e97202710a6615fa95d90c2180de4b28fdf7623c25ee10145568db17c0e08bc3364c4c0b8786ab97b7c22d62f2f26a895e59893bb24a98363c32c60ea810d07dc24a20b99a10cba0684d1ad94e0a893faf63edb2fd600f3dc693dcb289a7e78cb40a39d214c8dbe872c2fa3fd7ca05f2f357424fc7188667fe572fceadf336ded597d2e5fa0c89c96c760e98bb8c2c05fc404ce18006a12bb418c5bd995f1c6de2c215d5a5ff0ae79904577633a6b3a09bd8ae66ba852cb18165c20ecc6cc468a6f36ac4f5ed4f02b305fba9551d981104ca24cf85bda57d5a5456672623919392ac66f2186154117ef47a12d8e7aa66c1ce853ddd38c0b72a58259b1b60948e36c238e27fdfc71245b2845b84807b6aa7235a02f1857c43ec50ff31daf7187a3982d3373d4fa084a1bf1732320e3bfcfa70f1039306966949194c216c40c18c4b93323b8075bb72643fc2796270c9e79ccab95b9620253b47018a5239a254747a0c5f96e3ffb96664bb36551b6642a2ee134d265db66891e979c0bef52f5592a037e190f7ffef7921c113513528166994d4a021ef4e0c6ff7a1527d88e8be0ecfdd32393b0b19ba35702c36cd378f14fe700d3ab952498ce4a3e3508506265f4fa76bec9b4abf473f3be68bbc41b2bb8f77effba275b70b7276a969dc6f64fbe6d55950c499375e7881760a406094e7836785a1e3e7f937fd599f1e383d5d861b6947bb550243791c85ea7140cd33b032fab6abb5092193bcae5ee508302c3a457f492fc1e1bf27fea182705c9a0cc7ed89e671e893d6192c33028937f6b8e80020fe7ccfe554489a63ec048049280a8c87d0d9bfd871d94eb0f1e31c4658aaa020a7ae5b6c7f110385bf1ebcc22ebdef00d0e81c53781bf9145daf914b4ce9a168c686488b294d9d0d7f761a3c265def9d1195e4f2070a8ec5fa51d278275c68cf7255667db116c1986c6011daf1ac8dfd5ad728a832bd758979b258348ba9f0212ee76a90eaf3addcc67fa470df930fa4c4a1d3e46a37d7fabcaec9e2983d00671c29882a46e9cf9b03f3e7172aea224540df4a64e49f7d46f3b1fb6f717da355dd3f48020745648bfbe4d9cf903962d00bb319a650a889db8ec6246e6b7085f668fa68a2f9ff65d7084f602395d6b39949a8788c8a661bd803b2d4c44c4a655bbf67a532418989e8ee039e485f88a894ff172ffad2d5a6358eab88ec27faba5f5c17ca65aa3c189f7283daadcc0bc6e9a142f57e50553c533dae8ed663b9f36078ca79eeddbfddec0b136741100050552513f9013d45090ddfc8ac87ebda1b0b29257e9f371fea3e99bc7c7e256bd13570e9696ee676f1586b159bf4c6d33c9f31378e7da6c02c38821d63b7a14b70ae1dd4666bdcc59382b696b55ce0af7ca2ef81d5ce583335e72339db05e7171230fd9b016ba8f5e62d0b2f8569d2aa606a981b89d0ad24c121da9cacf08a70973dbc3115634fdc6b618e856f072bb0e395e2fa86bbd644fbc3ecc9d0163b6e239fe871174e618646dc52b9c553a0e92445258c6da07b6e607039e8c86011aef065df4d2c47db9340304f92b548a551a01234abf1a6f2405b98109d693625471a81bed49209f3b4d71a3d5586f5da1b44b2b4f237e8eb61440ef0752f626b5d659ac4fd8cb93a7c8a56d4526f070d4cf327d8862e8b10d1c77480539abfd543bae887cd66c220008bc595dd0513795871d428821f3ae349c31700e37f1f08a0c4816d90d7fff14a550998fa4e4c096c57a9e5d88745c1aa43eb6669a8fb5dee6431bec4f4b01a880323098a1d4d2f66f0df6eb52b4b539de7d99a5aefef73851ddc5702f5aeb2bcec5de46050f5da792e14095b99e595cc8731010e0e256ca8e0f99e817b3636827a0f3f93ead3de1e976f66ba790dc44173c1d19ef9dbf21d1a37c32b08a03dddfcf81590779257be363c94bf61a823fdbd3e1a51986d417be28ee28f563fb7283d9be9b4bc3d24fc7af999e2ee7fae8b83dc7f29e5547e8597d1ffb626a03b82f8a579564beb77e42d94f686b341314523bcd2975f5ea7d8c23e30d44ad6f2873873c7e3c1f75dfb0834ccd009e65a9bef4646e2cf19ebd16f3e57fc8973c5ffcd8e52457bb9144261f72be64f8ecb046c6f85600c409bbfc37fa2eb1d72f6f537ca974e65ba589bb04594bc17f750dba9b3e31254ba108e27979d59539f8c9697127df268fc745edd7c74343bea2b3a5a44f26a99c8507e18f9eaf56cd4b1ecb10c842575938745f91c42439fecb50d0e21797c2defd1054d0c47890558963cefcb516fd25180941a38eef4cf4496d3dfe2beb4dcc7be691e175653bf85853aedae7a09051b3883982ac75342dd03075afcecacaea70d5855468431389e55066cdab06839aa009ec7f0f80bac1b2d7b153053fcbcc4cc4765339d15a5e015ec371595ff61e47cb075b9fd8ccd3f981f4d6435c9dd6a4c85fe98afc4f157b94d72b1fcf9433ccf4c904547b63b6c08cc13ceb4de90f13512a39669961ce4e9679f11542ff9a86721edd305b39ee61b539cae7fad93728d755eee7b7c0d1a2d989098a9de3be7a3cfeb275289651db5fba61e3f64485e6d7d22f744520adf06978e73bbbed3d09a69535983b9d55fb2ac9ceca2f29549f9fb0e74170ce82d36b65f82ba07ac6189c88b11a3faf8207d9b986ea06cedb6f59eb1795aaeb7e58a23cee16c29cfb94476c0ac4a26ac5860472acf575defc495e40218632c4e32150c023d6bb3f90abcfb48697ddd05a0b84d5161ac09375d7a2f237759618364a7f19791418c517050e0de5c27c47589c2b12a729d3c5ce05ac4765a34cf2bad649293bb601f832a53f912449e9a77c979208394498b9df3cb20b46bc7296340bb1578925b6cbead67634cdd3e041511ce1c073e8e5d1e14a67a9d43c316fb300871051e83e5b38f22446577287d2015148f17438c653428b5a93757e0889ffba587e2d6237f7bf7e233509fdeb1e5bbb530ebded271f5fc8fd52ebbda97066a64f1d128f7ea1a97e7f56dbf45175db9d9a75d30870eb379e088ee8ec6b6b0a256a803838cc1007f98b2c6547fe518337c262930097c0c8b22b174ef459701edbbcfd7f3454ee5c9f4a7232df95ade43aafedf87d48a85a68381c5e18be909875208a9353db07176efc6f20ea9d8f239cb33b81f206e94da3a51d41d695c1efbeca7285209b5de72fa8912641e51df915d37f9d75c4b13890d6c2aac6539b6b5b06ff7810c235f5a4055d437e0fc3c845a76d30713ab1068679bd2db132433e815a7ad6e8f8e944809939fd3f727d17de578e0523b9c96371f954e162c1953648bcbce0f006a1aee5791d5516b4ae98307a48cecb98ac6a61756569e2105677bbabb784327e5a6390f28a18bdcc20a87c70db17b7295896b33ae55d4595be35cd4209b6cdea7c906aea9e73abc9abebe79381e4b0c870998d32597b81f5a7779b1f6eab5005049f7f858aeb34a18c276e5de614acaf3301bbf9949af6da42d92d954a40b1a945698269775ace30b6a03666d9fbe719b108a47494f990152db0ff0eeea355d3da5235fa21fb700f39f675246ee14b0bc7a3188b94c0ba6f449fa875129d8cc939bde4d0b9912c28ad12551ba533706930c8fb201c1797f1a9bfa711fc0b328d86507cad6c873f95fa772eb27f4d9608e562564573a49d6f39a68528584efe5fd44fdfb0158b25c9f5614a9fd2d6d797076c761c990cb19f264c64c24989afb63e412895b55322ec4e67407f53f4360a41b177b6040b4454feb642baa37b004ec7995206f0355927148500da799093b33709acafaec3ce62ca9e1809cbb1aaa6f425e8b7a415e295e36b5e74174b7fe8f8163c10708621a046c75248255bdec43fc58ac4e13460d500a58d8515bcdf455a5254b2d58b32e8c0182ece7569ef45d2805f1dad135a3f049ec5ef32ce78f9b9a09a921394f25e979c8da8885b398d128ff815f7345be4c702cce1a72d6516d95e93afa548fe1154c1c4df7e2d3dea4b48931d0a8237e7f12b647e2cf55ab0f163869fd94beac24fae397ba74b791609684cac364284a8c3b0c629b6d125d1963ea25ea2eed64f5ccc7d3c1c76fbd5f64213e6c4bf1ea812c3b44f167249411c9236b78c69380d45d27c025d2b8c92bcf0270545bc25a7bb2f04ec95598a5eb7ceabde3c1ff08c0455334018d7a55d94b2ee4498d755865db18147b4e2c725a6f48839e89ddd1139805f46b4e4844711c0ebff8527662daeb838cc0be332e0a77f037d6ba2e6208c761a69d8670d09c9d7b5853efcd3c1d5d03cfca2868fe405726fbe4120bbfabac255bdf92827d7e96ec341095d0a479b676d26cf80dadd1f87dd56079eeb0e58eb1b7fabb55d572ab919fdf8c55b32423d13665ea47c23b23d1afe9faf53053601180ed4f8a11c7f1e7766b8377ac611a6a39e460d060f60ed894288cf2b58e0ec8df3a54a0e4c3d1b51aff5796fd53f13427c8d189577fa0ce85f2dfffdcb26e3192db7b435194790e6f0c6174da7db0a5b240e658fd9674d1f2b0b48c1753a17636c44a319589e0bc0afd5b40659278e4e0eb4eeee5852fa239b52ed5962a30965fa38ccc43537546a51b12e93789a078a3206117d89b258833037bfedc9ab3028d0d92a8e96a8956445f87cb2b2fccff3c70a849097796f7793c1e108352ce2867fbc09ce344e951d963084df35e3cdc62cf9458f072ffcebe08aed087a3f138fbfe40d9c0cf489cb373b75787bfa92c5015f92128513d08ccc25c36446236bbd5f7f9a11efd974320f1242925dacb6ed8e94952c8fa3d0ca318203668add09b721e6159d00083608f801df2fc9c6a0b427c765ac9c6f4499bcdf49f33ca131d23f82830f7150217ae883cd7b80af91eb6aa13caeb4d836878fb32f5b4dbe6e6872fe05861aad7ac60a6a46135cdda9aa8a6d5c4c32b790765f6258eb5d8d2a87584aeea79553059d8960b909d627a5c986346ebf33044cc47a886e67807361466e71bfb1ca459c90242d55cb202d4cf78b5a218a4ab75cce8c5cfa048ad3a8b12c0a0f6d3ada5c4269c0c250315e3143cf62b70991f68e2aae9bf2a4fa344a03578a0184949f6f1be075b60ef9feef27689049324a77d03e7ede54c7e118b3fc7e831fb46ad66363a1b7efb81a6d0afd4ee1cc5f6705403ac384df7ce9d9dfe963a361058d55529cf88c5eed05ad5cf1062bca5a4467fb06ff495122cf14f80af9a52f865759cd47b8c383327363da8414440d449960ddd4cc09ca15739595a49f71685879734d6061dde1c685b51beaa1028f81f8a4b2bf3f171cbf63c9282df8ca5891531783599bae855b935045eb3757b85e430fd65887dd17ed68d167385fd49ebd49ee18f906d2047b4469d523f79aed80f8032e464aaba331949883d1a7f339f71877d5c983616fdee11d2e9791be9691807be185fe2b6bd36635a9d28fd04ffc2b70f80cc13dc5aa8d864c2225b973f7aa7a66f6cb45077f65ec05c2f43f77f9a2de9873e90b8438e5c4f9622fba1db90e3b216595fd279c7d15a72ddcbc42b94ceefe60b17362f8347ce812163366cf712831257fd9df0dfb21ec6eae7b360ed36affb501b8874c9b71c36bf054b1ee7a889328f609381354fad2a0b500fac12f9794847d5566300e96f1efd00e9a42ed3203c1e1ce33ce2369a1a588f334d0b9be2896f424a0ab11dc88f384b895aeb534016efbe41c231f0092577d02edb12f2a55bf4337887589f927fdca563c56c58360f4133f0801fb5678529d605bfe20edbd8f7f8fa49ed05a864676c317e9cd1b2264adfc42bc83d7cb8d939bb5c8b014a8419df705f3255628e52eb3aff1b576220b4ffa7fc211bbb6742411141121766a930702e4fc9d67914182442038dc3f8c7d22134b5383c780823d5c22a440cf9ddefbf671c6c7ef0de32cbc3917d071d25d34bf755138079c9270a150d6947fa02fb5b812f036909ef0ca645c60f1d16237d75c13386fefd3616edb8c3bfcec4881b5c667a11b226a1760c2198a256d8368b5d735693dad30f634a4b51ae8570671a95a0064f3628a02e52be1c7f452a96d4110bcb576334b749eae6aca8f5178867e9a9984e8da9380c8b56a8e0d92dd3afe1d20e411e7d038b2fd4d95e9e187876cd17269052f5b96d29751ec86bc0b72298dbd47bcaf0fbf1a46aacc57463c5bcc7504f5f1326d2e8bd94576436d8b20e8376b45e840163d1ac8ebd9ddb9709561d899b1283bf4e34ef8db438a227cfcdb94c7ba097c1263f453ed097874865fd76b46a222e61fe796d2a3d249cbdcc8189e09c2b1dc9ff93dee32020a20b3439dde531e78b5dea406fc66e36d42eb8c331872bed0823cb3235bf1bc580f7826b13cc133c749853ac804f3e91ff7518c1a0fa9f09389754d9c79869bfd4d83032188a8c6538108fe3892e964bfec70b8184546931caf61b52d4970945c491b3dc67ff87b2bd1eb1dd616c57328265e85ce0c89ceafa0e6a1bf92a991cfa040a676ff353dfd1470b2fd1f2e5827279014a34da0e560635c160","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
