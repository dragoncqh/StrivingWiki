<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d3471fd1d2f267ca9c5d3f3ccbff3a63c1c2592701ca4775a496a94ab05ca55f939c464c23b54f02d8172842396f89e958bebe81708576b1ba5d34b79198bcbc749718e9922a01f626ffe907f8eb4726f654c6e64923d9496b3e06cccdc7973fff5a331be4c96a39fb6af099123756d0830f74f4676fe25b52b0e60e1d9a596de3ef7c4965d22d48dcec0b68ca6dcb2d30a149cb0da158fca64b32926fee02fbf96ae5a265f2627ba6e0ec9db60d123115eeedcdaea7238db0fcb9af2ecc6db40e1b0f8aed9ad02a8568171b5faccbb1466a256352c125eae3f0b4193d73e129f71937add10b37b8fdb26479c6c01e694ec05012ac706f1555dd142a38affa64b89e5dc850ab49acc825af9d367156bb31c12f50aa6245d90a87d47fe44156082045fa779631505beb10ad50028511479d3627224d2dc6a9e7c1537cd46b523ff3f8f2b900e82d65557307ffb8b2494ad3e83ea528683e4fc3722616137cb59aa8b2aadd5d571c94778732474016b13882fa883ae96ccf059ed49142e55c2112c8176c84554a94c9b1d464ce9cd3f61fb87a758c4994f3097a35a6e85f0c3e531c041e507c580c68f0eb7f77cf3e8efaca079420cffaea90e2f00194fb74e920b0dd611b2e8dfc94e87cab7fe63fb03661441a2563a34f9b8af78d4cc956ab0fa9453694b2529fd1e737b39aa6059f10b251fa5ef9563ca36827d10b0945f87c9c6e47ae2624d937f10e8f1761f8f469b8ea50bfa0de3e9da013c0d7afec8654462e328117203023845be8c6e4693f919568e31f2421eef97db60bb7baebb44b1a5cd80403e4b4a87eb19d2f1f887a60fdd5b0d04010751b8afa7b75b3482fe79187e615451a226f0efa8d1eeff1ff3a2751d7e2011e8344f683aaac42672a5a2149e44f15aa1572fbadd151dbdbd9eefb584927b4c45d9833152a53eeaf5c0d2e4c372e6056f2c29a4e406a3c5633ff769ac089168de6bac60b654d6b88625c3d8104089259cb972d424e7d998dd66cb5f1c6fe225fabb16cd661d97abf38349508f20ef04a43e6d10bd1a844463f5d14afca0fd5d2cee856c6a249003ae7d1a8c119ea5ccfda23e5c351955969ea8c2a7f186b9ed0785845690da86cb0cb97e2661c1ddaf742c919b9e75f0fe72cbd05cc8c58384fe174836a1f753ef5149ca008e5f5d7bbd4e6b31501fb56b26b35a975c02690d072afecdf8a96b82761bfb6072ebd4bb360e594f579ff804d22635dc7862270f1da531f072c54cbbe6fc79a25296ee0049e07a6cddae8c0992823b6de087af2f1de1a0475e15b6a48e2c7861785d930dfb0f037fe09a80b4ef02752eb9bb78df7d7f9ee31cabd3cd6653a201ea3fc5622d8c64fb3bee886b4ec0dabfd34fbeb683b3e04baaba117fe0a0c8ef8b8c46076ae7dd868211535fdf61f282dea5c8f6b3af0ce8138c4328eda9fe06acfe3887554ec9eee498363b706526fb0dd4f1571000a9eb3a6a772db13136c539af5266548503cf3cb4e6c034bf02e8faa0950c055d1e263dc7bf03dbf2f13a03916e11322c7968710985bedf84a79eaa8c0ef8fc0390f293ef1c6a07038c572941b87c358070d4eb47a31cbc15d11154f1784429298a72843d34dfb0d04fe72452fa9666ee72501adcc68992a47b710b44ee55582fb3d65b7cf3fc709cb966f073a1cdb0e91142ff5c13c7a7a67426154411f01483d386636d9598e11727567cf8571aa2594aac547afa2fc73f1e6aac60765dd127fa727cec2a9fa8d4df360f5f7e4ad393e51aaf71d556f6a36fa7b490c8d74e0d5ccbdb1e32ca7c69ccb0ae4bb0bd2410232de0b26c4d98ae4f6cc194ce07470e613a07bfb489151c988f3e08de62242e4d12c6420b770ee20866dcb4f2614bcc0b358f560a3431db98a4cc811e9c727707d45419ff6fbb214012e9b4adf892400556929320810c1b9f76f851f7e4525768a824bfb495681864cd6f85b43ef3d8b5637e7dbd6d09b0ac9e5ce68ab5dc716541f7a7a837d5b617e4618703ea5f30f28b76d81cfc6ea83d9f59b926fbb43dd588df3e2c24452e8bffa4624255df86925317b77da11bd0df2350f8885c91ae697ad9223ae99759b66d9c944152579e80676901ab76d5fa2b80c2551c12cfe3a6f30e595dcc8709213f73fe25742c774ed1c46df1c14729187d81959af9bbc22d9d03613904893e756e1b081c75a5fdf407b2046913510a8806c0099e689aaaeabd6c44709aeea578b75af701007799c1fb5975469e8d151946bbb5cafcc9be851ce3bb995eaa5b1d7a9a48e8d22f0cf40ebe841c433560cc48aa3c988a48256f82af15b7a31766e033cde521c6b7fb071eddc9caf7f28af3533ee96530adb3164137e85bfb567fff8ce1e24f660fac538f3d7bf5df3ec0fa1c551e78d12b92627f648c6dcfff916d4f4766f772b2ceb00915dca5264bbb8fe686878ed46258234dfec1ebf36f80b36c701363eac7b0dd1da1225dbd59c32d9607fd2885fbaf1393c6b53bc67a1aa7b0e316d2d77bae9aa20cc79d6fd99c3582c190ab2f0b727227f4d91d971bbc16b06ce65b04374f883e4d1b4ffe47484971e7253604dd6b5e131d100410de1981d3584383e1e93461f107c3f202c1fab6196e33a860977a7d57d9e743c7f6e47a2b275f36cae8b04016adf14c5e2d28f6e65b4ed52f049a0a72f477778929d6192b38c233d1d7d332875a7bcc8d9f42c5b439e8a293e8974948bdb666fd87d7c69a8be3d134434fda5e704fb8527f3ec084e016151f9f4ea16b39c3cfcd40b7f337f837bd624200bc7a6aa34a8fbdb474d1ab624a950ff894eb8dd0cdd683967fd7e80f27a998b841be46a8020bd6bd26e56b01e7c1a418060f809ebfb8e7400a9ed03fedced1dd159a6a40338259c823d28c5572bee4d3f97eaffa913b2884c1a0e44ae2d9d6c3aca52a363f9e3c56a229e4d8dc9b1420e1d46d8a11ac82fe97a9ec6e68ddc0f70ced07cbb7a76879a550f63ec8102a42d6343d78081e8c0087dcaebbfcaec385ac85c4407a0b44110074c4a8b78cd403fa11fb78d1ddc28282ed2c09542cbbaf2fb09158c390351609e9a812162bd9785f668f93886b44ac76735b82fcc131dc541ab1a79ac1c2c884238276d6dd862de43e618d471216f9ca3924010b8919c757a1eb7e2304c1c4f2fe0d3123142c11a91b76d0b043acd450d62d6dc566a1e1fa5c65b3067f3d136b0509d3ee80e7b5c95a90f59187a66c95d6afa25b452745967c985def07e029d145d16ca8f7da076d77af79a0a1c8d8e2ec76a94d32930a14476fd8e1d4223961301dd58293f0ed728056afe39c4aaa1f9ad2742990e8c0cceb35eeedfac0fd7f3e706e718688d139df68d420fcffe6b55042ca2207bbae74fba2d4e6ea13cd00c96521a61851cc6d48e431c7506429c8048962587c94d35b368d9464ca45294a11d188e1baaf1074afae4c2c5e807beabf3af5e405c929c16a93b2ffb65260c7e8ab47d3c0ac05dd6649560da472989f0f6781438e77b0503c5634e45e95b77244712207b7aa144b427f9a5792effaf4c3022fd346fb4f7b0ff83ef84da4d7dac83af3359d0b3575bbc37a85e76cfe8df3aacae69d1989f4de4323a86500764ac83beb1de5b26f8679e21bc7f1f047e6ac56676b250d0679d19277dcbcc97cb75781305f96eb216a1efebca9db9a921fcdb7b2544cb28590e9b8e4df27a7cddf4bc0eb4e9aa979cf885e14074e33237ce789e40d50012f051ed513bf674d4444d39564127b8c5ea3ff383858bb69ce1cfc86033f8db119a15c5da3b5a570bee219a32bc070e68127e4a89a11794b995f6fdcacfc068be61069978e498884a6139c57be2f3eee9263715ff6145c4c12f1a65f6c309c9269b86280a568976e832a3b186312e45cef0164b11a4672b3f01977abbb0e15e1343262ded281e5ad3ebfd35d90b863a1a91c59669107dd7da4c3dffa82a2554d994a815205636caf3a1a14d93b8d0e72e11113c034314412e6be3c9e1f109415808124fb6c2b0c99243692ae4ec10705e67d409717511c0a88e30ded4d4299eabce80d3ef962231d25204c211070ffb9ef648303924b5d520c8dfbc9aa96f8d04f79c73cd24d6c6959f35c832be6e49c72a82f13cbd8aa2283b236649b8ad14d1f264a4fe0ac3a9d48bdcb83f48868495954bd30fbdd3fefc67dbe2d0d38b0083e7997c9119e8e1afe1250774ff74976dc0078aebffafb157b5dcf800b271c60f7c16ad64a5f49fae8470346955de2bbfccf37ee017bd428d08c97a7878905c387a3a2c1902623ee20242907b52aa8dd5e8840fc72573764eaa99955d0063504d1706e5c917a0dc2ba9e1ae4deb0e545c54631dc0cf7f8bf56612d6e4b3b73080a8370f51716c12a4d5d5e4f94cc51a99562a8e3602a731d7aaf95ce87547ddd541b4c7782e1e8f1897f576417613715471cb5a8532a760099e94b23676104a46c426182b899533d65300de843af9cdd79652355fe17332d560d2764442eeb04ba3f0831a350fbfab31d46dba366f81119c6aed284ba09a7d43c1b4f5ad76a9c9cd08bf791791fd76985b748ea6b22d6e933f0e9bf5c18c3aa54ce2b52c5e4a10eb8af789d94a3d69721f680b6575c6f5bb1b2a63103ef9a7cb261514261eba27b991cb89b4e6f79455e683cdb85f6da9ca87b5977512608d58b27a69ce79b82b1baad75f11ac246b026c8eff7b5499ae03399b02b890d2e77e047fbe999c9433bb1596d368686990cab85c48ddfae0d3be96bd2c746709a833501a8364132d2d4f85e30c502f67ca8d6db14c89f3fc75bcad070708602bd64401635ae6ebbd7b8f9788ef59007b35d561b985cb5bae85e455bf47668daf66b217c8b06eb93d28be7d5e0d7bb23e9714d1c34638345bfffe2df036a40f0cf6429aad8ef0574a5656a94f2dcef7a4e4fff5f738bedb01638769c4ab7c2cf54983840be205923e4b53c88508afa5d8e6144c61e9f3bb9fe087d635e3b901edb732bb3957164d9a381fadb022bbd08431e31440b5070f7c18f8ab00caf70e0d9beb795e61962aed91a315508f2afca829d2c333d8abf99847d35fb5724111ebab2e4809551900dcc42a56d11be320ae6aa87a3718c50cbd45d4783b62260bc62c1a7e11ac113d549b327a7895600a9fb37a098afab1621145a8439165d3dea3bd1294ad4586bb67ca3e28162789b91aad1666c82dfd2cf9e4f6fc6d100a1a00e4bfb34c4d81faab9f7476023fde42aeef4d81c411f4f20aceebc65edeea5a42eb914a2803636ac2bbffc0f165f12c16cac21be20e7497d8b50d31775036dd151db6ba3e693391308aed4afca3cfc8b628c41fcbed1aa5c4d56b934cc6bf6897918ccdb77c67e7d498f196ec7e39e651352d6c9e046e013ab5cbe38f460b7d62354b9bf0d3ea44181351f44b7c08885b3963eaa264c8d6b6cc7bc7960eb7758d9b6bf3b370d66b258829fe89f05d27e7be32a1192ff18433eab6bfd7c801ee874d9e19e408bc86996c104ce0ad1718fb39c46909441cd908f689ed42f020b736f38c6b0a114901c4106a1afce55b0a6aa507776f37142433c410e3e08b08e657964e494f874ec152544a588a72d5cf4802f044c5dffd86f531dd703bbaeb657cf89ef3c115f0c8b302e0c6293748384cdf91442656368dfa489a8f91c83a5853ddd90d57fe42c8c08f203c1c1bcd749dbc83705eafa7ed133b67f5ce16d5124086b8b93d3e9f2fb110ed1630bb955a5faa8c27b05570fd394bf0c580fdd35ac3cad4946c05846fdcd0e34f6aab60ab4a593718d14c7a8a68fc0683e4927857a10737526f058221568c2e09b2c2d2ce6b7f74b0d9414cbd7aa1d3bb48c20a7ef8463089e449af24a268e8a5675d5557ff73e81cfe3272b07b0e1b9ad3cf1408e302ad1eb408d74917a364a2f734903698b312e597eb246aa0ca39c53ca92bff010886a032ec625321453767e13e04a2ae83cf62cc39129345f447b7d47180eaadd381c19faf1049d9bf79dfba185755597414bd327f2aec9649eab13769f0fc16e44efc2befb55aa39ca5710fc5541d46a5f2a0168d3eca9195593bc52be622d7522c5554f00a64f8631ddbbc5b0df3557b24dc2b79e3150187e057a304b7d58f01fd8f7e3d812116487c22efce8d19b743fc21e5b2e87d2e42cd3987f76d16e80c833fd661ebb32a9d46dfcfca99527fc82e60c3c0fa438f8c8e4085481268483a702953f258970559026e72a5119759c1a135facad31f0156dcd7d5ae14ca06c61d932341c9602fde37bf3e3c4e6aa20997fd4ce16c52154e0c85709b1b2a51a69f12dfade1e1ecdc91e48a3e353bfe8c8e073d594a759fb3c01931aa9393d2487d3df3f28ee1de7ca1918f074bd7c17ab15098458ea75a634ffc8786793f40314f3e9b5b9606ace29509abdee70a4f8f780281676bbd88921c5ec88325d40d1bbb9b445b077d912e970f63aa8ddc8e139b4cd7460d4a8fbad9ee33ea31c0e63113ecced48096ed1fd837e049ae36bfa8a8cb7a85555c73e2e71f54bc15476eabd42379b4ef38af131c3aaae966b96e254a6cf3aa5e66ce342da079192b0071bf7d3d2fb22f37d9e3ebcb1ae6a1de1cc1a5d5e5cb680aeb4fe95c931798f87a15ca66cb15949e8ed48c1f72ef80b97ecd130cffebc166578b1cdf91e4da50eb223534a228b551679bbfe63cac79273580b8571030a7f5ca239b7ed22ddd4078eda489f57eebb7c993411639d771a4b457f54c12c69c66d54a8f69a8aee9dc88f6e4794aa6f120734acb9fdacbaa973ffe385e8a5eb0f52963f828cd941f2e96e830189c274eeede448c522e59094ad406a46b9b6e51a1bf5766c4a5be7e6de8842dfa33ffdd6cea8d873cf585b78e5754140175130f1f47690327671452966b5ca2c9e8d907b5ea8af89b000ff1e8334778d4b2c0d06bc671e1607f9e6edd72d86e85665ef98f87b9f09ab665cebc64345dac17629052c39420a2f53655bccdcb695bc691df25445da0a6cbb26fa0b5228ddf140629b7aabd0a658ff2fb9018c9ded5636cbc6730788989838097b56072cdaa69fbbe118ce1209e8477b0eae6406b14e9f596128d1e208a962ec8aa71de5b56a64fca311f8b10cb812ae96ac79d00f25275efa95055f7915c2cb1fe6ccb8dc3ee7135e08d8da97e8ede484ff67efc522d97a871e8c50ad3ddd63611543b34bd152bca1f60a1e0f54556a8c1b71ec828b2a3d3496342ced6470b91c84649b5ef4bfaacfdd5f3d6114afa043465b2d4ffb8c12eff9c4925f5882864b30c94401654168327791b4358712ff2f2ca22ddf7731b1b4068abe5f890e65cbc372783924901151525ab252c4cabd4328072550ac74ee9592cc0c8e094899daf9c25bb6450fb78ab83a65c82c1998f188d0883b3b536926ecf4197dde724dde64d07a1336ccf68c4a99f95473458405f5dd8c78a083505d5c98cdc62a43a01b5a1563924797e00d8a574130f68eb97a707e757f2d03c5e6839dda875d384b734bc7c383ac8ed963d01ff07f82e1ed478c064c794346bb74a37c3c70d29393e5171d4b621d4a0e4b841ecda0adf59f586adcc6b7c3c03c2c61d895fa70da68531d3c81b994145029ecab1d3a7fa6f9b24650b8252d388ebf207516d542ac66c82e6d3fab4ca92eed8431020064335ecebc24db3619711b40e860be12218a5244ba42d541a9b2799fb97dd8cf77548e0a91560c9bc5d7ed017378f093d7702dbf81fabed802420ceaf702dbacf8b1da0c0169847f0bb4d18750f3c5dac34ff02c03f13a2a05e6cdc2e0e435a6288e61ee9c51b5eac498e1f279c72e57b96695148dce0cf3ee66adc57203e965e5f79e6c5d4c3f5e978cd10539a3ccb070c2b28f1f8d5af3c4b896c1e67addf76f86e4d11f13c30564a1095c517b1d0b204af57db070100c321455a07ec1a3bbc22e2d433a4f9d26061e276aecaa9a9beef854ea3c8f5b9d707fa6749584cac48b13be62f6984eb018ffac6a15a1be3f34a00eda87c1e1b433daccd557ccf84d61316d9de3be8168d576a45e254d3bf5ce74e97d1444f87bf7fe890de73a02f5b8003b26f1391c215a2df8c538177ecacca78ad87ab2488fd4bda76a553b1ec8fc41df51e8d004e720c308a27421f5944ff9a4204a78ad638392cd061c9328a91779256e7e6547f731a0048fe0375db62ee1c3a304680640362f8a6d68b7f9564e8fa9383f048eab247b8285b7fb0702ad07d6d738ccc31a21a1aa9e31aa15693afeb73b7527d0aa7fde9ab128e86d2cc5d8e3714e26dff3ce4e4914d0ebb3b7b860bddddf76566a0f5821b772b8ad1141cd8a86f301b3d5da40323a0b458184e21b33a65d9c2e73776452a10f5e81ca12e38780559039abf65bd90e4af50d059f2e0571aa75812f00fe906c3dcb0d8b622a63c2d9fcda5c66692478f93e1a243393203274e316140e398018b287d957cca8dd2247c32bbf0394ae3c47a9aef054ca3e3201fe79b9866195d41a2612711faf22fda1282746929dbf8cdd76fbc23f7cc914d72a67cff2b05397cbd545b8a1b3cff5820ab2895d07fbcd181e84c29d5f4df23cd5d1ab879b3f2c2df96bee9875475534826f008120b847b7186e641591ac6765eecb35474a7698589973622449c16b079088a639b3a0d6eda59d4d9d3af039d676c45cb174d989ec92ad08bf0097ce9b4ab0055c12caa36b10b223d601c5fb471be1efa0c04451e4c7854b1687fd2a041515417be3f824ec7edba8ba60da28efe0d64ec879ab4a2feffa8f069c36ac423c783530613433be92cfc750467fced43d42321aad1e5d98d17333767b2831132069860f711fc06f6bb02dca97168a0469106ed0d40d9940777d513b796c3716a65cc6ae2dd95dc59f3bd0f36fad8748aaf31345a5a938dc3d14cc892c251fa2f12edd08b40298769bc8f2823005b6211f859a636cf957ab096ab275528bbe27e4ef8afb0fc6a73bc909371737f7b2bd0af1939262ccd5651008e4fb5e88fbcdf38d63f48d317140980f009b1dcafcdd534e835d3332dc6f2119335f6deece9e546879b081da2dd9ac92d0f65f85cc04095f26a09f332f71982bfb9bee1429e581ec61a88a46fa45d25a5b7d7a2cb5d85f01c73efab69390ce505fa890b838738df68884d96379816ff06f09ea9120ec143c324846a1c9843e7cf5984361c2aaeb015d9f0999da79ba9b6035e0bd2f9fd63f7c03a97b4dbf21d57309157633f7aba92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
