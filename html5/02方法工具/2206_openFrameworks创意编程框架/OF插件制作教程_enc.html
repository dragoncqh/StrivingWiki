<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8a0ebe8f3c674cb8afe4a0c0a40cd501958820221921103c303828e842f78bb5f2a00a6ae681666dfa6aeaaeefdc5a56c88ea4d0814e21698d81bca070b2f8d8a499462b466a1cb65ac63ec788c6033d1242de40401294ddadd3feb1c1eab4ec42ba0b77beafba53304169c57e368f5a376130ea5254cabade9ebcfc9f60e942b81c75dfc33828e45e27db3f8d2437fc2711f473245674c9f813ad127a83ac9db0138f3d7bf1e13a31e965b9741bf579817446fa493c4238c6d8152b52fef9f65c3261e48c0e2ce3dbfb30b3a6e0681c36f17c7fafe57a4b58b0cb1cbd4200422573ed6fd301de7798e413198a85628cc3a38814f4b33f6760412c519abfe80feb0be152105f71149997e72b724dc6030928e27b8fbc622146ff22d45663b54befd3d1f435b2a0c866a3d71294f54e9c872320430cdcee20972867fff578d12ac921ad36dfd2801193e8dc200ebe0c62b824406bdd097098bb7df8a7273a4594c89e55dcc0bbb19cabf0903925f12ac1c8227ddcf3423f2771f77db5626fa12d8ecc889a0811e004ee9216c27bea5becd3becbd056d13ef63cefe27cbd1dabf289a9f1f882056fa9d9afa82a2676a2463ba1284e0bfb37eeccfd8cf089b14f71e9695da1eb6129227e3e7bd84ce6408e84a336fe7f289f1be442726ca5a534121125730210280d338d104faece26b6ab1842eae9edcb02e243a951831b694874a844a6e1d982b297ac70bf8df1f65eb0f3d9ab120ea07f04bfdadaf9f409ee767d1a6a5b205fd08e64227397950b77c24000b7c74ee12fb9c65806ac5b803a85c4dbebbc502303c62a0115cddf993608796421943144f239ecf0508bfcbfff873c4ab16d8c838fc0ea2ce09d4bfd4fa3d9225a61ca2760813a95a8a043ad64e850f18b1ad1b451831372cb51262d7901d52ef20ce9fb593188338c195b853dfb3c469e9acf08653b1d1a6d7615c07d121a0a3480d9d6d8e3d94c7a16ff7ae8e985a222b0c64f855e7f19d855c4b219b940f1d332f88438d0a7f9af3de871802167e5eb76ff0258aed07237cad2ccbb3b085aad417102ea35a181f9b49935063c92e8f531b4f9b39c5c65e3653b6726b0d14c601042377b86cd464a80445f0134b9e3c7a7e0cff0419bfc7a1e091df8c3173138bd796b69cc923ebf69c3435b4148139e4e7f1255786cbdd5965d0a2e9f76f764f76cc974628d97c373a4db767d64b691a9bd14cbe64f9771a9e708ecbef95563018fda0a34431b5b78c38bc53454e1c186453d76e1b825737c06e4142591e85068e35ef85287937a159eb435d29782ae645015ab523e6397c7d3b854b115ce056d8d26f345fa30008d06f9f531ec3177a07f2b8fdb2fd2382f4a65db398b041b722d60fa45255e09ced328eee8931e28cb989ddec6f2101665827fb98b92a3180a8a013c08598a43ea8deaf4c15eef7754ee9a94126f3f66e2fd49cee5cf5e0f636ab8ff4695f4f5132fcddc59f93d9731532ea5c9f91bfcd11267b7784afe3aeb24d78d882724ca829be415892073899ff52923ae0f9d5c70979f9b4e36a9de487f489cb16dc2719e8a000f0cdf51732584d9090db3ede0554161c7cc5194492f3c2fbb90eac4fc4cd43dd55e41b491331aa05908ae4518677d242e09cca9bfd6d053c66f826d60c40c6c31a9305a9f23fa420564c978ced8a6bc4f8b603691f81934b59ee45136139aa19fb07b50a3e196c7eb60397c813ceac69498d7e3b62b918ae6c62b9aabedd87297ba5e2d5ce20404715b313476ce7d268b3c2d3278bad4eb062dd7d1559446d8c086e495fac0358530b20221867419c620b48821093a3937d108af27988dca557c3d4aad10212fa76c706753c58e263f24d6a6ad5fd06ef77b8258e5452c9ef146fffab0f96f702361c29457251b13da525885cb90375ed114098c67fc21482ac0b75bb1ed6c9ac33e8d2aea879fa6a320d033a1c697f9aa181cbe401415fea589a8cf4d3693b0ae06e30002607c48b4c0b45e0aa9b9b48ab23bda4af4989ddd9de6d3ae2e160121776162b644a65748ee5fb2552124a83849c974784ba924f651030c59821a1cae75477bf519ab0837443fd8a963626c1aeae2da506ae785eed347f41e428a5d63288e05ea7fbcc3777dab3739d4170309aa02e20e9f0d7911b8a93deeca897a5a3ecdd04e3d3aa43f24efc3af6d4d319b14fd3c8180dbb19f94e1f3957e54e096f38b198965d8baae06307bc870ffe35049b7653f556e9f3b88e00a817929c1acc62efd13b9602f797302366ba39b30015de212a6ad90841402a0784bcc898a31b3b8c283eb575e53291871ac7de5277021f961906bb3df41e87ac40fc93a1888c12fec088a7c890e9c01d3136285590d34cb27680648334bd13a58cdb00bc0ab8fafbe81173aaa99a9425317905a4be154901c5be21ddd07d428446b1a6145b9444263cd3c413621a4770220a4641dd3999fca6fc24451c6052605fb640b6f1c73636704a098a2f2288dfb513590a52e202b1d31c17e2a640930d44c5fa15c34e9582830387ab68eba971774c9e52611d14d9bb9ea35b80b29f62ca4e0d4170b3cd11fe04828b8374791100ab9d59e6b43be2d4a98f22934d5e8e271c044a97067817d76f82cd9e80fcfaed188e3600bcf06206a7a35282c39e8b6335bc78fd5a56b506136f143b21c76dd7fcd6f6ad7f38c6ba34d33512ac80aa93d7472984ba9c4c49434801d3fd4848af2b3c84323858649acc76ac984405a4f72dbcc9b67d6f5b71913c4992243858711033d122130768585e6847792a7d8311ab06b083c41d05840ab59e0bf2e0c84eeb58d8f6b2ca48c362690a88f421ccbb7f68f74e48920eeed352d49f3625637173077037d6ba12cdd33e4bdaf5a42a01e6910e4c284716aa9dfe64cbf19b43c69799f16b4678d618993e8c03f87d219ae52db632ed44d4be71aa28d436a2207212a8565845821da8b2700aff9b6bfb76badf8e9f27a8020d8083ffe2ab696ac18c6bb245f5c07e41875cbd348adecb2c791cd00b499f4a05ec4aff75ffd191ab30862bf232eb0937666af387da613de36967e8c8617ab8c27f238447e95ba1963022ced733e75117d4bb89fb003e033aa2e8870add575f47407008b4e89afd6ec022c25d0b4fca64bb9c633e91460868c0187efb448ecf246312648c3393d9f169619b414889f1d8f1aee5739addf70f872ed50b6551e05568797181e6e76baf27ce2a1863cf6e2d1d012bdc390c020d34adbba4b78b83f230ac41adabd9ceeda2310b58165b080cf7fbeeee8490fbd60e7dcd0a50400b61ed6a0402f4e3ec85785fd63ca73bf5b6ff56ffd6e48994c861dbaa5ca680fef7d49ee478f9e2cf2fbef107dd98fdcd49c4a906cfe89d82536e0fc17b28a32633791ef1d32ae8b8ac2665b315a285cf51e0190c1577b173d2d88c581ba68b52228ccf65d2483552854c4bed200bd42415a447cef9f375b408ac52a8a9fe4810efd634a394df6848e3a556e30531177d6b3ab0ebef0ee13cbe5b262f648169848aac0db7698db62e3be3477b780e701efb783b1fd77a1540f6e078ad01857cda8c7d36f239774b60257db7203b24ec7f38d59bd4750f1463f0dea795c9df244be8533b8df796af50de2c7d15edae0316cea58ba8b14ee91d7a2803e1ac9fa9d54879f8211dc8c5e9d64bcc9e040cb8e271a247a61136c463d5157cec1b259041db2f17af9ec6a5412de8482a56809da87aac2ef69175374c76966427ee9e89bcde82e6ebc4f5805efceb1200a5bd6f9b04e78a347475d7e0d6ed7255f176426fcd6a53fb8d232033a7e2d607e143120a9e3b03ca11125c09bb8e34f08d4c5e0aec386c632709d54759672caa3d082488d99d8a41c4f7b7745d9ad17202b8259c57110af7c17ea08828f0357f025fcfc8536769f6e4cef6d470cb047c2920cdfa35170a1f224932c3530ed8e32338724c18beb20944b49b439b346093bfa246325f9a93031e5120a6ca6b161134369e072218c38b9fe6bfe5a299a90d9398156a23247d523a47e7fcb46f2a29b06f9db4fec1e70053d8c1e9ee56d177fd856a9283f550453090f94815b67b9e333c7fb9f17d229c86dfa2d10c66b47670fcc3011cc897b1be1591e16791c018491fef558b325be3ebad702953acb671fa4ece335b967a82d8ca659b98646914a121ca984ece0e9d7a783d0e0247974573e1e8c3933a9adf4a080776aab712763591eed0a71538fa39a50342212a27da07b11570fc22e7988750ff7592ce4aa766797a6f81540124fc3aa4deba528b99ef2871966a1438dc342dbe1327d2f824578944d7fa9fac38fd263342149eecfbd67b1d3b3cf5ea200d657bc7507f570c8cb71a459fae31844c95f8e229b73d762875a059b80d67fa0962c2fefe3c6d287c21c116ae8daddc765e991f71d30330bb1561f0220687e40a61823de1fd9e3be28d9274f24c78a5cf81df070d2c524191c5b5c6e8e724939c2e4b724259d40edce42aba9e73d4829db520957dcfc891b05d1f04c0d01372e31c84b48fa9db88652fd7e4e24161c612ab0a627e23b6f2c9ce5549c5d60e1198503564004e1bfcb02ccc89f92597190fb51f1adfcb115a1fd762c761475f12c9affb95a8a83beacab89b86a726f8d1d0a7a0a54e486d7c019337ceaba0a79583b55087ec3f0a24639e23b40368e9bc932acbf1e4efeab1f863f8c5c4c757f989fd9ba57aa812828fe516926edf62f24981e23b25f08dc55b271f16df493c9a32e7a2c84266468de1c9f8af3d0fc883c1f7aa95047d6ed4630df2c18ffa99294b2a504ad00e92cb4eb7e1a9ade0fe52f5f91e4edbcc0a780d8f045e6395411da88997610814a1458849ecf7728550345dfaf5d8dd145d7eb6c29e5a2c5beb8af40a0f5b63406c16e9db8910d579a0f3887a8d922c8b485a91fd24381857502ea8c71a42d6b055bb67571e961e4cd65b293e4e1b7062be979a4e7f04530beba0d9e01ef2a4c4d1909bc1f011a74448711db45fe768ae7f1cc4901bf92c7ad28aa8dd766fbb5bfeb309dcb2dfa8b196b3a342683473d65efe42de8e8f650cff9344dd2f98353d157918671a426284e668d291d9a93bb70e90922c1a8fc92d794af98d2668e575f15c15573d726bc47b3b44bc2a034139e4c729d2c00496a95ddcae616105ccd2fe70b8b4a814074792757581a651ac6cea6d79cd39e02fd3b09e618014e716c95a15ca98311c1aa3b9fa23aaf4fae417f071dd1be53d4472afd23a5e159f1d808cd5a8246a220927c6b65d8bc6b1b8a6dfe8e53019b8aea9c527401518c3c94dee4c2495cd02369647c72e09e2bd783668ec1a85491e3497470ab45033045f7f87ceaf0aa8d488dc0668ae04551c60096560d1f87c191aa7663db1a5bf7da6f5b1f36bac54e41d3e1e0b94051d4ab70f87f1e99810918063a607f7b3ab4eeff7a2d69e0d115d8e63b35bdc74295a7af5e21e9772a45206a7d012879e881a5f7f56ef5bf0e25823716f0673fe680a725ff0fd3bb44fafc4729a4266e28d3ac0dceb069dbda65452a3db6f72fb860ddc4674fe17a5dcb9c6d51b6f5efc7bf315a088f15b03cb2b4bf3a99868b93e196fee5620ae316c26022a2277d3532770ca7d548d5ebf463cd05fbe3bcbfcf20e97f3ba7cfd5ae3ccc5cb7778ee0b192a3c9bcbc33c92f21f4aace867d0884f19bd50cbf97ef492e34343329f450356575716475872069aefeca421a435ff74271fdf3e88a0dff9faaf26f520f76a676a96821c3ca429c2b30e1086af6911eadf902ac3ea9a60262da1f602d5f15b7d65c67ec457e121ac8debf90d162d11f95b5498760395058f2383df406f26218d700b7aba5bb33519d5f0ffa1133d680d398bc26cc225d15e31d2a347957f83354b3a3d5919b5e85245ec9c6722a0060c5085b81fbeb927ccc956af743a81ac449ee8a6ec168165ceb925778dd40607a275d946ff975e53a29618e5d098ab02d6eed81e0e6fc8e3c3a66ab574844a98c01a26955ed9677a13c181a998c9bb7c0949fea4f9f90ac3a0671458dd691999ec0d267004978fedccf6da895093b0dbc5df8524dd9f9c9ba7b17aa87eee54f3329b20f5b4bb5df89353566905585dda006e679d3a3f791fd1950902db8c29c521d40dac9e9cd05f6b3720fe1cd07e47d0aefb476732de6de5af61daf511570f51f0076c4048afe27482e6c44bb89d37b70bce7fa4ac8ea38c7fa811538b11595598702564f5d4c01f50b3fd19ae47d049a4c12ed86c7d7d5a79df9cc14d362c41e104d1cc395d9612966c32c0175c1e34d11fe5e3c69da1a6bf24cfbfe633f9c3b11572840c99c268e0e54ac73e14b867103c810768696b228a76f176ca60a69597c43239917db4aa69da12928e638f72e201482432c3fddbb3e30c38c2ea4079c0afc60a8e3424b1d6e8b3b9f1f197289b50f6d0b8e2703d38870eae39dca4ee37fd7caa02e6cdbeb2e8a9952a76a6dfdf05521293c2ea5033fe10c51a5d8b384e9efe73037088bea3ca1203a61b4a12b1b118039915282144e633593eafcc18ff621496546e6acf03d5c3d5df374bbb9e71caed6606f8d8f77187a69bfab2355e966709c118db8307d016410c406014024e47a3b9dd3430703fe588d17c922c2fb3a9a1cea29e49b6b7db41031c6b6c6c72328b189c287b83fe4d35327311bb6b3cd2e6464ff85853070f882b2698f7c0b5cc137068df0fcb56bc9b2aa8c18ef0ecded6a183ea0e6f4c53cf3eeb9f404d6f7a16bf754acd05013562037ff779b00559aee64e39164cfbd5ebc7d6e590df4129e443a4fe18ba2c851d4cb877c77961260dc41775c145dabcda927f502d3e0b1864eb2e71c6d2157457b9a6deaaf424db2604c7801a1a2a4afa85c2f29a6544a04f31babcfdf4549fa168cc2f2d6ff144ad75d2c11a87581b0d2f56a0cc1f3029df78a90fdfacde1970a512897a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
