<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a95c400c328176b44816ac1f188fa45052eaa2d59f17d457819185ee28f55d4489d71777e494ffe01c4e967adafe5ce87b6e4ac78567b50ddc3ae81683bd640ee59916e32a72798de53df91811bd4826428a52fcf652f40f9101ec755aba1a20ed0b63dc18193e5ed81040712134e1a4175651a87bcd9e7bcbaf5fadab2ba7d58a3b23ddd57e2f887c8ddbd3585cca93ca04770809e3dc422de47f06564ba7154a3cdd56264176514c1d17a60dd090b5b401b035528bf174d9888f457ddeac737495ad77d2fabca2535715c11d584436ff9d0798fbe8ad2b422a5afae8e0523b54dff739ee068839a5f141cf3cce987eba25ceb734b0295405f698f0ba96ceb34815ffb0aff3a5ce2adf6ce10bda63e8cdd627a29bd405f279f796700bac1efa7ab592e5bac169d6bf956b4ae7bc280912df91b501fb1bbdeda275c9abbdee3a3d62395e5c42b657fd6ae9f7db93aa16665d3a8009252466874769f56a278f72219facc458f6df5f7a24730cdd8052772d62f7cd738ce06fcd91e1b1e48cbfbf0abf6db938856e411c0ec773e1d451cd7858c4d43d4ed49c521ef6e7acf87e337d8bf96cf65b0a57c7fd2ab9fb1b56b35d351a4c399f8adb524f056cfcd1f874cb8b30a8983869cca93fb98191a55fa93815c95071a4860cd24f7f801c8ca700a2ea139158f84048f144647b9e761c29599e61dab10eeb8ea38db496948776bff07bc7c486b79928e33b2213698adb8d336d71518ccbb9518ae3264ed38ace0d831ea3788b62cb317361fcc20ef7f5ca05ce5eab9af376f4ff60b16cca09481888251517d4f41d98f7d2479c5a89ca511ba43265ade15102f25453441850689d1baaea80e60d0da6a204259da585f0dac9fd0184efff73aee392cb3a731ac85cf0d65f90fe95cfa8e9a87fae8404e536d3e1b126405de62116bc3fd3b008ad80a072500d42319b8c9ae7c925ccd7ea54c8266fb85fd0813169af7af96f89bc3778368898376c2ed72e9f387feb2f79fc8ee8b8fb510e25e62c4ca84fb0d2fc171989ef7be6b36a0db221ecc8a0cd52a403824eec1de3355f7d8aceffd2ca12518d538c62bc04b3e6012deaa8cfe404b9a6628412cf0aa7d436091f88efc18461612f41114f7c5e031ce10294702fdeba4f40a35870e9251b6176cb46491c6e3b13cedfd492c24121a664bea0b4e061709e58648fa88748111dbbfcd36b5f1c0bb58e2ef71f3d99473d3ee8250c811019c32fc1a6723321d22ea0fae42c0a01073d5f8ea668dd9c275c399fcc0c435c1b38120cd8e4581c5b7469cb977d178fd67447cae45fe26c9257e8c3fa30d9f2a004d35441a3ea219197370f5e07d50cbd94c44bbd2f9043548a48d5027c751a424db06c6a02fc6178c8a06a358517fa7184c6c88b89f603096a22ec995f7463d1deaf5a59e1b26c4488b6c1d2aa4cfab500a77ea0f1acc44219e50ced3f4ec3e32cd7b7403ab4ec46ff710bc4a81d93d409f539e977bb8f59a1d91180e48cb3c4972e9588d44a6aae16b97dc0dce1786ebe463b05319c3bbfa5c5a10e4de67dade3ca9c2762d8ed4e55d10039c9e5d7851126d3f3f395ccd02f6df70e610f86100b671bd8970d3ad8f4a193949fd40d60ee581dbb81215b6393308e1b80bfce51fb93f22729216d24ff48eef75038507629ae8caeced631970690d2c685c8a17a367805a93dbd4db99ab5a8c01b65b175553fd6c17559f9caa03decfbf3640fe23f0dad5e7f976af473828c42dc4c706f7d844150b8f6707f3d48cd14dd9a5b1d1321034d2d7a41daa7630fdc12427ccbbb498fbd9152bb55be8ba60f6212286ebc7d97d27e32bba6ff46b5c640c014c6b7e8195ad929215e59da99c515296c1813bd5748f1ed271f09301bac78912b3e8c8326f2a10fc09bb2cfc77c0ebd6c6e504f9d464b6a0ece1200130e23b7192a4b206f1f47e0c18f3c52a0b2f3c1a9b8e7de7aeefbf97cc663aecf3fbbf64a3b48f691a85f0f7e86f653f8772b791ca2e4aa57e6de5fd6d8c03e98e04a929606df5cedf8beee6cf21dff4646481c39c761445003841826f274a04d1cf0073871b1d56abf9f871f4342a1be8089610825130fdce9d4ad56bf5e1d58110fb7489618e36ea94cf39e898571e3b6366855e672dbf05de3611deb119ca1479a48aaa937a934670af9d2b507b98d086109bf8f56d04dca1fbf448658eb9d91336bebc30998b367ad8dabd16456a8f672b34bd2352cef3fdcc7b8d727808bf47c6b6403f8498aa046dcbe71eb49af5d10f338917184a9a37b70e0b63daed3c8319a6e09abd99635c19112e0e7be8c2bec25a7197c05231e14fdae3be0f0ad725708ad86f56150c7821c707a5a4f420215a9579b33e961d2eca775a9fb0bae58893aa65384e81db82a041f7495ef9f31dc633802d27f209bf4174462e288cd2fcf226e25b7aa48ce6971972ed7489cd5425a61cabe39c35f30afb7473299231b7d9d1c0d3c0aa78fbe50e85851dfa272d40759a439e8db94f513598ed2574bb19f32837b5361a4d654a28597bc2b6aaeaeca21936b3a4ca22716c751b0dda512dca89cc59f01eb8775752e6731dd876a99bd972c85ef786e65536ef3c000d0c1ea2dcb7bf2aa0e9c97ae73d12a22326541abdf87e6496f1d3b72fdeceac4a08a2e317dd031efbed6e53966b50773465493f73d9d9b559c5e90b29eea25670249d7ec794b02e9f9f55784315e2c345f8a8b96a8c735232c666f06e3789e2f85d1711b170e1e24e4c266ce4dc4a5c6bec59404382e698af5714cf068170f8624f89ea54c4e2adb2d655ac2bd41c86c6dbcb4a4486a10589496041864d10459a6fba078612a8bce6c9e1ffa98261cf2e2e194ea915c967133fc476f83d45e97cef03d86d53a3843308d8e5432d3b349f57ea100ca39b23d9ada622e89816aa3474b8075c986763453839e658957b5b245e2bb2b0d690b303d76f29190f5c3c1dfb2690988230790c61b8b857256b23e1846dc4cd6dc00c0a2e305c988d990a5d8486abead3116e4a273c41fbe40cd6c4c46dab23a38c716399f53a6a4f1ddcc1518b30aa54bebf1265bbfa8024c7410c37050891c2d7a38cfd69f3ca2d0dc3d3737a5573aa55fb06a321000dc578418d4ac242b0852cbf26a140b3e32aa83b0c8d12db60c9cc6d1fea6a19bc86a43826c3452f395adbc1c51aa6686cdf63cedffe5a1e871c21f50a3690c9f1b31f29aa4750d16d1a24d784db785cbfffcdceb6649aba2032abeedecd4109ca2bd7a64a980f5c814a652e54de8aed133f62716a67a271d4833383c04fa61079e0d3b35f45143a9da3b08e32b81ca9a4c7f5f80cba23f0fdb5a9f6ee367f4b80ec687d25ad7598b9fdf5db6ad70d5aa4079783cf9d3faa7dab9fe8df8cea2443bd611b75e4c3cd0bad970dc2aaf89b79802eaf69643284423e51a987d611aede86c5807035b12cdc3018b9c373d4c09a274c9e313192a21a954f8d418f64403d63e96086981c5b7ce457ef663b1bd55ed91b6bd83245a5ff3d9bed9298eb51b1bbce7001162ef35ffb449eeccd94b60b22f86808a7d829203e861ea3f0f0f697371feb207048a5698f0786428703136454fbdb21d02f2044185665acb7bf55e3bce31190d51eaa3c8423886ba0c4042a892daca4a274321d6f19d138d3ca7d1f38cebb993a8c8762a1a350ceee6c00e9188f3124fed48aa39ad6b708d5d657fab1c92cab519294f2d3e07ff762d29735f96f0c84a0a0ac5cfbb6503ddfefb6058719a83165b0796fad0168cbb775c4165aa957428355bb36f6ba052888b982aa3affffba267afb97a0d450d2fbd4d952f775da87c5ae4514e80917ba1266087f2971c6a553d5e624cddbe7d9a9ad4ded521de42fd0c9b296aa04cc2f3b388dfdf3de73f5a7ea0da16709385f3a86e0d8298914f81559fd812a6d926ff06e45aac897af319cb2acff3d84865f0f7e3fd7bb0f61e2ada1a846727d19a57d1ab360b6e2995334ad84d3ca1c27e406dd6ad811533ff4e7a95c1d1251ad64e20f958bd0c0f2ad8193eb61ea22e42e0e00789bd228d1a1f8f124334f06d806293d6787ebeabe6f24799dc5f2acf5d807242204896cb82c574a651cd24c8477e8325abca712c359f3c91497c3fb5b6d7af0eaec6c6fa257537cdd01a79009e511650ba98d7cb553a4f564fced56dea76071cc0424736fed821c40ffc9b9f8bacbd97d8337260e9e866c5edfef558a04a3e2cece1b97cc916ca0f0b396e99b0ec4a64050eedf031781a094ec2572736cd6194154633c386650592098b18c9ea9457890f37806a82ce10ba3d8fb53073f5ba9376ecdd1ed793d9c46d52e30ba4c8fdd56115759969e92aaa0b791c971c7f924934ac144547d3a95191e83e1cea1b5a811db993859743821cd129869689559d9db90ffecc80edd6f1a8d7eeea3e277c09c522766d9edae3e5c8243efef8027bdff677087d931b1e7e2bfacf7670ef4ce2932981dca2505806b5f3895077d47ce505887f9c0375331ee54a5a0e8dc6eff600f695db2399204962d55e95c25d79bb5eacc35c6655d796f561ae3aad5bac509837c18b5b09b6b6f8dde2090e9b8e47f743f1137bb797d9fdd9057ba05e549b713c218440da4ae3243669948e1b91c906f1e581e3e842d330dfee6d9b78a7b011a7e12f58965b9c81e3ad811f5dae039e2ad3e0f78efdd640d32b53d8a61ffff6b28b1d542b8acb05b990b0097463d1ef9dc889ae7d76c1f9f037fc330c69f0cdd679ef8f402b146f2a4a8e3942ff6ba3166f30d0a98e369539d1ac1e6ccaa9a3b8d3a4b4596fcbd6cb6490b7be0fdd5c98257be9b6fcc4e0789667be36c36cfe8daba52fa3718c66bb6a984e915e8e5566c126b6dbafb54ea54307109144bf2160404c89e33a9dd8f1e84805ca31d102be25760205ecbfc6632bddf01a0353d70c57499bb58ff9156822d7dd9bb597ab6f1e7f4ab8ebd44b9139c6f008487de0e6487538a32ccb15b78cf5525a038177fbaeb5ef3e1feacc31fe3bff476d3e02bea0ce84406a4fd72e830b49f38c536633c4e033df2476fe5d365dcceb84d0cad22fc60a90ef909af2d8e2eedd59372d8a5d8f2dbe7b88a5febd1e1b50c83919c9ec65123ee096d5e9922a1a09bcad0d6f9d04e67d435d93aac49c3ef3bf7b60510d183b18ed840fb55ac339607e7b7100bc7fb200e4d8bf90f05866b3b8769c556bbf19ccd30dc34865ceb589c3215f23975a538f3c8c5749c8311e69299e5a8e1fc414a7aaba4cd6d089c032da8e46703f3ec5df51015500ad67ac90c93917e8418e2c6ed369f26d535f85633feeea64ef98478dc4fefd3685c0645d88689fccfb49fc9da33130229c97b3a64cf452876027245fbb64a10b38d2c2c9b2168c56619230bf35f16f6b3ef94fb88294f06d7c9d3696bbc6ed5a021b239b05d6f25929e9a1b66dae14f0f20903b97731dabd792088221d17dbbd53d9ee8eacb86caf0a5795c0f2ee01cb5fdab62b9613a06397cf0be1cae037fdf941bb5410dc54a69af8444cf821d437ede236cb1024b4bf2326bbf22e340f9f72ebe7c8be19e64170b3d13a9178c942a5fdc59b061a22b2122fb4749bd747cbf178cdae1123a9cecd62609e59cfcb950170abc4923ccd79e94d17f72ba643c427108c1dc6a4f34ec0dfa9094f0df8d5b48cbca58b357a90cdc9d59b353120f02be017f879dab70978a44d663f94151983bf167b638a49c7c2eae8de28bd823743c5b106fdde03f8eff6cea2ffc5aac0bd55655f983a5b667f8498a8e1d764c66f48b8db21fdd46e587a7d41e6df386024a309df84795b40a629e892ab3e12eb5298850e3afa43747a0f36cf5a1b64c8ceca20bc04c248ce01d92c537fff2e6beba7bfd37872758b19998f67a2db2a12a4653359a6c7fe76029d004c56fa89a74e5dbaf9ff2268b79b8858a64474d1e4684ef72e244eec14b9f3d27796cb81723c8ea2229c7bd1afb4652100eedcc87b6993516068321527a21f1bdce1d9139c16f4259da5abafeb2fba3cbff328c001831283e6e3d17eb76020c4f81dab7f7ae49369bb2472a040efd4ccbeb4ed87d9e4d2a67cad3e8b3a4034560ae249dfbce55205211bc1afa04a787f7e23c6cf1e0854d17f4c4bd762e91f7de76f7f109b8cdc9d307f0dbabf327ffa9a35caab5ae6a18e2fe1c591b465c6a82afa671f6eb8d9e9c6acab0e4046a7f7a3c425bd9bcc316c572ad68f77313b23992a3772e593fbc0a519eb8894f6c9e8ddbe4a3d0af337ccb1ac825b93945cfbc33de5dab9c6dba666e69c19ead9ccb033235f691f6001842caa3777e969a88cec46e87d909171a7e8ce999ec1256d4b72ae2906e5cf47ac785dbf202556a8f9e194635a4b27cace06577063def990f12294f4b1e2c6fa7bc8eb1dd24fbb5f4ac225919da06573d2b7a52fc34078ee0296e6f714874b7aef6c7e0edbf1e001e12a707b4d2b8f481de7b3a0d1d88ac8ba8e584a9d745d4a115a536faaa3e691178f99108411b059013b9d3bae957ba76ccba57ab6cf87c4ae0f5e02df8ab6269676e792c7f710b1229a3c7dfd2a328c124adb6afa440aa492928696a932c0fafcab261b1052bcaab9a1bcecbf6d2ce1966915e0a50464a9e47fcbd1fe99642f1eaf810b775535c810885605714fbacbf52410582ac12fd19f3fde2eea6861e7f356583aa8fd8a2b675c79f443a60a1513db694b1fa5e85996b2514406a1cbb60e88f16b26bc0d13486dcc3e22d60c21d890f5695dc8cd8ff36f85054d04ef2e17a7422223188d11bdbaaf4f625d88ae28de8f2159457577fbbe49f7fe40de16a95321af3d58efbd99e4199888508ac56c9ce5c50e1f26733bb49adb111e0bbaee0627de6f68a29381b74f27ef8ad1d0632c82f92a4537a9e1eec77a4516e58bab313393a41264201608f90ba95be18a94748337b79fa3707153fb745469b1dd6e422b434b2380a99ad505b006c3136b3df8d245d1864e5e0c91b7c4d471f6328d3ae08adb226f93093c26a09c86d2421f385a22e88515402817c616191ddb13685fb608a1a4f5885d34302011875c81ac3ff3f9e44dd135764804b8a44ced06f6daae17b0563e3ba3942cb2dcf3cf4cc0556dc97d25f4d22df83b1da6a085205e7bf48393b41585c200ea550190389955c4fc69693ce43fa472e7fa8a07cc6d06fcd141c88c42dfc7d4a3ab5d8e10e3c71ad55bc5fe774a88572780060994dc097bf6d967ad024e92f7577f3514ff228c72eba7f6511ee548377f4d7be13e634f0ced36eb620d50aff7e852e60e7c1545b499dd2e7cdc96b7015b4abea4278638df459a36585729fe404174e14737aaaebbcf551c7a2e07f7507e69b1f4d65d292dbce6e17b0e40f06eafa5453cf928a83a5e3bd68f97eb433b44c0b35b5f3e44edff09d988f650bdea0ebe3d7ef73b5a4c595312b7f900b2d8023034d26c7da4c159313cf8dff4345e677cf32fbc09322827c048f51247cef91897c3e9761a1d8c0ea46ecc00618b8ce5cd2161b2ca610b65cd71dccefc6c5202ea941688021328b29d7c1fb7dece15978ab712e47f5a24baef2578a12fb1a02de0eb1af63473359ff07c8cf35772b3d7316e5d30eb52d377ccfc3b1052629de17cc8d84bcbfd8d50a02b03f488a5c5c7eb07b7f5ab596b45550d7406029a829fcab3d7106fa88605648b17142a100623473aca85349429cea5131e14c70e5f53a5d4623387c2b6c2ce67cae7a482bfc0c8d5b352b3eeb94c7fc49a614461890b713f326904ccce1796a62e9286f7d255f58acb894017fa6aa2bb749b07f17eedbdb0eb4fd1acdcd65694b5ae5c1786cdf84e35ad45f5398be97e405e6942431b9f9f692a6e9f535dfe679129b8bf1d501bbbcf3b4ab442b3c91c1274dde49895ce6d49e91bde7fd403893d41bce873081ffd187dec79bd23b4d53b7d75dc6bfeb23b6fa5c5256cb8a6a8d3215788a6cfb720de117fad97f56692b637c5ed51b2d2bb4c591a8b4dcf88fcb79cea634f03be69e643b089888cc4ff55cfbfec336a450149a875cd3d2d50af9c66fd2c232276e20928ab2d36d29d951de019bb97fb348837832f8cd42df1b8f4faed487771d8deee045ae30c140d730c05b2b1b3e12d62487615fc09e7c99ff80208fd255c515ed429bb112605f5db8f8780c36df00d803399c0246ec65467650e0ceaafa1c76a893c2f2896992439c419b88c029da31e1afcc863fc24d5708001d7e9a1c25e4313b8672d77813f570d26647d4d65bbbbd494aa0e73670675056d47b62ff66a5acbe079d854a0e1a7d38e897903a3f9b25fb186dd070426f64341eee67f453ebb9080145f39740f6f84424a096dfeb1e9a1add176bc190024ad07d45d4761357a10de57f1685d875869efc9ee86f5134dd09e5bf92ff20890710d89d2c8f0525c44c9d8f285959182ac6eafeb3edac179654acf8d2acb3c29b4d2c48da1316018e6da2e9666f60f97f0b2744c2e4eb5cd96f7c25bd46789a62b17437e904c233dfad84a7fe39e8e2f86b15cbf80eb318e998df3d64b4dd8d217de5ba4a3594ae0bc19a03e75836111eb4ccdd92a5f3a60db84f86aeb28624d4e985c1f2af9bb55009b9a9ab6da2daa752562a0d610bd1d75ff9e9c9270a5d6b78f5614573640a81f3c9e692474f217fc8709a868f5b41481e365ea27953b46e85a00b1fba0afdae85da336a8839deee4ea767738b8645603c0f65e24fb295b95bccb737b4682b46efe82d12512002dde4e5272a95448cceca310f066569acf1a57bc9acc90c2b8cc45c9560083a2a34f9fe910f851c8edf969b052afb57e624a3aa2f65c877ae78d23d3d8ee4f6256abf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
