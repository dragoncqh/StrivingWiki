<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2106e10c18168430e1050e38f401429fdc96ad72113811e80a60f08e86224105910b5bc40976f0f5a76169ce356244166eac7ab00ff2e629c4ce816d56fd63d184a7ffae6f36d5f4c6da623d8ee75b84f757a1061dbcd73793193d6e528bd405a953a4dcf5835558f06139a72fccaf2dd3b7856946b89afa1050b0002b632a08575e0d4f891353d36d980b3d4528250314bce66942f310443d9535289edfb6f68bef79a14c3551be00dd216633c1d019ec516d2cbef4dbb90d86ea559824a86d8a20560858ed20b9fd20f57b89717d05f07e55fa374cfa35052932a2c0748832de1b2f1313683aa0f0a3aa44687baa3f2c70701cdebdaf5a0b984a409f59db9bbc7575fddf4b690fefe3d71e16e41f0611d6933a5dac7414e694f3f516132942237ae6a6bec78d6f010cb224f344cff4828f348de8912efeffa0bf7edda7213582a6c63908bd878af1f15b4bb9d63ae7851167b1b682f6801eb0f8b1694511457094580b263d63565914520181a3ca30e632b9841c1d109a204e0e3cd6d42eeb9ef163244a4998caf4c211c76c0e59f867d95eec9a4d00a84897de62e77131fdc35166141ca5eae1873b02847a748f93ed6cfd0c3a04da103207fb49cf5181813b52cf71bb8aa6b7fb3db0d9beea60aa40e54cd4b3c2df86be88d3069a4721a4c64b5623d6e00692dd652210489d158be4d1f8b3c95a1e28f8007b98fd8213a5ae896a943d051092fb2d28ae7d524072614cb19a607fd23f4fa0633e1cdec25ff70d756f04b88e2a3af6949fe80a8baa83dc7539e565f6b0a5b8fb40a3e6368519ac7bc6e368a8d972dcdc36325b98d9e4e102dfaec2ff7a8e14ff2f52f5ec5e17df94825f6bb1af26936100490eb4afeec1354436a8927acfa78e04395a470fdb95df8b6bb7c1dfe724020fcefc75cd6f03797a4e274a5a1bc22242bf71520fa38668808017fb6b9c9610098977ed129f4f380f5a0fe22573a940ad4773a2e4b9c6e365d4eee2f7d4815ed3d48cc45adf60736e74cb81e9d47393450f9bd5131bab58c5e56c55289f6731bcc036a87715a79ef6428e5e7521e6687a6c7bd275f2f2689e7ad2066a8b193edcb47a8a77e8c22e11a9c07fd07c1fdf5bc8c0fd7df427918dad0cd011304db9fc0d3be73b88076a4e732992e25767299d59dad2df18fd59c7db53431ab77b28877a323d4cfb3c386911570a4aea10fd5a3a052c20d1627140d750520e744b1a470bbab9d322397f1e13210d4a7219db5e9f6b707d032f35b2079bd1a38a37594f2d9fb227501bfa2ae175b2e03dd1c47f63d0b049ba84901bebb55dde14070ffe6d42b17c3ca914ff1d73cabe1fb71146b4705546c6590a1e5093cd57bf0c679a29f6f326eb36d33d420564b89debaad2924217c8fc9545a9157ba2139ef40f5dfba9e97e0e218b116c3e16ee493b14fb103a139c7e69d76902ae71fdd39d523e2bcc7e0b8ad12ee012c0fe64683ea65fa106c05b8fa4d2a1774f772e9c5356bf57fa1fbe071ea81883b18ebdcd9282f944eaca20eb879efad0ff1670deffef7f796011054bdeefb9fe5393634494fd7961f9b17bfc0df94dc38c789d638f3b55ed6f0b8b66ef162d85e9f9638139b670eb784fdd4198823dd40acf35a9fc3e3e619d9a187d089af5dca15d2a615f53847c9678d5d0d960bcead7b2f67c33eb47a47964bb46b30e8ffe1e029f89a9fb568953f4aab81948105e5c7fdc52ed388c5f0e0928c23512f649993a4891e4f8a2db5ca5329032f045bf3d2fd44b133aea7133828cfc4fe238817d4b1c9b6f65c0128ae02519fe0feb691051881c683c65099072694d05e687996706390ebc108facab48558b42ceecf333a942a225b58104c7aff3f73a363093e0370ccff93e75bbbcdf6236f149933cb102f4d5a4f33c084668fee55791bede96ce62a17ea3d085276acd22f6aad519568ca73bed9bc43f2b7d10e843900fe006eb6efb5a173dde874901f67eb5a5cd8d249da9949ba7c7286f6fe6b9e70b48d8c11a73340fed9ed9b3948a6bcbe1d8a3af49554683bc642c2c9f005364a661006fa2cbe6494fa46ff946201db0caef65d6bdd5f86a89dc39ec85fbe007a1f1ff7a0d17e15493cbea02676ff6486f16e951393337f582a89f5517fb451816a6120583e1e3cc65b653492dc6412650b7deee68f0bc81ed46200a86d18f24c3c9d35220133ab7105a85b159b7db8c0fbc1b1a60ee3079ccf70da1637042d1606242d7292828857bfb324a001a269998968b97fb6e9388f43e4f66b58e6adb30df324a5e987b6d18b07f32c7a79a61c185ef25abcb88957b66685caeb5853e3ca6dd9ef173b6e2775abeb321f5f2f68820b2d1b37e630a83aebef7f9eb417cc7a7da0bd0a8ed252e01bfb9b6414d0227166162124389e3ad4e101a1519538e58b5dcfca762bb690285c30a9f92b8e5eb31b37e051770dbe6d490de011a70b6c250408e90656a7bd3bf22f05068de2bb3260eb118c87091b43d9fe5d446bfc7c78812696335c5c3e77717575aa5b1a201f6d8ea7b01460a3277f8e3560361f16f86c3167319ebfe5edc7c70fc270fc4af4d27d65d20e8ba9d11c67dcdce34e77be2ffdf1f65830968851716188a5209f52e29912b77822576cd218505e890e5dd56addf0602dfef155740ec292a450d8d54604ed2be28106d837d962e5731ac664af7347c493164b38f9be36af0527938a5077583dd9bb4af8333c5683b6218ac1dc58062df3355b794733ac5a9c2b93d3d8ae2e63b0649a0b0b48c184019ff0624b261624ac74023c2f692ffa3301ddbde517782d7c9148872964b30a2f7842715880599f08c595743fa362c79a077a225292aec5bfdb6727e1c8c021b1691cae70ffcb4d36f1136117673fd811b86fe9d4227bd8658979ef61ac9e3dd3897bcccf60381bf7d1aaf96b9b0bef596f594e469a9a67e2d62a3d96ff5d0173adbe99115855cbfbe192d95be4197a214efdfbc49c0c278997c040325681182aa53f16fd6d7485b4be003550c3d8a4b0ef7cd754c2a1d78455369994d404855f504bbc8e928845836629f236a9dabf2fe89f4d5c6ce5715dfb79c7cec1493599197899d57803313c9156e9a0fca61509363ce8e8f8de2976869b94e285b6843df288140cfb4c56169e86be74bf12e8120ee9d89c3ed8db56340e0c75830b420016f5acd5f260880a77d36c7126479d106b2186b68c3cd3b72084e86b68e0dc6e8c1cb4807a2e271cd95f8ba04be284eefd307fea1717cdc85083b98c19eabedecb40e1ecfa4830c58375ba1cac9f096efe87e3318fbbbb3639127c5eaff11c762940a3035e5e345c93c58e3a4f9e050a15950ab04963d7cc2842094d207ac3a28248665576c972ca4075703c2d8c0fa65005a9b5efbdafceb89e78184e02d2adfd76ab17f6237730d40935757ca8b8c8baffbcc755a74033688cb76315e18e507661bbd2d2e051c10ec9ca44b6596cfa32754e0f6ea9e5240160e20176ce10c03ee9d53645e535ac8d80e7d3275ef25c3ab590848c2c804341c7a9c70482927e574e5fbdbae903efcb76bb4c9ef82142cff9b3c2c837810f9e896493a19d97fb3f3e5cc4d37841b1e715990eefa8e800dcdf71710a49cad8fadc0fdf8bcb49e34b1e444e4a8f9bc0ad49c5d96621683d745ebd524ce1543540058358ebce5633f5edb7c6d81c6b909992fa8ef5414c49802b066b822be9039e30729f100a4edfa9ccce13ef6229479f7729780339088b3d693ebd5cc7d527f72acc4dd3de3d8be16988b3b09fc3ccf702b8cba1f466cc5aebd6e9019273a0c21b63f2a1fba916b98cde56fa7a6ed7a38edab4757ebb10d3b95e3d9c1810cd2b98c5652eb5ba43ee0fbcb2702ba9553dadd586a2b8805aebebdf63cf96ca45222b7a43055cd611c78aa4bca2b1dd7437b963b4f0b2c4d26911453678261b578f32e604b39945e1af115353854299cbecc6ca23db612f2956f0ccf4331cb09df8cdc34a99d37c2a155243882407216fb4d78fa55a7559133ebf4e9eb775d782e80dd582e02cd3d992eaa502c0b2527371ce127a8f353cf1a9489f41a2cbe0896beb7252120c5f9c73ffd3c3c3b466681e755c9c21b6275a6a40fba451bb46c13a22e2873fb6fc97682111234966d1baf1042abb470771ff55bda5407da5f0509f74ff765c4a065707141cf83d14c47681e32a521b5ee40b979ac5b6fe48caa1416cd59722b9e7421342f7ad7bb8ca7d6406828b5f70a4f047cf3b1a3e22e4e18367d6aa1c51466a2910f0b45ca25079e8662cc8c14a1e007555d9e637f55ae8529f08cdd062c580a338fc9822cbe9d7063e2be0e068de2985ff8dc746993ab1ef49f6c5fc317853f2f00f4cc3f5a5796b20e7080ec8ad2ef6d7d4c9fedc88a0751f7f80b18ce58bc1633f6ee6527a142ff0f12a35d5b4ba4d56b683d1517df56ff1895d29c78e0a6c8b6a1a6450e9f78f308ef303369ed7738eaaf10d86ae7d810e410808917327a62f369215e43590c6bdcf08451052c93a2f8432789e53488a205cba104d94b2026b035ee7137fa982a733b3da1281db56d85c636d002bb86364e881c28e3b5244108b05c20d898c998d03aa28439c2c71218cb0af073824d3ee0788d520e3aaca42cf402772de065f90b7cdf8985d26c75fe9a020d752e93566e8c4736453a9842540350b40e772d7b4e83ca412b5fe42b004e6c79a4476dbe42724a075d38edd5a66be4109aa1b972d5bdd969ee959f6fc40a501e888fab4d3e774da2007260f2d6497d98cf1b336768cec63c85e4b0b595b24991312c968602ee2b39aefff1cd05e7651a36475a1f58218fbc1bd7ede0663a6f05d4b41126dd43543f6768d0fd982149c50b0d8f6355a5db9ffa129c587bddab2f72a764237fb3721842fe136680df4260e5370608028d11d6f5e23a690bcb20b90a4ab363e5cc4b66465a7257ddfe91b7bc95ba4babea866b055e674410148c164392ab467f344ab957a26ce2c08659f019300fc9c170f3a3bf9f38840c64a52831b6c2dfc87b92769aefb2831720559f4bf2df559bce28df1f5b720b68e55cdddc033d95b5993e1031202edbb6fb8957c27d0ec38c88aa5d9e4cedab482222bafbdd796e14b774add03ffe772f9188680d481d60d950dd2c3d5c2630bbfeb112c0710d32936aa85a3dc08a4b5e301431122357d57d11f18c875c4972e2aeb0b439d9da85ffc096d0d7eefd7d4a4fcc62ed86bb03132438deee3e3d8df40008ef98d57a398e092a9cfbee62e992b1de3e076f9a9bc1384525fc4cfd043032c3e0e3641e66082874cdb38e554cc4e86f3083913c20752fdb9114e1d2245d2045ff259a0e6dc304c0268721a28b57f84503dfc1cd2910a37e9feb85eafd2671f548b97a7e69b78077e327c1ef62f2681f562af741b2f26e5d6d20a8d1c15f52ef86c26e65b49e624815b59b05682334dfa5abf167ce17346849a62bf3b6481d27dde784c39f85fb5356a8be52e3e5c5d392bbe1d271fb7f1ee016b1007c7f2070a579000cddcae69a31a4c203a8407d7ecbab030ed6536c0f0e49761d1977aabf99ca2f0d406839a1b50ddb29697819cd0f330168f6cdc25e148cc9194303da2a0eb86c1a53f3e825954ed91a9134c9aad527c4fded5fe3defeae7700e6c51f22578751e5380caa2a37a140138b06971e90056e720dd931c386fcbb0f6a5715eb0241e25eb0ce1c94c623942c7dbfd4dab8b3d5c75b92f6f83ea95b13357af39d96d98f8f1722c7c76941caa68eef352992ecf5d7926c9a2809c561f929c84846e44c8a12b3f2e4ab428589a5aa327103e278c7c27141fffe4c7966bb05a0a352b2e027cc539f06984b195f852dcb72b63f9d449b1848531de1ec7603f2f082bd4c4e092807b80ad63866ca345cc635bdfede3fbb15c4d15de6693d7df95b125e902b5cf831578d5b1df9b00fe9f664b10c0d180317176bafdbd1d5122ab234ab9cb08e9cbf6d7570825375c71a06edb763d2ed4957396072136b7d66aae4a28fcae4c02452c696e8f25baf5048b81f968a4ec42a55eb58f6ae071b3e9d6a91786f3b84350f611ece642aa6427960780f865df07d13a265e2a3030fe4a13a381e372989efc6d4f05aca071eba0adfa14170fcdb80d53f3078a4119b9c126c1545b3201ad4eda62ec1eb15201877af0c8c0502923850399910c6ff8c30740476316e5f9a2f1af7c612bd0250964231a7bb0d609e23435c3ffd4aec214c7d0ad080d41ce88353f3c82e43c17b0d4559e7849f5c339fed7e88901c2ed06766b2732db37428e1c538b18fafa2fbc2435e10d7e442518f7bf9f3785317ee00d26d5218c79b682ad26059387dbc0d70447c2b47d762178d3e0d5fb930ff4e563a6911d403340e9d1ffc47e40e5d316218ae24e52443dcc1c0126daa088f5ac9e2990c54a5102b2cd54f169b34c912cb79094b21487b6d085755124ed2f479a477d4035c618f16ec23492fcebbae573e01ce1095bbf111a2e891b24e3cdb2ed93253867d2c14cf27f4437ede41eb4c6511e8e8ae95df857cc7bb3afb8d9d62819a0b42f78988f4f97e360d9853d96c2965bd8dfa50945e23723ffa6c8be6f2e8b049940267d33cc0005aa52722a311a573f5b0f4e82a1c4ad3f11beaf0ee8464bb30ec51d834cb4e583542e390e4da57708ba281ba37e010b213f5468dea036ea5000a2033d87741a54cb25780120c6b634b23a6724959facf716d227ea4a5c6a0642e0d4981194e427e8bc3e2454f0984ee8c86802159c9630272475ba7ed2c80a0d733d4e0b0a96feeb2fdf080ed24f6ebb966996d2e1bdc543a85f215fee7bb2c9aeb0ea26467bf0f0f53cf81cf06a8496ecb621ef25fa154e5067ebfb0b05a315782f4540719bd3e8ac3b93758856c203a2e0b9175ab499e3272453bc24e94275842bf07e7f1a0c1d427da11e8008fdbc2053cf43e6ef9061ae96921a90d07a810650a00e7602814556a2d31363a7b5205c7052fe5b79714e58b5b3c7380f4d7c852c0b33fcb38939c8257ff3316076fc50a25c914e4ffff7ee95e0553292af01300f8002c3fd26022b96644f46b04ab63d9b45453014dd682dfd61a9dfb74a3fde42b086bbfb94bddf85bd1fc4a96f1fe56395f0e6b5d50a7b3ce43b971dc4b87247f4800307154ec1379f150d621b726a18017a7115054b85fe269fc55eb7ee084483e52d885387c20f61a8b902789cd532ea2ab9295765fcbbb3392f849385775abdb1e194506f670fc8245c4f7cdf4501f8c3ee482f832b302296254beb248ba37cbafa7bbabf813eecbceebc269524bfdf4bde655b85a57ed44ec0ed758a22ead2f370ced4fb7b930c51dd8bc7795c78c6550e00ecff693096ceda89213fb6ffcb41e6c0005527f862f6f975f9554897a6d922c039b749681e264ae24587dcd864cc46e765b8fe7681512cea7e5aa5e03f22eab0e489a319468fcfaee84c1f038eb444a0bbe68e69be9cfb58917198738ba7910aed03ded11a907c0cbebb1b3a5012db0eb66330eb41818bef765056e6ea8df0f98d89e096bf6bedca0ecb14faeee98a59f11a28bbe2e0dcfc0660b371f6b6b853dbba6e55f0be0a4c413970bc2a63c1d0842a6485697560b12993bcf6b370718cf5b88e17608a916bc26c342e73333bca8255eb2cd7d2b7996be9a8ca201882f4d64ccf6440d78de33b8b86af81276e142f30ff9f027b02327078bb5d63bd06df71366fabb81cc19e07318375ff7498680f39fa728083ab6f9fe03cc4744e6a8f71634c6509fae133b70b53bd81c289760f91fa2dadf2e1c7f7bcd80a984ab234d19b451be90c697fa187723ce12046f2a07e883b4ababcc7a207d695fc65789e1c284e3fff00a74e8950dd13dd63a1b3b8bc216960d1495636c678d55210498d4331cb4247977be3f99092e3484de90f04b6dacce9954048cf3b37c33c7b37991c0da5353b320895a091752b2eb006519113cfce713f0fa633f95cfc3eeb952cac129bcd879509668a159ba1943521e028eb0299093166a5d8e73721ad39b5841c04479b3a0834094f2d351061be52f7a7f23c62bf28b91f831576b0e70360a26a260996f56c1f345e0579dca25ced436f254bcf6ad63659ac539647b8de245c542dc67f862a4e6490a2c86a4a9ea7903833d19a9e06a5c6a6569df22606b8e6e89cb67139c5e2125b7bd10af885a244bf6cc43673a1538465e994cb733a8a8129c9a9bdf24ab41bb07633dc1e14bb51dd76a6a62e41bab345d1954d7358172107e2e0397b6b2241d119ac146f1ccc9d28d4496f4fbc2a3ad35d775d5472914cd596ce3c9ad845c115b8bdcdc80747366d79d941355d84d24173f44d93cd26eb181275acab2a4a0cc45d1e9f84eb60137c90399737b54e23663450a92ade9f53dd517be49ffb4a482b7a78b2313902595a8969c3d7cc1c3542a8fa62001f42ff066f73b761ef74272adad4f45779b0fa1ef5d8768f9c3a0d0fb54517f62df785a66486395bbc719d58aa5a4a8c32f076ef9c5d6e2685f0941715dbe46b75f5d162bda734005a5012d0d6f1088ad0e17b1864b2cf68b2a08723a08352eabf891a764284aa782fadfa113e9bc45d7a541f552e24e4ed4a9bfc16dbb503baff245b7bd6bb8b00035d6f1c88ed7fb57d37b952f941ea400ad26636ee2abb7b6cab3c09796dcba04d3e736aeb25e614052b0b0cd70563d8c4c10791737a550eb8bd525a1e52a454c194920ad6e5206cec89d4c7c8af8a10b5741acda7148d7b16a0fa6a8a740662e225819d3a186789bad1f073b23e5fd7e801a248b8f8f086b6898eb04309b5c6727ec7516278fba165929e68ac7812480d10913ecff69599ae70f252545a72cc072d6dde74eaf630575c4d7cb6ee63d0cc9eca9a3b7a35d48dc8e9ffe023d4a9e1770aaea772bee807490437a9c725cbb176b3f966137ccbad778d05c4face47bb30d72e0b99442912bbd99f3f6028697093a75ea160407d5d48da8d12df075fa96249475877e5e994a44b0a5ad060fa0e1443b5025598cacd6f71177e84ecec883996b486429b66441acdf28827923e1fbe7c6b95b78d8d36f563c9185435a95427ff5948c9f0d057596138df147159d36eeae831501708be9acab6afba5861dc1f0887d6994225ac2220539f9247f0ae8589c8a2be0861b5f6eaa76a9d62c8c782024c988b62f48f4ad581002d387e20a26d661537874c2b7a0daca6623899e924de5d78efdebf5f94109e60b73c86229fabd95412a86b46db9cb7b0aee3b135f3a600fa6591dbd82de53f640ddbf9bb762b61a382d285c45a70411ecce1c1d4a7950f572d70edfa5b80727b901708dbd2a966138baf763f15179820d09518eaba138eb85060573211605a7279e42f47610a0b5d8056f6b6f9dc2daac8ef7e852a5837f77893cafef825aba8b062bb3e9f54722444c439fde98ab7cfbdad63e301a9af1d9275d5b61e79b732eafdb81bb3220c93220463d29a368be553fd75f8fbbd5423efb2ed28ae3957d8958c9499f3714b4673c2abb19eead56285be732bffb85ca300a77a45276e30b73aee310dc4fe31e67e08147f78ffa11ef7bcca329e1d08a3a69c07c0d54cc0f5989ae652e49c19d7daa6b30f9dc081ce9a87cb3366d6f5c8b4c7ec0945418dff49435dbb901fe3a85cb52709893e2f60979048e44a526b334a5c0e14b07310bb18c2d14d9e57feaf3b6f665234f0f188a7942804996593d5d88aa83fd40411f58955b881b4bf6cb03b1fc40c9035b8862388e5919acee80b28c14daa4f800fca520197e904ee61067618d360f6fa0b4bcc357789f4293ad3d22972eba271edf7feb25daae2bacb604b9c6b3b87973f4321f1552cb378334144e84a7c0bf6e948a6616d8204532e42934d8a04b97be78991e0333077770be7856aeb9991e392cca77249359e76231a13c6a16f4b1c55f619c3329011d8418ce6f08797c13069c83ec50f399d3e29f4d2e080f3fbab7b9697251de8dda32fd549b7909d23afe5dfef78dbc69ee8d4dce444aeafaffec20222837f01ad9102d9a0e0c7796694506aeebf3ec41eb2bac28fd574ca5f38ffc7bbf2f1100c0b1f1a21a148ef3bb86b10bef2d46313f960cbe7415f2f0f9caf38726e148761e414884731f8549028deeaa9d8dc110cfd993f837d5b86425cff670e1e0299c3295ba55128c33b2349c655145fa05f77fa5275393a021546259f8da6965dc34dad391b2860591f562626ba1358e8f135486067f8a0b0632bed8f921920748cbb5cec17ed0cc4a7358e404a2173d915af9112f06e4afe643b9e78493353d12098eeeb9f95fa45218633580e3a831492406a52bc8cc4353caafdaaae94667a8f83fe2777d7f0aca83fc1d0bcb6be8b563afc93dfc3d0546b39b6192a9758c4ac77ec9d98ef5a2b204e568431a9655934e81d581492806e6c721d7937b34777f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
