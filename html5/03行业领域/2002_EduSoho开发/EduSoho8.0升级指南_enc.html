<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b73aad5fae2a4a84f42a1407f91e01e1c50bb7e8a47f573b780635dad5063b19f1cc7b54b5cdabaa82ed1fdd236fae349ac4498a09b7859b5a7eac51bdce1e31fab39eb71c71f1a2b77b05e36606c84968496dae62772027b7b86409fde9e138df586c990202ec37d5ea3321e7eee86548b3d88e8b86ec998e3e7770b549471ace28c605a6146684419c6d8b49b09748f90fc4a093be4f0e038f9bd694bb4c1d76ec13fb37e2cb750c380416d42ed63d7a7cf4f16e81078731dee97946cc8b50bea32a63f0d76ec44b08296c019d484eacdfe22d9a162f325a4c2423a658ed8e8c5eecc211ab8db90485f2e9e8c13ce5fa90e568100be45e36b845573afeed9602941576297da33dd30efd93e81143bff8e0dcc621c32eede09cf425e7e27b3dc0dcc8d81ea83dbe164f468726effe47cb2938b93829b7983c71328557d3639c5895695b80422533e9ea0e4e45b81b461a558a50bd17618e25a9f763fe239cf074ef2c687015afb814f346d88bf7fc3351942691d9ac42150933fa783eb1de951357361e1b187c632c1a51cccacf792c084414059fd6621b61c534245458b650e7a4938b833705b1bbd3aa848ed7db7e64b05bb64b9cb2138792d377c439d55eb0ccd7c4c83a7564b8066151e12bd7bae8e9cad18cf7331091122ed8cee57130f06de55b7372265262bb754364a4bc94eeaa60a3500704e384138fc39f64b05c4fe7d86364a822524cb5f936bfbb52d3656a7125c04e196a5f0f1eef437baa8fd449f5ff1f5601a2d8ef7f8da12815af70ab5479238b35dc71afbaa7dedef9a1935d8b52ee7ee026ba813a542340c982a64106e8986ac8b2d5256b721189a7a0f29a238200ff2ea4a428726bb55e1535e333c76f461de76a357f1fb0df29f29a4a7d4f918eda331d63acffba5c226bde1c01b5b99f1db802fc7c5bb5bbc04b55716cc8c8950d83ac2129184ba668e4cf3af814e38972500a02bdd636f5e4f7cddea652de1f7ef8620d32a081f856060c5c51c95a244da28c9155798126031d191d6376d814596e218cdb6c036c597dc1e4ca9711252e9ec05427e4cec7725e29d7a09ae0bf201bed40306602c36372f91354fb276f3025109964eb4dca1837862915e928138b35d0559b207a0819b7bf861b10587f00bdbfaf3ee03ade1120f4371ac331ce069d135dbdd936c7daa4fc5054490b5c343f5be4f8e86775721352cf057c9fe6e67fcbf3e37ee2242f758ed0049c5ccb356248741701ee826f16406e22279215a74acaa6bc7458bc1ac237011fa6c8831524c874d2a5ccfc5ec0a2ec365651ffc743c67b26ef13fa2f8b1cdde734ba9394f70180613462b85bbe4cae0a88f899aaf9034dfa7c2728b57a2a5d71de2e184722f43b1b7a8ba6bb6235c749195be363e07734cfafdeb93bb125e8919b4ea203d280e13e15e11656bc50063cf31a1c435f8f5dfce739c5fee0ff34a9830dfd712601e53fd34363a52db5b57aeeeef6cbf05fe935512a5a57eaa00483fdb0d4dbd6d0d278d69b91499063c8afdd5ad13adc0c1f8edb29bd124395c478877f973e007c0e8816650ecf92d9c306cde18c32d2315a507bee48de924ea0037a3d5fa7b4178144e7e1be4a6785ebb21fc71d738834c885b7348596b3447826471ff388a623f3a0a27a01d30d41a034f2f199b52373b37e38d1752b4b64d786df11df350ed4c07d96ccc2a83d9dcf6ee7a83e8ee5b5943ab8782efcfc48bf0856b1262232b69f089d581c64b0d9725fa95d32833c9f150a3ce7994b8e23ad3c283c98c07891fe4168fb34e16efee07e5eaf47a6886f1bd6a981dea9fb72b3113c70f4ef668d9a159ac3853823cbe31e15d38b89c56127bf29c6c5f728c7742d2b8115128da5da49ba7c918857bf60725daac285be1468d809002e0a9e5912611d2a314628dca05a626964c7e062a8c832f98a1e406f607b10486bb915163542a5df2800d562393e6e940ed1492d28a9c5d01776273094e20ad84394e512574d331a06404d941e6a551720f3f1d42e0eb12c901d4e241ffed0feec674410edafa396ec141fd1839acdb8184af741f4b27bcadfde27859bcd4cd1989978d9f55c9c5e4d9c438e4fba4df5e0d8f5717b67349ffb31e46e8248cce5101a0eb776907bc78c4eac6db008aa7e11cf4121bbe7ada69589f08dfc81d84277ff81f9506832928a4233deef47fb3091b2e158419ffadea9a45fe62d50ba73cd8d169b7de063b3cf167f1edeb53e8aa8066055f3cbb9e0d2eaa39b288d8af88dbdc235234c450ee37ed6effe76599e587f85dbff3c8d91e63de12e8c2c6f958ac458c1e723b9f9e1b813d2391a4a8d245f4ae20863c5a836384eaede941bc98f05b0982c50bb629506d8bb6d37f61b0c8c201d0999a4f303851f94e4bd335c2ef6f9fb7b8bcc2e998f7d468b776ac87586ba44e550fae5f22d990f8e1e780074dba5e1cfebc609a80a98a75173b82c70ace15db919064ca529511d01a5a815236132dce770ea70c1fc0c5ef3113611b5bd896401417599de4fee543c97df6381d0cfffb8c840ee8f161b0262cc33ef4827637163f22f18788eb6a79f0e69bc2f8a97df92920fa5750db785219f46d382542927eff6e518793adf201be632f99fc60bd3055086aeed05d9c2407a6c3b7f6a2ecaa09f6be5e8c4de1bd8fde61730cfd3a9ff4c075dc8f2caac191b5640729a4b6cedc4ddcbe2cf3674ad0fb6a880863a1bd95263a03e3d7c77437cea60bbfb4f2c967ed58203757568d5a5885c4374f21ed8877d8df5eb41a6927a711121f0fd783b1ae0462b848308230736222b8046f97c43a119baf2aaa499a37388ef43a7cdc1aca53ef14d4d284b354107ac65ecc0dd9b7c7dbd199bc47e6a65ccb8e340889c62f58f4612806e8569b4e4635e4fdcde00d7fad1bb18de451dbf6effbdbfc2588598bf10085d1f172f813b3cab1f3c7ba94daaebb559aca729c146f5715e63fe9a58309e93e8daafbb1bafb8d2ecb0dfb402242696b2a1ef4cb4a50c9aef0dd3bf16a01c797be19d32ccafb2f3982f61cdd21510aed7c19578d0fd79db5aac0ca77ca649b22b13fb1fbed52007820e9ea51695d63a867b42646af6263276a9d8ed0e72348db1313562b346a25f309201887169719af0f89d300b3a7a9f41264e7076042c38bb6d8f8ba774c799325e53c3a06a10e1ddabe6ccf5ae6f1e82e9af8d6c572c8fc8ed508d668441f4386fc90617eef1354bda398ab339d565fa0eb41b493692b0fce9ac3aff3f067cb94fe64028a8a0bc90e40ecd341aadaac9085a90d3ced2363cadda6e6fc0dacfc2ee19e72f34dda83d475620055a996d95d67d58585582d79beee71f63e4edbf34e0fb79e081b514c4840812060a59e1bc5b3c5d6b6ab3544d16daa17b2b93f820081e319d7c6b485c7cbd21dc9b3d9eb8137025223889c51fa0fa2c2a4dd7ea10664d53df8b4f7c9378bfac700a20392005c7bc7dfbfd6940054b6ecdb1040806453d646dd4e8ad44694f62319b7249f222f9463e078b2f25083f91cefc13b95269c9573bb0fc404a0c9676daed722d81efcf01ef01917e50fd232a7d399672924cdabe00645db3225b069cd3549e2dc5e94107d805f8c45c0d28445183421bcf7ae491ef59bcc2bdd85a0372606c6adb9a399e248de23feb42fb07841ff0170bea31e1559cd0875674bd264d5bcbc4359b43e3371e32d37484096048c2c1c4f93d31f8312d3b5ced1eae5ec8ea894103b5da94e172e39433075d3db2c1873a08b1529aec7e4d6e80803413e48b42a9046adc362d8090cc4676aaf9fc613f3ba8f64a2f7d1bc0a7256c20f5a41966aa3ac0cb287849205b7f149c3d96be64817b5f371be1f25d250016524d7faf5f2be6cce37a530fb1750a338f2186294a10c91d701298347094e133c505c76b3c8729a3a70a952acbc896f5f66cf8616616211dceec644cbcf9f469298ad85201a0d2ae0d4a3da5a1f45e97bb25866d0fd46c7d77f76dd4f993ec3f0cc2fbff2de492cce7c7c935c1ced5973478285414d55b54443fb1f44776334f6e5a218359030736298edf091cc5881c2ab2d007a0b362178de3655ca5dc6fb91e1cc6d4191f1e96d3e9ad299838c838ff276c4d0cdbbf99064b8eaebf93ca889dd49f16392b727c790cc6591b1ac82fd5b2a30359ff84eb5de761c6bd75d65a8a72469d8d3dda7766d4589732e729443b08824f6e034bc47b6f50ebf296d7214af1e6684041a0701c45a4f029d34b0e4535af0e8bf62ac29e53b01a5b15a09def152f4606632e1bc1044772dbb415106890e5c6472402699c5f719960d83d75d460ba84dea23f685aaab714a459e1946c917443528b2bc8191cf91d39d8b543a07e090f4d6f3405d5b7682e61c48c563fcdd306f0debe285b9ea0d221284cbd16e464cd848674b3b8cbb7448bad8703fc8fa2c3e1ced101fc770756ca541cb5b60f8fbb5411f67beb2881ac0ee3a8df98ca771c11a1ce05a7b80d2b657a74b210f261c04757a8b7dd978786a4358f33c02c78dd388fc009e633585bd252591544a09a63c7e1fd0dfe7e3abf02f0fd3f969b2110ef22a94fa90eebcb5f353f8d700a3264edfeaea63ae12b79ac4991d7ab1eb6351a8f939287c6136850900e4d0077c6ad3bd9283004a45a506ccb716b0ef44f1152c1026af2ef541893564f20c62d581c676da811942ad17f06227036d3c220f649a1fc08cbe490917dd065989fa18fecaee6475861bce0ed6fc9de0530b72b168b471f3500e64595254214e84551df5aa3d6740ad0a9f7f07e7a7f6ee590ad7bbb44b02bb7f1272ba7f23c1db0826da1278d7c95fafde42027ed22b0fe4474480834280ca76c50bbbff0a1352c4f53b2502cc376017af88087866872ab5262ebfa8d75bb3c1e2d3837195af3606b3106646113ec852c22bba2f925cf6902a74f1a216c89d62ec4bbc14ab24084f9911b8c80266b82e31e4de7946e29573186e8e8332f906c13edf25c832d15db8d849f758c8ef53ecdec95c6696bd4415e0609737f9bcb1587cf6f60ba2578f2d5c33c5fa0bb8903e02c9763d50d009b70e8aee429a33ce999fe8839f8a33d3058c2e51e5c461e3dc81a44dfa48c7b3c6319dede1d6ea25f24db5b5d26bfd152b02be17ed61ff3d635b1fbae7dd27718b1783372c11080649ed826bcaf30261c09b41bca3f77c5c15b4a5273f769eadec98a6b0ebb8d6751535302d2f1d277c7453bb4101ae31f23205bd53271bfbc5a9449fb40c11dd07add1e7394215b2bb8dbdea3811cea8b14b143703ce5185bbf2c496a0328f4771501c4722a6e749db9b385d615c17df57eac145160a3f0f1e4315d7879916c9c295a653e3b76304950b873b16084b615a718d77a5de2c61bc787e6e98806f91ddbd63cdea73033292d6fc1429280e1c816c2352db644e8152281626206094c48536c61d65415825f28bccd46b07a55dc43c72573acc830fdc1ddb5cc766d55b95e495ed16846429b0b7b22769bfdd617187596a18c85e9fdfa666ddb5ea9e31a7d017e9910d2af7eafa35995f25dac435b7d29fa8ccfba53eb4be570e9720c3ed1b98817127765118d41236836d309c2baede0cbd4ae8a1d5d7529ec6e13650fadf48be1dce6c94c15ba956bb4ef2fb3680cea69c7eb31d9efaedc8ee839597785191b4e5b61c3dbd61b8037fab6967c56fa8a0e1453d5861c72aa466491895dda7fc877452b7b33b832fefa9ed40ca3622367b04fb95ace62101516ffc99021d3c59f49a4bab3488f1cad4aeb58a1ec3a2dd9882423182f24a22e75cd8c56199ee39bd25e49f1aaee86bf52353b2bbed962a28f5494660004ce44b1b1c27019e70ad93f63b81e44eb64cb35b196d458ad3e6a879cd59e8d4c3ade661552333b5986f0026d72a0e37a83001eda3a50eeaa4a4c774fafc5254de60ac909719f4befaad806cad206f5400a8165987c80d92947016f0a9c889bf1784684db97f9fa10f94ea3603a8d5b82b0db16b85ee414c3e24a9cd9648ebf13845cee237b2562bf6e7855b244875268994e6bd3508237b74fc86288493894cece308c841e34e5c6a9e461ca2f9b1b1b6b9ae728737b738b3270b83be89c5434eac32ef7475b4fc4a9445d0b3e031613b676d87bf82ff391ae72fef63f98ac40847c56db216cc202f157898be7f60979f5cf7b9802457f912aa809106d198ba1504256532be4f32c1bb50d07ac4065916bef0553c34d1912a74752151018a2924f39763896b86102217ad6135326e6abefc4d0d8c7f1d863d5a778e6f96ac4c030696fe4cd4686e199e31592f356fa3b5251060c9a93c8f3aea0c71cc451a6665376890791ce19f149274074a7dfb04814915d6b6918d5a104b805f87e6b0b0a3720c83ef54c6ad6dbd0dcdefc15b8203d989fdab3fc2493bdf182061c071c5fa00fbdb102f1741f2c0121a07ecb02be5ca068a88ec186b0d27cfe98e853cb4268bafb143c15a587e2090a331518d53d6125ff8d87420456e37e9b17f24f0a32f62c033499b0f2ecab0dba1d660ae32e16633706528dcda13699b27be5a63d05843c11c272179f8de6d879e831e4948e77b1280ecd647c44947e7db7ac652d4bbb2c04d8951427fd94ee3851c57da5636501dbdec6cd007211b3a13c4b07559ebc2227b2456f8b78e02361d97c0410ea90fce2783fedf26f99c0bf26cd2aff171a895e5e94fa3f181ff8de077336812587df9f4fefcfedf70dde53c7b86443528a775b5c53408e22b6a3d9274b5576b41300ae7106d2f7242d12635b770683feec7f655399bebafb8256e600117ce02495bdf220be3ce16520deb7f325c9c5f3a8519933c8f9e841b004b849239c6b25f019b2388e8983c2f111ae7648d3d9f1b1626e36cfe19b5e8fad585ce8b34a9928d4213b68ffe5bd2f118d82e55eff062d17bbc6183eff8bc8a235e7d71558c27abfeb23ff516f970ebbfbc281e7ea7a6f456fa90e89608e9f5078069d2e6e274f16c563718ba23d619516d16ff4303957a5d8dba9e2bf1e7d2c5762139a28ff90d172540bb2709d5e664eb17cff1ba958bb4e0890ad9ef00cb3a16125aa1c52b9bced466b2563cb3117548908aebfed02a128bb929e07db2b6225844ff3422b39612cad6275358ccb7063bae610e78a8442621e707eb3313f284516f8a7cff5528213cad84a5052857b9af2e3cd6efee0417b344d6ecf27667408e3df538c7821403e6365b6f28da4d51a49d8d38b87a6929c866d2f85c815a0e7e71f53a22f9138b3603c0d666beac629df8a9843432855470042ca7cce6d9fe2898c239368d49298a53dd0bff5021bd90aeb2d0dc3b8b27fb3dd1eb9f95bd6d313ac5917004657154daf5eb7ee8d54e04aca10568707a4a59e1446f6c6356aeef582982a3391e26cda7f63681745ccbf499ce5cdb61654c1404655f765f1d08b76f1e49dabcea211db4ec4d0414401f46b99393379fdc48a64024b9d834eb722cae45a5b6f62521a9fcac9a124206ea88e6f05857532c3f54e20c0cf784218a77031690e50bc70224faaa792745f4327ab98bfca3c1b4c22601aa7a4115303df0e1ad50ee0cd325f0575a9b812a090c121088091f6cd32b32c8b59ef1b057abb5182a21d0715880709511cfcf432d29d6df3e89229ecb563cc8f0b209132be5cafd1dbf4368b92fbeef9c5e241e7cba765b0f9c1dcf936491012feed87e69d3f3cd807b7cdfc4b664f03ae269f364a6d9ce06c8590ecd8f1fcc44e5e99e135ae0c06c5a968e795b74646d0e0d26b354631b5b05c0191bbd260110a69cee7f9188117a4a56e6746858f6b785f02922dfd48525f4a4f8567f709873190e066b2cd4ff2a7887cc0ee37d4c1666cf9e097068289a26c4d253423fcb83d699585c96a336b8ba1b9a6dccdc9b50e1a868158b1b6f3b2159ba2c31ce0acc5cbb9ed45688052b9150d5d96fb79b2e395069b974c59e614c8e378667c2741f6462db7e75b2a9f10a34d39659dea65ff2437513dda8e7999dbb43e1fa233ede36814178d4e4052035b761f41daed70a1772eca63484e6e055c968732222c2f3daed2067e7bd26790165b82cbc1c35059d3785c86d7d86cb145d390710aea2e0e57ba7d03d3df308d3eb2355c3dba72ece338613b1195a648b587f5d3d3f7af3de93c1db01f5c755f9d097c42f76f5aef17de3e2a2418ab5fc6dff4ba31996f2ecf90cb93efe619f05c53869246ab5d2d7e5373ed7ea453379c1256f5599a3e82a9acb46ff366ad563de10b64782abc561bc600a1d0e95d580641490070017178a71622f86c9acde798e6b570d9a21ac6bcde776987b0de5bd4d93875809b0de8ac58fc5a6363c780ba5ce8c40f2bfc3ab267c5bd570b96f24a957726f20e7c5a46db98f887b4da0457f5113358bdf54f517d07f5b344eafa764462372e3cc9bb10aeada553a22467423c7f8ba0c784b51a45bea4ec9ed7220e79f88c82861a802d99e84cb732eec6bcc163e7320e48aba74b9d09bbfa8a7d10c2b65787e4c742981c8a6cfbc0a004b47b476c084cb6202df8103d0b9c80f45b30b3a0e87137a61f2f33eca2e035300b11c1dda7db3263c2cf6b1a0e4ecd61e2ed2cc02bd10ffd282938979748f1f73b47bc73a332c49848e531a317d2579ca6b5342f85f323cc4f809a60ffa4d0b89b61f353d8748714cbffe6ff1d867576706c9d7e06d55203485c30f4816abd5928c1f40a6aa200dc0a16ec4e07b565492fb7c3101dd2075a7ab976261cbfe5e7378a1a64633f8da37b08a7b23658ddf13cf622c7720c93211526398904db7f2edb664263613d76e6d40686bf808effd2ddb68d257ff8f439d56f5c0bb99593c14bb5d54fbfb1929be39d90e958eeef5b70d6b20e8a554376994e7f7bb0cf0e037143cf402815a9c904c2b5c3b4219ad93bdab8a1ffa79d7d93302b511e82efb073cfae00468465544453752e80b03045e670a9b4105f83c78f82fb5eac3139d472deaab5b7f0bcf2e92d6f6372f3349b3747d04715d9e49fec4c2556ee372488aa8c1ac7e51372133b56bb75f805d554145d23d2683f7b40f41ef3f9af0a67a5b73cb4291cfbf5033da10815ca566d8c9be1792c881be511ecee06ca30f9ae811f9a9b27c6378374e8f493211829d08ad94d240cb6be6ea8e2f4ce8da41e3210df4a604cbdcde284181e7276da5cec1feb4fe91ebd426d5cf988b3792693c24c5068bfd37e29b86a8e47b1844ce7fb229b887a361538e537e426c8f203d670f94907f828b602649e06f4a32d93889fdf79a2b378be430b702de24ad002b6c8c395b7c40de476f718e398d3286a0cb553e813f828768c17b47680913035effc7c4615efe11f387e28551ddec0a5ae3f7fdd6694877e0772b9a7be5a82df6193adf0d23c5b22268c5c5d49b8f2b10334231c55787a46afa03357247a57ff40ddfe90277a66dae6013bd5c8ba6d6da50d2b71511c3b324d61b87ca1dd5b8e972adaa27de407c5b743c6f2f8a5e4a10b731988ddbecee51e3fba8249d8e0080baa27a42f1c3d4756c9c99519e18f2c73404e762f182c0d48a3c2c3876e929cdbe9f43ea6d7e71fb66921bb0930907387ba82bc7db2ec6d292bc323271ddb7ff34b5c5bb26c4a44df43edaae14153c99eeabe0c8e81159cc530d59501d36b89bbe71342eb312cc9685adb1d89e2964b3b469bc07880cb3b09716a215e5bc5474bdaf62f6fc2d1c0f1a897a609069d0bb22f2f73bb95d0294bae9dfbf88e30490d44f5d7afa360eb6ad302e151a3df996f72a3c0099b69d14496efc8a280d5957f5e8085d19b77696dd0ef2129af8dd4dd09d552d9b577c79ce0d396f6e1563f1bbb086e56fe919c8ed1192807ddb6d53a5e34334f19269a36e9da33b7851e778568ecbbd2b0e52effba2539ae18a5dec039a280de47ea190cd29afc17de0c3c229cd9c370b0d33989e07523b075c1ee8eb6837a7b029d640c0e73349244126e4c04a9c8aebecc701004298802f5d306dbc306311f79c0a21b294f48e2e96aa6a2f37fe19d1fd534eda2d1bcb71af52a96eefb7c33d2b8c476320c030b9aa0bdf41697822a17058cc3df6bd07223c0afdeb216000fbedf972c41068ceb0612ff5941c7b104dc988dbde5e727edff099a7ae1fc327207fd416873797b520239c73bffa411a358cfb4139956f5054cedc4db20c9451c437df35e92d80ce8fc60d7b1d84d304e9f4bea2564907162c00f504be0659e0611bdd8fd97fab4b5efa3575494f12ebc509d7e158daf46712a9d8f5caa926f0f0d55f246c55c26fef6a692ffefa93dedc9b9fba311b4597f5b13530c17ae9ce3e3a9ea825124277c7a315f4794ab6e70c459727fed444830a4182a1032afcee66962061af03ec8540b3eaa2ad175534e722f3897a89a003247ab731fa0cbf961de3ceb44dbed79fa18f14932f27aeb744b9c5fb01c2c03548809f23896d3b3556582e2dfa899d92a95a490db6ce823d0bc183dab5ef7a570f91c0e1285c531bc6b57c291108b791992ec84fb81e2c624017484a87c51cc9fe554399ba93854324debad3c04f71032a7f1333ed764d69e3c886cc78e0e80f13ca01de47f2f1a5f74d2f24754235a005d55b60380dd74c69362ccfdc78fcf12884fa126f06ec6635aefdff951e75897f3018ed997c814e49d7825cadef0f287863fd8de4e0f918174024275a22db1b6e6708f207c92e79b5c6b939c9555e5fe323b529bb0b72ec5e66bcd0a68c4b20a8358a0ef2cc65e08c8c8473cfaf06f9088f5d29343b8836e2ccc62024bbc46a1aadc1e109e9892c8d819456fcf5c56632bb5c46ec243a4a2fa62696796587dc76696e987f1fa97690f85c914f0dab16e2855bbc667019cde5b337d2a49574a7b07b7a74aa1e6cbe31da778bdb41913af4dde944f9bc234271b2faa0b7ecd39e977cf51c09fe3d005d14b1298b80c47f3e9787b372fb4e2125d1eb395fc17838a9b63fe4b6fe25d574682e9d06acb3ddcf36cc904bda9801a4864580bede237f738c77a08a6d0d25107ff3327f978240d53a893c7486d2f6f4160c1bd0d14680c63bc418a424e0467d1bf1aba482505a539392705dd1c59a2c9a59e036e9d3f5ac1a258efe9bc4fd28ea278c260d65674c06916fc790b20304261556aa1e6ae434319c29e2760c553dac1b901ca8587ea61a45f5d6bf9dc3c07f5966a18c176deed6a68db0c6279f0f3596334c34b672b259a97084893cdb9a9cec6af6cbc719a4aae89c046864a9e73b8f053a12dada7ac1188396334e01487b78e0c603663ea7be6b5aab3b836644d0a980cc27affc4d9900c1ccd6997d7de536187249e0d097f882312dd10ade5c4f460f11fa7971533d34a9f88a0886bb9b8a2ff4508f32233615f80f4da117f3595b783df8540680355cef25d9a21b616f394af3cd9f3c777fc52f320370f4ea1e09fe82d8f03b24f760818e45812e68da46ccd52281b26db67f410cc187948fc06eb55959c578e547e8b8947fb80abe14b796b707c7a1977918f99f9f16cd47f91e78ee611d5436f5eaae53824ac4cd47a307e29d403917700da5d4fd36055d66b36f861381d6fb13f673f64995de3f1e7ea005569d2e025aa69c6107cbb63667c29c818474aabd73bd1e20baf73beeadd54462c4873b43fb510dc2c99e6be300a4dd4bcfd401aae30211d2b71d2f072a3275968d951f5793a21b061a2603caeb3596101d74579118fdb6bea7784cb3241e3d2231ae10aef20f5ab004706e36da72b6585d72f038ca7cf4508f83f71c13289fbdf4220a6dc26154042d1feee2c613e8c58a1ef40ccc7556e1f6035e468dededcbd9f1bb53f9a5dea29b45ca6819edbdef356cc3fb3c9f417e0a70d172d4584c45c3f982000034cb662400ef61c70b9fb24766da6f6bda778d67424508c7b608433df2b908517d2e504bfa75a52aeab7a428575c2dc428cca0eb9db3780fb2ad7b96c4ff19f136ef85be5f446144e19bc1361e97aebd24891eb855696c4703e264e5ca1f69a20d9d54b8189390064649efb51637498fbcb3b7ec9f92a0544f8a7ed9ff6ba840dee72a84ae65212639a42d9b9207633356498dfe6e863527f7110b4d1184c61f4bd6b4a749ad1db805b1f4c7a93f5238843ea748debf93bb73ce2ce6e230e9a1c0ac38b74d99f98a7f2ddfbca2b696bb7f3608d949fe8ec9a92a91801ca56d846025acae230b960a7677ce28eff4a847515d41b22a47a4caddc395acc03268c9d708219e8f92cce4ede7930a2d9a38d8856ef5511f520ba4e93371428790d8f0b4500a7dde2ee7c7de6240b9076f8169e9162d46a842a4657b9e1776c4398646456847403a6187a6e6e1c5ab7b31380842d5a2765d51f3508ec31562e0464d19585cd3ab629f61752db1db7c9f91d4fd1c766da023a5367fcff5b325f239cea821cb543f885d7d5a1f237877a38523ae64c25bc3fa1e7227476d9a75d84dbf839f65878f3a75e408041867a34b696198906151f22a407b184ccc08a2bd018033370c232f221bdd452b5c40a9cd20b154bac7857127d1cd62b1320552e02ee94e397dc2eaab29c70b25052534f7773c26d0d04f917d885e2204d01ed82f3002512ac3f3a2ad2186ad544fdc65a63f9d2139efa42eab80de209282efd52f5cc7ce8d3c07717a326f6f8c9d0fca046f83b7e76daa5df94259f8cbbd785f46e0161ce4e851f39eed80febd3c149662e6534a31416558908052b6784c813ea0238dd1256a4a0fe3cd459345946898e6ea21429881c0b8c4cfc1d240fbe9662467f9b00a31b4ed9312979e3607227cfd2efe3170c8574f0019002d4435911c9324f74b348524e9cd677941b10f75f6ab9303f72ff91f1860d766db6d743be9c35ad3827e19df643f5ce9d0407db0dda010c2502caa9b589ef5d78b33907ae72df8f835b215d5f48aab5fe1a7bef1c70431dca1a122f08c135324819ebd15c7e24edca47cd1bd0872f1c35fbcd88d823996dc14f99deb629a7f549af657569d0bff54c44fbab1d1d7eba002e6bab2efe6f395cb2819b8ca369387d5f81e9095e2c4a5ab20979152dcd6f35eb27e242fd202faf9b9b70721409fd20a2a64428f9e65b6f94b4d04959f73e0851a2d0f0a2106db179d570cbefa8a8fed51d0372eae8db86f6aea25be0ca8a74f975a03b0ab3d20491bbb7b5fa3c95cf74993f707a299b0e093659a6d1c4337e67e17c850bb953b37c9967914926866b887775cf1629eff6ad595304faa4b6b216845788217dd828440ce79fd8b114177fa5611452955f1a7322f718925ec514205c32c5407f767006096a9f7f63a657d5118e60ef14cea847092b4973607c61d8cd4301af2815657ef5b063b10da8d5df3e628520ccd1b148dbd6768a7dc642f8667e8dc6635caec29aaa8fea5bfac4a5ead376c11d921ad7157cd8ea89c425d4c824fe02df18f25a6925ff95d1c8ba1ec353b98a265258a19757bb1939cb44add97419de794c5eb89a3c883e3154072a0fbc84846f07ee36c2f5ef751b9b63039daa92fe4743263b45718d7625957c4ee65ce318c070fd1a70a43cf8aca8189efae700aa0698292ddc21cc863e202109e708b46dc7f198c604555ce93ace3e6ea4735112d56f7237640146f234b21fd0c91e87c1167736992a458b13eb6b7417c277e5674b6ee206ede85a1f8f201b0569a174801281823c62a481fc9e601ed10ae36bba8fe8af897eba31d26bf30c37d98090b38cdfcd799d7ec890db256d7aa895739c72453f5856b02a19263ae4f5de5e8fe3a4ad7b632cbcfc048414b58db0f830db4233c6a207c1c909afe2ae3cdfdb7d91502b0c9e45cd049e181a44ba5fc538de3cf85961229ab8dbbaea2567020b66c68a7ee3f23d82b7a6fbfd706abd4c9e415927b0214979f5633e37b6f1f075d9f05ad91c2b3b9eb3e994a169544fabca5412ba13f189cbc81dfa3e9da739c0eeb8872d112c37737bca5f5931a169d5d7b7220bf30f48e6561de207415b6663fafd286234b9996e47a6606ccd4424984f2400bb9d2c92b17f1bd3dc7c3e3778f9bdc2aa3639e94498e66a97fd833e88e5e850b552beb4c66035a9f89ab90eac93bf647ce24edd2221bdb3511c36e4644d9163e7ddc8854b5bdf0f7efa318a3a38d0f0541fb972626ed3668cdb00fba56bbf31f41e4161c55ff00d3594c2e6dc2a36c8bab51220aa09efcbc9bb7e512c1c9dd8c2965b51211e40c67dc4796011276f515dbdfb4c204042e4f1abcebec60589a69c92ced557bee2e219da715d61150c63e35e345d4500ecc36f099854d49d443","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
