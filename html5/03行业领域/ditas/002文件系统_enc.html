<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48c4e11d1cd4b5d0b38a78a3fd2641be3e3775709d858f0cb1541656d2e3a1bf70a174965a694097b9206ab49fd25b78616de3d55697a1be05a7aa8574ec4891709db087401cf511da0e9eb7bf2f53313a2fbe0093425cc4d02e48a722879b0f0ce7926c0e4391a71bd0c1b7d73e3350efa5326303e1b406238a0aa70d8303c5114f088493723c61af602eeefaa3813d495b26c35d5727e47fb5f9deeb96ea0c6792b217e1399ca49643872248b36112e45ac81bff0d2200eef8c8c77fd8c1c5c2c78727f2a64e4434886ca805168020709962f5bda0d156e94fb1805564a7aaf8be333cc0b7333e35746dccd4cfc5b2c3996d8de56baade5add353168152a0d34ebf87fa554169db11a5ffc38761166a53cf6106e188504b3f53445f559f5b62ccd846080c1c9d9847fa1217089b4d90b865376f558092808989ba30c1efdb073fc52b52f69239d7bf59d4057291717288b21fe6a50d56da8441ef9128213d20fbb07f6e4ec3805468da5b665750b5b77ef577057fa192577e35b2579c8d2ae43afe20d01dbcca113ee70bfda3c5e7c91357fd5dea590dd8028cae1eec60b3c4af1fbb663502385664ebccb247704473abbf06577900edd391a8aa2aca142a0dc9877117063a9ae9d0b2210cf2ef91a6321adadc93147afcf729c1d790863845d46438e17aebca614221c6fe6caacf754adda4421d53663d80d603e5fc22fbb4faa023e2e6d076018dee713cbd7828379a9d12f64329e59454160d91f1b23ee18567d022d717d691bcfb0b44a1dfe4dd7854044ae5e207ad637580e3d6ce8b5f3b571f5048751732cd357ee352587a515fdee151c99b1b6c4b36333da477cfe639e8d0cee213eefe286533a74ea012c62118223e1899527fdeda5757467011164d2c9d4ed6dc38ce7908fd2739818a16d2e34c96f71ad88bbe8bfa0c33df4424bfefbbd89e8af9cca25c688c4dfafd282edba656a174604376f790fe2adf866abe14c2b3adb29516177a6bfa89a975f6258c3af0cf3bfd8233bdf3b8f9a30fa5ace639dfe41f98f0bd366f0d1e0612826d42d6f4d7f7fc6d5d014cdcb0ff8b290fce05fb29da00125b402950338d7a8caa2b8b91e362c9b0ea959853114ac6bba2d31c1cf6070632dc61e914658ad65b26869dc98e32af155f6bb995afe8b1893e43f8b9493ee9eb5dee34417b88ffa46a8b6fd8463f0d4d4923004a34f7a8ca25409f742bcead68a2c59f21c7270d49dd5a3891c01b112c63a7bf74119bb276e9bb598fbbae870ad068610dd225e5c8f99783fa9c6fa89fb1bf2325002bbae710205931c7d1e11e41901bd92938b8aa7c3549163834d6f371031f40d425233a285ecb8a49a860d65e4d8ea2696097f89fbf0efec6155481eeffa8fe9313849413af8da099f4dd9883f18f644f3156baf4a64bafac8691f0d14463a86fa7686e5d556586ca0b6d79210e7f623ae0f44afea90ccce6caddae609d74ddda0c81b67581d8145a5167af543a7b8eb11def1c7da7b606893f2c4e828a439aff731e3c7f15599e2ea57781a55bd2fe4fd51bafdc32ae04a99d8c59b469356131f67e438267f808ca3fd97c1919f7883d0137ab56e9072a1cd1eb7deff3e067193594021e59ba7371f6986226e34b8257e995a7a61bd116f8833cba6f1fdf268d540d8496084d4e5c4f550ba50d57985fa289e3410d4cf36d0cfc451d4b0601a205b12c38b849a7137713ed26f1dc1b21de9217576a51da639fe7d882e3ccfd386ea0f97dd1f1c05eff9d98c098b83fd1d98c26048d48ecb09439dd573dd57dd750fb67f143a08588d8f3a0013ab3d28838000c4a87eb576c1c2164bc89e171de518ecb0ddba2e98040bd814f10328d9417659945c3640edf0b1334e5eba7911af322860f58966807f01349901c97c3919102e7168688bf2ca0026cc75aa94eacaa2e2b2e0068e84655faaa68862549266c5aa879ff76dcd0a6047628146099e5ff42110d3ac754f5005262929fce0da07623caa6ea8bfe180651b16a6c05d6fd961c06653cc5e07d68607c8de274dd859e2a82d0e59834ded321418207dd7d6628a1616a4a0da59fb7a1f2cc628a62a567d4b48bb6cf5fda67ac549967b0c6846cee96e71f4ced8e8289f42007b60493dc50408883fc252492ea547bedd33efc850ad89e1aef47adc8ec5b6c9de3f116ae9e3341e3fb2648a3f2264adefe6452c56cf38b5871174fa158bf0a01ee06facd52c7ec54f793ab23f96a72569f36a087e639e4ea1c1dc7f89563e95e155e88fd169c0f80cb9bcbdf5761f3a16d19cc520dea6ce85dec3f0b5b1ff375e0231421e44aab99224412544ff13c125fe85c4f7eada2901ff4df0f4410314ecbccc35944f44b2b4e1ac3a1508729de4989457753f3ad06eb1e3ec11d220f51705285926d55c60729f291b1f1ff4d161886e8ee7c707f57875c1d70ad2b75bf729e62892f34e4824733fc1ad77870d1a4eaab24eb27699e1b40c8fd908a49e5d1257b06bec7c26d2b6bab50df4a9e4e219af14f8e29f1b9e7bfb5950497f42d2c886c2ed9cc2a591cb301cb20604917d0635ff268d39aa67e46778ef59e4027f84b25ece0c1ef6d0d38113a72737a10d12b0aceb1e7fe1ffaace19e1238298191314479975a36d6ded975cf057008407019aa02a4354c82f848f580f94135431dffaa7392a6d305f8be2fe74d41ea31ec04a2bb280a2181c2a4ae78a20c492b27b6d202ae37bae061ba50ac6ad888612cfef81078241089e826f4f07a7d7dd383ac671cafa2d6d988c9667cb3ac8b655d5486fe64890429f567271e04796a9b3f94dfa61f5a6799f7050bc5039968d69fc85566bae89bb9bad6f3a2737b9612c29a6b30ecba01ecc7f5615c4534098d2c36e3ecc206acc961eb1704aa62a15043fa6ca2a98406cee5d3739c8cc4633bfcef57fbd69da9f80190aa4f6ba1dc7e3a80348005c73d11ae5e878f6e1bf779dc89a0614f2c56c3fb6dea8570be563fd2d858acd851957b83785a3108d2727ad09dbfb9712ddb544eb2e1250f23e4d50f410467d96f7772723656d6368dc73902ad66f3689fb430e2e2e2ce0a1e89d7a61d29bdb3dae44000f401ee296f561a98e9135b31dc22297677fff0be114751d58a1c80d487e864cca5b50684adc122e2aeee16cc6696c55ecde9524fecf97a22c5fc208c1121eea33a7046ee0dba0913edc5d19e8a8844ed6e6d863ba660aabab7bdeac98f7b5e2730a53592ddecc19dd29cdb33837c6a5bb6a0a29ea2786070acbabaa179c1672accdd1b3ee99ac406750759c402ea7cd0edc1c8488886a2b38076b939a5d86af9482b3f7d05d7753e6eaf8529cfc940d81b1325200515b6f469a1a519b8ab815b87556d3a0d9af2de81babf482c01b753000600ae01a3ceba3bf78837fa30d2b66ede312f224d6b20b5885110367a2cb1d9c06d24b245a63c08ae633a4f01dabc84b4042cba7e269dafc0695c48d9303282f321cbeca745fd9f810aef99cb3f4c03bfc1f16f05bd779e823fb88982450d0af287488d1331dbe61abc29a2756dd7e4157daab89a5b0f9e6c21d08700897dfd3d376fbda3c626c35cda1ccb9831c50985af70393047d25f62b3b89ae23df1467288d8260c96270fdb5dff8a874350296b7e629c5df0eff891810c41fd765e12673d78b8af2fc69dbcdb2ad081999edf3228f67f1967f5efc0cc2c01f8cd4165a32d52806c08dabb59f3c96cde7de263cb79852e78a2e0052f068463042f8ca5bc61c1b43e033e54df790182bb1f12be76d39ffbd8420fa446511408dc8316f94e377d8707e52855f228fc428de9d6ab55dde5ae9a879773a3508045d2f950ba67f085162d62e8538a29b697ad62811400e54b26c3a190c1e46381fd2826055920edbe685cb8c061e52661b9a55aecce09a9e0240b76c9795b66e6dedf1a31ece0dd643e431f5a02b8abc7acaf8246e1ca8e9e4320cf144339adcd32053ff011bd2e8274abd604ee3c8a4359cf486e87b5837577fd7059b1308f971beab5a57517008b0470ab571753ab3dcd67b7be8b037ddc1638d4654ce507c350538724fb36b2ed2f3d0f036412230a00cf5d1461d3478b7abfc9d8065992d9a396fc6dc218df8db930d9a784a70b8d66a7ca658dee7fe830e19f00ace6f59ea783b43901f8c12968ff5d96c416921bab211ad48613753358a0b04d048c288c1aa560002465775f0857ac869d87a0bcbd626f77918eb1dccfd05fff60d70830d20b5220e38ae503ea91cc8e56c574772d663ecd5d958dfd29502d1a09a6c001a574ac68561e402b26105147cec717c61a4048cf4cc7579d26d08b05ba20dc63f53254577faf6b472569291590fe7f1ca48fb42006c45b834daed81825350ee3c65b6379367b7b0e17829ebef20e4f88e33ae71a43fd2d310feeeffcc64530a749a36652e1866e42a2ed801e6c4c51c8cc49ff604114d9c630a26c0ebfb3bb7ff4ca1d65ff1eb93c34fc07e2b0e643123f7c5e8683a5bbf27f8d679dc048821a4c78dad24a70ded91bd245156c937c69af14bc95d4fcd0e1d47e2ff7dcfd8ac18b4adec04ca69d04e919af79969cebaf81f020cf4d10cfed72ea8ab771e71988de3a7bc1a036391e40b00808556ed096ee4045ebf2747fed86baa39e46febcd8c6897a0d521d65030db0cf86c8398dbf95e72a8c9c8fbf5af0cf084a20dc604812c5e60980c0210a8b5a3a9a775b18bb2f4b1aa20e5a7849a662e0cfce65fdbc1726af693c95d73b002a2a51ab947ad23fa0e7af0872b71c65478584b2933f6be47fa4de4fba59b605d7fc373b0b0718e9c73af759f7516528ba0b83f81a5dd6a792b9eb7c90bb1713591241f2ddaba7234475467e4c4e74735be70a95bf92d7aa2edd9b47937b948b58e4a462862e75dda6ca8f78488d60051d9147a86ecd5f69cc320d0403072c9986196065dafd68c9eedc24b4da003b9c47d35eeaa138f4040f33d3650dda68a0436cc0b9b9dae75ced9a6a31df8dd72a27c018dc8ffb832e256c914217bd6bbaae40b3fee2844be98e70febf9e32b448fdaa3a0ed779beb492a60cfe14d43ead37c77358fcea7a99be02a8077e132e54ac5f3a4ce91764e7c227d7546e6f9f08ff25f587b9e3e1be793a0cd96b6aaa47641dff3afab5e6f02a8935eec9da8b573bcbb6cf7e17c8454f6d72c5f46582912e1f67f9d9f36f5e97dd628d501e8a11a4d7d0247eb691f2768dffbeeba4bc96bb0044540e066e5cf317a567aa58e675f198b57f6df2560a561e0ea014a01a1061627525a374791af3b11e9f873134b2def771683553252a3cc175112d552a126b10f9a5baa15275eb95ef829c246e0a8336cdf8a60c05b92e6ac7a047c7bb81f7905eddf0a7e134df0dfeaf7d98e81054cb2e29976b5913bdbcbb30217672560f8a9fdf7f9eae658b95dd06dd251dac8c04055ede15de9e797835a290872117e313897c76996898d1f0c3b5dec5bdb0779a8e48f1cd01137b25e84f8d4b1e2063589021f552c38df4e10a7f1e1f522a09d6064717ad8c50691f624992608dda9fc73a763805349ce0f87bfd4217a0be2a30b1f46dac946a775aa35a22f49a26fef2a1e35a70db468bced65898b7d65901e4fc3b8b90b7cf664206f7fd6975c86c2c423f2bd85099e3095196f973e6bfbfb52d38c8a09e3fe3b915646c7fd48d6e287280ad81d041d505e891687c8ff45aaabd0678b112a5dfefdf23b5bde3c3912bcc396ac76d238e0bcbffeb9ab92a6f00824a3cc3ffd05c1e51e7fcd2daf1fd25abf2d5f668b309f21e0315c077fe6e650bbde201d45c0c0b6f666da3a1e2acf392cc67fe37141323cf70be3bac822c2dad3e2386c1b72ee79a7501e65723c96e9f7a3a8363617bc74cf7967d3f97c6c19ef7a0011f0720bc851e55f9881261e86639cd0a8d2ef4b9636ca0ed9ee7ed6ebe03da3973b0ec663c3b2ce7e80f6a83b521d3f0a5f59f8808e0592923481cc901c8f1a237011b008197cf9465e8151bf44717da85a2fa5545191d86064921f4f2a067f8c34fd5fd6b26b881fdf8dc843647d040de11359975291f02499eada7eb7971ee121052941e4d3cf46088bc4491fd644d574302176b20442744fff0ca29f30ef6533855d4663206d2cf092922489fed4f9c8589de31cbd95f0c58537a4799277adeb8324c18f2161d75fac6c0eb81174a0c53e74bdb355961ab4d7a7057b14119e881d0a4731015d842943ca190d924a82ba83567dbe5887d1550326e1224ccd251f0d1bc28f517b2f9c65c3c3c021a1d3dc9bd48b598de89c22d0b6ea9ccae72e2d8ad8eea779b5ec203f7d73ddbe203ae26a6319da6ca140d4358fc973d08e24161ccd581e97b36a92c55a2a2fa9d102f4e996a51dfda4fd3eebe3d8bc4f581802e1e97d9140d36d684b0d8ef0affe57b7086eccf4d52db86e1799fca304302195e1c40e69cb41ab004caf3700a82d8a1752624a81fc364e51a9f0b836b1c2886fca99307cfaccb57a442ee432210ffdc53fd954b787cf545530e66dda42272e946071b932fb1c0d81a143ff85cc81b20d94dffe8e8eb512ec77db38062a93c3b07ee0c5545df9f0de3681cb5bb5c3b229685b2bc53a6d3e836580018c5fc1a4b636bcd99dfbab85f18767a97b70416382976f370448e47706af26238db75d7105fdc376982c9b07ad0d7de21e018b2da68ad6b77e9c26e46b75a808ae23c56228f41264baad01fe7c6252c280f4e67408241a6e916e06d544c19bd76b5d3b79bea2a1727f1ef5728742d13584b87e79282fff72dccb9fdf375575bd9150b1f364afbc3bcc8a7b7d22ea1f94c2b2744438ecbf783f9718bff79e98289ce33a4a418c038420ff4c319424cddf9a895124338ce735ab56da4ab3b0e4ea38b6ac4cabb5e6242ee1a4ba56b2ae4a18161ce3d0ffa4969f7c9f8b7c34846c3fe69c83d32c8adb0393ff555ce18f73b95355e14e7c04499112b68196a978782a04ceb44431466ee7c8bcfbc278feb4d4e395ae45e5b01d5290912dde199e04670386a435fde02ce0ad4f736c012c644795009e7900cbb73867f0843f2fccbfaa6ec814da4d626e830a368db806107afcad1dfa896da8663299893a4abb249849fe96b41e8062a55c602440ca56ad95eff61f0a175d2af636a6ac945a47d6f1f2792a801032c94f4a9e9d446748da626ed883bad07ce9c548865b5fe567951ecce7fc9098e9d92b852b33adb9665340a181eb123f63ae997731c8e87e18c74449fe34fce3a59f66a0cf312bb567110d6df532f94888386b533e85d1bfcf684edd4c873b7fbae658c9262f547058d1a457fb2d044928d29822e89041269b1b204d710610d83891b622b04015028781a8f5c6de926b10290eccbd9d42280c5fda0f8d44523084a828b6dcf0aed88dcf1a72f05716631ae6baca545bf55a72cb0b972baa51e066194f4f20b4bd346975a11789a0f4b479947150d632ca324070ba43ce1de95c7f94804e9ace520d91edd711d3dc81665cf2b3c5687f5193b24677fce167bd5c723b29ea5b997ea08d9bb26b5bab0e06d3847f546e13879d98993ddb82f320f6de35d9bffdb80ead4e6c7aa0b8d7a5de290a7a14b96856af871f333dd0b371daa2d392ec7ccdfe255450e93f13b9ff7455e5fdb3fe30dd981e4b444ce38a376dd338640ee2a8c5819606970d8e1a5e9c523c6c724712ee2acec6bef2c80666e44a6da6720df6fd60612c6873c0f08a7a0951f845a332972672b07e407d81e2db8f99e2efc73826682487d4ccf0ab639b15253a92550d28a6754c73bc389492752ced4475b52554f098968e1c74989a78a15e4e7ce3127aaab195b439a06f1dcc98f29ad4b399ee030415fade24e6f0c5584bf31764ce1abef8d548e917b18cbe68cf7a1f137283572bd0337e49d1dab2f4e0b4922eb5c0a7e48c48486e44e0d6198fe6c24df7258008e095d0c0135a5edaf600127e2f07e6cb9516e4c92a54b3eca68164b3f523f1f915d95bdf2e981887d246b09113f6b96c3046f4c43ebb1385b75b86f33b63cd40d18bfc857822bbdee7c19d7a560085a38d20f3963fd7727019328a498c1768ff8d4eba3cac58ab00eefa652c27b708d2dd3e666e0e1aa0fff543695f2fa40761e0ae44c0d23c3869defe4060da69a4bb3b0184c232553e505e7e88959dd613ad5c565f1932ce04e089832c5072e96298864e1ddaee128f718d2b4cb1607b5336687653d74950acfd83483eb6d6b484964f04291713c418336068518114f32ff0452df757a85332dec95a503b89ad37cb42e17d307a959891750ccfb484e9d9168fd60b7af7d2ad442e9f61987ecd2c51561ca85cbb0371fe7a83b9ff45f1ead4ed752ec90fbbebd04d35553f495bb60cd0e722d723d9a97b43063415cbfcaae2dceb8afaef5614349672c038d2180916dac7c98e1021f6dbb088566f3d07b3cb6534e3e4ef444fd5d5db673c4e96852971a520b85ae997dcee31812cf94a5bb6d0aa17a3e1b869b2422a46aad653895f73539d5ab635f1ee38d4d2f465ed7ea82b1c939d1441f328ff435c6d7ca4510a2bf094db922e108e77d5caceaf3ccfe446adcccc631e6bafc40ceff653b514f1b024d1ff01bf3b30de8992274b46c49b0e9000a9f243ea0a7a181497f92b5d07dd9410b52c84b622374d555cff91d98bea69bbe1e612e2a9664f271f30f5a3f266ca29a38188ab23788a0ccde4c5029152b743c49d6093cd37fab0a71b6d62e81c589873cd667b84f13c9bb35a5db5a6fd6e45dd05858abc8fd0578f1e35f717f38fd9cd4b57fdcc8636f117f9c41d722e44e9fe3282d539493a052b8db4834abc6f5126179040ac0c5b41e137d2f000752e265eda4948e8613ba8749c670c5f2489342bd3fa41781d2dcccedfd658f188db1eb1ecfa8a741c7cfb8c30a34cc7094e07434a7f0521f69b08302e78d0997047d4ff3d76793ba3a2b5c704c1502c29527637cf4bed54ca73e90154ca77a9b0fe466d5354af01a3abdd2aeacd3f28608891b343feb4d4a92430a92dc4540167334ee44872296922e087cb1f830b2637bd210f62502f3fe98b09af3df00e31af06b10b85191f205a9352cddfad21be53fb9ac15cd5a90906f0fa3765ac2cd8c9396ef218714759e3f37ab381c818295049e080054324028178c1328232f1c2ade6fbd7d88f0591b458167a3389b3670df86b59bdd7e88de9be8d56f84b2c2e6cac8f8800b8eaabc31d03a850d88150933ffec1ed1a9f6403feeb4447a6d13069a2d3ab012cd83068f2928b044a622d06fa44b2f5b0757baa098b76b0d8fa0a69d5b549deb37443fe2c58426d26d998ac7623e6c35d96c9d72419b9361b9717311abd776a0b025793e70eff6f12175c878a76548110c529cacf13cf43cc6de2b8f7de0f1e57fb704af9b9455c0716095ee2946793ed463bb7abc2fe37c7cec4ea583d8b8dd1a5c2fd30813b459aad96c8b92f31075a3fd66d0f36a43228a41a83d66f70fdb08db3208413e98729c7b1ee2a39c2574879d9cb3aa686b7e7205865c79e114b676c4cd24d2f3e4042b7d93119c90860df4f89c14b950262cd5269e4b70a650e489347d7628b14bc3ddf106887a093636eb931a03646a56988363e63be0de78812a02072e04280e223e63a4b95ce1aab94faa78833d5fbcd5a0a656e66c9b5adea156d410b65da6794ac55d495259cb89d70a45c1e37f0a34391a1d8cebf81f2238ac3beaaaac55d6bda2f05a24e8880fba87c0c6084e58963c02fa0c3cad4ae18db11c12a2efded8604ffd822864bcd3e400ec36e9a9c0a9391745ac78d7c395e89712794c3b4148708684f08cf634677d96d25b590fde3472339794ba8e7bb83f957d128b2122db6832e4ae41ac93cdce6220697b753d870a6780dc264e0c37499e06f591c9ad5b32efdf854e4e8852337c6640e975de55c8648a78badbc2fea0fc2c9ac3e2cf9601ad331f61c71db14879d72d9aec3268f9f0a49be53b4707e4a101e44bf0d16f4105be4009569c909302288a508b28a235879b3b9d3ae963eec823a26d45e8fb08c03e34a0ce372a3fcca6aef1193beef3e95f803f5569ade5b90e87d6e605179fcc522309a93a2b473e8137e779f7db31e9653794c34708ad41af1b44c0b488b22b9134c831542aac62a797d223cd40ab27d386b478e8b582dc960d81a735c8996b29fdeb436715a95de5b20b8305b022387702db3492def7ea10f2b6330223919ca547a558141615d15207c5731383176a6b1a29c0a5618f07523e2e6ccd2405027462d85951d59f8c8ea7d86bfdcbb953875e74e3809948f914e58bdb6fb7af14ccdc7d52bdc32204b555002509560d94bfd915ac37f24d74bf3f60037335f7a69ae5ab38d773ee98fcf11d0372c0f0841cc18a65c2e8c5f21236c2dbf8fcd92f3fdc75ad6d7b507a4fae37644fda79e76aee22bc4d8183f551f948453ed14cd602ff49cd96a92ff213df10be3e860163c3e72bab1794a165c939649abfc4a929b4854352439141a28f4240aca3311372e8bc1fc5d5c3a0a70530e767eecaa9c7d87d153129501173d95a70d0e1cf312d3d5da4f31a27d0050e4f7ee9a8b738a3495f3ecddbe71b1c96207e0b30a6a6c0e39ec97cf126cb036cd854e2c951b44fabf0112dbb831356df5aeb1d776686856a596a3f9f39b479c945ae61ff3779de5b25aa0bd918b7851c23fea042d2c2cee8c4d7feb2be30bc47c5219a3722cb5b117435546360966d58d44e227ff6eaf3f23d821bf58132cbfb895bc86ba4c5e079d1177c19349ee10f91198a5fdd1db36011ed2e9820b589ae523f5e0d10160e7fc57a2b815895b13c4c59f18f9c31c6a56ef18c3d5f992c33043d1a6b09461f09398694529bf9c97b7bc12ac96c59e8cf24eaed3a196491d93e818851e8b6d694deb901100a7bf46025d6269ed5f31b4945af9be7137fce25a644c1908f512f2e3eb3e03449748da31e0acc46264c9b620378826e7fc36c35434a828e3e7f01d80b22b37502eef2672964793e17bf8a8b46b0f823bda49e26fccfd069dc47c0552e5a5c84f184e25bc2c1ec77c24ddfa5b99501c5912ece5d862d99854c6ccd52c4c963d33d39f0c182b9d1d8321cf074f4ef16a4c3d0e09567bed52df2574ac49d9c56b3703f6c564ffb7fe2935d80ed0ed76046d4436f0473d985029dff009e85e8073edfb0ad475a2fe0d4de72fa630f58d63925546397aea9141e71bef52332b997336de49007f8ce190c101b45e3302a6591ccb9f402820c638bcce14ed9bc4cb70dc9be3d079593741e6a811dec77d6b77fa74b2d97b6647df3514285b3fc9804b2879ab8ae1575c0722b7fc94311197ab4ac5bfacf111712912a34f949f1b1ff1e89a3a1f4e903a3de8fb9de0c65e028433cb68911ef87e27642f4bba6738c77d44fd395500545a9f2bcc0bedb5d0931c0615bf0a6ce7de7b246086d0775c6d0bb9106a397fda897e199ce372cb66cf4e28aec51a926e4d5957f131c08fa308b3ea4b2989894929a04aee4f50eb442e5e642bf3491615cdf61583ff6dd971e74164398e1a8b14adfc561f4a5811aaf9e65e1e86f5159217cb457aa055f43cf0b850af283c0b0925a31fd8673b79f4c1d4df63b397c36a9ceaa080b76f424fc5d1899958ba6497b4d6c1b370d18153e5a07eb6e87f22ff92334ac1cccb4f1a8fca723254cc924ef46ef6c6c3375a379316a4ab4c0363c550663cf3be9e503d5f650d891f2812dc1b3be1fb69fad12bec7b68b3ac237118b18ecc4d690402ba3307285ce77bfde34af757e6790f7a4520d53a6d7267ac18ff9f56dbb53765e52d04ed9b43c7a8687c322502e020d84d61df8ccbf2599d762d32e66cfa1331b8ec636f93a7f2162b15151ef2d3346461439db68b614fd2f8fd7e27a511e4b6bff6fe44b00c1041ddbdec634a348036473695cbfa1efef1545253e20e98cfa248dade6220132bd30a1db0e6944ec274652dc1f91b7a824f59fbea77ab2fd094dccb233d7037d6be0aa8f6775613349f1efac59bdac26398670172e8871c1bed3a5143080d50d5e81cac82e9629e3202f1784e9754323ccc19ae2c9c94cb31b72859b7716946a61a695f7b3b3310541fdf6bf0ac629f6e8a1db85b5fbae6e4382dd221ea49c49cec03c32bd48342e5270add4f27e531432094c3b6fb74b491a8addf35237f262b0372f4012494ebd4582e54ad783ff8a7275bce0e1ddc6367ff5eba84676c13172f903fa0702f8d4196840a0080fb0e2e9fc3606ee5f0f819142a0f845888cd7a9cfa9b90d2905722d9ec14179ce4e0b98fa5916d8dad7c3d0765d9ecdd42cee931cd37c96355453bf7d8fd31977eaccbe465ab4abe09d6c04ff78a8f4e9be9e49575aea80407297e6b78d64300764ab3e08cb8f57343d9ac76931357385797c21f1d0f3d53c719a0a85eaa04ea8cad4f52a7b3e9641bc31b11dc5e487f11007948845eedc00b7045d3a1c8eef9f62fb60f83d4e3dd89cb86db23dce19a565a62063cdc33c89ef97ca39820aac56abc7584146982e996ccdec98073d499b0fe98493c96046c43d00dea0e5945355cbe7f5fbc49c6881835ffc96e6f7b1f5c59068b284dcf02c4d5b8acf733658a93262462dee97c085541944c74be735b30b8059c5b8416af7565e76b5fbd9321e7c8d80aea8a0c0ef5e38968ae24df3879187071504f3d2ae193257145586754987712fe08fc8e7b0e3097f1d5ba0fd908aae6b55bfc87781043577461fa51f30e0ff9a815929eb54f7809fe2af56a2e07b35c9f7fb07f1b0a83442d8b65b4a03bb7a3c45ea3f9dad7ad415f07bf6972c8954871415601d96ab5dfa8cd74a56bb03ad9be59a255f5f45e1f5756a2b4bd8b970875aedf5f31ae9bad6f4af069288f6b30ab87a30c599abc80c662a4e3350cf8d8f4b35a585c8ea7c1465ed5e50922c74a047b3e3038893cc3172a930cee6e576cd24ec3e6d7e3cdf601df276c4d23a9d9327878c5c88cbe5d6b4a0ed3db265a287ff595f029b53f05091443d0ac4ee38882c0b77d7851200cc2252a583693b218fdf3b49d143e579948fd9deb5226f3512bdf6d74262474fb4c7c71329a93a9bbc88d2c939c51cd520e6475947e80220e430605366c1be34935b15436191e299fc7a16cbfc074d5523d1dd4d0ca33db825bf8bfd90efcef6841ef262a3a6a3b7ccbe0646408babafe7254bbb628686ce64cf1e4a07cb85fc085c57397b193caa8cbc003fb679d9c609834c3f40f1b2d6df9d4cf2be4c3a74124e40019befa101bd76d2f25934ac5a3eb54a801e8f0592e46966551160f7be6eac8aef782198d78e5ae5f98f298a419ef08c18c687ef320b308b603ab3424133c2307ed9b01366e548a527f9d27929d9808c9509a54c9362510f1c536e9e2fc3729007f2e06224748984b59ecc5f5cf1a9a4c1d83cf391d4762cf08ffe7ed66c2d0b01beefe95ad58e4b8f9e38bb7fa743de88c5c461d156ba6d9dce2022d4bda242d2949f22506fcb39db942c1c3877255dbc5f7344b87b9b2e2fa2ce314b5c546f6d7db9c5c72aac2e5310dad76604444da06d13cd0e318dd62d1efc1ec0ffdf247b9edf2c5cae1e3348701bdd1df0c347337df2e0d23a58b80b4de64f752ffd4b360aeb860ac2112a3ae6bb8284c178751d7c7876dff73bd12fb9441d0bfa8b69d77e2180c7dac87a622cf8064b36aff73c0bdc37802ac549aca6a4eeae0d648291c70087d611bde704ebb3e4d291512cad0a04ec9103a18ae53aef50727240040397bc78a3d4a183af6acbd311c1202b5f54415146f25761adf962fb999b9a8776900134d61561ae708be40fb3a75c841daa341312c3ad46b7bdb4521614115e5102c7dfe2249f75399591bf352b3aa21bc658f79b39340377f7cb768648da9e415a8c75d8cd7d2090e65614e59fc50717c43b80311d5f3518ccea428a428787ee432d3cd1e4c035ba5ac2bb3e53e77f2013a95ef5e1fa1bf06a4881246da75cfa44ee0961e1831ee8e32f0858fe5f256884fcedc725dbd5f3695a23d4206b3d08a5dca929cbbb7a8637126ed8d526d07c6d9390db08fbc4e48282bb7352e9cd3c561163c8a416be65319513c6d07d9fb67d51a9eb2e96d490df2afa34ab2872dd1f86621d1c4138ef53dd622e2db6eb431e23b08a51759591db6a3a250cd6a2c48e76e61502b595dfc5190d25a74450f26069fefbf24f44c8cf1ee37954a4ea78f3209c9a8e1d9c5bb5377098bc50c6750176e02819a10acc39dfe4be633a13a21a42c7ae9406dda283f130a16b292790ef764c527bc5e6f1e63ecf200b704302d3241d6934067e209ba92426296ef465ff4234fa5a702a694029e6c95597f28272f4684d1450953fe26f716750b533b0e54b299421c038eb011cb85594b30a65b5da122e4ef9def5b193b13f3953f357cb5124543a11bbe3a4bdbd19cc951312bddbf63d153a9e61cb9e60a2faab69ce0d523b2f8e97a2359eeb426aa5fbe4b528034ae1eb13053c8d68eec73300d8acb4811fe8a1c515054d452af9c0d2f8835786c4db171dd61aeb7a60d0ee3d493bade26e73b38772834aa539485e5ba835ff96143f54a47d1683eca8be5ce483fb3eb9c78cf986632407592b4e2ce53d53c5e0a98ae573e81d06d3934a15cda6cb290bc3aa22e5b1bdcde390d50a42ae149d650a25a23873304cf05a68a2dd805405e3346588f70a0e770e052ffdd79bcea0c9128018603382ecd8da18d280931e2d55e9b4ed88431bc84fde8c6eb611cb78e5258da1a55aaa6be9c82df63cab9737282c99f00e1946227dfc752aeada48dae24f5c712c1fbc2dcc391ccd28692bd4e7721f353816ceddd43779a294e84762c8c94f1d2c349514b8902940592669687a914aeb712ae99e4d714b29c709ce6b82f6b44a3e217f6778ef5d7ee1e23ce95286b6f54a492545f997c67a6ca8a9b9915408b15d9104bd888edc4c16435d638ff45d3699b53958a350a2726da0fb1cfb642116dfe80aa8351a7b374a084d116f55af43bd28b4539aca00aca4c8ef22ca468fe9159ddda4a57e15c85cf6737b7ce11d7e2c1bdbabe4cab7104792eba8adc9666a314f474e7b54bf5ee755b647473b7bd8c8cdae3c6d455360da93e6766362febc8c685dd45937a1b983bc1aca3b2363e7ccfc4a0efd50e84b31f076595dfe89033e912e43800fade0401770a4dbd64d3af0f69683b8334f775402309aae186a80af1a633b959d55ca908b115d793ca418f33282ca44364a50ba4a0ebcb49b6c74008849899e9ecd9ed1b38c05c5adb7cf2987a231f73627ae8351c7cb74304b003ae08ea41ca6926defac6456490c3dff87bbc031bd431f54eaf620945f0a00b06b6dbd143cb432e4a483bb55edb1a3f03ccf09a786d353bb4c5259ecdd50dbd84b917fa786f4a81e6cb9c5427afb0d4ffcf83a2c0da706bf2624bc9eb133b7d11716a0124871b87f8a52fe9e6c417f9e010d2618043ede51dcab43f750714d6c20b30482111b801c222a3f45a443d87d9ebabb89671e0f851ef21f1edfa42653cbf5ff5ee7e196e6412e4e82e9437da3d43ca1a8a4592603b0c7bb251af0910652d90cacfdb505bc5b0f9e203c693404610636eb470e0360993e8cec7aedf8b2a07b56b87d12958506c21c91b95d2a13568ec87495bd99d397249fc71c85662b163e8bb207a857951389dd14e53f6ef380e61dddaba44c1944e56347ca1c424dcbf3c9c55544cf70cda8ba28cbd309be85951d3a054fa504d7ff5c81ee21f5d9074edbf9b8acf47dbda760834e95c49903e4f417474e2500ceec0d00b351a6b537d765df4a83b29560fa184a00dd5e1bd3b60b3b99081b79fc45ce98e385009a5b59cb6a1ca8fbf883c8c7f9681201140aac78c15c6f22bc6d981ccbc73af39f66949ce72bb41fe7477113f9b9918ad3a47ea289a9491ec619d7c8d095b32db5c1ae9f63bb8f22af7409ee2b7c45764453504b4ee0ed56f283602b8e4570ac441a943de45d914b5024280d600a1762d76de2071aed857254507018bdf90833dba380d20eace6596fcf12f5c636ea59abb33a0821ef8fb8f7a8d095692c3c8778697039a041c759b6e6cc03000b0eb75601763089e57db0aba9bb290640e069891c255b037ba606f3cff842a98f04899bf6f1cdc10814600f19ae7c809b5390661748ec1a3bb44b6b06ed81746ac69dcee540e4a6c4aee085b48dba013122d7f8761fbfe1c653df67f5622f61306477149b9aa57ca0a61895b0771cddcf942738b2f7be69118dc032fd3a195ea155d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
