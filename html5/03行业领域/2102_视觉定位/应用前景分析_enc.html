<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"607ddc11dc37ca1293dc7caa1f900444e6c0f0e7cab84990dfa320102de099c316ab26598efd446baa0f6712ec1149eb6f302eed9ba76de7844f6961cb1829dc76247c808d82174d6f4cc4ff521cfc52f33920e621642d331bd163bf36a0b5149a2f420436b2eac16659f6fb906fca55c6c16861e0a81597422de3b6736ab36cb71bd582240853579831146d3095a4566beab3f82c73493bfa03e20ef1181744c7ce8d30c430a86a234e86e701953cea48b306d9ede498f2961db0226d838e2979e7327f7afb4415bd87bdea5f38da58f4587bc836fbd819861f5ba0299bc3b09d067ae5043c0688b75de0d0805689e3a54bb220a0235a51e35f019349a060b6e2632063fd4e54fa154be1d054a2d9d7d4130bea69500e6ed8de05114d0872227bc27bec574bb3c88f4cf778a4310162816f30144e3012b851f9df8497363d777e69a892987108c5fe6c8b29a7a5d0bc6ace603b9bea181dc018eda41647e58b39d40eea3f46b138e2099f6ea46a87f5da228bf418aaaf68f4397a396ac5917ad34774cf5a8e2232bcd53d9c5405ff5ef75f834c9a89aa1359333656c12e2064a4571f1ca83f964d95af9f2aedb35ed811ad821fc000823244c075a181f813bf3619f7da7629c8fe07d2b5659af5e781ddf6c7e210821567180fe6923b22876d1bc737e9ef502d0a7948e99d3e690b7e286c080735c4d2694d12aac6286cb37d9178c05f8fa952d924d7367ebe694e468b9100ff6cf27d959848f027a78638aa48e895b85ea7dbaa10b3bee28ff62d39e18913d7a9fec9a0a9686d2d227d91c0344650f1fac88a73ad1708042716c87e36a94b3ff317ef7a4fa30b172b96a829d4faa86bef63882eb9d072de00ebd54ed5b0c168f8d2310eee8c8683ea8b2c6bcacc0e8957324fc9882b56667f12c5b64fadd09fcaeb632c647bc7823594ed747b6d794a48e5e784f71e9a4c312e4ef41185bcc3a566e4bb9791c0e790dc84e36d9643943f8657a7cffc04770fec844e4b749934bff6399e04421e4e71865a8348b0e462dc8c675a9665a345d94b59fa8bd259d6da289c48d0f1ab8102019dd2f07e352155bba403df720b77178b242f67567ff37c90e2cae1719ef1cfdc549b098c2cbc060de976ab99a223a92affd61eba17af61e1ef63932ccca9a08893a641d11049870d0020f438cdf629c061aa97c29a4583266bb624c385be16648353c667ed3d75e71036cdbc9101a098069040a45cc3c955a72381c1d20ba716ed66feb3745baaea021445a01f2f1e0c0c06bf3289c0809f1c3253fe762ce5dde62cc5d7e4f5dcd6ff995fa14533d8a5b20d06131f1a15bd432a070f29ad8c0860ea95bcb6c809f2f075ab0957f1c6aee64b66941286f9d8f774029bca5c92b43e51e7f4f764f09892aef48c3e6a9f0c7b6f38fcca27da77e20a27ce393b9a9232719d997c19a4d0111c4b716a45e732b9d6bff1a3f3c08fcc247d96d1c75434107679170cd8e8f1abcace09bb559074335ccee5176bb4258fc000397f86ec97b37385a9fabe5543c3df4b4f36967fd5ab0494c3d5f3db55032552152fb68d2a6da743e0c9884f11dc69f01b1fc5ad69fc76889df9a1252d1d1e1878646168e9c7e1a15605ba17dc6b5ef9c4e7b778332d2e113a2e665659b222e709adbe446757bde60ba1a6d0a2b65a711b19e3a35e363000867c9794c144bc503f7726535be5e4c4eb3446b9956a247457d8b2ef8467f7c4424a64f60cd115ab1da36681b9a702dfa09fde5cc345e9f3eb5b1d44b464825fd6cf630255461310813e918bb7379145ce159d2dfd3a12b7ded4315b81696f2422e1dc708d384f8233583fddf5be65752c13ec302d7ee9d0a4204976fcb9e806dee3dced7ba1c867ebd53d185cc8c9defeaec7064ff710f983d3a3920432b6dbb9b4cd39aa6de2e4a062d9f68529e34419d0cb969d11d2fab2c9440a0ec1e14891c36f9eff3a63912cd4d346641b96e55ba0bee1baf2e2b1362728e715bca48e5c8c450205ad4964f0809790619ed7d6fbaf468cf213051eea281d266b42b79877491e85992b54cdca2a282d2af74752f5360c76a79dbe3d75a371bd084c69b925700025a0838b1307b95c55bf3387b722ef2479d1ced48cd3ee812c292e86837fa116fecf41735d2e3c7ecd0870faaf2951ed2963e3b657f22dc2ea3f91ec10ef08f8b5ddd455a9ed4f293c06bde29fa97613cab9d66882fb200dcaef1562e65d3e3b30e15415d0f70ef19824a439d1c076fd9fc016efa0752d3c9a90574fb557d34abd13a47ddb9501f898ea608e8b50ca2acfcef15436db29ae5ad77d1dcab85dd0614abc841112841545fdc1241b29e4f81a2e8b9e9382c6d28ce25368184bea04131019db008d865a06445a2adeec561e02f5b7da175cbc0b48ed40f6da429f90f05a1b04a7dd4ad0180f2be9ddae6c4f2e2da7a4578e615905981fd056e23776629d72865bfaf6fd24e0c0036289b8824cc4097c415092b4c7c72c1087cb64e0735e50cf1cbd0992f0b5e706771b7ea6cdd60808b485dccf1207055f4642f5cbe4fc9a6d5074c6d6357da26b3875394e2178179242539633177cc79ec79094cf74d883ad8349897d4a95e5ef01b89a162df8da221cd1cc1b7065001ee6887c8f1960037aaadeb64dd10fe879465e9ce11de7db6a09b67938ced92779e10064d85e4f2dde792e3765e07d147ebd4d07b84094376afc8d4f0963bb76c685f8cae6a030bfb722676a45a5fcaa09931c99abd2ce8e9ba80d7054ff5af55bd90e56e2b163feb868b41dfdc951dd22efa3a9da5b790a9ae6fc6f7ae06e1c36153936db798d6fbdc42b9616add474fbdd6f1e27c4b1b0b72b5ac1cbd385f0e5a0583e580c2e8cb8b3fa455c6d096ce939a03c7a89f0ad7ffb1c96f3169a8afddcb12c7c78cd5f309b2006a9d429a1867d2efddf4eb1cc3c239d3ca0a5d94c1cf42b305c3b392e0ed8f78040ea88df6300dabc66bb68bce6de188b0858b17f4bebadfe046fbe08ec215b333b082dfac475c40731bc8a2aace7fda03d4db52f1eda012c67d46e37e41dc636a4b31c61538d5bbb0eadbf585a653f754c47f6e7ed5a3b3a307043b2eb65b896898f131433f668a9bc8d244fc18c42aaf6cb4fe6b8ffab65cf730c0f9a8ee29996026943b214c65da351f892aa7c1dd9e976d04b58c1124cfd03da3ac7fdf4db61d607bebe48ce39738e1bea7efe4fee3f430cdcf9d58e8072e8530e2a0f302cbc5ca1778a455c1e90199b2e2ff9ceab5b3ed86772439ad001f1bd4700a313c956fccb4bfe3848d46b7b56b85181aa078e2dc2fa0b5da567d8f9f8dea0ca625f0dc7035d77a594d91d3904c18caf2c831312aab693706e6fdcaeb9d7ad6eb5cf34c84b46e2c2582f2e218214cdc7b19c86dba96b86b96a7a11c5e71466a6a7b060fd01e2b4540192043230ecb16a2eaddd6b9e90280bfe18b7fa4b694f09a6a8bd458fdcf0100d415c28d5ae7e4f6739ba02381fec819fadfc3235b568e7e97980121ee7f42832cdeafedcb164415e48e010aff956983fb9b8c9c105ad48554a86c3e94ec85b668345a7e0a861f8946e1140848a1343f3c5a90d28ed7b7d5eeec85c3c1cc8cacc48cc4c92ea7be35fc4474584e47838ec668d7294be4d445bad9d4f7d120f372342ed8196e65bd2ad55fb6b8f61fcdf11935c304f754b2b2758add1f36d5b1b88278b966d3b51ec49a16d717eb966e3db378b7365094795fdbc99ece0d427a86072b8526aa9c8f04083129ad6cbaab8d0141c0e1029a1eeba8fbb128d480ac1ec746e02981d368401bbd062cfec335fef495d43c33aae5a483ba53ce06b5c968bc8b8bc816a79c0a92718016c780016aab1064a7e0831784ba9c6f151b419ced41cd3acf476e361adf0b68e1aa4dc3ff6caf2777be503001dbbb4760b026fa85183ee049f35fad039252d4680222791224890caf53c9932a13e218d5fcf6a80c71a248e9333a7c2cd0c33595ee4d0c81da1d733e30309cb155942706aa5d860208aa035a03b29a1dfcab082e1331ee4147622cad0b34465de28e9995c73ad38b38814b008522191798b856fdbe4931a294c2bb744e41084a82627ed028f4104beca3ffcfa71e458f5f209111eed02829bb0054e84faf80a753389615eb7e5ba998468263fa046170e91eb87951d524322d6d93f311cfe140999ce3ed2ab004d37b51e7c7ce0eb8bd4372615263d3c2d273c14b607a96f6d53f2a11720e9d34d0a3a53d598604563e9ab37fce0b2329e40f56a6d657ffdfd6966d14dda7d4d0334d1bd0fb8b5f1f0a9f79ecc91975c26d760a11cfff36aec14183c2b0914de0507aa0ea91c0fc58367fa7acd176fb3cf2160873904e80ccea5827dc08dd4e7ee776b34efab715f54bff4356777569c1f77c00e5293eded244beb591c7dc88c2b428f4543dcfd98011bfb21bd7eb67f186d97e558893fa1884a6fbdad94080cf35b0e30a3c3dd57623714cef1e52326227a32a5ca55c21f87547a67baf5561723081152f92aa4ba0dcd2f7d7c459ca60de83d1ffa85b53cfa8357e543e64c9225393a7e26506da29fb2330071ab8305a5321d215eaed88f870e6deb9285f60a3a85cbab13f3b9beb64c8aee6b96a60933648a0325b37b37d00aa9f3fcb44b716575169315d9b3ba7c7803a40a2d610227331a06ae52aee25f8db6af12a6d13437edff28becc03dccc0dfe1487a0877f78e8955b70a77b2b2145e4361f4a461d87907c4ab77279a99185ab0add6d050ae41b06d4269fe4f1f9e61151f091b1e2fde6b111c62fde55708b81537029315e83ddcda0775ff63601628fa2980e733ac266cdee5e0f87e5b545d5523273f25dc6ea7a64daac6931790f107d20afe2452d2ac4c7b238319ee68134c866a1bcf6dc7acdd3aa1b1a6594e34a72a5b24141bd6308359dfd294fc6d8b06ca542ccb2232be379e6bd0e97964a7b2bf3f97b2e28c426497370a130bb6349b5ff5942a10bead90c0b478819ab0e2b6236765f0eab5891e712745bbdc58e3c7828cdc6ad7af053086220e7f7d1e7f4a1eb8cb925d6c3fe082e9d16bde85977ab9c89f607e98ceeb0465c95980f7272d711bf5f81a76d96b0c034f89e6042a8d589af785c0862508c3f09aaeffdce6fbc53336fd7f04590a54d5738a9bf9bc0b19f2a46104c9a585fcd1630cf4bc12e5f4713189bf482730721f48735fed39a2b8eae10efaec30f737d71df9f4868e81c6b9c16c90ff652e9650827de3cf232e1a482ff84a22d7928ea0ccdb90a4ff5457a732df910a3bec636691193de446a7d7196c8aaf422e34cb0f22f88808e83e7de9a401d57f0bd9d9bedc1e959fedeb31d583cb9e655b7f24171ece452eba68edfccd13276fec46b04c7521a5395e5905afa09a107c6cd0b9464d4801968bddcca683e602256833226b0e7fc976e77c59f388e5ed462dcb63282d39a718d243c969aa158766a7370468df692be068a02e2c625aa2ad813e1f00ef49097567a16572b3260bf6a1e0193c2de312f6a84699433bda8a77412c613b62ef82e1608b521974e551572b73c9d12b20d54a11240975cca2f305d13578554b1f1d318b0f64459d7e648b66ba9fe0e55bf03e0c2be93f54735955fcd784f0a3e0da2bb831a65add69f8673d4c62e39bbd2c7caab876804891e033ebf0e6710d51a95fdf37c2796ba2205b30bf1e46edb47c76e76b9fbe959892c5b2ef127603718d839bc0123328ed1dbf75c5318106ed08bcc611eef7fb1e9609915b89f96aa4d9d76f22e71d722f146291ef87fc0f3961460745603326ef6816a5b513ae2fccb2b71ddbf0bd9670b56653f2fa440c094a2c8362c519cc3bd4dc91fb93f28ed99cf21fefa3d343e67b8eba63c296ba574c5f2ab9518bade009f7cc5d0a0540ea86bc68cb9c961ecf2f58a6a2149a05fd197ea54609f2adbe6043f3d97ebc6ae95fb70abe9b3c2b8c44f534648a7c4cf73c0ee820f8c625d485841a084fe1a23d13867eec65b404ba33a20cca7db5df209874dba8f37b1060e57d570114b0f1033c9ab12ce70d0875400b3c89f7359868d568b21981fe56e28ca0b617aedfb5f4262b76bdad52bca95b1fde6c48b005bc2c41508c3f4a9ec2f5d4d8ecbff65ce5bca316bdf4a129f605818a6116f7ff4b6344c69601faff3ede7a46c5541c89c848287a1642cbfccd9bb38d73ecfc2c4b360998b8a677c8457906530f34c311202e6c8777b41ee3716b57d74ef8d612428ef44d16d9bd97bbdb2ba0cb51c148533bdf51bafc265416014b7b95b7210274344a98e3446a85badc9f1bea4530d7c308ef6f910cd15254112fb8b7342c9cc02fc70b66ad538698c5f0ee75d4290bc707bf53a171bd6034bd31bdd6f1b6343521935f057f7bfd7b0b9f36cbef674a5f600fab8c892e66b277b09426ea7eadf6a7d0122f026bdd1b91476406963684a5a0ed439d1557d7c35118ab9996d1f840fdca6e61065148a503f5808234661c325d37c43fa01e5ab5fce9eafd785a887f9eecfd05b695cad340443e2129dfa9b431a9a52dd3886ecb40812a19d78ff0dc5bb52c1ab69c1f7eaa55f6a64b1a09912167f04e14824cbe0b400d3d9c8673a88315e5b3c2e66456a4f6a918d6d8739bf1f802fd58977f04ae2dad2f8ada481fff349233273ac28b0b9bf8c7e2361bb44184dc260d814217671fdec9bac4f1773ca52a96c9b4ade7ad8dc5620b37a84ada983a6dc5762f3c679e6cf8060fdea330d721f5d4326a5cf146bf9adf21e572ba3f80b9ffd63e02452aa3382d85ba1993032b9b0e2a7a0d07f0c0cfa35989270900c6d73b8aa81c512b1d46933c6d90aebc9cd204f593c5eea60191fa069ec0102fadacd512e82d46b22b974289fb9db319b0e7c9ed21efc9db1bcc9296b564452cbd39f5253b650db39aa7f293a948d70c6547a7f576f66d879eec868405597123c3e9afa6b2fae2615c50ecc4966eb4df58186b81293e6e2f1827c9e97eceea9297b7faa8082e37dc653b72ea41bd9adaa40ef9066b68e481aca23cc3e5e0e73896764cdd3853e41536c630fe021dc56c18020acfc47e160bbbf05a5d90997ee55c53c19725a1c13197cb5264916b5ac9c51f2858dc958dd0233bd39633fed2b4e075a8814c176ce6acb3cecfeefb01640257dc4c3b09f4cda1e5c0e2dabd651380341653444ebf4dab8a3b0c432e99b739513c73e6113a28a8aec064ed95ad917b79cbcd9d94130cb2a4fa81790752b12292b20164a284013571ec9015cb3e2555eceb14fe664d4e3ccbe8cc71b0925236bf6e0354ae9905ee1cb313776ccce1e97b5bd8712625bd4efa28eb554652c5f5a6e6ba7ff08144dbcd3a5ed0e220d34e33d2819c223ecea32bf33350a487ed488b6ac3ce8b6baca81594e3fdb58db0b7cc17c23c4daa5f08029cd565a59500eb080ab2c7757cd9895c6a9130a4f12fc08fee0905f39a549e89e7df1600eff9b8a15e7029a0794ceaf28f7ea6329575a83bc9ad385ac18a3ea7efbf3c8e597b20b184970f7d14518634cb75d8be6b9618516e836b76a2dd5e394b4ab5d6d2d5949b7a856fb9270cc44dd0ea925563447b43073d156a83ceb51b45aa992958d499139ec7189321a37fa678009ba9a71eba0818564bc264c6eb5cd634d08b836054f6bbd8f4d0d9c28f145d7946b241850e1d346cbc4d09b6cd9be14d867799d7085d4c3490e6c7ffd7359c15ac3609dcca7ef022a2cce65c12f8c207a75f4e4e5c96c74c3ac7bf9e9866cdcaeb540041e4e2df368c470de302316e457f440f9bde91750c9ff3f632efd1070269b24bd431f8ba5cb5f13ca4042216dda5e18d0cd302ef6303ffc78288eb1e3b9e611fe79abe34fb4c5f9178983296e7e37b21b8809fd5e8123162ae5638b4272d12295bbaf8405b6067e556aef4cfba2c8b0e87ffb2319902d68de5f09b5b06356a04c71cce023a3b85a21bd88b31102528fab1bbc8d6fe429a8335e6b80db82c129bfae8637bedc7d5ebeee1d399ce365444b2f7bc834f916a10938ba0ad4f50f8a75f4cbc9ed8573562e58819715267a95ae0d233c6dd5b8de7ca129e3cab03af92d8c138655f5ef03dea789957020a453caf8789a42c7c68342488a71f952b5c9fa7b225710e377eadcf69efd3b3df9c853180bf1d76c029283a32dc134acc85add792ea40c83dbb80448c66fcdc9354a820163f14ca2f47256398c6516e8657686b87916b78cfdc4a2db637cc90c8cc2d3441944c617d43c8914e690f0a53f92fd5575d0f2741b93e28b4c60080843ebbd83791dfbf2228f2998bb12fa078903bce10281ad637d1bba78a45ce7e362ba6d73b1b3452b23ceb01c4062611a8be2043c850014161a5792566e996d3818783e7da6ed7bcc0fb57fe8ea788a3a73a72325c8c769aa25284c8f6618265f9b2b6a448ee5fb57db42abb315ad64f2d685e6275ec64a874a00731c74e28426a364bdc594f62e2f8de00879925b9471fd2f02b2ad5e040a3f1909e7b19ad252d9e94fbed0bc92f45c0f99e25cc11ab629c2c0b4f781642dd27b560d7af0be6d633194a0b0b2d0563f4e53f9d2a23ffa7bb87d8b3690088f249587bb1a15d322ad21fd3d026d88d773fe8b8f5f1a941e9a7046d47fc017a13f31bba7c9a4906bc79ae35ea13cbfac0be896a532caae754d4873cc0049030c8ebf098bbfc79ca138c9141742991fa6d2c410e103c9523d275fc7edbe9732d5312a98671b20c42856771f78198420becf3b7a3dff32c55b74e59f2f2b4f50edbb0cdf0c1d2937b4fdf903a53b4d27350338dd8f4945e16aafce23d37b32872bd0d6978ad94436312d57a648275252eb8da8cd0a82282619e3b03478e84293e107fa53580eb81e28655a143814f72d45c6f2c1c365110ccbefec1a0c89e098e054dd1a59ae0c9e33eebb22328fcf37281975fb0e703c2110c8ad9389cbb348f7f9ef99330763c244886c5b13e65495071bb94eaf1ba3a2932c228f3c6385ff99b5535b7523879e61c0ce39322aca00e36b09976ac04da0b79589639031c51161e74a817dcf6067e0a145bad33ad832ce33c10d7d49df0c253c72e656f577da8c2899a1c94a5cd07442aac006929568e0e28088f52f887363a8702c1dcef91f71a129d32f1923a3529d96280269affed307f47cc23b3c6dcbdacbadcf3738b896a57e243a8997f36fc7cac6ac460b0ec0c119d4f66b6bd54e2cb80f5655f23494ccffd390f9db9712a8ee91a3440b9855a153ed302e3a144acad33ec32c296bf3515ba490e899c8b4d8b53ee469e86f65a664aa68f308d55ff195d268b91e1bec741f8042d9774f71a8a22afd0f8e89d124f1a26558bf7b414028739ca61256474f1f2d2b6c8f144134eaf113908bd568652fab233f40f3ec498611275284fa1c777f5e6618147a363c7bc8e1beaabb92f5df5b294533a1e134f48ded98799408980e470abdf20287f18868f18a6a40ae08ba1133d5515eb367a1e4f63a7cce016392d8682d2d208f6ce5a154c8fcfaf856785e88f9c1acfe3ebd96aff293bfcdd2c6a63a2f3a0e57de58c74dba9fdaa20ced4b850abe0f21905969a6e4c4566ff47f3274c23d47536789ab551b7c64ca13f88fc184615f788ff0451506b1feef872482ccefe6e30ce905dd3cd308b684e98c1349c4a6f147233112a65c0035ed7918aad8c235afc34e6d5a4ee1c109bbcf03a0a9c141915c0cee6e66f57e8bd3f3a2c02917e3450f13638bc48c470c5010a0119421ff1bde4d766eee42d7c5b45b8c1e9daf502897bdc386f4ada927385a34c2b8580323e8388f8c62c552d7e18b15eb8e29b7f3c6a66ae5451441808997ee5e4f977bcb4bb123c509ab98e9488e52bd31658e5a3ba74b0c8cdeea2cba05d58baf66096d8f639e3b04148abe1cdd5577ef9781b205c796bbd4622916b04d5234439403dbe08bbd13e6c5414854b0c01dec7a3c1a393fa93f8d8ca1d1875063427239805ef8c49cd55a077b40f421c4bb13082b48bd44f1d2ee7733bdecf3297b339b570ef80c977b0565e78b357db3b42891f5f1011322a06854a44faff9105aa412aea745a8349e36236106401c73a94bf3bedf30cbac7595577a9684c6ed06b09a16fd50d1feb5ab712ff40e51c4cecb14bfe4674ab7da4205554b02348409601bfde6df6002fffef86c3cf1dc6040398ed134aa8d53a149966d4c3912b582000a0012d94464ed30e14993e98fd5a6d6d0ffdc3ee72a8068105c3306ed43af2f162aa514bbff00946e619634634dc741218938f98367e05b798b28f1ea3bf18da361dec7e6665895366127c4eba52d1cc52a3de7ee5b736d9f42a9d51a853b61b78e3f1eec2aff8a6a57f26043d24073da361f781b9e66c1c3e4fc54653b23afee5ffdbbe620a2c8e4f24e5722b2228f971ef9517f90eccf883d00aca11ed0085993b900a450b72317c574189353c254823df54fd1e74f3731027a79ed26c571b8697e6710ad1fb947d18ce5cfc1cc31cfc6c5d9eee4fea800ca6d7f238bfbce3d477fbadb82ff70a6dc2e94b6fba98067f98aec8833b11657db233a4f3c63e49ce3b6c817ab27ec2ab57cfe2623f0e213c33e9f3f017913f5a4a896e4213febe91bce7f2869523526b3fa01fd1f28f62ba487cf2ac799896c77aa3a3b9c6c3b95673edae2689d2c52b55a19c20d621c751caf7f6b3594a2effe4703ac07aaddc062ddd34e72fe22925429555fcc066267885a1ad51b8c309a7cfe3ed24fdc92102ba02896985e2f79908a3aaaebbe7e7382f9cbc6ceb7616e17087ce288ece3bbc8913fa8bcb0bd8180a0e49a4a38fb8ca87db807ae143cf2936a92c6ff884aa901d636facf82c26358e86d36120e5ce490f245552464fe2435cb8241cfb98499f758bc4d7b0748df1e606733fe1eb769c94f949df1d69cd4357b2e87ea09f25332b2d98f0eeffa881864a45b8fbfabf30e2da47541be9cb4a9a5fc2b0b7a4735a78e26d63637951527cef01421fb454f24e16a22a99b29114da71ef2eaca792d8b0395f056bcd0d909574f60f39e81c269921fbae2b678b3d05878b408553fbf4b7e7972ad6b216526e5d80fc9c1fe9de0da9ceced66790271d9aa363cf69fcea8d8182455b473ba951f2d5d70e26f277ce1a8ec8c6e9e9d7afe9b7192d025004baea18af55316f92535df07831b92a834c5cadef7acee429b5b4df320d8aeee3b20d73535c27cbd327124ec4ed3eb3187fc9f32b3b0592bf90678760ef104d211076ebab276c45e0a16c66a8feb69f39ed18502111cb231035f0f5bf9b1c78459eab4c652abc093a0c5a159c27a80ca303d09293d0f2c4c3fbb67e88cc6f69e79a2ab2ead240f20199ede723f40c46a6817d5f8fa482843c6c643a17d69f0ea0cb0349a3629ae16c937005eb0a46c3f12caffbe996785b6fc4d39793a1fd5d105846cbdede84fe1b06bb7e131ba36f5ee7826b9321d69779c0cbd8adf285b193ccbfa32a9ec9a3f290487569877e988990dd21c05c2866187b8167624fa9ecef74ac8403f7864e53137be669f594dee0f1df028416edc9572a2d220255c1f3de11f70d8d0f845c870116140b9c2e863fc0782b1630bede2b352f03f81b6b4af26cfb96c1eec85067b0631ba53580fca2efd46459232d74c46d0ac6dbb757203cd68628dcee43bb45961a1cf69ea0f27fdae3782882b23cef3dc8366d88fb2efe5108904a0bb5c8a3f459223a9cdd09d2526beaf2df1db30f32f9b3207a4eea30373d349ee1bbd661d975f65d6aae8bd05c331cdbcca9d565abce999721de2ae3c1a36e70478d5a0e763226b64dcea754b6f9e070f1d5b4e81bd18480cdd00f8304490f010b56206d0590bab4e64072c3affc84a6ec7262f6307ebf69c865227c59758126104b4452ec51cd9f2c383da56d7ffa2e1845851e7ce1d0e36456845f3d85aeb76b7dd824c758e615d47146db19a49396b8b9ccdb67c9d3e85d645a6ced49ffc98f8de4bc2967f00123160bf9ed717b047825ff975c66ac0545386b4ec3c48cd5533ae40863e1b58aa2e81bc129e81820fe02b8477ae3be37df2e1ac63b467964fe1b9b7625a392b6a8473b9913b9c38bdfbe832a0453681c937b22b4b5c5703516d98c649889628b3368212b4b47648103ae0df7bdeed438d5335bdcc84224e970ccad4e9c082626924a53c008fe3a2fa356799240b05adfebcb2daea5ddb53b7d211d4296de1254ce1487feca51351ff3761b756c5be73fe9b9f166fd0b1afbab3a56d44a5f1e1b9068d9e8bb965cbd4e8497cefb69eeebaca45a06dcfec9eeb2d21b5d77435956330814aa14f82b75e27f4f7ae6a8c18e8819832864e71db09e9f0625780ae8dd34157ad9848505a89a2efe3f09bb1b02f5a2d76b82b06032af122f48f31f31f142930b53ee9396f1b556cee6d19d57033f428699601d003fe24cb0eb1a95bc734a487fa8410203d4d4897305bdb0b11639ac06bfac226eb8f93814ecbc9031e2b3929cd6dd120fe6afe17d22c7371554c1b09f6cc8c1ea6009e4df06b1d7c1e0f4c36b40a7fa772e1fb74fe83bb1e98da3a0f7be1f47af90e5bd71e78804e43d2d7a1c5cc7b98c0b2ac711aca769ebbe6331b57592ce2aa9fe23612bf76dbfe12bd51eaafd1231a4cd36db00ea9ce534bec410899b0174b6bec4c273ba4858005a011033cddd4b5e74df45aca5afa4432a8770073e0f7aa6c31f677094badb8f9475af7af20ccf81512c0d01905aaf961f316adafcbc30c17638e41d2d91d6f34f8ffb8312472f371960c575d44a6c60a78e8f5f5f2b35fd6d6c17b29ca76ac02073da7818966d45cfa0f33494cb657fd2907b1c603ef75cf0fa201adcfe2f5cac94d22aa64440840067aea362a2c48063e5c2c167ef90210b7f6d5c4ac8e65eb10b145cb32fd4227792408edab6567d2ade1ac76996db7c90fd0be3d997c4f687b135e7cf04ed56e5d62c8f9105ae97aec934e58bdb2acf24c1ef2bae8a323300fa93d4fe522184f65ab74fe32b2588d7b896528918b0ef82d427edecef689d0871552bfc20c12850aaaec9961d39dda8f92f9aac6ea621267612d900b61d082217446f9ed915c85ad55d6d9a8420eed9c975bdda5e6757e348fb0c56b49021965f41e95289227d42e81eff9e6ebcdc5ef5247fb6c120f01d95a096536358cb444989fb9e218df135278fbeec03e85a22dc71a6c75941e78988f7dc79f31b6b991ce062eed8b886f32530481ea0a662659b526138a35fb5b73321d7529d90d55952e9c99e9a4f09cba2567976da8c45ab62dd524165bcfc14ccf71fa36cb3e8e2ee899e8742e130aa3a388ad58caf1267c443121e308355d3e69a6a0b5c749f2dc1c36faf1a0e21948df9d46507ccfc0e9f8078214dbea012ffcb117a73ccfd8d9d7cf3e5cf7d58c697c91820afac3823975fcda8f87a44cfb2aac659d31e0cedbd1d875ed9d4028262c59d3d4b2c5392928efe8cd80871e6a03d9e016c93bf1d5e36a45cad58623d9ab748ff8a2227ec39476aebbfeaeb03dd22520a6de2203a3fb201a011e3dda301ca800da0d02154639e2fcddedf48694be12c2a10d0ac191d9b7d06fdafa7018159cb89e9008c3c3c946d86018bcdc38453410b339c61b8636b237517aa9745fcae1020eaaab964f6e6d72117d5494f28f271316c9fcb476d646ffd6ca5c72699c3828574a253908223d3ccd6ef2a14002085c3ad65576027f07c46ae4de63edc6351b8f9a673350faae8543b6692dbe5a44fb89ebcc7c8fa60068d9915ad5addc9ae4923d9faf9859854413211783671eb027e4a8065ee5c967968e327ac454e3759754f11967ec56f9043d311715368947fd01afeda8322db351c1a2e618eee2fb613edec683b0afc8f0dfea7efc332b53746d52cab4269c5b0f7c80899e4602ecf9642fcc6dbb8a563abcf30a1673753fa32b184f21baeb3c181a7feb90e74b8973797b7bcdc53dc1cda52fa7bcaff2a38ffae726e2b7d8774a8c7e09fcf2dd2ca019b4ea1cefea9e103974f8c72c530638834664f15ad65904933a1d319eed4404b3557a43622d6a0bffa3907dfa3f3f497d4aa9cddde89656044b98f950016aa513b99a64e86c9de4877cc33987e486db512c8e0ed69ba4a524c45b09632c57659965bdc61b9791db6ae83fb4f137ee39ff602a03bb88bb57fb645e9b3d8ebec4cadbfdb839bd071ac97bc85404955530ba2081020f52713e3eb1408c01834ee643e06541b14e6ad3c04adbb6396403cc5cbbce843b2d309e8e10aebd5de952c13f33ed3c5ce00abf3f2edc06d7aba199f58b7745e1f8cfc13baa2861b4c69c3e077101f3b45e379667198d591c99ae4fcfc07718a2ff87f4b2e48a6e22f9c5fb01d057e340e9c737de5a7046dc07bc02a69d08dc95e7bbb49ef13519b9eace58a7f87b7e91eed7791177535eb3167c674a37c0337521feae0f503ed17141fcc228a2c501052d78c47466e34a88ea01112da064ed75d99d200eb42d8088d42878bb0f7d4a8b4e4303f88cf19c01b1f59ec647fbec83de82abbb6b846b1578e973f5feebd2ee47d79b92d1f38102a933e9754f8ed2763cd0b842a55f1399bfa202c1ebaf975c8a08f626b7dde0af1a55a18416875306c20cb102404827b0561a8394d2a1ef32529828cebfdd2d5180c4be0f5bb4f954d94ad375f4510b0727a6cf924be053368e53d7754175ce638027bbaf001dc5fb9ff83faf0b45d755e7bdb89a69429eacc2b5efed859eba197206775dd417f8c13e76f93d259521caf58e7b2e3e5f2f900a5551fb7603c7a73426a6046f9787a5985cca263e7e093e2a7085ca8a5275bf1c321004587d374daa5f2ee94b69ce1d58137593d972657dda9ab06327689e9c939ed77be3a0d92a28cd99673a45fe81f43e216606c48237a127ba48b18f448e244463f2ec5d190cbea52b4d130029d0873983e99c5bcbd8816485a810578e5a5d97aeb2c7edcd738a561a229824bea15b84de03eb0e9f2453798463d800d7a8a5486f5d8cd938a75b734eeb0069cf6a347878c853a30b5ef319f0841ffe5bc297484b4f4753983f4add577cae69800263c17e568e7318dd1863ca1fee7b7e53648b66b2d3c89d9bf2e21b6a19445e47b4c5abf94bfcf6b29030e130667b366a794f03b6827d98fa05e36c8d5d2f102ed2cb81b2f6db504041bd10a16b8a2234d4aa02666f49b33209326d5d546fdad35e5b527e8780861714fcac6e84aaea4031e4359e1e168ce04fe9c2307c66dcbb93dbbd5378ad7e0bab4dd296525aecc05de4bb48157b34668fc988ee0d9ac068262d377b60602168318becf9b0a73c3a1f24a9b370bd988ef69529a34f8e3d8fb99fbdc5f995a7d9849842b8c01a43e523a47405d1fe857edccd66a47c117e73d9203f110ce27fe0d25f078b9939eac1d02158a5a3ffa90842cec29a50696ba3e4c3112dea763d49eb96b840b092173886d5968631c60c88388ded44a295599dec1dd9af9640ab72096d657b0ab85561eaf90af9df9c8596362d50dfdc7b787c401913a57cefd9eaa6035242119517b2efa26543e54d46ef5e03d65b6884dc32ac2d47f94c1827b8d5bdbea26496b1e877256a211471b9f42f2dec7a9f30a415bf6ddf03935e9cebd145e6d00fd4377ce073f90484ba9be2dbb8c087d34c18c2b6dff8e3d7c0d2732f308e9476e095641202022fd15e381f1af6b09b4e609c6f41772c3a2fc0eb1dcd632cbb48601b17e51ed53bb60f5e95b11242e937a205b0f584b662c1af6216d2636470048ccf7e435028455a2c7d7b0fe59224165aa826c699123cb5b40fe2f7874e155aee69e7cdfb866539d3caca51b429adb48d0d4d315152f05e1a5a186dfc7c4dc5907d1613c7a02dfc35ee94f178170f6cde132c70d546e34a421f91f3569043895e33cf08ffe22f161e2fc6db6477584616fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
