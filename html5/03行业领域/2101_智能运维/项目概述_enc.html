<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2a8dae99686c5f6d6cf5971c9964bf908fe3742e32ea1949ea6c60e24c238161b6bcdb0204c12d41bb2e8d418082265a6cf796949d8c3c0a741ff07a5169de531086d95ee1136d1d45e675ff70fdb508163c86a6bd6b82fc6da8126f3495311976418ed3de09eb0a1398d39555be00a91fc95eb6affadb85c038772d46804f3643afc185f4b9e344fccbd634ca15e37bb981e03417b78f26e63e6ce76c8ad1489f0b5bb7fc5d0824044e3e85d7ae40e208678753b949f346a635a80f827b73025dbcba40d5b048ed3bcbde66248450e0ef1723e2401c808d2561387c6e7364cbb13829888e5e012ed0b02ccfa79372b5f9ad9484116bdfefcb9d45a4ac78b6b4392fba06c8a440dc9b1e1b4b42c802861bad265834e969bdc1680fe14af736a92da258db171fba4036fdeca3ab53e760e838d650fd061e182ec8c1961c5604115c7419fed15e40d2940acc9d3b743b24b6285d2abe41b9fdbeb23cb66837c3ee47154be6e5accb5b134eca86d5d77190ce94c24aba4680841cb047f9164d6b923acc87a77430e79c60caa73eaa6065284a8634ccb8be99c745730fac0fa3b7b472047bc1131e8a76b6ac9bab5e9007d0ca68bf4870ef980164aa75a9963a49bbac29f1fc128fcb2b717a05da80ab62b9ce0849b053bdce9b8073da0aad25de3407de9cfd88f0627d1f1ff60fa049ce501b47f7f5897ee48c9e65d539ae0b85c09c1cc5663e4e3cd3c77df06be5cfa3478eed2c48513b3f2b27707e0ca2666afb79a9490f2832bf1776e0581c5dffd5b379ca2db5165b9aabd04b11041d5597cc26fc6cbb9699cc956dd7b8766d6187681f6fef3bf68c4c4ee21fe3a7127b82d9e600a0813f1d765f9c98736e781cbd60cc050ff5dab74286306e90885d85d91ccec8ed7022984d7306236660b3c116dde3641447ba563e4bdc188ab18cfb65f13eb931924399ab4a90ce49d25cca71ba2c122d46f45b5f45a394a758e8af3b093e6fd7541f4c3e464910da89ab1ae48e4800267407b656bbbbea3b3bc0c87867192aba44441cc935dfeeed669815c72b7f53c66b77f26f61fd17800b2b101357438e8e8133b78719fe6fd12caa3bfeda1a2fb8f5ff249f48c76d179622778ebf05b31ac97236c80cb2ccf248be275273ffdf6e856d48504ff073de03c2ef5cc5bcd41afd289f54d1375fa35c3d06b33d054f685d997851112b36c1e2b4c2540a1a38a66c2d52ca2f4eb15fd59c8476efed7f3211d564e9f7d489733fece219a3425b5959936b437820e18bf136c7b0c79cc8ab131239b55a0afa4ab0ab101616b296e4e11be6826c8e82b0757166ea6081763c45eb02c11d5e5bbbdaf8ef228e34a994eff6f050e5c37bcef3c460d3e6a0a6b7938726a0cf03be54aa6128a2de132d7c46d80fe9852b43ae20f38a287988ba9f960fa1bc79d42e59cf4c96f7a5722b77dd9629575f3941f6085c144037daa2756310f959e4531382a3e26a8cea41b6073c56825e64b173894afbceda24f4a53368c1566929a06979d70563dd4eb49923b0590768f9d590c3bd4ac4d788d9aa41a602bc45a2d0c761fa92ee0f63a70faee07c9716772e01f757124f624e740d8e2d92c9eb2a414b9c10a2665637f345460f0113e2611299877055eed5855e7e885d790ff89ab0f170c3596c56ba09e62326cbee4c564530bb92f6bd50ba0943bb0eca2a3c3701b9e20f7d22d89d3b6d9ff706cb83ae48c3256c49f62316f07bff31d86e7ef74e7b9e34da5904163af2ca784387f9dc6cfd0a4e61588b58b38138a1428bdfa51ce9cdf6c113b508600e402732d5ce20f40bd4e998c90e983f196f9adfd25bec583f2ea43ca9236897495aa9c6b943e172ba18db2a686082c696d51ef32c54552375c00100d3b44234e15bd4db2c9291d3588627d1dca930d9d80540827abb3f2d149fd84b6418dbcd877055faf3d58ff8fef44005c9fbc0c5c8b9b9370e061dfb611207fa80291ef2b1a84ae6e792e84eba6d91c9c72d1af52e0c4679adcd19ff76ad9a91bdd2c182ec824def6f67fb01cc42241853f3a70d7f5fed4a58cd303ff5bdee3244ae026f37f1a533e2eab15902e3f7ad462fb097318debd75846cd40092d56822a36f934067457de88f049b4671e1c752e2597baf93f4a25109f36098516920b920d4ad6fe5df6c7252f2d18fdee7106e7a58c8103fd92b3dad552654c6be40658292ee041fc0784815adc5690de1f9835eee16708ed21d11652ffae3f6ff6dc4602c6339bc4ba4857079f1f57833caa231a22f5540fe4ce996f210165b8cc436af55a9ef85a71c1a056f10a5eb746832b066bc6db3be9bb38f88c9a320e8618431a465c3a9504813120514e3945ee88dec591d280d9ea2f65f822f0824116e82164b741122bada2b9a0d5283545a18b68da7ef82e4b09d4f973a60d0014de9ebe9b5fac559e1c7ba7d40194022e6cd4e78324cff6298a744953c013e425b27b6e1b16a7208a0a78b2374870817968ed7ff4b4c7e7e9e49332153c3163befa2fbf09ebc13c8061dba173071fcf1f7edabec03d2a5ddfcd9e20f440921bffce583d8587201b8030edf41ba641e55f4c1499dc8dbb12e4a2b7bc4240b5b5f1ff124fe1c0c02026b50bbb10936a277de0ae5ac189c4243435758085d54b6850883293378bd4b60ec8d7a281b85979100da2ab3962af853014ae9bf26bb72ee2cc6efcc44240a216cab03d26984227c27964c5a5527c3af9a4bbc9f9bb67208ce6bf4087ec298e58d9053b3912217d34b7fdde3b8991b94ddf35a6c2bc8a927a38e70145ae61a158b5885b2b98962814c9f88769ca23de32eadc0319187b148c9ff19c6ebba6a8b2908bb5048d98ce700b30dc84eecc934ed8a59e2a10f11f6dc930c73e0e29195015dd28cc0174becef1e140b917cd2db863afef37f6238a7a31bce7fd41f66bfdf464a418bb943542ae5ca30b80ff7eb28b8f1440b22e1f9da2317e77e47c0470eb182ccb9945251aaaa32a5e530aae8df14aad11230e660581471ec688f541d2013f16b7c12a31955a3b35d647dd050bcbf6b54aab346ad1d86b0a12f3ea2646e185ce664606592cf1b8bb6c0f875b0cb20e6197b2af22f77f8545710a2b0d37d380cc00efb4a2d6ee6410ba7e1fd468c1c6005275602fe319f87f53da7b1b2649ea3d290e84dd89f2774fdd32f9f25dcc608d7490aba18a7e5d6ebf554260356311e38e6feb998e36fbeda2c38ca08d1ae30df9b969639b136b53c7bc6fabd23baa58d85a8d471465a3cadb7de1848070ca7a793e4768b2f576268437ed3202efdf18f8233ed9ba9f11592a3ecd79dbc9f4cb3b4e26bbc12449b78bba1f58d9341b9ba0598df01ba1c4f9e3593baaf23703a0d7d52416af5d1ce0b88ad3ed839da6fb4e138639433bb098b0bdeab84e67cefc1887e3c0d8e4838f893145af43362bf2db52d4091b6beefe43d5af893930a8f6d50d4e47806c3386755b4cbf3b8573d290e1be96da2fa7dd8bad7f6f8e5ecfc55dd7ea7ccbb0ea3eaf3640b1083774d0fbf74acae1ed22f14a105f76af74ef597984e1969d848f21ca6f0225420c4551278982ace2b567819d2dd89ecc04b49d0474d6b5896a14d3fe03d359c0938d1923e8579c31c4df8fd2f21cd968209f70966a5382d0be625a969e88e9903aed5697612becda08807c7c0b743360a8fe606c384465c4d40810e09a4ce8bed53fed878ea672248bfc6d69f4b60a739f5601e83ce2a223470434d142c7a39341b4c66b05ed42f573aab2801233c7dbe619d99a400e58c6041fc937ec5ed1ef96f8c6d5918b98cbadfb39a38a9d422040e8caa73b32e546f75b7c8e48e45ce4c8c6b7caa4858d23cb5a4f18e4595c505442491ecfd28300092fe1e9c8f5c0bb150f8f1ce2e16c2044232011cd3526841d87b865487bc10252446e989363268affa9929c6c296fe033c63fa7e0d4729eef5ad29dc07490c2bfe2886c2806e316328d1b0ebc0f16c569db5ba87907515f6259d5a2ec10a46a8bce41354fd392cc191496ae8dc162ebf34efb9dd95b294b429bc12eb92ea5d6510eef6e76b625a6d2176e53866876cd96a1657f9bfb519bb856ee917f6030da7b5eedb885166afa0e0022d2ffa45d351da3fb8a4121214a8dd4d7afed6c17a08280d867e5bf793ad46a6ecfa252a0938d2762cd56f385f2c3a45c5c0a2912d6f069aa4bb481e390e693777f85020c3241dd988685946ddf961aa3829691b964861a27fe88bdcc6ab6d7dd7a333cf0093a63d12ceb349c9ade60e60f6582a0a9a06ae083256ecd26a84953ef460ad50440b3d5d7b760b84575c75f561ece11c850361a521a9591b00ee5ae96a5e55253cae10f88128464c03f437f839fe3aa2c83aa6806c090e2a83db542efbae19aaa1ee2d700c8e2fc0054ce7205b104b25d4948bc5449003bc01513cc4303c24216f8411d65f45ec211b053fe3358d96c855b871bf5ccc8983903a1d06a7b8a6e0bbd907f83336b0b75194b18c8bc2f71c7dd33eba8ca315048b5173085a7f275cab604761e23f97736339df0711976049d795bbbccf44193979786cc3549c1e7c77b368ef14a83ca7d8ca70135924b2af2806fafd6f5568a27f4ecb8d5193092766a7e031c2ba7036a9faa56d308d4c0228e8a6ec3d65c2d6e2e3fa2d32295fb5a9325421950657f941cb3940d78abb1e07cc295d7b1cdbae6421c1a14b37e9abf83409b24369b0875e398b2862e19230f180b2236168aa4a6f3c1216976e66abf8a82e8b0ce3a497698c2d75ffcee2394c8bb879c9848f6e58f02565e279c023dd4a10654dda6d8f4eb2a0846a4e98c375ec231ff2f3fd1d5663d111c74ac0e9072fc7e6af19db06759a34e5db7b922617b92fbd5fc2e38a78d927edeb4c15ebb6401aa0242b4493153bcb2c2ca95c8859764a704c4657d8da823b81666545e8fbad75ed0d971d3134d46a17230ea489783cb81e459e378c4882e78407b26370666e03b6aa11766463645aea2253cd5dfaaa3e57f6b1a24d4f9f475568ce0e3fc3f98be5f26009c3b78ebfa7f440a5e3f1d4f9f6f3869814de2186c9f1d53506838ed24080d34ab3522356a505a20a88ba1c226d353cdf560e1323501d68bdd240ac87705172cf3441a2a2f39d8e29271db77e65e8ad0d7f7d33735a1c1c5f10c2ed479006d11871946af68d274db3e0eb0a298eef26d3acfbd4cbfb402c87a6f8c0040d7d1f16a32f67ce00ed201bfc322daa9b0ca981f7175bd52a10f535d0f307c7e5bcbf8b4dc1591c28c9faf420a03752b4e027968ad8eda37156f2426fd40175cc4ee1bc0ebe3567fff0ce202da82e33ae44d7aa305ba1b0452fd6654aae582187aa29a5310118571e198349ff6671f19373a4862fd4f6585568f26ea38590bc959afdcda518b76beec971fdf20477f2f5989fe906bd666227eaea54206f2f68af0fb19147365fef71df7b6409acedc375dfdd5a9b41287e7adca240e18da2c8048ef6996fc1a47cfdc4fcc406546ec6c4720ad1e57a43dc67aa7528ec9ed501843fa63d4ed362967ecb45251b4f2d7b9288baae132e012c79556637e3c15c2101e029fc877ea1fcaccee0dd4188ca01e930fe7217e74a668f49300f0d085ba07db85cae5fedacbc7240b9db161e15c560dfdd360f4fbdf6cc2c1a6a31f1a15e3a8db4351c569a4a1acec9d5ce10048d11a91d4a45d6097dafe2b8426710f70ad46e5600019c9c4c3ea6b9bbccfecb148c9a3297b50a941c3df455090823760b736e5ceba36b4085c557dfa798d318d85dc427928dcc3ed77c27dacbbed567197902c5ae15c8b7a26d65465b30d4f69a6d6ccd525cc353db8a0906ed2ed1a0bd935c3d321cafb98f06cf6d805adbf9a541af8eee6c29231daa7fc55d7f5ce445a585da99a87ba299992a15c02bca80bd403686a617300c0c80d8cefd7d20f887162f349c6506e208f5273006d4203a72029c2d9b655013e2b7ffeb2dd21c8945b6d605a7056d73af06e3814ba63ab486095278c297953122d290ede6be2df4646a010287928a3f8a08a9a14a9a37b0f4305cb88690a3c6692b61c9a47cd49a659939e2d2eed18bf6125406b508c1472c03ba721a2b4a24f7fc1ac753ba306ae2abb38086b3dcb64f66e2dd75f1089ea054c3880fd6521e2a2016aa4bd863d45404073df2250bad59e0ccb3c769ae7b447bf6e0c16f7b2b5a67686ca288000fce0e20ab0360204937afd69f2628b32e3160da0521c6c0805f3084a11af0c6c4fc121ae7258ebe69412c86538973f7a0a747b0dd266aa843b3008f26638fa34fa1635eb325541a81f7fa2cdf46244e2e8968e95e2c68e3d1c574f937ddddbaccf0cdb0af33bbb1c14a5b4d7845027ccd87c824760d070bac0a1514c74bfb20c104b52969604c407373579c4289a2189e95d007104181aee442f625545d163b4bfd9e731dcb0314ed8f5ea0211d4e25603a8aedb6c891a46d8b25f27cf3f6f11bd259b026500fa25ca064fee61bcda3c4d313f15fc33f068d7798a84cd00cf239a676306bef35f0d0da660019ebe8f5821fae7def8ace014a02fefa26beff2c8ddce09de6a11890df45ff70fd67aa570d50ebc934d7ea3b367c5e603993af3e9cd038c89b658e47520b2fc1a0a0c074b0855e1f9bfb61e41b119fc990658ff2b93ce331cc7ed5e2f995113af69006842f899e2dcfbf8531e0bb3116b139739e0faaa2d265182fa64b4674415d0e14c87df94a66e35e6b3e435ec9e45bff156414676456ce93936dac802696e8b60844565092204621e7d3c3a0723a4392def88d2b14d5dd5e8fe1dccd713f46b3934639ec66ba68facda6e1d3b0a8ac4a2c0ee9f62809903223f382fb4ab3b665baadd9ba920bc9b61038aeb63acce0b56b05c83c6feefcee442755e68434e8e6e6c09bf608dd13fe0a2e7bd544b6ce3a78fbfea0b73454ec4998c7b087ddcb923711359dd7990c114181013a717973b5e5350ba6fe15e62c06a9ec4c055e4c298588108154a7958e58bad86d2eeedb2533620fdbec2b8b601316e7f0d4c3c6556ca3e0a7df09d3b5cd9819097d8a60197cc45babc3883c8c5febb05a155386e6001e915c3de34ead2deaa04140494eb12c6a7a76d70915b78f8cad1ccc5e89a3a2f84957f789b8a6fde1e0fcc83190e3ff342899e1b3a7d0a6c12b754d30ed682ed2373b8db3b00e56cb40cc70192ebada8b5e1430fdcee37cc3f8b264233ed08134fe7cd090f9780fd50d1c5a8ee20f1bd065809955ffff5c01b85110590b803e9befd347ad729df2d5f5dc83a7ecc14fa84599a76fa5ff276453e6d47ce23861d6dd1416d77d3065b286d251ed281859105296b39d106e8ccdae51d78e18257ccfedfed9ca15f0b046380f2ceb6efb509da167f420fe5048791c51da556a17817c4ea84d5341d7a11563cf0bf695203cc81485733314f7cefca585e6565d14b85947a1351d55dc2c5b9820c68dba4c181fd3f805c4c89d64ea1d0cde0c63f0f03afeecf8e3af1a9801ac7bcd798402e0859c22acf4ccb5dc8e03ace6ce1500c05f77d89da2c96580b58e21041795120e14431f2ea67a1b99b9013dd1dcda6cf0a31bd5fb1151b813ab60bcf500d066d5e32282e9d3e639dafa364ef837e10b76e4aec556e23ef50311962ab818b5d977660b7cb06df0a8780eb451866a885c708a34daeac9def741dc176df1f59eff623073b69d97a3a0a5c71c535c578eeff20667327fb826ec495c5d0cae00c75d76e021d84692123df22c45e5684570c6af1234e0e535b1579fcb8cdaf06a45317750a7955ab7988d9f0d7c424d5f69d9c766a175bd6368f18f51e57b757b9e39d93aed767d127641d4eeb19d0c617bf9c2c2cc6dde5b1cbfbfebc26a0e02abab12db5edc4884801e1703e575b9e2cea20442e82480b5026d9a59a55ed8ca905a5abad52118b78cf42440e00a060e8b59cdc200d2e32fcecc4e1ee519d3cf976ef17bc3d88a01908702da3502fc5c1e29b8704df2a870a6cddbf47de45ffb10c7daf99131879e8056151408c86c24342eb639e5028cc909393440191a8ee56528cf8d3457d7b5c7e23073030ea7d4886dde85db50c07f115f681a46e42268641a345e8614b28dd596a635edd6146fb77040b14aa1a1e842953773d2446c48b51d6fa6d65eaef221b723b55fbac0e6e2c305a69b9b98506584496fbe202a781a6e7a66a18e87f3b1fd4237aceb4b7798094276c0b5a656b5f77c272358b8b4dcd5a7237d336cf85f30eafa83bd8c684e4e563167f0bedb547a81a81fe376e916c161ca5ca6269b18003161fcb06626fcd261c1604046063a21f949f391606a5785c6bfe8a2e1193871f6f55b764bcf954fab9daf492d6f84fc5789191a39d50811328d56102f947b4b98929e27fbacfb732f4a7adfaf67bd7fc5d338dab96e87d60e1ea54a03c1c1133d13f831bc4a40a08b3d3979aa47b70931db10414abcdf21f316a32afa480edacbf1db9a414f5a701f33ef5144bfcd4b5860fb1aa9c2ac6bb9df59997058c566adaef472481f8053d6f46eab697936a1ca5b2b05a92e99f347c7773c3838ee2dd52933e60f55bac7808756b6e29ddbc5388160f5c59d04c3dcf045e273b5f31d98661ecaaa5e4cd412bcfabe75fa0e197e1f5e40948973530dff56ab9fd9baa397a793b8a888345a93b39395efbea1c6e7c9209d82a779e3afb65afbd733f220e762d54cdfbb9bdc80fd6d1a11216f83290dd8a614109f758aa5789eefd497699a5792d4d424e68edd712d95eeecd3b4fa1690d88388f805384cdcd99e439e75ba7d6de40b86a7fbd293a3b163dd315a4591e34d6b203b7e7ba0f13af6cdb92c3b86ddba924e99258182d6dad93b8ac8f04f1c7b973e8c8c6daf939ffb849e5bd83065dfdb32be7a3b56659cfc62cb148b8719984d5e152a2f29dda6cd73137547012b4c69ec83d722ae045cd7f2d4e6811af21940439f2a85917c4508dfe9295fdec194e5df9def2591e157ef0cb58dfb996696a3017620d27f916481fe368a590df54b7d08365bb7bfcbf9a725ef02413db3f61a112d0a5b02316bd2a485cb463b8161e99c8cff70371eae006b3c188777bc8e08ceb60c7cb88c77a2ce5eb50a9994729145c46c1070f279f279036e6b5c75397e4100b7d9b902f2af5143cce7797fb5253924f6ad74ec1ce08eedc062013bfb6178dd4cf3a18a1e8111424c8edafea423656f291aa920a6feb1ca0ad8f91df8ddcb433dfaa22a75e3c7af89c6c1c6d66b37f14c30c6716d667e2a0df4e3035cff508cffe1f2a4794741f6403d31004462f0de59d88fe342a0993abefacedf9ccd74403ca6e138673fc478d4da18e44570e9779a60622d5e5cafb19692985635e23e27b1a3b8c8f394ca47a58db7df02b4a518d7a718434a8e7e70dd9de4cb3e1ee5ec353aecab49f823488583935a653b0ff256284c0630e70ec886b664b783dfd7453abde1e9a717141e9426bf2843aaa1745efc1809ebd417fbface95367f1f6dba6ef0836a31cb46e8ad77e006499bacc760b3533af22ca24dc957ac385ec1f0df160c46ed97217d03a6e14cf22adee47e1af3c079027d997a95a475655263f112a4b1d81a2581e8350f2137a318a6963d8f77e00a27a681b3a4d2df41cf002f513dba3d44c4552c6065b261e31cee4fb3a1616a7ed95c23e5d30c97ff12157795cb62b7c757d9c6f59062b11501396105b7a5d207df8a04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
