<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1241948974d847de04427cb7f89f67295c26f63edc31d08be783616fb97cf0e52d3a569a3a1a1f0e89cfe811df2ee052d2bb06df9b55683df5f182b8bb539a0baaa072e1768b2672b837cbfe2c98976d20f0bcf271dd133f6469bd271ac444cc1c226a573c093fd12607379921477da8b20cecc33d11c0f4369eb37c79ab8f43285e414fbf8e2a692c8ebc440d74cc5802c560bc5497aabceb61126a9878ccb33a69725f0bfa10acd43cef40b16a29f51a5273c62f4c1752a96e6e2d1e36edc301bac8c082d412d3a778e511a62310bbec0fd2fd9eb3067931ec733e6849f64a19cd96e479f663fb0a442224b2055096da7ef9baccd6b38eb899ef64b0f50f8d914ed196c9a71bf32f5365f28ee21fc4d91713c0d8e9a1f3c1df327226277962e16954a24ce22349915488ebb80f61eb310260ab039ac15057c1bc61fbd932d49c0b6ad652b61a1b132e513b42759cddf21c833f798c7db33c18fd117fdc89c1b5be9f9d0ff3b14b173e046f2e73a4091df904f6a33485adc23eb0f15a89e5b4466210f244bad843b4e8a1d97ed23f7b4fd8ae2e6b38c75bb8e71b58508c65daf2460f3673b87817f21750c15a80cb18a03faf9ff4097594713f1d30351771a4b192e6c4b05bc28d108cd91ca64acd5f961623c979c36c992d9dae767e54c6f17e2d88ffd656dff62d0430db446ecd10f4865ec1ea8aab46201e1894e10ca5c6fa3cdf434ebad5f5549b99ec6f04b97e03aac34838d420f3a66f32f1925de6758b7f45127690c0345ee043126dcdbaf12e00d26c3223990ad7966dc926f924b31b4c05f4cf4bd6749fa2a413c09cfd8f24b8057c84012c71c452c5061d56f17dbfcc22f575dc3432f43ab7e3b0869f66978d9e5dd2d86e051645250ca38f73e368d315c3bc265f6c0b3df16ea039b44e1f9575b2d25957521e4da988eaf8d583a4ea921a88552c225c872c607853808345faa4bd6b7811d81f5c4f329a430c260d5aecbef14c2c6aa9ca6f228e38ded55a0cac49933ec2389d98de4daa2aa4c81400f94a36c0d62b695a4a3fef6948c65a1a7162c51fa284ab3d710bbad3e5bd9f72be4f53550d1875e1170b3094feb08b37b33db017555e05ee63d429d10a5e05963fd869f6808aa9bc1ece2cfd203e0cb5c76887d2b860b397a3621f589bee5cab8c9a86f78da65c117f73975a15b2935d5c69bc3686203a63632589c3bcef8cba52e9d61f7eea501cce8aba95d9cdc58765a6ca4b9d97dff55eab292227684236c483374470312a7bfca17fa82ebef24a468fb64f802cb6b9002c1d98b5040f011f4d73ff7269e389df8fed98eb37dc7c0a9980f5b11a1a01a805d5263584d300cdba94b009569d368255c2fd43d1d9221321b1fa228aab4491674fed1609c85eac754fadfd29b7cd81912896722bac1ad754017d2390b69b6e5718d3018d7416efdad7f1575f2bb97ca8dbd200f2e88606fef6b5d9725ef7f6b73ef86ed13f8c3b29d31b5de4815eeeaa8fc947838ee331e8ebb93c8acf1a2e6cceef61bad271dfc3cfa2fe819d2849841a5e0627ca4a03820a5916f8dfa841468c5d65a151adfe13877ea4e1315a85a770bd505c32f0afbecbb3fc28389c1e8ddec2c913891780f887a8c272eb854a1d1c0fdcdcfb51d9e5196a0d44cd0812a4002cd003bc60b5b02cf3901b2c286b08ea6f5eb570fc85ed8f759050516ea6cd4c132adb8b90eb7598ab34a3a6592b349f06096ec3c3f1ff9dcff2b879eb46a17180edeb651fa5a76861e79f93423f026efa4695aa254a2eac239d229190b042ef92b3527658f695bb711b211491f6ba1151cefc2141e3e3e452b76d7ec75989dfe0dbb946b36cd9885138fc5f8104b7630c7c6b21499a97bda4d4ab8d1876c67239b6607e2d1c191f83b68a40f6ac4a5e9986b1a5f65a52c92f61995d0c87d22d8af9ff45b496cfef9cef3ee0bbae3f1522ceda06a9c47b7d750d2beb540c157dc4320531f6d3a353bc4b4a8c57ba288cfcd29e26c208110b7bda6459d8a797c6663c45e770df3f184ae71756db6fc0467553299bbb6f9075e4849aa4018654ce0bb58fb1349d6f1a00164d8946730275a61eb1bc87c5468e294e453868a956fea1e175ae1481565bf098ad6e34d00ec1ada49700c004fb16b8f98a326a835643a476c9a91fb6755c8b8de939c72292edd27e3b24c10499ecec2cbb1540e4cf3316b72ce612131d8c3b4c308be84fb85f9121f26ac79dacd0b2a34607aed99a1d5ed582f35b08802bdc13cc1231ba3a631d3f27641241f15254b434d01411ac9f33ea5b45b22fc7d32bb588934217874d05f5ce221e736b947baa1fde1c7eee320440b27861b42239d977c1b85abd3e42b9a2d754a409a5cf1f582b7326d4cd79d10141c5df34acb8cd6ee840ec78e9085ab2427f98a2a2e19005a017409e3d2d8c7c4bc3a9fb70cd8d60da334bde4abc527cd28c76b0b3d72e920452d9419f2cb4ec345b581a242306d2f1499eae6741d74fb3ff3c24911085fab927edb101a8e0710d99b9f11c30cabfa441116a16bd79d105b5df80fb7f54f00d9323c47d63f1d44ed0c4bc41c9a126d29bac8fc4bac5e6ab124496949590444e0eede96d6f1a1ca6c4ba76fd3a18eb1f7ebff9cf25298947746926919d33399df9db73a9ff554ce2fc00a604eb1f79f80ef2213b359b02d543b3f9533e0e2599c48c16a554b2015f9de3c374004a9cac146b16baf93ca8493918c6cdcc5e1edc059d6e837e8698d653c60806171e8ce408def000b7e7a3bfb7cf0df4894dfe9306f7f8889710adbd05995d730266dc7bc7bff365d8ea44ee463cb1e1483a6dc28d7defee027289ca14c51a3508d3aa8fb84a16aaec887f47d5aa6b2f227cedbaf360b17b368123934de569a9cd62396a540559802b941534432f6bda49657a10d39dc63d20fdf15350603727b222b5567b2ad8e12cfce7c0e64c38b132ae3b9db5cd9ac7d4b5a1a692aa179641f644d6d0d28ce42b94da2ec267d9de0d7c77b68d08dad4b3e127a9732e63e2fd0325d5ba2cc9f797bd00926ecb6f0c02c1cbf389c18e9fde223e4c6d717ddc7ccb51c86bdc99d25f8dfe94a2f240220f6ea4c02d722f6c847bb2e5f220ef27e8985c5f82ddc40db6a4e77141bbeb3cc16f0d7d8934b92caee8e660db121145f1409bb579f4b234bfa3b8284d3caad1b802dad5baff1e861e6ed398d4de617ce1403c0ba0b8cd3a81b186b0b572dd284f030bb5d06a821a08ca33b80df61872d1e38d7e6af382515fff9f53e3d3ad66ac0f2bd1654401a6a4b69d1e3ecf0b6a4d84bcac31d183473c5684645d7e869273d527f1f6ded70d86166880e17c515785754686750f4c1610258b782adcf60fe1542b054f81a8ebf97c00d1ce9cd0f0a61ba699a02d73c07f399b0204c548d9ba4cdbbb6da03f9a4ab168dad0f6578be7bc892bcefc0442ee2a80056c6c4d1e200f89073b977f5a6dd4b25cbcfb5bb62e2f50b62edab609c416c654d7cb8b111c1fc108def890c16b007052351c1025ef052da358c668a074b913ebaf51827656b11df2094449d546951ef18f408ba0364d2699872aba9687dd626926a9f923a7c3368db5a6736ebc4adab1164ce80c3fc19369ff1301f620decc21c904e6caf05e0d576b0f18ec9313c579400e1efcf44b65474759ee9e3689a2867cc8cc7306cdf0bc2f97c13b6f6a8a28a09fcf25cd27c6fbee90276d0604624f2dfc6e6963767d2459a23fdac07cf806402805eaea69682f29df89f3eebfe53d9dab88e8ce04baf5bdf076d81ac3c132325284bc3c5d732078ac5345b3a5e515669ef0c858f9e35240afc0486fbc2c0746edb75b13f75afcb70595c1ebf8af1bc8bcb6f0df922f1c1ea06c2a31b2d8c30bfb3bcc4f739a7261e24766730648d86082268b7c9da1bd61c35582949b8c20ad494aa422d450b8bf2e8f3944756166dbd8065162ca4a8b2b7de3a36f6ae4818a2711f32dd80535e6924041578f666035d43d6da892bd0cd7871a687205a7dff9cf5c424463a52f43333864e69afcc8795674cb6beb274ea7bb4c5f622dc89f631c8f510b8cbf57433d540907556fa3599c72a1250321ca1ea185c55f2620aef1025dc19680c1ed7d98cb91f322a78bea11732f391d6f949250a58a334a0a1c35da02101c1e18e97df6e8c3e6958ac6da03d7e11aa88a3d9aad7e3fc7381da72e622df11f1afdd1c3d9456aa3d4c730ad32c31a0fa9e8893923e45840cb7e03525a0e8b4c20c43522e223e1366e516604003b49d641906240bf7ee72854a70f39ec7d682ceadb33d593a987d9b04295e328f87b0ce8d7ee58633526059eb2de5e2e561dddb27bc34ca9d2eb9f49465b5e798a88aacd88e12e449d26d9080f8f2ab56bec049b2c4ec770264476be239aea5eb26757d8381a143fd0905525db5990c3903ad91f4036259b9a757d502a8f193d7e256db8a59378dfb1b766d7111f7099de3be360a699bd8d6ac955b731a495addd8c73830b43fcf85c5df99f26651a112ba631ea7e3e91661c52361eb25c56b8026a794840be89fec678035c49e484e70a1e721ca7315fe9c983ba1f0e9ab7631c5e179df5150ce6598de7a929c62d4146b2164c7841b60da8cee3a28845f614e6f35de2fa57a7df4178fc8ed7ddbb0c74743c211cb1af23d8b3cc8581894b8edbe426971ae1156a36b60242c4ff099f29e1a9e837565b1de4d04c1ea097457cdc3a849e18953ca08a95844550ac6c4889168ad846aec707ff00934ad1dd4e979860ce7904c342e15e9e18aafd10dbd6c459ad7acc9a5e55fd7d78a49e418a32b738c1aea62583805aaef588cc555ae491fe2425e0f00fd0d7013314158eab5564aac3fb3ab036ab9647bfa90afccf0b5ac78107a8e6f4d1ae886bb8add622c274df073b3cc000f839b68bbe5d74c02b3be19eeabd7a132ba7c6a9337eace2a9456dc9bd629b0401c0b3bfa03e23620120d2cbc230882aae1a31bc194b83dfffc69d0b1410a401e324d8f978678ada598d232b7aa7c8387248f9ac4b5a42904ca59cb9cbd41e66dff3c7687467535770ecdd9752e5f310414f6ee31c9279c66adf6c36ec36de432fefd2f3f8fc7fbe10068b4de5c66e3a66a8fafb0ba216af4fb641e1c8ac7437f58b5ae4a1b8fff71f99c00295e698f7a5b61df3afff3c2999c0dafdf4292e3684cd606acb6d7dc1cfa8c793603d59a7e23543a949e9e05617cc41e3e772693013e0676bb5e2cc79e7d1bd88f32ddef7eb65a10b738b12b9488f58825d51f307a9b212c3f3c6f4b4668074cb2c8f56cb689e10604d4fae39c65dc75d915d28a5ad5b5ee198d25db1467796abf21d337b61e63ab573911842bc1ac70eba72772bbb0d4a43504731287f3b35b65a704edda7fe143200d20b64d4d0345944486abee422588a1320664a809208b63e2be458a75e3ecbe435ad7ddef278b848a3cb200ee08a6fa6fb09b4a02b01ca57f95720e82df568f9976bb10ff701a6eb61a6b5f4aadfe1ef1e23913c93274f44216b846f9bbc343796cf9348c2ea14f9863d3cb6bb189a48144dae7ba00de3aadfd71b9a2762f888deed307c209ac3550549477878cd5f040f96910b4b60f4d7de2855226de82488d34167dc8caf69298014c85b1940b4c6f793523120124fd47d51a480dcbdbb6996742dedeabadcd062d364ffa0ef5366bce56eb71c4070c80782ceb2b348d024f91b756c91987c52dad2b74546b9631fc9b525938c41355d1db022ecd331a9ffab7e47a25eb5882ecb77e346b0bd7c5e46c37ea1611e559834be60546fe60f92628e89ed91a359257231bfd07b819cf4ad18ef99b38d7b7066053252968bd24ce9ebb2be3ced0dd43af942ea396ee17744172b8767dee40de0300a61fcdaa7d86cab414995aa9ad45127ff52e451dfe48513cfca8532fea3e930ce17609e4f48c4f97ef326e095c3d5924f0b8e295cfd2d46b6bdc1eeb71f14f1b259ba09426f97cce7d5b5926076174f4f0b307edbc0544d8078483ae6b81030ecb34e9b30ef0d3ab248db5c4cc4efb705434f3512e5bb6559b88f0013162fea3094434203d5f481336eecb23e5e052ff4c84376578f9691a6eacf5d5b432fbced5a988babf565d60dcfa3c3b5c32243ffd0b1de863aae82b5c29b852e27b73e86c0cbc1a79c19aa7503a01ba77505148379fca8d2916b4f070f8c5dfb97b54362c88a0e65d44737746e5a1f3cc9bdc827ba0bebef3dbfdef2b9b1e24ecf5dac89a9430ef33a033f7b59b983362ba8c1b5d17f14e2d12b328226358281843f53b2fc9132105c1965079955613ec06b3fa1ed3096b57732de00e5b04f47688a75b50e5535e6dd6c31ef3b6547ed165959086c0a04bdba376d2cc17473caf35a00f91ca788187e07530c0126fc86ffe5c123d681a6736e195a1818c85f1145bdc1e619aa55351b84be896fb646cca4001141ca9022e9a7316de2c680a9b5cb9b6065ac2783eac4c525febf3e2eff5ec310e660c5ae63587e5fb8c5849fee78d03a75a5d0dd9ef44539dfc138f6adde6ebcead0e96ace695585e5ec5c204b9b6054abeaf9145018014ccc81142415329b7277611a79a7d4cb194adec63c25289475eca3aba91b050366bb1f1051eb8fde61008b6cdcbb95c9773e85df2ea54b5fe378b358ea113266b056525c79aefbf8154291500c4281c03ec1a6e1c9058f7c723444841d3e7e8b10ed77d3284258c9ff60c56cf0f8f15002448b7ddeacc6058924d37b4064c8c6b858e224747ea11c963433a047ba1f0f036bbc867e797f1b790e08b4938c0651d0fa8d63b94d77cf4804144f1b2639b0d7dda924659d3396a32a1ff85d117b734dd901428be6fd1e8508abcd7604335c71ba59bdba898b87c06fc073e95b6e079d36ad9caef1ec5fd5838ff859a40dd27fe459088efd352310741273f4d4c825713083af2eaf9973107e59bbc651af32be78991fb4af844fd9b158061ac88ff0f27c29437ad5b9abee53fd7bd9caf72d02bcd883c883befb911d216398394562c6278dc90bd8e81abd078ec1d3dffefe33f8211af75efe86f57758a28169c70fe1e018e39637bc038f585d0eac44b2c1a6a2ad9dcc943c87037ea1c70e90318885bd914c14929d6ec6c34ac7ee5f22e838b14a558e7089496a87797d3168ef56f8a34778d53ff6edd8453766197d623d70f6ea109541936530fcef8f96b3d7263def99ffc2ba54c70dea6652cd8775b4572ff86b14c8f91f32cf1a187266e1d0e1d6480888e3e25a5c4a5085cbdcd6e6d9deeacc482b41f723f27c6f73a5287b14ffd02c6dca9a6db4536255274020e8fd7fd144c60a138eaa18556f5f8ec63c75c3867b0da8b7617956c9744f5d0fbfe4f368be08f1cd469524424c09e07ba119e5365ee2076589230fc8b8d02b05a95f8fe89c47113a315a89c171f9d5fa2b9e5b57227dc0acb0c7e1acfdd950809223a883bf502dfb17387a709163d8c5ca6052c19f52302c08c7d332ed5890822779bbe1ce50ca198915304f3b528690cfdb44a4046597bbb0e0874a02f64c6fbef610ecf293f7b1788dc52bd61c6d76f0ce375c5aaca3cef5b04b5f58442e41a3040deee77e6b74e5eade2dc2cbe3a55e976ba99f582cafd2897e01f300966da48d9b082116dfb43b01d64c60b58b7b346c283b9c1b2f8aa0cf5f51bee38d664592f65dcf0be5bc25f94ec67b887deb0caf6f3dcbfff7cb16cb3c3a450e55354adec4ce3eb74106eb4c1c87e3918da2ae5e9b24ccd391118c7b80d62ce5adb286420de5b1ba4ed56feb9ee6a8afa493c6d4f7028809981d7aadf6972b357dd9dbd9c2e35f689fac44c2ec53867b63491b1efda99d644219c7fce42799af17a97864c6312ced4290a11badb0bc17f89aa579a1b2172804a714c7e1d387317899afb8a1c1c6800aa27bf7ac3153d916ce3c5417584d4195fea4a1239a81ecb155bcd8c6a4db6b0608970272701841725094a722e64ff3765bbb105793af19834922c1ec642e30916fe521e542551122c4379237a47a174394f7c0a26ad0f420e6c3b64b5432687cce0ccd29a8762389b61de40c0f9758ee6ce0c9871cd08a55934fbfe8a33efb4113bdff032ff134b458bfb37b577ad3de9d69a95acd61c3170520069a006c3db30dbbc2eabf5ebff54e9133f1703bc9ba4689db1d7a2ac0b0bbab13eb1bbb77e4390036a2087329d551c7e0a196ce6ea0de09f45bc3ff44b28bbc70770f8b4a5da58957b0e6393f595cfec0ed0c9d0a92ff7b2149d09409b21d1d7a56a45d70193e9b56491e496896d0b091e1158679a896da9ce7f3dbbec95f19e56c06ef5c43fb4be0c9a74890947f935681de0a4edcdee411c899096b31ad4738776a57d1725f76f5bba09f4df03e88a710a3c3ccba4156a728a26294a41e5fa0441e5921541f4055a9239b68621822a49562ba6cfbf5c873c460174ff2dd86c6801a3f1d208b7606863ffb760f48b8b3366ded2bb3f8201944474ab35c60847dd140ae931c1742e125639dc2b2692fb8a7e101b1dcdf647a7ee58eb95caee81f8994d9ad1d4be16b3ecf652af12fcf9dfe91d2326b61da845bc4fed2a4351de774b29b55d59232d28f3177ea0c1c954e5dc7e9a5877a1876acdc23c31f5af514f6696a47d9bb968846d90031ececb6e45ac93ed8a7d479b44bfde8eb22c970056c942ab011fb47bb20fd458b6a77f3f1ce6389b5adb0b3de03e471907cc960e3966afe4df72b0ff70410f1a7e69875b9647bf05cff7d7c1bf508638a9af52a8341d4a83b5b987351dee605e32cdc8d45343025413b532ad1e8d60949c7f19eb3b8c6e6319586aa8d624b2cda1d0b9c8a64aec02a39cb299b8ba2500a595336aadbe337a9c4768a1d1a8db4f4696a44d13fc6d84db8dbb48eabb6c21eed4782b9837d0f448dde0642a3c046e807896b5439b7c4c3236f7c11d94c7d1d8b39a7061a3d82cc5e7a08e019a1243092f809be826f8bb57451ec68f00d69f97be2546a2249df58b8ecc681e1647937ab6e24c46b4bb572eea3b0bac82b3e20d454a1e87c17407712b184405f8a2259d07716098b8ecef737e046ae7cbe9c29fedc26df2b867c3dff8d28b26c9aec910cccdc762c6d7c17423986f80a79ffb9fed05054eabb864d22f44db4e950e300f06a5b21c42731f56e4d85f13e376440620578a5319d8b3d3d095f2f58a8b5f0cbcc901df40b186ba533cc724382c8d6a646f72b2db692dc81610204469a866ef99f55437ceb37f00b87706bfa84ab7f72e2bf4336894d40e2f73267c08714b89e0c9c56aff47bfd96a55955e8e355d460dd9f5d3ee09f56afcfc27d24cc887e0a55c32cb63bcdd62c5d1004530c2a80ec4a4a40639a0fb54adcaf7b6c5ce9e2c356a6eb6f95e1fa065b8ced8dc9c9871cbc403ce39026c033f68d58cbbeaa25afb995d46f9b888be657b1ac87159bfa90ca4a0b8341897988012c936dd84e6293824265a3ed765a98912fce7791b580e4ec759100f954bfd500c2c6d1f3fefbed980a44aaf6bb7408a0d2af64ebef81d7347b5c936577075421fe38663a973aff751427c3d6899fd00d60f99b618b360d0f285d682459fee7d63f698f93cff14639a0180478f17ff4b0b900c887ee1fe60f45f63077e4178fb77300fc1f36676c6127f24cf76e74215658e860f09ba5f31dc6d21efd63f36052d8788e096d1f9b67ad3693b40d73c8520e18b858d17a7aefff340c727503cd92994fecc700e5a8f6b4497c1c09c62282327d10270a83c4da20f8f2f0872e2bc99a4715c8626846eac830c0e8beea5537999244e00e99a0fc223799759e97871633db9d5272a9d3a72cb1245072a6197d9f02c5cb16317da8acaae521b8ad1b53d151a5f9b3f562cad88e90cedd2fbedc5c49888889d87936e8bd67bc159daa273a9235bef2dae93073a4f35c02dffef687851e24696f80fbe7e1c5db8d8845fe645a0125710caddd41649b02143236f00a82236dddfd0ec26b9003b9dbfedb58512d3ffe1234422b3e8bf6bcc986ec974fe2b2105fcf2b949a4daa60808c4bbcd5e05ae0cce4b41863ee6b0a68ef07f175ffeac204a91b88a9b0e2b3f4ac883ffa6cb972844f0f6359febb4cbd45f5295ed1e4efc7a812178d71bf20cd6b387110c5c78a72e47635484afd5f3f8c702c3c31afca1cdb1a27c5d0040c604ab1ccc3995bcfb2edb0cf9439253e10a3d46ffbc5594fd6bd89b2e25100add46db0012aa3f3515c4558c700f007ac33f8c9effd7efc37aed6baa66ba6c11113005e66fe9c2ebfd5a1436d47a85ce760ce7164bbdda7c8aae2a2e92b1f8364e342d59a84bac72c027737221011b3d19c4fdb0e4b0de4b139926f446b2e73db3fabefe374b1ddd72332bf243d642e71400cc5243682dbeb3d1a570a774cdfa15337e6c2b1685419afd196d05d4110cc594c0df94fed2bb206da248cc30df92d04a51aef2ca210c214407e6917f557dc63a22da6d6a4d4092d92bf93249a71a2d2a7330313914393349861cd3001197025b9d05ce1b1dfd529cf9ee2f61fdfcbcd381c27016d739567f13250d5bb5ed197fff65b312e63f12ba7f312fea86eabe091d42e2d72402c9ab9bc6923f2b6d1262ff4fb58a507ad72afda98a39afdfc2964ca5d5052f4ee56b5811ab888f8b3568f206d0095556981c2c62c5f1a774be2f73381326e3ba16181bb5acc015365b4fc9a8117a5533c47fd64358ad41a109c5e88f2521d7c3031bea0bb15b8fed27fc58067b03f3674ad615bbc2c77c0e6dcb1925ae4bf28fc15ecef6d5a90c1fe897e37b6da1091a977c1c018f695821fe427d51a8c9a7c44553510d31df9b28a76fd009f4c255033e8125b2c31d2958bee4ebfbe6b8196377dad0fc7a95846a6a7234f2721052bec493999e76018d9a916ca64a4f0a6d8d0cc45b984cba7b842b73e58c49a953456526884878a6ac6977a8f4b75716356de23605685da5371ab970c8317baaf93bc8b7057dae35daf5d2f8d6de58b4bab0767d5ae2b70b7d6d4db530f210828223952e12bb25406927876f46e79088bf6e90c874e59e2cde68e16d7ca8faa44c5bb9206848b9eed7721adb8edddb1307568beaa5fda3340204969d502972ed55b74c696b3857d1231ec15aa60bacaa48a55d4f8a7c92c8dd4a48861341f4a80025c1d71c78c023cf21327fc56aeabc88753b44f9ec15c50b9995dab75171c938bed403b36607e375b7a4f923acc1fefadc129ee46c868d5aae885ed167c561bbc4650441e133885df03c0101d17fb827348292cde2f81844a02fe4424ccee426c388d2796602db45bdd2c58aa2917cfb84ae00693e8159cdfe667e69059cebad037a10ee342c20bd453f5400c43a6d9638bb3a1cd9fbd1354aa9eb87e7ca5760232f8fcc678de74e5268d58272fe1c24e1573b39596dd2c81fa343e9070a5c8bf274ae26626f9833ff641ccdc44a0e0cf061d9311c461a4043d49913ab8756d3b64805877c5273689cef99f2f2505d8973b378c6c9a30cda4aecc93f78f1589befe550329e9e68cd456b9d8f8d9db69257ea8b809adb0eeee503acb2374067f5f8c5d95e24f2f0ef5f4fd20d40aca8252e29b916ffffa4a2de7614cd39230c9205eb92d9cf79f9a5404f900f205133b770b3e06059a1eb5553eddf409dcff21578f1ae0b4780d5c354c481324e1d77f56acea904809ec652c83744da497679cff1f7c0db22a623d5e0e6bea3235e77e1ac388be0bc3c8d88ee51a65d9296e1757d260568d4fd5057538bb5b29466682ee303547be5eb8319c9e467727556338b79040d408d0b9f1115daf9c657f1fa6d1b26c64340ecb533743a1050e0c8427ce17a81d8316acb18d8efb98fa8f209a69a6a552072a636dd3fa380bf0e8de2b7a1550b7c4be6a91731fdbac58ecd49dfe9db04a3adf7cefda659d07ce9c3ae98d2daa8a07ccef67001333bfee79765649649d1bf77e47ee70944f2116ab8fbc8699883279d2df02c32aa1ececccdb75331cd2fdbea3a941f4fe2d7a3b7739b76f6288f451aa537f683bf17727cd9201882c736da7b7b980ff8110c26fb1df4607b86d45b7e109c65c70fe9639ea556190ec8311481ebe0eb81ee41e1c31859ef7fb2b6a2f327a9fd3ed3b7bc503579b66e84a49ea7adf67e190e52f1ce1fe7513f3f332a1e178727c50de0b9e295156a446906f74a5fd5156c453cc93d4ae8173808194e8841b66bcc89faae6bf1a578858ea5122af3e8efc915dbfa44127ee733a78f317392f72e03c2f34940386e26833b03a699af506f3e8e4ff245dc3ec0670e258053ac82afb1ddff7b53f56b5cd192ca5107493bcdd5147bb9758e857c8d0bdafe9af6b46e6fdaacdeda113e487358fd04c6d162b73513ce6cf6fe81c16fe1129d24a3171930361985cebbbc8bd9529db1fe35b6b31ceceefb6e1f4640e3b838c14383e4b49d830b06a60c9ddadfc0d1516ed85db11a9a33efe9309bf6d92fff42e54341ba521b33523dda5c1501a1878a54ce28f71ffcee774d8b4b1a9d885c97c90c6c68c1e06da9805b4ca9ff86e7532996ee96be3488b95eadcb1170bef8172b621ece2aae8b5ca1601aeda5dbd9ff840f028700bf4851d67e72628535b0416d60f9aa2959aa9c528af835a399ec61520f740ba74c1048cad9e07c26b234207ccb74962ab34b30f979e0cd85e1257d26617486963d10b940dd1f446226083b9cbfe06eadfdd2d7996e1e18af3b8d4fa688321399e0935bcb9c8c779c34b998ca2a9527af088520359cca97d17da563e3479b0ef2a125fcf4ca380f17601e88bd7969152ca6319b2a6477817d09b44e89489233960edd2835abe1889ae6ffc80594bcbaf2db4179591a46b47ac1b3cc7784651303da95c24e2dbc13ed097296fa1dbc4dbced13f95cc983d31bfe21aa3e25cec66eef0cbf7551ff1bdd6df5e9f9658d4eeef161e6da408e09e1e8495040829748057e9775e08793dd2e30ac173b1668e2171574eeb439b6183b12f85b8e24e2a6d68fb6a2fd2f90aa3837f96c2671c917a282b6b24a6ed0ff70f542372f61ee033a7172cc4c0e67b8e8d171c51232844b3087d99ac2acc3aa67eec072c28e6283183821e2d98943b6ee122fd618a615d347f23aaea9cf042ef712d696903f4f555cbf874f2d2b37811edbf5ed67014dfb7b82f3e5a5c47a61b98c154e9e0e39c4eb52b690b4bd8de69e32605ea61a4d6c6b68a2e116d68906c94b0c1d45a4652982731dd59cf11113ccd454d73e89b86b1473d9fdaeb02d7c1a0f60d98a881370baa429ded9fb0d66ff28782102093b1ba74b89e99921bb33c3429f099c0edf11839beab2492128f1d5ad76a3c9a0d59ab9431caff5ef79e75d282026e08006b805d0b26f427fe55e2d0790234d8240f019288950c7c2c4f190330e97e810a56b775dfaabb11e110592285c60a646309c3e03990d9bfc6f40ada544ce5b63957f1b7a45060519842bf20e6e28a13cbfcf3bd2a9dc85cfdc3265fcedf32cdae32f18b7c413ac528ead6e67cdb838b77f4c769555cd054bacdfc5853d2341abb89b184b0cb7178784b5f2a54d0efffe383b56b6a97bce211732f56ddba62f9f961fb0feb30c38a1540bb31f2e00986a9360e3b39f22e8e689039a81a6cde60e467d21ba9e91472386317e3fbe40fbf19ea298d670d9938685a304eb3facb2738d2a50e9746d114874d66d68db1f0c55deb23dc8dc5d58dd2f541f3977cc53eef81696c026668a8af270ac4461a8de60008785fd67331ab689a66e6a2177dde8e9da33f442f7dd15d337b3b26f55cd3474d5c819bdfb920c532aed0c85a0fca52a05844f3d35d4ee6600a9cb70c67d75516760321d6a39622c1713bf32c1f0c4893ff1f0187c45c5402da4f2a12f802d36d4da20729c2452d8a8a7d7167e91238ece82ab76e9e323b9fb8a500dee5ea7ae5d25ecaacb3c6ac2cd289066b8b4f9ca770ae0ba62228724e686334324e7c7f7408d37b9904488aea6101d7e75d756e9434491b50c688e110888531efdf670c4cd89bb2693179e3b46400025cedce701422f19333687b4c0810b4f55cd3d304e315e2a039ba02f60399aa450c8541cf4a63040450361ed1e8a376d9dbc01e9c9f7db281274d0e58c9e20b1aa99eaf58d308d3323b4044c4a3d15a071e69462ea7a435c10a79b01a6d1102c0b2f41381570ddf757b2f2551852514939ceb5417021971da301b01eb1a711817748e53437d5a27210090e43151e68098612afc70a33533911cb81b2e4889438b93b0220bfe9a030c9dfc8be936687ff7da6829d7850f4d89b7d870679b044df472ec5945349148e5ae59c348b9e8e381cfa6c794ff9222a86834bf0dcce0fd52849868dd831b92718770155dae4b6a90f97cdff30a664e72e3d682685bf5292df9fd3f3074652ce339dfb5f7f20ffb7fd2342d44de2ddcfb7e2b63a8c5580eee896721d7b9ca78e247a5c2b93cadaee47e0637c950531d25dd03c73919481ad8295b2f39882ccce46d058b3e7a6613f0448537a4e180c78870a45ee84bbb2b1aa4b52e9056c1625d0c2893fb2196c03b390aa0eb6d3ee74df0aa05837e7e38cac88c8ea41569bd56eada0754d6fbd64cbfd6e846dff0a5a5c246205883de85808bee231e21713029f8ffd80bf6a6ddce07ea1a0b8819cd6c0725ef89e633e2ad02aa07fe0d8a8f104111ca6bebbb59b791c26a7896da9dde74f60e4977a096ea49fe86df9f907576dd2ec618408c70f6d27f02270fc60e7a1112a1f6fb80607491ec3e955484ddda4906ea82022b0801be922b81ee0c6dfd784f410bcf68fff0f027189460ee60625b564f4063712860a67aefed976006e77366801b2eb8a18379801b337e67e08cab63f3c0fa541b75f13cb770d6280b8aeb50b89c679842fa3cebb260530cba6068e13b476bbcb203e17272ef5377cbea62454d79182f71e4753bedc0c2d4e02d143b0cd4449d1dd5099d175e17f446c661ca3f49e45b06db135319cb2154e60e4ce926b39ef49689b1efdb4787b62d32312fd97b74a4d1e8410d5efb6ff74c80011eaeae8e6421752553767797432e985032986f1ef3f223643c87c169f4aecca4563458b092ba5f69138475815bbc628c15407bc45e10ecb469838ef2d945e53f6119a2a7cfce00b820fca10962c1e8906235f5480451b2ded860f442a3771be4467f29400151df7eef3e01a1be875d05ce12771dbe1d1b04e6a9f25551aa7ac144900b0c56394a467116ebb51f59804a3b6a8244d92ab523b3a76e6ba3f25644c8e084763811e243ef6ce6c877e25567829cbe5972f93329dfa45da64957f594537b8cf854396ad8a49a5fbd69077cf49852e569d1159b0c45c922c828c157759392b3a4f573b42113ba9bc3e3e7fa140b2fd08a6e8b187b82275b63e2e18937f642f68515a66e470ec8e38dabf0af1fae6d91d26e99893682bd071673fa3f3beb4c8b5776a5bfa599a392206e306e43d08938cd7094cb8b08ddda6de4d7ef74f56c33b8f0364a927d8cd9b70eafb66214e8eb452946dd30fd050c09ce9883461260549d58295ba5745c713da578ce6ac4312b6e4b49d790b663d0251e90ac1842e9a2df02a62ac40d7254564f439b1259d7a03aaa32f030c4d434611e2da910aa373c67b183f0c04039c5fdb1dc649ba6a3d5d3a1e278e35131dd85a04ba1faf4186377c31f9b9f9b59dbc02635b2cfca3b29778e0c2d404dab47b89f7a7f5b51fb630a43d56717c633e5141002427ef1f333529458a7d0ba5d556cea05b7f1b08451e999a4fb302c9642d07ad4cf9c490858bf1416ab86c6a72b02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
