<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2e8fc69188ec2d3a7f2ae418cbf7fd7caceb9ae504d1ec73dba1b3f6580848b706a5491f14c07266ebe07b70110ebe964fbe668a77eb20b78f40397e28b7012b507388bbc9b7ec34643ea472e52ea28711aea4b2c176d07ceef4cb2b702d35eb84ee4af2dfbc3fb67020e0e4887ec3b05ac8c86a0610099bad4986f42e5226abc8431eb46aa61b479b3ff5a714c0e9690c146828729cab7cb4e3137d184c6331c908178dd749ae3c449692b88cfd7249a1f5fc7e11ca78419898ef580a88c6f473c48dd446003fda9e1c08a78fe8220ffed4aeb287ff976f010ef13cbe2faa40467099adb18a00214a4541df0a179df8bc5c5727a3fe3757005affd65c401ebb19d84d711f894894612161a41a4cc067fe92fb0000f878657e4b1f3c8352da340fb409e8fe846c62c47e8da1eabbbe36cd5142c923d3c39c4cf7bb1e3d36e73c85261c3554a9b00320eaa27d1593e397be273a5eb1daa6e08eaac720c1c3a87051386b2ad7aaf9b3f9c751aeea8b41f6dd11f6a6bbfba319f1682e8253c0394e949adb12ee02dac01d6012a40d7b662a3a58ee7a7e19e137632b801d460a67b146a2651857ecde9786764be5577e69fba02b97428f8796666a642b99473925c9c503cc25f39acbc37c64533ef15bbb563244647a39b3d98250c0e733d3c1c88908d1ab49dda623ffe9237e3db06dc4d03886a04e548201b52ac03cf75da670e54fe86ac9dc0950d510ed8e390fcdd86576b192544c055413d52bf639c23f8914f6e8cc002d09ca531f40a829941329f1c0a576cd5cfa857fbd897a31e267287f0d3ee75cc2a88ceae23dfb9c5631ef4cf6a4c525fcafe5368d36618f7a161d7c0ce9c1bb9f769bd41e6c32c3fadbbb596ccec480d3813a591a887c91119a9732fec749b03a54a0036e45286fb901eaf418cc1d2cbca20dd88eb3eff473a842beb050bc96a0af17370f074174c88b830d50383719d803796fd2de3573299dde11a1bd409be421c32830bd4b6cdd340301b8213cd01186418764db5ce33013ca2506de35c700b3e76c51d4252c1e2dddca8ddbced9d4a4381a9f1e7c0f2a0f2f16e7a5af4b3cf026511df5836dcc3ee1bc2db59e87e6efba786a88028253acd568b37b244b7e311fa3ae700fe457ef37a261def76329e45b35483d986790e892e1b832a89943ab40ce7a4535d7d9b7364145d2300fe4a53ef67097bba60adcec5fafdaca46147b6a38df0d8ef28d3bf66b5896f85a8e441f66c844180a63c4fa1e12ebf4ee5e92b7eb60136e11aaeb5245772dbc5fd855a686ab90a23d331556002c8674a043e9a9c507149e615ff8175e2597898e08895bf3310f4eca48003feebe8f5f2a6678dc9448995ca9d634d2c9c81f6f1120919e0e9ae16eee9ada90b27c91a2edd8a3550801a41f4ef9c0fcde193777a0e1441610149f40969bd213255f57d57f3553ba41d586f7673afc6e983f2ce726045f5dd7d5f305ac6bef56df236caf0fa0b4d97ea5ba2a48b8aa06ad0afe0dda997f7b226ce7b04668a9fbd10db1a2e11b55104f6806f82ac649b8c2bebb4471611e960ca4d6a9b072d45e5ded53cf1d9e73b6420c2ee5bf7602618e55534637673b7e5d4d14877fa6923f5bbc2b414fc197e6cb8851da47d5562f7c01c92bae9bd839d4efabe22a4314f37cecb4ac90e68d4325a8669ca6b0139b04f422a718dc013b9d72fd67d96907c211363f8719a80e853828336e0d5dcdb06652594da45e463d8e53923397dec248e613d00daea238b652ee0e03eab16d397cb3f5c65faee48f012c0491c23537138a9422f23114c664ac3d7955493e9a6df641c6eb8763251fd19ffd155971d002d2317d9010f2a64bdc4e728e22143d1550c7d40c11045eafce69865ee407ea6c292f82b7d1da598320806c894a675f55091d157e9c8dd6a9d29ca6c940fdd0e45a744f940bc4d9471b79a98ae058869fc3e84e0944d152d425838be6ee8d0b2ec1d72eaccf27d531c2ac22ab42d5a0673fc35e8fd77b6523cffbc3ba7c81d08b032a65650970829256dcc3d2ee06186e1cbd6d05982a0b9fdde045de24646457f11ef3a334628f9f0f14793ad2ac0f842b91e737971086cf9ad89b21be7ea5f864765813aad886292d7ee1fce566abd7fe447d8477274f605d977fbcfff79fdc74577a55fcc979c49b89db2a9f6b1ac430ec5de4f08af9b8b07ce8b2e135f9d10cf92b4e1a5c5a5301789a5e515353e40a1055d7b6224a239ac9cb765f624c4ec1948b41bc09e9f99c55d2a891d3654f62454b292a6dc91536b7357727cee18f36cb25686597b15bd373d23d0e88b9477b5385b90bdc9e1b8cbe09dce9853b74d87b63a48844850e2c5ddd9cb924bc98317dcf40832e0d284fd4b4f29e736c8796954f9f628d02ba838de876efc87fe5baabac0ae170be102f3f262f974195309a53160a03efdd629683c2553d045735688aabb0a31dc4ceb3af3548b686e14716d5da00a6163b50e7696a91e8e5d1b5cce06b9ab4dfb854ce27f94f84062a87bd7a8673ebcee88221f2f8317d9863cd4561516d1988d85c890fae393e242ac6195d3413c6d0ff662c17b9cfcdcd0ca5f011cb5266fc7e6aa13f0800d84329c53c374ec680060d030c16fff0b1cec252acb772cc311608f2f108ede6345e5aa81b9ecdded35e66875b864738e821d96dce523941a6719bf61b53704f0eb4c08540602722026f19577fe4a37a4a10fe07fd50d1ec326d4ee249d4112ac77824872c7774d097135f5ad0936db1197337aabb9ffb67c2b0accf596008538b5913b364a89f65813732edcb18bdfb54126a554ab506cbde7a28ec3ddcc1acdb037beca58b2310370c4736d0356a104107f56eba4e9c7283fb5cfcb335604f955b82c328a9c1c3b9b30f055dcf36b80ffe38a53805588c5480f3b6a48e5205bbf2801e6189adbd847b7e2827283b2ed089b556f4af450d9eb72def185709d1cd4ca40565a4d726bda9684850fa216dc553d06c9df162d93532836b0819fdc79cb71a869e388760f4db7410a3a777c8bd6eb6ea5495155eab0c2a959e7035c4115f29b42937a4c1b5fcce36ff58334ddb346b6e32d03a838016dc159d16dc1718ade722538c66c3f77aca0650a9a6b7b5001fb1c780189e5cdec1b80c655bf52f581ca3807fde9122cf71958c739adc44ae83323efb8dd58888ea6c55332be34d2d2522956fe4be6b2be046b2cf52b3abe922d9741bbfce827e64f082969db2bfd006b6fb2b7a776b8c76d566391c4244c6c43e368ee2c07f58f5e418027d4bad98fcfe10d3be97d9a00e11ca964631d2e4f42d0aebc43a273ccfed387dedb3799273657d5e92dadd565b55f9579e28898ed22da0f348f52a28e6e8edca971d74b7215bb16953f249ffe04dd812e8ba377997ffd6ba094148df770f2722cec790d0abd1d9d7fa0c1e3fbef339f78aad8eaa75514da175e7ac22323b162780e2bc076591f3bce74fd717aa1cccec05cb51e94e719bbb6b1cccf6051b65350c28dade5d8333415e9c8bfae8bf145b1e246bcf239f8820e296349520d0edc6c03e9bbc927ad0e9fb055598947e972d3b94b45c4e13261e94082c74706b39be0d49b7380e774686da0a199989ee77b1ac86e273012c8c673576de11e439281b9b786ba1fd2c659e87b86b8bbe6fa40717710e88c9e53cb44aa432f180ab350ea34c6530b083b052f1c548c5c02ecd5fa021df2a78c1999c0ce8b062bfbf917b61cbaca96d9b7848c40a2c972e26d119cde35eb90bda016ab856e3919944e10dbd1b0ddb1c2a8227a8a86ac6848ecaad8da61e7956b32f6aa6ea6a3aab46e85c2b4c1e32e7261d184b6f4318e622f1105303b101806772673a453ebad9db67c750780d830f208a24b970771e919f8cc234d157fe6c8bd79401a97bbab9ffc5d876ecc0e6d0e9fdea94de7cdc1873362d9674d14a46cbc683a5c067d164ec7892069f6de263c8c9e61ebe02b0c6e7fcb5f76edc68da2df3b746df7ca08bebc3fe3e1f498b5f51476b0266942bef9404aef78605302871956126f06f8c1fa516b5c7301ce57669eab6b1835cb78aec61e3ae9b0747c2439c434d3b8914d58362f382bcd9eb5e7d98ed3b2c4393deda6dd9a35d16ebed8ef778f2bbadcdc56e88b8516b952f0aa929e461d02d154367a35b8b602985de5db2f9b5478e718fefc45f9f7a81da610828faae0d3bfbd9589120754b06d56c9bbb9950cb1711b459379e036b6e4c67a44abccb65842524a91e66c394c1c39777cbb4edd7705fe6f4c2d5b95a1c254d617b0068cd4771e4004a7476e7952c0deaf3e6d4e8958f346e5287aeb94e479f205fdd8ee03d4bf2831f071fcecd39cd7d330b0524be079cbf631799c9f4142616f1cd3fb8c2f3a00882def430614d3a2540ad79f03f642fcae3711f18d016924d511a81617134e8b6de9c78bd59ee36a97e22a07b8cfdbbe8db2176e69393a19e7f4eea484247ff43e3e4f39e327241ed2010567611e188c2f81dff079db3c3c93fce70d6d1b731d8a73589f4cedab47624c588091a4babc005ccf3ae15ae5db524996644e179dc6c1eb1eb0f6cb71f025dbe751af8a2397a7f4ac741ccecccbaff69437ce65311c1206782372252279d75d03f4e51b52896eb696742270724ac5d6e3bf5916b159e92e56bd4af0e9ad8cadfab5c3fb60242c9543c196c5092e4e710cd54db316afd49a36a6c4f5a8142f13eda0fd1c206535e85453ca425783791d2e88cec2a4127138563cb64be508d7c0804a4123bf13dc5220a7fdf1df3d8f68f5c7e6f6c7495e9cc59f0c60ecaa5fad132ef5a20ec2030ddd40d768214b0698652375ba0b71c9afc93430af38f32f8aa3b53663a42551b72888099d74ae15da967f622f8848b522afda1a5690cb621a62cc019f02af19d0c8d45690af5031e2c7c7f3c2143926a0f0219f9c7b4b0aca71d5d4648e89938a2d5059f506d504448acfe7de8a63bccb70fd9ee8a68accc1116058586fd5a817022cbc47cac3caa6f1d2caccc0a742f69b7d58a791c39bab7fe9c7dd9a49e009ada9e6ec19aa057cddc3e8873357ac72f139aa0cc4e20788f4e3e02b17d1fdaa3f1fe2626982bfb051004f668a9b7ca7f9ad12550288da276ac767c8cdae46e2dfd21923e8de58ef485e945f5ced5d62bb3640c89eefebbc0e9cc0ed4f12fe2244c8dff142c9574ec42c00dae3cbf797ee975f06f4ff6ad4c36bb1ee34b3ead52c63bcebbe9c389c0425229049237ea6f2cc5564f6ce7e2bc98e52d14af2af8ca74cfa8a7d4aec5b40e1c4c95ad1b48605ac7770642c5ef8b5299d5f8c96a5bd19106e759505974fcfd1bdfe77c4a6b26d6c97fe7c51185d440cd8f3245755bf31576b1a3ba7768d59d3db63b304e4414287804d045916715a3042101b4a6ffac91ce3fe942cffe8dee5e04f326a427049ea344980d2b21762eba5e06cf2e6719e73080f325cf9fac3c3471987f20b7e1aee7ec619dd1c7e1be1036b1f893af73b380b2b5ab761188c52ee9dd3729a3e989a34d086919275be8a307f4f10a3b12016900f6d7cac88f63741f21e207fc0772f176e036399e636610eb37db8ae86b3a51d66bb10f85a0417d3443b02618174c646730d977f26d1c883b7dfc02f930bcce963bed0bdd94673f63f20e94e79dbc991161508bec13ea95dc3c297dc2c0cbcdd2d46e729cd3bca86986aa201be534b2f3482204bd26b7b9de588d871e88f2ecb1361944da62e5ad3c0c4a92a333bf14b6bba080c13b30d03dfcacf6c2be34a2aabe8b97b6a7c1eb99145144e6682e8b73328d1c50a8ef1d093fc31c4a9a1bfb0b08790e4d1588feaa244eca97d49e5ef07dfb6a3deb02ff215e315c2871802a41259fecd87a036d1898503c362aa5d899b57343c56f57e151def21bb7be666e88eb7052bc69fffb9763f219eaf5f7ff35b0cdddf3b1723cf5f89c0b81cb56ebdf1afd502f757eadf974b1aed064bb88289d7eb25d009f36aa10665763eee55e2523ce7a13d55f33871db46abc3a8b9bb5de9243f908936fb37b757da5da4c2336d4c7efd75ef99456daf9a964ca9c22109dd7686fadaa47b3b6649efa2acfc9941e80a92aba94a79b672a33245cef8bd456c4434decb68bc323aa9ac696b6ae0d2b4622d1af0133ff31cceec41edc40a421e96b49cfb243d66b93e132451bf3d0e7da144ff615c6d9fd3d0d6248efccac1ee369f5f0ddc9063abb7b674e978a5d3e72d05780ffcbac7c37c9eedea720619cf4b072a196c5d9432c8a5fbfccfbaf8903942ea751b914ae073f27490d1df699f41720aaeca5c755d53d53c28a2b60b055637457db060cd3b197bbb54a598dc9094cffbc0e14599c8fed6b22ec679142dcde208a83578af437e3a27a98e6e68f86505217d859ac79124742b407edf96b876502edb7240f51ccb11162060a760a24d8768d0a8a4ac7257ef6a26e2236d50e408319d1e9199e02de7d92a0ad8166b5c83a67da5a0bb0e24f8a553cd164c626c10b4bce5b6ececbb13255ccecd40f1ac4c14dc7c6345f5db8dcb7cc18b00b54305038397c1eaa125094a49d1c6d59765d800180abda3d4ee69272e19939da159a72c6f20e59bb4d0cf92f971476ef7c712b28df36793d8d1a5e490fe259924697c4bf17c0ebda13ad0b4e7db25c3620c56e1d7c7c4654dd6e0533b9ad721d2c494d5d102675e1ce80d4cf786e44c6d2000564c2e434f2bb14efa66bffcb32fa0555eddb91d75d46040212ac988b243dcd7ba89f099334f583d6be9c0b725394439fec9d195abddf857d57a66589d50c9bb13e9cce2cb0ec2b6abcb6cd0b94707c9f47a0eaa53445f646c602249e1e2ec034de0d5b1a538c7ace920c7f34f490ffaa2c7ac96e2e702a3a7876a11899310ea22a409b4c160178822a86bcf493ab37c5a4f3d3e8c11b8cc45f45b57c456d7f16d5c4f6caa8e24cf4de23920c40a9bc631b3070d95f4fc275a0f9d941901742f3465acaabee4e84367b7ca8fa4f1f43bf9a7686b83031600dd2e16a9cf8a4aa4d61da6290b1752cda021c96d9e0ad62d6c2667a24fb776488e9015ddcf611062673f45cf14ffef99507c704e8ccff2657c58b8d9f134897e20c04c7476df3992fa0e29d7237e31fe9f10ce9208a75ea4015feddd0958125ba617a50166f5a69e485b3fa868ca6ac70da9eb642d902c20dd13418351b69c0b3483933f5ff9ee43f09db39fa9d5278afdba57bb675cdf8aa57b83d9b6627df21697a6d974c96b85d982405aae98dc1d2df1a742e0ec3c812f8499f3d798e956d11be592eadfa32e529cf8e75560d6d404dad8a6212574790ddfc3eb86a314bf3c4b4c2ca9350c6cefca20f5e1ab2d3720990149cb98be452f110cbe2630e949a12ed6db61ce6a75d719b55af8435a0125940f5061aafc4333a882c646ffb8b61558942496bca37e9cecf0e70821c1210861992b20175d72480943472252584be2391f8aaf78b7186abc9b9d6d52339ec8f47013adea81cdfe48104ab6f055ab4396f3f03df243f9c27f74207e699b5bb6d9419850c8b8162bbef59a0029cec8e711c77357c52f9cc5c54b28e4f759460d88964e2830d0b6beb62179e09d2ce18e8cff8d9be0da4a286d31218a4365e076115b97e4edc4e3b4a4072cc6da6eb45dda4f4d7fb6fe4f2e598adff0a5d1d464ad448d0d91558237d1ebf858b349dc3083d310784dc167aa4eed30adf976c406806705863b38f56240416f1c4429fb1a372dd86bdd50816432cc328d5a0086d660ede684b8c395e91c78f4f560de75fb4a8df0f0c972154dbc12101c652fbcee1127ec1ca86b62952c5427605cb863ebc4a2dc47ef23020ee1cb2ac0a4f3c2a05044cf50da276c6570ad2a0b772ee404a2ae31e6af75f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
