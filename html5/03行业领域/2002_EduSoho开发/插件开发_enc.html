<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03bc028c6fb7e0aa837bd851765cb4968dd8f5f4a1d23711616bec7225b7158c88b49060e39aaaadc4aa00ce25095aadf73a14cdd2b1bcf0f5804e269982a437ef50f501fe0be8f84daa0d81aa886a393a306a5935ed1785dfc6571c857f5190fb709e4ec25774e4cffed722b8910bfc867b2cee917358c36c389f7e4260c13b9b2012e8d5a12a5f2c95d28131c152bceb1588a43d1c0587012c91575b50465949448c9cc9f7039490d8e312cf53e0780625cdce5ea443653fabccd552b6d868f6c11d3d9bc0214a806097566720938417e8c7ef05c35c65ec0b27419e2cbf513e014a05f686579f940176805f433e65e3cea3d2e58b0e7cdbb1f2a6250dacc26cc831ecc3c014a9ab6ecbc9aa566de1cce22ba7fa951aa72080360ad7f16687351c5abd57b46d72339f648babca7f605a41aae9721d9d4c8512ac7a74f68d9bd2cb04272c57ef4344109f899b853eca37a163069ef535a899b3a8dedebf3f73c0ba2823a6060614691d732a697e33e0d82cc9ca6a91c6a8e964895447d701320c36db24f00cfd8ab211db993a9791a3195d2f12d1fda492632b995ffe1a2f7b4a315f0fafa68e7b93281e8276018619410616771ac3005f5aa26fdead474b1657418620459b27d9847c3223c9f1ca457f468fe63d488d8b88d74949a47564dc48d24fa746ad5db542f55b61d88d0c57f71503fe77e641c92e736c3d3621644a34025053c6ee6a29f3bc3c42e4d6fc69772a127622d6c6c512f06ac57a3220e557f458142c1e7b123a2840d62b87ab3c31b551b16bf5619c526a2e83a0cfbdb334c3a60d5271b7277d277e5bd63296457ff3d8862a80bc63d1371e47cdfa46d412059a72f69f092ed6a0c8a310191d5d4bbe4c9cf1e5662be277792ce4ad321bba35bb279a837c8baf82ba9ed856021095bbc69195e5c6e152629a8dc80e611482a35991d9af372e7001fce649ceb0fdb2c4a657033cd2b32811a66049a946979682765dbb4b4c949f9633ff6946a9e2ca053643a5435fd56ee2688937d1f2bc6e0d8f8852b6daad8b5105ab9e88246af7c94de61f38de0ea85ba99cb5d4976b5eb11c40385567c8ae0404506a5b26a67677140a72e1bc7f399abbeb5058159a815e55b4b1e6a5af2ac414763ddf8883379a4f404621a0faa58a9669ac60db927a076f43ad75330f46ef4a24241dd11459c6fcf8f53749e129915a84a35ae0470e0c951ebdd5c5f412630113f5d2cc4168a2c261fa3ccc1a1714042463dbb5ded748e0b1653af8ce0c72ca574e35f424b682e0b3ce08e2348e6fd11f0412fa9ad54c63b287c9e9a7a2dbea64bb0e5ca11e60dfb9388dd8ceac4f2b1958688cadbfe10daaffc68486eefc816a4e43bf65194f329011e4ff0f6bd1c213cb657e838f4a6c7ae330f88aa01cc0edc1d6f4575a1f2bdf047049fb29dedbdb4f2d0c22c36895bee34aeb0b623c20886c7ecb168b4c2e5af491cbf4dffe66320a6c886881b89d515807c0f4774d5bf9091eac87ac2a0b335a5a552418cd6f6177ba434c802683c4b3fc6ab0392054196da02482710d94bdba359e19a5caf278767825da603c946f089ca7ff8a8d757ff12dbc9124d7f9898fe3985151c8b26b5640bc39f562c889e02e72ff08a98f97db6f287db39ae4aa2574ccdd3a31d1717a86c20d2d6cf602596d45e923afeddf981ca39fa2a45c4c4274648e13158cc4d83da61f5e100111cb22f0f63b368cf2b06ce44cde9a6fa9498b6f3a2b805d781e6baeb9c96fe30487dc4117618efb5813958261d3fd583018ed2b709ec10cbd903e3f0537c410505db6a1b1455c20fed1d2be4201e7c4ed705058433edc0ba7de6982b3d25f29600632a177db447c05174a8bdad9e1f14db24a663a543f2646e8d391aa92b1fcd0ec8f310dd2148fae03c6846299244590a62476490e3ab24741c20d438bc772cc1774dd2149087b0f72f049b2c5594f512d57fc31fe15c473b0cea01256f930406b2227dde6bb93270a350fb494842ad1870b725420cc4e9e218d6f8ba94ca0406161c5b422fb8e5ed647ddd1597b625b736e90806a398e8b5f48d484eb814acb4a4d007a7101775a75b5b4f32e74201c157923ea438a7a1b9b38304df236ea89e98dd6b2539ab061b92178ea05b39bb5f50540b11d97929a41b3dcef960f2730e8d37a7d34e161d62865683168520e3168aa6ebcbbeb89b3b06adaf0388a9701bcbbd8741f12aa378c63f57ed49a648eee6e4dc6e5ac2a5217a7e49fd4537872b5f16ab115ff210cead0a22fccaecd8c9e6b71a753fb2aaba485dd407d6680cf25aed9715a57573b1968188a44d8ef84837d56c63d0318e5b36c4ae1f65c0ba17c82b24c220e2dbe7edc7d96b2dcdb4e7e8a4cca6fad3c08dc7465fa8f3c8bf231fd298cafbb84e90b642b9cbc017ada9a66ba7a57af161677513839c92efdc292fbe6d08b0baad23f38332f471ecedcfb7be25637346f87255cbb5815fa017a3dffd9af1c68c33b3a673350cba64359d9fb96b7128ee02f2434e9bd4a38203196a887bb78aebf69c3fee5bdc3354c06040e955d5ba1b5ef2fdc2b7a3486e81915942427b46d6430f015d02be59dc00bf88c93ff4f8cdc8a6445834cb4e6559bdf945f44d01f3d4bfed59bb1fbb8654b2aee0fa00d44889efb7b21dfab6422bae221e3785af5e22437ec1c6109e7570589653a6559b1fdc8d85f7e05e6f545d29bf6b248b4fa6df081ae45d29acabfc62cba80a660ea028638cdfca2283e9f5ba37965270f30db6142bfeeb316bd73a77e230f7434a060ce0fa8015dcf8964492cd0cdce83c71b4a095bed0fed064b8f66b76d4ccc62c4ad138ca6c95d3842b7ec35c122d5396b1cd796fa604d6842a8d617bb7ac761749c964618cf452da566227b61a77ba424b0118eadd2b3feffdec85e585d21f83eff6d47cbf28632e06d85dc46bcbf197a4c3684cde1d8857bb072134502470f9ca7bde54a19960a1859d8de94d30e095c26651fc2d29aa6c06807f0ca9ac1a45edb679930ddf6218d9fd10042a06c282ab1e1f9131a1e4eddcfb34daf18ac0c91da6b02034fb405ae370034db7bb699f7671dc26c68dd143721de116df949949f8da827c4e8b3ddb3c30defd14bef4d4f230a1f3f0cfe1c5ebf10b2800275113dac76faa38f96247f0b718753012fd8fb6b79d563576f8a84b21d04d01eee91dca3c656fcd7bbd4e9d98b78e8958c5cf1aa16f8ed5fcaa39eb8b3c4708315184b45bed14c07047ce60cfc66f849636dad1714e45c9200799322d770639bce26686a0676a836148f477fab69b357b09ef7a6b512c92964553ddb5de672987d5208a0c2715ce8d58709bdb1b52b28263c30c62b26893a6ac6e5bc0cf3f5e0ab5edc1d9dd1628339e853a6014835035111ac9aa863e9293949c95755581f0cdf4ab9cece03242bbd4e00794adcb369307c50b149393fc8e63102937cd9bb1eac901347583e00403c103ac67d0a7ee883254143b295ea4cab9c94fc76409927b56ca3523418c0aeb81cee6decf7c3308c9086f5f15e99cefa5443b820b86f8dd98dac86419dcc988287324fe29135dca51636a96e8ec10d3eefc68feb7b70071859c8eaf776ce307344b5670dca88bea1eeceff1dfca1b2571f029a72d8b94f0144b902c5a36c9669ddee20728872c8e270563996b204f1324f9b4dbe22c1f6b0040d2ea8f5f73921164f3346f2b28bc963a0c8c934e2aa0dea2199ff4fc7193d598ee95f1b3e1a16c9fbe0f33a876de51cc92602348dbc85ed9d08df3afe3a47aa06e8238f54721b583683b04607bd07c6ea3521653b99259b68311ce09899386ab2626fcb74f13d05ba4267c2e8c4c31724eb7d9be836ea45e40d8861b01903b7ee8141193231b48c9aa511f20dd591c19fbb599c505260ea78cd5ccef4c1cb1400b0af0f76071f92a9e8c27c6a5da822bbedbb1c4c60841d02b627cf710c29c53e052a7a02c473d0e8fd6d54dff9e45b47e797b05b0b86be149a36c947649955d2983acd1ac9eebaa29c6473019d485965250890afafa7010f48b01fae540ee8552d3722537ced78f84ced532db5356f225501e6b6cf4c8d82ecadae7eb600c77c0073d42b739639edea894f7f5ceac8a4c4af4bb0447f5884d2cc212c744bbec1c9dffac00fe1a4d2bb1825e4fa128d50ab0f7a0373dc164d423aa2bc1f6376f0bc3043df5cbd5444616e54c356dea947ecaa560b1aa9e6ee65ba1a7d6f537316817e3879997b3be334f8920a6e6b76fd6424d89260bd1a10dde51dc6227caa792d3ed9b077f9589aba94c6edd59a8689eb1992ea726d6ff9508bfefc3adafe4ecf23347d725d0ef2396791dad2f27573d8dcc41269a04f27903be9924768a10c8d814fe8d8801ce04eba5b9371a3f81e5d103fc57e2192315e1802e5c37ba2a475ccdc92c356eb38ea48fe6b7cfbdcd1d9590630cff1542c440fba4478d93047dbb1db4dbfdbe82f8130ff0564e322e719905a60ce4bd8e993649daa78cffb5b1043b451285e482c8c01c0d3698674ed3ea91f421c77284c58c05ef834635f5ffa476ba1c7562e5a3dacd3cacd424f75c9fe5edf59d2e18d0b2c5d8ca7dffcec718ceca7dfc871119b3b6091ca61656015dac5aafefe21ca8eddc08e8ffe17dfb8243c04d244ce8a3f8100bad6d71514ad4694946e15357299438e3e9e7ac38e0cdbbbccea63ad6360fa9e019e5baed60819645ee3473d151bd2302f7b79f1b2bb96c70e3a3f81ed959b04de04c1906125af85ecdd198b5e347d37c4d9cd3cb911ad1df396e7be63ace9aa50d4d1070e0bc0702e9f21f22d86dafaf6875258bd6b54de2eb2784ef0414b00b809127487c3d72d2724c6dbc596e59bed1ee48c5e48e7becd1f234b48a1941df352cf4e8dd417d299dbad78f7c2e536ce73d4f29c54f4c56992017629bdaf541ed94822b35bdb1b189acfe61635f7027ae6ae4c521b7da0aa75fd310bfb67b0ed2ab19c4abaac2f0183e7ba652abb4f1efa389de2d430d6602d77fae3e51a3a7f2fc83029e1f15cecef0b8a9c74242bd0b13f6378447c555c388837a2013e33ae4d242cb97d602fcca94b4ff577e198db6776956615546ce14ef8d1727357e828484a85efbe1be3f3fbf13edd8590341198ad335f7efefcb1d8f1fb98af27ce48bffcabac050b4f2ad693dc52615afb0bf079d34615d24c4d6a0566702898469f2e8481d95704de72e14b6d48ec57321ac853e8f8e186e6bb1098c5805abae9daebf07bd1ef2db7fc1a5477db118a6e9a382fd8f7bb05f7beae801b32ab5e4ccd177b38eba75056fb7982ac02bfca213202ecfd0e18e6ae3ede6f6606b5be07fc7cbb439c5f3e3b426ee590b8270eba7767327239d6f7cfa2ecb5d14d44be91b44020c237dee3e8e4c653b5ace6f8b6f67df76ac5a7e8689b6532d6feef6a36d04ea869404880ceccf099158674e10e9e5aa609d1c4aface82ef57deff12939033188af9c12d8671146027f1929fc6a86fef8c88ec648607ed952799277e65fa0a56ee6b42fe8be0e81eb27100794f313dd14de380e100c5a8195eb2ca8447f34a867319eaf3f930bc0cbd79cc370aea4d2c48ea0f0fc524b89e78c31a0cd2e7f13ca62b29032761d437b00f67a2270592d5ead107a07f720c5f1397ecf8b48509a546c1923bd8225728861d45ea815612d3aa4c2990209361a4ba45ae6e38d6be8102207ad28b5791f26e002a8ca87b083d1e23e92a8de971f376959623c3b7124cc66aec6bc9a4ed0568a303ff54800eccca4c8615c2b2e1a8b42789f3d91c1a16fcd0b14a6f66553bd055c82c05c8e518e32dbe640600814bf648fd345abb29ab625b0083a225940883a7e8da30a4b29fcbfdee085d96038ca7fceed2e7b51d23caaf3272c83b633616089ea120ac88d0a04e4734da6210ad103d6208351ff16d44758e8377f2640deeba84d9b726d1341b6390eccf81c782d0adee7c212920f212c30dd5a77fd3cd510c2c18808ec8e66d00d45691ddb86603cfc87171f95fea9ce1134452b2a6220d61febd93e5984b868f314c1a3ca2aee1880752cf0843102dc7a6d2f05ba7a4678e8ef16a8c98b82ee9c32f9fe59ca0a15e417201e3441968516b4a8570eb9f189835a0b68af4985df916c27086222cfa3672bdb2b04fca9bab40769d4072ec38d653d5959db561495a13b07b71b15ab4a999af29b9928471650869ca5a1689814fb7bf4e4be063eb83a2838a067ed78f2d6d91d83f6fdd7f9834b4d94ac83cf379c4c6a6109801065eeca9d6a32cade5dd9c00f394fb0c8195928c3bd10168f348c335959dc71862118504cd66a6fd16035ecd274bdee1d4ebc8023d0d514522edbcaeb063a723caa813247d70c02c74bd4aaa64f39324d7032eeed74efd5f3e8d189ab44b5b748b7cac4910c20cc5d448c2d70a32f4f24d75df05c0c0db85e98438dbac64449e7b9dedb2399e6b91ce68e805beea2423d730c87fe77078bd3b0e7805cb4c37929978de64e431b5630c3501d1d6a4e5df24e4af20355b805641e79c0e4419608c8be07f1248bc13c9f9c78eaff202982e87428bf650b7c31fa50978ff0c49f5790ffd5878a964188a2fb3d2fe8370c2685cedd46f2703ef6221599b01cedc44ce5592feb4b404641237d74eeba6d323e841b20cafc2eb8c74af07fa706e71370ef261030f7b69b36553b510ff6f0443870df06b4bbda4f13f325497de9bfa5f2807c9b0bf0db54cd26b7d47e3b41da4a84586027a7d292adbd41c81d31bb4c414a76937b4ee8c3ffd354bb126043a26fe98cd1c8b52e1898e3199a9f9ae0a13761eb43829b7099dca02bf584db4b40f6b57ef22c3986ffc1d7cc883db2b8c96d33606f67d9e6bcad3739e2249d914deb54a841472966012113ae2854a6fb4703b3d3b5e0289d4c8bc3707db83d046992fa2908a3820717f6dd2884a68861c7e40d16121a07380ad7a1b07bd71315e96d647a1c9bf6f58fb54f5e1d6679b93b80e5fb5bbe9ba6c02cf8c07882e104ce521537133639f52b314d8840320480b69ac69efdefd5a5fc8e1d3b399997a5da5c9f6255dbdbcde7b4928f36c4fc730ec5043862bab9b738bbb75c56102c5a5cf7dbc80186b30711f91075510b12e71456908683244d632d98b742c697cadcf7ed5fa0cd3f47e5f810cb7eb89448ccb1ac59b0a9061029fc43b52eb25cd89281fd9bcc6753de86d07f64e5189705d1844000bcdfa6f429d52c4668e72e3b5ad7a4195f9e2561edb5215680c4a517f28c4f4d609aede3e86bab32c1b0fc04d5c44011717bb3dcf04d1f8626642053f5b82c77d9595ba6129a42a2fc46d38ed38a6dacdd08aab085ce88fe8d16abaf0f7a4a5150ee99ae28d5aaa1f578fce87df9a4e98ed93bc146a19d41efbbbb7a26446afa13f63047c29aaab322be6926e30c19186e32f383bcf802f948acb3d228fb9cc91bcb6549c40de9a5d50813f8c554bc94a10edd18692d27d59cc9397e84e31d303f2847ba924bfacff76212c1b8e9933ee62170631828c5bd5b5afd72ebe62e9b13939fd3b816699496ac4a2df7c39a2d9deb47c1fb5723aadd5903221e9adb46c5178fd835c1e1ac420224bcd8ad8cea98a0bb245fb3915e1b1835f213755347d52c421b3881d23f5f07df8386f46bb3c4bed087df3b54b08f9063f4e63f00205351ddbf8ea66ffea607b05525c46359f3d30d09f17b5da6f979fd3614144d3ded64c792c12fe274946b96b81dd03c666030cd8f5fe393b408e027170a4e9f654a6f2aeecb1663db2e7060ff4d77b925f7b185a167619313e646faa95eb43bc9e295b0fb0f3365800e7b5561638f1cdb4da85b1e30bdde365badb1dfd7a7bc722630f977328d7e81c560a7bb883672a9e619f703c4eb20389ed15cda73ec99132e6577b6be2d8c277af7bfc43934ba3b59d79fa7cb9b408062c56a3b2fa6c27f2eb6e437c1cb3e784a3b44e71cb26a301735bc8f72df2a12bbc4e503a0e74209fcfef641173e15d0320a3973c1b78e1a944c07fdec43979bd9d7afd30e8dd68f40e4f0ba33c9633717d86657d2fbd310fcbfb76281781eecabab877756c359e9dd641b96abac519de543ed2ef711e0c65b846049b65fd9cbf502e8d7d5b98c47c938ed1e3345dfb41daeb792ea2197a16e711d9acd4b70665b9323330cbffe466e32e4bc95f1edb3563ed1d767579c00d5fd6e6a3b6ddb807459f7a12df0bd1934db292d98e731d4e6fe8746bd1ec8b09e39eb6b7b8c0804555d0b0b757512a9dea4a4e6571e646001f040610d2abf7289c615939e483452ca63594435f70d8f6342babddf292e093b175b6a9f19de7966e265baab820ab34794affeee0f908d937edd168233234d65234f72a21f99e46eb3ac1b208bbe491fb6bb37ebf50f4db977e2c473ee3e844ddd609e4b51e801984d3c96128086165c3ec3ff970b9d00a8df514456fca34ef82f1767a8994272eed3a5ecfd46ce78dd37cb2e63ddfccd5a70bc97b6d932e7be0866ab52b59c709eeed8688dceb8839243721a79775b17fab847b0665bd3e1a7a5a545e69d874cf3daa8008ac967352d2e6d36b414573d464af6f147fabec89a9ee77532b7bcd537d54a13e73478f5ad455d0b9d6195a67fd4d441e5db9fb2d40f9b125d59af8280c05378feffeb3aa2efb4025e586a5df14e2fb93b98461010f4d7efd9ed97116a33e0dd45d3565a4d05439bf33e5fb984e325297e34bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
