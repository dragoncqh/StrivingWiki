<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4651286c6be84985631aab42a68ee1446ab3c6b9ebe17340f5549fc5d3877a09f157257907d038de1c7a583fbf11beebf84b24204d334d7cdd9ee1fb05a2746ff8a036062faf476be26a692ad5104bb39ed90b1cb8f0aa7f7e2d45e9b61d02fb0b73218c12920451e97ce6b2303684b732d3a6102223e57993dc321376061e2b9cb58bd0b839d48ad7a3e15f4f81c63008f50dd59caec05d512bba2cf46f89ba1dfcb955e85fbab5b0ec7a223a0531017b31ffee09746371ab8b2b7d4f1da09c059d1d1cbb0cc384915554ba922892d42083b2363abf41b39ea2f070d172d649e74688bca7f5eb340953bc77148bdd6e3500390ac5246047cd03bfa5e22306b27b05af724aec642fd5b14f5f1fd5f3392a5b33b7777ba18c864faf39f6e5d45e0d1bdf9898af6232236ba60655cecbc2d6a11fd45bc5b44d1e23311b1453372bcbb1bedd1ee9672bf33b9c64a3e08de63052864e8af49504f7dda420c5e933f9592a7e59fc0ab45fcb73d27026b43a187a72a634c364d3d8aca3db0c5e5633e8acfc20d4616d8ad5338d433cf3986eeb37cbac9facf7d0a35ab6c36ab7edf7864c87b0c1aae53d2306151ae7a27ba211a98e7c0105b9d14d27398bfbc46450d47dcff99b7e66e7db2e6b219cb6829861c013e508b34466154c24923addb7ce0d4a5f918ce05657a58e9e95a1bc45226c622a64194a675f50148bdf57fcbac9e6220d4be16853930a6ec795e42568014c2dbdd7598633f7aeb491adfde067e974c7f4fe4986605d841d809233b967d46bc85ac228149dffe629a95e5df5e617aef65165c88ea92da5603c005032de6aa01443fa4c2168042a4f719ba58df56749f838038444847a2cb42a0e8bb832f688019d62121327f13c8b811597c44691ed42a4b484cff95d7bfebc6b3a354542be556d3c3b5961fab85e8781362aea9899000e797217bd429b2e87ed7c8d3e6384c3cd6e7291329f5e264da801d697ade62087d30ce1cb0d85654b085313cdd4228650731936bf1c8d92efa02356f3ca85240d7b9eb6a8236dc5a9fa8c203f9455b68858bdb41ce87b690cc8bd0cafd8de5890f5bfe3931624d226b9279aea900683f3f8c51e341d5fe7ebc3a578c225bdbcc4ae7afba22364caf5d8f56875fb8e5716a362c87c91543d0d277a576674f698bf4d82bffeb273ce59978e001b4a2ddd38f1a2c915c5adfc47232deb99a59f362c654044b8a76d835d6ed427f1ee71d97c6993b9407c183dd77c65fc0a5a6eb9183698739a9890d9eee7b2e56574a22b7842b5d1f1caca4bebc8bc1bcc289a943973832ef7f3ec3d2b173a569179e6083759b41319b46a05798d980bc0afbf9e527e9de1a827357ff35623e85a1e620420ee9a5ec8debc190908c019a33f87a9d5af21e30a60d37dab121ffa5b62d4ad7e81116963b3bbaee7066b0bf01856c1f1eaf90a1aa07dbd840fb49b06993502a151cebf00fce32ac53f39d55855341c11ae3a30845a22deb360f63a43992d915420bcbf058b7af54eb0f9c6f556393378e3e37d71f29e129513860f9382e6dd0aace779c6ad9cb67ea10beb6a76aba67906e3478c85b23138ae9f84f6e2bf20b27baa5b438bb15a4cc5407f526b7f0d5eabd632f0c5589bda86272b911e31dcf5a4bad3622811def00ee78eb27fad9803df5850da5964d7d006442bd6de8caf2668f135100d3c9405f99fb58f5dd443ef0bd6226b95160466027b99826f3560e7427622824fe1260c4f01d26b9ef19277199c6d0376e8c9f81b5bf66e1ba5967788267477b6bdcaf872e34cd73a443b3ab9d77224a5ce5d31b529f7fa0185037247fa6844cdfdcf740057fb14d034463cc0942c73b49348bd68c9402087c9fb25123ed87f2f6bf2ea2c6bbe7543f75758b31fa40ae5ad2c24b52442c92cfc3fb69d5da43bd3204b19cc5f09c111a2b3f0513d66ebb648d07d66e63c2ee122b77bde5c7aacf9f659556658d523d35811da9f333a6f1fca10d22e075e3733081c88c46af6b6f3a45e638dc6b010874466aa6cc7b0c3b0951252d11ace57ab165eba04aaed08a73cf63df51e76fbe452a57ae209f3edd42d6dd9d3a72507344f404853f32a973bb5a80cca3ef43f8dc38cbcf6cc9306d09290bff42476c2298d6ee13d56a6073bd918464542a9282beca783354b60f9989bfc0700d96e6e98f14340dd26b9d048dfee5ee2958e6dfb25c2d3bd450da4cf3f51d56eef3e2bacfe56c0ca524b2ff38ecda8bfc282bf279777f59cde3cc84f08cbbb5e87fdda9ffee9811e86060100b3280f6f4d997bf0913b0976a3a0dae33aab9b9616763f3b00555e7b2df38cd524b2915bbb16582da7d7aff0806daac5998df14b41fb38ce0cee1ad3b96eff12f20fc0bdbbced6912c2508db1fbe19ce696e7979b81a6182eff0c5269fac61ac3e02c0ff236525a98d9a494d6f26619f1dbd24f05f77864228f31e9595e9b87653cc80545529fc921f20c7203cb028cbffa9f36e34406b7d1d97e6b51dd5d449d70b8491bbcfa99eed2092ff47f3f7ce900201076addc84d8c820731da5ab282f9f185060e74fb136cdff4a4b3b90b59a1e1270b1a9f823ee3a9bcc0b9f73c532c0093db96e7c46f75b920bfe9709c0f3b91f8ea035c36ea179e689ee47b0da55d5370c3fa56fe761cfbe3243171129e8fb493f69d43785b2f941608c7cc9a7fe3f1c6325606f9e5124b407c3d18d188c97215369eeff8e0434ac2105d2b4627192899d3937d98fb0a43f4ddb7bc4815f1910bb9c4365a42551185db589e8154df5afbf621ac28146b4c6167d1f67fa5e740561545c7897c6a00b57c0571759c9eb329b436731ae326d44ae3627a0515c51b2da811d746ea4e982d97454cd7aae7492601edf3e41692043f7a5167a2ce68969f606ae5bcd0e50cb08f9630d649ee0283ae185fa27db36ecbfd6e889ccb1b944ec497077cad630e46e7ee943ff517a50afedb3ce6d4d948b6a9bf7d5016ac2e8b41990bafa2c4f03eb1b0459fc35984eebf95f7bfb8c107ffdff6f1d5a230ecebb0121c9e82ed90a8fe70a7f6e7fac64a8bb856789df78554fad4b0170cdf7275d5587cbbfa1707c4e6723fe5ed3ec1e32a57eeb7803dc30ab67f2a2f41e3ef25a2586ca14c50652a434613b0d50de0baca6c501e734e477568dca9999e48e224a52a574765e0826bc61acb85dc5f6170c6c75861d7a30db8f26947945f57680bfac8c6101ab49aa5e62a52aabd00b841515b78ddf57f56c4f2ec409ca0055bd26cfe96a98cfa5d76790a48fbf8bd4837626e656102f55f81bd45f88ec1079e2f3a54a05fda9c5c19d0ffb90f57347a2b530dcbb33736aad856b2a7c4082d1f5af689bfbbd619104a0a2851ecae790c8d5b7b145d2b6209833c1d6c9f9b5103b205cf4c378255b89d03cd41c85bed07078b43e1780caadf7cfc9932b5f59a0471dcc609158fc8bd00403ca6a101492593474526ee26acd89f8495262b42582a3ba4e326b62cbb45d450ab8c744d08acc942bdabccbaf4389439417c3ed8e726c2e662f3c58fa7ec094d0e119fe130efebea79c0d7f8fb20ad842c5f17cb3c21d019cee67873675739b788d2bb587b37dd3ed7b8832a8dfd7fdc59b3d2768268a494e987d6424d663d6ce1363e3586728bef028576de45b4ed274f6fddc10143a4e46cde0c1e091e066fe03d18e79ddbb59aa808f668a8b9372f1a3a187bfc2487b5cc4fe02208e116104d04b4558b088d821844033b3542180bc93fbf62a2f09a3c7bb467a6035a07c8f8104cea153228c291504ca2b8777e16596ec4cf59566c23b1e3c17e9e452e932cbd5c2fb75e123d7389f44986eb8cc67cdcdece8e314ca57ed4988bcc272f20dc01b9fde36bb7eac2cd23acf7201506d014142b8e6878f5398baf65baba1a80252ece9a897181a9addfedb08b149a40cda9247ae1334988ff4edb8fed6ae42a5f4fa77b7a67b8a57d088b6da38a2310e3897334848699fb51cdc661071b4f9e57e8257f8c60947662b0667162f2c4baf4f340b47f8e4a1b80db0a7b71f0622b398776af86b40e8910c44c513d0f749c3de68f70d040a2af0fd0bc9adab42a6838d56c3ed6b5850c55e3019afda751717fea39e489f61b28e8288be92f3c845f3ecb9a9b629ea4103c558245164ac80319fa9f6a91897540338aecb1aa4cf9dfa90f5069fdacb67742a1fced85f3b0c80bfc79b8fb6ca3e8732b04db253f50f35b19557367d01c34d4fa2a71c7a0fe2c50bf097e3413264a787cb28f7424bbe4110278b51f4983df36a50bd1e3eb198649afbff4409cf408fd65bd0d7a41c219877e9ad68c9807c8a0f1f252d5c95bce772e113b3a06cefb99553f3c34ef8543efc3e4a1b2c24e2cbd89daabce8b101cd1ffb131190d900e838e7895d1aa3bc7b9ec8f525d56f7b221f4f4acb97f1f758bfaff2fd4ac883fba6cd8f65afc6325c10d4de3bd81bb2a6006285ce193a22139315ffac6fd4dcdaddcebe1ae569148b3e66ec4be93e2a6adccc25906a3a832273d2a7d094f63f8bc5126d3a93f72db756fec715c8933833059b637e203a8ff3e0c6ee4e8b391f24b7d026f1cba7dd5dc55b6f725738972e1659993fc3cf0288a4a7731e3ee5d38cf6932f0c62a33f00ccf8ee4c45760f8cc5c88a83c02e0202d598cd0f33eb83af2e4ff87681da78bce1ed53b5f2a139ae514a2f03feb6a5fac8ddfb9eb06252de9343bcba39d052f678315f010ba261b324c49f91d21622ccf456147b37eb32e1c83121db554de772873ca7abda8cc6f00c3836b8a578afd44f85666770b958af7e05dc8853dc9bb734691ccb3eb123dd4fdbf7b4a119fc64cf40be248a85d08946cd0c6de11b3d0f04e3a17cd6f9b347b6b226b8525a70e58f68228e365770f39b6166f2436c2af8d04f501bd88d8fcbeb767ebc8b2ce25c44d0e064b97660d9dfc0c075f21ebdf5348538ed641a363ef0e1ba020ce07e570bf8e29f32cc1b550558ee2aaac9b68ab3cb2eb7fd8565193a2c212cc8600838f13d055cfef11ea63e7d296b67e622a35bf63e94d9c7ec71ab641998708026b085bb2faa6c138dfe94f834e89b4d87c60a1d21fec513e0b9db13ca74c62cc0b0c94c167d756852cd846e63fac0eaf739540b1fde14cdc1305c30140761f49edeec44581b7d954c089ed58a7a0864808f964420ead78d21f09bb6c3d3dcada873c2c760cb956eb862f9bad5e6344c95fc9f8e9c8a1288846cd74a3cd828e768eb5585c57984c44192db9f01428d8238b7b116b79501b80bcb506da2326e973424b2680eb2c5f5767a331f96a4ec721ab868db187fc3b5caeba81a70fed2a526cc3c9428ffcf3d9b6cef4f0588130ac6c6c241d5579c33a04412c4514d87ad33f2c595c16aaed30a561b18fc493a8a71dc05872efdebcb38657050156058920a4675ad807c68d54710f3b19dd2012378cd00b88117e68fe67c15298eda73467f9395330a7220f1de625ed4974213542a93436c4c68c4eecfaa4569426975663cb0b63f99e4475485b487c753b35c1a6c366705b4d57fbf66bd3b6863014baff36283991ab3bce63b9a9530e388101a16c80ac415397b0dc450f4e4f1b0d7b697a5d32c496a22061f12c0e1b7f3be5b506329e9863035eb1aad6fead947102c8c150bd1f609826bf5b9d56e94a26cc54536a4b6d95648e6aa7ba36ee13b2095aa9bd21b9c3fb78cf0f2d6e7d2efa1d3b983d32f72bd6658c47ce930262aadcbf1792cdb79bf9e82e09cf5c4a85e7d51f40564738a66aaa727c57f5831111590cd5d8cb8465fc8c9f0aaa377d9be7e271595874c72a846de395d6abab22cdfe80ecc8a59247a6bb1c1ebbd122ffc0f6dbdff58a73d7ffd4cdb19c992d8e605528840321c89b40230954d7656ec92d804e56af1e40f97ea8aa2e575dead6a58cab537a596487979101c9ef3fd311439a0637ae74159c852514700727c3accf7e398014e9b7b2ee6bcaf90a2fda7f49e1dca540b1320cbcf6eceed0a85434497804a6c981fcbc4989a04a742e26a6e69849f35ff09b597e32c078780edad3ce2b98d1c5ff991be9308d6b517e4e2adefec586b008153327337e33aa9109dc89d0237953a56f2b4b0ff128efce8dea3c61c3676ab412ab8591cfef0c18fe092056e174fa7f53fbbcf9e8c698d1527abef2af7ef5b48fcde128ae51cf1e48a46e61bd84b2a1df4f0c080ffee7e25d8e8be8facda2a52419acb6ad79c8accf60cd86c8e9a15c70899865003370e0d5eaf2ff028f47fe2c7796daa1d3dd54286dbac79cf9c8736382e0d9ac53bbf3476e10dcfa780060ce30b616fce7fe460664bb8776bbdef45e85cf76f16477e8f2439740138c008e4af474fd0cbd1fe0271cc6baf3a6ffefb8a46b738bee6e153219a06747549e6eb0b3c0e3531001191564707d30203fac4f7cd4463e195be0256e60a3c44f853af909d99419639f8908551cdff27a14d553cbadce265aad958097552dc4b6a59ddb050b606c60dff17996c7d27f255dae31fa16f282d26e8c8fcc7b1bff775b6740f9830639a9497254c0ff9d19995efc8455a6fe32e0d2f4c9ad023c3227bc65c3526d6322e69c6d0f03689b07f74e7c954663073528b9d7cfc0d020dfb4005eaa3e73a292b57bb245c0e4a2c679de6a96d0a87a9762d5a5c9f85be40d6012fcfafa962d8d218742b5294acc79795a51e314269fd04bf1ba34ee84323a621a43301b281a96cb240bec7b8cd0dc781542f61fb739c21b87283a80fd0df0285ff789485baffe583b520517dca604e2e242a1055866beed7de8ef903a7d5bf3c7249ba8f33cef732f8376287145b45b29cc062eb1e46c37fe46d199a8775ed435d44ca5324cfd7f95f743d137001a818ce09bf515bc96216f0db6ea4fd399b138c420d7b8cbc78ce9cbbc62f556133008857d0245aab00157a0cf1883c069b66c4f5e0a0c734160d75c591ed54a3c884168b12bed25eccc6b08ee22a101a7313b9522476cc98de77fe8818da0de2c628670bcd763c240979008f6fd172a8d2967049d9c6e4c7b707f10293926bdf98f15ada03b97fde0da5b14d221cbd3ae88a75dfee40cd5a3a8cf70453af865597120925f859f1a6b3ce9c221f150f7389c2db856f890483a2fb2fba729b77f3219bc320d0901fce48b602feb6fa6c43f80a83368f9c2ff32c8e774d9129fe41ec5cd573a98bd38fd76d0e80e82292e17ee09f7c071ad48264fbf75cffa96ecb17954cdcda803ed04dddf511dbb3837c6bab965998c0784abeb8a0c9c1476871932c7e0722c76399003dd9bd94a18ca5735aaebf3223ee7d3fe069621ac0d6da5c668eb9bfa577fb94ce4720e3aa8fce30f020ec39bf640442e38ed744fccf6342a6e537a25df6b8fd3aafeb47a08db8637bc8ada2dd26b6a4476c736b80682fd56b5e5b1f38e597c94a2df4a7db924fb40e38f6e851cdb99a913d35d38b2340a8dd9de6d4bd21b6faea3ded5a76a1795c1a4a13b5f999f620060c5465bc26abe3dc55190dfc16af8d9cebf3998a4efd24833fcbbe0bba79f3a8e179bd965f2bdc85059244287f3eec55ba88537dc7afbd899b9400c6dc1cbd25f6b28947b4a3aab86bc1d0f59daf8f06542b24d1f86604a6c8f388637b03fc34ba0e6c459712d9ca465077769949ecfd1987e4df3f6e2d9aa2015250a68b114add629ab5b73809d88a3a88cf610508767e8d3e0e69c7a92ad93a5b2041a6392fdb0fa918dd053cc10c4b9b01a4d9c9d6a9397e9899ef493f143ddb649b37a1646274200646018f3ce58ed8654c9116f97bfd871c3ea50abc8d56a11784c1ea86205212125c184fcccd086a71f7b91fb6637ab31b07317c7ae6fd4aca3d16172773d5d17f192ce3c6f83b67a4dcad68800bce67fd9ca85fab584919464dd4be9581e59ac20cfecb270e155cbea3f29897cb7616168240978d3453aa75cf8c230a467c4254c71ee0fa583df29e39182dd028c19e6611bb08d26273a775ff0a2bfe3b43ee1bf3536b756336330fa2ae694981a339efb7dc4a4101604128c41f4048c02585ea80a867c34cb2495ae21c3270ab2f8923625b37e26d07fad94cfc9c514866cf8239de4427455527e1d0685b49ece14462ded130c95661776a9ecf1a05e42f0e5ed52d4cfa9184a3b3a80c8c41a552c3f835c833f1464dcac16631d646005fbe8d1d836dcd9f17adb66b394ed2cdbfc3cbfec82a020dbb245762b1bbbac8751fd48ea1c65b940346d516f137fd6be9dd4fce65ec177d3302decf2eeb1f10cb7dafdb13d3bcdac7f5d1248e3a95caebfc97d7cc0ae7fd2e984c00d3104c829f3c55156ec28b916c51d5da5854e5a12bac1693b6e6ecbb9e515a2061c3a47d2fbf5e4164c4b58fb5661a790d0257e667fc6a1ba7d48abc33cb6514ab03f2c27e0eb3cdc95a821022f222bd71ddcf86d7ec84326e8ac00d160e1bf95e6ebd1e8088d8f0a72539d2553ef41588a88fa185851d3b168f8ab551eaee22a4050b206a6b5f1d9644780b778e45fe078172ce9a4a9f2afa6cdc5c6372f6221441abfcd55d2f388561a4fc9b57297fd0a1b4c0d48d3e4ca0d1b7e6535dd34f6c902b23a4462c5c1d947bdc355666a35ff9da0b0e6576d0338bcd5784b98d7aae30c289f21de24464af37d786b4cf811dc646e34b97dffa55b981f7d9aa5838a27808ba536b8a16723b029bf262c39328bbc8b5fcf8ccf3899ec0035c36bfa2b8db0d91177088b9e8fb5587c83e799a070b8339ac5f75244328e827c47007880a3f2fa1d1a85f9f992cd29915c8ef5d3b2502c4a853db70e39e5d6052b715e3490d8ed6bc40dfcc38457dd7616858be606670a2aa35d816a006966291910824012bcbb5ad0ce90586129dc2faba9a11500e77e832163c68e772acf7cf1a2692e25117e1d020478f45d93d07b3c701a1d25b349ef5c2ea0f3928604992fd5c890d8538814fa077601d781f245d89549534b7b6b0b330928a66ba0ed48b83bfcfe5558f5a8924221af7b7425c6866c3ce214e17111bc61c6b3791bb877e68b6d31f06c96b4eef44249829c29ca48a5592d784bc7002400a90aa5605ca0e8a8a493bbf0573ec66359ed380be23c93786acf8162477f4630cb4d6de997c65b30b0f2c97a4269f6b4ae30130d1043b98e329ba505c4c4e50810719f98a2f23352e8a0c4199d5381813aeffda5140ab205acb77a189444ba1814eb45e5190513d18684b9df545ea33e4cecdd9f368d9a6d8278e82cb2251e3661629b48e52b7b2d8c9b98edcdc0ceedf2d743ab975ee752d4398b64eaadf22182199eea7592cd8028e677c9344971a2e0299b033ca7f341c838c5569087d5873f0ae2a4e4c44c1b4151f8926e943651e09715cc42872a114e16d69ee47022ff4971997d3c0de4bbaad369d850ed04280871b1f0bb51282a995dfa47f32079936568700e8f13716bdd1176ad3892de7022b3f85c07a6ac4a6dbd052f35bbdf0bcc6b2b5ab3c40113d8628037f3ed948cc425d581a634587be7fc92bf3926af887f9ed0e9630d87417c58a05ec0c0b4174840533ed9a2422b6138f9dc7cfd55912ce538d017fda959efea750f5edb18be14c0d2b421a108ffbd0e98ea8f3faa553aa0e0a2d549030f5654d4eedd4a42d7bc3b9d653be8716033841c47bb038883cb7baed54954f800ced263a8a0de99a7462728a86a7babb028ad3112038493380307ec83a92c255e108e44b3468246a4ea3243f14b4ba059478b1ce69caafae3c1fb5b9fd43b1010d6645ab31adaa3747193f9eda6dd83b7e073a65bfc769a0fd7e9f1f74814956c8d6ddb5bf330bef76f0f1870798c9434c7fb3d267245b6aabcf9195e55db2ed80effd9567bd6ab68480c35b36b0874bb23fd795a9c010a0dc6482c9fe7c65d0c1d8b05e012f2f9a500915b4432f4d13b8424faaf99ccbb1ccff8c57f08f445740a02d5af23b73426f967f4cd0b49f956f5b9f3d01f7630abdf240a2257c7064eb2a68a06b2f9e852fbaaaf42b60c6954c8ff4feb1f90e7fd6e846671702e75965075f5480e1dab298c448be12c272732c93a602ec68da2f851e2c270a7387ae295721483fbdbee4933ccff2a08e719d3d157768bb5feafd2f4059d2ddcce30a32f1add8f18a54b2af74d48db5f083088d6996f169ff0fdf2249e7fdbfe27899a1c12dd962f52f92e38316f50936198f1c9e02f2eee9358d3b123ea686206b420f1fd5efc6ed35969b7de8479b6ec2ed52cdb0f5cb0b570e7c13b682d43111f4db3767ca9109be7ba95077381bf483196592ef29b4bf5d1f145b0b291f978303e9161516cc0b26263a32ce0f51dc15ff6aba7cb9d0088d5e4d0e4a46d403023d7f2cdeeacd8e6b41a4d5b731d829a2dc57696d07aec352f599a94ee6ff4aa6d396dfaa5f634c7d2e8f98dcfcb51ae435c1cbd6eab072da4026b0f6a037712c30b6ec989a6b0d9ea737bfc50364a42edaa26ae20a85b9c36199f27097b311259a842344c6230c48567c2b34c717c24eddb213d21e3a89c168ec2d87290340019a3141495f796ebafb7a636d5a603933dd75803503100ea20b06b25d41845d5fcafd0417b563f6a858de755780511d437993e0874e9f103563bd87dfe6052e29f7c88856e80831db4aaad1f26985d142d5853aafba5ae5dd7d8bd92086f680bd57ef77b930d011ce3dd904824e7230cd30715286272474e93c5d9210374b5c33149255367b539f21f9ac30b448c2ebfc87d642acd9f722bd1ea20aa38759c2fecbb0092737032d91ee988458307e7731099e2843e256a00899c3fac3f346dfc61e6355687632cf5992a1f5eec96b9d29afddf308200409ac549cdd2d5cd30f9895eea5fb4d2973fcf2cac7b444328dd925a1ea79e729e186a3d919b88b2ae3dd7dd8efb67591525ea1d7796fd51f97af5401f9f791de1a24d737da2db8539420cf6b692f8216eeeb0f1aa955e0c0dcafa403f4330ebcb3377592f711404b79fc027fb9bba237d449f2460c78a18344897a91a5765efc323edcbd7b8241f7ea0fd65966f64475ad57c71bcdf0cb42d508b0137dd40ae095014c7d022872eb077176cfdeead382edb2745a3abda37a3058e92ebcc4d1c90676f2d387c166d2815d66ab90d79b9f474eef7689c85a48da596b05f7fca70c56e3f30b498d4bc3a438fa48ae9ad7fb83a051ffd250cbe96831eefed295341256b38e3027f04fbb988639a8ffdec8f58de5e196bab40793aed567c14b67f5024bc363b52324a163374e222bd920f756d643afade241352ed4e9343f3609398c47a282056c232a6a07a2d3218adcc9db6e9dd2b56f6c5a35e5d73d0eba4c45527ff6919a2dc6bfa943275ab11a52269a07d480755ba9098823218c1b4413df6c487fa09925efdcb0bf1073238ca1b7ae84a06201707a9b840e4c738c668d39f6551b276c388728064958a0eecbbd51da6e8c43852a1768ec0d4d3f14f4cdb5383cf2d6a78f15f188397d599bb6610955113cb40448534652a8049a8e9b4a39e501222621b522a62db11fd78302f4d7693cb53516e2f7b06c76b03a8f2a7ba10243dd808c1440aa1a2ae3dde57a602419c7549ff9ddf8a6c781d4c44ce1cebe78a6f0920511f79a258b2adb0638922eb8aa1c7d2bc1115cdc7daca1a9853bf7b436f8cb071aafe3c611c1c856029a5f403036d0ebd953be1169a76233f4361edc83bda109850fdbd2ef91505480efdcd08a27dd68199fc0ec1065191b8b4c61717b25c757d8ca1f320101641732872542748d8d4c11ebd0144e2de9d39daca1e06062a9cada8cd61e4b8efba1a89a2762cd513ac761f90279bc73710e338a8e0cb80c9a1d9bf772748f9eb189efa4735796c44c984314e1014773ec41f4942a9c2d040c1469801af4140b37b1719e83168ffc39dc911eabfa6e270e03616e43d5e401a8670ed2ad10ec6a24e5de296524c527146da83368590d334d39b4a77ae39c7915168d178f104c6b44c963cd537706a5173ff2802fc8455d10552220e0bb709c222991d6383661fc09baa8470bc00df19d4a06f44234a80f79061cc119159405236547d4d52297bc3e26ab0c69824a809653fc8203b9e41ae08837d237ffe8ccd847fbb902fc2b1455c1f88c3d911ab1744e6579ee0719f41c6791899c56c3ba3f958443a26dc34d296fc62dc277510f3f448a0b538d140ba7b9e61b1d595dbdc815875e4ac26e61dffbde83c9789daae2793912ec521132bdfc031f097f6911115a1db276fe566d7a263852f02dfc3ed5fff9ee849f9320b0f72927860294d31db75e1ab7ca68910c51f6491283b065752c016925bd27d16e3a9cda63274178f5ef2bea77ac17db5cf1901cd59299190b8cad8a7e226c37eb52ffe059fc974594026d3796ba3c945aea6083f71eed55087991bdcc34a2fc85f0744e493526b2ff6e41363d13ae9c043a41157a2c93cb6f13396710c5c39cf21be39d801e51c282bcaad527672e12025da61adb7d6f62b3e8363d95e00097dfaaba367f0580436dcaef8538eb05cffaa3b0ec779d330af3938534c8a0538b9ee46a9e8d6768bca58593683fc3082dfb3cca6f39f3dd1d821e478f10b1bdc0b25938e684808e3cf786a34b1682a1f84c8f1878422eea84d913444a4c064e1f6e53dd988ca956521f598cc29ba8cc04f41929f6f991c4d174c11da6660391b2fc4178e59fca342231d2fcc74466ac2fdab7be9d123f468ab7d2fe73c470ea3ae1db79fe9e6b91dcc761b9257ba30b2a4b6b2fd8f6af681011c6ba6a7e85b1ad414065eaa074084ab469aae775c0b720a7386b5dc502d4844c303e5189398801709e15c2e2836068fb5505e1442b2611ae90388cbde52002b06fd17476a8720a753ca3e0fd49548dd9daff7b5ef38d71a1cf9c0ac0ec5055c1eacdd5c979296d9d33c73ad653883310a88c6431061d42a51fe7b4a8cfe8e97ca7d2a610b8240e105e691aaadabb4fe7a7043418116446b1af31c904e4c7188f2e9e567354860cf32b61ea57e008b1b281b6e1575d252b45113ba69e0cd13c02ad05514b5e354640d1202a4cb7ac7494415c8535612db79fb769d9b974f6417767ac9c27091e006b8854aef337191c85b86a2b15508080e9f5c95595c5f85e889acb66216737286d2f88731d02bacedd75f11c6edc34993d0b66108617c031ee2202b87de8a7d382ca475f73de1dbcd0c362ff14703e7202b274b1ca9b09570da2376912d0266f7718a47e0066da4b0bda343f3bd523fbb463d9b863431b00dc0e3aa5a4c074f8bee0b5caf83468e497f7ce36b2439dd040c5ceae01652cba6fe1fa343a37df77c454d731d56500e3e3793670651773f7e63b139dff09613d6ebe0d1774a74f6f17f8feaa32dc4a72cb81c92666dd73a6bb2a6e2c4bb1fcf025c8c36c38ad0893b262e1d0ccc4fed5359ef880f336487ef74433a40fc4cc71e699cde1283c964b91f4df08b86a73a8380dcdf1ad08d8a97d72decee08c6b2aa7c11506b42cfd99ba25f552effea3b50b46a941a9b2977af2469f8e5bd7b71f0b07d9d71bcfea52d1b2b6339715718e35fa35786b2fad8f9a5471353ec1de64aa610f72990c02245b548874e722c4c944033971503116cc1fc8fef75bb1a2e4908793f005f3545ea60e4e84f99939c785a38e2fdc705a5ac847bcc07400d99dc160d06d0e05d7c4ae24f8b9a29915f8769360c8464726dec993929f3bd598b26fd0e17141cce888b0b3b4b4cf8bbbab9b5346a6347277bbfb164b2a89ea3325dd771300d435d54510e6c4cb6018a7cd3547af5933d4a4bd7a055f463d518a3dc6ddf0ca4fecc3d22dfcf558cd950470c7b2308c79da80fd8baa5f8fd086d85bf8f49c1a33935746a128aaab61a02747fa4bd6120a36bc217e5a18be143a96e6b612a972c8da88d19ada17d0290ccb2504d4cf84569f247b7edde9980b9dd69a80482f731508ac64801a38fd8b3cb5bcd510fa44c3c0a9450910afac58033c0fa1ab92367e5ec836859906ffb76f792511b0f3c725b574afa229b144f9d11ba76387c25b6fd9dfdb1019b78aa5fefdbc47fbb99f3c95de3eb29f21a8e7aa1a2f36bb86311ca5fb885f76334a54798358b97d99f6a3e5fc78a51c60d1527600d15b3dc0350da841e7fadbc4e68c448153d144b8e22b5d95c1ab2ba47f672579eed81e9454081b9dd0ad410db4b4b70d949862619bb822e4b7a0239583001c6306d58d6c6487983da7e5f777f1e7ec145dde645a9c25aef70e009f3711fc78067ff1a452eaa394606d3e845c178a736b68a7efee334edc256159be515ae3ef3fe0c70a7af7b063f816b5bb4137b21048812850db0600297bf11b21764a11c720f4b452031cdc8590332ffa7dbf8252534f9039480a047a9a7a153a2b4f4b4d5f6adebe19de73e93993e40cdb5594df235619983e92b66754ac0b688e6544272e84772931f9f00fe94654335f01eb5c374867efebd1e427fcfbfd844c65e2b12bc00f9ec9ba724339db5c56f2e79d3f8ff30c86f2a3723b04856fc9cdc4ecb118f074922647c6bcedc045c6f523ae09fd831db447f6ae8e4e3efae595b87af5ce0fce6be508a836198d8283159e31be478d1ace22c45a7ce1d345e443c2b17627f59e6be3943a2a5fee3b238008d375e34e6fde32fe04d11aacd52dd1b1dd0d7776e3f06f3c9a747d2fce27e51320e5552160c0e8425dc75c16f9e6a1f652c326306ca4da034e91a3eead352643b402015b507a42c392d169c2f9f732b07699bb201a9c294155de5edd3324347c486e0f08faa5240addd0d90d10c32f558f7e8963c14bb574d134671a938a58a3e41cec547478d90abb230a6f375868b41c0b8467fd64ca9d67380fe472f466147c9993d14e5ef2b173811a069e0968dd13ccf4f3163ff5d8ddc85504c69fbb80b3d4626152dbd5b2d28e03761964736ea660b455f5f6e05137cb2025e6ee558de0154bc1ed116022be7a1df901595341c3f1bac4c0d66fb94056665b2cd1ecad27760194699a7b301e651a62b339525fa78f975ea6c67f413f1a36359e2131348d7c66ccb6e284aa3f4b766812adaca0ce6e8923efc01e478c73b4c79a28787cf4e8dad9a6cb5542c46e4f608748fa8992ed67e89b4414e354bd4f35c0f61b9108f2c9c983c2be78e8e6036a1cce58b597cca0928b7cfc244b74801ec0a845d810d3a3f6613ff9b11687483926def8732e84e9a4b5444145e6d0d1d86b4c59c32a2662a9a4d97ca9aca32a79223553325b2f210ca08fcfb60f61477a34436ba631e99400c5405452d58f3c08d0c01642ca7d78c748dbd8d59c41f4293266f7a50838a5d422421252b2ebd3732270701fab67a8a577721fd91343beb34c376aae9dfe9b345e2f7dd5dbbf68443131a277c8266395b66caeeac6d6fc689bd7da3f0f1337a72e11052a7a6e5f5190e89a0080410463603ecf04c3dd51f941605d31058c73fcefe07dcb307e5be6dfe9a100fc76139968296022587569bd1435b6d4ec00bc418a47e8ed70b2a1b1dee1142cfdcb20055c6ce0cd220e5cc5fffca99ec847f92b66bdf815da9ea912541d257982891cd5bc16bb964977e933478fdb80969ad4f4e294a4b2b04e06c8eee0e67aa489ec37ad603a0504a3ef67033770ee0fe763f3147147880083157c7ffbf56dc08b69400baea32d72461aac272ea0380dbb9911def8280d4e9286f4d5f2ab7f6afdfd230f9f9418109b93a82e89418c9350e0c971810f33fbe89b109c52ac730cc272cda5e7a9db2e531b68d39225cde48fd4e2c9682b45a488de02c91a18eed236856db88f6653d4a210831dc3a385eb8a4f6ab28ef6f16db6a65c1d07cee0bfe0eb9a5fb5b7dc0f5d7534a538298c37e722982c57927d7b326cccddc5ddc0e502199418ee9b3b89adfe48e25dc698f0ccdc2f72ceae23795fdbce9b71b8635981129acc327109b05c4be869adb2065a7d08df6210da3203be09bdd951edb92fbf9b11e8240a77c378a3b849c93ecac2807facd74bbca88a0fb11f61ac32e4157706951fcf5c1d57f0680e879f26d1158d12738c3e1826c0ba33cb686f4242e89ba2291bf32cf9484e73c74af3c05522295b5645e536842fe017d6802bbd213f6dc56f2263b0c4b1854e9476296af9757de2497b3f670d8f81782d831020d05c1bcde9bb983b5cbbfad5eaca1633e88632a90dc5cf7eba28ec5e30d6ff22f494a364115dd2eca4ea35c9936e746df050f5fda1be76dda1c24460b7e7b4b965b01d93f2eae040601a6fd4f2f821f682b275aa4de402ba6fac20832c32ba2e30357c14e6f9657a72f3ddaa1f9e40e948cceb9b20f36fb2a8e93904d603099973fa7c1fb69a80e92b52e2dd22b80632df7ef91f844f99f6af2782fd1da6e6f024069d073d11c7d63873cd9e39c7bca1da177b07172f3df6e227c32422312bcd93e1770ac7f19029c8db842f926456ed6603e20163634bbbb140023695465b0037b527c8f0369274fb2c0cd434c059e7113a771f8bba547e9c7ee5e9f89c3c404123fbf4eb3b49255e211350a1c990f1c627779f3c1ba325b384f1015986cb28a7382635affc93b9c70b40082ac57b86e78cee682147c84c033d4939f517053b8af21fb7d204847a9366bbf1530c7276f0d4daf7409d6d791fab923d3272b11f0f58ba2eb6405f7d5a9eae624a89149aba19e4b8c321abf162ea004a6b5a3c9f446f37dbeb0b59eee18b3bd39454ed84a893fbf79afb5ea572f913118f1716a57544e6d90c23adbb0cecb1825d4fd9a7479b8aee5a6505a416cfad999c31acebb7b8b745fa0b64b7d4b5d3555ef179fe73c7d21c5cd522a7bf52a8c8406f31623b4be490ea1d5fb569b0d77fe79c3eff173528ad29e62de09858468fe064400d9e51d0325e1c06770fb6b1bc112e2455353e066c4d4d5239ef1ff2f77c6f63122c9f50712eff68c077be9ca534f12b7a0a25607edc6eb14308a0c1db6550ec8e351b94ad4d8d1ea72ccbff12a0521163d8b77b1766337c6cfe042fdd3a2e2b000a691387466042ddcbe8f001a5fc8f2567836850c43282ede9fb94ceeb249d5bf3f0ac055b71bc477e854ee7e210f6a5dda6008c551c3278269a8c695b38f05c2b0f54bb3e8e27f35a0ea22ce8f39b00a63c98617c1963459449d081e32a8bdad82a5246f2fbbdc14c091f741fa102db91642cd00b1e7ab6d7b3db203729159d0d9f3db56a7ad666bdf99f4ed906de0da68900d3df79c676bc6601ed85725194b0add39a4b03901a6e43aec2de3639419c3752d21fbb029b93667fa8a0a68ffc7cd2f4c454f0825818edaa63c26df4c7a62cb91e86925a5734985ec430fc4308bcf48b3165c8f110f25f0d5f3bdc5914f8edd5f5720841dac988c0ff23fcbc98f0b4ddbfded109307ce8b4ca49dca2e9549002625292789efc6b5cae9924b54aa3c034fd8543af85a1795174935628e1dbe00abefd36741433821c56ee3821a3209ec86c1421e07aaa8b0e177ec8a4b9362d3ee113c331d3761b687d6dedda25b46558f181fbb1afb48416642576a4cdecafc5cfc581461302ebf90203ef1c13b20abfa21c8eff397e7f804fbe4c6a3a2c9ef62b4d2d1ba77fecd04c00a3bb3cd7d34f5c34c8665e534c03a7e89bd1e991a425c78c3b96204e14e7504c7b18ee3f6b8e5aa38adc08529f9d787ba45d7ee229993da51da49f623f622fb332da3df45941b4dbb5d667007706d548c4d1eec64ab9fd56d2f5748ed5c137bd957ba767d85a688c1f4c773233b080fd4e17b30001b2175391d804e640151e4ff0f862eef2a6362f7da6a4bba7ffea2e32a183ffe699e5dc693881afdd81bd6a7053b09203a102e7c1da4f6cd847f2722dc9e7c9262b55e9b4d37041ec9cff4513d4b9a59f4ed7005f02022da68da07ae399b976a9c890ded8fbd7676bc52bc6104bd69d84ced94a67510529221354bfd5580888d575cf4b4714ea37fbdc31b8ccb2730836e04110429e1fbda2123cb53644e0b50952c30ae7c95ffda37d8ddfbba7b421dc8872db1b9b11c106ab4c6ce341ab1ee6ddfa17bd76b8e4998a8b348736329caec89b062e94fed7f2984b0ed2acf765c4e859419fc5d229a7bcc85026eb1246b346f34689f2838d43592598b70e75b2df9c24f07200eea9474fe59c60c31ac6613b6fe2d89e105ece4fdd26ebcb9007b137bd293f25a9b001117206c213b72e5d270ad7fa8f49cebd3c02337f48e28b534db6804fa07f87ea19d403cc122486f584e3d0aef188d6f171bf749fb52d1dd4696ffd1f131e1e8e301d7d4e13213943d3458819df00dc192baa119a3cd34704b9a32afaf6e70ce04af6e52674b9a1cbdf06a6959a50d32dc042d02e6bfacc2707d1cfcf251dc13d735ab7a1173d67635eefeb73d30578339c5e5e7b059272f5e66f6359fdc0a89d20f43d46ad4757a314b85be780a30600d34ed34eb802bf0ec53d5ca2f77c2eee020a758efea095342a0109c6dfec97e0551fa14eef543e4d300a47a8faded46990afedefc8ce823bcfa4a9c72b0493c901fa58d6c2e3165901aee7786403f0dcad7fb4c584c49f2b7cc1dca26b3981182f23615d9bd04044a44058a443334f5c411ffb6999d1bced7e37d117bfbad79855f33c327c62b84af86a0973d64553ad057c8d42a8111dd0141b0f47d3de3ab73c5588908da230c61792fff961e1d5c8b2dcd989374cc1fce2cdf92ebd786bcd23491c79483bb03e65908e90560e0ad5be3dc510bb88b0c4a63619dcba6c3b3a26f13dc84aafb0fc5c9cbfd5c9a6f3116bfa5ef31e1194b893362be290eacb4f05d82710798361ef5ff2bb03edaec9ae9e25c7f09dc7c2980bfff69ffbf6094936fa40eb3fb368d6a08a7bef373bd560a8f217ca10b50e1b937ab047aeb3059823721f64b655ac0be45bebfe48cdb4d53eb5173969850df673cb38e4badb8b322a55c64c4213d461f60bb0454dee7661c8f4ac0b2cfe23d1c84c4ae30d6a3ed5381f0beb2f09852122ff556f35daa108014498631033196f8cdc8a794a983785629b5e256141dfb1ee8340c70796aa11d226ad5b688a20a550d44335c5be2119f04297cd6fc56d459212bc37aad8b50cd509fc98c3f7d57e1cf5b4cccfdfafda09fa671c11bb60f671b7e5de2791415b5a3f3fd4ed14b5eda4b656912452ba8aaad1390a0742dcb3ef2a03e9064dcce792989065e0bff99f8bc68a7cfbd446f563bafe4b88cf807d7d4b6b042661c9488a82b9051735973669b6da2b5042e5712df0647b6be57d6a92612a93443b19c1f71a682f4929b77cc90dbfa6866d6d061eb08ffa135c1cebab745eea6568aeba2a29e2f7628dc2c5f16ea097c40f523e022d32883c1014809b211df0cd81c2636b101b6a3840227cddc99aabd862b1a4e7943270f17132af22c0991b48fc2bc9ba4583d10d0d7e149f027753ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
