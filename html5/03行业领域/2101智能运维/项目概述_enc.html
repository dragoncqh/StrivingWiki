<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ac18e382c9adfd80edac79bf8873c11ff6b420b98be709661a45e1b559384a1b95549291008bf007fcd120354f6ca1782fbd96a72cbeb1d2e38fb8042ab73f4b60514cc1de5e93662845f1ceac004010298e8d4da97c14365ce18b49e4464017ca5ea726240f2891be8f285a599e2f741178c0e1406778ba725e72bec12294d4996605d2d35b33e3e47ba6d444372a6399ea73b215da71348c12d2e96b19d088f1801a1931bfd5f3473bcde10b93a276b1830fc1813d0b4f4c2a61b86ba14e7da120f334e6e52cdf5f2924ec10e9851ff4b226c9996ac1e0c548cc7de3cbce68c683859ba861554be64d458a49aee1cd7911f51689466febc8a50424c6b679e59a85d9f6111b2fa1f728e09df54577561d268c377b09472914061ed69f541ebd26fa93032313007c551d4a248853bea0dba146b96ac1f1760ec039ca5c6de3b132b63341e6c03eb2ddfd2d98689f9c78ddd7ed91c68edfd08d4cd5c50e1749dd6ec4dbae037e39d5cb5b93c56205f2be765b674b584a30c03b5bc18e7555bd50021d6ac4d33ea47a688b01b0e8ced4e0e71ec0e0f95a060169c71b5ee54428d97263fa802c0a57c51572ddcfb1804b984b4776f68900add547cbb9c956c1988c51b7e4eacdfeb0214ee38774d837ecacc98e0adda2604876f1205636aabf42c646205c52d3e628eec7edfcb4b1370c560881c11fa377718676d7889ea8abe8cbb9c2deac22ef82adfa2c601d1721b0e03528bcee22bde360f9d6a9065a6d79be257f42d675a38e6b1399309cbf79bc0b24a2312b5e4c95c7f91abfe5eafc631bd9775c38923bc20d788b52ea9debc73b7a6340a6b4c8eb3781b77e6e0db5cae39aadfbd5ee10eb80068e126c428159f3e3e6742c06eaf34f666a203defeb89e0cdada742312abef04926c1d61cabf1bc2620f352b8c5f50988938f1b2aebb76d1304235f57962343ed5c1a9132ae5a0d12efee5081b372a68822168aa223b8ddbdcea68286729f979baf4b94920a02049da0079e0ccd2ff3a1f222ee1c70d981e5fbc52769db6fe7721ca453a4f765bdc42b3c443a3c546a0491cf51cbdfae432a90eacc9da484654908f0d990c86e61d0b738b443c518016f52b1ea931ff932867bc16f9f5b2e376e3c9396a922135b346ca1371581afaee9728933468cca953ffbafce6f916d303fd2263cf65a0797529826ed32f63e002926476319537ba364d2bb33e83b63fda442d8b4e81a9c5a25e4ef6188b191c19a95f822c914ce581da4912172a3e5d8920f9fdb07df549ff7605440c8f2d9a20c4658edbeecef79254735dd4b50e037489e2b6bc65d5cd6df7e7ff02279c4dfdab118c1d4648d71550c1de5e4b6bb6413275403780ac2fb99be019e78935fddb73c10af9f6fdb24be8566b8898afb06c83b04df77eee4824076bf14f8f0b4745990c77911ddf4ccb5dd9db4dd3788e6db9aa1858f962be7d31f792c10686a9f9ac5191f6f88c0ed5c1f69e56d61f5400b23551d333c191099d50a14c84791349acfab049de462b705e56d39f176af6c47e65f17ff9cdc47769dc71748020909179390ee28f2e46c61b5e10a35b5846154263bf8f19565e346e7d0d65a5ebb9e2a1da0c78e74702e23e1b1693480f07306a245e971ab3355de903f6329d48d91ba090046bc19aa5015b490e494931cef685da20c45853354210faf02479873d28ffd144987f5e2c5cbffd4a7d0a806360408fecf63a78753f6c872a24f316624f57e45163fb2bcc226ec163b889897f2017521711ef776e010c3b26005c029218eec3200923bcbc71e88a31bc1e1cbc9e4871eee6695ede53369e77b72b8e66cbb8e9adca1dd647384a07f8cdac940b5347aa157ce65a2e34520ec0fb545e3a806a41a413e279abfc96e846cdc2dc74a34e3f8d16c9488e8ad8f03f93652cbf500c345f06a7451fea92b7cf7e80b6ad2c612bbfed29625b2d89777db1c6b54049b87843d475c56f25c5319ebc9a4877614299873496e02394b97aab7677b66fe2ae064594817bbad83c8444d5b355183924f961b5299b398ce2db18362cc014e47cd7764fbad80cdd7c63299e1725e8e15833e7f720c9f780613d4c6561eb7ce9ab3f981d071d49b26e8804f581ec33492470fc67e0274c526d6cc2bbb885cb47a71989f8369bc9c249953cd688023a65a5b9af816c1fb5d035d04671a2e290067a376baaa28b63072092fdc9a4f57595cdadb1ca07239f8e44c434e61efabf88fd8625736f155e3e103d82461b589e1ecdb505e55426fc4a256a7db469c8b71f013853e45771fec4f63dd0ebc7f2584b178debdddf2205f410239fd58c85b639b5c15e844bfe8dc9644870e29713628f49301afbc30dd81c1f6303171fd116be26d81e0cce0cb6794a1ffc7db398e5932efbec8f510a3dfb79bea15b5a8b0b447c22b02f902efc40bc09b696ca6b5309d7f29fcb59a76a1d413ef1a06615a404f51c8e78b5b50bd5cb80e8ec04e3503ba857d10daccb6a6cb0cf752d9458a2bc2fafc6d6efabc0a37f5254334d84c81eecdc8ecadbcfdd546ac39814a8fb461b3dd1e2c5dc4dafad491c33264c09f865c8568b6539094c580099de7be0816646ac578f3813697bae976392c42db005ae88053a5d822b41376b72ac939940691e9ddb8e4846c23118853aa9a8eb959a22b728161af20e25d5789c49aff9d8ba72eef072f7eda3392c6370e4ea4d7462be5dc9ab3fd155d9fd114d316585bb2f8c0090f28b1a0406e3b06a9e4d4affcc0d7f00a3cdc077a75c3a3c393c90cd6324546c08297ce60fd6b1dc9f18151d819b21eff9a52e63d3e87d1f72c87872f445ff98f6aa7645b64c9d79e30e28004e6b208594f50b13ed0586253b954a3fc7769b55db23ea488f25eb6262b7f5553f6d5beb94dcf884b236e9282d2289368c65badeb864ed334a2134c9e42a1cce71c6bcaa468993f13672c6ce9a306b82019f724efec8e1c587560d8d134397aa89e462c98c8a8031a169bf73e9269b5f4a31598024f6f4f407e5db89441554858e163831b6a7339f946b578927096e6b18c83c2736d9f2c0d85033871969a59bd622cf2a6782ffad1b9208ea7d92c18f3340c24293d1fd449240698b134940d0232f5c1590b97a33d1d6eb18cd813626bfdb2dcaa44d127fe52f5d0a8e30d3d14d97e51c8242a0c4715392b1ef97da4c2c5c9fb95648f6e620747ea18b748186935775a16ba257e836e8b12c03c03befa6b6da1946a529742ecb613a1070f363ac9c85ab80d968d803be0534b81ed29db8239d52aa766e60190f6cf955c8f11fa8ee696cd3f5f4ccaf35e5abb6e2acb59ece22c0a9a4e422ddb2e5daec59ebf464c10c55dff0d418edb4ccc4f14c4a9562995ca5ba60aeb331ce0c7719c755c96da0a2604324bcb35371e4d201fa9b8afcd824fc4e283875834d9b298573ce43a19de4bd2ed83c9f9ad98840d853706b316b90e35e88210c957355b4a21f4644a8eebbd68aaee6055948c1bfe10f826dc5f52063f9e37538159006875a9d677af2d50200b768d09bf27de3d0907aa8b6165b162809ba81fe008a404509004d4e6d83e1af4b2487e326d2b508cac7d1437128d421dbd060bb679805c57a949a45e17626a511f1d77b78cc109a4f2b74813152ab35039d3d58fb710e539926277df1909bb923e0b3750efe21bae70e81894804582d372d43ae193281b453058e05d007a8bf58d5e3c33739008eecec781aabe5fa6033a36b0b12182bdef8b0478bc82f806585601ca35893ed0771237b8ede1682eb6068cf7443264c804a940ca7fb282d4678c95b26b3c75c6d919303fd7da1c2ecb7a5f28bc5c11644a8d453ae0a4972965f35b27eb8927eb618574b16c3f6d3b7fd16e26324c553d68a79de5a71d3ea0e3a4fd2e13c9306a200e6da2164358f59df6ba1be99c032aa2a2b8a1de4ef7415729884113581aaa950c436982a1a41ce123aa5fe29f8aeb0ba119ccbd0e87c485b73abde8401db5f6d9aca2fb9a070a8f6e2a73bb61cc257db7c5f6f970849390027562174e3b0f055c1ecc148d077f3fd9ca1c9b867fc7cdd9de846770020227f49dc8bf8f06e6d02a73f732aa4383711108062d511c9e7c886320a83cb4e81637c54a36fe68551484b7beed63d5582cf04c952c6cdaf4c6d041f9628f81503b4eea60b379a8cff33046fcf3a8b1a22bb1c071a04c1586124bf70a76eee96fb48c40dd960dd60e5a460fb13818006d4731db706677d33dab3ab088776027bfd7b752347725b7cbbf6f1de0ec9388142b90cca8928292493b6dae46ba0c346cec6df5643313d71d00b9943b9cb0dfb88a74d7b1f82769877efbd8cf834ae410cc114ab79282561b5e2c3d20b75d07d57a41d27fe065421abd93b2b2924d10581809c85edb743ee24aa8e50ea314a6abb475276cbeb42428adc11d55c3e41497cd529f9ca8eedbba93b9bf53889ba94a64b08dd5160ebd59a959151ccb999338c5272f7654b7c98b2e1740285f99e046199d4d885ac4e950ac5636f81295f231702462cff3575b50dfa2ffc98b76f4212028db80b81231d88c42e6c8ea001fc1a4bbf938ce916ae33ca1f0893663343bfd5bec8346e774ed527670c4702c4e426a42515c9cdac8b1fb4465d58982180ca2f32a3f1035b47954c70c8cf7916b804f54e20bae6bd5fe9c8071c8882148c250e0bcb55877d7d259ce2cddf70e22ed9f1cb08d727d47aaa7386b611b1470c2213daf4416173cb695ebd4fcc4c242c546f340a2dc667a0b6139eb00c3d63f9d150dfcb011d6ee81ea3702dacf8dc0b99b761920523123d9cbdc0eec7becf1762d9d38eb9ab344175e2c109fef09264c172a446fabea014cbe234d52ad16ae09fc77a1e852e5b706984a0f291075181dc86fafae6fbc1b622fb4b7f02a776dac0cc5efc8373d4e35b953696dfc4bdbbc773226dcc0dadb2e1f298cae4b28a94a3a3a677c15bc3076f4efb23934fae3e0e913c6e5905f657396ab9f6a7995f4bec96decee8416dd8056bdf6516478d2de69838b07e1adf2c894eadd60dfd1d06c717b31969cb520927f4e83929bb67f26403ae8590e37319d17688dd8289a71de94c9ad8d4ec766877ede9e4933252052e5dbe39e40afd5a540c4f22eb1905cda54d8a1101542fd67b111d89bbc6f3b4ced6553bb555555234e7dcb6a6141686ac2c7791328cd4db54d8d3ed87e9687a5ea6ede01a5d8d5a214750d93500ebb6e3609167c0d938e800020deb0c7da4ecad47bd254033354381f1eae1d3f2eab3da77c138da2a181ca7cfba57c63f9aa15b3372a4c4957137af0502a000dabc9269adaed67d3b80bc803f50ddc043fb22d059b668819333513a6b7e25ec115b556c59265f28ec3bb858cf7b551ddae4ad3bdabc4371ac8562385eb3d0f132d026ff80ff20dcb7e251acf50302d96fa30c28824d131f8efd8d70928300d9322b47222ad1fbb489e4dcfbe4b0672d05b3801d6e29d3ead4e4be80c6690775675aea1192350a20844aa4178e27755c0297310506237a408020442f620cc9202f870f4e2ffd2a0a9936f60e84bb75f7fde0c781704e13cf83e403a69bc7b6abe4428256c22d5211249c3442599d2ab47a3493416711259b6d88cc968107ea2be7b10bddf912f9a36ada52d7ebb03b026d84930edad4036f3cc4d51eee172f07747ee18515beeab713089063d26df83681530aad047f4ee0377f446d7e76d135beddfb0ba68ac566dcd638702577076b317b30500cfa91dc1db5a96266c64b5e9c2b617454ad6092ee6ca42e13abe6c72d31905f41c6de1868fabd8a6586fea5a50946a108a5be020750c7d21fb19cb534a94a6bf7bf9270ac6d8402af1a02477df21f651b34f50f17fce9d9f293aca4c4dcf4fb68e505b949b658e3e1122ad894a3dad8a737c9ddbe950da56d255d9aee69c05a27417c499e4cbbb1f269703d90626c7686654957991b4a02106f5de205f49f6214a2fc1e6e90993d29af858e9f226ce4e219f47a2c75dbc858c526b08ccb0ee7e45488b417cceccb82fcb356cd885dfe8b92814b12330cc1ffa8e4dd0bed6c4532d3c1dc5897ce64d2ef74cd02def463a1c1db9fa97dfcae50eda40b17718d7096dd0e053fc808d14b7edad4a1ad884ee7d9ffcf31e2f6462f6dfbdb9a55269618d28f37a3b0e185a166c3ea7dbafc0476191c93f2438c5a803a3f6a58e28cfbb175e960dc9739333d114b0df5e431d236f86f8c7ec34ceab896028fb0f5963bebdbf3ffa43234e30546761e93404b5d696d0a1708ec96b6f73201316d7c4b251c485240411e39a6870a6ae9b50e03405cf64108444776a796258e52c315a5e436522440be99f46b9f0cbeab5575bec4ad5a82ca54b667af19e9694d33ddded38628852512385fff2ff184b026f0157455469c14a7bfde074cbb64d6c2df74b1cf7e0ee090f3a28be946cc95f2443ea682b8b1768f10324d04cd8de9e05081361d4f02965201a8fe7afa0be8dc7f9c2c7c80c578adcfe1da969d8b8975c6b81ca24440b18424d5d2b1ca2e81cb4c51a7df134e371f7fd2814695dd66f611f86efc49b758846399a627e7b93e8f0ee9cc4221d581d3e168dc905ff42c909ac4e5b6fdedadaf4773965bc9100b834f9ce7b67c394af3a487e1e92117230d22cc682b23c9945d7c124551f82a57be6184d8a6d0550012b175eea03994d08dc65016fa64431ad5f346dd1e3729ff10059e5e77ba0488f288aa1da0cec0aa178f7f4b7b577727bb5b9f72354fbb9b1da9089182ceb220eabd1478eb6cdebac48b3d13f01886b7a536649ec36c0cb55513758991cfd2b3e1010ad2967087c57dbbda0fe1d58e2413a1d11cae7ed98ab49b62678baacc124e5a73058e7e918da552f712654e3ef32a4949565e713e802c90a495abf50ccd038292e93e9cade15829f196521451e1fa631384016b7eaed2b7e5799db167b41be401def4df6551a2c45b9b84f92873acbc1d538bec967ac19f947e498f6109d15fe3e59ecd5145d72f5ae929c499246234a0348ed4e0a7d544f02fbcd76eccc0dd69527845d88926f1e6a6f9520aba58d4328c6a03f66d1e3728412c373db843d544f86274ab5d5edda7ea2bcadb26e8d2ee7b2f970ad27fd8626c30026968c8b9aff4928df802615eb84bf90ef141b566d3b13d553fdc67964a573f33a9c3396dfaa768adb29c26b60b2e6a5578449a199a6cd5fbbcc99afc4f8a580b91399e337f24e2707ab1481f5af8820d80e5c3a9db1c367b84550baa64cb18d650b27a731cde59b1cc172810a23d4429948c845dba4af0a26fe1254b8ccf8703e057679f574d8eb5727022505069e92a292a18b9f4ce94bbbffe864e7a2be2964f87144ad1a842828b8313d46d81b703f46e681e2d399e5a7634020ba7db2b342c9fdcbe66fac19bd45a352ea5f6db404c2b4d15813d75f13563e7c3a5addc20758748bd1f65dd9b8cd2bd98d51dbf9c69520650fc2449b15d3c5db56721cdfff6583ab0c8e64ae2f2976100ac14d652ef9365d7d9db509a9cf1e4397b185e4e2c7d8264a0f5ef5e60a76cbc53a2a42b2ecfdedf4d8f9e07ebc70d20c492f0e11fe35d67d3d2422130a3b56f71747198ba056a41b71a1b1a3ffeece97dcf6ff4167178c939a614e3c6250df969051088aeb75be60dea166c024dcb7baac293ab5fb7ea1afcdaa308f7e0b5d9cccdffc524af3ac45035510b3d5ff756f70b08e253d81eb06ff8ca783f5fd2ff96500f293998f7f9c677ff3ea5817f532d65b636a4bbefca6dcfb465c14f199ff9db4dbef54ac1bc4c5667a093dde80077d4cea31b4512436ffb6f3e6505c2fd03eb6beb94561cbeb36d6bcf55cf6d527e4479dafdce2b04dd3fb062647d69431be4ddf9a5cd372745bed2f58ded0f7ae245388dc164c659e2d049c8dc4161a1850ed21262d743923090790ab79e1127330c7d4d935d6f3cdf28bf4120a21977e56401ed95196b87aa5d980512f6564f0fd2c87f0a44ed524541f2ce498270db2d878e56bee721153c0935cb214c7561c5219ba2d67a5a2f1a78af4882d0129e367c17a57e345dae696e5079bb776a9b90148cb6c84006f388fd073070b93988e727c6a0101d2d06aead8d23e3cf473cca06fee602fa92ddcfbc5d68b60a8baebe91286540761b6b6c0d8b49fefa6a543d3a77525998aef6f018128b768d70696c1e1067156403389d5255b3517bed81c34668dee0abf8bbf349ca6bce2f92117cdd00c1184e2dc6fd6900771a2507c1b45ec13c25e0c020a9330f573795f9b4f56c12b5886c61c5e3e4b442410f4fa2bd2eca06e945bf44301ddc1cfe3437ef2518676ac2e21e5a784980c32b10b725966e1c079bd1fba4c18f4b3a988bb31383ee34bfa7976d74f1bd776170dc19afaa74037fe0d731b7e869b52194512b275ff25d316758b6d4cb158b76ffd8378b8a93423fc3965dbc8205144429a29c2c2c6b6702ae6a0783a98e3b1535439dc886da2bac1c6c0c9829086be36272b18c0457d1bf5cde22ce2513ea319836db74c595fd06705c72edb6f28ee16f66534d4b26b287f3aef49797e520f0fd37ca08df772a78cfa6408268d41119f9a0d95fdb8dca8d464b9a99d925953b6e33454a86b0395e1649ff1995e0bcdc5e0104ef837ae267565ba166e8544565dddc4d5626f7399f77f38c30336f832196be846b41b0c4b6bfded9a6dd28fd24d031046b75d21b584d2c2208d0fb3bcd8df16562b19dfd06efc12834e6f41e2dd97930849cf859028d492a60b4048bc481d15c5d87ca1a458011fd9a4a2b30fb05c0078845f0fa76c3df16bbc9656bd8592fe21ce8cb4af182f6a4441669619923c2cd69dc137cdd186578a9e13de4f93d493fc11631639a94abf88c8de4824be4674bcad81e681c7b5f641a7c7599d657f2b239e46add53053660fbf8e9c7352eeb968cd1d3f8dc740f7b8074206fad38a12da9cda17d0a5f7bbe266595aec9784a4bc3a62a9f08e5e3a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
