<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0947821e3371d195d1c41b914c179fabb36920760a3dc83c678cc8e876dd5626dae2d4c5e0a75c94d01b3a05022a3adb4682db0089c5ed9130f507d6ffd5ed468b69c710c5a43c05c95ea5a1d99cff5822db5e3b403355f53ff8c46e75620e63bdfb90022568ea781ddd372d246e05ec2a91244c1ffef5a6df9a0ec81414555346ee2678ea71cc9ab42f0e9951c1d02791e61e24bb9fff012145b48cfebcc7b0e5189f2ea619b0ec17a71670e8a1df95de122b3086c4068dab59ebcaf1a75e49c9e70eb4312e8dd823f1ae5fc47f336aab37b529eda4a6d5fb73ba0ac5ac95228a9aa42c0f92e8424543b8f7d7b0f35eec696e2a670014547dcd17d19841b0017f4375e4b76db91e07e89051c7d96bade3e05675eeb4c28a724081320bc49e09edc1b1a89fad3e878355c428378c2c3d57f01d8d92f90e5577a31f568f300aa7fee113788fdcf8b1231d35a43df94dc3317f2a28acd3349c177f1ac2c415b2652cb88ca81c4265fde93cba3bef482ac7cfce9cd7f38107c1406ffd55e62b12e2bb168f0fd2c7151d8ae82a6f0fda14902f7caaded60f733d3c9e6ae873b7ddff1d4cdf5013e43b65a2c3ae6a7624feb21569a7f7444d24a0c388e31a65c50965a5fd4b9583e0c9bc424473147b5d4df66a45fa6bff1dbe43190ba06aeff56188ff0c90e80fdb2178e0d0af6c591eb898d70d1bb6c512e6c0167dfced1c02a1e38fa828105836b957d4bdb232c922eec6a33084cb428cea5ef1e9119647b393e64bfb10a7084cc75d166c5765a17ea09b6e0063dc74ac1dbc0242172062800f20d0c7406edef61c912ba20603757139062f0243dc9996e0590576b4814e3f86bd0a7eaabc7cec89f2284bd252b225f2c20e53b37ab695d6e2166e4b19a4589ccea2304c119fff48ce302e8472ca36d6e9b5c9cdf22e6c88eab1dacfcde1083ded7fbaf1ebaaf0e2d666c6c974f3c0006a298f9d1ebc545f982e35e852725eb5e06508e81d6df8a7b5226620dab1adbc5e46b5fe1fd73b4ca4d0c78f7d8dc96bb6a05a1091671b6d5f99fec4dab8b99f536e3e220c363cd12992a454b7ca3e280407198774872f2c26d6e2c08d102bfbbc505fd2d29d0bac98372815e967f919c65e5a78236e0f1e20878859910f6c04919c7faeaee2917d04b2d2a88648b80c3f1291d14806feaa40a36985aee300a84e1d3586794cd15eab9f86ae409d9bf8f70c5f3953e42453909bd9412052f33aea154f1a92437ba865d99bb6e072bafadc215e5dd1e35ff88eb36c35a5dc98ed5598479791164259225c88be5170463eaa2e77b8d9656d1b71fe37b384f742fcd375cdb19411d7da34631fcfb5d45941a7dc0b974c13021ddc204fe6edc752875c3c790e4a08065170ea4404664b71869ba9bec7f72bfd5f22ccba4d572a5db5780abd6d51b969f2226d4e2769c463983f3b36d1b252ad172a044fff154096d30a2b1545da3a1481638f90f92e644f627ebef6e07378c9238e3c18c0d4e604149cee9a28eccc3d6d03d88cde390b96e5d159bf1b7c9b0369baf19ab4df3e6198b30663924549e1df90fcaac67c5128e4bbd082df699c811e93019f238ded7b5e4c4a00ea9d2232e7bff5cb06d677ef59094bfaea482f457d5b65dfaa8aafc4844c7e5e0f8977bcf2cf067bd792600aae8508b0505b2e83bd8d9f956a7dc4e8eb61cd00e1c0d1b27456f8e5476cef83f19e72a3a589b80f9de7ec113f023a42a232d6738cd9f847fd431e71b86b8108ded1f465b420a2b7f19502a2b5d6265a90eb9929761b3465c3d3b114d7c9d914b994cf30f5b9ce5fe82df3e9f66fe684ce32669113b15e2c7176139c21a8ab61c91c6de124fff1c864b437c236bf429e579a754dc11ac643b19c043ce52ff44711fd1d84ac485a78cf592b829cad0905f86663e114f51364174dd963c207844e183607bccc12ac942cb8c4cfb6bad0529ea9ea8cad989619a14e7e3a0c4a863d393d177f72a551146fb78d48db12d177b73febc931e2716aabda6918e93069d9919ff6d9943c4ad6a436afdfe95d7449f7aa8869cafa86f6208b6674335c04bfabbfc706df7bdd8b9d9a1e66203440c5036b877655abd16583c288761de84cba7eae727ac40b718d7a163e979bf0a114f7546abef8965da20144178ce1b4244212582659049fe5affa91924b125ffc24281c11238211f28a69e030b3ed1a4b09b8af83417ed432d44b0598d254cb7cbbab400c88bd544af5cf37e784e0ff9fa5e56c2488c2db6e1810fe1f077df4c9dc10c3111e36f136f2deff73d5c94cd9c7f599fa13b22cfa91d1be678bf601c21067ba976217ae9e4353595d37145ff23365cfcc6e631dd890661ed31f2de24ff80876397e5bfd97479bb2533aa2db5c29d50433d43224d3ed7a24b0641c12a8d572b5a55480edceb19933d848d6ce52e686d113b2412edb850237d53e128ca1bfeb563c3d5949a061bc35fce052b4cbfceab8e812b2b4a5734506298ebfc37a42a31d00cc9d53aa764b6a163d65b44422a71e2be9c907ce53a744cc9cf81002125a64dffc6f7b20f57101df5a0caf5f5b9a3d6f6ea545904d57008a1fd82a065949eec1273a2cc1a40c3e9b1b2bb42639127a034d5abc5ff32f2b54d52d3426a32aba4f821ba8add91d63b1b2388552eda41ff7974519bfbcb6dca6bb89ba2e5da622177d4e09fff084fbc0c4d0f770755749e415a8954b57057af95f10d0d3f55113c5dfad7e77af44f2aef5d628c6cd548886414c4ed206e8f1d44b388165c9c1eaace642652c48656052c3fa8f9ce531997ab6f247fdaccf1395ae97682405364455cfad9d010c0fe3ebd29b636e6ae5a455fb447d5c368432c645f768739bca2594476baf19e3f9577a0878f07685c501330351dc4ac34637d4d8183ebc7d2b564b7a0e555a2ee3db805aefa021dbefaba86b9336fe339e76f69d3e294397125007f32e21946d9eef84edde716a46b629a377e2ce14cffd8d0b3928ec580678e610a9806b0ccf2806a44875b49876ff6518cf066a90cf802bd2cf00502c50c8119517c3901a1a046410c40e8a9136545b1b21ac2d8f6aa967c1baee8f224d856ae9a50b8681a80a50d8eda767ea8330aebc4f706bca7a45335b3f428dd3e78cbf01e1981c502568c1a44f30c4ebd12100e11418d758390a7d4679b0287adf9f19e2273cf68af57c75b3bbb00b8f263e1214a5a30e335b9a693a1b83353e31a2e873d99d734430d9c898f241be1fae5b40c1b1c521b5ebec320fd360163c69c96265a10d44aa0037e113ddb0ccb2ab3239ee8043b89c66cfab87b1ba7d78f582121800122292968f8643dc067b66210d6a79a310496b70e1695c336891b6b966dce6da7d27be782404cdc40d182edd91d493c7217fa66b1e25d8bb25bc083005a181d50e31c1eadea9400449e8b6b6946f5c164c340793004fe64b974e71b7ff9a3d1ec7253c3673af6bfa3aea7672283ad192676776cb20c8441ca22c6960c3fc5f5835d4a53483c9702dfab4417f4bbbf2d807b1f04d4f22393324940a3470fe38309746a095e9818d94db0a5268115e00e785b3fd25f61eec3feddb04f18106d94e6011ab9f3b502ef4a368e8c1da49ff2e88a224e745e87a2a77894c573625c993a4c1049a95c9e3182e68ff92ac21baa7a0b8cd713832af043434701e16010cc36c13268052d476c95b7e14d87a616b8913d00d282480ca1df75e0dffe006479dec76cd63d8afdae4d3cc2d802fa649cfff600a62e22bdbef21b30a9c74354bb353d2190cbdf13116c38283e658c7545deaf51b0d3890974a3d7b95981cc763ed5953447871673208d01723dd23cdcff685b7498231525809158f81f9275a036e4d0811973ce58f1dd797b24eb3d8636cae9641695b0bfc1968b8ba7418cbd2ac5d6e2fac1726f15392f762a882f5f9288c8b0ce0ff2e3cd95886ff2b9d5641a57b196774db0fdfb7532a80b649fe0d00cb3e08ba0d73be8a7f4b82ac3fc7db6565b143726767fbfced8d7284ec73699f97921425168aaeea2cd459090b99dbfb6077587456da8bf87a58d4a8740c015b67e8487065cf3da4327cc2dcb1a9c2948811711b424164b8fd46cc855d6fcb8d9770062dd787569e3bae2e3a37eca7570c235658ba6362cc9290b69c33bce54c7599835a036ac8e8b7ad62f975749e0c09ef857cd0d7529a49ddd1ab3c9f781eba1dbf49d1e3c84d428eee6756440a7c82f6b2c122ceac32177e90a3491df1df6d1ab92b4a25ff0b725de37671fc9b69c9510844a6ca84903f22a39ba69f5f751e11d554508d7de9d16c7d52cf75d4446da0c818bcfcebaf3ce707784c10ed48f149a57f3ab19304f02a4f37158592b52507ce26dacfbf81ec48ca1868df77adfd29f45f8ee14b11699743552a327ce05992d28cdffcd34a96875d55c6b61ff2269b64e06b14c60d973c63b1768992fb2f8d1b882dc98d9ad8e252d41ff3ddecd0637dc9f82209af41a4e3513cbe8c09aa3b0aa0b4c32eca7db54f394ba828782ca4d2604480947dfedf2c87ee10f3bb15b5eb183d93e7c7ca6643d5195e2af62ba7b9830d4f27a192d6e22a7751a4b42921953d7a09ad27626b7b8b0995dd24dae5d258903fa6293f5d800ef85bcb868d0fb91584817105370f3a959ebc14da044d5d61cb74d22bb821b2ecb19eef1e8a04344a1b04bdee22cb3d826095690234a52c3c95b3df607710da885a37cd6653081166f79f327decb722bebcaddc6a5b4b94a2fc6c757fa996d53cf624a6039f3f13677043d965369df5c32cd661076006f31838c7ff0c8ed416d63e65fe00075b1bf310e500b0fa93a9c1c11565be5c916a3ddc740305feee07fcda2d897144159fea38a76d7105abb7d0fe867d59d8be1dda84f63b4a36257cc7bef0a1b644c87494b1db19522a5f4c872170b05833df2119cd519755f70d1dc468bc06e9a3b0ab113db0731a9c1c79e412ef1515d0e202e33dd3a23ed3f8904f5c50e7d72c560c019dcf8f19ec31ed7b9fff9f7f9c756ee6029040c4b0666b8336b01be370dbc89d390077a86052e688ddb2e39e535f92479aadd157b0a3178db4f1fc234b5b5d4a76510ac15b0b804c9ea41f4a00ea0b27dfa3942a6e747a2b45684dc1cc8c299ab3f916a2c9c388fc9028cef99b58eeec3ddbdf96fad071907d12d0d9ae520e14f5d66a40f7ddc8e006a0fceb8389e5981bad674ee2fb59982cce4c55ca4689903a72a1fd14e17bc89e2d565676204c571a7fd99f75b4d5a21fd3238ed2138094da53b208e8d2ebf8859cd542ec04de34f669e051509771700d9f111c7245edb3b8eaf3620f6cc8b07f9df3ea6e251e11240486bbba0674f9cd4d5c7b3b703753942e36b0260f80797cfc7410d687fdfd15532d42aba22e09cd37745412f22b66467e1cea9fd7c7720702fa2973df2137e88488fa0b6d610c8cdd01a4bbd5d6b8fec6c99c709fed65e3f15fd884beba2ea453a35b3a70a293a36c2b038ae9ee2f32376c7a1e619c57895da7a99fceba78e7110478ccb71f7b36b9a8e162de79ba7207bdac592eab44e33e652b218e4011a10e941593c3c34e51cd4c3cc52c42cae345d4370789dc46ff3a8e57683a3df7d8d07bb9640be06a21ed6bb54137c113034b771e48ac95ccde80d54d9969efa6ce4c81d002c45ea227dcee16bdd9eb995f9f05266b6f9bbc0d44383125604ed3801d7ccede0795def5b2c7559a3818d3221f7a6bcc42381660b28f6e3f08886b4c240be33daa3ef22e428475f1964a5e337ee62d281de24852b35044fb105224991e00403e7f35657827fa51cacf2fa895c4610e5cf998a89a77ac39d84e79ef8c857a8ccd75412f48d4133b271b2310922e3e8993591262e5125183868afe9eb133786b8aa16d02d040b64e7399df0a58446a674bd698a53dd69c396d2563e8fec3e496230706842711ebf7edd4043bf58f008ca20dbbab8641df8988b9840e27352057e2e5bf73ba715b27b1a505a5b4155bcd0a757a2aae837e9a62f6522734d1f74a453e16b41af7397ce6a4fd000d7ee0f9608351f3b3c0d9a578638600874a806bb415d83e2bfbd664b2c6d545fc32ee5acd0db06d2a26742ff29d502673e647cc3c57c82dc99d750d966fd096f717bc7f33464ab3ccceb54ec8ac5ac2640360cf7f5f7f5a73c8533f9eeaa90554ffaeec1a54850013397bd2b11daa113db29db64b6d3bb03b397ada1166aa47f112086f4453fa64200bbd1f858c33253b19bd84341dc7d48e7ac04df5655e0739529e0a6af14d6eeb215463a4f72bfb12cac809861cf4b2198fa31e45608ec07bf7ba64ed4376d4253ae7861214e9b5d8736fa5fef26353311855ec9eb55d0bc9b6855dab0ad18092a65e69d15d1ca28f103ee5163dd307b152501b483ea29d6a6d0a2a9ae6a3142f6d34eecd288004f6e1268f5b29a17be4b405ef70a865377e8ed9871329983bf00747fcc634f1d9cacffbb87bc7eb2044f4c440fa152e886218f3a16e099039a749af240ca7f1d4173a84e8f767570a4a969e8cda243765706826fabc117ce35798e401cecd7000614819b3c10671564ea8847f11a3597cbda959da393d0356046e526feda8c3c8d2c95d14582223701687c2c26a33f75c89b7e851cae9012254003c6a900b962fc33968da83b3a3dd21d83dc7032ab44897401a50f3eb111d89a6cd52458fc2140f0737ca4cfebd7b2c0678123612d68c7fb07a8ffc260115cf687dba7c4ebcbfc6e4143c63f962cde0854fe7168660c4836ec374cb4a8de7fd4cf30856ecad5cacb6dd047330e901447af0d1745289417c3bfa013904b6d08be4890df48709e3f6bb4f57408582005565ce33b5e35bdf41dbf6496d57f31c018ca3f4ecd4cf4b05da1d604c1223c4dcdef1c9d401ff3ba74deb816e24bfed1caab47d123ec23519b80d1ca684f412ad7b0642b90b4467d4d48a432cb6e7809c1a96c5c39ef630e4005a0f35640e33d04468949ead4af201437536b0ec1134034a3245727786e53d0a5137b59bec1da7f2249720dfd0e49e948718644bee1b7b629c5f74cdd8611a4c20045c08522ee6496072932a0070c202d924e3e837c14fc433022403bfcd1c5623ab862b63c984bb6f650fb8821d1e5ff2c07b25656338179f43f954938b7aa717a712755b45303c094807f142ce3ac9aae2a20cb536cb751c6daa06399c7cba604d9c46845b68f2b7ca56251ff9ba5fe58b03969e06d4b34fda030886043f1c36f3bc5e2374ac8db31c55386c4f3dc9dfa797e2fda4011f3dee503b51b2453aa3863f0e4e9bc8c94eb5a2156a07107388e33d199d94e517076d1fa969347192c7020d29643a2239a6816803fde8c178aefc18a10fc436ecbfa4fec7793690b8f67f8a096f3a9c797603b02873167058f20730cc5686cc7b9c11a09b9e036bde1f24aa50bb5a55e400402ae88584fb04e6bfcff5064134cc62429fb3620cffc5c33f8f6a658c2b24af365a27f92f42961e37b1578a3b8bd877afe69c77458561124d9d60323414b24a46277cdfef2305e2fcaea24ea7b8dbc670c20f16d45aad1858cc50e37010471290c41b696481a1dcd7400a88976cde8407391400c17559d1bc0edaaf53b82dc57849565b7246d06b9cca77fb12201edd48bfd17abc3417c3a55a81ad33b7ac555c0c6c9b2af5b72cfd11d72f7b94b2b2fefb0f297d2ef9d4db52953816da4181c21e9bacf52d0941bc3bc64470f08b17576203b44aa445d1d2786cee7dae4bfc68c4cf9445ae30d9c29b37a22e9fd94847d4ac8b0a6e44a3093daaea38e948eb429dc2bba4ec38a04f0c729e93a2dbb1a208dcb40b4bcb6bde16995a6897dec9e3039521760d23413b0b1d2597585541e764f52e73c2b167e12dbc230abb2e33f7471c2a5b80988cbbdf459f4f5e61d643871c342f83db369524cdac6468194316625375a3f5ce0146f00f422bf6d6945b55d3aee185ecdbc42f7358786c4619d522aa118881fc5787b16f2868726df2a25237d2a7978e680056f1743b620a7c8061c2289b4f8e6442572c900d0d0dcda63a46664f61bb3e8e70fe8916cdbb957350f5be710613952904b44b25194a9dafe1756838d01b25214e3e1fe99b8ff298911998c823ae72078bd0f8efdf23f2df44741ffd3cef28baccbac13b844c819199365186920f9643a242030ed4158adecd31cbaed2af771dc5f5f9255b70601b31befd3b047be3f995efd38df6086101cd4d767b8513c1e008b77f2aafec2b340f565ff89456f31172c974c3b8211ba14b9d6e2ff0b42f5af3b88f875602b4708c1cfbfdff56d9e6431a6824328dd82e72454625eac9f25e8ab39cff779bacb854c3091c416ab408aed00a14f4f156c93ecd432fd9eaa75e4f7513fa5687b58b5ed3eb4819f77d1e96ba63661562f661ff382b30d456debd7ec260317aa255ad2fd5cfc30f4d167d4d70e7e740ccf03b5bfd2948cf1f9c453ca21f2037f0b0e4fcfa2b232a63c37ad54cd0390dbdf36fcc640b883ce41fdd94aa3950ba205e3604735746c9becf30d0fad70244f64caa7c4782539c0e10ba9217cc483b98b48d9c8c7b6f42501a546114bb4078c22840d493627c111607cd1d036925e78f9764cd4b1e5d2a9d9213452115f193f665d9ca9cf747d0abee2de667abe09b0a8d33395f0c39d4c4de47e2a194648f7af68c7023d1bb295940682c8b938b8c4a56ae2f27d24d9763fb4f28862f9925423efb8667afa5f5fb65e82f2b823bd3c63d7b3a7f67dbbb2503135f1a1af32e9887e04653175521d5508da8e37fc02fb3e7c852b7640ecb91fdadc75ce1b4a685417b44e4e84eb683595b9bf72703d9d97103f02963d195fc94eb6bf595a34a9a73f5f374209b514b2de9db5b0013df0206fc618c64333d1b94426b6117c7766d7735a880df63324ae991de48b71bcb6e4b7c8ad7faedc79a66e51578f3b99860be57458d656936b69dd55cf3eb5f2279aeb6037adecdd09ba81517ad455a6751063e2689f735feaaab413285362453bd7bb67bec938190d80fcb1b2bf655a1e8e46c624442d0decdf18c1cf6bdaf0cc770eec9233010000f8ecb75719fe2b6a5d067b1ce7d6ce3c41a4b8f35922c6eaeee596b891c112b7a4c8ca7ddea6113d6d8ed86f483f39c0efb66e48d67949c063ab35155bc63f730471a2c786e320b085c8371e50b756f9dc970212175ad6e5197a6a3ab21f1553c19591fd736f89fa434ec4faa93b892eec5314fc5282bb325f628566be3ca7ade53441da56c67fd9937a99f1f1c25add03ca3cacdea320f8487c08c300633efa3d7916a3e56c3988d8847fd3bb626f771b67834900a4953a7765a8ca04a5fd9f9546897b48e1274ae93d7edd5ef42d7dea7c0ee07670febb7cbfb7791a5d93aa44b95ab49055cfbc6497c388081104557c95cd0642ca50fca8bdb0637a7f6d8b3f5406a4a7db1676a5399ab002c6569aac7fba9b0eb9692a0c3ec7e976cdecfbc0f04e0ff8931ec22d444242925fd0692710d25ca714f43b21aeddb66e3f9b752f58512298d00d877ed4e9afe6966f3c32f756d33b693e5674e45efd58e7af659a8de87216ff2b81a1dd2ed875e13e012a93e402183456886922a852837949b827227940640f3dce65d017a4b97caa19ec6468338d8cccd249906b4b6e55d8d6e205fae6f98b1d4ff5a7274763c53c6fac2563c0400629aadf0809da960c633de26ff956d47309391a73eb7ce3d50a4d8f8fe11d2d178686500798c1eb36e81d67e0dbb7313eeab60b2b3693a4131a3fd955c8f07f2721d52af99b2984d63d195aeaa5a5124b75a9205deee614bc072ddd016aea0a9f527b475a8c1e35c5be426a88049c081b228d727395ef90322e8df5001e349120e2e53da1a75c1d42c4318634377015543eaacfc566cf0d4ae56e43dc0de05781044a6b641bf84cd20d13f88a96311d60bc593b39556bc6fe232037bafe69bc1af150899df2ea6d8c660c1999e13e0f1af0f2791f9fa6e53348a844549ebdf0793cd9c600d35d361d55f1fc59c1e6dd81cff84e67efb6fa48f287b1f79d446c62daf2fba176e6ffb933e9868a8c0598c95a5bb17072296047e8d1af2a0c9c3a469a7ebc92eb1796a08c416da663e2530f64fb96724fe55053b10c9ef12024db4ab46e1b4d3bf9b7cc6ba0374eb8dc764f9572877b6e8f9c1250a71d20c7f5424d6e8e89a302700e784e975dd79962f5c34265c2ea05bdbd26e7feee8e41bf17707e233d8bb1a506cc29805bb31e0a3fcbe1ca8fd2b23658dba3fdba6333b81da92718197e0779c4ae7c1fd521a1dc1718a1c6de2fd275b0d6857837e0223b2fc943a30c023f5ed334150a2d80bfbdcfa74b51daacb7e51f33bc8cd4777ccf49454fc1d4b1a077216139fd4ef26066882a2b3e4bb62795ac4b50572cd18fc611a21c798b08d39f502dc12963593486689778e0dda760dfa9391c8fed88e69c6991fbd83bd91aea80c1703b11b8bfd14390978d7c0bfdfbde2475738d82cc7355f95c848ff13da6844581c36f3cf5ecb3d42a0ed1a7bad3bab6dee60803b3676f8f602a2bad94467808bf861ed13407d1f34b8aafa8269333b64050babe5f91a5880c3feef48c4bfe7162ef637136c3875098616d2b8fd457ba583e6016a974554b858a002de6ccd4cbbc1c4d884ac421cfca4aa1fbd78ecd2b9f90ce2863cb8bd21c0275438880dd1ace5dc4c800c5677f7c8055cd9814f958a76d6481d70677a20c80e1357b4577446c553d9e4064521fb061a37fc55b1aaec68e1e889bd0c08dbd94bab0d4a047fbcdf719ec3a8b573e7dd06a8afd3c7187ffa8b621183462725eab20f41f1e91363583791d5c23eb2503101acd9e595c700a4f8bb22342d2df752a14996c66e90a01bb723ed1b8e19a8d86b2419a46a5525dbbbf207c976c6440b5813d9d8dbb7373eef107ce2f6214b015339d8b25dc943496ea397c248c51a4440937b827acb236db1fe778c130eba9656f4cc221b2eab6bafb3f51a90717c985ab25463580be4fbc98f5c8425ecc58283a2ec4dd55e90433f2f3c6cd50d3340f1da5ca6db2d787e6a4a6306e5655bdcfad98bb19377fd5fd09283b3f39fb39296e40c3cccea1b21a8e61d9069891c4c25ee51942f64a04108605fb00bebf753afe790ab5507526d4dc3d60f96db7c46a0619891fd4a3a66772c2d87885f12a514d939aec48e7fb5a174b6e0e77af840e36add56549188176023652f0deaeddd2acd2744ddd304d5cbe0f57380da3194b6b11a51a187e5842d000c93879699e1c2d1759b8e20eef57fe774621b535e2e8689308f2d76dfd1e1188cdd94c99bdbc1c39d4cc9e97d1642d336c2dfb18eb71101cbcbbe0b695697b99758036ef6d627261dc640a1b6f47b17e32e6b98c6ea8dbf6271295aef8ad93526da12868d8329d888eab31ecb47afbbce48df0060722060c5bbf453e6ed7f37f49a63a4a565a11dc003a802311aba46cae88ec253fa908a590bdee30298d1e8687c49fa6a005e2dc16603bf925a5901feaedd9be2f7f3551f89a6db9e43b9a2743ffc3b0d0ba0d5a022788b90ff294d4fba4cd99d40af9d706e6cfe33c6dbd6db7d300a5ca8a195bfe1f02b1efde49c769df9151c6397560d1c678fcb9d85da2cf4e76ca60b18465bbaac6dc5456fda53138a08c33cd5618a59d29924613453715d1ba5a3caceca4b0e9ec8c87623f158080c0c204871850c4be4951118ec1096ea64bc0df763e802b13367c39c2b0687a1c40ee3a53f23efc84457512c1778d879acabd095f9848e2cc2a087db92ee1aaad0db78c98004c18d6ee789f03e2ac19a7ed19b2cda15b7cf099dcbce03951dbe6a256cab3838787013efc69074f7fa197b9395f4a7dd2b1961905fab486e5fea2fd99a1f871baa27038d32f331f8937b6226212ca19675b038acd098ea8176444c6e4cb253ce8434d00eecbe75de7e2d193083d7d292d36058dc403055d9fb8df70b927b5504d45cd09656df512d9097cf3800a252ac60a2e5e19c3160ab52ee2f410d69928f9f27bc13312729125e51587d21f2c0cf31b5e88e9e6fc22116f49b3688dc7417b0eaf46a8dd8d73bc50a84ef3fd5948db0703fcc521c0aba72f55041a2507bbf2fff80f796f8158c3efdd5c0355e2da822bb07d9a68a7b90c027b2bf3a1e1a8f3772490359e56dc66a4ea70cd1daf7fd0d431dfe31165363ce8ee8f0d3ebc00f8c41231eee4e1a21f47d7d533b98d0f403166a07b7633aba4f55df682fa25ef0378c8ba1fbc3830355e1e05f02259635c9c50ba00513f10d80767226914e98f754f541abedcc09a51e7e46e2354750a62569e6cca24c8eeb549aaacd5df29c320335a1f7b6d1963894c926c9c62ced8251cfec0cfa7879723b3456c0abfd609ed7ebe0d204a1b069b6e222e413cf62420377314b35180fae912f015ff2bcefd2c32aec9e1d1721bfdc22d71613e93ba9155aa2e7c2875dbd647ef77a096d49a1ea415a3b2615fb2bdc330b047171591ee2fd0c467e511b4f04aaceb9ed50a948d9bd7e45cc3d4c7108a3b84cb3cf4833464925de8c0bf2f0c49b52e70c097a294ea65b0bcde35d8abe2c59d1b8cd504c2abf07fb00b3ea9f7188b46183b7bac483f4dd24b5368243c3efee614c9c70f087240fa17ccdc66f3f4d286aef71e647eadc17c3e6846811142ea2547a686c6a0e664c12929a9c6273f367525a7ae4b7b20686c04b198c707696e4902aee28d67221e823652a341775e37bf9ad7778d9250932cb3d78df7a03a1f383c545f433b7a3aae17eb1d4f014eaf2777c4f9c81697fc195b154995ccd6454aa970d037e4d3ef8eefb1f138d94b8ede905dc1a2c7a8c957d3680c7617fc437485deddce70ea826dfec8a25a7bec206e3ce1d0685c27a8fffcb9c5783051a7c3099fb0ddc5d8c8df68403be31d48259d58a6b942ffae7106b7a94941ed61b9991d498f5c08d45405c5b7de471e992f60ba6d004a397580752688810830876108bbcbd06047606eb60829d996d4191950b2c84dc3cfdddcb111f7f58e8deafb2b9c5a88305ce63ed3d474f623a7e288fe57a03adb741e8c7521e026fa8c572c652f94779590ad04b3e11a6d117d253140340ef125b80d2fd0f1865ff15a1a3b5469e065c6f14761f457168bc59b2e387a1cce6355cca57603609b8d0b49139f7da5f9fd5a6e1d96d13d1c4811be8677fb5ffc306252c0698f3ebf996aaae0bce18fb77e1df5ee5fcd4ce2b845b5a40a9f3f2bae64609ebbbb1903d7790159e5430bf25c6f819a9ced6f4d8b2a9b0c58de607be6d7e3a09b052a47b0eff0854fc98e650f00321b463eba3a64ad6327cd7ee9ef76aa1e55246eabeab35f25270b387202fdb5678d905fb295f1009a7ecb561c6360d68efeafe5024abb20df4aca143ad417c0c254682e31084de7abaff1a3836c8419c91cba3ddb2dc2480e8345976b6f16f3ac68d96d8f7210b4cf1df95305a2eff1176fb689bc37e6985285e49f061ad8cac8531e601a41e1be60292620f6f6caddd889396e70d42cf1d616181cf0fcd43beb6ff60c0a8f31fde08fd5ac7aa8d5cbfab5e2d7a0fb9ec85643dfd573a53f5e5f49cc7bf0cbea2f42adde6c1f9f38153ca2446e8f164a8d3152222419686966925a6cf77336f007a20899ba00f33bbbeebeae38c283dce1f13d44d476d0b06d326ba5a3501e960376d7e7c8601046ccf0bc0d9f09466c76f19e69f0f563e4990b3eccf6aea82485033694ae2c9c3b2e242d72eef2f27fab49abb690c821e7168dc8a904d4533c3c8a07c1edd4145f2fda5279f50b686e0db6f58d8e6c46ac61b481158a30e535f361e707218c96cfb542f3af115d6db91aea713ed5ed5226ca9daa0286a46ee6fe32daa4e1931941d42213c9858d3ad2b318c1d4ac469747b3aa3c86d37a8aaaa7a976a2392bd7d6d5b23933df243f3bfd51524da37c66372f18e946d884570a3f2df0e3c168fcf55c82da297603aa8027825e8288624193a51542f825eee6b18c6d12a540b2e96248a422e9ddbdfa3a6ca33a99025b33ff3a4eab7956fa4800e21785b0204b6c103468eea53a0788a38527cd3b38324e92a95f4cd8b4ca49ba511373ecb35fb084cbdc85760ce2eebf0abc2cb05e5a9b4364086d6bc7a2782a9cc5860854d1dff1938b7c9f103f0b0069f8644ec04763f02b6841418ec55782e07a71c762bd1bdef730d5a80bd7b94f1f8d2199c774fe1a31f473742e9bcfefa8f86b1b2ca3188aa7217d4e360365111f37202c9b6089a2aa3786b3b5435bb4791b5ee2e0768d1693e50a220e644c9c3fa880790f4f746bd0c102422271b2fd2dbd177660954aaa5dc87f3600c337a5dd33a4d66fe708841f3951ba0c3cfaeba48bf37d3b481ba3363fb55f267c457949f302a30bee04dbc1e46ef809456efeed3a24dced069a21213c3507f152c0c2e91ff63990e3e90c40f80f6356b773cc18c6d67a1a2560c584bcc8909c854e89bde6145b268e274e2bb3a14611c2aa22e6a4068cbbae3b280cb8dc4a803336b36dfec7731f37ce71788f1168fb1c1d754d81e1bb1e23b0b779f849eb5e4d0e5822615c27635278fad2e3488b72bf353d63f9460bd4bfb74e2490c7fa2a9f564702d41d22468d0bed27dfb20a1e66bb24716057d721b87a1aa8013c31760b61b13e6c849e547a44293b222109d5b8f45c994a3651ad8b49422329acdaf8be81d468c70b4b53d185137db26dc8310253153c46da59c956c617fc3d129447c0a12b710fa1510f1cc387eaeaf61012e7eff21e20703070ac7d520a0dbb7ceb52e9a0f9ad947415a8b076630aa230432c4f1595b57a54540080f8afb1b1afa36f493c3ee58c6fae7d96cd72c4cb3ae10f561121fc6d3abb526d7d4ba19f06b9f4dabcbc39397deb7bd74baf26f9d116f62878ee5010bcb09b1bbc86cccd2e36b65c547d841db92b1dc2efbeb3708f37625ccd962ed60f09df77e0446b4005de91a34bd6f18fd3a912892221c1666c02503ef199cb91636446695a6c92fc78d9833ef71ee9222a496b40bd9a4bc3090b0bd5ad4c8e6b626cbef3d6de88b66fefcc2578374c9e02e24034b18213b31e95e99925df6e427a0bbb8f58b138583282f1ac64de606e1aa0f1577db4874ebffefe2c4ade666824b7f945c8eea069652ec7281bafb8daec7e969d298b117176ff7fa3cf7bd5014938b333711baa01eb9e8e5880ea7c5e463160955b2c4775d15404110e4ee3a2448c75147947cac3f77eee95c725aa7235161bb3eb6d5825bc6105b14ef8be0caf7ae5978d1b48ff94b70923ddbad86b77bc8824f55adb1da67f913a671e24bb61d75056479f6e332829b5e4b9f78d4b8d3a393daaebe32fc754e8177f2ac25387ce2eb5a03d8e1b1c56cacc4b14d447951af12426ca731f9f37e4e3954b9011991f04c71a94be1d97ce4fb9e4adf28c4b6429b8be79beadf3b77a2902d285c7f49c2492f5ef23201f7a7f8c7d6302f3ca2bf7762286c58dd918faeeac9400d0f7ec025e6d94e4a508ce3d54e4cdafe3db3f0617367ad16fd8a46906a4b0dc764f675b3dc087b219b14b56d366fc48cadcfa06ca686d93c63e4d893b44f793d4b2c0fd673b774982129986d1f913ebacad1873af986732de2d2b19675905f5b9ddc9a67f2d9f721ae43c94e7cf97a8e756ae17a8f1aeb00bffcaf461ceabd413c309a84b53bcefd66e07c23aedfb530c27afacfe82d7440b84d4578a807f700e1630a5702793ed09ac771da0d2ac67b7a24f6028cc39e6e7dafff9328d7ed14e95c3081b0e8c4071b95e5d9e32c5fea255670c4d13f914b7c4fc4bae69a349bc35b83182bf0023f1dca1f236db3f7f0889b394b0877c3d68fd94c64fda1871f463687352cd922d805bd75ee816ca1ee17e5959f9bc1f37cc18af47969e5c74955ce868b3e1a7dec9cc53616143924f97222d1cb866f9017a21c03a7aa52a41d226bccbb2fcb8537930a055ee2289a1433a82e94e6d56e6c09ed5bad601487fbbae7512f651a7d5382f0cc9451c0d5b9225bf205a53b7d336ab85379b630f0f9d9980f7a8de25aaaaa36bdb9cd33d0d2b5982a7cce9c8a8e694a47ce5f2e01e87239cbf7c7b9388669136f106e51c06ea018c6a15cf40ea7530867b16499b3b5b719886f62df4bb0ec6316739aa46cc48668d7688e714ba2065fdf4bcb470583bf2fdb349603a855a116ab7aee0295afab26f77a6ba1fc77ec1e041c7204945b65f3c16addf2f6826c2c9904ffa66a971bab373c07991ca82036c24cad32d9c5521aa2ce5a762a5cd659187e3c5bc2e24ae69431a340f6a51b9c5150af4040f088709bb4572bbb85b86b1f4bcca54eb2eabe3e042a9f6d8f0f5fdac9516422f07635e605c892567034bb4312f9a17cc456a5daf4b24821442467cf745cbbda5e27fc37bdac7630c9a1748ed0b2dab297aef639c4a8352387ea832eeb685a77c117380804ca2735cb472ce390b212bd9493c764db3bdc58faf197fadc5f8b950571a7f74812dad342f3f77aae7c0d66b0f118fcee653de531d9c84c439d8f7d0d837e9d9b96ec519ec80f12266b049bb77d4ab962a73c7b159444c69695549e6615937d808ffa8d923c7ceb369b9e7def74836269706e2a0264dbb5bcaf17068753e6a1e652f2c3fa814a4a2b05c361e162e84d3e9523001397586840a0b2bf4bb833007abdbf78c0e49d9ccf48fc05391d5786667345b342cb0c5a24be9e01b5fa57573f439f517c088e8bef4f6de65774d7a7ea0401c0fab885b9976166523a81c6a61a07e29d54953b8f5d50b409a769d217b142756eb22ca8886d090326267e8d0c1b5a5deaa398e566865162677ddc4c900c0adb803e58ab33dafa83d1620d545af91d3c8b1a4a4f404ba702c415427718fbfb0468c5de90f1b4a8cd61daf8c23adf96d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
