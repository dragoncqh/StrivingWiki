<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efd365bf1c53b606976c1b5d1b09e9ae329213b149c6fe44f185d17a007df72b34f33720b4f6545726f5de18d846d9b807679d4c239ba18bbb80faf7e9566f9702db54d244b527a97817fe00bb74fa1166d7b5d1d7ff23cd730b26319adce7db8dc72910437d29344768d82882e32fe81ad5e2081cf6b3c7247175c451349ebf329c568575d8e0c28cd4eb7c88c326bb50dc9a06112e23ada08e0c7ef57b2025057372a28370de50aabd462ad4990d0d2ac22ae291e108d80ae4f1605de777403775b0c78f357e83727b5e904075b071ef692c65ad2b147cdaabbd571fd211ab5e629d4e5fb48f0b3de651a07d3974e32a60dad0d303a916d49d4ba5521afe851857f89cc8eaab1639b4c98bff47d6e206afc6f478f37abfaae624e89d1693b800a71f5ae17e55916b9e5e6a9b37a5d15d098c34f14ac8be8f48e0bc2a0630bfa513c46a74faa91d6666c8048510f29fa51bb0a2d8ce7f8a860d399d722c2cfe720f516b67fec4d48e7d302465c1bdb91561e3e72b8b33a49a69843dee0d43212bdf16110afd69b5a4b14eb464ba58ab134fa30f1f4b7fc5a0623f7c645faf0640c6f3a755228eaac59569215f013620718a49a50361d59dbafa75ef2623390f24a8efe90918ddf548e14c5cdfc9e08a6d58d8211169ce6160d161d98b647cd4d9e62a9c8f3d2104e9fa6bbba0fef2def3a4c48d2a69e559b842bcda98ee405dc2d2dcb998eb5d5fd1e1845e1f42a3b4fd36f7ca51f05ab596e683bc45e31cc4cfb8f850f4ec6186ed3c51d741efb5f2fcdf721fd9541dabc0237b806c495ba9a4842c93ea289fdd7c8a3e010af56956644da9c9341fcb5463ee3ea5d0574a83f6ab5e4a61fb3ff4d535ff2b068a67be11744d879d3b023217728f406a8a7663a86854fb82a5369d4040d3b5b5ccf6091761691d079359d9d02c236157f06bc48af5d9ae72a648e25010366bf1a4cebfec0207898396a2d19b15ad95dbb697ff096a144e52b8b562552c3f0dc6b0dea200e56c6519dba53a3b2cc5268e51dc78538fdbf7627717bc5b487958cef21d38b9873b414a905056cc0250266de5e3c14a40fd3d57ab512f9839ccc30b3696c2992ab0372df1ae027e18f69a24c04baf06359850f457aada96098dbe43f6093fde2ace456dfd9b700e8882295ed3debe382e893444c70e7adc33e10c34a2e89a2661bd1a09bd7219befd4056e7f0552870b857ba69ad6c11ba4b7b4fac82079dbd88f47d656d1911b1a6567c7ee6227a4e8c0d498bd0d042fa51e0519478f4b33988154f67911e7c51f3df18a6b0276fa00ce7b2b194d996f1e7ce3b441075b9e5d1a5077eef07df9b9eaf91fe1eae7fa3623f30c7e4ceb7a8c95bbc7acb2d564f5d33213a2d569d00d1e7b3f81b548ef700108bd8f06deb551abef0bdde9f463e7f59dd80373fd2b1e8bfe2a1fe4506f8b7c3c724f60916b0a3e65318abf8a0bf5bcd92d31da78133657d8b9e647e495d574fdc09dcb1ad4935f5f6b257e830daed7d101e0da9afa22aa2305567ecbb4fec562826b017214a5cb1cc8f628dbfb5647ea55c19a398902a88166a52d6f129de118da8d8dff8f88064ce5a53aa25fa3e9f3ef72a344b4fdb602247cfd71ded78f4a0cf49654aa44f372f6c9fa79e3f0b83bdfcdbb643fec074f052b3a940eb5d482cb5eea8501775caaf097862c5ab0f0cc0b65edf5314be898823bee5b729339e3d39f349467d3ff2713e1025821dcd4b953c4af648441742b256fe580113d2cebf56a0d61caf6a411a39d9cdc119e3c79c5306a82512da5527ce211379c2831f1ea2e2154c587d160c1fce420fc0272988817cb4c2711baf184655385b9fabbb330bd002b134c1354661de7fc6856cab2ed2026973d1c0b4cabdeb8159d9d1cd34591ac91499f25980d57957291879fbaa494191a11dbe236cfa364be3a4660f4a4ce605b14c7ba8181dbf03de5e815744318c7fcacda706e06ddd21dca39c64848fbfde723ca3bb9bc56332995814e08daaf4ee6eee467eb5c6ebfc1ea24bcef9488049b183718a1fd47e03623a248cf9c3bf5b8d3af5d06c5a73143bb5e396d8a409eedcf1e509e08354c03c8a684e5ffb485491a613049c6015dc8ea3a842c23b5de6558a59abc679d81de6075eab55728267d4639f2f214087ecea607508575080d48537d72764d28dca00cd00784a7d28d649dd444be3d8b4ba378ff7bc24f650780c22caa7a7b840ac6010994c1627607bc0b75d82dee23b0e2d2ecf20701ddd226782ccb9e7d8edbd27752cc28926b7238c3f3bfc3d82ba5683bcce3177527f84314a3165d6fc689e22c8a8b7dd4f0da6344b633fb137bc04d67f6a19b3a0ee7fa162003d943ef3a05dcbe69529a4d570956472fc1a097891c8438dabf403ab1fce7e0ed4982c195d1ac31be1b64a237f0fecc665970839a924c44d9a79121525709947d4b5513d527d9903c22f470fdd6a5b20e97c636f3f4bd1745596204b3208a47d05385236b15c2dd8b993f0d508defa0f966fbafdadd13093bdc8193b9e2b90a0ec3945616a9f4e19e547dd589d57eead036e20b8477a0431aef309c1fb828c28cc1fae59ed9d5e2ba406699aa703696b0a5e8f1661a3562735a4c0857999fc5e20ebb184f7fbf910b83bc453a3b1ee03f73d97b3c459ef3a749c1f6debe2581621ee4676c0cd27a74f0fecf87fe22a8415a38916c3b49ed9bb963b2fd25b7c4c6eb89aec5b5f057d60f65401505d0da807f22c70bfb65433bf5b553fa1a75e0fa7020ba592c4518fc8e0786b587a2d112c770ad4d8e73aa54e24e51fb7da1f318d351edb301c9cfdfe94ac2d08ecc4d4fc670f5759402197810f6ff0ee3725a75494c52a8f38c50929fd387eba376bf695622bbc28d73959f46612602ef4af066dbf19fec62c125ffd33b50fc44baf12c6aaba5b86466ef998ec276c3e2766de561de825527cdba51ae7e1b1d01e3102842796829373cc7ffe4735153a8e66886b947a798bcb1bb2413cc56473308b0b08f8f69ae61434e42d5b8cd5821cb29aa3cf96d959889b4a170dbfe0ae0c514cc52124c78388feefde472d14ecb61549096c242ac5bfa022c521744ecf479dfd4718966c840e7cf937cbb10e6b3c464a8aae3706a5ce4726af6683d1ce69da68be2070d52726955e89229069e3a7809db1eb240846b6d66be9f3568eec9f854938726d49c9abca83683db674b4125b423c3f3fd88fe01dd18c9a25dd5f3628bfabd25904b0ed2de4fe912aac9bc670c509b5776961df07be15f02ba7924854b92441678b21f918fa4d1b42b404f73674ba75899ad70d7ba1980f1434305ebda799eb5454351e615beb457d5fb1754cd473c7c64e2b7acd8895115e5fab422ead257b103ec7ad609c22c51d1577bf4a29be859ef5dbd614ec461eb6c5d0e7afba4f95e1de66844d5f7ab6cda4e22e812d2518ab524d06f9db9da157f984b9805d3b913574228f1c1a953aad2f5b6ec445aa0230c13e097b5f83e20e2be7d111ced9ed9833a5c5f1df8db1f1a98f5713b72d3a12c0d0890ef289d64d3315ac7d65d35e786f27cacef007ae1fab0ec9a076420a72d3084aed9e21a1af016e1a786efba0c5cef568852a150df76a6e9f9798b11ce066f6d1187600ec80e5659c3117ce006663c2d7af4d61b207cf3bf95e1fc474dec63aa132bd7fd5ce7b4247b4d5475096288507251e80512af95c48f954239cb7edd1c5bd213a47bcf85ad413cea074a67e607c2833b7819278fc0355fc9a820ae441bbf525ef7ffd4d64fadd1104b7e019750bfb41c59f30b934e5377d033fab31a4f429cbd4006acb220f408e81c99911a5e828309a74e90679132c03942dda5ff1792abfed22b4374511627fc2499f5370e59f5b966aacc03a10bb69d9b322cef8e5e659f5764216c7906b3473eacbf2706946a40d2d1ceb95101161876ee8cf4acd1efed168d03d7381f3916e73bf243c4e47c629c91ff987ad82c3c957c5fea2c19b33bf0a77d792302ca27273d48939f033c4245451e31434f74c375015bc2c6fff3695f1d335a4f4bda1e20650fbb7439ba7dc9e6d19a7ed44d460319537c12ea634b065ba3060134084e1a349a671519218a4bcc86018f23f7d270a361c7bcde65e5c9fe11fd1c8f3e060ecc3a719634c7e75233458249d7f3ea19510400ee4a59c8553ea61ba466a4266360aabcbe1b2b313e0d7aa4a202800b6797c98b5759904443e31646e0eb3b3996a3a59596b2ff417b8937d0bce425ac080c9082eb838e493e2f7ce0bd28f23238d6ab3a69f452e2d30a891835a757ae3fb02cb75c8e70f51f1dfff94ade83b06f0a4e98f5dca7924c81b72b1afd067fd539ce54bedf4b3ba6f1ff7c5fed036ac89f641d98150ee0fcb9ac72e672ee74b1d995119e5b8a2609cabb98d01ac8e03825ba6cef2af6d745b37ea5c9649d15c0628f1a28edce90cebd0b258ea9d5d23f8a98a7d0de9b3f53b7a524b8168018a78c2d3811634df60a594aa69026775dbb6aac919a306a7076d7d97879cd9f2e71d1df063196b758d1728ba03695f0c4e7946dfc3ecbe5a410fa7c3315f7eb2ee57f3cce42602500f7861df8268785aacd56ec6813250b82cfcbc2bfd8ebbfedcd42faf02c1ef0f525c5ef2c5a027c8d7312f8d3be4746da7593a4f82a447b659b8ac68bad6a460ea9dfdb17b715427275c92697e22f3d6d8b49365dcbf686fa00d6672459e946d442222ed686692249a4dc8d5d7293c6d4c97de8f1480a07f327e3c537c9bb2e8e84d9f644865aa44679a01ab85bd3d0dcc40f9037420f0b4f93a0371b9f1a33a7734135379c362797975d26a92787d14ebf68bdd8956669ce6a86aedcc478a73d11d561942fca9dcd320ed4111c9daa9987c5de6805e787331828fca1bb6444e97527d8781373d5f7cddbf2f688644c81e4797fec43d4384fa3b2a54f322fc5a4a7b13ac04825e8bb67e2a497fa5ec30097092216c2ef7a3ace0e667585d025be8ae8aa61e6e74e5fc1bb23fe2a9401d8fc64ff987e8d4faa62222ef4810847f226ece7d7345bd1fd56be61d85f1eb4928904ec123749cb771a8284063de1e774dd264ed3d00f769f46c203f799cc973af21c0419ce5141405dc01d587e74d71df1b40f5d784c652eb57d32e42da5b2522145ca48370f5f27959381836f3c3709103d5e489b6836e84e4f21deec9bb7f03a526cc3f78658ebfd70aa3fb46e889e49c3b27a5593b424584f4eebc3ef506aef8d03df4f18958d0f1c46323601d16682753fb8d78ccf8e2aeae69341a4c5979ac3d3f1e4d93f532f2474e70828f9f836f9730a1ffa711ff3907be312023f3908e91604fd436b4aefef3fb4a3d395b825528aec438aff5b44a388f504c9df2e1d5f68a89c6c7fd19aa1d372831a6f480c91930c1bded1756d4a64a7b79e6853f9d883350e915dbf0450cbcdbe3c54263d8a2a8a012142117964c7161ae801b337ff21a8542a927b937f26d16214ecff70d438fccdcd428e67542f35174245d7496035bf6e96b183a64230f10cdb78de0b11171107fee1a6fb025133650d4046d6e982f30441c8b79fd658d8dc31de2c26486957e1feb5dbaf9d13189ec63ea25ab570d2533f72b81eaa340f5b2dec7afe1cb92618593b800ac547dc294363f068a82d88fff8775ac7fda8422e45d6d759791cfaa0af4c66a1b2bf7434b0f0dc71a1c6dfda550be8957d35fda1d3e481f9776230d2435169363d128f785c8931e225320f42443d32b47c800ce6a4f05c7fc02e212d1a0d6285db11a8b776197a198fa48a88004876aac66b3d366b3dc1b318fc1b6638a83ad688f9f0dbbcecca4452f248f7da4a12cea7f454f25e893ca49ff22740e9e8dd0a2b7e4f5202a407e54adaa40c9eadae260d241de3ee1c51f1385304aa727d23a8bb319a2cf14a0a50fbd7979438531f9b83a8ed850ae8a03cf766afbf0d1083ec02e5c3eef0dab4c2dffd53e017f37087d7267a2575ac50282e62427c8772fb6826743cfed2331dd75de548038438aa72dfff4f65dfe3f9d6a37da9cfcd828b8e3c6012618e7827283406ea88b658d985d258f38a1210d8ed733c0bf411b8ff6063f9e1b73cb336fcced942c52ba1f7a4be3367ad40c16811f6b6ef3070f1fb2fc87a62840cb80e0450e10de93a6bc71239623be6c36b6b0cafce9b977fe1f6961d077d9598b3e13df5bf8617029cc66e4a32d198e9c321d32d1a4f516e5d05886256f076bb75941a4b3d090d94f129ee91c6c6c79ac5756fb97a1fbc1f905ba2165ec37de9413b04e7388c910a322d8eeb0e935592836a9dec77b68680b561fbe49c941244f21d8952e81503b60f74b01924e18bf8b1f98a6c93f3af5b4350c3fba906838b7a13e0e78e60d229cd2ab03ad283684cfd446d14c1d7d9c3a5e4d42e598243637f2b3d29bcffffc1a13100249645a93e256a90186d81f8f7c1cac67b2ab7660a09ad61bfb22ad4cb36eb8a66b1898f1f5efbe462bf41b2cf318d337e23aba39f31672fe88c28a2fadaf6aa745e15f4fefb010aea3513028f6f0f304aa439293bdd0db7b2dbd12ad36577f23c537c146c11b0d41b6cb4c28a59296dbad8e50a974f6ed1e81040f36d162cbf43ce5bbf8f31cbbbe59ef33368c134692518f5df0f0d61fd0a26a048d9ffd24dd8aaa5fb72b99e96fffd5732e61ba64dd2ba7ad60b8400f8314c0e9e55aa67b014ac971ead0f7ddee503d3363389f8f9724dede4efdadabcb0af69163cc51792b93e6ffc0677aeac063e99bb5f300097d47b3b4b982c035b41564c5118deab7a375faa25a230f55742dac10cbd9f897c8817f10cae4a78f241569ef1da20bbe715b7fc2b2fa6b1eb19b65a72b35b28eee658390c070aa91fd4066b2e7ac7e2a17e68729d6b795d32d4f28988e6939f33a440d303062ffed9c5ba92e330ebff4aaa822e3c468ceba6545b3c9f275102f39123d7ae3e74c1ba4142f6c64e9fbca7c683c853bebe37786e6a2e46cc59230bfc994f2854bf9586d1be5cf2173fc67c2e5e1de88423d28c631cf528c1090daeaa5cacb325d5ab8ad88f1181be090a773d938fa3cb40b93c7289fda41704d9a70a437a2d949852aa31ce5a1ab573730b52a7d8132d6f5b052334d9ebc55157734c452cdd49a00edafffdfd7e5b9e501a078c352b92940e1b3152eea3eb34b5d9af476e70a38d63b8d720373a8d07faf0f6b3da67b63cbc1f8d1f213659d2255ee199e49ad02558ff49a2e1e309fd4d7e5dc278095dae9930790556e2c24e1e91248950168df416a80ccd3fe0f3d6299bbb111d5e7065671852fcdb39b494e9e54a39027d2e41cd6e4e7b97be133a715478600944362a3e25245c604e2f4775bb28ad32534abcb9f1e8701d44dc6faa304068723d5c3781841ea876f039527709cf034f956f18abd259598cb6033ceae89c8a919e19916d28a6c0e95e593456bec2430fed618c532cd7a854db53f605eca3093bbd4280c8c8a792ebae6032795a6cb362624f7ce1ab895b4e36ee07dd1fae05836b89ef88a8379ed35a5ed9773e49de0b9ca5fe0c06eb22f72d4e4201e5bf802d6112b8df4169580aa608d6527fcfa9e56995e0e3af7c4a7777ab60bf25f79a9070c000af735a0efdd89aba990775be8e5b42fd306aabfe446404f076b243b12dc61b5f480a62dcc67f6514a70b09ac0be6fb6164c462803f6178c86e7eb0de9ccd75c1466f494b328f9abf4ffd8009afe196d872fa9f44e7dcbd4d1de599115a8e954171eda512409ed6182936026eb4ea8cbee7fb73090db1bccebaafc3f36c3bd46f50cbe2357ce91a32ab76a66f6eb4976260010560ea068cebb3374d716224a175ab8f2ab79f0e9e2ea164bea101c57e2ed0f37246ab9eea0ba92459ce8e1bbc008d1ce17928b5295e12bdfb11aab2f0e5abeb9beb6099366694c5f15c83a3813cf78b1ad462166705f5b7789eb1591c75d94e8420ba3006b6428dbd2df8c664e87ec415bf45b6c56563c95308fb130e74b2b4e9450eabf00f8ea73e9385e9373f6eee13226facb954cb436a18c9f3fe24e9da7c254e4bb6899bf8bc9a016b837bb531d4897ae56c7d2a98d65407cc8560ec7e8c66e78696c17a11b662a997c0c8bb287fb6c73cbd3a556c6c18a114e95a632f750b5f4b6755f5043c9ecc3d6b32bc9cf86583dcad5feb102d8f441a72d4690c575786c069d1711af1a1fa3e89a718dd01083f262afb9d6e51950a3541ae5fcfdad40ff084cd018689a7f920883d29cd82fb26761aa4c5da90ba2a848df167c661f80caae84b1dbfe5c587be29e711f666d8db321381107b278dd355e7b20753e3f70259d8849854db295ed28d8212199182a1c94b576867a5642dcbff7966609c1f403b0bee56826179413ca2a66d4ea78568d68060709622be37756af96bd2903c083795891a1456305f31bc4f4461bc3051f9c0e1b59db27e59e28b300cef72e7ed6986f5d08a8e88f4ff8d86c43089632b83aa520d5fcdf3136ae09f3f9f0fd815b55291f9d9ab997fcf2a30503a166d14c4094b8fdabbb82f5ebb34cecaa77ed8c5936f4c52bfcbf31edc12ea5a9e38ab63326a0670e72a6994cabfd935309c33a5e9e58a7a695b18e2910c66ce0f53aea3ed6beb90d3bbb999f4f3a8e244d6318c6415f8bed02f6682a842874069991ff19b3ee5c36193957948e84fa9c5d190d989a230be1ee206969d2608c36d25d0dca5995562208cbab9b091368c22e8d116929ab92b0adc7a53481d706533676aca7aee6cd694aeef1b8b45e6b208dfb49ac1702734a7a10b0f520b33857934bf49bacd039cd914e281f23749181544f3978a1138fa1c47030f27b463d445512c72a6f70838c28f5a71fb6bd7b86961b8e5920caf3aef4253b8039f7476e0577293e7458cb0e7167f7a9bfe954f0189ddc4148486c9eb1c60a1d050422ef1de5ef053bcc0898916d4b90b0efc9bcf0c71920ffcf2d686e7d3906f1ba0b114837e80f2a2171a2819e92521dae6c30ea27cb9b5da4b0d24df5d25a72a4c5793cae2ec787e6a220aa8b15f76127a84c184a0f5cd6dd99dcde857152414ce197b777f74a9cd0bc6acf31a8364cad669c13ef3d1bfeabdbe02535340150614874e34c9ded8ccba75cf59dbaee81c8c26d7b56270bf30ad154c9813173fceea09e2cecdd7de5e1ddd44e9b2b37c97a735f94a8ef737671f8183bd435d4a1cc5af2a988b072946cdb8d6a289d22740454f6830a03f4af7f94c718f06041161aa25f7b4f2efc2cfdf92c0c3e80d006cc2044a03451146ce1aacf57c1d259da2f2c2b25735a306426d66393a1de3a790bad28977e576863cce97e360febafa90dd567ab56ca6b9148fda566a69ba8fb59352c32bcd8e2527a06aa9531f0cb2b26e0d46b1845fe69cda020119404575ad32ee50cddb44d376c018521574d34bfd2d9a9ff7374a035e77cac45d322d60b200d4171130c30bc449874f6785ce3de6ee8457cfd963ce3ebede84902e54047f4de139934d1b341a46d2ab0fd345b52a0627a95965ce3bb35b2192c286d4bc1eebd8022fd85622303d73ea494c096f1893485fd4cb83d31baaa713373ae0700d6abd21d75859d59c728c04d19758b7301f1a824d76a2796352a9dad18556b368530a1bb20f692e045192b3c17dc2f5623406c2a9c483cce1267a715d1b836f9cf7884599364c912df14e0f7a2a2fb25d45f5fd05bd1febd0bfccff873c3565485d06adaa2fa768da7b1ac9a5dbc8c18ec63b49e958436d89347eaf8ca081b1d8978847a2155ddea6d06a2e2678a45ce055e88e516936c1002218613badbd218f89d134b67175c3199e5befa22e7ad56545ac56ddb8e299dc4074d319d1ca676b541a64e0593101315b0ec68890bf5b7a6aab605e1e0c3a3d69d2f3ffc1145837ba8d596de46012f4c796ff8f69bb5411f8062dd730d705620bf0dd8470d212f735fda8337b64b93e780f9b0f512cba13a1bc88c177fc7fe1df612af2c7cb9649be731fe1405241bd452bb90b7cf023148537c3a4f34e4ab7c45d518405a4a7e257f49111880b76ce227296417c96067dcf9c19c5e3270534070d709deb1700b2c9bd51c97bd9d70f8df96d5622def6005a532a8dd8b5f761459fea870313062d2bcacd1701193d1d37e05639de3ea475b703ba1dd57828732fecdbcc1ef2fb59de359a7ef458291d27d11a0ecd0f05dd9a832483e575a5c704a6bdb58ed3e6cd59c1f0c1e9f6cfdb045f21fb68732d8b437e5f6d76e9e763201839a666a1738e41f89fab74f29617bd10d1ea3b83974203198cfe523235e574b90a510f86f5b4622df2d69786938435994884b3bbdb5ac23950603a591d7fc18b06dd37f31e4981fe6f7ebb4570fda5aac9cbadac877cd73142569b0edf633868b0c1afe486c87d1408b526c435d6af765856f326df2e3658ce8a6b754072ff972f4fbb0ffe2ad341cfa8b862a2680e47a48202f17b3f744de7644387556db5c0892b46a9cea7b1745f378c988609fdbe2b20220f5511b2714aee657f86084d1c3fc0016fdadf0074d43036a7f7844d6f5dc84d54e49ad87409e9b522a2690f03b5e014f2d05b31bc4d64340e14ee59c09bdfb8472c3d84ca70f2ffccad7a65d17c6626ba73a0238050d96f7c097d78ac51b89ef17bf80a127a922b74c61a9b7f1aa1ab098b95e656a9a44cdb7cbb0316dfba9740e020e80d5b661b3ee90135850daf6570e5e06a89b934b86d71d8a3bf4986b98531c76f376bce3d1e02ad97f8fe6b1a91b32759d3ac3ff671d6c32125aa20384d41abcddec417965a700d2e7d0637a836ffde3cadaf7ef249bac3c8b12ff7989159e9fc134659e83d13e0f6553f10ae1f75284b7e5ade8df0e57e86b0023bbce3f063f7a341a060f1a1d1ee5c860ca9a1b3be1af688ba957b366ce8e1efd20ad2d4335348d0da780dfc53f8ccd2e6df04094a076c484ccb4413bc24248f2fb8c5d913e06abfc7a764f6183dffd11979c1b2dc4dcf7bb4de680898ffe65ae69d0c3ee54d19b1d1108de1fac5558561e0bb17e9126c3c900950a0a1eea65b3058b678b9ec6a3eeb06c288992739b9ad1f80e21ea8f150114fe913f9613be6f12c8ccb335edebcee10e7c2ad3824f08bf46a1408e5fff827239bd72ffcffb26b13677bc90844f4f99fbffbdfe30faa0d9219c1cdcdc2e4c314d341e9456affaf661d1737914a63876bc81f00bb0db28d8bac5524b76d2cbe7db5da38700f779aa337bac2e4de66fdb8a63c6854198c9a4e4c46c0c194e91c8138a6fe8aaa63fe9f1fbfc3a3d2d4f7f76445514c1f86d57365a114ebed1e326a4132ec9d5f2d16d4cb2925824d17e9a2549832672c74d8e4d061dd21992548236b7e1169f6eda4c80727dafba0f0c413a71e14072788b2dc1e501acdac459717ff92138eb936641fd98f5c529a01ce2107941f5958a275e50b335a87c0b35c1a9398282dd549e6355c2f222be25ab8a88fc17498c30f70058d11ef1a4390fa37e931510614c7936caa1551507680c47ec03587ac679305248a1bd4690b76865e2ae805601c5ef2b2a05ea55723e78f27df9ef4df5dd5f7562d8dc9961fa426e241e998cc6d22982bcf5d0bfd1129941347564e17af87bfbe5fe267917896939d2d34b32dea94e6c1b1b4ebabc54cfed784a18bf972255397236526c084826180a21cc2fc749d8e51235e4a31b88274df36f58b2ba0c6af7c18e4efeb7addf71ed5dbade4bca795a66f60d3d97a27ce5dee48b1c3c94108619107e3778100ae4c7232830023c4869f7201e922724d5ef1d2ac5278c45a7acad085acf67561c38a257bbfe46a57c49eaf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
