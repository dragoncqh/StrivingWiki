<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc12d14f511e3c31c79cdcf434c3dae22381113ecfe28778261808c861a474bd190ad937c21d82464cca3675b98847a7e259e79ae1ac090711306dc5ee54e25039a41cdfd3c77e6f5c37503e2dfb4279a5af26e32ce346ba889ba93057d5519b0040b713c6e458c381632683252a1f6b9d212ae4985a4c1ec27703054ba109efec735fdbbb51e384312eb7eaed047fc54634e3d15dd5ee80d40e461f46d2221f7d751a4ed9d5ed4326c73bfef146f207c184b7c97578e6fad702069fd9c4fb88aae0d68b46aa7d1f942200e51a1549205043af50f8cbd50b8a771d71d89553935946d5a7504a934df7677188515a49d41e2be09f334ba409bd260a4803ab67da2f43c921ae11f9343f216d5d0179fd01336e575b8a24d9027a7e3df64ab2ba3b4690dada3800d0ac5f39f61d77b34554ed2ac8ec762702cd0bcf261ef1cbe46bad42ebacde5ccd911634bf93448496501b526949b78d2abd8908bf3c28b302ea5c3dd1c2897a0d70992d24d6b077f0f4580a6b28b7c77fd6b16d5a6e427219213dda279fa71feae8088e43024df59f334dad7c29e13ecc3a12943922cde2f75c4b89ca0c9a54601c7b84d9108d64fcedf9f217e434823bf98dc70e1307c760878f370655520deaa3b5d0ead33b953f56b6aca5629f3e863422cf2d50ab3e4437954064735b28d3f3bfe1787521f38fdfea07494002c7e4d4e0248729a1aebec2195a785f561f62400a040c82769a361d5783d28812765ed92e97412d37dc4a9508f5b352de66d1f90e7e1e3eb2880e9a30a53a8fab6c03b6a1b018d344ecfd4850aed50a5faafdd10b71cd30527d1ce3b4e704c60bdfe70f118bd45fe77bea6f753a6abab226e34e167f0c9909e6ce144c8a3745b4fe189db17c43a0488e6152f7d68487dd310dd9ff2f5c13f6747a439ed2c55b82fc8fc2ad431397db6d8b42f0b3d29379b79e61de8d993ee794f6ce486b2b279a78bda94c2f014ec30ddd1489193e09088e0146cde81f7ac44e51f67f4ca17609d3ae4121939f177cc8661c512cef0226d6a193293a14a4297f8b638d9e59eaa75461d57193e180453ed2ff3bc435ce4128c9ba31ba6fb59d752e081509ede2c5afb73935a5795faea71e51a73964791bb452d5ab8e0b81382c345a8496b63a4cf01d18338013cc2b0fb8ffbcc244ac88c133ba8eb3681e641864da72d501e1e46711faa6c88347d7839c7940dda2cd1f86c55b9d7ef32be6dacfe2d876635bf4bfd74c27e3fc435c2f16e5812d2569db8d0bec124451ddbe877e792b40cb8b79695a8992abec2148c84474593b3f8aecd7e5538ee55310dd5edc55a101f29dd25fc326ce7666519d8a5779b63f3a4076e7a5a09c023f516a552a45a1ad4dda817e9d456a2af30378020c79dd3d66d04ef0f1dbb30836255f811ff4507ea390c7d6f7191f9ac039167697930b8a9147d9ec44066c46124a7926a5bbd4792518d430976e8cdd4bb2f4ee89edb9e3a979eaf71327be9e966266f1e43a76e24766d4b5418e8d270c68da21992a409b0216b14fe3fdb29d3b6d8cc5b3133ea2ef665e8ba6abbda436cec40e738d85b74743415cdfdc1e5126fb28736c63d735b9f7c2a3c11277b7702f3a27e6e60e4572d6ccb59052590c6e408070c899eed20d74f81d56f3dba92e0a4185233602b0d52d7c605ee87837017756e3c970f23c68edf016d1e367c317b6715f283711cf0939af5f9e4cea7d4bbabedca454d80e20c15f7f713ad9283ed9b4ed9d176430bc858e7be10d7ed0926c4f1b070d18bac3ade18158b3f4cfa3df7fcf6e9e346aea90eba9a52c50e3cf0fb8676c95e98891d37bccad9eb2eff38ea432def283903c4b700bb69473f9f5ed8b9aee6e546b95d3b786273249ba0c32e3f39b6242c39546dd20d7f8838c4bfdfda8f84224870e779806bb288fdb06a25258f1d45aca94d3b037820a1c85540b155870c9f5b99228e3e9e24d695a7ff4c81307f3311da5e677710901435dd0e090791dcff98db38325137deebe4d7aa98451c1914c6d011de726a329bcf286d72f305aad150bd6198b60e0adc68f2912638ff46beb06625fc47d8cd333a6ef1d538bedbdae08ef105319d0c5c8969c46aef0e3d36bcf0b8722de29dec08f86ba1a299d4aff21ea21ef54d3cf19753c398a429aee9c2437ef642ded06e5a4060318410ef3369d7749e9ae681b64a34d3d41ee10c3dd746b14946e7c8fd53436faf81e5183e13709323750287d843489c7e0978a2492743d22037b41a82607152a873e8cb213c989aa75c6732efca300cf17650e3a9c5c5d9b358d1bf9767f40c1206a28440fac506b6369bff92543b45893382df4fd62b273fe6687ae6888558bd07e96c8ebf599ef3cbebc82830c2b8b7e88ec0e566abca5f9af19c320a5ed003300dea53ae758cc673116f3ea049f5862576046d7f538805cf5c1aa6b4598e921e92df713292fdd823e2a5c9b81fa3ad3cf1141e51f1e5ce131e2879f82263ed79c0e25abbff1765c29ed965717c2eafc05dd4e45c65e6a0911ec0bb4f88e20e7030fb13253b24bccd3869f8bde51e94050c43e3dbfdaaca292e53e8ddb03c8065f9c63f52f2fdeba5d81eda7fec5dcbf68b4bdfde945a1d89adc617f26f1c9eadd1421dda2b5f1e3f8966b530e3a7b10b9edd4596978d30c9f1cb92404cceb501a5cc94c6aad935d4f2c411d6d06d8537ac9357e340d9b3e2c281acd5901317c49560e746e9f83bd6b303463af248224dc6a61665d097dd015876add722e8f1ce9c8d3ed05e5d75ea9437fc30e1705b6c0f488a39debe3d8acd7ba04b594bc076d556da73e32f464c91938f0de11453aa4eae61bb35bb19056bba672f2f3e74a6c32ccc4d03be8e7abb3ddc96168dbc26d407243ee3c43893b9983a9932acaf2782b2eca1ab565605ff26d190caf5b0a9805c704f9ebe0bb4c2492e0754d2cb207eb0b977e188c4d8c83d8343c653e14e11ec9d2a36204b6aba4b787c632029e388b559a70e784cf45ce3fe0c7b96c426211ba8dac92ceb1ed34e1a80afeb526de84b1b0ae28784312f294df7d734b3c11c6417e30eb68906244af4e0e2c39552a47c86a9cc515883397c71e0e09331caff6f1616cbbc9ba357a4c4929249edd49eadf659649064ae0387c42bc8b8b3bf04bab4177af64dc5fe9dfa83d155b08979949ec20b11aa49403d1432f4e30da4d18b0c898bed4a11fc5478db2d2577438a2c96613d673fa7d552c7b5a3e4675c1d606d7ad972ff8a90bdb2784ce323f8f28e161a47782fccd9c9b1d0fd27011f1dd8bfbb53f7c04336e4a23253c74dcb450cd84c83e832640174f7ae151a1a3b058e10dd1d488dbbb0f5ba90e875c939a0268502d641dce7709ac98f929a0ea457d923e4cbef44f582b841d893657bbaa16060f9866f57d9af58dc507f3dbfd8bddfd60b0fbe4364e3a1fd0c7ac3603067582d29602a7dcce9a677fc79194f8c58bb0ed0699107018309c17efe0704a4e28c60d65606ee60a99d6dd96fe8aa1ae9249a97afe4ecfff10a47bf702962e2be314e07a381c8e5969af64104f6375ef5aa06657915fd7f4d0d64537d9cc18a3102bec03e18be0e62822d7a7a07c5dd13f384d663473f131f9e518f7d6078a15a2db29265565947a8bd857dba384cff12a4fd6ae551f66417ca600af3f863ca0fd3ce5694f17dac9ef95fdf0c94d548d6d31a781f369897c05a5e24fbeba0e6f26b8921996076671d0115617820e9d3cb4a3886f0d21f57bd13a3139fef09c6f88ea6dd0cabbfd7b6ce392e9d998314df2c179cfbf3f7a1fa38f45d1d7634b43f34f36e5d7e1764eab0a11152e7ac513a4226b7e2730d15622fc996752c17952d12f58e3820709aa2191ce1bfe8e96677fff3eddd9f7afe51059530f727957f9e30a4b2d68d8fb349d8b256fd20c6e2be3bb49de25166cdc3c3b296486be7da6c2e209ff0f37260a3c8a6452c3228676cea30a9480d70b0e4f16406c57aa24f2ebc46b34aa389c72349d915ab619041f9a1d2653d4a6e37d2c1a55493f24a3946383b7b91ab3740c8271558586b95d7eff8d24c9d2727ea91a65b8c37459cbacb90a449e873aaee72a710b012469399612c6fe4741f10c52ce1bc79208f0489d84aaceb0734ec04bf62cf847f7607294b8d2d8bcc5c9c818eba6c08379f6998a1c400bfa86ab8bae8f3facbff48b539f4199d80ca6db6392af504f22ee32f90e8ffb929ab2b367c58ea5cdac1064f19089aac0e7392eece69df490cd384ad538674f28132290bbac41f9f9c5e57ef6e0ce60ac220f34805eeb67f2edca5e1b18285bf23f1f6f255999857f9fe16e01f64973064bda2f7afa58e45ee211cce8a573d9a11a6c690380ef1319b1e09699a112cebb7be36ee7d0222ee9dfd8f5036e1c96e1a46460eb2ee0403303bd2d47215a9bf5fd604dafe3ad51e1192b7dd160dbf2abe8da063cafe2c8041e73770709c3c927cd76692297ef09dc81faa57fac2576ae71bff6f6a8d07303070d9fb0461089e650d18376a84231c57e63449b1ea5f81a61306b8d98dbef4512975838687b0ca9be415fa0dcde5ee0a579eee2ab019577aca452478df9c1d101ebe9dc28c67916411efc501f546f8b1c13d3e8dd16423a8966e034e877fdf6a3fe8ddfdf1375b1e62b1633a16ea071c7aa657fa48280449bb80743aed9b0477381a98c95dbcfe5872310b7cd68b9d84eb2a1b20a27ba2a4f2e6eaace01dc71ca8ae4a80487d89bc1ff81d8ff241e2a1f9b6cec0af8cd763fe2cd3918656bd9dfbd7aaee1a3b34a9abf1686458dfdecae26d27c973e01ed69952026a0890adfae0b07bf3ccdfc7d4a61f4be80e1c0063607b8778ab3ffe9c962c3e74e5f54f87567c9398e787c5cd10ab1e3c3774686db5d0d5fe89dcff814306d831818525ba47c6899d51f43880092efc390646efd9e213199494f143cbfa78d77a27bad10c8159265a33e4e73949391c2fd93ede09cd2ebc611c64681703630278c550156673c896c2a68ccbc8ce6ef1a3c716b3cfba03896dc011f012bcc7328ea5f7f15a7586a8d954065134015fe75b6346bc9118f5bbe8aff07727a14310a0b4afb42dc4632346c6794ff9158ff2be37d917c7df4b80b3a5cf349cf9427696a5875813edc5518a95dcc6a3d75c6c33adc4b01840cce099cc3b6aebc4d6e5a4683574d8e41b5c40c06548c6f0b547050414e79637bfad73dfe3adaf500683d409286a64ad05380d3726729a1430020a973172d63a2a61727f7891005bc2d742f0de2b17084cabff7ffba42e4ba65d13ff9b062479854fb896a4bbca10838997b56d45fa6bea77cb98e50522884872a5383a754440e9b2be259386599bf704e6e9b8df61851e3c5f3b0bd53760b4fa6658ccc91486e8c26672aada9956ece1dfa0893c48b6bbc97212e155125d29a55641773b8df22233f6ea13d04c3ab562ae30b14d8839bef58cc4be7b414b430a2abedd07894263a29f193b12b73aad0b5172e7eb47b2b2b8cc5febc368711f3025b3b7db3791f99b0ed9b27bde5c39c465aa3a7f724d8a914589a34a15dbba9a402ac00e577d5b0f67d266e61db14413a3d58dc9ac0e36ec64bda87e8c46832f785734024cc5c6cabf47e2e78f7d0b28a2fcd24e5ba840086a524e8eca7c02d9893284a580000339fd80e90c8bef110bb9907600286bfecf3479ad732ba1f090492666ca15b4975fef13ff89ed941034ea05ed2ec4111ed66ac21b66706602227de3ce99cbcb4c70ab0cb83ac4db96eb8445d8d74312e3ab3deab7dc71ae5218d4cdf7b59c66f2cb0a28911e9c9a1719fd3b4c368d6d08cbd12b2158d4e0ee0a1596252cd481059e4a57ac32d733025bb77ec3eb720ec778c13b30c9d882dab0d299ad95243162526dfcfc779f617ad6c8d439b49594a34b134e31ce218cabbbafe792bf0787ee9f415b29bb990e60edf15d94e1f3938d2ee8a512375280d5dfbb52aab95f428fc83b38d0f0314e9b98fc2233cecd9518ec2643907c1d4e89221ed4b2ee14fbe8c71a50abde6e6709c6c71574a49bc385b03bb5a8ebc4d8e3cf280e41f93c2a99c302efe812afd84b51734bdc2e5f1b84fb9b27c5402f04adfea9ce93902c99e3eb17fa2d3b31a835af4673a9e420da1170ed3b2766d061f18567b21e6303e146d00c323eef96bdaaefb635677cb29296c02e2f0bab8b11aa1f4fd43bb53f89214f133356f42aa1cf8290937eb2f242ba62bf669574e3c5d1592f0ff68221e44c652a6de7748e2527e99d37a8c0b3bff8426ed32a8fa01ee200fb55cc03971ac1d25f65a3573fd60f8342515dbb508cc67f6bdfd439ed1cd107e4567b323fcd81f1c285e79254e3622c8ee7fe31d9bb0cc05f01c1086155797a18ea3d7544833a97d071ba5964dc15ea78395e212809de498b96d68e488b60af93f4b5744a25103b7cb4e57c8d69bd7c2156765623c3e18cf061abd3ccff2d7e5c83cd9939d3cda7634c6b261c1ec211e3fb3a64b571fe19c3a20aafa3929ba6613ed864f20c31998a84001ebde36e0dbd141edab1e94fd23890188e10019d0e63e86f2c4ff431f9132b14094a0659d6affdec444302025dffd68c9366cc884ab06a54dfe7905bd3d1c35f6f824c1c7a533cfd4a2f33300115d9072ad2e92ba90e596ce4439f838b76637fdc07c0521d31ca3821b3c49bd8092117c077cf554fd873aa4c16fcec3938c920d8459cabc69b752e87da5b2340fba09095ae9a98e13430f9138f463996cca1ecb8b220b227dc20fb5d7c3338e49f62ed0ba0abb48df0d905b43860eacf164275a675e535e2e0cbe3dfa6c73feec070ef2f22b793a147bf6fb18f19c95fcb1f37ee8a71ad058ea8e40448690cb188289d58e147408cfe1f9debe28d9930766a698db4db92f036634bb572bedfab5f7a1d60a80fa69177bafd11cd65225c64921f80e271e530659b646e70db53b0c0b495e9887c06b23e6ef62163b36b3923bf969bd9460def8676f22552960c353ab56f2c79a25b1eea1d57fce019b30a432e91ca13b13e3295cdbf1b2cfbf7d23fd03bcf9b1eefcae9fa91418bf2e681f728ea5660ce60c7565ac9cc76edc50f2e6067ad32d10f2fec7b1f34bf7b6fd6a2749aaaa78be4b781525e09d3e8e7664ad7ce1908ab68a71df1d5189aad9ab5ffa818f7bf6826ad797f0f28b215c7fe673c9d5381e55809e614bef8deeb267697e4a55938094a19233898f814e596a35bcfe0c401768b65aef8e229353a54776d9e3456ba18c0d6ccfaffd7d1beb2d1eb53b9c9694e8c103fc5bbafcb2fd84872718bdb9bd7ef0cd87f97ff189917bae1d79526db257a345ada99315b8ae309fddba9a13d54a90a84db236b6c4818faa536ebb68d7ee091270662140511e0cde9b45ebd973c679386c50c6ae84117a2480fdeb11e929bfe12b9bca8bdc3918064abc54f984f0560368c92b37a8014fda3c3bc7e30573b112a0fa1aea2d061843b0c9acaf278042e534f7bcf5de09f0b9c9395477e2da322ab80b2e9997f2bb15fc5b26ad399ce2995cd1041824906a763cf418d98d705c3623c4cc5df0be8fdbadbe2ca05f239f5cfcf5026061bfb9ce75bf954d91eedd3740dcb6d29ba1547769fe4d3ca891079abaf2c575249862d155b39f33edb15095160b10321c62b07369923e698e244a214740ae52ea8e18e3fab0d26961b97a95f0d1f8606551a8d4cd8428d53b0baf617fb0ad69c3d8f8730f3531021ffea8f21ca2a9a1d0db854f0aa244d82ba6e78efc693d2cd188246a9fd3e964cc9f079643df7de37c8afb3d8565bc10450ddf2cc6c931c8130a64f43976ceb3c1dd75b86f24290191e643308d3198fc3de73d3d3adb8366c2c05f55fb89319691e9ff5f1558ffd10c34d96390ac8014a394642ee1e1ebd9319cd681ab6a1558d3d311246045215815bd88fc122a1337270cba5f25825088c42b572c16cdffa38a1ddbc19e23e7f3971bdec570add74cd7f55e4dc68494edf5be16514adea909a908cd06e11d23343b1b770d96e662b38ebeb12fe30e9a38916d5df13e78791f1f8312237cf799e827d1e6bb03f9ba853b08023b3832a2ec630cbbefb53a4faa4a8898cd5ebfbffcb3dfe949fe1753d0f79f5e9ffacdf408c39a17ca392232ad4d771224a586b663981c96abced5a809ee24f566cbed74d94107ef8d8225e482a1be61b82abe959fcb6eae5c1ce4421994346c54ca28a5670f442129ca7b5ddddb5953a305eab65031c20e02e58f73041996d0da04ac2327d32e17f213043472441e9921e0518aa0cf7d2ea536f14cfa3077bca31dc444c2b037d4c5572b9335639e544d4bc3936c87b23e0ca2f5aeea322b890e1c834926c3d168efa124e94847119347d1b5b282e9a9a918df35225c381cec61f49f4102ab266f0d81c71cc917d03c01fb1f4e61a57df2806b7637c2b0f7c9a7592b347a0ffa0f655ece6c0ff0bc40203563ccee644684ef3ae25f73f1fc26c1ae3b56eed862068b3d46d169e5dd1cbecc091d9d3e82c66b0fffccdd3f10f300bf840e7433849fb422010efe9db3006c3478914dae1f353ddaae0b7e0c4973b2cfc328599617f3d373ab8fa9129f16cb3faff3d87bf382be7560260dd5e383b982aa82f1f6a0f17924491e1654e2780bef13036012340cc2ab8bd0c83ecafed98cdde40a9c2d258aba6dd7194eda8fc77024c33f0ba458ee4f1ca48a6f8588b8c9121f80c939c93e2c5e4d642114ec591886c2ad18aebf7cb4cf56fa9ba285750a9b05f00d31cdac1467c53cbfb11a0d3661fbbd98dbdc81475a0951d08d91480bb1ce40c5c888f014f0cdd24c99bc5e378039fbf42b56dd01224cb613dad6550017630cd9c457655b69fc5042649a1f51b8ba2a75a20b2125ee76002363eb29708ec52e0e43303afe9e8350a7b58464dafdc850132711e6386935e41f844433152877611d205f9eebfb53160c34997e824b62a7df32b9bb0d7bb4ae3a2177364ef2d7eaf03d9c68ff8f24454391ce8c586843ddaf2f4be36fcce9b79be35b35a24626b6b84c6976a96a64aec86c0f8ceb1bf103570318021f3d8c72e43989f83e818e09d53a12515f30341e0625e3b4afc1148895e3aa6eba1db015a6e9a45da8eb5b2fcfbb2059edaabf358994774884b8dd9b4b46ce249182ae7023f53226e455c810340ec682ec7cf160d0270be37a8d101081494ac4b57032480f61fef80dfca5db10a78ecfc24fe4e4f1d263eab5d248a6a153523230687158de558190d0e5a7a2aaba3c6efba6fab33c24b907465487c5af3ed01f4d2d9dd5d8dd83a7a31b0577603a475b2407772f515733722ad6a98decd12abdb598dc6e97f75fc56f199bff81f83791a94de611259c64fcc311bf670654413d5de8b170f8b2c234abae0fe26225c82a50209355e629cc60a62f1681bd459ca9dc1dc0af752a5c72bf6933154254f2e14cfd1776893a1e84d51885260ae983caa53acfe4acfa7407b47227710827dacefc33b1dd9bff2a00937f13fc5f68e1447d6c336bf3bd5da0ae009583346f8a5573b97b8383b4c344d03a3e8d6bfa6ec2e5b965e8c1d4a39c4e5d7ba57290d89c68aa97b128781a06eded0f5dc5b786725c79c83f978536a27a98370b91a490f497c8cad9b5f84d6d67bbf4d91f22d9ac0ab78bd52e0030fb2d971a53bf3c48658193887f995370932bf70527e9e70a3f59b0cb365f53f813dc82325726ed167bd08aeecd98c23ffe16b80bf3e6e90d993d253aaa6d599ea522721ed470547dc987e02c5bd1248cf486acb86b5136a8e330f68b9f2a4c37153b233ce1c8f1d7a7c4f83007d0266115b94e8feac7bf085524299d9c1956b9f2bfffe61e50dcd22d4051cb0d95dd6722b52dbc328034e3f8fe5a1aefb447002acc16aa4d444964817625a8a22e6a190a3c87d1d9783c2d527cc408dc26534172f116e47fc645c540f4e4fdc1edcec645ffeba041ebc04c0c47713dbf231d9f47eea061f797f5f8dc5b10255c7d3c778f08f92e849ddf261c549ee977c067a2e9a19fa7f365663d86022d5dc3bd0e204718e9fafdc696dfe6e8c32f0d041fc2306ec329c13dbf36ad03d9667473e6f36aa89fbc2577805943b7ca35478250c8f7ef67233c1b2c4da26493fa40a751f3c554c65bfd69e59f2a09312a3a60e1b22ca5e83891b2d69b1489ef38457f09ceff4002c666c95f5c4d329c1ba68ad198b9751c5ef8d5538991b4a7db33211bb3fe6ed0aad4ee06799393e2777a9ff39c1afec9f54661bd1d001446cc72952dc94b533ddd348c3d9d063ed1d81c3573d8aa71d10ed92e9e5d5247241602579fa6f5ed3720f18e9a723d3710d7f19d020350e5ed029f2b7d138a4d3351357af0dc74a22191ac7d73a25fe7ec0a651c6a605d7fe03783c0cf25d4c79264","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
