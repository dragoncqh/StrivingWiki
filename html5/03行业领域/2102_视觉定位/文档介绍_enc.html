<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4cfce4a0da1438327b1f401dd57f265f2b67b530b06a6648cf7284a2917d6663eb68b94d6e1002f4a54079cfbf6861e8e3de574c14909b5a89ef99cab4454d055435b66a3db9f12139d52e98a7ef538691c1c81a37a9840bcdf3ff49f6b0d60804c738ab4b86cdd915d405b5afaf17a3b96359b9527376436703b5bf9483a94c85ac580467ef6cb1484165e4ade40c67f7a898377b3806469e327075d820d04fee1e1aad0d1260cbcff547a844060f66d5ec368343bf763fccdd87e75b5ce282b7f6f37590696113066930dbf579754566b72d2cb00e4a8bbab54ddda5dcb21bed582518dae3c31c8a9092e89facf81547005cc24d7225bf27d8aa64be334b46670003c4000ef3df77a1fe5a3c2c1516c305518552979f6cca934c7aca2ad83c642bf44dedba0e6ffcfcbd8300f386acf3abf8d5a2a3559b46be36c80bde061ff4aae2cfee3aa247ce8742f39697ef75dc1f8af7d7b9ef37a571a114b5f0a538ca126dff002d4fe0ca43acd6bf6e10f652f6bff41906d0be8677936da0429cf00760e639ad7302345ef3a196c39f459474886332dff0c88351040a9cd4f5057e2c3b6c23323c443ec9ead68d17054dd6bb09849ce6c1e5628dbe394059a93ee8172efcfd542329a178442a8793ba1502e1b94d15358a0d4632274f131073e266c6a21ef1693718670442cd97b9b962f8bef7aa5bdbbd83f58368d4ecac390ca5e92ff28c122ce75ba0cc5097398f991124efe3b1603fbf3410d982a603deaa09a29c31d6e72831375900fe3f9fb05ab5dfc24c04c688511da765657555dc570227f115d3f69ade42f50e0b0e570e99ef5696dffbb73691e60da34e7d78fff52f18c7eed40c7e414f4433723b16c6421cfed5771c245fa1488a5c1fb128b1e99e36017f3f756311b3a158629cdad0c132bcd18bc541696da8f9d195315499290ab101a941cf285394df90df5cfa89feb1b59af61f31b9a9b65faa897967e55d248bd7cb9b1ebd49d950ddbc4a3863cb0f95baa94326858787b973d3033f670baa0e9caea6a1436f28236b97c6214a9ea591c142b7b7b8fa02abd427c878d97012a1d9754fd80f2568541bca41a543e69749f68a938a77270ec7611db80e416746ba0df2ca955d2cc5ae797f1f9dc5a1e2c8541db8d97650f56155bff4f80b0b9e1099aad7c4486bbe84128316ca330efcb2447647f7a384c39e2575f742ef94e60f984fdc8e4f800f92a3dfa880c5a765f3a4bb1f72f39c23eda24d49ffdf5690807576237b306a5bf068cfee938b31ff67f7d03ed67132f79ef28bd23a8b877c2942455dd8dcbccc7e6feabc4f0dc84ed21d77ed48022a5a32de099688396152e1cfdb507eab6764a6b1cf7c4c95047eb9689980b1d898073df5ec25ae7b8b8a4db0de9cbc3f5ff1414040fb848c67fa4d744eb451b3fae8cb6cec376d42fb88b535eaf9d2f1ca1f99783e6c8aa9e8ebacd27352bf53c21e4f857c559ffebba14aac076229d1913b691d97d342281105c3b1b3f5314c07b2bc19e9eb50abea51f61d3efbd998fa41806bb35157196d51eef5c6d171819a68ac3dac0277c260f4ff0494dd319b3e77fe8949361ea897756129865bf1582026acda6e8f7f0d97a94d1b390ab83fae1ece2b722b81af0c0db55b806c063f1adfa59d4730293339a6a55ffc44366a94ffda1b3ca71321089717e219d141c1ff4012005ecefbe2407c300acd3ee332ad57d1c58a33cff22f547d28dc7b9466c3d8dddec982e4a4389ea5b9f6dbdc2337cbd421f60ca5fa4c8812e83f244fc6533c66318f417e9f0194ef8c82f4a896a04416ef7c7df01ff89b966b5151897726f9934c82bcd44649b0fe1ef9e9e8d43f4631d86097d1dae6c1a13b4f494163422f15f5c2ebc10583d40390dadf1caa278af5668115091adb7f35cd7d8db7e48504fc78d97540ee9b6dd079e7fc1b22df2f1605616e67790f1793f0b5869bc0d1b71e4ec8034a45350838c582bc7d6067f205f6157fe7fdce61d988e86698773df330748356b2d776298c2b57f9d86404141ae544f6081cee5eee02ea3f17bd237d4f65ae723d27dc8dc9af67fa37c70490d9b0b191ca3c7ea14ee8920bf90b84edf80a751319f3433cf039de59a3a519f08d552aeca2a54647e916f7fb139e77143063028ce8052d9dfdd0e785afdf580260d37ff4f75171d0089ebd9e26711d91edb176e565b5355566bf3e9748c7aba75b7463fb307f129bd7d509703881e0487f6c91d6bd88a22a1a174a859a2d3542699e1133a00b80e5e63bed2b9de8dd046b1dad120587a85699d2ed99cc98d104f53eb127675bc3a5377f00933d03130b2d581e0e195364bca5d3b5e88d04f9271dce638a21d0f9cb62d61e97debfbb2828fc753776df5015cd9f6b9b5d3dcfe23eb43fe121989671849896023d96b261da04bfae618f890c23c311d55003d92edee4f14ababfc47543ffbfb6028467adb282eb4fde05acb44d814d364e32e71fc69e0cc624cb3583a77d8c5bde52792d62ad333dd95067bd825183961a9e7f378dc8236c93e0e80eb58c8e217eed27210b1af18632a6ba11cb1df314d8e1fdcc22792a1478b63877091904951f375352b48602a8e377de9dc3e1ba478dfc242a6af250ac027dfc4683a80ae314505955a5885fcc1999c21b5298e3516b6bcc65cfef230bcbb6c94fa512aaa6083a43950b911cf432b66caa900f638dbf328d9cfd591218fdd176171be49ee8f78224317e84365bedf0cc9456444c6e3cb0acb477c892ba0be72e2ac4bbba20a9846bd914abaebdd23259fcf81a36fdf438c25c4abed1dc35fe053a216621cde9e064654f57d72ba539e9646213bf281564f97cc4bb79c427b524a344106092d4373c2a23bfde2c0876c572712bc53576f4eb558141f5a9ab3447054eb6c99729302dc5de96316cbce7cb75f936e1c09a89c0621b4483b0fc6ab9e41eb14913462bfc56718abd7ce4c1439ea04cc90eb7aac6b86bb150c0f47d042205b49e52e708b9fc88af74ae331fbc4a631d8f26663bbd175389e656ad6894a156c885462e210359c1cf4de32fa36bb92ed3278242e08078dd9e90706cac776b972188fece6800e17aad8f07be88e8b6f6f8a414e355031d4896ca420e7f94561c2a64fccb670dab30c2802ae4c62c658d357ae8b693f3b60c8721f90527f56a61f7b6b22079d23ec22e20964f5e0d55179be384c6a8eead1ec254945ac35e7de8560ba57cfe0474a2feecaeb063c4f0b2e833ded0b047204c3651eb398abc44fd6d631109520774001234b5ff9281d867997ac44f8305ebc4d94c1a930c30f466e1d8b7192f34ef73b8b7a7a1cc9cfe1f44fd65b0e14507b3ce0eb80e6d08af5ca2ff7fbd0dd6dbeaa7ae84a4dc7f7101eac5117d06a8f47a2ca3086789b532ea4e62bf2ef566a51b944c2fa20f7d5fd3566a53dbaa13e243c68ebba438268d519c4c5c8b0744645cff60c9fd3c8cbd95d52ec24a3341513d9e4a6bf6090c6b3472a8c7d049900a1d4e240766b396e0715f301fb6f16b40ad62fe5af94a4856b7ec8a1a4488bda681f679ae64d92a1d91006a2f0be1cd938fac4b81ec193fb49d1273d23ff5709cd7957521f95c4f9b899204621a3455b60a551a91b7fa2154a4d2b88b7f549fd74dfecf5a83702c640d48f6d71bdc8e7c1ddb25c467712061b724a182a8b65468eafe8790079c31e019c66817a04ef18a8203691082de59d33a81ec89aa6b89643184db2680342b7feffa4c88258aed0f17d7d1da9009ae69bdfd99b8907501471f8bd249d22aab1b82f1c1a41592b7f8212eb614c7fc008c2cbf6f7d63e52f89c54588d8db9678b7536d74ce3935c278cf5435be16fc90697b87cd5df9b292ebb9ea7bd9c9e37bcd02eb8d94a7d35f5e9032595b7119d232333e5b4a3a78f50e39c6dbbeb5c69f95d9cc8b2c0632db7961a68cf09c035aaf9c8af25828fc2e6488da84e493a81e3752e079e726410c08034e63c439418f1b58ecd1ab7a97d84eda4d046b6cf31a1705f7381bfd85d376ef51e5b7b440be7f179614f81f31b193b06444ebe98b6b771c20bb7d752e362a286c853f36caa2d2ed7363664fa981644f2ed06eeb73a5204892a9ed499a931d45a99a9f9fc63ada18ec7de09c7ca0989a88d91313d33f08110b9fd4d238fb82ef7e7c8e81cb2d0e02051b9ffb2a2d47a9e31cc71d52090046d3aba614fcda1a5edcfb7cab519704fbd89febb6ab212213ecef6a72581380de336431334b17ab34514d692983dd76e5295c41852faa99a6764d82a0859522690ab0ccc02018727768a3cff9719ec46871e44b45b906c22cc392a8a71a06b26064bda7c36a4ddc1f97b3de385ddf3c2d40a82bcdeaa218125339070a2f62de5f60eb879058396c7d3c19a4e059f8d40e465a979dbe498d3f05aa06adb05e98a201a2c06962f65e4196054c9dd44f2e5518b7433e0e4f36a56a8b18c27e810928eba7662046e9dd233172f87e43abaa96d397dd55eaf575c69f7e3aa9b02d4ec2bc733933bf11b4c0665c28b58afbbcd32ba45754482842ce98faac31ea0899b3efec3ffd09730dbb1aabb36fea947c7c0a94d1ad586bb267adc8f67e977c5f587e8f5ea8ae9978504de87263e874b14bf477f5f8b1b81ead46137ba9adf028bcf7fbd3e1640bc3a0fb4690243b5c1a4f13492476bad8bbda63c134fc8b069ba7421202f2a15b2be0a7fd22b2484b23e869b2583d18eaadb441513c21d9438f0e218e7cbb5b8dea6d5ee0aaeced6d120d0e4324b46ec10d679023dde98e83061497ed0fc1fb9a708fe28d3e354ff521327b942f1dce24b75e3801325e32d338f98f6088bd028662a3df2a83e2210baa9a90b3092d3cacfa3efcc0c454149372aa9b7294e310f3b43596c154204e4868116766760a501c328f8c36af141a5590553690881aa2e18173ae33011a1c30b986a08bfd7cbf41cc9ff8904c7cd1063679693675f24acfb3e2f38fd06acbcbb4a100dfc141a9eeefd4b0710fc8825518b81e6909a3ab8b78dcff881ab65ea1efd5685ca1902c74280afda3acbe5c0bc3f14a49e4fab8b972cf27ee2f3d420a36a924d10a9abc7e5fcde0aa6401e7975e55951af7ae875374f3080383188fdbe9e86e008c104055f9ac20d173f7c0b04efe1b7d62bad82192e268ad3af43a0377b3d155dc5d61904ae867094e64384184a252c011e3efdd1b6f101df774854f2d54a309e114e5c193a873ce26c2de75c8a2469babec58565cc88af654c45d96242ab3c1455cc4ab9dd7aa9f326c3e6a568f86905e058d7deb3d3426e08c3121a6714e5f87e37fcf3a86f48842cb4ebf33fb4d65d59f25d951af06c6fb0e0c2cbccb2160185faa05ce2795ae5f07d99cdfcc4c94782d0fcca95d3fe7a579b880cb9510457e5de207457915089fbe7a8d377064468ec99d62b7de5a1d53e3e6e4fdc2f7bec3b782cfceca51ae007e75b161f1683d812cdd7efd21cc8af3fd787eddfbcc51cbc0d996fbf5041933cdd44d7943f0a43a2f39dc5d49c7bbe0e4fdecce0710d9acf16b24e2becb90858d7becd4b439bc3316d10729cdb445ba25d23a8ae42ddb2473a9424588227e4663ddf579e123f55a0a29a4f6e6dba994da75664965aa8e5ad1f0f7685026cebe82749d2258f70ac46bf931c8a4630569e00ed89b3ed86f9c3c42b6f83dd4909e8aaccb85b603419bf6d64e73352e1d7cced1ecfc0db821e64e9273b62ed7f1d26d966c7329e035f33f32ee4dda274e3e1973b2918eb69980f252a22bfa3b8efb9b7b4000ca0bb002de2422a6146c25e5d38ec1765d7283c499bbf8802f542d3d05c1f427b55f12175491a1b91cd8813ac186f69ed748fff54550b18bedbac5e178bf64bd1bc23636718a597224440a8026713ac87d897e0a425d1e4504f3e600ad14f48e6f395e9dbd78e5c3cb1932a41457bf4986b81e6e3bb0a8c466cfd9ec8cc36a660e729d962db07f61762f442be68e4d2896fa77dd08c0e3c2d71c1551d7f29aad0b3c2e0c4aa1d833ea744d65ab064ad5e1842a976fc13539ab0b5462b14a9a4521400f006873dc06eb63574e935c40e87dc5c06275d2338011d5877f9ac2e34cb24bd64ae75263651b71e01d5929564c300fb805ccb97de1f616fcc13fc4b925458a90b8531c9792c92c660000ee9793c90a26d09c48604dcbda79c2a81e7ed39ea7b674bdd040c133ca463c085d1fd79161d65404eb8ee16c13a963a048fa19bb6b7d7c38d33be109465f5d8ff86f5ab132a2181227e05ee516f0d0d169fe19d304b2cc02af4f895beada0c12a96f172f677f6ad6686f44cf9658c9030f9148f85ca87d9cd077e3b32a607c67c7e135efa17bc17d63586ab45d0726a8ebe671d207ad1a6255989f767d4dff6577947f1f5fddfe58b505c20a46428d21bc44322e6c02557ee4e54e000ae1fa9b97267ea1a4a81d7e01c17d37b3b22ae01b367d4c51bd1ec8c175b55c5300fbda03b33bbd81e9ed357647b6c7bf40548e6932b65c8aa7ff8b376ada974903f87a8688d9c8665be80d2ec79cf45202b5d76687ff8167e55d27ac3856971f18d2aa7cb3f665f3a6de3bdf533b6eb1a24a5eb9d4564976b4196659face081e0a6a9179bd27a3c5eed1f18c67bf299cf58c73f6dffe900d1be9d45fce1e018bfb80240fcba1d83c34de53424f2581706507dcbc7ffada68109ffebfef6adae5861fe6cc816767cdff31b55dd2fd93e17aae5c259ee786f3e0abac857b46602017be80df9b1a3a615bf19223625a7402c57830fa77b5c78c97cd0d467837b2c48f0f746073c453dc287eb3839dd9df6a5e0c01f24f3690140ae781e0e5d8603a05511a3d13b1a9e37befd6e0d6eef2bebf106662ca49c1b83ec43d7a674fd895b168bb2a97e2b23d0eff530b090d09129ef97782ac21e7fa0263b262376fe0d247474dff6c205f8da520092420228a89ad2e577564181256edc992a7a57732aa81d5455e9e5d04151024407b8938fa9ea29fc94d99244dc4dcd74544cc83fbcbbf4ac5a597c2d9ade459f337343fe69bad354c65e0ec4d54b057b21ee52e7ce0ea844e0056d1980a72d42dbd3f1eea7f42b0b13aa52fe9dcf06b2d6e24c7a55938d839e9c8c2f8aed313a05a9ffa0f6ba44a10d2bcfec614fe31c76a6d012f766a926df7ff43aafefae47e05627fdf99ebd90f74f00f783e03dd2c4ccb4a727d69b5e7b01610e6fa5357246ecca06d19164057f3ec4f71266779514db2121f4ed9c9716e1576c893e9f9d1104e289f3b39742362851c9cbe8b2eea8e155ebde728e7d20cfdaf37e7bf166baa5553262478c244be6afb92bf7d9bc0b604a251915a2bd6bb287424ef944565e427eb1d12874258c89cd8a7c1c6abe5131b2af33126ca416e3f687a60678e14550925f40a73a94ad8c7be0fa0f6a24ae8946f04bd84f7d349fd2329e342da9519646daf69c4bc1c5119c444f9610c376e31f404b9e61fb6d7291edf5608e84d3e7b18d0f034084115774b935dc94df8f2ba9b5172dd50d872f3871faa97f24b0ad4b994bdb754eac499226a96e1ba7eafe135c8acc2b7a250e145c93148a79402cedea65d01eed7b4ec1d9747a94c208eb6c3ee265069a16bcd05dbce6bd843d0947fe1f4974b35915922c3f2269d7d78f2b84f708d55a22d797c3cf8e38bdddf82972869466c022c615d40682ad5dec40f50d48d4fd252a3c42e91f8f3fba1da453755b29ca038ae69a13e362658365e63f69e20e25c3e49daf7d035bd670322074a5f5db9f95e68d720544be7c709b0e2e3046b8a6b6afc9345fb12b63295b266da4482240e4d756d76d3505b803e213bf45f6b80fce29abc774ac1a8f8579b063b62b2ca6c93eaa7833f157995d02c978bec77626452054d5be331113a218b8cd92f1df259861e6f6ae2b53b9db5d3233615d0c7e0ae0db0bc2b1b8803a4eb3ed83bfd4aa2a570671898ab1a436d1033f06ca2c5a0c56bdf879cc38aaf6e00c8beb15916b7afc99a8383547e48714e7846cc2815ad249ca0b6a7dd3d17062821928e7f3982e27252e8f7e20a9f76da179078ee8091cda464c660b90dc5898f352dbce4b0b871256c68c2c395e402da356fc96cb7d9e7b845f654c55c233bfa63359adf8f5be62f925f56a0eb9d7d80d3b4e515c842e3d6f3ca738d3d4cc8dae219f266d654f690f965d0c40ab5cc8d8b4903c46426f2267f474fe3191376ce203eb586eb14f04ea1a04b79140f092241555bcbe9fa216d94498b6051fc35d36a27b2188896a2a6f790ed1d5d30d74647c5bd632b2d9915f54563e24c5620c5f4d69a765b3b664754b9b657c421802e371a450965cd87563460e2fe3c10f96b36b98f697886d06da34defc2549f30270a0cc16232020f5afd18f14ae44d647fe69af69d5613e31545db0dfaf62dad49f02d06530f0b943e08f34c02b5db3c8225b78617d81587755093bbf12500ec519d9866d7eea9b6294bd79eff4009544033310a6919e63ad726cb207eefb4f5d030500e97f034ea5895cc15ac4089b02c66174e84ddf6ee57f6421a8d145c5c4dd6c2c24658b874bb7d7c3bf2bda551e406b5a3124d71beb4a2a4e403d581d89085fe0122e6d67ea0df6017cd33908ba198ee0db04d9936b4eabc02360654c66de3f3b80bc6f7a20ec053fb8dd94bf7cf799a92afe255fc5e51f5fcc7a7d01eb6c00a592a6c3407c223bdb0ab0c96a8cfb2a3ba96cee2790a390ee664875fff263eccdea4505f2c060915809fcaf095b6de5e5d73d32f691c072f058e0c70329444040d3338ce6313dfc58b54297b711453c9dba5843002056dbdc1833667e4fc4307909609bb77d8975e9b1d4d9fe42ed4cc01ccd03d2879fa2e5fe7ee7be1557a9b648ee1db6d73ce72bb1ac343093c3fd29b4b19450485b7143989cdf8c2329487566fbecc4bb9209a0c4c42e39f54de3e7a0a8d7de0a94334e9317761ba48a69feca60925fbd1bac2bf6a8910a845b02f485a3751b74890ded2c1795e3f4bc0d23c317321678abebe341a5eef44b22cd23cf2b6fd6359d92737c443721fc076039f902c9096c539501bc4d106ba16aa7b26f0d4a38fd982cea2901d03e034d753fb59eb6ac3d1c364ee9b657d8c38596fce3ca6765f74e6ae85c7ccfe72df4894bc745edcbd52fc28a1bbe7b1e176c48102f2b53518922b1224d78686262c94b3c3b43d62a4b738d4e993a69f602ac3e9a205b8adf6b31c83c51f2995228ab055fda24a4c3a983d279519e86eb5346f7b08a769f0f6165b98d33004647a5e79e5ec62eb4fee41f9fb5066d2faa15d9200977c2c62600e954e9de21ca81be1d7563df5a93dca809b7100b866bcfcdbd8d27c60b5fe1059173577b0b638350d825f740115d11d740a62e7cbd65e541479747ea540f85356511a246cdd0e09bb3e56044826ec83bb1f3288f98f9c1fdca75150a50142af48154d9ab4b38cc10e83e2fb389190f0c94dbc1beba0a4b8d543cbe70486dd5bea3647c9eb142555379cbef7ffd77bb71202a3e41c911beed5c56e46feff21e114a856157c78df0ffb40b2d0838438c4470240a50d2984e8d369d81682c27bae39dfeeb8fcb1c56e437c2f981ae21e6bdeef621dccf7bb560a776ce9e04b5ea383a18dc1c5dd576531b1f8e86a7f1dbb371398d6ae6eac1276a573ef90a597080e64861f6fbbe0ba1291acb33ca75786ca7a2b429d934cce35ad4395623f8695e895cc3202e931a011ac643e399d2673f59abb14433399de5d926505fa40749681d2526c40c37ddbe6d479e9d28c596cea45ca10791fdb6446a99615836b209045b01185c1b33fc14ab3d60bce3a8fee589b8c21a500cab0d2b30e8a2e0a90bcdd3f1d059f8175ce2977d2423f8236361922b032e9d79976e56ea33f70868863fb918e7549cd1779a00736c01e0d48901b28658b0a045d7355d0fa5af8e63590fb69a45e4e00333e3d40e4b74d67f1c432a367d1ff23c0b1e4c39b4640468e32f1e3ed85517798a0707495249a0ab29fb37d74bdf1640d10aee96312512cc5dcf2841fccf90429555907704ba733bd79ccc68099586a6d6b89ab6e58eb772e701f0d84345f5b2cce1e59177a5f0097239aeab424b4062f1b5fcdd581ba2e4ff5a7fd264d94ea76e91517375ed141a54c6d2d23d0d9a7948b5edb9db2a8d4f98816107ba348ab90f8dab862672ce77630c4506adcb53227260f7137dd0e95d3b67cf77ceca2a66326f87405cb020137bfa60ba0dc7e894c40b64cd6d83c8c61e44c427c038c9db1e86bd14752ff1625e50b82c8f510c6db5c62b97751b69ea9948fe985c11579cf3f6b1f451d5f6d3651382aa568ae08933d5e4d683874e103cab2b4fae8e3c02533d7d59ad3c651a1ef5259de4ca194b7a87b4e2f7cb53f28b92108393528673a5154da41af245c66e597981ba7b20fe633b388e303944572c8baaa58b4606193f9795ad5eee2d999c6ea107ed0e08c7b59a62bae1678e5fae01fd8bf2bdce6ec558b7a189a21b6d22d5ca7e173bb33a18b88a445607bdc679c940b9cdc44c232e49b178c06c05ad7a53b3dcab1b53738a42fdd79ab1c15f188adc2041ee1fe2c21bd6291eaf37c90605d3eb4d956fd4ea2c30c6d9f30515a971cead8ec90d05952ed774d88c78cffb86ea9f4e113705aa9ec90c9a3be7c76db22792fe054599e4063329f9962bf97341e0d1f35aa6fb767c2e7857a418361ccebd9aa73b7996501ea63b29b0581e090a39d5f7a3225c6ed2c8b44b7ad94a2acdd304a838f402873c271fb07cd52dc09096ca3a7a94622e7a6a365b08626f3004bd0793af7d72adc32993cbc16d416492858a030deca2068df9475dc727d56755eaf13210bf120272820b5195764c86dcb158d48dee1279c54c04b35c54177bf385a738d2dad7a0c3b21238626cec85c5211105fb04abd570855ac1f1bbc5d9921cc4f8bf450d49100bccbafaeb13925b69e21f88cd374a490e9cda92aab1f18276341fd5d4ada2e5d9bdb58323502bfa46647253c010f3a642079fe3045cdfcd451ab221c1565a41a277ed8cf9d2b815b8f451acd2a9c984aaee447488ea5ffc3e2c41afe78430aeaa5f5bd38d41ba8d54e20acad0c3ba0d21316fc85d9a9d4568d90c9d48e98453200ec511e34c224e669a164b46fe3a9d36beee20dd5ff42fd0fe69004a06c81f00553153444dd7a022ff6e54a73b356f2606056f4986ffa430c468e914a26aeb96b650277b11b256c8e985cea9e059aed89a57b5289fe791e35035f5db87c714753abbb7c99a16862ea3b9eaa3aa09dd7dba491b7a666120a574ff87f921b556b19e4a28fdfc4c5d6668f63a224a336ab8147d03b690751ce36462608ffd96c0f5f07e93176ba6455e9242abe7b823c13af49433a196f45f669df2090827de4b768d9da1df53d83cb3fbeba1084fc62c68f1b551227a6026361fe3eddaf1241542bf618da4bfc5b1d05d0b0935834670f0a6acfc2ecb7c55715971c0a1bdd52b613aa44022f75211cfd14476b67add71a547edd17f7744e038c984079d07f812b6bb862eabed5c150a66b874e808c18a5e6d7ab5240a424477c543ca05a15ee9a6f67d49707bf1abe3190be62ea03b81c178e88426c7875669edf3eaefb62d05767a73b47cc0e443af181b82172a0d687de3d6746748f68cc9dfabc35672569ff37bf592570bd91099c24ec4635e326ae5c9ffd590a677d1c2ca54719178ecb4fbf07e41255ef782acde8ab68330b46b3ddd637056263e4d33063da9b81458dce147310d44c67d15a6d384d8aefa94cd9350a853c55a93f66043ce960a71aba885098eade6976799f52a9aa6653637efdcc2c0c43de30729b3eac6601988287ca71d95f6cdc66ccd3b3b0887088d2e6d094ee67b216ea149c0050bbaafffb2b6312002eef2b6a15fe9084966d80ed0f412ea42821cc2b0e6d75bc9dd53f897c4939354d9819b962063aba4345f395421bb1fddd9d89727b20aa872032814c6ec8d916effa491996e9495b902c66f03030b6a5a014bac9e4149cd9aec52afe9cefe3eceb98503ea6d240d3a3cb0a70996c9a6a0aea5cfc4bcac4f8a5db0b773cbd730badef0f187648e0b6576a006c841a4e88e870f7a64b643e5dc313971b5ee41255ca0dc62c8b23119b09843e34a7e355bfc2a26559d4f59e788c35fe669a42d148d06605a5bf895c45943bc58f4d27f891004db60637f6c7a896bb784b615f5b17eabb4722e200ed7b6686e49702315e717ebec9caafeb1db8f251db3bb631596b895abb09da88e6f04eb36c82819cbbcc23486ab7ec1a0bb8806c1d025b04366fe6422c228e7a5742e454b83910807223b401843a697a990ad0022584c1d343af7b6b56a870758a130ae6ea4c353dea923e1b59a873be3b875a012e0c0ccafc17b3f2944724ae16c83fc27704184f03a7458a9b38f986a33628e64887bdfc33b5e1badb1c4ba918f11475bbe96c4b639fe6212ffa80bc030de01b8fa00e58af343273768f9e146de81ae18265c6c97326dbfa3977a5a3d07d422e9f0b5ca82ec2be30bbf83f7035247726eb123e016ca7483e958ba1ae9567bff5a37c1f84148aff7f98eb2789f4189471d89a4eb03f60b2061626c10d7a9197bfcf01f13aac64bd59234357a21ee75ac268bbbd496a289fcdb38999c03a7183f49b6c184e53b51588d48365d4185d7a883c48f6d42c1a57809ace14975f5a23e1f0a97fffc46786c915ba684786d0b515f8a24827744e5addefef43e9af38a9a42378b51716e7a1483494348dc97842d8593215bc6b22cb3ab799f6c2f88fdac8379a182d44f9fd2e39884adbacdd2f8c8e58466879dbb6d8fa2bc9ac03b83b9cfa21540e7f6b0543ca01af59eda14513796c1fdf2418052b423124ce17a8f0a5912c82eef358f570a4a7f4216edfbf9c62da30fd1b143eb261f52bb0db19d6784810b0802985466c3667302ca8cab6c64e841f742a9c1c80d518b533fede4a49cb73cbe668589611742d093914c9864b2d394b8f7b8ad217dcbdb968bb80e83d4be295906b2de299f65a06ad685e3498d887a74fa39bec73fe8a8184856f992e856fd5f71e861ac1bb77d8a9432a848b9deb513cec9a3e7e18c4860d66474f7b10c51a9ab82e03e4498cc6e67027c0eee7ad357d2da6fc33780bfd879aa0510431df87aa121b44a9f3cd7e8e65b9a7943e0929c9cba8e4007dfe126a31ad8be765f8022e711919a21b2fab189c71811c8a8b0e2780a457a84c03ccdc21b6845f5ff71c8c65ee7a12572c76122d9dac64266d50ece373a8c4a7cbfeefd71b7741b5254f06efaa726afed89db5155b320483608602a2fdbe819430b9b1221a213473693a780405facb321ad875e46dd4a14cf3494a9b405d1a68a6b53394dcc04ab2612c95f352bb45d961b7863efa7383b7fa1f18514f845837c32276d6f48e48783232fcd6cf0290c50fea974625bcc5466705fb13173881d9dd22b22a589e55ead1c23e2a19c263b99983f64edd6a44b769070b44d63f78ab62b3edbf832ad9916ec0faf21968bfbdd13ecdacab80bfb9e5af20452f9ef61bd2b0fc04ee6e883634bb43f7c0948babc650964614","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
