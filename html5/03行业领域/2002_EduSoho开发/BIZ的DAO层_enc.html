<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19ec6efcdc87473e88e0bd0111a56e23cebf1311b423f98fc91b670f057a20ab179c5428043280833c3ce19aba214a2851ecb887bc005983ffec074a27931eef7765f32215136c12d02d2221fd78849a71248234154a83d5f91ed22742f7833421a6dfee917ebbc19767e04a49c1e1d8760ea56fab2eaf7a96383603b86cdd1fba7a7cc439ffa28296c01dfff2757b8a29e9ba411c6eb98519b9f211394d5ab36f00c85c15a3d6fc49f3562a8797730d38e336070a9cb4127b8a6650e9743f28e7ee4f9bae74893059a72d19cfcf8045c11f3bdb1c8981596cbf95f78a0b1f0700314c549183550ebf31e67fac3dff476a5b35552d1789c02ced9e4caf3c133169465f2f96b56de820be00fb11f3ec5db0a17909faddc7868f2178b8f3b22f26dfe84bbdfedf72cbc5ebad7cbda46be80c2cca692f2803b4ef4f78bea53aabff24bb8a5fc1692112be8389815b39841279edd30c504c47479cd856862e0b7266320a8b661c7a0ed1f514050bc45fa45e6d635e200f1a7222a779bd97e75b2fb5ecc71218a5bcc52eb402da6c85c8a1698d3204fcb1ca7a21ed0c452983227030c12572212e82644529546341e58159d5530b7ff44b774b4f21fc4bc8d7ae904d832fbd208db3d08ad199e2c250e3dfb97c00a509836556b352cd9221891886ee1d34c996cea5dab7cb83a72d21481129ffb0e96c3b05a29188abf57048f45288889971adc4dcf35242f06444fdc657c228a30dab4c529d971bb4f28193da57f7f7c7607a67b837ae5d657a4295f8e30e40fcc162c69d55c1124b4bc679f4bf36c6178c6f99d589c1419dfcaf9e8fd932772af8121ae81e6ab938c76a48a697fdc063a434b20ac8c9e06e028b4fedf95f594cffb55f5cd6d14cb9127cde74d3680fcf9fdb9189f5f82b1129d216ce9be9c0d38338a13517c1dbb59d0f7157f776191cc63fee1e3dceaafe57d6d6162e2b3a785380eef8398eef26283aed79a0c76f3637ec97c5dcfb0b5b7fce087ae73da8853461357a2b1593e1cb306d132d78f5b03eaecb5537d0ccd90a626fe4db485155469e65975099df3279190f5a24913c4ecca5cd055be7a0c5f15a1e85b5792a04bf3782f055b6acf310dfa0fea3c7ab00b906f75c6349dc36ede232fc8390bde39e691cdc8c968c99ea9e024d2c73881b14d4b8d18a6d6e4566228ac95a0b8b6d23c2ec8aa55485fccea1408303b906068599b6f6bce1f0a8c16df9545c54b39cfb443a7b4aa9edc354d4326bd454e70eee103f3f48c66c6955f35f4cf6eddb02ba1dd0a44eb32d18d43e9e29835cdb420d686bd4319f039cc05261a4eb4b02cca3522614710f647614dc9cc52be130c6006bf2a8fc7c65cfb98000f0b6ed2a34cbf93041974f70e7edd1819db35ead9e13201dc14b45b69b802542b114ccf432dca14c540750db5ef58c9054bf5cffaf25fbf96bf2870952f63bbfc9590c2bc5bd2eb33286c459651ca2861a7750a0529d802b738e75fea852bb2a2001c7eb13df712decb35900b72682341b51536baeae5ae76e53bec6ffa77f60cc5d1bf63201cd0c46e59ca65c49d2b25d2d3b0ed43c3276163ec5c38c1b38d9f98d1641875d6bf6e1d6cd6622f51431422df8f3252f90d4902e6e74e04b0d1a85d22fabd4168cc0f095ca721524723f625c76c30a3938d8e019ddc15f2c0cf495832b2b554ab79bf91f8fc4a51e87d7414ec545d02f015dd54fd83601c6c4cee66c8b4cfa9fbbf4ed2ed2db4bcf404e6dcb668aea3d0e2952567ebb3dee664bec6566b582763be54a7537c089fb9ff5c7ad4df5e66399d9adc33b2e892cab661d60d2836711fa1ca7bbf9311b17b8f8276eaa9d8eed33b475acc724cedd177e3649814392336815d00f49e20b40b40239e7b5eb3020ca1e485039fbecc5f53f8784cd12e52cb0ab11817043779b646fca36ee1fc575d55ca8acde8aa06e0c1d7f2f2a2a0facab2c8181df73526959883457cf050d8e980b68075855c1533cc5c67ec6e564f4bc376fda42510071f6d94c8ddb096bbd38f86f5a2cdc102165d71358ffb1bde41ea46d3696258b32d840eb68868e50e460d581933899ad02be81ba704d79b1e8d244a1c9fb6f9ff5407dc70de951e67b12552b69b8c4146c813b39779967a298eb6bdcb4bdb36400fbcfb5fd519e899292b40cd15bb312ed1d9296c44d03238b4d9b468a59399e55476e25c1c5d7e45fd0aace1272e271379b2e8a202cab700f15c5663eff7d573cd9a75bbd9bd8b3b68efaaa6082dfb885911bae49756149ebc17b83156990647f729d1d190f2ab5011a66e8b38777a99e7ebafeee5a57c1b62f91dc11565ab4119599b5bbc85694c65859cc9ae4b2d66644b46f37b357fee9f23c8949335313f83deeaf5e6159e837ea0b01b3f5457750013808e98b0dae7d5bcb7efabcdaa2f5ce36fb81630a458f0cade7d9f2eba8771a7a4edbcd1958cc7b09bb1c0a4dc1db0bc704ec21a24b8a97ff3a3e5d27cdd2ee80022ab3b66d15fc0c601729e03220572ec8a0684efb8d9e6978dc86cb1042780fb999fb728b210dac78cdbdedf44f7c7baf2cc97099a95a78992c9bbb65dcf79eb0ae8c750b1df19e2e75787fff8c3a2f966042dd15f81c1bc4f1cf446cebb0ec745b4152a83d7af2d2e1a0afb4a6aeae79f7785c6908e6ad917a45e0f989d9a4be9bfa689f63e36cc0aeb6e56cc762818822c71b8d652dc0a4b526bfbd404f9d0c2829d9dc7f77fdd2dd01c566975945dc38f7bc4d8dd2891464ca07b82a04b6e56e010800c2f2378faaf728dff08d934c587f8e2151a38e76b59c56b88bcdd8e5b02ac0fd2de5b3e17a6a0c7fe76968e1e3755cd7f78f50ea86dceee02e53964272e1296dc1ff43fb9ed35ea55dd11f895d5ad38f526cb191eabaff6bae30242190789dce988fa35ff8d631709619b4c5497772c43ba7a29f23f054d5aabdf9cfa1e768ef8da315ee75d1a53f25274d37253e1bce49219eac903eb4170d51b82f6327c1a54387634037d9b803db2c4a0d807ac215296023cd968ea549c772dfc12d202dc6862de7d04392c15380044e864c10bca46b203cf89354b783b1cabb1c0d0b2b33987cd14e248b531b4749d46de59f9c2d6bd9241761ab3ccd55cf832fc89d5a3e4479e085a6d3428c13c5561926602cd349519507a3d16acea024137db2b2d5183ec5eff0403e24c60a1fa63da214e7edc465af4b24e9def67d643aa8d7468afd524481389a2420f76d46765714fc40a51944dc6f32be78ebc7cfca37632699146969218cef7caf8c83e1cfa2590f74719dcf8bbff80fa32899c20a0a5f0265f1bfe4325556f6bcc955f06a90c53dc1e0818feb964967107fb1f48ffbe52fe57dfa071121d6279b39a390e56ef0d81dc81ea9c7d39222724b77e0d87f65fb7de3d51cc36a75931ee7a120df0460f63679c0bec5003ae5ad12505a22c8463bfd90cd1c6ca45b7283b9a44da04b96dcab44e6905fa9b35db7159bb7ee4667d1241b23e3007c243761bd4501b13a5e172299e2cca01069d7ea38b4e0440b29a0876f7a6b2c1e80e17b82142e9583bcd9245274c51e0dfc31af85efe961d57004247e208a8690d0b94c94ca21cd3a35dd5f9aa1502c7d6dcc64b31a3efa8d61bc79a830b6710b16c7833fe031bda49af2d197a778c367e7cf48bd70e3e261ebe42ca22feaf22d13b017160c061f3aaf09fb5d670349a68d3c11aec4feffbe55e03f54ea6d65f1b3fd68a3f6002c2f8fcec3a8661cdb6c558e9b7d0e8c3e0cf5efc1458921f9e909a131a8317b0a8a7d1d73b3b4a9ec78f1861d3dca3b9c958d6abdb15fa9264ba1360109b66468573bdfe07d28fda5607714b982b63d6d7db2afbdf59fa95c38455ed25316d844af709267ada7103ed8d1cd20abd979675c725d8e974354968868ca9d0d6f28628b392ed6c4ec9ec9fe63a780d616a4f890dede0108c12d09b0f6a9460d9158b72ea6979cb56d1984aab9042c45e94838280cf19f59a8ee5c582c4f49c93849eb8f06a622daa12adbb48357b55869010bd5ce7fde6ae8edb8cf872f8558eaea0e58f72e03bdda035b92278f716e6991ef8adfd68ecdc6aac74f117bd379eddcc03b15ca5c77358370a5845960be28349bf6a425e7902f5cccf0248a3f23594bfac49736e977fd8b46a5294b7c1d9fb23c4a12ba6c0bfddae56ed28479b49c4c82805f555d71bef4e766aab7888d4fe3033c540cbf9fdb9d6df5d94d747253d83388bb02cca4e5b586533baf316718244493395742dea238fef3b7a8157ea7584ecdbda8d2147fb5b20d1bce8c965b7b8a1bf6df58aecd279b08e833412e660862eaac4dba9305544e2059cdc42786fd4706f82a08aeed1886f5de0780144e717016b9194bc53bedab79ac2f8ea156e041122471b56797bedb3b2371096663e2dfe965477be97ba36fecbab4ed36aadeec39b7c4f9e7aa0f0ad8b45a4295e3c4e02a49510aaa5ec4fd3c1c143d71689847655ef74e92068ccff097d0d3d0f9955fa3f6cc3c12410e88ed5deb392808e0225d9e83b411e17c2c5137356e1663627fcc9c2e58884be4590c3f2d67dac0d0c4e715284068b5176601eb19f1dbf4e935ed20e45def20e1aad853a44e81aa81c2dbccbe4f0af758102fc1409bade0332c876385add642c51525e12a2594ac368f2d2ab0f1bae21a2e9b8b9facf5b15e345e16239f270e7a27507cb768edf84dfbbdf8e17896d161890601dd85a459510a9ab870905c7d713738e5c1287a5f66514c0003043cb70ad06c002734584764cb670ad8de757f955d6bcc5873ef29b32d9b4dd87790dff3f116b8abeeadb8d41a2b5d3aa359ca691a62d6eb1e84bbeb9731dd93acdf90a44aad5e6c700261ff5f33b4c44016713424ed812cbeb324689475ef01b90af6f638cc9c47692653a8ce3ff9d690dd133330a1ffa85c4556f969a330e4049cab7b126fded3e09f71efa05fca14d0cdbc9bb80389dff1339bf8a95acef8c7c31676e59a9ed4ceaab16763ef596b6543951c68b5797bf390bc61eb6dad192b0e3a82adf87a0c9b7e1ae0dfcf878bfc3f72c90526420079f9f662d18ada0a3bd856847340b9335fce4a1b176ac24ae1e4ffb19c848d564e23a5c78038b350379ece0af9d4d4f0a5eed853312ef0cc56501be6d9a0b7bff51d2704b49762ec1e07ea549c67d77ab2f2cd80483e699641735bb7615fbe49373351992a37c7a9cc87219b4f47c27b20101a0f696385aa87cd38d9481927559b2c669bfc7ed66e881609bc4c585732e5b6b368df448d7bf3e7c381bc1ca280202412e359680e7f7e41efaba5819be0d8303e6d54f9a912aac9f1f95d163e879a2961d2540478668180b45d4df24faded15e27c74895bfe28869da2e4b2354a99cb828adbd3346854bb717496020f362762d58f0fc58e0ea843137382bbefb44e538e1fe3e60fc0fc7a2755f3f6f8098538b2d93620b9c1a138061febe4f24ddb9e05ec5a0f19f96d9ca43c4f65a86b2c7f972f82e9f666d76cccab4bda5214ce42b0f0ac0411dc549c809ce3f9feed76cef821042051a85bb5f25e27a8a6c197dd44a4d6062a3f8b02caf7700b9568b405400bda8b3a039206fe3b542a8fb76dc9ba3042348ee8df897162f716a3d0980193d8c76fe5c2b92a66e4015981a73c5ed5d1739d8ea7495f74fef0384bbc5898e4913e406ea92d268a523171466e4e8a683e40cb6411d78d59d59de417ea2a844321383de8fdc582bae2e6e9ef012cfd48e607243765c26dae3bfcfc7082e1b014e7682f7056f04dea3ec2bfcfb775a3783277dd2af525e6c222a4ec98df11990aaf787db522eb2b2ec8af1aa23c98a5b9d882b74a08c5a5957ec54af31e4613ccc1fdb92f44461ee9597dd6d69a82f8598480851c22d5f3a15b5a94fc0187a94ec5e1698e549bf3fbf141a0752deb662c32fff64375cb21a0e8bd254f5539bdee019238917a71edef98f793a9b746de5611cf5a0cc69ebaf7bad1f78ccaa65df6d08e8afaadeaaa89c22d2b206f12a4e7eccd42edcea08b6822d9c7cfc33cbc275352463a5d7325219a7ab0a81cdbd4a04a229428942cb6a7c8d34e6f4b2695c35ad9060a3a553e24c346cbebdb49f0c75431e8840f9e5f93514df85c1a59a786c4acc92ff2a1bde1229515f17ec0c1687ad52f89b684f012a19aa6e1899ee1bcbf636aaeafc064fdd2ee1cad75f8d7827cca8ba2a23d69fdccca8928107a25c31a7af7b107fef7949637ee48bc1b6a66dec6310e1da3149a271d3c42be956f406bb8401f119632296cb7fecbc1661626236c33ef6bca6e3cdda808f1cbdd99977c95e7489f30dbe450ada2ff3135db4d0d84ff2ce99a8913311fd3f2a698531be03d23fe9615543588765c6184bede8c3f0dfa5e3ff7c8a4b44ba5821dff1eeec9c298f1bacd40bd303a4db28701183b53d68ac89bf8c33be1531041350187a097d390f6d0959a3e81b4323b95500c14daf1b97ba8eb1df36c3d6174462126500e409b386e01522e79c3d6e4f0096dd8d53c8094b1796182e0dd8f64421672a178755852ce8c439b6f7e7e6989ec8da80e07d5b5a104297d30abde2f66fe78b24fad6cf4346e2e803087503d206b46c70aee8c3458336ef5bd35934b822e6eadffe398c096a527d0f8204115272d22095c757ed15759c0da20f0e887cd1ad64fdf738b5a4c472e7c3a8bd9da2fb8eabb4b4d0af015772db975bfdc5dd70e059d61d89050a17893a53a17d0dc3910f8f1a3ce56da6dc6970336436461af22bad2f3c6900a3224ecb205106ccb2f9c08770f9ad25368b453eae891d6fc3ed9a6186bb1f7399a44bf5b82ee6087743d96618e316bd0d1a3552a169a12f25feceb14be36ca7520bb3c98eb3bb88d138b75f7e9159308f87327e4b1f94ff6262a9c67ea33eac8dc563f4166b12276fec364f8259d6edf4715a4dbfd621d45a7b668492f68b0daa347d92fcd200a0ac07788888cf7b956a2f71357c37578fcff4b53d8189da8151dea9b369347af6a9de3b353312f99cd66aa8f50bc53ccdb6d1a39a8cc4c39fde601e169493999610b1f8bdde8a2f40249e7641ece44fb4bd97658f8a4ad2d50694c064f64cadd68588c73070e66608898b8d1558cbd4b87a78c73a88f17cce52a8b180ef8a1cbf99cbcee986c59aaf22e9c0d21e8164eca944808dfdd7817629fd927b1d2362f0f03004f3a907155a2877e2b0764771c330b4fb52db35707a6bd03943135e7655edf352d85a1d33ed7e211335ed2240ba5f75143758f29d1b6e0a2e1913d20f91771c4fc97540278081ab2080bb5a0a9ef75d3e323c0e5fb03f140c31b3eebaada8ae6d12f1582478a0f1cf960a543bebe36b32d85aacdc0ab137a6e794f5de0592c2b0372544c0ea271d02cbfe46e18cbd9d3ad44357e12bc994481b83a46591b96d54483cd799dd9e75c4d8d33cda4ce9258fd6dc858b275ce0569572a62658547c5aa29ef01753baac56909b233b67f76a2b21a8e4ac451c22bfc6d79b5acb40e1115548398593f609f219bc3aa7e851dee45ba1b465aaa6ee05f81a4ecd3cfa419fa816cf3594516495a869bc9d6f5b719ae2a6322758366c11cfeea059bc6c240984f73433c129f87f91b34ac3eb0964b424b625826521ec0beeccf71a2431dd20d384c761c9c9d74ec625003f8eb35cf9509d1ef1a04ea48e501ecafc2bbef71c3076aee6ed5dc769a36289f94b2dae2800f2c668370e5feb07c9e52af173fef1fefa3306055a50a777662d3cf490828532469ec625c35659eba1b39cb0f3a3555fe39984afce2e7361c26377dfbea01aa204bd4ecc4541a9323019d1f89d19aaf19621a3b074b6bd9dee301b36df2fa3ca1865edb49cc456fefe7632b6df963ea5e88043cee053cdf783b7be1de27210c0e5e059c54cb3656cf0bc224187a32be0c28d6582656c7248d166b77b4574fe47e6afaee442cb29e0e47f743f745407b8025e947ac9496b9ddba9ce4f98c74902021f042c7f8849777f0925ee12687c127a5184bbaedff396ba8e2f265d873b55ba883d83c3f564a4a9841fb0285df640c2834842a0852d4de037170bfcb7e8f7bc40bd394f4b1c448bddf8cc128645150c3605a98f096a094ecb4108549614a38974b5074152efc786d440a1f8c3625eb32c73e5051bfb06720e400e00cd2ac6ef6ad771160c0fce1774e4aa044dc2065d5d8acf6a6b2b105a3d3b20345ce6f089e84381972973c2dc61ed5b79cbbacd98607eac23644fba5116556aa1ff6ab87a3df25d43f009e48c30b3c53f2c3a42c64782036bcd02260abbdf953cbc034e5dc2e732723269e1ad96940a48884865c3082b9dbc559ca2dd94c445a94df768be6387df845bd95293b56b29890c3548f5f21ebab9b81379d956455005cc3329821a6d57b31cad4ad8eb2c4c91e39434f8bbd2dae3f3f635cc1281c166fc268f3ad8864cfbb222ce927dcacbb0faa2654f8a359ec27ddc48c39d7271e036e3da9cbf96ec060955f9cc4bed6ec01353886b5265cb2f53aaeddf83f93dd7201ebd5ac6cd4ac3f727239e3588c544f0bf587ecdea03c3561f146355c516189f0739a1bb145942eefc9379e2121f2902b17b5c00ff493f548d13f6e1e378f8f16d18d0788c71540c9cfeae868db22e1dd6866fb4bffb573f14fe4916e6b86b8a467eace4bb6fac45bc11598bd0853c80c1e50d09706b6f6c10fdbcfd49519522107c24f752edbddccc0a6bf496a0670561858f44730213483d701f4d15a7a8077bca51ba12889be46ccdb2f620e12ffad908d35c01f30661fee3ea7a8a3db72130f9144c2112d065368b0f9d078f8e4cb27f239717ee3e7da83748f260a9122808edaa8dbdac4299879db66eba8e19ed69272e7aa4c23c417cbede3ad3caafc7c4792273ba8d351ce2e32005716f58f1af2cb932923cc29522bda8f68d5e4b4950323994d56b34e150b76e15e422ab580bddd4146c6146a95e63d7f0285b560c1c2b01e61ff570a11f07a44da1414ee548e4b01564132950a319aca3a7f1612f898802da61cde2be597924875b68ace8837dac55cbc45e8c69ad91c259b95ca46a51b790d032e45abbc7a4afb659c60ed38b681418c4a654e44ebefc44e94fe5752fb184ef87287ffb57344c16523f921fedb7a34f0c4a0e3d5433cd32cb7efd6899a47daac1e6d7f39e085cf144f628b116b7fd1c5f9192a5d92c0ebb9cb3c92a696d00af9d150fb76a0517d2fe56a42d70364ceab5f0f6d2093c9c2497d92009d875976018ff8bf818677e443651fab92c14b4c632e25cacd783026d1ab52089196efba5e5bab34592aa9f0d6f80521058b831f8d74b0420900288c65e9965c5179528995e760246fb1d99045f6045b7fbd099dc266c3113a5a35785aef70ce28b5b3059ce1677a57657ba91242c8f40c87d351f8f7622cb40b930b7b0a7d7d2eaa4117f5cf3a25819ec65348c3dc231038e627e3fbefe76681ba75fddcd0abf13a33de394396662e732391cb90a61ddbf2dd02e4afa696120f3a151dd7b58367d382e3de178dd49c1a466189a7f4e99c3b66d5fecbd6ee46ca57b2b3f13d9ca834f2a22bdc43c90c7182c740bb75d088679cf20c892353ee220262c444e17cbdc8d9c79607ac21566ba97e3613d5a54fb650ee271f72e15e485a42a4cd8f7db135a4e62eb3fa9f1b2c874c283e4f9404ca982437f5d19b7d2e0362903743832016805d9e8473cd1e892ec65e1bb94db4824de387de04e198cba3ca543bac91765aaf9d31329ffbe6935beebb46a41788d6ef2667cb7fb72b9a71e1a938b9c020ca06c9fb85f45eeb5a93040a0f921d990d15ec37f81ef06d7802aeda206510bcbf74b7b5b55cad04120e03c852499f9c3226a2410aedaae211f8496788340b88a258c3432cc50f9fc22e7995dcadc11bc75057025e35b29e9130804b63175c86eb4c446e3772358da60dae33cb1a0813d3b62270178d2abcf6dd3aa2b4c530f0e49d4eb71b359ee9e52729844cc0b9e85cb55458d53ca49bef154f0bb3a199320cfc80b41facfc9b7a7f5e941f3562b5fa5a051f5ebfed78d3e3c9992416c29c47c8a232000c7b0673a4b42104eb6cc4d2ad9b09ded0c13c1b8563376900a1b853f59cf37763a016f32878096120b1f38d99482d171ecae94efb17379b330f2c270f5ab7e0cac7c5bca8d0bf16f6157b7f96d4c33f19ea7ca0d5602ef661fac4338ff35f2a309ef392ee3f9393e00fc70f8bcacf0daa3a7f8f390e63266d0e41cd25279ee2c823f08dfb043359eacc2b10f5acc4e447cb632759ce87ca46312e841e9519c0efa0e3d3b97009c8b9cd675f7b68793a3e7fb3f4e25e4d614b31cc6f8531c5c5794f8343101ab7b84ac4274487e89c2a732fca3635290874efb025954b186f56cd773be2bff47b07726c4cf90c2801780b6f4c2da9b74eadf02cfe3eb8d4b2ecd0364cb57ffdadacaa4e7ab7a6bd420046e1209d39ac748671a7508afb244d1f95dd862c561af411388c6a873080e19d4f7095146ce863de04ab5f85d815af1a9c0348ef1967eef008df1de6b3a5551656f3a70d9f8d889018d4e2a0a9406248059e71c48de8417d7211231c9e842a59c4e29e7f453c3c02eded667a3e4942a89cee340c13bb2a2217b3460110ff455280ab41dec57786855c12b258913f91e83197a307bd859cd79b5060e66674d45160dd09ba0c790c122a6562943d01df07bc3b9c8769f3cd2569a2ca8cc157a8ca08f5516dba8c30bccaba970751850c0c69f9b4c5cefb681f9a1216c3474744282bc29be60ac95676f84ee543aed2167a0e3c23e3bef07cc12991a5b8fb2a05af7a61b924961730b85dc6b4bdcfbf95d1fd51a5cec86935ce694f6672c48c762f93a7fded8afdda8ce197891bab7ae70eb902bd75b1c441fc2d3b954c7b1ff2b83a48a98aada701e98c7733e0c93ddc157a566a3b723303b685154ddb1bd4a1e33f224d6428ef7f4f6fd73ba75df50e31f5e290c22959bf03c9bbb4737a843730fb374a9cc050a91468a271c1eecc8181121f1d94c8188bd8b02ea1b99e055e08cf335a5d7a765253764f2f44d6c5953cb9e786e212833ff029c00bdb816523a57b3a859f5ac35d5ec41f8ace9d90a72baa6ae1d7f2b8fddc02fcaf7422c81513e73521a2e9f7788da3dcfb358802367f41cb69ab8f60289f92bbf7ea209816ee0ebc8ab8f73652b4f62e924ec613825aac1f4fa90e1ad437cd8cf3ad7e33fb63365f781ab15bb66981c3f0692fd41452f57d65e262cfd979993d71bcc9579cc556ee9c1469e27c95c03c1b1613fa45fe1b67067d18465175bdee14ed1d145ed4026b90266a2e6a1e6af52160f5a550edf4a2549a443a01e3486f127b960bc562c65dc50452e21e46b82229adc3626af76440e0f571441c5bc5fb264dd2335727941a8c1348b42a44394f0ee2334daf956f9212f1be26a6f29087f81a89d1348b1e63365abda21f7b5b9325dade62d9f33cd44a80e949a50811c3d6f76d7deea36d95d787364be1c43a097a7c68a15bb878d07065b45f7d1af3abd4057db0915d0c58c4412f29438b25a0caa5d69b050100f2a13668322ff042ab7eeb66a7cfe851ad7ce20e115182807f2b3ffd3a83ace43a193d6407edd3f755bf819a4b2304c11604e215e225451f523a7829516d244d30383a205415726550494cfce92e9bf40559badc9cc9561cac0784cb1b4491f20f590e091917fbcd3598b08bc7475984471be116d723f5ae075013936ed497c4cfbfe43a5980ed23d466c1c558d2856569f0f3b4d902132d2dfed8a74c8efd64e3f85fad0500f0dbba712589bba5ef2c422c9252527f2e8ce9872b0383600fa51d6b35f12355c8a385266d08cbde93b8c18bc47b8b965d5f7e0817072d90365558a1105a032bc56033c8ea979bb9db2f20db683cb73c8c2ce81ea49e3d1d306560cec9f4ff76f81d822bd243d4650c296d7bc95ef48dd768624db39a7d74b05f2447b081c150c5d982f57800eabab7bf7a54d0f9d054b9edc891dbbc8661cbeb69636d2a2b129128b389cd901d8e15c0aa2bc4a177967c4177a5b09d292ef6c0598ab922d5ccd8ade64d31a397f6323995f7aea92713fe14a07b139a59431a5e0322c763444b7c760b16cbc1fa266f1bb7e9ab1b428a27bb90e2ac4077a7fe6d65e50325282836854a51f4ce3e5054292145af34aa4957303dacc442e8bce4adbdde326a5ad42350764c4c9825d09379d738fad083a379991c1f3c7e6aa5bebd5e67139057263075f9ba36848cc780d5de2499bf9e1ea9f92594f9fa80adb2a0b1fc596ca8480725dc41c88f58c4e2e3b08c3c13d9a33e9e2b57432c3a5fa808e3f031f9e59c1d494bfe91a5142c3ceed20fede09d6b9223b789df17c312c46d5a814e0a1ac2c286130e10ed97d5b75dbdb31371719e9160c36871b94d216c962d8f78f02ef161ac433667822c5143fd8627df1b725addebaa492379118e7e44eee85f66cd03f986d622a17fca51e12c29c6505948164d8d1bda0d825b8bdabbe1697709761542d49e0967b55cd35326072fb43ef2aee9c5a29dabed50c6e49aa05c16cfa3d93c821ece22c279c4ea2e826aceca6b2bbd58a5e82c1eb02676039567b31a1c60054addd324e7ad3a1519f5056d6377b7a10d5407b5d3ad4704310f83095018cbce47e0f69a878dfb112ef007bfc7e647acc67a8e8ae8c7d8e13d6b7dbc2c2fd40dfccd7dad7beac0580bd897375d9413d7fa5ef04d16a65e419968be2b52326f2dfb500c9280ee935ce09805a09d93a00707dd742fff2bc7e04bb669d8d056da5290c435a7b3b3c8d634bdba7a6e3b04686326a05a6a5597b62c58cefd81c56528fd4fb6a4b125c71b94b316557a9a5304c9fc9d761bf6b6d8cb129d87bbf307e026f24da1ca4d4d759c52c04c5f7024e60cad2c1979835deabd120204a5410165e2d720a1dc548aaf16936eb956a71bf3904e3605db9dc8090de73a8ae8596930be042b4a5889147d382db6de3877ccb34247492150d2a2c838132736bbcaa44bde78e7511e17804d49e1d1f029cb892a2d9037cc465ac874ebd8f182cb642e2f83247dd39f48fad449106aa3ad7518699317941040bc5a8c2a9ad2474e2ff7e7a602bf4e798f2db9e08be34003260f96d2cf61d6664318f037374026aab7f3f7f6655d1095fea6df2deb6ff0e7015193b0933c28dff988aba26a94661a8cf07e26df03fad0fbde7cad7fa689e1c64d6e4b183d09bedc4a11200652bd4618840635b144981087098341f7e4c126bab0f69e0d81a0bedbad69f232a18a0ad114e1091c24418fe1b434e11af778bf7d917a9462209878096c35fc2dd113240af7ff2967c302537a85bc9fd00fa5c503f287064f116a0314e5fd061004f09099b62e70f458ef49d7efcc2bc51d2044b39c112bb60e5fd2b4e069c6518d8ba92f7d403ac790ecbb04e81acb3debc0bdc4c3103878634406e53060a54e8f0a466ca2497d76636c15cd042c324506cc4e048d1406de3c246e66d4459732dbd94730eb888bde0a278564ff60e334d43b99cc8382519184e11389f68e129574d80d71087dc34dde339238af826b1380aa93b285b44f93d63de442dba38d205e13f3e0bcd23e98d8cb290285256b7434dc16d9d2dc6139fa4bcc68c6d2e370ad046dc3b3c48c7fe145e16d7164c462dbd83185cccc928b341def3c7fd3a9985319ee5741de8b918bbf9342d6ee44826ec86f21da9493ec07f182d9baff37437d8fccea8ef888fbc467c67a9008bbbe7aee231011fca456e793777cae34d7a70077766a4ecebd69e2221ab32e1946524c6415c620c0bfc2f2f86335d92f0752ddbd7b7855d3bd0271f4e4d3d1c3eabcaa5346d857c684186365aede3e4e2dfec57a21e78fb243fb49c31c4b74a796b6b8997a441e22d19a5657c1263fdcdf1c117778e1beddc504d5026432b67aa35ddc886afbf2c80bcabd6e692af49fc6afaa8a87c2fdac3cad705ede75760657771fc624713f201a8e7af5e7f175770d2eafc51eddd706263151b20d03b4d50d2ededc8491aeb5a3ffeec7779a75d42ef713dddf3659222a0454fb77ee08a44b48fbf9bee84bcbe6c060a4e611e7035febb7fc20addbdf0ba872f98a2d3450f2fcafe13ca9b9ff9ff76bfcafe2b410959c4154470fab08cef1b8300976c05b0025109c659f31819fa6bcf7b6efe834094963a2f392dd36f6069a1195caa62cb45cd764b06ada8d7f6957a9f7f6a547d4ca0f74b15adeb6c711f6c712129dd56d6435b89b2892d4fe2b8c07ea814b2db62bc108f0cc85d02652c2df507cab644dc3c40987bb962bc2772f030b0da87ba884b33ea478328eb34148a2b539bf68ed3452258a667ab8f896bf34ac6dbd2f1fe13d4a440b212cfdedb240ea04f11356ec3a4d18ac549cbaedb4bc4c7b94ff09483cae2f114e9d911f38674ec359cd231076b6744eebcf3d1b6b967eb5189ad2b85012ab627615353a86a65d70f0cb6b3eeb492e3b541de676e50fedbdd5a24e4bd440027eb8ae05e9929d6dbc0e0202780e7ddd8ed9bfc53db0b8bffe1479c38fe5d997003141a3f8a8e62c0303335c77438332fd53d03feefee16c481ccd61b1637e99b3d0f4f137dde6550955bbf3fa77fe141447a1ce0f7954e197c163f030c3d509ff20d900a44bbd14846fa89f5fe5050eddf72f01593d8572ffe24f8f7fc4910905a7ca379808cd17255eb0e502de7f104ee0d253c089b88863d3b566","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
