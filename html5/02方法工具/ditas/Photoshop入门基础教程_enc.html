<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"080b77d439a21e0d9c55abcc7ca4445c8eb9fbf73132cce967b1ea32b18bf1f8d68ab7229a6dd4359dbeb5c529ddfc80b63d1561e6f7dc9bcfc1a11ef0dfbaeb8129589896f08e8ec8d87d4fc5b652e3d0709db79314d72c8a9f38079430e8c989f28b0db9aeab7cbe0810eb0339583377849cce668bc6a7e3bac0560e6891fb5caee1f2d5de15c17f449d78e41dffb7854519fe74c6d5075f6b70e85bbc1b7c185090cb346fbe343a8dcb1fe0c62d8d0d749edba165201eb4a01f57a2669c2f5eac75ece205bb67888cb3cfd35aa41857843891b16eec55a1f92eb89c202e64b5caf13faea160c3c180761b8ca4d13e0d90883fd3a303b9896574608a365a24f475371b2fd69aba407760985e49b665a166bb8667afa89239196967a070a559b75f7375277a121b272e09c12fe7feb6e8c78b1c4da249fcfdba2a7bf809a58be214805c4550740c27f19c978d4d6ed1a681d17c55565ff8f36ccc37eeb644710dcc22d80d346219e5cb0f4c86a3f4aab3b3ce46ef1e65d762eca87631cc7dc3ab96f1f44397599b38d05ce780568a8c521c9a3d78fccf2224b14f3a7be20c7199a07136b6bb4dfdac0b291e29fdaedc8ad3cb3b1fad58bd90015e35aa3b25ac63896ddebc9cdcc112b199c4923d4fa29f7fe6f470e8bd69142af0a7008079b205244f5c4c2c11c6d8c07f8de27576e66ca0db512aa70b9eccd843ec26d4edf201741179e1016fb929c590584e1939737f2ed5a0ddabbec8aaadce22b515d62676f83064e0c0f39bcc2cfdb4af00d74cb0636cbac02f28557c73f14223066b478ae0ecaa73d12aedf233c4f0a562007053cff2519ba522994be9450c3095bc1753f2b476f145c5407685c6703a91cbee51c339cf68ecb67942e91544b68ac72813dc30f30aea7f5620e86d2e8ce718f0a16f808a860647ca141292fad5b499b9abe536f1db7096e23e515042dd93b1408003325e71a7e2d690cc87cba9258b021ed823e6677fec993e76fe34ca1e5150e8279aaf59b64a5fcbc58e3362ede5110c111574c84f31fcae14e693a2931eeea4e8393e107f07c84bbc1df2d954633ec6dd1df8fde5be0bc704dc72991f1ab9a28cd831e3d5f2cca2417efbc3830d526f862b1052631fbf7202a293842b31f7f2f0d824b7b0dc6659abd98dbd35e64c1194925ae0fa7bd8a0f74eaf513ab13edfe41ae3c06a9ac7e95c1858b1ee650976beb6ee3854214daaf36223262d944c8bee5f16ce302f854d43a951a616981a4600be096619fb5233e311f92ff5e6cf8237eb80a317c655dd936914136989edcc656d322b97cfc6d3d910923706ef2614565072e9756f6820786009f682c432908c822820c08ebad8680e75e176a112a0e07dbd75df3d61d865e533fd142524bc7108eb58b72559151375f88f07e412dfb51465f617d2bba93ccddf1cb346b6e1b913acc36c1fcaf21db1051107a5c0ac4fc8f751278bbfc0e30987717f87346d6a39ceacc7ae9e5ffdc911b12a890fb16f9384baf0f5039b24ff4e2d753b59614b6ac8430331896c8164b6788f3a0aec7fb9af01311884d07f46ed23ba89f0c511deb005ba91e83959636f8dc672544db8e8ecbb326ba1460370e73b9b6b9fc599fa41482a3516a5224e340eb89483ecc759431b7505cbab0bbb70cec657030d78e308a983f512772a7960d97199f7939d0c4836503173eacde08ab89bb38cf435f7659e733e0447f97aa086664d74276cdc2113bb16cff59a24125519aa5ded2208d389f83cddc2d69ccccfefc666c7114bd7d7417899d26a7f5339eaee9749bc36b08149d04e83a90dffb645b0d6c99b9231a76d87704beb08135a7376aafba099cab2174e132a26bf7e9ebd135d3f52cce63c6242b8a2fe62a3730838e7fa4d82f0dc25288443747389dc05192efe58eb552f673f1e65002e166958b732f60d75278924658ffeddac92c924c4ee36b7a37b69feebfdc12d9a05908dc87b542477ec948ff347c540cf7ea4e662c84b963da3d5289da8b00a5405a22239d925e16cd302074667317ac4295bfd86a7e4439c96cd803afa65e9665f38f87424655fca4b7df1b85d69a4d062e9f081cf9d6b76aea6727ea5f1cdb18b68efb435f9ad20aeeb3074ac60e7107b57ce187b631171e52354ac799a5adcfe6b38f0a8c4f874a9d09c90cb4c5593554d8f5ef9c7934df6a7214ac51729c7cc145af7fed50937dceaf1f0e0cfa83b6308dc5e721a0414eba1e3bd582687265abd28f1d11ebae5dfc25d470341ef92be5163c9148f9aca50f1eec6498ab1be82b741d4db36fb7e3fdf2089e6ac748705ffd8e37edf104ef45577f47157f0dc3759d9dfe221398683e5cc26b6b2fc1607bc38b7b8ac1595162ee106cba88fe5e1af3818894580f05666dd09127933f9cbdb8e1feb63c93d4c5fb77508f50184d3b0329ef0d0258dd7d89e56b70ac1e45f45b60acc59df59577ddfecbbc6062c7fe30a424d37a0bba6a3d8438ec7ec09fa2b21db6511acf4a57124fbbcba67126bf65254af0eed3137fce0a4f685e2edae7018f097722120df15bcbf2dfc0be021a261ac9b35301352656b729e221767ffa4d03f808a5e028aa4994c3d1a711ee0e58397068241a6f7342df6fed70987071b3b41429f4123f051e8b607999df75ef7f65ae88168f1f6b72aa12fed0d1ca04801345a35554454967948ecd1d6160f1ac8faca968f62930ed49a8eda385e6025ebef577441dd1f71248f5cb90dc1061ce0c84720b1ff2132f860179d5713a74654dba2c8af3c544bef1d3890f0f8f71d60c1ff89fba8f9ff130ba38fa5747d7319f837c38c60316bf7d51285a56d69e028fc528b1f95fe6dae95e717d6b0ca259f50bb8dc4ead9422ade095e2279cd6980d75a78a1cdde5989fd69d601c588dd5e034b7d558cb712be53c9fcd1d349cfc9087ee45ca7451ad14eb7e851e9435a141a81a8ad3cc4b50babf8b66e87ff6d6ea16e7dd445ac644b7babe1b302f052f2243b15f3def02b0d81cbe197c51e929fd4f194ccdb9ad5ac23b9208736159b5ea3ff71a27fb108f27df3bdd7d94e18607543f488f42fda8082fd099d84828040cb9f8bcf665686cdf33ad514b2ac19c5e4967a30f77950dc3d6a0a47d1b16ecb5fe54a1a5f810c448d13ba20325602ce1de8741b31b06eadd4f45cada288e894c4ca5311efd8efb59e7022c7034aecead81aaf0ed3cecf50cd419a2a5421241da5f1803125efc0f5f800944a324d47558e2c358d68a053122bfbfc11dd20faf51b35e60f3bf938ce4059e1ac8a7b3a3b60eed7f47cc5cda019bb1995af074c6b361cf60c7111ab2dd76c86ec28e71e5905baa9894614f667c5f5998a2746eb7992310c2f783f3778f01d882874a478864a53f02b634f9b5661f755af53e30e1be0ee35a8f0d10d4495b5ad1453d28ab3a974395d048213b55ef2cae321d7c18d91f630378aa1a2e7ae95f7d1f51df13ddc50c9f440ad35510845df5c9169adbae63d110cde279fea2479e45bd79c18fc8a5849b441d5d3d6eb037b53bc31eed073c4d195598491a36affdd7e041256cbe477f305fb61c75b0f5e5d118d807747e09c97db3cfdbb1daf8bacf1cfa9aecd1ee1e39b7969901dfa8da396c7799f5083a6cb930dda2791aff931bd959f9841977b9afdae60cf60726ae8d468139da7960faa07ce70bdfad6d8bfb232fcdef64243cc55dfae1725ca489ac69c094f5b1071f0c971fe6d9b91cdeeaee1d283605d2c0a4574c5b70c14eb8ca524bc1eb11ada1c3c56b82bec46f5e9e8beb27872659d137cb16e6e69e3528c2e1552b191be7d087f9645be97d68d5aeac8aef07fa01f7e5debb118a127065c429518e14f641e1e91d34c88a31a1517536746fd82893263974e00b1034f2be4a87b21fcb1e1377cbd803f210e6840b7805d3467d754dde949e354ff311f403ccad28db56841c87838c810eb335eefea5f21881880811765830bd341c1bf58dbac0b8325f0b8a2671de7cc2531732faeddcbf735c12ad33f53930d7b7dce9e99165452e3a8cadf051ac7d52c0c26ef04671747d6704b48b8a600fee1d0a52ce6a4b8eb9d77a85fa2bef9946cd75826cc1a1f4796fb8f3b313d1256b11070863d892f2d6dfcc9bf768a4d9855a0537fc929bec3f4380d772312dcc3bfff2de5b9490b39048705892e2d467e2304b54f0719cfe4c355f24cac8a4799197838ba82a6b01213ee6eae54659812b86c66459e9350fa1d97b13893806aca01777969f32bfb0fbc840aef152fb8660e43fa3949203f0121b59e399861cb8cf05b29bff5300eff5bb1225a2fd9a30396d223c36b7797e04438249d933f166dbc998c618e89c8624f19a21b8a3813de28004afaf607d0aa2422636284425c98389e07d60307427cc3c200468b0538959f02b50550209e2d51dfabfa356ad19d6f48bd22e4bfa03df726c38b8a165314dfc7d340adb118706f4f9ac62b458a87dd4ca5a17de0e1d1e3c474e97f0fd944b74116ccb35f7b64f3b09e81e692ca1ed13dde3c080a1e73d5e474fe8b8bbb9d057b82b7b4e2073397fe62be721f36ef245f824f9e89d90f0dd9886018fff862f9373e692a2cf3a05f7eb054905ceaff17bdf216b2961efd7db64d83cf7ca4c20eadf689f062b83572b1d6b07629162d7f643b56640ff3890dd65eaf884d5c1f1127460e5a6e6434bd28e6f46b45481e8b7874b791c7cf2ab3737bc2e8be13753eeb44e53cef941db3b75d572bf7cafb8ef26b331c1bd599c158048086648589463448d18922040493a2613902cad69f751944bcbf3edd2e4342a2508fb59affef67618b4b8e9a27cd2462dcb73deffe56bf8a421dd3c6b87367777d0aeb8e7c4611514dd3f25281136f14e048c81c63499051e7abd29d8f7c46edcf9d5c92dd3df47363956fdd0831895f18f93ac13ca25b44eace9bac1db7ec761df1614d1c5e8e1a065a94a006af048d881f59741209e383b80541516fe93f59a6bba96c25c5da56e391524cde1e0b3a2fd4376b64c9c7417d5ac9e14ef86524725f71d9d85284071e78ddeb624217aa09e6f00eae34b89c090a1cddea1c577f3a6aa6a6edc7fef7abeb06665d1c383fdc71f13f9bb2b18648e96c9a79859324cb1db4dabdb7d3b8ed82609b64dcf45cdd68fe95674a3ba6c3faa1c547b2cc5cb26150041e9279c61aaf4bfff569841fca20e1f581c20003f92f52506b17d512f262c886abbaa7cd1201b89ddc5d79a0deff98f2bc1ca19e96328467c1a27a055078b36da54a014d2900e4aa7353e3acd21eb01f85ce09243ceaca58ab9af89aec291306c23b1a1ed0ea4993ceec873c54be31e5d9c20e5e232eb6e8ee00629053e7489107b54b0e7b24db352b2f3ea48353f92bf5dde3e6512b9479a0413f036f425e2930dc3fea398694206a9a5812ebe430577bd4978c8ff856b5fcb42543af8b5b42bf6159d227d19e13c6e8e78d4d9cc14339859733c7232c7e296e5fb72ab84e37221c09d0f0e792d12fba6f37be5c17437791aec0ee5fd50d6dd36dd204783345124c1fce63da6584c788fb8e81d55440dbe8fa7c522ca5c1877a7bf0b5344894944069f7185f81161a0d05ad0f73560ad5e9a7d3134adc2e0550573a8f4ddf48d23ee496e04e3fd1d08d6f6d3cac026e8bcae22fcf50ce7da64af43eddb7a8fb4f78a0da3d08eebbb8d28c63fe82ee6f0c2e95811a7fcb066606d18740228d827225b0b59dc69e32fb30bd201fe2d558a9f555fd6da732a7dd5456cd9cb01eb54223aa915239b52f8825c51e00e48a49b0e86d74a13fffbf49cbd0c5b021f43245f05f7ac2489297bb74ac9417c7756d174acc8f87b1d3c217ae9e53232b39821ff6d82967a5f0bb1789b2313edb2dd7843c61b0fdffccd96a2222a27ebb89467fda72460d32ad0ecf417359279b3001117a093e2febbad06cda654ee8dea94426df2e0023eaf8cab37db88d860d400529052f99ebf7412e8b04fc040baf9e8a5acaf1e852a146d92d8546cb3e60f8547c5e55897e49c5613c2e5e6de27f3a88ede668c056464d1531f1541a25f662b8244f4166fe0e31c51ce6ee94da4c8a9747cee458ad63bb2a697e900c035ec50fb0162d3ad1e0981520887585a04c5933e5b1d6d1005574dd9e1a11cc5f19e0597601b3463d020f639f659c8b91e84a8f3b446225c20de91a6480a45bdea2fc879f3e7416619c289fd6c0bbcc2e57f421d5812d082dbc2bc2505419e6e062355535e968d49a9d77848c5848ff6d402beb9c4a947c21f6e37423ca8253b3d7c06265ac981f1ad0389969ea45b57958e8c4196c51611df183a10c98d1918b8f069196ad448745e7bd2d7d57e3cd6f436985d52dc6cc74a92be678c92e8f67160fe65274097420405a0afd0ea80af0c8dbfff36c4e7d585b9d0c1d6d0317906954f5b5d29dad02072f119e8098a0722562dc9e1e3788a4068ec83154b14905c1d8bfba29d88c22e4007e4940ef0421893f4662820ec7961a100dfd684f047509b0858615f208c25fe07730d4612c7684c1c64b7867c89f42e5b7a9f0b710d90f311cfec462abd9bd1f700c04099e56ba904b1da269b0e457d2e1754c1c38d81847b0a52e7c44cf983eeeb19ca5597039e6e170d6a72384fdc16dcd9baddbe5de9b13631816106948201899d76b8b5e2362e0516845b70c93b91cc1fb3df5237aba3c03a05c641075785d2b12e08997ad54b8de6914cf67effc4a0201d30bdf5525301c5b78f739d3ef94baf52fad7ca24c9ec260d614fc585785c0f53b0eba8de9b694e96c7adac814319df7957db24dd434a5e7c72e40e4e236ca4fc9c2541f8ef5ca482914a2f61c9c9c1c3f9c17cfa536f0850e4a7387602795b8c74bb97def73b17fe7a355812047132bcb143ce9b2dd9c4d02b3432bc6ff676bc95f29ba7acbc262487433c720502d3aad5830f651ef30814085b1bdc164306fd7deee091b503d3adcde847c47695e7e626889015ff1fd3ba7d6f9edcac387a8433f3379d5599a6e4c0c6318912e7becf1b33e62d890c92ef5919ac107c035f6797915da47cb9b783518654c8f9fcb94f98ad61dc0a0e1d3ee491dea644314f1b16dd0183a43c7ccc6025ff3fbae39915a2c55e4e80372d4e1edd5511c19a622151fa282c5592ff4cd591f9f1decdae613dbaf8a917761869827d7e30680a953fb4375f7f839de31caf535f2e25360943fb98261e485c3cc37f6723a74eac73fde95fbef85eac24f9c8ddead2d8cb208bff0f06aaf697b7babe3fceae99c72dfbaa6c56033c4aea8166dc99a7b787f3b248db12c63124226100a57b929befec05543772051489531c9ea6a42560d2d501a8f34df7a6bea1ddc7f042d4d56f278cf0742cfb0d4c5657bedc454b036c9d5801de520e7646bca2c37186f3bd693263c969309723b1ef057f53f2d2825cb96ced60275cd49acf46a314d30b80773d52989fc1e44b13f2e18fbc08e896d1ef1940ef4ce4e8ef454c7bd65fb8fb30a2e467934eeb24352ed335491f00248b8dd42ab14a65a46f2667cdb8fbd00af59da6b6c8aae2f2e560d71fef7f60715cb26eff5ab338808ee8c846f4cac57603997b8bf323d6a555827d6141be7acb5098dd8e0095c2e4fe63aa535f1d18cbccf840eadabb3f33bcd6de2862b76fe8f14444b1cbaaf60236946d3bf9d15f1df3a5ae05cdd1fc886ea06203f000050edae59f3b57c7f91a9f55ca9642681722bae98c5d48d07e7ae45d7b07a5015d5ce6d8cf90018bd7848d8d1b970f0a43733cd7a985ea1a40a91d6092db3d7db1ae5660fc4176d56c8e5d3c5840d31549710b6e2e451cd1d7776ff450c609dab4338e08ca6b9750faf5d6603aad10f3797ab57d544a8849066be2090a5d8a5814eee529f673324ae53c9dfac0fe9c3b2570ed9ffb7809e50142ce2cdbf7a4e82c730d778e74cfec1e185a11cf4532a4cbabc78742e431cf75bcc7ea555d14ffa40ba6c439d294e2803bbbd0c6022b6686c31aefbfadf59c41af35d142bc7e031fec5028afe54b4164f017a2c7eee88414ef91f98f232fb3ab754069f854df5cecb2c879820a6f98eeabc3bb94f320a6ac64b68d0eacc870c3ec732f4e415f135c80fd9bc0b400133a879a69fedd26a3de6b31a9c0448bc12493aa4720c4e1a1a36e9bf2799b36858db61a3b16239bfdca9de77fd88e756aa55245ae3249c62b2d885b435a36a328f6045e0937d0096840d880ec08814c63f8e2eecbd43457192d651f685d903c7da0ddef87d6a10dc1757962bcaeeb0a43e83a18c25b453b78e55570394b2e06079d1d25776eb10a5706ac28d9727213dfdddc1959ec6748e8addead5fc42d8747703e35f232b8ee871650a955378aa419f1657d31449c14650639fe889ad38c7ebd6d1f4a5082a5375688fafae9de229f7d72944f9b9518a5575bc829511b53e117c5248df3d2c72a7bcd7526e8cdc90b9ed1a31310c763027849582496682ee8b6966195dd5029a6469727b251a5edc1b6cfad3f3bf7daface998a90a125fb0889660e4e0d1fb2e8601b83bc88610da45781656c9955fc89935eeb7573afa65b70cc9a99f8e401158fdb82c781bc7eb6be4a741db5c86bb9ab445548107a24d79eccc96f4b44af278379a0c863fd095f4037e64a466cfbd9f77c0fcaed0a2fb042d98a085da8bbe9ba6146ecfaeed7da4b74125604a8cd8c625453421d282f5801dbca3988e92f0200e17c821c468c3c949f88c46a3dd1f807a9899fa269eaf16a8b3c1acd5b99ef128f038178e54d1cce7659ced71a3267991216a829f66ab7bd0d0a60084ca00ab2de6087baec2ab9635fc90f4fee3e3b40cc12108a1fa3a4eb78745c64d06d0d78659b4722fb6f0a68d72d22c3f6c2033bae3fd2866cfdabdce29159c3c228d2959802207a0dc5d2e484870270501979c647bb6c5f3c272b3c0067cee90f19eabe0c2f6195dff59acebc3ca7855908d6a3e78b857f60a4a49c902d6c72a3dd920f232c72bf53566dbcb0e2a46eb13d2f3083e9eb4c1980b9fda859ae815d3df29c5876c86943126ba9bf042396a6c99a104fb41116bcfa6edffbe711876b0a85af4d805e73d9ca36e918a0754d89f63a5e7bc3742b9baf159122d034424d3d6faa83a3b21276eb858fe268d3e14f696bd1a50df17cc030350a2ce989413e14920f94be8175e38bcc9043660e9f6c6c4b1aa44ae16d5c47fa6620586e69ec0f89494e7840d9612713a188a049b0164d5bcb0d9fedc393ba15b7680236c9952805c2c10c80606e865f64285c52cf21f5729a6e8f4a57d296e2cb7212230d89a4a5bfdde33f7c05d4764b97e15238dc07cb4d27f8a44584d432f67ea0ca7fb5f07b0652809d5dccf51ceb211896aad9d0f6b59ea041687e681399af726cfbbb32c8a8cbb647b3a9c5d6d412779833a02f670d0cdb84a84955550ec1a9a3c215289c61c4533b4ebde0334301aafa107de760f3021a07affb6f39806ae52d39f82c36c1e1e774bc71a8adc10f3531a45206e3c0cb3ca2fe31ee4fa963a192c5a5c535c351e9cc57822a0ef8f9a7351937910e08e6494ef445b7f09bf22ec9b07e8a75aa887484e5a7c0881ced2961c02b75f73dcf7de2f7dba2056fc115ed77298e6718d96ed6d58085151775cd34c5f571be2d7ce99d8b4fdda9ea932554b707d14f5fd861041a1a92c491e073f7e7b84bb7f52888f48b48cc3d5f63f4c2d1393eea128e231324c17273b71c1a77aa3663acbc5e43e154b2d83768a30ab7b07443edc0fa1b7f91f707c5b3db0579b885e73c1e2b9cc8722bf958bfa8ff7e72121de30d0c240eb87ec588919191628b50eb81f04352b5ccb2e3597ca908bf54bf1c3db4d7abd94a64ed96e6fc61ba164f48276b1df46399d47f19ac747bb7bb46a86fceb9d809dfa295d76c7d798bf51a885ac30af56f4850d90fad280935864406bc49dd5e3c2dbdc31b724c667a3f251e3644d9f48bc12039c82ad2de1f9e891a02f45fdc34e79a86e24b311938c80d8ff3d2f36c29db3964e9e47f22420678a5e4c6701ee2e5778fd1581ae69443adc8753df9539c0a254465099ce6cdbe2f0d054e69c40573fe0c3573a10d383f4cec168c0f2d39460655ac5aa66c752eface73db9fcf8251502b5d2672bbb798581bd47deaae038c92448023e8e4de755b8191dfab10c2265ff90a997648778afc3d84a8191203d5ea096b268d1e55f202458f1ea87d935f5440dd5e3c7885c78e49a78c717da413b761ddee4e88b7475e46176770c752b6394235ec65d31e118f3ee82e51c4656877acbbce006ea435fa70fcaac8d033ac8d3005fdac50d73f90925b712fbd5ccf16ef525da2525b15a669cdbe73c9e0808e369754fda0bcaeda2dc0122497559d0289f698b29491ec0471823545d26cc6f10e7df52b1af0345433831966294b61a72172c86a24d320e57716d35af2bc959716e412aa54a2b9d710cbb3ac5a15a67beae337f042ef53b3ab54e112d3f8dbd280f11a8bb296107004411639637616bad3c1414984dc970b4588570577bed5ee45e99574e49a5138bb77dc0c8c87bd5f6f2b8ba1b15823c1fc423b5057b3bfcd0be93a616b3ad5efc02ffb95733ca063d139b808553094994761fa1cc0f945faaa11cf6046f8bc704b269917bf5e45ddd20e44cd78c9de36087458c12fb1f4f45518847f34eeb8695d4ef1a13fda0f07f9a37935ae7cfe71c8d4a75432f5ae3f634b0eb5412238583b07d8cbf8b3c732f9096ac653b6910b8181951b81d410972c14ec930750a8e91ea10d3ce1136144af86b2a650e7d7c05b9f0acdae42dc5fe41fd4cc23aa6c9086a2da164ae87fcc92c6508b972649e4564c35c6b743e5fd2a4f8aa4d7d64769ac5f01e1a774dd124aa19e934cae13a5475820b17191801e6517050e9259289fe860dd38e6c1be5be1a8a505c3a20b8f3df9fb07f7466ba266381a0ebef057935a0b62a3eb2d6583a06b88b0c6be784d70368774352ced5f842ec17d953368524a5b092ae38c75e733efde444221581442f6923aee8d3145a33a96dd10f904c1dd10db67b2ea59f4a827f6ead28f2bc1399039b8be0a6ad3cca5f69f8aba68bfde29b740b91ef55c357014be9edc4b8638dc29b0ae0d2432b1e34faa8de74ee6cf95129eddbc5130f13ecfd7761054e313e4d12c54be195ccb01c5d9e785fab142c56c552dda749e0717d661470fa8b0efcfe91dddcd2c9a27ebc9d839a7cb80b7e065deb2efe8318d7f39f299dad59cdebcbbdda2a914fac021fa2adebb3af17673815220033510843ad2352aa1f4ba3ac3e9500d6b4b9ac0eada641b8c68dfb305b1594b1cbf8bb97c03180aec231c996da21fbd44244fa487c1c232d86b0407f761504f8ac1284fbb5cadc5c9842108d5facfb1ff3941ca63cfcae037779fd5f3c650d88894c7f4b1093f0d95d21fedc1b5ff6cb1fd89d9b03d0e5c1f2af7a9345c0cc7b122f8a7e9be1d364b2394d47e41bc001199219c4dbf5bf59ef6e2e414961ea3e3182d65672317b756f5b63ae57043da196fc50e9e5cb255f0d185db6f0f14bcf1e13cd86e8470a5c6f316dc64262d3bc2f2c4a85b95dcda91ccebda62555920051abfc873327949630e75d71d377b228bbf3d47dbffc338cc11fe2e263ca9b1d86ffd0f415ce6c04d3ade65c4e6b18a98ce2203e6c89ddcfddeef772528aa04179f0fa8470a5881edda9455acd24ce91aa3f8cdc2b2cd1c6caa796dd480d24a27e90e352773ff575c13e0158c41c21d710b69d1dbdea2affacadbd78a9fae69f5d3d070de97872b15cef3ed3074b7c826a054484cd4c68c4126aa1c15d1599b80e587bb81eda34304bd5f1a2fe37e2dd4e55c7d8378327bc6e9a1576483fa9e51bc0a49a5c2af31109793902aa46e2e164a14813e68065ef0004690787384fde8b13df91732d239dd72f827c48293128ac2b4dc0a9ec88cb18b850da8a73546796a9000daaf7043da2eb1531734fc4a8b473aa8076fecb127b7ddc3b19fd9032481aa54db05299275036539457a6e45b9c89a601fd885d8da0ee631b9b3fb7ab630828e1d2b4c11c3f5a6bf2391e53ca3685243b087bad2d3e9caf18fb292f38247b8ff4c3145ab0494b9189f89f632fd6b9a5f49b03d5a6c1e174415c4a3851e277a8b0f350aa46b2aaa30f7806cecfb61006127125dec58e12f9c652be049f05b742959531722a77c230e3c15ee545911ed95f379298099d59af245a2dd54bd01060a58d396b6d29011e417d5d237336114984831b002fd6ad36703acad1769a265fb06c6517015ecbbe5409d3faf3acd154316868fb9c14b03d5a0809a182e4cc3261d8fdce395b0a7f81d15ed09620eb462f8a183753ee125ff34f3b87f63d9c499d267dad9741131bf68c832c2f5423dff1f43d9ff826bb8611d8bc81ae09a484b1424666ead6f9fb1846c5d7204223819c8ee20f6f0bbe64947c70a3da7e13d7ee416ea2d2f7df2b491e525a7e5e880d1ce62846c527659876899f828c95f54069b761d64faccf474dfd3747c590c98ee6acea3ce6a99b949a8dd81e2f89ccc4bc96730e044e9929a358fb246bcbaa926dde1308b49c42a40858ca59258257b4e8d1bbc539122bff9426bcec1601ec6a067c6f59d1f8fa4ea643c7ec58c5e293fe83991d898133128f721463824e27348350a7422950113c99a7bc1710a07e6080d4d7593a17b5a601b5f71229489c516012841b802b25cfee920b12a0305922906204835cf3857e4b857dac6b776a96176836d4d71e35bbfedc4c62e1050741d66479868522902c76b8b3ea0625facea319838a7647726b4caf63a7e835212b5c76eefbf75ca6c5dba6a8f35e25ff75765f43767bf25a07cb00b23814a1f3593919f19b2e5c8d8bce94fe3a4b1ae2b47c553d3cf266dc6719bddeb64adab7ef4d3f064b09da1d9e1df121a4daae20f3a0c8e2467a8a485460a887c669708cd56e904d0b1bbdcaee91281b7c305d69980fb2c1ab8cfef3e2ba589e5cb16fcada13baae2097b7e19d038a676f944e63aefcc071ab768edcb4c9964bb7ed7ed639d3c5352a9da218fcc212e0fcd29afa26789b2d1ab36be9450004a7dd28fea389655b4fa3f76d5d2896c6cfbaea7a36ec0d3ab9b162dcdd17898d3c7a6e16a7216cf2800317ade17b9e6a0e9fe1efc823fc0a9ba816c28bb3c2e28a2159ab99a6ca7b056abfb6be6b03dcfec834097fcb0f2de00abbf2570e4c59101c4caf23ce4b3192ab32c5643904d19f995c6cc9c2c3cecb3a735f2d2f4cc20135731ce2ecbfa5cec3a7c00ace2a2381f65fa49a1162d1e6a92923168a2884f2a1a16131dd9322d575b8ee00c0babeebf31c6fc4b6712112e00c94d98e9e51379732a2aaa47e69c3030ee507f9badcc071039477de81cf4d03b006045b8d6cb2f606de5c5eb517b37bf92eac8075e3e7d6fe1f7fbb07eb07cfea0621ea36a5b335719a3b22ce618fa9ef7abc250c61408a5b1a94f857256a019a7e25b0c8f30a9fc1cef447275d67d0d6a16517b29d32b53bf61f0901c245b18c46e79d47840288210fc0b5f5e406028590c0b63bd4abc1d6025629dfbbc71f0378d8946026bee6a1e670f629aa3756afeed0fd7b64b5ada60f83c6093ec886c7aa8115183b326064da9712a3d42f816bb9f58dc96d24cb7a562f689e167ddec5d261edf0ab3d8b4440504af1848260ee7d17cdf12110862c101dcf8bc346996a7007e248610e413ff0f677c033adec43f5f16310406e2b3180509b4046c15bb1e9b9b6ac7137565ce8210d380334355452301551587397768bb92e3a8606a17efd896dd0bc743761b999d4beef07b7be825732b853770c70a74288c10cea9d02ea5f527fe9936a6adb18129922675fe59c4d20f19c5cf1c2b7e4c6a95713ce1d0f2a361914e5dbfe2e87fbb7e3322ed44adba4117a8f0f0456e7e1e51070ff2adae5d4bdd4d18434fbc9a5c2c80a38617e5cadaeb586cee02962ab3764d415cdb4d9b44bb98fad03b7ca04d025c1deb94b2f35da9dcf6e9b2111613ed76324046ad6dac07733e6dcad5ba1766e5573102b38ae3d6964c1ce29152aa81d4c03adb24ebe0c5101a9378588a222f4768388536a432fd068d15ae433cea83af00478b9a0b40e8fe16f84c556c913a897a228f362a1a0468aba499737e59f1be986c16e47fd680abd79497ac5271019c7278d6db7e6a4a1272cc70a0edc146bf45a370f6a8f8ad9b7039a2c4ec86b8d78b9d3e6dc15e34203e69dc1f47d382c02bba39f179a552d1e50c09f86ddccc60d234d67d5abf733e77b99b94a8bc59bc3559fbaabbdd0787864eef1bf7750530f6460bd737472eeae783fd78d900878fe3627670ac6e76808d8ce79b3b9f0e013033b2522560a60ae9bacd565abaa2ff93135dad2559c32e3773ed851ff5ad7a8ccd9a3f1c0f36e718fd25f39aad7e029fc3e9425e22c3524916817bcc02d89b1b8cc43532100d5066b4caedb3bdf64ebb4dcaef7280de3298c0dfcaddf0bd5536e59fc2bc5c2ed4189d9e6651560eb5580ede118c3123a3213797e8be975c265679f770d5bdca8f717a7ba368ac3ba5ed9039e9ddbc766609f6ab565cd22a8f86b1541e60146ed0508b3a407db218e51282ac2807c5eef4944bdcf09d0507f17609ff1e3beb9bd543079127b820b1fdd632e1f87817e83ce3de696ca73739c547e6f99d9efd16750be78616198254f99c10b5eb6071e9c661e9b34604716c820738884da08bdf80a98977fb1db141cdb5a9098c3b0d9c731d799db0069c6d4a6503cb337bdecc60495bd850177ca492de31caed84e8d4976e18761129b3f4c4923e47a08ca9e10f1b6a73ae6e7bce3e6a6b37a1d5ad3789f72175562dced0e5efae3f3e69cf96160c4b4e2b4347eb83d51717c5e47b47acbf12b98d6b35cc9bdfb49946de760db77da0af2f8901c87ef45f0d39ca7d8ce869bdbc4c05e404936edfd688bedbe833d9694757d5538c7335739503ff08e710e32fa1a439d062538f975400a8cfdd31e2a39072b7029c859a631e40a7cc5545d07838ea4a39d71d54c1a190fcf2adc8fddcd68c0466c15e93ea0c8c80e19c9ef4cf9b7aa5c29347f239f334165bceeddf79cdbbf5a5100cee022ef77bb7076e7f0dde542cfcd7383df77f0a79e77aae8285460d3e03639620a30aaa5fb1b84f8ed25f0d0d5c1ea27bcb07d2006fe11cfb58c2c730a3b54f98f96d73a1d966a96a59ed38f34c8eb44963250e9dfe9d066a5864371c7682e744bfe452298b7aad06d999c334bf7da715a033dbb1d712c32823f6c444402dd0aab525105e3cb1198397018bdbd57b967870359acca9effe525aa5b1c674cb1007995622ee2b3c8826f70c6978513195332086ad9ed72a53c3648958b638a6f3ae21260773ecd1482b2670a118b02121bfddd240956683c0b2624387aafb11a002c2fb16fae0124986172af739fc8ca21f025a452e2054b7daa2c5fb2ad58ddfd57940560c72f56d0fd792cd49c1a0c7d058bb08caa8aff0ea2a7b2470ffcd3a7fa6b99540276d08e1ec103e42bff79bcef5d775b95d1311ecb36a48805e0fb48ec9d55f75248ee5d38f522450271dd368f1ced0285a27e623dd6330a95059b43edc41c556c2a1b267167ddbba34c61537d7966a6fec5ab9bba9610dc48dd7e48b1a09fa589b0d7519f90a0c2dcc3ae43143649e12082970133ea9721b53409f0bb03012016ea6b91e630f9f2c31592b33e05c9eaea68a63ac131d58e3e36f4a1e43305023bd90669961c10d568956a192dd7f7319300aec18dbb65496131ef4371aa9c03248cb36483e8d859fc4bdffb924c67655f316d00d2ec8cfc649f7c644508dee6ac00628b46e5903ae271dc83f246b56ac8013bc5ebe4f83de6a875e7965035f3bf2fbeeb18462aa87e4d0cd37e8750b224e0fe688a4a942a43c69e307021a69db0c9f41b5891e2d954429d47c273274851d2f3149662cdbaf5ab883bb7931725115de628850c99d2f015a2ca428c5926cc7c64e67c5056af44850d873c6153abe0adbbb5e1fe5ecf367e7308e10ffbbe75f61c2f4d009f462fc925c5b1b047d7988513c4c5c9ed28bc187b032369142911509fa679e96aa28dedb532bfa679bb2c7fa6b98bfc4a947d43bd8a92946aea9a0bd1e9818a667ff4ffff05227e5e8ac5f69f7f5cb7c683c27a3cdd194ce4e8e05f34ca9f2594164deb1722b72c96e7727a07291550eb9a4ecb0d8d653795caa245ed552a0051ff19d1815b7de072f34c3fb266af3851d6c2c589aa8825b1f3b34362c3bacabe47566b2b118e3392679031e5e6f16d22d099b8b9f8d2cd0cf800eb18d47abf89e2369a4ac6239036817e885272ca661cac3ff9e1875b213431cc8742f349ea760714a66f65506ab50385cb228e453e2e915c29441658def79178b995fd4163efcce4a24438d6cbbe3c8349b54cdb774d222b21837cfb77448a2ee5f895a1c5e290639215098ecf11eba7573d43e9fe412c1471028495f00a658074daefd487d5623cf2af6ba44870ecf3e2851893e941628036c06ad644d995850262a0a6362fb43133","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
