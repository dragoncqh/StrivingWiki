<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3190f68d552b36618a30be1c201ad9c0d0793b7b5790e0a5888887a2976a0344d64b959424eddb178115be939c0a38c268b8fd0603b438c249e558582fb53ae0de0651ed20c2343c1f953d728c6cc0093fca6f4170926961cc758e763fd75d8d46b5d4d1a4b8a968e3f791eb8af99a75c0f4eb907b8614ff221bd1762d8b53cbde79e95c097a2b076f03654066703f28fc22caa56475492bb298de15c2533fcea0ab873cf975360869c9eac9567da5592f3e7423fcbbe3ab12cc9cd9bec0c7e0ffc2a0039c3372af45827a23081b0e3fb8373366a1a8755363861526d35950b4bf0f978dadbb98c32db629c6217dfc3677bf8e5e99eeecc942ed78d77529973bb7b3ab3d7104802f7ff070a146d091d73d54a2782a106225295a069a52a89d4555d19b5daef701e384096d94db2f2953133dcfc0bf41a3c7bf00e3c048a6794cd3e834b59d6c284cd653176bb712bee7dd9acf64d65dd3e79a7c7f2df184c6f9dcc20630823120d1c2c2983d9eba659b7e9c7375117bb174b91ec3a4c850e161b413badb5fb3ee07661162b12b7c2de9328833847c7c92c28e6778459a05542d1f07ad78ee07c5b46203e4d67c1a20ec756e1843bf1c69efb1241723fb6a3954643a2e27e1491a8d9b13ba9361498ca7159b212e6a10f0608941681d7301eac539e9a8d2355b1bc9750261b788468a09d5d448b16229faea6b3f1197df84f5cf449f5ba8f64e2e7f80577cb950c62b5042b2ce21a2f393b3dedc19eb3b764116ab1a19d14e530f52c594bc5b4138e08bc93e0da609986f537577fd5c67a4042f87ad377797a850483cb8febf620bcf614d4caa7af6ef0b18b22a6d5d94ac641f7c798489fb2f5915255e3a25d92fd172d3a3cc909aa3af0daa4b89bf1cbd1fac65d0a19bb34faa4ccbbfa559295284acae2817e626c86487d2d2aefbc888ade7f631091c1320f3c034ff5155ee747c51ab3e18d622a44dcdc1a0e37b0998c1093a44d93d7818ec87f5e153e4c1aef84c8195ed41473ea8c95bcd6cf50f72e05f2af0ca8374b4c132147c71a12aefa030ed48612ccce058ca22b30e27c7ae59e91f9aef14c91c53b5165a613f0f57026d1dc6ad015d07aabe83071356f9aed59a95d5d6721b06334c76f9c1b12de2cadb10a2c78a31dff93606973f24504dc86924429ef365944e1b0aeb94b694f777ab9531a7d8d2ae5e779c566b904db4999f358deb2552c2a0c8822c4b18f52be57b957a8055b016456e39e84ba94e198e11f2fd49b9ce08f8bbf9d9472ac4b0f24d148080590a2ed3872044ba7243880a9e9e967cb1cd7c117fa2ac02171f078c0a296cfb507c1e598dd3f035f2449d236daf4c3e31cb7c41eee26e3e703c4ac0615e5e67d516343b50c37f7b045564ecd6896ca3da6593f3aa7b49c319c38fd2ba6903f3ce16353c1e226e9e296184bf38d3a647a95524d5e6a7f5b5adc3c24fc568477641a6280dc24835b36d2811cb102b3d36d24c4e0cdc0aeeba2b52fa8531da813a192d9662c49124e15481d0f9e89c28d1fb8dae29694b2e98bcc69e5f0b522eabf1848bfb7efee39215163c0fd4ec6e18727deca9d07f47284f49020190b9c5cb568724321e7b2a1ed1f9f2c9f0059e8d5e98fe6bd835448824ca687823b895b0787505d97e2fafc264f1193646dcf3a7f5183e169505585ebf2e3a50699cfe09bef74fb8f8d5da2781b2b0138c8be2b2616aaee565d6fb32fa673abd29638f876acc487a83c59e01a8855c6c09fe581ae64ce8f48d9b2372b7680f7235135291a44fa06a0d8392ff5c4be8ea0834d1c60eed5f01e1a727c53bda747ac84926b3e08838759937eb0904ea9ed114f1abbdca0a999e0f0d934d56c44a101cbec004f89f90deea2a1167785bf3c518f2791e6b1ed773ded1308f585d4e56058860f9103802418edd7da298d1f91c9a307721d7a1a39b8588f64d64ffcdd36219a4c48a692debe4284b464c1ceba1911f09a9f0ede41841d7d892652bac044afcaf42583438ec478a9e2c2ff0a0fb64e69f1f153377754db862b9a0c847091c676a5584734a9fb053d3800a2491de3ec73a1054231fa969e5742bf1b0efbc59a72a917869a777a90106858e42cbb2c6600d404c26cbd8dd4d91b620f7ee7124ac70a8e97950348562aaaf77940ce5434b815501285cd1e6dbb5469b80b57eeebfab908414b6af9174a8ffb693c0ebc3fc6a112492951a2dfdeb26608b664955d684096aafbcf32ed464a2ec1f8156ddc9dc611ecdb4d41565d67502e0f014e8990f220ba0c9511f3e4564058a03f5859895b5f9c8fd09fb187cd99f4e60f3e7d463b7a18a8b5dec3c482dbdcb4b85a8a3302eaa8ecee11d8944952650a804b10efde5d8427036575605ae191759176add41ccecb9996a8e9dafb5d0cfa162fb03f2b151e448757aa370a4fe233d735acb761aeebe4ef425fb57e269c20f5a74f5b675b6d6c51dddb07d8edaed76f60d4d891f4c831cce21fe1e97d55ec7b79f70573046c439b01632eefdde8c7202e4cc8fc67bbbcac5375fe3ed34b58333f7f1108ac9cbbc7bad4af9a2e1046e717e01ea0e419f0cf30314b3c4363dd62358bb27d6f49026b23e6331b4a13ccf6e8c5955b71705bb81e8fb9a60a7f745b4925809b2ef0f6bc470315537f2cc5f0804c0a1ec1050a0d3d855af3f63943a0ade1b8252a6c2b9c65fa37defa5faffda320fc454abbb0319da25b67273cd3f8d3dc2db144f723777c9dceb08210b98602f6415c52c8644bef6565450b5d07ff6a38369b0ca65117879bac542f3c63d418f22e099e1594da995a06aedaf6be0a801cd5361e3af7d744e6f45f0e5c8d975ff12b1065413010a1ee14f86098a856fb53d36279bd13df3d0b245caf4696fb5fb26262af3ada2d5b518265b4f01c99272414f08eb0c9a2606c7f4ae9e39cde17998b2c1804cb6616781a868171bcb2e0d87a36d5b7c56f241ef927c11328341a9fca062d7572385e74cf3956bde4599a437b14b6bd8f19b763b7e3170f17f7862ae2d9541beed90c0c65d629223d5e4f84ca6dcfe1a66c1c9b8003c82a8a12b1a746f6f00985dc9538ba91f320dadb04fabcc4c714d86544febf900df9113c60d175b410d7d90bc61edfff247c8effc75227d6892f520fede8775112b49fee1a72291b1c477c56ade3d56755ba5f02770ff1030087ecf301c58ea2dffbbcc851ba818d33687b8b504cf8e3ebdeabae5c3f92b69ef264f824e1f75d1328c4225a6edf564682d607cd2ee4fbc95f534050c79c911cfd9816389221caba363b2bfc41608a9f8ee02a8bffcd6f40b00e4a7a8beb587bbb5c1b30b9a808f6521625cb3406ed8b2611533b3cb72806a8fe0ccafe0ef5a328db514c336ea5a42c5a52d4ccc6c8d047808ce27f077ecfc548837cc7723a609897d5ede66adff75b4af4fd0e9a906d43a2ab567a91875cbc558a5b4850f95cfdde34d8eb8c3bb36af9fbe5664a092459b77f333a87841013f421e0ac296401eac859df2d75b601e651deec0c07b66f0f31ac0f5d699a9a884a4e8699abbd9f8f27355c99504a73729f235ef52d6bc17107fb5a3f36dfb592642b8d3ade6f32f6cebb8525b700a84bfed41426ba529b2fbb74a0c41f40534b237be6f4a916bf6f3b6396f9e0cc2d20032d894e73864b33fccbd87e25191ce76360bb01a3cf9cae0dd6b2088375e86c0ee9a0a49def74ad06c9c35ebf4669c0096e64b50feec10679e1dcb201745bdd6cff76f42e1ddff674d0bb9b325f8034ac074d72fb28ab1b0fa5cda7acc298ec3192a678539dbabf0f66156c2ce6078a7c1dd49addd98fe919478be8fbe0cfac9e3d9b12d0337bb7c897809c30214fcee1010cd5c643ea7313b5df1a5b2e6bc478fe20672cc95f0ff5b25cbed82d85392c8eff1fb9ddc5e176a84824ed7d39a870de8d6e93ce685a9a83a245495e6f2fb198110434bc241377b051db48c48673b6cdfdd4edb7ead1537378bacfae2ae32df3df328567930374747309d53c7df58b24278830ee3eca3c3acc97e7bd9bbcf9950b22fa7e06eefa5752b969ddda76505f1ef56b0c93ca1af007928c0184d7f2c61647246084e57320ae538e4901367563e7c801079a44d97d11e9ccc3d5b6e670b61ba645e08f76e7e017fed5952c1f26eccd917f377273a6c3c88e7aac37edbae384d120fdd8d1a6a019cbd65b6b60dc2fbbfbcce817f71e8bd83e882a99531b098b5a9dd894abd2cf9627daa5d744461a612d97ff6e64691dda24b4be9a6c0b0f1d0f023815caf1ffac7a6c97d6c010d23e9f7441b7783745acbb8e2b64d529c4b730ed445a1e6dbce6fee4db67db71a9bedb4b964d15a9ea6673da4d48b50e4702f579adbba43afe346f759a1d9c6c67c2272e07bef49ccb06327c59280c32b56d0bb634ab0a8352f20ed6556d76f12183f687580278560134c3856e03a9b53da9e2bb12b39f4a99692e470d04614bf66ea3969048eac539d8a4bde371b6e7a9ae68b209ecc2f36b7dcf9807b8904e7155d2476b364962454eb418a5096a95b2bfa6401c90e687bf6fd0bbb46f426d610ed5aa08a1e6fa470f066e0200c74a41e86319cae74e9e428f9a89ae1bf9f7493fe4befbf7b7ffebba08cb5ad21d9c9b28822a76fc1994e2ab6445cd0773702180d6a661e8453afd9cb8ed8d7a03a4c637217a2abad1a8f381d6144c0c6555e16ad3351efaea2f68448486e3a092c925fb8f980545aa38be4a6b31cafa8a73a9c7a742f6e630458ba7277ee8ea2088561c76350818088de98074ae577de31fa3a01a89af2e03d94b82c1eb48f04de05633ccfab048d08f12a0e4cccc9800e04d51e2f269d72d837cfe84dc2123348c1581551a288c6760ba6b29f05d0476f5b40cb639126b5d694ca61a7d449633af67aaf84e11d2fe875b536f5667c1f7be47cfca2477a3f14ad16edfc5c88c4e4e916519ecfcfbda4ef5d6e0cfb9442a6a691d494310e67fa07d611fff16396606dfdff5260f2bec6ea904779b2f0c54f543446cb67165c67d1411b7706158fbc151fd172fbf3d5e4a4d96c638422008b587b8ed4dd04e48db2de9a9d5639a425ff52897c58d43ea2abf3d5e865ea2854b7c8f96785f7bf31f50cbc227b20dc516cf7b1cafe62f881f09fab3cb7109f3e40043142f2156ad414d4d93295703cae242c39925626979091b9a1eca5846046bbc02e52a20c44f7fd4679913990f21a6d3faca960d23deb858c5be6739f90e222e59156c1c1c57ddd7fd03b43c445e7cbb45a0a4474dabd07cd5d4656ff77e7707a8ad5cf2fd7a6ed329fee91aaa5d0326b39f0d6718145b0a92b182f3c368eb36821b1f29c0a965ba7070564beb1e790338519a6405060f3e3f9bf5a799c8a7744d9b7166a1eb280733c80ffee2b1ec11269cffd99716e6a79dfc1a54957b80fe7c8c08fe2ae6d29379099c5a779636c56e499ce22450279f52c3a19b81f62a475de199aa70b59b97e572bd8c385c63b42e3bb6357d657b8e291f662fabeec0c44dea8806b1b08c977b3e3473bd4f32f9a9371e49a49bd69f31c3298ff58c833a016738dd122b74a6cd6697d33af261cd566a74fd00ee301bdf86bdf0b65f64dc9c8150b5b8f37e1974acf60730f1a0dddba6f8219db7fe966d86fd5db0155819f31c55a0a5fc8d819fd06aabc5e097de4a72117e1738982090a9479214025463a8c6d7bdc04431342f21521e2ac52f0a676f7241eedd427d32ad8cdbccb048a284084cc2e33da899be1be3b488081d4b14d7ab14a7825d875485b900fc4b97ee4c9b851c27ad463db450a19e2965d5959a6db54da0661579e9b71dea44c5f2c97ce82e1b59f60790304ca8dc835d6a4d997bf0e743194ffef223d82b1797625fb508dd247ad765574b437e5d14773b35f7dbb9300dd50042986597d9f300f4940822922607a1a73e3b649cc03f08f48c729b539b2f06e84bffffc6d7875bc6dd01aa8a57132228768412ff753b63e20077d5b4adf36a3615cc286fb336ac2ec21ba2b01e141fd8550c11579653173f954975713501453ec106f68a27c86713f1391f9df3f43772257ae0906857058c6e3b08ef5e395afa47eab584debdb560b79acb53493a4244bcfdf97fcdb1a3a212ba543794dcac5c29641f73fd315539753845e5a1d6fa22d887dfa0a29f61dc415c3812643ab096fae662bc575b0a59a014758c2d576edca15684d0275c15451ae030d384a9333717ad9a940da75e939075b5333cd39ea0b7563bbfeef6e840060d0e80fd441d5367b12e41b253f775afec88c5559c631d08eaa1425b3310b8351073db7623f1f6639128b5405339643961bd37eab19fffa132db251bcb84bc890300a1a2e5447bb832797df3f70cb649bfb527af0cd3d111035be9e73236432322dea71962c97a2bb0d61dbab3db758ddf06aee8044f7f9980fae639f8a558781d0f40cd10d84de9e2cc12ed7233fbf7a9a402b1600e2bb7519179f77349e1ac96590dba5c5b6a9a86c607b851d7199f258cdc98e743713904095c72dae79a7561a6cffa8d2132a7a8ff9fa3de0276b2decb7066dab0a706377d026c2e729d0a7a9f8e104c1297fe6327466fe545afe8098a882433ba9f85306f3932df7688ef74149a57044c77221ef22940e7060cc37e4f7b69557fe442f08bab2773efe2234cd974aee3b03b17d3ca2f7c995e4b3a4c2ed740e1da27dbf45cc9c12f06a316a77b040bba613599def6b72264ab8af0f03297ed03bcb4c14a0dedf778a27e56adf6fa44ddd0e648eaee86cd9cd1f645f4a907b34e5626729d6be537c560081f82e41a00c6b893d0882c8533d2bcb390f311008325bceb1a34df77ec3a7fa16646f5b61ec5dedddd76a2fbf9800553f47f771a4c87b9727d6958ab65144c197b4a4dfc544094003fa85d136a787b5a7435d1c5fb01f4c2098f1b4696d573542d133ec42c44a2ee0f294d8a8a2e3bd98ac1916b7e12fb2cef674acb2ea15cd858637d0f95a814162e01e9ccd4b27c5618db7f4b90e41467023274ff1447bbca27f9376f9fb078fa26d16aca9781bd06a86c9ab340837daa7d423fdfb0ce68739b5ded551036dbb8f0bd1b0a49a9fbcc8855cf3463b103a891f6c96f84738f07fa6ad73303532150e5798cad1df667f2dfaf702815cce639f361f07297b2b241e0578d96d2e516ea242f0d6f2fd03c2c26487e96cb4f91d16717acaff3d5fd2b6dd68c21b39efbe276cc566ccdb34b49a7fac5afa9b3522f6000471279cb0bdd41b99d19548892dd7e92117ee318f1a59e9490ebc7ff9a0216203d451b9fffc331ca0b5f4dd6f393dc9b5c0e24fba33103b5790ed75fce3e8f45bde7eb8bdf201fba9b125f55f6814e00c3a480ff0ad6a77edc062e5a2d29f2ebc6ea94b21e759e880edbe0d8e8903a547e533d5e09865f283946cb7357e86ace867bd0883772dd9c0d70cd05b0d3c17840ec76002c379535d5d62ea43de51139272f1e3189f3bc8d498a530a9aa813ccc168b569aae8b393e4fe3fce1af484ce3b3d5c78f82022230292187741524a6d68d3da621617d5938ff2a83074b5ae501d2431efb004418e68f41c50d161a634732c61377ebd9548e211702edec191af502fe48b59793d89b8aa08435a4d0a15f80090294238c79df137fb746f891f66b94216c69305cf80acd4ed1f842a8a375b9ea42643215b54cfae53c8260ba3d9b6021d7b8874d0e7c7a12095a57f976ff8d7a332b14a9fb4d7aa9fe3d5c00fac418adf0a58b3d2a1761ac70a1c27991493a72df58e5894ad86ce117c13d6f2483dca735b228aaa79c2b003b53cb1e5ca3f9937692d5cb0fe40fc35185dcdc8e1d7338b42616e9560b5761d0c02231f539b58a988c419031796764ee54e62d3a343535444240513e31b8fb981651fd67ee1ea577eb91cd68d13e96bd92f3c692d6e80414a873a5ebfab89c3f599a3dcd895555c5e3c007aa2d46be465e078e06ee629984cd8ebcc5c51e3f32af5f5d623565461d34420d0345f1f93009875204ef03c06a9e84700d165b4b2008819343007789ec09eb6145a0190fa5f4f65bd8881f8ed58ca94bd398e016cf9c7d3c9df7c9ee1e499be29e835b4643d5bf49d7d6568ca14be6747aac76356daba4378e218ca8856a02f7b1287ca69133ff00de2aeba7f9d2a7301033a88ff23efbee254e540c1f41a6deda67629bef00326d9aba2807b72def7a93abf7184dce42ea8953934eac9ddd45c14484d41e609cde27e2f604eb7c079268ef75a9c0d422044b2e9976b952bf8adfa1df2a792171e3f0a2fd5427d1ca6ca64003961ab953662fd0ddf236f8682fd1079e005e733023b8d6cedf29c334fc53364c865cdd96ea9d225c512eea77992efad5412b3b9fa11a4d5247c3f17ae891cc1490bc9fb50b7dc140f1d29f32a0da792836b7dca6b691698376c1675b923d2c9996c437c676be4e146c5b65381627f421ecdca02862751f7799579e77bc94066f426d7decdc03c2e8d7544e92db360383d465464d6d1c59cad4b6d783f3e20bceefac3ed44675a54be992653014e477276d2dece2575f63c862096a1d612fd2527ca37f468df5bf3ea07fb8d41dbcbfd7b3221f5aeb9bf9ad9db5da3d00d58bf0b925ec4da31a15eb971ec1393aa4fa2768eee54a0b2a2243fd1d6484b7fb2ceb43dbb1b2705b379ca3b114d73c97708229b23e11ccd8e283ada8eea668b1bb0823a3bc4fa613c376ae374b3666d3312bdbbc5eae377e4ffbb967769b30fff71700d0ac244276033cd4227dc9c13e741ef1463570428f3f9636c55f63b9b9697ea976bd4545e4a9615f400c4f763b0d3dcf813f59e0da1e02992e70d1afa6085da3b3aa7aa378647141cb2639b86ba9a0edce95bbfecac6e56f29f592d8db3fe1aee610aa4cdddfbe8931d56fcc250fd055316fa983269f959cca9a814379397494ec136b5bf5b68fe2794dc264de79021f3b40882ebded327e6ea46470a049383eacba750cca35433d6f1b82e36713994e5966bdc78e499844abdfc905059fa1a617143f86662a2e04a10039388be20d07ce6577fcae776b6e44ea67d9ecd47e40bc8c04a7ffc2d31f38f98e4f77a9ed952881e87aecfbd4b8489a24d46858483d77a17e5c729a02004921f159abaec9fad31dd7f7c230caa8310803fb37b4521208a78b4faa48951de365d53a24928f71533de688eb39cdac62c66eedaf491df757bab8bb92bef98fd4a081011f6f41a27193ac3b5dccb727dc84a2d4cd3a219ad1a63cb881679cef5ae94d94777c3b293e1fc253bcbd56a96b94ac0442b09bb33d355935359f826ac018dc331cb95d4b1092bc195e111475f75cfaee729e505c75b39b11c9aee20ceec3877f0785998f1e17f1e3c266ae3bd2eafb186c2d3836f078203b47d968dd36e0ce962c47c6f46a06098c13edf8c4afd921f1d888a254062a1371901d28c20b9693beb8362a231551ad3ad2a48ca1c4db26c94b239339e4ebafc7b28861155755ba89a5924c56f68fda598eed9215398b395d639e040836d696fafdc8631f8f63f981e08802581f92350a622fc7d197a3fa3eb18d6324001d5daa3f2ffd12d65c2b9fa5dedc4e744e1d8d855aa91536ca3098658dd60d9a082fa3bb0a5d5fe7c2fd7f4933fa79bbf346a261e8bb74137e1b7253303152eccb95d1232d0351ab9efe3ca4509a0d888b364647058a2fa44d1117d0bafc0e64f240c89e6c9272c0fba69fe0ff6f553c9b9ee3f6d0b3d6f5a82f9a8cdce9a9f1fd525dfefb9cd000b30d75d49f5453fb6a82cdde99aee6a46f943432db9c2be51a5b755fec4ff5857b9d959e2816d0c939d8d1bb5ba0fef393802518db529fbe9d1fc8b67c62d7e3d18d4a6e30aee675abc93f5dcb1f8aff59b2ea7443944a087b2051ac3533d4f978b3dba458ff2d5face22d30c6dcbfc98c0c7871022465d8910ff62f7fccd5f54165333adb2b40d7d78933960aac7bdda0032edd7b2c711a891259a9c7824740627ad71b1cf6d936a35e15b054ab4989144da30369e1188c341d0ea4e355ab89cff589397ea69b409c6a59129214407e47d0c68f7587bdda8fe9c9da58bf7a53ce7a5783a613a57719a411e87bb2c2a434fe163c1f754d32ac85f1526c802bd1750ed2bb8cf57f604a80b05ce75564b4df064a316f8c7cf0592752f21fe573980589797fe464e2732c1363154be34ea82d5f96f9d7460288d8c87365b57e19bb3b0ebd5ee38ad869640909aa8257acfa40ed24816e5599e45ad746e4876032c231729d8cf3450e9eed6fa531987520c91e8597007083aaab40164b25d9be31cd2c876b4c9194d2b3a11346537638d02f6c9c01f528f3b6da3d4592118aaa4b44ca3e967ec08a0955bfadb6530c030b6601c37d359fa826cda181c7d43ef2739bf4254ee50cc55bfb73426ff62e9cf592a25e01b103b1a9263a52a976bf9c4805b4d8e32d0b20f2da85f7fea02ae3eb7ad72fea920ea4ec781b6e5f59f09411b90c66805ce65ae339587e56d1676e588864d021593feea41c7a24cd5df96fd64209e0e800158e328a0fe881a62c43946e4a2f6105045c542cf0319af9e6079c4aa67da7834cef22066ac11559b9e34efe663bad5fd139244c5e4db2f29dbcc0e2b102016bc4684a558e90f87b29dbed01fd462a6a4d8997ac041275eeae04e5a7ce7abe452b44e7ffcaae4046c411ba85a05806349402c1b873f3341efcbb5b2197bebf525a84fe76e33397502a84de1b6e407834477aa0f3bc0c62a6bcc386aa79fecb6b4ea70d53264652b4b43dee517b13aa086028c54b2ceb8f556c2594f8be25751a44eefa0dc2b76c7605af6214351a2b106b75bd1fb6b6954db63dd8b1b61cee2706459acf28f1b5ac03ad46455ea6157413f3dcdd8d6c31f8c81c06896929a1fbc311c386d239d690d05200da8a67392db267302d6acc5e4895691c4e9f5e13cad763f303a4fb08c8774204a1b5acf8697803ed9d756a2c480d9d8d3b4755abf1a9462abae1d94caf48a58f4bc5371d70a37f60afd707c7c930aa5e60698ccb39ad1b508b73768acf89793946ab5ef23334caed954a2d6d811be4b3b0ce0e1d04ed088f5801b103237c9115a692d1f7f444b5bf6c3a8a972118faba2b79c5d3528b235fbecd93759b6b43bd0ca927c02dbc846313bb7a10aa5e943683a86f163103beeb1501cbb38dfdc37f31ec2149c156ac0d5164557d5deb96cdc182d3706cf17226e6354e8c521e9b53cb5b227020030029fa479a63ab23deec1eec7b8a25fe5354accfe602480e0ad59364b0e88dd45e87ef504d26f6d654703ec68487164fddbb5d59875762b1c2da029f8f8912870cd9034a3803e5932f0e540684ecae042d24a9be519750c9d96d49d9ea8d9c636b9621ecbf80296c1b978588c4df13a3e7b0cee8ed975f38dbf623a0646fcb25f305b34235c170d663341d56272bc4fd5e28c9d9d7a73246d19feb6892897bcfd05b5205a17f3bed646bcb492132a8edf429a8064d4f5fd5d7431b1f1a88960020e9dea92ef01a9c6c8a908ddcd607de65263c19721ed9894fb02077fd2f064e91e3358e8f7fb38a7421efbcc5cbfe80de8cbb859351ffa253e432cae94845546f11c7aee854e7ed804d501f9ffa6020ade459f70ac81331ce9fb4fadec0bdc749825bee8c593c2e7f7e50779612b748cd1f4fb2d461f1c983f52adc01660363a05e2eebb48e5ce6ae00221b0f13cfa16d80f79deae41c2a03a8b7832c4ec012a1928868bfa334d4d783dae43db7ea148f8ec74e3f8ee5ec44697b7f1691e2181695f7b4fce7a8683db7af199dd62b00796f64ca96183954559b8d61f4707c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
