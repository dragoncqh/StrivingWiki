<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc7205792a2763aa63b0ca8ddb282630ab44cdf804168a7422c1302626bd9be8bb15e8384169010bb53b0ddc73da53e2a444314322c7c7d143d67421d07881546c0c0d88c6505fae914c2ae3dc47fae8066275f36e16755ee446d92381c1d8c065303c81bc16915cd9bf1c0dd9e5814ff6a3f4f04e1cb1722b552de32ef8be667ca28dbd53471aeb2ad31fcd28ec3d0024fdb6f76d00e5feb0fd598211a3c8fca8fe94816f5b15492c52d235ec3f55db4c089c4ddee609904c5d9596c994ffce129c6b8ea5a1c3cf8ad10d708967d151d1fbd95dc8215f6b9a10da51dcede99d96d1b1a3fb9dc8836141d16b135ffc97c72ba7231fb6c72318fa96fec3194e70cab42fa64d830ff6f2ed0da92e6ce39817fe8bf5b609a183a0840316b3a5c1b70d75e11b62f21b9e8e109fc8e8c52a74a15894f8c8b259b293eebe43a615e805418d824cd1a4183747a26505662b1fa43b0c0449d70d9699a5a83d52f750d008ae043cd5519267a53be97bb7247857f67015eff1b9086630d8942d4ab9c2b9fed472229a4bade6e801766a7079d40a38d714dcdcfdb7da816e8392ede90c98bbb743a725aae8a58e47b1cbe3732ab4088db00ef5b4d7786c1c856ed021cb15b60d34f14f774231f1b9a4c070a5de9680276c8ee92c9cef475078ec60a51f9417a310d7d9c2faca933ac6319d0138ff7b68aacf82a2e6164a7bc6b41c7a4b5a765d8591e8608e0319ec7695c83d682a5d4a19c01fa53aa2cfa92ce71b613c6bdb4bccea99404d6d7a2402b1081ad2c6c166933fedbe24954bc5a07acaf76e711b8135b5de9629e1433c0708f9cb8c1f3cd8719787ba9f01e55f7bfd747b081061662d38e186bdffec571cccd5bc3649c4b2cd57fc168008da494673e45e8eab6adcc54bb8c500cb3bee5b2fa957fbd298af0466543bfe4e8390a2ca2d3510285b397d97e020b9dc95dfe1cf5d1410e341dbb3d27d4cbb7ad1389b129bdeaafed0cd7e4c862ad5fcd962a8d56dbc48568ed56f39a358251c11231600fa1ea02dea9baab83a08c93dcb7b0f7dfc8b6dd75d4d70f3bfc3d36ab8c1d4143c0c4164ae6d305a098d10d40c37fae0f78131e63912efee09ec9445e070a0c8de908345f61503fa75afd1d9aec36ac939e06abc5ef73b6c7ceb4abd70fc22d4ba1104f51c8d175230bf1ce30ca7a4930cb1d7d5aeb1cc618e9eb67b05a5a322f7fcf798b53fefb6c71e5f76eba39f563a913bcfdcef2f8485a8ad32ca1513a41c7e10d12d6b995a1cf766bcbd0a095d505c788885cf1b3eb75a42aafbe7893f01dfc9b9bc4656eaaf3d6b9bf791a85add4d1f073ebd407a3ec3e68389e21239f89980e70446026d85e91575a7f544f0014432533cff4b464feed7ff94e07c9ff9bec17ee58863e71f7f139a0982451964751e82e3bb2a9dbd50e346137a8dde75c4611429bdf7ba92807453feb6c7c6949a1c7275c8b70b54117a638877db48b185562b7b565a46dec9340b5e2fb5f68b76a81af14371c8ebb7c308baa4c3bec4499adec3d5a2edcdcf3ad6a3f63a015a1b260b60417e5942c66f1c25f4680615a98a5d12e8193c22de2db5a55ba2fa7d60ce1730d9ee308ead68eb3ad26ddc0dbaca3f647601c10032742dd36658fa53b9442208e8ea93507a2c9a1376cba8ad0d10b8a46181a7d528c068818f0f62e093049c27a7a6cf1c761dc075f018dde6e8d47dd3ba53b86095398da09c15facafb42643075fd9ae0e64c8a9aba2d8f57da5a90d79b3c26b0b352a85b5939201a10762b7ce4215b635279b5e6d280f97cf54d7a152e799d008ff59baaeac3192ec3dd4e507bc752e01f5350254e8970e512dab8e20d0157ee22e20f674ee94899ac0691b9ed93ca4332f8265fa497c1f122a09c1069dfd9dbf8126a109f8345a6d529fd326fb466b3a23b70f7df98f8f939a3efe276dd537db940f638083505737bd9047cf80bf09eef1cb26ee979b29e08e29e4e9027783e37ca11f2918db2695542eada654787622e970e1279bf9af049eef0f0e4760023c76ee7a342435a7c3d79a859086f738dc6a7f5576221908e857d6af98aa0e61a66a871842547893687c6828f404c227423d8c522b82fdff54fbe2913dac15b99662af3b273e84d2745e1524f5f540bb3de44ab7c63e2f3cb2ff3b4c7ffbc95d50e3d74017d3d928fc2312eff88dad67fb1e95d43b2034c5363a58463997840f3da35f9865de91ad1ae1a3be6dd5b392b25065d20aeb95be2ab33530acf4d76dec48be47d025caa2bb9b8440943e571643188dd1c4fb682aff945dc4d4a5902cadb67f072521fec7aa85aa573bfb2e997ec41f157b680ae0a7b2ebb94b1cece61b9d65b343f0b085394f67e981fe8f4443831acf00fabbd6806b01fa45a59447725a781b0bb2eb4a02e89bc07bb3fd1c199a087a03a710cdea3b1d06f6b9a65d4847420fd0273728f2548a8e93426e8a054fa26ab3c277f870e591b2768df0b50342204f5e0f0ed58361b686c7011bc7c79149486b73a0e143f65880763db7de05b77b9f2f159f2c40dbaca2ac24d2c64036bb66f2a15cc0ae578a64b4759af39817d455f0b7574100d3378acb64ae16189264de3fed126a7d1a45860b32c746fd9adb659409b6b4a24d4a002be54d1708aa61fd523091731d14f250a074fc9bba5a4cee94a993912651a1971d32287bd97388cb92daa469958c8ef0676ef8c6a594c351cb78f0db54d27be64e741c4f2dc4dcd50488ef33c0f346c19d31a6f144a01255b3350dc5e76a899451ef068db417b619f2bc01569bf739dc2c450c657746a46b85fc8e131371bc16c9c399be31f128b08e64c1b5b0ce5abf8ee7134fb27c67cb15f231451149649d3bc01c961784ec4ff36a1bf48145e48959a634444b05ef56b3871ed622dc7f38d801c73ec11f717a99381596c6100ef1c1375440fd42b90ad562be5bc79a1309219fd82ad75e9e560f383e686a8eaf57eed3be64b08f720d0ac9295c28db1769b8021a80b69df0b877084c81410169688a8fe77b7893631c5d3c90ba0c079eefa5f776039e61704823a5ea6b7634244228915866fe2da83f14b8b6db6390d0abe2545700c5583c0dc863002173fce9a767ac78b378fa094a4240eaa497958c8a338229b4131da8e1f3deac586942822a68f35cf1ad32854f09f8d0357db0132fd8d7124022cdd56db64509bcd50709602b337e0cffbfc485b22294ac793be426cbf89e397d9230806b16abe15f12127329871f2a2676e7351bca51794376de43493d09469b7c2c6294e336c58508391143c8de1d637804e6de3095b42fdef7c8f4a58707645fe461469bf7d9c7e8aff07289d7e802099af6304cd2cd867bfbfa26352eef41772cc59c34eb7eb7dfaf31cdc3c3e827eee4965b5bf5786251fe30dd9d74a8b0719bdd0cb6f765ed5f19d731f4cd357d7e620e7b646728c41a009b2ed30e0f0714bbdead894073d7d678c860ef300ef570f59c2b866fb8f7918fb4eb02d7d8a3dcf37f14b1547f423980ff34138c4116369b868bb541b738c7a8090275295d6715e8d740d1f204752e5a9d7c76134a76724a61f805e4ced705a59e28aeb82cf8d9fbb0dd9b5ec3b512849e8ce0acabad38481709970ff638c9710216eb316a804d7fdd1ecbfd97a5d7759800a398a5178d17b35c0ce00052b18366435d5e1c5ebc60551c7e03040ebb3ea81daaef9e58b7de6a10e9f381ea5292fecfee5f349a9f11f18f85c018916e66b57792cea48184f17e39d9b9675f835ca91fc67a8fc6f91ef5484730ed3a1d30e3fd5e6d9ee4dbcfcea315b0e1618667f2846463fb1f35f8ff6d901cc92047640f35bff0b91018e815b8dd344f5a49c5c8d4a1f37a4a57eecfad3253d5f53c4e24e631615bf7dc7fbd9e2c35e7f34f77375677c325def3739e2895804d6cdc7434ca418374b53a03b6e83b8c56b3ce0bc508db14365be2b698a36f0d8b2825de3ec84ce3d3190815bf25d3f2a155045995ec97a2751349da89d02a3a45dee1c9e51b5894fac4936571e29751f111d0ca120e357fda698addb4dcfe83290be4ab74a9bf5417d5860b2a1784daa355360d47602a8b882c0da44d67ef9d886b7083d9b7682fb46e16fa9cc6069a67c8769c6e9e22c654629e8d589ec16dd8d3cd6eb354a08f4eadee3de582907c496b80036c57e11750eea9dfba0b75b33093af60b9ee54554092adc5bf0dff286c7a919c616755d5f492e56151882f677c8f1799d0634dd4f13b4c9493a613fdcfe86478eee36cc923d04ff34c9e793e62c49640f8e6b84413b069e5801011efcfff7782a1e55a873dfa55867c4e09d5855465ebd84a04ba2e0c3ff5308c85fa7e9474ceffd401f2aa95e91f10d9a731783a782546643d35614176d5969d5d9b49e76ec2103190fc8f6b7ecea6045b24deb66de261d313e4a8e4f7417ea127f608e9c77880fcae12fb69004823c6c921ab51205f1bdd322b9cd6fb4709c2df39e61483e279d36953b985ab985a6b71a45c7f54631a0b524ea8afb3f9b79db351d7edf829e794fb7deb33e7f1e410892afd62e7d83cef4eef3843a82b0cbcf01962e3a4043ba02634e172d37a640a205c167809f090de719cc786500d748e8101a67dfe57806f731a5a652f3606a363067cdfead4750e0c8cbc682af9c2ab61f08928d7f49b2f1566082d8bafd26c76134e8b7873a9a03425aa057f28203e5d3871d64b09bcc9b5a4490ecb244dea06ac94f6c36ef5e9c59a39e2f0007c0aea8f1fb95a732c4585cb0103659768ec37e06466d52a541d0a3f9b54e0dd386ae0015515cd93c9232f550d7a868dc5fd5a4c9d8319cd20198d45e8903b654707fe5597d7ab6f312337f7e8a7290bdaf85396178256ae98b87efccb62ce255268cdfd1754b7749b8f37ed85c5fd0bce03711203106bea5a27733da4e2e03f5c6910cb6bc45061451b40077d8ae1ae65a24f3579b4be659f3520d8d5f6394d3ada0b51046f89abe4b14fc20f24ccb7425d8439425f5d50cd92d1b1f1e7b4d6a22c64b76104b9c876e0e40e8e04547501b3f345a7fdd07691f192b1291dadf3263f13fb4ad64ee11c5e71f6ab21de12c99f682616cbab9273cfed5a1743d9aaf68a83c653db8d6ddd61890a60b8b372291ef53731e4d59ba1a71f0c200d911068ca2997e134c641d585967fb0629c7396edf3932bbe1050bd8c4d77b8796b6579ae349cf0aa1cb323c3a8a02f91fbc2c48499e3acb42fd871923d22d992cd71d7e508fcec3461b8c944c459255769b44b0cc2df682e68898a1684a288b66c2cb5e16d1be08eea2ac81d4d07f51719a9c2c428d77da6187a420468c789a94b12c97bd4795abf25123601bdf32a492098dee48c0f20769c1e42365529311d692190b0e0fd922c2052f78290048948b62edfe8c3abb20c34d1eb8b34ef10634e6da45fdf9c4d40eb094e27198786127b978979f030ce1a382421f99fcfaebb77ff5f0a6be952208af28703020a545631c073bbe16fe7f0a386a16cc5211c39e77f4f35d394139bab74076910956626e1516b00992f79d28e042168da53956a708efe072ec9765b4f54624f43b178c9c0ccc5f2187821c63ec6bd1be02f056938f38b1506aff2114087dda1c8dfaff295be9321088e8623984584ac8eb65032d703885d7156cf7b95bd2f8540489d338fda6ca97129094aed4bc67b123aa704ecb7c188eccb404938e82be792dcf47eed2484e97567b4822e45f5de5405e1ce757c02ffa3fd4fe76285dbf1f3cee50168970d639216f75e07f653cb4340b92d41fbb4d0211aec4b64fe42f1fde2c69629f7f0e4ac352501a5dd12f057cca4ad1debcfaae752b6a977566fee9cbecbcfb03811efde5e80fdd7b4420962aaf441627c4d3ff7b9452408aa9b5280333415fced5813784db4b8a807e2de07a14956402fb833c1ca18c5dca6df30821295e6a0dfa1792bd714d4758086308721a831fd3be03ebc3fcc2ce7ec17c3e753c853586024fa19a2ac9696031bae2be7ecfe84b4264879277f733ae49a509119be71e851d2aed5405634740946114c7cf39058b21d8b228a3daee12d645c20f955b5ad6e1c15d6bf8f10a715e6aaee6d189210ae95bac49feb3953ba8930d4871707b5f433049f764d139295e30cfffd20bce184281ec43b6fd62b998a94fcb488b865cac7a8e7e86b5293e952263070a1b064c5a742c5b32c4e0dd724f83b1082a8d72231a1edfd9ae64341b82ed98fdaf2fa9b27ff2725a5beaffc917ce23e991ee103a2f5f2d57f3ba89a91c2b1ffcd9a65e4479c0eab1ffc489a3f2cc96fb8c0084602a369d354dc0ebc087d1c6c5802c6a1af498f393fc03b26f975ca2de9c6e4e7801f67ae585e7cc7587c469faf762e56f54728deb5bba5581abba954c323e7874561ccf3ff854fc8c86f625945701ac93386556465299b24d4806d911b355023a1d7540059b9ca3520a046c0c5af3450e912d4903c24fbd6b1f24032a92b7ea4179525c0616a9f88a90bfda89c0f01fac812d717a97bd6aec74776b23ae12e9712145713b9b755e658f2a917af627772569b79c096780bd136d4b094c21cd69342cedc03d86312d1a726ff9576b1e71e4fdeeccbed68f3d0b4b7adfdc8d5594bda48c267dfb2183303d4a54388e22493f5890b51519d554500a5380ea527bdc9d9ae860c5e344ce7dfe2ba9248511f32e9ab71f2daf6493a271e967b9adc35237c0ca57e7578167f0fa8ed9d77871c2efa99b9c6c6c6db69015acfe83be0b4d799f7d405bd95218025252f1858aebc506a9d10f585715379cdecfd6ae86b3239f291cfb7be6134ba91a86d7395812c6e0c70a002e210665f1504e1e3a1e6f0466bffd1cc2b506ab1e2ba74a604863889f9ad68756f0b34f469a2212c817958c40672d8d6ec1cc902695c671b770fb6216621b4adbf2ab4af919d63e5e63df24eabf0b854015769ae07ec76206b83b024d68702340c8a84f68689bad369350021a12beb9274d4d3b586e955549cb6d66d760335cb03bad0a78f5fd7e57da784b827ee34464202f8ecd4f73c9a1fb8c0cfa12202757dcbd9a979761306b2176ec97120f151a44a740caed80dbe68da3553825a7cf8e953f79ae86c260c94924a04a14672459f9ee36a77079615ec00eea300a80b48196ad3cae9b62b6add5ec13cbe224832aceed206a2d8bb793314d1cb93d5a84fc86dc713905c352be27c28df81a6e57b9766fdd64c4285e184f57467aa49ea0691a0591253c2ac996a06be87d189b1e7f4478398c49533a46f625b02e58d7f28901bf8213e4a50577ccc64932eec708e2406ce954f2a0e598fff174ccf8edbd7ffea2c8912c14cc71faa23445d142fdc455ee4e1bd9458142a214e4faaad836296bb5c52c4a5851b74e6b8e0953a5d459bae47678ed90d93043e57b6d08357099124517257d3e380194ce2f9380a9659713fe6ed287d90e4c76fca61b144c48d236dcfc86c80071e27256aa706bbdb2ef191de1ec9c5b9f806a585cc17fb11fdb7a89b3ef81bc82680230a2768dd74ed1f56584f24c0ea08f83d47d08e96de2be8d0aaa4eb557737080f1b78aec933e792c1be15551762c1abf4125f4273b255746c84eef0aa18a18661684687c4253d838b98e29b750bac11b5eb2b81246c5ac635840a7ff7d9800597c1c53094881d4cee8cece46a59e14a7c10e51827cf0ec90dfa64d551b84a3e4f6f7f39b3af1e96e72aa070f4c85e5fceb7e35ab4622ead1b137a596b7c93c0a3c79761ebc93bce30b7cc047b56c63a1b224bb9fb1fe179f0d533e43cc4cbfb59ae3a9f32f712784fc3bde27944fc6f892368a69b4093cf9e536ca57f45c3eabbb01f7c87a0f5f41e9253c295e6cf14064076d01ff0136b93b8052d823dc12748936d3c8d69351de5c33dd743d1f75d973911b2bc7a46babab5575d6525c565da9e18b6ddbb9cfb2e434716db04837e77156c6ef3841262f588e34ac45e4f03a44f5e4a49ba0d62b7e3400163a9791447be3f87a02074d6f06419a2b7172f0ce2ccb24198a0273e1c03624f536d4dc8be3f88ddbdebfbdd0e49d58a503c63a941e7e5f295ef30875fe4ae9c44c6d70bda64f10e234ec730908bed3fefba47ba33ad9e2f60e31462fbf298f87ac58dd850dddfea8ac5fd8ba638d822b0a3003cc5783fe43ed226db3a628e563264b3fea8eb91cb33768e0cd88ddccc8e624fee6cdf1aa7e4d2839909b2c4648c8964f26aa9fedf918c919bda3a9600722f27c2799d811011c5cb736b2d1650a5c6ab70c9bf4cef507f3deab9e8c99e018d6bc18407f93692ddbdc8d0e7933231fad23f3a7367564c5c030fa117934aa4f47e4b13180ff0248c1598eddb29400bd47933783afdb3ae59506742ff30cd4178a351dc67808b44abb1807f733c79398144e572f3f51ca26923a49263a8b71a8618e6a0625ab29601ce6b61b56c3819ef77fa87c22d4cc819c5c795eb645dbfe4ddeda53f70da271b05a2cf2fd8a80df5290ce9119283aeb7b0f3f0f35a08d3a3a52b96cb77d8ab5384152c648c77c8d44c42f23985b6bab327dfc2365df3476efc0efbfd708577471ce053b2a3ddf7d1524447d85386bf32f8ec27c7eeecf9479957e1df5231cafab94a0de203519ba8281d67b4b086b24c5232151015226d5c0a9b7ba3fbb9c12ce93f08592462d9343c7089f7690d6681c56b593e6a7fe3e2fc3590ca7033d10ee6cf632be2bdc5b18d3a6f17e33a974c15309dca94b83ac82eb440ef42334bd2b109d28bda7c46b64d5a1fe21d774c1f761fe84afd6a703396209c3688f0e9296ac349dad8ec6e50a03b3fc602c87c2dd857d77cb3d7267ff3569d0d988af1db020436d1eb07b865878c6dd992aaddb5cd0d5de5aacbe519d48ff07c01be20b40d81e8ca5d063c27ec485496ef1b767753e6bfbf980e7e05b1bd166bdfa6bcce9e7b409d2b18eeeef685d800300f7825453f7d5d0c6388ef235ef4fc1538a7083367a8da541501831225c0953e31dc3874d1718e07dab39dc98a95fbd6c07600421b1fdcc53a825fedf86c5a81f1848fe1ca84a55942db0f1c135a61b3dcb53eb788194d88005ae95a3acecb4467bbe4be3504f75d986fae395429a70436d1921b6cefcfd4a1a910ed8e3c5bf96d02c24a74c7f60d1dcd560c682e2c05d5f808affcc9ccd659e7dc3602bbafca679399b70798e713b8fbd9738935425e85658c53bc435622cf769d1639a97d7870a9b8b2a675d41c0ea70e05485b2af6761414c95834f2c2d1a61182308b6fcc43dbe41ac257ca633f2c1133d886d03e4947807c9c06823ff517f60816bf993d8223abf72971eb55b103352e41386a892cc6cd17f90e95abe7522c18c0237ec50eb1d45629d7c62a1dee8667085f23a723740b5ec8c69a886b4db9a41d1b743e7cfe96b99e24e67e7ca9728f229c1dfaaffee44f439fbd15f71264c7e5de6f43812f6431a388c431e1b2e948383e2878fcc73115f32be5363af97fbf39367c04c60b8a7fd112a136331a37100b5f395bd0f45c43600885b943acfa1494691921b8eb577a7b14223378244ffb4d1a8ec4b78a3e1e6f25210aa03230bd16c88a6f83d1c4666e6082bd4004676ecb6f646e76a0068eb975621269b28fe00d2fb170e50656e45323b025d7fb0cd4303d1b1c473242643044dc13c8636dde7bc398234f5b0c2c53c8d1b5ba5224d55753a4a5113804d7fe6b01130dfffd2a0f9497306a44657ea127e6e5e45d2041711b2b6b2b9c31eb5d5d01b53c727347d1d0be3d8ddb36020db4530af1b6e250fe07771deef53050e2c616e5a4164d640bb20110c3bb822e7f20aaeaba56d51eb65bee39c9eeadac370c5877257dde1a7259d2685c8f1093a02f855348307df1ead142b608092aac4ee594ed333444ee8035079fb0c4d0554e4ff9c9d37270562457ec392abca8488f025f907130f8ae92fd90d3474521e29891d4cb3f0268ac883b50de0f20967011035d3317a04cb0ca4043650b8a7d08cd152b35056706635d45c6e6374824965661a41416b360aa883ec6cad5f78f6e858abdc2ceb180d6b557c4aa751a5280626399e26568d4e78146aafca8e3e5a9f26cd6c5090a6452a22a7ebc542de93299764d48b13cc8f1f8e453ce4b8ca186ab28945d96a74222f0dd8f4cecddfb824bfcdd6e47b0807045d0721411ee81d37a291d45308574d1c6a280300598157f1980f4332a9c99786751a22da68355c1f23b1243db29578e20424b5bcfe25e9ff0447eb4bdce738d8757e95e916b52ce3d66abcdf33059a5c25c8d797bbe71a65b6af66510375e583c3c76d18cab0dd1893e9bb51d8478b2dc586fc5efd8257997aeb588894c1b3c23b2a9b78ab556b8c7d70565815cfb7041c1eb7fb8e88cc762f9355c67e7d52c19b2e7566f59a90ca82d4fec2e5829a6aec9b7c94d3b03d51451c8e57781c4775f2dde02890a8562d0132573c385e9b65706b0aa66ab0cd757e9e7ee66990345d9360b6e41f9f68455382cfec78d72223b8e0320e570abe39e5b6054432f0064b45201e9e334c61e9e01bfcafa58b77654c48ef77033fa16fcf5bfbfd15e1904e576659c9290b8c3650e010c1bd1114a3683578b170af3f07dc1c7bc68fabfcdc4a908faa02135e2857c5285fdfdaa69a7e65c3eb00afff0b2e7fbe80362fb505c78e90a498bb23737767a3886cb55bd57ddc7077af5447ff4dc8e45e647fc333308355eee30c3e8aea032e10c64ed54bdaba17ef964ed99aa22f93f506f1d80626c773d77ef5a1323b08f1f8ed9457be4dd4ddb0a21b48e5b85fd756e74a111b3a36bf97aee920c4b64da67b2e4648799267ceb25c9251d5f952acb6937d8937c0bf5ebdb89827fa0de89a77258f407aad2e78b7e0a56875394203bfef12addf67f6bc8660da891eb48790370c7d05dfcfbcaf477267e7232eafab338f16a51a1f275e60bb74226098313f31761a65d8aba1fa2046efc3fb230153c1a5dbc564d73326befec3f795e27dab958b434532513fc0badd81a945f6a50bd45beba96bed5b565a03398bda2d15a53824a2dbfc8d26c1e7f215aadc58844f1a0eeb6b80fad3d852ea4d7594b995205005c795f31dfbcd9aae4b85e0b362c6e78e8b3966e6de83b5dedd49f46523be66c37b8903bdffc53acfe4ce551906e4fcb97f7becc8618f2758d15169aa1d43a0754d1985bc41ed51df3f3c16cca52ab4460b15e08be6c5843e6c7dc3f48b6e6cf3086a466970f384fd29eacd5140fabb4e697ad4c8f999cbf819bfa272cbde80ac0d91a651bb3a03b101b9d89e9b4a912fbeec1cf39bcaf97e0e980a499d5fb3aa4b4e9f74e483087cbfce9da9911a3af6359f07f62363a0e6eea04e698502dcce8356de50fb078ff617c6b23995143b48275bbb54fbfc021d5b3d435da7be04763342138fb2be826d6e4fdadf6aa25a3db194d75eafca547b804f926237ec9e146d3be1c7e61fc547a9099fc2440c2f373c397719c547d4622b57eccb27cee3479b09b001839b05e01f8648636e0367e4a58970d6ec0c04aad26b65af7b09bcce52c771471cc40c85d13cb572fe20647e639e2fa359efbc1ca23053ceb1ef02a4c95e08d2e35a9fc2e8469efa51cd1994f010d1f6fb7a57acea1736b4c695f43d97e18d4bb2c96372e0aa4db57cf7278f5e78bd8971fee5c32ea2344e8fcaa0d6d0352d664d154f65cd86e41e4f6f98ee1ef8ff4899da3d275df67d3016170e43b7a00a02b1a87d0141196063870549ce4fe2ef6c527fadb298f67acd6cd4a4a42f6c18a81328027cceba55fa12a6bfbcba65ee1c77082d5b0354e468a827d75fc661409f480f52420a9653a8c8ad9917f4ce41fb3abe3533e3be82069d1aa5acc7353ac68b5ab4395571f842eb14aa8d7059b57d9dc6781e17286b493c0451f7f1e8c190292695dcf660fbb3b6f32df883d40c0b7623541dfe546d631ffe2b6465d43b2a50c7b3b149d2840f777088b70fabd6fa11b101d30864c6b23bcb1c5e51359e85481b4a35feab72dbd5dc2c4d7ed4a9b77edaa1fc641ffdce3b418b15a01a9995b8840d72b2bdc40134977a043f67e105dab83654dee050376f4dfac3cbc92d7a63dc331a01a55e0ef06728d207fab91a6d7558dea9b324ac05b956654e87216c446c51c83d09ba3761b84eb1274ea938489847f071347385b9aeaf7a65d0136be119a0f7b148bd591f666c62d60bcbb37937d35f8386daf3b50080fd278428f0477326ae06379fe223469615738517f2d024e6ac87b718f30233a33621a98582878b65673f8208e743db6735e229f4d84f81c2fb783645c59daa641e87a2f32b9b0a7b37b72540389b1537e97d2c1b033cc1fabf9eb1998fd54618b41a6077bf54c01db8d655f1058ed93a4bfed6f66e991633a4073f346d79f35c13d80884c98d722b25ba1df8932fd3aad09e9558831a5bc366169fed5c6c365b0a928f59c30627222197a56474592c1bd53ae60cb765e74cddbb6df3399bf82f0b39facf4271bdf83998abeae1d5d1d53b3ab1436a71471f790f949b3eec0607a87df9fcd9b5c12675892f6e70e2818c244bd9fa51852ece5e66881e0d35b24a1a1584df9780422ea84ae29855f0cc574ea194e28b0fed3f5263007b636707bca00914d632cc846f41a1a9772179132f5e88f997f61da30d193a4dc4eaa35f98e8fd68b4b252252b7b2c9a968f7dec5f2732836d2c92d4247d99b6ba91f08043507ce9657dfebdd21c575d8b086f1a7f449cb06dafacf2e1f41525c1f3f94a4549ff0a26857bda711335e0b167b924e0e8a3f01329114ad2ae394babb51a0c2422aeb80183154aa73053719fa1d5be9f18cb58c4939f05718865b7641e26575582bdd60ef6b288363d229405cc841a74bb5d46257e896eec0c1bd1746bff466add7db7666407bb825eadea8a029c0c318554b7dceeade18edf22eaf8a38dcad8c610610fdebc69b2f36e35395fa0474caad55a3de9172cae600109fc519044c14b616241b5a574fdb9512208c9baca3626498efcb3780ffff39d3fd84afeef3241ac4fce75d95ddc14147b9abc3b1c8cf1b1bc051a82b2e7690d036b297cfd11f069732447a7b253f86608978fe6bdc6831c9853349dcdc0c60dc5bdd9e87a11eaf93fa56333a16d42a2402f7a8a2d190e33c054069e96bdf52ee0242717054f8c0bbac5c116780e4d5a986eae04b38bbd6dfb4cf6c9a41fa85b86cf0deb6ff488ea121216e526378c4d8b53c5b7ef1b17c91e27459183729c201c10e7cbaa6e6be40c3ffdd46d35759de239ccad3025ba9a0a6d9d319f9c5d3fd54e45313659cc9be92ea6b765db9d7fb8d2e5bc38c16958ccf0bef44dc2cabb041733c810779e52255a9dcc417bdf360f40655920803098ace58f4a8e9c21a53083ea80789d9be10818fbc477c1229371f4cd1472b8a25721225d00ad0772e124a026b570ae519a2decab39ee2099419732ff790f39f0de8b775d385371c00b3fed2ef3d727d45e12f0d8070f29982ea1c882d51b4313","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
