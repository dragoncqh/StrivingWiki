<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9211a3eab9f0576a4bf4f32e5bef159ef1e0489bc9ce101e246e6fad2d9d898bee9b2253ee387637ff39280ebb9225d164566cc662651e1b82263f77d85f5bd4714456bf8005a26521a0eb48a8649f4ea0651fef41e40278b5b6a61cfeb4daab1e2137d73c7fbe393ce6e9e5e9cb868b76a92e1bfd771191d48fae7a14c645600a1ae24a00763ba4dcb73c1334082a688de83603ff46644baa45ca7d38660f2e21e19ddff6b5bf977ae56c280f324a756401f416528b8be238a75092ac2def3d61d26905423c26be4a8c893b96b32a5f683931be7f63e1482b00ee58eb861c69554b6b31fc99a05480f1c19e166c038c8d95138029627b0fc6b7c3a52a6da8f62c758e3392071146dedb56410f04d5797786f209ddc5b36bd18ce65a05d6d24fbcebf6f662b41e65d30801334fe3e9c374f160d208ca46683b44b3662baf4f11954c21b6a2e658804cc8a3d85de9fff3b67a6b66699a93320962d622b83bc4093949e665321024fb7893aa51e2367e7f0564f9b471c93eea4a11aa828743aeb06ae4d17bcba00e677925476d2e90549bc1c4be483cb1d2a1f41b7754ae950fc527d8383281f98f821f170984a2e1b1fb2d8e634ad9d310cc79b2f1588091d01ab99394c6d15cdac575d8ac46300f72a7041f015211d2dad3f06b9216717c4ae8fb28037968bbab19a7a4fea523b6ca703905f5b631d6ea9edc1a8793c1cdf1e125cfd2cf1f80aef17ceaf475f47ac9c2e6c41281d88962e4d98917febdc4f486c4795da8feac0e7f2faf1a56b2516ff754f66a34071f72821bde0cabf77b2e9492a9b135f3504f255f98489105b44bc8ab797e96865b3c9987487dd6b10ac1c9808f8f708375479286cf303cff70ec9796bc7614b1013bbb7187d9cce92e1d4220e047cc9da7eb306e0b93afc833ebdfa464c13f9b9ff2e8de96c4102504a2bbf317f21d27c15b82bf9392e7010591c4d84fbe66842bf785661ced98305e1951e186215fb4311b0e86ec55ab4ca532051f621857ad9b9edb6b4e4b4a4de76c1db2a3c08de7991f3df0cea0085d5dd67a29e2d1f8f3792273a135b3249faf909ba4a29a86eb4f97ec8d68cda9ce61b45b5c0d753a218d7d18e6b4a14c853d199fca1119e0d29ea213110ec5233b4231aebf8558bf079f42bb09bbb03e8c9a69bb1bd94e7e66fdda8e18618ffc83ecb2b9761d7a27f2b12c30ee4a1f29baa5ad1105975f81562ba11935713f4afdc4eeaaee4908d6dae8d8db5ffc4fb8e8c457f048720d83eaf7e2ce940d85f3da448927e18ce07306ec65d275a727cc636b8eff364ef98243730c67a4724e58cc4cecc0f4d80e9d50586d1b539b732426255266df5d2c22a3fd2113b759670ca8f959e00f6cd113408e8cea4148d970dcddc22e476816501963d861ed4735e73fe6796beb903318500392ae8ef5901f355fb7d2bbfec5f535415be928ef53544f45a77bd295e25a8bd2fe8e292d064635b01387e9de1311cc32d55566f6596ddb4c24341b012ac792f5a5de9598e4b345381b4720feb5fed3085b00f30b1fc08d60295ee001f0a4dcb2fd9769ffffb4f7a8c9467d79f4d43bf005d6fb1fe473a99ec5aacf54869f312bd9b982bf72d837fa32be7cac1b416122a4dbecb60871b5987cfc58468cb5bf2ff6a687220145c3c69ef14782541463412df09aa4e8b48159e45168d8052ecf5ee5faecaf5c4444f978f553a7c2b3c01fe5d302b73fd947ba73236bd059ff08e7e3a6da9860f722e3354ded7502b4e6fd617ea1c7087adefe3dfd7435730566eec78176080989391a4aa40fb6575363a48568b0ef006c57e118ea53123244025ea407c09a91f1af012b35956704b14f2b3aa96ea8c8efa2a4e620198731bcada65891a73e75cc5bfe358cd2a063bc7bccaf4fff4420e226f2071c981972bd8dd491dd6050a46bbce69956593c583f4ba18d390129426ad3a90aa981736a5ea2b1a06d778ae6349513c8445fa5fdf8577fc94ee2c24f54bb07376176e8fd5cfa43af1b80ae36facd24a6873c1b9e76f7c9efe1f1342a7301c6d243f90ec08ca77dd4ce8f79a491837f4102bbca7cb797ac5026a566aaeeb34bbb252885ab2a15f90c5a03d37f32b291b65abd99b7b632dff38f46e7e4a14e6a757dc8248593b419ee33a228214e55bf41a80dd46f8bbaed7b5d2e416315ebb5bfacbbcf37d58cee3effb63aae18c2e0470c231a35064332cc1e1fcc3cce29eab4e7d71d318894c1838ba564fd2b92d504339a7d75f75b0de5c73b4e996e6eb8bbb0aae61804a5e407b3df2ea464b9c67ff99e6a41409940676c3479f0009fbdeb46257ea4b6c7f08647976d51e7b03e66d2aeeda7797c5695f6422bfda55c6373fcf1b9b5913057af6ed0b710a064fb6320519e4e6990b38c8b2f4581087f22b9e73282ac83f4a269939c892c90ceea8fc070210b65d3f8f040c24cfba5f2404a541fc83eaa6d0893b90ed7522d5df1faae32af1c226f7832751521e234d6b298a99191bdbe0a0c8a845898ab4e9ad5bda93f3b9539743e6264148c555708f6c5be510f126d1b5c378b3eb6ade941e3701cd1153e19ad293138c0135c10ca2c21281b63920570db3370eb794e7c2a27cb56257eb1cb33487ab51842172023b0320f23ace3742e6917a7f691083c938d9c7b9dec07344c2a1a005c602013d6c0b6ddf17d2d3fc94d33ec3285e98ee8f06a1103e47af1f2574fadd089c4721660150ec566fbef0f44a9cf7968ed4e19bab0cadc420c681b1fdf48de3e9c8aafa619f1cc9d1dbaeb341fc0aca4939d91993813679b6495d9eed685d99bd30d90c54d5a2229293b192c660ca7bcad23f2b326a4a20d12f60e4bd4db1604befff3cc3ea1be8cb6014e51621949bf86c209aa35474c3eeb1dd5bc343c0b7ae13da58ec452bc4478fa18f8cf4517cc833452525701cba593abe052a271750b794c0bcc4506c1fff7b9934ae878df25878e09d28727dd4156900b150f06911e153151aa0dde60accdd4ed9f6e7556df53d2ca2910502a106b50a779c7b65ab38fae05647fcf13369698ba05ceab54dfccf304b08d2da6685ea24b0e4b1829871b35d7494e0445c4e7e5420be435564915ed85fb043cd21b1a132aa6dbff6a87933834f8aa5a591483039e23894936ef598cc6ba840a9ad545bd94cb61e1bd91d02ec8dd5892d2a0fd1f2470f6695b82c20362b01f0321fd5b7301791991a5ddccd61ac850083ede3116bfb1d6fb7b0726d37b5d6bc3f0dd946d3951531d685a7dbe1837eabd4fd5a3742cf45043700a30eb79084a4da01ba17899ac8eff514b1635e0ad4b63a9fe33ab654791d667b39282ea9ea514675074b826ff05293b4cda0e60616e4c23de5408465bdd135817cc5fea08d39e3533241c0fad61acbae8b6c83e66da1bd36c89c8389c6fa650998a17f99c0906354fcc47bb640b2e3298686d177ee09fd154909fdadf248947f3cb3bb9b5a712b937179799b949ffbe8d61520b37f5efc9dc3c41e40f65768ab1fa7f6443c9defedb47a99c018d3102fd86f57fdcc684f4247598561c16ffa022d3aab95e449147ea844d2f304e7e5db743f367c1ac0d71d7868d05d8bc060412d2dffe51923d587bc5ca079bd698b0bbcf494f3b2de6e37b5faac944dc29a3bef80b2eb688841ab1ad51b3b2db25d1fed8cf984dda0e7c4ec68b9b4588a50d236d80ea0a0df096202222a1378b4adade983b6b0ef097bbc7e7f0e04bbbb4b655ae25cb8ba97fbb26f9f8d38e0b3b6c907618cdd235c2210365cb3eafe912ec3857d9c0e798cbbccd6c0d9b5ca1d896abb163d3ef252af674c44f36ae504d92df9ae4738d31a18ab9a18459640b1431ffb18f618b051001476f41878fb326ba423247ed7d2614826389b7c382f9c2663482f06a3ffd2c1ae69a3a1d35dc5eece2c7fc15e56bd78f1589d7bf00f8571e59471ec2fcc2a1cf0ceeca7ac667a0565276be1f3beb567407acd0bed69da7817663ba91178d78743496b5a72baf337d7ea42f5612a849cccd3103e4de29b5af91b729576a8f1602c8c92cf7f60f22b410341b69691ad90865d17a72ddd3ce96b7abc5a149d29b0b19ed9a6b873b690667a32aa98f3f5708be71c6bac1676f54342b7764a8732bc64f9bfe2efd6c80481435b8d19be75ee1ee23dfd9e7e8cf6a292b48950ed0fe01512d8e1b4d58e3635e0b2ed2ba674a5d0eadaef8c2e96098338a25c7eda4ba6b1348a4749dc7363978f5c0366f67268a10a5c7c9233b956bd2b8f1d1df1f022e04d866d85358807bcfc084518cce77fd066973e113ed8d64c50a881a5f9788532dd6cf1d9d34e3d17516788ac89e3db414d6e383b01fa391f203ec4e427f1df564b4f45e410efe74cb95782c31f9cdbb5eb02eb55e76dc2d659fa3991382a13b950b66b999208d6af536fa1ead42e15a03e65b2a2ec98beca1fcab366dd74845fd14cdcc1fda94a69fed9d3cebb6d75edd35e6c0ac734392c6f1d9e42a24c1c0e44a8a0aaf1d96429fdb9ae220466a2b202def7a65edb9a474891a00432172b7abd0dc986b08c9feab7e6bddc1707222df3367bc616a70bd2dac2efffcc1f129751c1da9270d7cdf36cf0025cb4dcf697407e4e470027bb0c22f27495bba5f2de7cfc73fb8fcd79e05b123a50f4d3efc18e7f8bca2cb3ccd66892d98bec94e4c01bd074cfc173b4ca4478386584ef34aa692e1f70a5f255ea0979ada6bd3f4dec3133aca9ebcaa46386904dc6672b8cab5aaebaeabf6ad67d20bd34f7a03b145986927c02eb6b258637275de1539abd0f1933305d714d84d9e690c33640adfb30433ed16a2286b0c45855361c9b064731760954fc2051db7e63a340c2f8c47c50b2adf953b6c2baa9574b97e677cf16cc689acf8cf919cdd9990186574fb331a2733f4a19962bee3ef08ad8ef175dc20ad9290ae8453fe71ac3191909fd34e6d16ce4b269034917f799339d31c5c2a932cc918ce000829f5fb3c4b8bbfe3b6712f6a9764ad4ec6a82feeebbd7946c532934612c815fb204957d2739e125e5e3970be693b921ae17c4d158d363fe3a71bd3c2fd14ddfc74ad159f158394ebafc36b25b3686a9da812d25e477e40f63f4fc3c47fa1147e89476aab7980c2849dd5ed3b710cfd8c97fe898414dfeff9bd33f9f27047771ccf08e85985356704dcb6adc552745147dd76dc6092fa2b41542ef3c56f2657d6b9d44edc485e6b49f3054b830bc6b990aee5b0bec76c0204fb58dfdaab181f77b907bda451c9c5abcc2717c90a476ccfd122867ffb50fed6d118ead27ecdfed1a859f135ab24d33a652196d0bcafdad8e6755b7e64a6faea4fb69321d9b678058bf6cf0ba7f95e5b6dbc1954d4f1f186ea5ad70ebccda6bc5b4e07d640b9acacd3eb38d8693795b81dcaf7a1318484599b9f2486b72e17b165a55c6ac679d4fcee06ffcb63989e8accf9ce91077ccce2cf65f8a664602e59c77941bb43d7aee011c4548b280b6155c7e8b9a8c316a5c72892bd801970c49f2a0fcd5c93fceb9203b50e9c08bf70293ea254dc1204d3c451e09c8c649ced9b60fc544958fc06918c86568564d00bf763da5cf3a7762bfa384f590f2e5a286ad127ba2029ac4761c055c96fccbdb9499a3ece0d34433014fde11fbc32e818782baff4f624bb65b2472ada11be181a13d43bba3856542a8e2069848bc9e916fcd135d5b26f0a7810ab307024ce6b127bc4544f7dc68fde7a44c3587abd2572e6616031f1f6c89f41ec5aaf452bd56454223eee95f32ed1fd7bccba2817de548807b7f23036ba3e50172a2aba00b60869b9832329a2d0382867115edab28e502412c5e9776974f92892c8207617623f5b478cf1e5f0a0db565f2261e4e16f095c36662edabdef4517115e61e25252de99ddab1e6e33a365eaef6c253741f855449fe2513f3a2afb00c11e5bc416063c85fa8a863d88fb43b9a3223aa7054bf95e9dbb422132ac68f2c8e9e5b4edfa1fb7fb27dacae16197e14b03b06be5d080023e06c4c5787636cce0488f878c3cdd8d6a4fe0b9777a5517c9ff4eecd7ea3261124d916f3bf30f4f9783c18bf1b4c0c48516773384be35f26d723b8519ab4ffcb5b86b65d2771d9b354b3ce930d5343a30e7721c08ffd0d45843f716b124d84b2f5efce85aeb6b74afef4edc5b1256e071a7a041e62c9e35967c679ce1624079240ddc61d08fe1f20f39431260e1b732fd7b7a3ba2ea96c24d21efbb0b2b0a06f9dc84d4643afef6cfb90d71d4ef330231bb3b9dcb250c6d3bbe805850fcf69b77eeb21248edaf3dd3edba8ac194f5043ef2eaf5cfb38c8ca7f9a260963ee4a116766d0ee0819e6ee4137084e2c9fa39a84802082d0961b0339441b4f92e956ddae5b05a85c352da8a9a4def5d16e13c24a8c4bd9c6291d0fbf2ca723956035098a3e5be96fa15a9e8871c36006769296bb64d9da1ecd21c10d725d3a4449e0baee0a7af2ff8a3433873b90bf664d56e4f8f21c5167b3602a9a0c5eb1de189e8328b1ae484ad932598e5bf2dfc2bc7e6d993e4ea6d0f5f9fc12b0dac4a3f47f1f402a514b079451e80e0197afe9b455b00463050a249025e53529d868a13d09ca9be691af8bdaf5c145b8e0d858c30408361c17c9f9e0c8a7fe0f9a33c99ff1e5c6fbd0a687c521e8dae9737a54186d247cbd9643b8939728c67845f2b391ac84c3ae600ae8c6ee01682e944149b313bbb86c5e62b37337e45ab55dc680c865f54338e9bf470fb03b355ea2d05f84c2822dc2b439f17bc8a9c47e8af32965ecbec0bee978bf7fe0a5512d86f1efc8d649aac8cd14e2f335dd5d1cc95959f88aca90d48e6da8659015daa99094a1c29751d4cf2fdb5f8a4e6084749d585c3960e46f2cc3bbfc1f141ddb2d61cb1103219d0752e74bbdb350442a3d71b496eae31661e1b4374f72c2b3e38c68551133a53101d40b17f0a0029898006c9f32729f3710f910b801e32e0dcf892cafaccd4099f33de376d7d8b14f97005a1a7f94cedbc8a8fdab94b2eb22c5cd10536b3ccb4d1d087269070a0c28d4abc27f8a33e281febb3ebd3869a02d0bf0f76f10b783980481a723bc6adb7904fa6052dcf456a7ca5283794305197430835e1aa5bf274ecf41942e5c172a40f62c7dd95d98170c61cbdace5f55b9dd99865c6bcaad9d9ea9dfd69ab7659fa3a9a9d5852017e2acfef4e9bbf6acdffd5ba26a5fa58d24b04eb36b6a9dd5abeed0be03395ea4fa243e5d1ddf118fe40bb93520e081b00f054a04e6e1f6aa68447abc3cb47b4758fad1cea5fd89d5f4ce3cc0f0229a3a11f092c3d218b59f0e6e4f7f5f1bb70085fe5da2758236d88a3c09dd0c7b4fc3d4695b0874af1bb4ac2c4f5fd89c00a1a581cfec12775b5e4efb234ab1eb054e9b878f21181aa63766912fbb5e59038d8bf32e04a01e552cb5fbe96eb341d153e6c58272db930aa9c626f8ebcd5e3d8b27617599fa04b2a57b05ff6498bc8b4b84097e392d9266867a182042a34ab2302f7803a1e00f3a13f28cd500bba48977c42cf76dea15bd79eebe31f6aa6fe4fd129eaaebc36df081ae0707e32bd6d1b8211841172774d6f4e941d380ee812997b6b38770c51da0a0c051dccec6c078d31e25c8525257727ab56e00f823f39aeadc395c251c370b2ea460a689001729b8720405aa181c55d8327d24e80f8f6f4a0ad70d7975e3ff6a23319a1a8227f3a70fe6b4198f511ea8656caff2dd5c5d7bc30337024bf31bbef25888aa2191217b08b97a11ba4d55dac616a25150cb23f9e3929eed59ddd6c05aad6c3b5419db46be5ed7e8928bc49edc9e40e9122d96ce5d1590ad7131aaa6601c1c8b5b16b67f5dd926136e007d133eab74cab759e95e53b7c98c56b9b3679301cd460b629fecfe7d6a176828637283251a3690512f5913b9fdb24fdb76e330c44855847f0570f7c7b12f2c9f8dd5b11ce1d4c12550b2726c8ee398c9c2cb5903dc89bd5c2dc03d207ec237f8ee33f04135e7c1958d4f86e588b55e9d573e90635398fc1c3a0e8e1a93d4be7984a42f63798d6a5d976fd13f88efc6ad82bae7969fc92cbd1340288229965e99e5e8e4370ec6f06800ffa64c9e6f8c1ae030a9df6f6785adf5fc8ec93a4480712813f6e417b8bac891062377ccbeed17227364f9a380e7a9905f4effa41d084de7a3b52c2ed19f72f1e2168f5336532f505773d243259501d3ec0d38c147ddb135d6278540864a0bef09ea29b4601874a3c30edeb94e82c9e4489cf60786fae6e3610e704e4cb645cc0f218c30b10aa892590191f81ecfbda46b38da29ec704dbe93eb5a7e2aee390a7bd3186aae7eca97b58a12f3ee05b50fe853ef9774db210a119c1771480c6593f4f78ddc3839bde8505b80b25c5f74af1c2e92dbbdeef78668753576d95b16fa7a78d6ed3908ba41166deb9ba19198f969b9d3e3891f3a5be4842824bca7e63408131d043f446512a5e3c5c3209ae1139689e80e3e1c2ecdb967de54400328212a19a24297ca41bf2250c7bf1439c699e348ce1c2de70ddd54f67a9aebbdfb493ea2a53303f5fc8873e8afa8b5cd7fab18066ac51700aca7e37d5141637fd98b193e0a5e5424c5f66a953b1fb3a8a601d7e47d8ff2bd9749244dfba436913fa8e21c176d1e2f2ed57eb3dfa113b9040940d585c01a3bde0638015c31dd58b66d484e514a95c80458e34f8a3d70a3bab841cc8af3008195e453ed102d99f9d449e33f5bacf9775cbe438601513e1df83e21d3467e38bc2cef9b061d8b52ceb6336a912244821f127cdc5a841d0d8e64f1af85124bc79181af290a1ab4db0772bfbdb30f185cc7acd58d44321505b376aa4ee6cc1d9b7900684955200a01cbde7455a4feca3498f2b7efd3e691072e81b1582a84db23ff542acf23f3d1a2b073ab1f1d88754bbd0b901a68b6ab265a567e12cc49e448e3a8f943db61b5a81e83299e509fe46dd8d774f3e9f9d810cc112c7458e6c253e75213ea923a4b155d28c4dfa8423888000b764fd2ea9751c7b3f0b8409d429dfd3bfbc5ebd160bcd35763ebff8dfee6c02186fbd546889131482d46593f31b741521d5538b75756dd9812e12d185dd002459d521c9edbca1f8484bf8224e1dcb1928950dabb0dbad1f50142382d217a1902cbbb16f9cd53edb3e9f7ea96eba697566c07b7c92108b11b24fcb43162846569f591584d3facb923fa400dcf3b86d6b983353fb077fd8f9b9c99032a3cf823191b020c56ac5225e742cdf328a292dfb75de68e43428565f89ffc2faeda81ee6250759a5667ac8d649a1dd5eeb226215c62a2a2286fe474abdc8cb220f69b566d54ebd10e35ac6ab8d5cacdee72058d44e3877bd9b880d250b22f595b17b65e2e07ffe99851ddb5c77b56af512534e3a303c93a6debdadb01744027ec96c8f42478dcde8e9a8c229b6e0777f73f9b447966c21ab9b25612def1e029002adb0038727fcbd29ca13a54874c67a8ba9437172d235cf0b68d43a2b862b00e052404aa7905741101308c9ae500d323b7dc6c9a88ec2823c32e8826dfcf0fc1cad550cb2fab2d161c54558ab7f0e325b68610540f3c18f78632f9a48fff4bfc04dbbcfbc665c229de81ffff7411ad810308fe9e3b29b2bbcd3f3f12b2f8fdec7bdebd6691fd7059c69a388e1902e6026c1eecae1c31eee0015ee72ab083c7b8d580c57079c705593e33068ecf88a8ab60130d7fbdae4ae9a196b8563fbc19f3134c3058712431c945e814fce551c5fdebd9801a296561ea99e9cee1f43210c722563c697f0dbea1659abbcf85b68e9af6565539c305b79763acf496059ed3352208c519e225d01bc51bc9899c5991820c4ea7d8f97f16e905b19a7f70c48dca34b3e3bd1eb8caf0ce91f5a751c16f8c45ffcf6bc63f18ae28e9272141f000cb00f7120e7948f98ad488dc8916b81eb1a44521afe3a559bec0639d725df407581dcba15f0cf7f73a2ab27933062448a78128f0c28b28e92fc9e4fd5acc2a59aa7003fc97ed07f89393dcec29a8f5cd4df19ad4a43ad861d5825c542a677ef8c04c0762a2cb6293193a89a3a13ed7784eb22019b59384fe7386b71a238cbd2ca800f930db9e94e8fe173b93185a3c4d34cd08d7394626187633e90c58c3218a6daed88ee591eab7432b6cf80bfa279c6d6cd11b81fa247049645a255805de297b658740f85d58b2d68d3bf39131ffeabfddea3b342faa8bc405d7440f3ce00d292d9d3da9f01984594b4f168f10f976ec8e6f884ae7ca48c3374fec35ba497b7a5ce917d62dd9985a6986634afc207c1603f68e568a94b70a8860983168b8a85776d5d21531965b325cc1047fcdc901048efd2ebfa5f1da9b004fc04b8d5736e0d7300c2e439ecc52e44fabb92dbc99cec57a752ba684ff8225df2050b4fa0abd9215cb67a0b3ab6cdf52dd17eb36ad06110dc1fccb83985c00143c1f0577aa9da131febb0d4f3d0b197817ff6aadee799e1f0db3291721121c6dd45173433961688a4e14a262dda4479cd4195a6074c4c06ea78ad7c3c014d992918521bc13197353207df7006b46f4d7c9aa88885c3774c1ed940dbc1726f463747a45c37bb3817857c62b507b1483a3dae066251cf58b29a186d7ecc56fa9e79db0605dcaf2ead8b86b181ddfe9811759f2835ec5c37abba331d05d875b323b5e3b66f93e03bbd80f23e5ad054aa441053fc53893499869fb8095c8839151d50a46e7dc52f2becdc628b3cc96683fc48f5bd83fbdf584d0b2b3c14a29f2cf0e962d8eb4546f2b0f2a6c6b2a7d951102ea72049125e915acd2f0d2e5245282ab8bc6532d0d24c1aa1f74a7cc2bfdcbba0918d9ab3dfd946266b517072c2e525f56fb5e81b5d1cc2a96dec279ab3a3fdd39e97f82b8fe7ea9c6df9800efae63b8fbd9e7368ba5a69d0594351db2f11e6c72cda9d11cee19409f20cfb68d7965d4037dce3e883ea4c0a724057d0c6f838e1cc59ed2318011824d0b02d383b5991c0cd8c9b882dd2f8f85dea25e71f205c55edab20b8a598ed763db1f5afe009d8d137d406f63640f9e1010d7f9c223b473cc0675c53ec908d737787b7ff12ddd35fba2b5f37a9d2409c4f7da770cb26964982113f08fb359a7df48babd1c672b35dd135c444eb1414e71467aa44cb082e3d9ed4e663d7be3b1dc8ef925184c4dacef04cf36a7fe542664a436b0c764db70844beec2db26ee59e2dbd712da6ece5f4f70ebbb7e2ebffcf3abc3b58f181354204d10634dd95d30591471cb926ff4779923b6e20a58cb3a685ec246a21c8a20eda1288a41a7d278fd6e0ef33a3cfc577d365a82c4472b8d952b306a784ffb97f7171a6e35504e3dfbeac22a322f2dd5b909641697d0da6cff535ceb63303bc4619feb6365ef728088de5d1d8815436f1d46d1ca2240697284d5c30c406ed423f5f33e7ff2aa845ba6f4bcafc756c2571908b0689d548ad60ea76e40ed970d1d88fbe5c68ae8a21fa89b8f3bd9388eab26006784f7556709126d79f93d4d3667cf5d532a3f60d73ce7951b379af3ba83b27f335ca3ca755b289522b03d231fb1167885f59cbe71de74b567b817006640ed2c56f080f2e176ff25e6a01c94fcc6a952bdd3a9bb922ab3509cd8be342154e579c318fa8d78d52bf46ad2cfca222d705116f5dcc0d41c01c005c8bb26f02eb124219ba4988fa5e0231eb54df2c8e12b581bb8c990fe7bb920becd3acd54d05221a2fa44e69c7c706b636cfd91ff7d5d3f8b1412786285cfef844babbc26e810442ebb9c4954e65f545d40fb3fa0b1d3299af5d93a71573a80b113c8990bd9c9b74b5ece5e27013562835cd7d73ffb6a82c1190f38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
