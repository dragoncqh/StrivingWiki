<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c462ff7640bd6405fd272341ee39cd89677efffaf0cc3beb0f23f23a7ae9f74651ea27f1303b698fcce2c2e63db9447d9eec73c7d84a39e505681dbb04564ea8b0d31d1b3a2eaa7a1b857a1ddda724e8b47bf0e52775ab94f6b4fb32250a005963e1562c52768726b3f25bc2800c56dfe30847a9ccd92dee43a19d58f3f5ac0fc49a3a9f4cc9b2189378ce029535274aef125d05aedfbd13f5647ced571a9bc974e81b65e9a2a2323a5d680d69677986ab5132d6c19815e8841a20bf3a36fd33ec8637dd8ca38f1804f6e599e4ebddf1f82da63bd323b82de95a85792b9f9cea739fdf60dab589d7aa45b94dd43e4bcd1348e5c3f35eac6e6160af6604f5f2a9c7c223a37d4f07c2cbc9823560a16e2ec23d80d3964a11a58b609bf74ebce4cf61e1eb41c3ec21f01c93a0e6dcb8c858b0863e218d5b3614205b5e402a9b5036079c9c0f2a3af50b3a732d5fb3c8ae7997520f038509b7d8fc851174bfa73ebe36631a46cc68e9133333f40e9cdd9194f0853b9b72a8de220f070aea26c8810180a977940181aaf4790013b4453037b5dfe1ecd1d6bbc5f9ebb86fa3f3cb81fc691355a46ae25a9fb9cf2cd8a93406510ca5a7ecd4c955e295c7e46ec8ff97145c74f2f1c160d50b64f0c8a3a662e9ad0e16071f8b49ca2f478dda8c6d71f1cc482951f47f6f76c96fd30b37bb612c8412b879f38b99157fb54ce0dad512982a72545906f2702291b24cdd7f87997656325198cb55cafb4e7e3a3672080e20c044bb65a1e4bc6e6675e73f4cc74252ce27edc29dd6aff31be0a84f29146137a4299a553b5df20ec7003346d58e1b8105d0748a86fc7cf22a3ac8e201d9e663a7624ebab5ebafd4150694e98ce28f2e31f514cc29ee5164ef2cdba90f06fa095e6782f8dd4a6ec46b01bebf6ee2066b17f1df10e410f6bdc873164dbb19a13ad6120b7170aa0e1fc5e4a956c89a46032b0478827e4126e64d70c6d75878ce66d5fbac089db5541b189ba47807d62e0f89cb0edf93093e4b5d09689c110a476c757755ecbd9a38db003bc53807bb42f4bc9a2ee75450b7b9067a54da8bb9d4492407307fcd679e2a05feb5ec3de8e19ff5756f0911d56149292a965540335f3d08f50276ed5525f841b6259c8a73834f75a769b20ad4d8a943e3797ec21580e52c2dba7e2d0e7d30b4bd441bde1dc15381b19f33475e42db4cb0082f8d2fa125d607bac4283e40f004f7fc634dddae7710f6cb3f08f0c8214f250bedc680c34745b3de66648b37eb3d7c00b259f165d6b240255dbabec60b795a670d688583b7cc2cc6d19bfad3ada9fc84ccde5d0af24ede166244b462c656230c33b8b95688376c974dd46629ce659efd60bfda05481dbe667b57d6c640864c2f7d65df79f4c22893b61931db8b7859bc741e2e8c92111411d59d24db6d883238f1951a7b13cf77f7807fed7036ed2e9ab6325220ca9eb34827ea747bd825bcb601020f758f94e6bf2de8312afecc9888774db12548ab07f4adc606bb2ad75c2df1840c3c87ecfa38056c15a485c7218074d44637e1e33d3df40415be0edd8cc14e18d06dca26926be9cb7fafb77ac942111f17b63fa3782e4aa2df7ef5893e8d55370e59d736d09fd139cde97a242db43017ba822dca8d595193e43a9d4eee711ec48ae3f908ee23410d2532ae868214daf23d9c2f7d8f3155e31822fc99f21f427006ea0b93092cdf7633b08158f0b901d989c7357f735b7366da1e7f67c8b99e8bdbcfa1eabed458c06fcef609ce20d5743c2507aed42c84b984a91290dadd4168c69531e3ad9aa34d6a400251e40324d3e8309fdc3b01027a3330545eb1630b9d4d9a61d99f187beafcdfd78ea38577d20392cfc036d3c08141e8cfc254164fedbdafbbace77bef3e654d194b9180ed219d5a80b6c7ba94c2c27bcc3a7987634b0e1bef168cedae64f812e146d205a27e20dae16beaf523f01fe99876594f19dfd8aa2a3038b0722d2b8a6e09d0c139c6ae6bd194c0750a6d7c7ba5c0d633236565fe3cb90f3c3368335712db58d2b5924be1aab0889f979d26fab96225b6a1041b46f1021ec4cecbeb38b0ea905f1c2e5084512b1377283a3f28a9ec6c54ac0303eac3f63e4883a88ef9312dd8281c33a232472deecd2ba9195075dd323cfb58076db443506f552f2b021e39cdb454155e792e80e63c2b8a84939a8fba7442311fbda4773d6b84b943352a2a248f522f44094c0ed420ca13ac554bdee45c4cec9f3558c9799c266a90a5ce2c2280cd2199ea630132295ee488956a74ef1c7745c1a372259c8bf9533f3a772004ca5fcd10a7605d50ef76766bb178ef209c9aaa0c81731aed4a2e0b4a575a14afe1be34477b68dd4ccac19db4c1dac905fcd17a7fb22b819491b7bb324d094a59e8370975c75a5271dfda3e3a50d97814ce9481ba2b7ce58d398b909568dbe85eae0237e8016a0ebab888d3a0cffff5c7ebc4e1be3b984ffd0aef968bf0b64cb88fb44ba500cb70a9e8c358b4db82167482ea5a0f9583bdb2c3c677c3823b9492ec1446f56178522075e9502d3601aa6d5db12ac99c750d4619ecfa8f43a58e6d894aa2daf82616827770e91e40bbc8e3c0b8bcb8f39abef34157d469e9784c2028de61a08049fa06c6050ad3306441b2f980822ddb322cff8a37ec0dbaa908b4501270ffea5989a604e9053b3fafa63e77a97edc8f8390478f834e813f854c444e32a507f16fea6e672dee4a21a0220659f111a18e4f0305f3f4f673bcac855c7a8811aa918f0139ffb4e6f21ee2efb4a00822e42f66480c8ec9d5700eb2a7842bbf0d1246cd00bd600b8916231c4c60a23450f4d3694a5013f4539d981ccab15c7a2b5d3d7eb27ec59692ef7609b249b5b21fea72ca3db427f3b7e8adc5b284dd9b455de75f8fc19ef22073b37bcc8bd41af8fb29d80dc4a2e180094994e77d600b3df126706f46c671b2a078ce46ecc7c9dd66fda8656fdec5df2d8c619439223f9202b6bc99f72f6a22054c1830a3bc3d79a2c9d4dc00b575ceb5c593a5efe5505aa872dc112b457b7c01aa677f1a1bbac901aa4e2adc032f2674f1534f03b96cf1645c66815bd0aff547e5d45a226b31ddff1408b3831270e7beae81d4907d38b9bc2856b0166b17f9b83e9cd515b552e3f206826b027debf27d242604829c755526d7af90eeae0fdce04a313d29304ad249239b9fe5cb2fa6626bf9b55429d95254a3883d8ad7c735be10adfc69fcc41ea773117a839450a0145aaa5a0852be2587007fa8e26041317d61a9e608f1ee8bcaae2afa311b7264d5a54aa28f38589ab88bdfb40c9a69d2211328871a47255a27e89c6cba3f358015f5aeb89d0d7ff31d1044568f5eec5a946b2c1f1f1e753b771a9f3c18ddc16a29b0b5e1124f261840ee44aebef8f8d5103e0466c8134c6d6096748f740937b2685480f4478905663d73d55570f414a291a7aa3a0514fbec6e331e78df102d1699625593f1238f215d75b1a0162226b599f1c7ec16bec4df28120ef54b6f876e864f3144943ef383caa3cc934ff834585dfcebd26bab6d66a3656b73dd9da7de9229089ec0ee4fe3bbd258807dd7d6ee60d61d61b81f46e34954e4f03b24fecaeab0cb3848e5bb7cc94fd02785b3b2ab7d728b3768474ca0304922b2e2050952d7745c7257ce3996f94ff567572c419a989a268ee626ec24c878dc3f9b83b1b9b8c6c5da6a13ba0de77ef43ca795923008459f527851fa49e43d9c3a952f1e02cda247909401e2c1234807b33c90ad4b42738a4a225313b306d85521177ccb4fd031d6f88ee4371fdbe583b044e4b429677093f69f1251dced0b551f317a3be7ddc008884e9f4467c6e4ee5fd3a472a2790e3f0add2a8cf9bb1acd4053004c1e59264523af7f9b39db7b24fa79ea862df417bafbf1d69b4abace9c9105611f305f0e63ed282913748705bffb42cddb8fbbc23ad44cd324eeb5a204533831e09de805fc1d205be7da4bf80de5a4791ca14d60dc8c8d28519964292c5aa3e365654f7dfa0b041efc42feb1f6e5081a405f6f2670ddfcdedd6a75d2e6ea49a996262d0889d834f95c2c49fdbce3ff3710d6651a96383778e684c668b5b935cb3a5fb4abc4eaeabd20e8447c914461d296c81d58a0959975ddf03b2e1c2c2eef5e82a90a24d598086223b8caabb226d8afa9a57382f3c6541d522b5a176b400b14f3b696582a9142c5a84c7281f0fe44eb21e23f19a2dbc0c46852fc86837808da545a3e031d3c0d92801cda32cf66c60fd901a32c68cd307672bf4968d360b02c2bed312c8f71e069eaa1feeaf102e692c09f54c90c4efda87919f234fdfbf6218773e11b073da0dab6bb8b653855de68f54c99879fab6ed3ed97de818e35e71dfd09499ea0d98c16bc5e96417febfca3ebc0854af400cf567fbb0d3c5be8e9a5f72ecb4240438a45f59429cf6526f3e914b65045ee28160bf908f198800e7579c72f1520ee15108206333bea86afde0de3467cfbd6687c9a11bef158ca42d5ee1b328fa3dabb3208191c24a7c38b98b57f62feea325746b6185f47ed29af61f088a5f66ab70df02f6747222f2b144655155e53832de3901992310b2737a85da8723103d786796d1aa38fe47981ff32ad4776ae3d480634b19b516096f5b41636c2bf25cac0dd4ba61e75f898537808e1280d42ff9775858ab376fa07ef04979d9d3dd413fc1a2272e0667393738617efaff47a8dbd0f6d906dab8b14cdf798b20d0df91750976e89491184a1a9d132921f159930c7d588f2d4f8575c1e647e4e7ddff882621b90716c32732b2c420f80c749f1ff7eb1f2ad5d61601035300863ae88f3678de630bb972080a4e3ccaf380175e39efea86ae03e577853297c8b38ba7f4a8975c5493b0de94ce2135eedbcd7ef7f94cecc573231a4f4addb69974174cfe368e6cfcb36a5ad593edcf6db111da4f8d3480a62b4f0b8c32950867a4329a19248b8a872cf0d3247ceb69e1adb96e17c64e932a9edf517535cfe719db93afe2492526ead619e668e788ec317c230396ea0f0a8129668fc0a0c9a442aa41663d29f4faba0ca1d31bf24387d33dd3bdb1bf92c73d408786624631f7a793d45caacf590485eb78e24b94c29579dc74104213c37ba53203271cb36908a444348c2d6110a8404699a910b670f9b2b851398f6306956909c70d67daa4ab6d3c19758eca269383cffc84e34c354fcdd59ab6606cba55350e82ed285b91b197e943e47c06b3de46c56d91d8cc3314887ab42c4c5d409f4785d89e6779b8338a579b0d6b66acdd2b7a590fd5fca05b5deb2990cd0fbd69051819f6e70415bafeeab85cf08b28037b3fb68932dbda8ac1c806af5800164e271bb551e6b3d6d597e5dc254d42576f13f0de5b3d3e97f093a2105bc4e2631e75a56ad4ca60749c88db375f7253b618ccf04da1d06419530c7717fb486bd7146006d22c322f90b17bee347b50f80dccecbb484379cf5b0f8d0ed10e784371e16e06c7423eb706e9ddb9fa99576054ed1f410f8014b16415fcc6b513ac755b66f204bc429b643e28e0349202c7fd17285436e4fe14756de13d1cdb1248a478864d649637a7fe076635bdca84842bf484833c273527d4592133251d90a82d34d59d00161c9b6e2fb5af20a9ead7b9f099c22b969259ac1650605246edb65e38a46bc0a156a19cbd4224277b0d043c363685de58534ee76180ad035c62fd538d431f1d7a806a7da1e956c76603dd3e27f6d609bb22c3e50eac76452b22c6714197641a9885c1daf3ce4c89e30942f6f992fcc1691ba1ee381a29d742065c594f863103a9f287e163d4a6873e4bd4db1d3aa639f8edbaba34a2c2ab4fac12256c85d2460a1034749770d8fca26997eeee7729cf46e5d0834d60f6a012d31bcc9dd2303271fff0678370bd077b211113ccdaec33b434dce38551393cad28eea09997273cc1db4505c33b0997e0cee38be71281c38e355776487bff51171987a2ba1731f933ad03d1854e169c372177ac4b690909fd3ad34e5c4491b537c698992cd2d13e5b43070f17737b96f0c2f9d16efe41cec854687017396d7cd233ef800f417d1bf4c1684d5b904f37a645e109bb68ca4ed98f385c47026c1553ef8cc31e91e635cdc69660cb35a84bf921052c54b191a9ddc266a54d266fdd89f5691c203a6652bf0f24bc453ec691d191dfd5296a1de49fe726665762924dc813b86d976c90c40783df65455e0bfe7e89a239a5c4aa9e9958ca13e7617ce1e80af9368c292064936fb060e833aab2576430cc251693cc7d319af529bf56a39bb21ab28a9a083bf2bc05861a3e88a8ea3a3bbd1d63f0a932186ce284b72a64c057028c0d39a417dc757ef2522fa8e0cd19e74f06aa8fda35a25bd9bc289020f557a2bd110c0f9a8f64e6e4fdd394759da6ea303a37ac66dc056e8faf3bc9aacb3d26d3b52fa3e7e9df28c4b97c4d73288f6ff0611a4d88414d9b47a83144d50701ffe06b0e081c48cc9e2def655d3efb8963402537f631c6af7a3a0e12c83195f504e1dabace4be8978ff4a5be9494c915531ddb1f694c7f1ec745e4b9c448a4884d06efafd420f9526d59b96f7732474be024dc3182cce96b865ebccf6266b4a8765ec45c755cb75a07f47cc49cfdce72c2de3fa4d2aeaedc1283af7a60a0ce4aabccb374f617bb25b91270073c2d13265bb2765d75993c8927b5b99c037c8b56bfc4eedc5646a0f07ce389e0b98967ca0a9870e4b75c9ad95e652efee622fac1989b71b1e1303032a9e61f04d9c5fe88db5fb1bdd4f6aa4cadc2e1594c7c8e988cd66525854f2193a1013c422c3235bd2e5389e5975548f90a6840764b763d7f4c05d243e64a4a3d1284a876e33a36e75ada72523fd69a0f91f1412bd85dcf585594e160ff9e227be041aabcc53a99211f3883e401d42445bd6bb9485da988af37df278fcc577c9cec157776b186f5a9d8bc7d4b6cfcc0a3ab05fc29d814f78214a371595a232bae74e5c65e1ee506d068e011287639f8e440bb570fa4ecb8d6962ddb00e34eba5a74931daedba93e96c986dc922993cee7782c9fa1cfe99732e9fde8617532f66bb284eece20a6eb63c76f3fc3455f5909ad81805474a4690eddd0a6a41a2f242ef92170f9b86c2f8feb8472ab01387fca38fc7019bac9f93e352244e62ad9f54fffe9f8bdd29280ec230c22698f9bc5b0e5c080d515ac66d2a23353d07feffe936e97a7f382bf07b938d8014bd853c99173565f2c6ec8ac07d0794ad84fdbf4d7fcd56c5804f27959fbf7e57b65c0f0f824e8b13b7c8a7f4da1b45d910a5c0ed0e410ad8021356f0da915cf6dfd4e6a36676413d2824ffd6c95637c30cabbc353c9499f26da49c78b3270e4ed880f5120a613a305c720db580856252af6bfcd7fefa76a8ef28128af33837299aef43c11cc80aee32b2333d68c5adce989d688ba08203c8375b30c9d37337faf22315b0f736e42734019a8463d0f0a8eee0378073b3c5e2b0b148465257f1164b3a7bb520ba37d14e9dbaf8c7d945be158d18ea59e71059be70f32c1f6b305613c3662b6bd12e169cec1a239cee8b3f90dcabf9020756fefa20a757485dfbd356138e7702cc79b3d0998e4fd3b46675af636ba436ef6c4e4e22238f8a3b51aa511b3e32186874d62ff121c26b726d988ff217d81b8b9a2e7ba403b3d201a80effe8e360b340c2c581b4c31b62dc8487f0eac351c634cf03fbfa662be56fe838e063df1def23f4bd5ef001150ba7e62357a79f4bcc670a933b9beb92872fb6329e53ba7f978f3ee6f7b9c21c16b6b4d2b279d9683054727169664d70ca380a1ea02d12814eba9d2ef9a69d2707893eb999e708371ea47e631d8352fa7734010ea965f9bf8ac91254ff23cab141a717cc2508c4b224982b9aa0bbe94fc56c019fd1ea111ee2d081bfbd350e377fbcb74e54cf2de8f2ec78a40a1a839c29a36d99dccbc88d7be10a7a390021de4b4f1bcd2bbb780549663193d420c9b6a1436f409eaae4afb1a84f8a7673325776434c8d25f8124dbaa57d8a58a2e861fc990666a743ede73b7cf84dac142ec21c24273b81580e0f43e5edd0a52d81539fee99df15cc12735a6f1d727baede119c10aef3509e5cedc8518d1605617f13d63f12167148d811ffaa947c6a868a389f916cbc844bc8a499ea8b1731e97766063060068d79db6f343ad28cb086e6d782520d8c1036694bd7f8cdbbfd4e58c4780a61b57492a3697addef0e9c786ec43e6d3746ecad260520a4a4ad3eb01e9f6040ec2ce7ce6b319462cda85eb906523151644a7e7e2d26f8ccca10aef87fef992fefa6269bdd381f1508aa1b479adec76abe067ddf2333ccc0601614be2d15f0bcd91750c746dbb3618d46ac3efcca08f89eab4abe3d16be2cb7dcf5468440eca6734973cad10615f0ebc1fa4b781bf381ab198aae42a60efc3140af8d75ff7378fda4f0b1a39474d2c50a0a9d61864387f9971e1477adbe72d83a5f961535cf1164bde5c5d60e7c285300921c0197e2ffa045253a923155a699e49c9d522fc0b3259784435be0745d4c1c76ee222b718b9479b48e3691f0d0a08783800b2f65c4212c04c817a332d34cd218f817461d8d26211d8805f3bc12575b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
