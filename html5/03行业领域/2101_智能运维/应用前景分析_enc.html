<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"173d028fb73fcd3be4ff278b30c70f2724a1f006b8b7b24a4bd7937ff4323a87ba63b7b908db4da349b5d1a7d440432a2eba085879126ffce84ec9beabf3214ed1e1cd0b7ca411e038c107ef4b0957153d4ade2409b66a1cefcfaad287f69038d935216ce5107049d87ab122ab5bfac694a349e78d59e4ae30c78c137c4284fb6c7f28464c39116e617d6dd4e5c3a365d8c029672d2d1156c19ba05bdfd071583ff4ba4d44b2f31a946d536323a0a9f6060007e5b69432e1acc4c71cc2171fcbe1afc0906ab8238734a3294169885af2868fe592c9faf0cc7bf166a02143447a3ce86a6919121b53fefb1c8d7bda73dcf4bb24a975e14f29e8c070ea1d5003fec64d5119474a412bd8a8fc4f6b12db84e09a6c03242a0d23bf063f7e019888804f46d9841ddf5bb7e6cfa1aa86aac65a61714eac37963ca2f967c9a8685235401705673e71e54d5c5fd3641d2da67da146e44e59bb24cfbb764710c5d98d3bc07d0e823cec429f56d86f5ea48cc961ff1f92b61980a7e4c82dbb16dd0e0f976d206f6ae2b44f59cede060a08cbc99e995d0a57846621c1a2c05e3937391a319701f1cb0ea0c99c09c1c68f81127006549f13ed31e3c89fe0979a2519464a9de3d910adb12172e6010afb5a43dd3416b5e0c741e97e0b6ab308b6dc76887c18e3f394ad18e4e2949a0b0e71bf25b13213d76673d18c6608be44b33ecf8106f66a6a95b0129d191b411a08dd77de19d7c8faed30c19fe7e92c5773382cddfcc51cddc29d248807b45c04caedd065c61500a9e45d1ae1a02a85471fa4f0e484b197eaa90402ffd0dbd047aaa1a551533f2cbd11f09f5c1b24d9118e503be5b41b291a8c655d4f938c5dbfb7bc932f4f35d4a5f973eda283f96f34b135446884ecd359bbdcd5fdca4e6f0d2eebe486c6cdc349a27c932601cce4fcbfa7cd97990064f2c7cb84db0b62f876d9ccc4e66fe20e7dbc6bbc0e0dd3f52c554abe49e052dc8620e9536648f7f4f909a91187968e0ce41327d6a2b0d45e90b46eb810fbf9bc573b626080ec6172d2273ddc694c764e3df9ad18389e5a0daa7ab857dcf5c1a95923f725be4040a13d99e82050efb2e81d899b9d1f4238369c429771715a5a26748bdc3f9a0db953c325049f4e1347e8092a5b8fac5230f9f147431d32454519447f14da9975312815f2313716e8d55b20e68a6a029137926067b0d4432e4b9009172d75a41b7ec509f57d3bed30f5d8d91febc3055c11907e641216a4cd532d31895d8e2e2b8402d5e81b18abf7182d1bb5cb19103217eda099e95aa4d5ff5880c1073de6ec64d4e8244e2c0f322a94aebf1b0e22314c170790436259618d360583a76cbf04f6b8ac8e82e086fbede5746b2854c77df9687750c7f3fa8824ed854a8c17d25590a6fd9d7be76644baf084095e9cb9b3ec4e7f665224c0dd055a6437c8be17d2495857a9ff2f273b78fbcf01d23f796c3a2975e0b3030ff0f646cba57d0f0717ddac1f233db26e02cabef8e4f93471460bbb88ac724e181ec25b9287c874708a3c71bc8daa62364e9bb89abb070ce15df09ee5ed9dfc8624661411cbe284cf9215c1a855554937ee58ef0aa580767ff114cd9080cdf912d09b4e7d57c6ac44d18491572e9f076d78b23f9f98ee488dfeac864b8efcc57a3db6369b03cab78f6400177fff81d7f219c9cbc872c29f56cd8f5eaaf69a2095ce21cecd8aca1dfb3a14d698ad231b1597b333475316e859bce9bfcb3ec95df4b4f8ae9ea4ae51e6a65226158ff0bcafd9fe988d9a5d29ce305b8b7e1a2a5d539b10e3875a581bc23dd3186fa894a14e3141d90bc92d8dd517b4f74647173225b91da950bd56c2f9d194e4bcf4eea7530d0e705434b13510ddbca11b50f896337c6f9895b2022c1b5f9277e85ff15cc3c94d0df19ddd708fb65232b4594ddec46b2029be92c27fa575747f71e78bf480844138cc5dad390e0f6c02a979caff7e07c06e57e9d66ec91b7c4a8cb7cbaa1f6a97d225d79b8cde552a4052fc8c269323913d64012ef9f6b1c525b74de93b79400dc18e3d8c9211918665bc42d5cb07ff15555f710f9bf3d3410cb7a915109b116bbed383dee29a35002212fc0a7e049981a31b2fda57791649992c3e2652e7742bd819a2d54213c9c951e4830ae0833834500e95021fc2455b89c851783b726b8c91c75d4ec6948fa47954b83e96e75a9827633fe4d35a97e60d8619fbe2800e09397d2295d030fc90d753656a3faae07593284a9531bdd3acc7031e62c005d351abe1fd6d1ec0b4e0f163b1944eae008f4c0d85cee1cdc38ac1b9e60e717c3da01f77ed48c309b11b1b7e932a03a05d7114c02313f17d17b6c5ec7e10ef60a63a191f6261c6e035f8500c77532cabbca761cb44e47f4cbd005a90ac9f93b41d543b7b19b2a36513044b639f3db57e35770ff95fa27e6e326e9972d56f92c63f56cb3cdab009a84d7b9354921e7c10e83789f29077cb2ef2c0cf3fd569bd7e1b5519f548e6d8b6c8317a752ebf12b056c318efa8b1700fec23abd28fe804de1d379f46809d83311784c5036a03dce223be8fb711b9ffb4fa59dde126df600c8c55b9834c1e6858d8c3126a402da5185be40a9410a939317b492902c8d6a80874cfe99c1c7191ca90c77de372df5386ddba7a61aa903ba342e0de86d5750d2014803f0e6fd4011bdf954fb0adbad95ec56883d213c1ae6b6c7e82a0cab2628b41d79c8b9eda35e5c482fa856ac3f1a36e1e441bc62a7246f46cc2495d2123a2b8a575d1d97595fc55d2087b88783c0400003602dee3df10c48d0cc0542675798f3945203c9f859bfd6a038726a46efbfbc7d80c56a90b12eb840cec569a39487cf81d3dcaacb8bdac09e021e5e1350908e80b1dbf1b28f92866a7644e1ce2fc54d6e9a586b131046d9a314af57c79e081ace05e5b7d79946846fdb54d0a9013da2ed891a77c1ba62c53fd14bacb3285c2c23a0c2eb39ba7d2b90b45447bfb06f8a1465f13cf47c78d6dc27901d9d9e03afb32d2b30dd34a4ffbb971794be7ec2b81efbc42f92cfd993f48b280bf79f5c56bb08a4e31b5a536bfd164d3cb229948932c93664840246e38f14f67a456d2fe853c0cd5c377694c0b183f5d9b6b2084880588841208ef7566905a46f27eff23e237f2e3fa5f56a8ac51410c542cd76b92ba76e06bf64bf109e781957d1b9839b7c4615e9720919ed02fef3f0a557822865ee98b4d961f971a7e72358fc415f21858d2cf4f9149de16d0f86d43694fb3ab7216878ac42f93281026e41978632b3df098f5a45dc90dfae9f8b678258da695ca19ef0f6547fa1f3f24ed9bc797325145c3ae6e36dafc73cacd9fb302ffffbcbb0e2b35756af5c50ac4346a88ecbdba647fbe123ab1f2ec9cf46d00792eeb392aba60281a815c9c60b1c630fd5f2d6ae9aa7fa9189b84ab26276b17a7a97d121ddd459689328e127fc658fd724f02551ffa1caae840249381019105b778f507f7fa249cb473286a2812c4cdd5fd956dcee6292edc874584eaaa688229aa08a5fb3ec3c14f2c5a1714f6f5111aca45669673d1cbd1f97c1313ff1ed207c71a7e441fce773a8e2f65b0c189b50729a4b7bf4e161b240b6d33ab96e7baab573b5affbaeae158c188c9ddcda11f3147e7e0eba724196be5b6c42a0b4ace4a6a7fbf9b7001a638e2a2f5207bd9395ae098c80082dc9410dc97a2f6a478bd48049fca4c9c6838cde0c781d0ea6834f6ef140408d46552ad4e7c8ec2a86210c23513bb60374aaab972a69114d1a58736f9f9622b576257c560ef4a37f324af8d5520bb6528486a1b764a69ef8fed926dd3e2a63f3771e91d100d1bd97447b8fe0ea851d2416fb9e9b8580c4540edc79769ba25e5680ce95bbd98ad54a0546773b911883e33fc049d98a3adc9458887538b1b8c1cd0fb681c1d4ddaad705e1c4796d655506e06b8849d751fc43af8f234326bb694662d639816eb6f293f8e24b35f13be5740b8078b8a3f2e39aa997db59cd44ad16e697b8d06aca39a6e2544fdfeb7c3ff5387717bb9b46e3b7e096f2e5b7035733f1f679b57d9f425301066abc92bf4522b1905a13600f13617e7698fa2de9e45aaddc74fd7e2919d4d5e808c4c8dc70e127ae05bbfd1c33414a31b379d8328530df7bba606a924b8f1184a65d822ca71f9e22cc2e6a476e6d8a224bc37e91c92746f9c6ed0943568109cc135fc9ddf2a8829e24593c30fffb00223ec1d6d291d21e1efc083b26ef747354826f067e1151788ec6bd409d1f25241dfd5a8c4304fc0885a65aec0e31cc1d849a8d3c51f9886645ad16faddc976233511e6ec239fc4e2aff0439a9f7b4704689bb69c900ccd5878bd327912cd4a1c86ae4207e2aee2198a157f5a19f5e26e2c7482f6d230f2dc6f1c4396348219cfc5d8a215a5450e78b477afab180bfe3f6d2a046452a454dc5b1e52ac1b8d653a9b6980246ee00b208d372bb95f025e357f1b01ad53584472340e62c4100650162f79472a2281b335916b1707ba6e6640eaf058522fdc5b58da25499eba5c3939c098a0176e146ff3ce7a9ce047cccb437a769e31eb3370d32466398b7dd643a4bf32aeb4a21f93b541a35315d7a6cd301d8aeb11d965c10a3e783c1db94ca752501a8cb592f0abcf54e7fe97fb53c0186cdcf5f6b79a5283344c814461f52cd54afb31934bc273b0ade3308b51b464890b8236820b5c25ddd0725ca8bbe1e716c15a285a7e00a3cd18dcdb6ba3316481ec0297395c6e051f93953f5fcf60f372a53ac5881a9bb5aeada124ea0e69741215bc13eb901a24babed28f421a21348dc47dd7b52f241bd70597e1bce3940f042b4fa1af98152ee756415f2f91ac0f448089ee7bbf0645ef4d204a4efd1fe1eaf3ffc7e31c6b99e5b6f40f707dc2fe78ec519f89f3746ec49765075b0d51763c2ff39e588e0799503a447b1fd03acee7dc39630890e7b209767a8fde821ac1ae995c607761861120e925bd4a4a861a16dbd9bfab93c33ce91667f7cd7c77736c4f7f5a5264d1325fdaca3e1b1ab34f5cb82016a5d6aed6d137e2d718f0e6d2e48a7d152b4a6b29ec4993a3e2edf01e6ba5a3bbf57f52d0ec001eb8fb8c39e4a0efc8bb6c465ad736c960b7c0bb6d96115de66cbe5ae890dd3e79669120143360585f6aa1b359ab9377c6b4b596ff1f70a88177475dbcd6ed9d0a5c5fce5c0bf2932f555a79d5ac50a74824096d85d161a10a01b999884aaead209ae716b73b524a9e2c51c8a5601a30de111e2882646d1a1df12d49955ebfaa552e80d5540f0e909e58b1a00a6c8de270f0cc4baa0c936c40ef6aaf5d9ec4f3879b5138dc73162355e989fc1b61302767b378f32008c771872685d207ba813fdc694d9a54529b2d29782ec04cb10a13a4be845cfa49bbf280f045d395c50e0fd1d83ba0ab1497e908391f933f1614cc51ab0e9086bbc4a4c0b5d66e961e848b89c3b8a559e3c5e27426ca1f470766a2e6061a93f19eb82b1d67c70923e40b81d37d787324025600dd2778af39a62cbe2709418030bd7117db204365a1d7b71264077947e9ea4027b46a9b0fd6ffa2115926ee94fd5cfafa46d0ddfb531f83b64977d50b1a2b44bb1f54d10f1cf83e14f3b516f7278fda94f99cb95e1127f0ec57639b8c5911211bcc5b96e81693cb59d25aad4d3cfb98cb50c092b8e2a29530a09f21ab73332a9218bd3543fc5d7678773d342068fcfabaa2c02de76f172c8d3dc3bb874dd1542998c39a0f40bd5c2fa1247297cdba1bd9cc08d9ad3997aa48b22ee3673c5c57c266c5f407becf91ceeac558d26b3c072759badf9758ee8f7cd16b64eef40c73c50534b880802e5fc99f9ba81dc50ef00338c0480a33e4cac75bd12730ad147cfad4d253ac2d5a45f375a73045db6d1bbf74e89c2c6ab1cda37e8fb7d0a566109b52879b7bf28469446cba117b7d3416de5aa560d758eac9c0bfa7d7c36b48ebf58c0bb47e7c62e838a3ce5750abf157151448b4e0aa5b95505981bee0e82d1ce53db548d8d2a863607688e5eb379e2fabf2a4911fbcc629b3d0c54aba61039b27b7d304c0d312e0c63a89361a82094c1b1cb8c5a1335d3bdf79902f0391e1b2485731f4d53abc05db2065021868758e137e13c6a02f7ce30057c00c48c80cdc58b859fa4c2ebf9de260ca6b56a24539c74452c71a13023a07e6e2d20c6fd3907e43c29006abb14f4342f636a990178f0f116bb9c33c50aa335e89bb0014681afa1d5abbee417a32d5eae988c7d004b96988154da9e305e2f58f7e448ae1457812d0fd98da833412894494c7992e87a229347e7618f84b07eaf3f45dacec1b31ff24d6d144aa3b7800e9788fd0b5b9c829e86219370deea6776d6941f91d860839954337e455c5f0df2120b0ffd0b83c86c056e58db8d5a662201f1d7001cee4570a65f766d72dde11007ca2046562b9c17592cbf8c73ab096ddcdd88656bad80f20ef1fda08c76be1825599eefa542bbddf2e2a8b5f544b1f5800a8a7c914dfc8986f9a95773d1bb42d0a284c10e75433b548bfa133588fd45386797c9c574f69a160b085de1c52db10df09eefa524fa7716d689cf820514656fd434cc86040d0e97ef1c464cc3a5795b28ae35c265f4b540f31634fd6614f39df4a8c743e08307037115eb4213157bc4007f703b214a55235e1bffd8443b3973cbbd7cea8432b59f7ac863dbe4c7337753ddca36ba8dccf95cbfc1f2af69d2aa878d16f652f25035ae1d471f5909fe880fd58b1cbd5dc694770d3d3225c5850a0125090f43c1a2d7fe35c0b2923e8db4d432afd0abc36666c49bd8960f7aa6b34cb5c46f577316b5ffea8f7ec16827f542ae324b119d7d2845fcb9861dbcc3323b179289c6494f29dc472ef753f09b1e2ffb83439dfbdf99c9369167fa6e6d881869a329f57d23761c86f47776135091e9dff337e172bd809a997a602835f1228221534b6dfa2ce6370209f3697e9b0c022addcd1cf10c776a0a4b62f3367db235380889b65578886547a00175224495c34c5cdd44a3240d739409d6449e5249a9ea12d7eccbb3a4ee59b8cb24de8f7d044f773114647cff58cf24e845f58bd6f98943c784e32c2bb06f4702d9184508cb9ba7152f6f84a2f29e0943670496c40a56ee20bfc92c676ac8cd47b9ffe11e6d60c12c98d27ba56d7dac2eccc73927d666460ccf55af65525858691ca252f773be2a35ced11c7aaf4164267ad2a31d831e71a9a6def2ef21bd6073365512704876e7b4ae6876647a8cbd9ebba8a7fbe418b5ed99cc0fb3c44c956eb593cc626ac247af1fef2b2cd327c15e734d9ff330fb01a182c888862f32d7f0da20c5f93230547995805f0554215f63bcf8632213b1f73a054c80785038631da93a7e18930c17c3e749c625f5194d08f170ab8ea3175928426263333bb85c468cce78646d84d0008dc673ef289befc2b8a2217f42228510d3d72df080568011a7fdb8f1f9ce624b8c644ce19b5cbab15e02dcf795e0248ba49518d29d238942cbe9ed76596c10adf8c584fb42b7d7069ac20b76c5526041f5e44ce7508a98ad7da1c3efe0134a9a8ba96ec605b9ed3cc78773bcacc1fbc01fdb4b7644f2d7c62a2341f8512921d4eafac5fe47c896f3dbfbf27208752a4409f4f79544c50508d1798eb29cd1d80270f635db6d4a3a38cca0f33218729298f638bfe1244d69f5c32d5e607c5be9be8b0f8eb202c1f3393cb02176baf9bb7d157c632635e759dffc8a00f3740846288c5e1f2704f1387e275c1b5e01fc54a0867151d276afc60f430d42569984e1e71ba5ad9a5196b65a7c0ca217130a795b4cc559713b0b35503f55fe9f482e089be823d60eec4ba11d5c7bd3df50e6e4becf4622e12b48597d91dbae1a1748b2edca4730c4fd99ac8fcf51b794d606a94b5e650c84a12723d1aa6bb81861212c701ca41a97a75d120408738db31e65d02dbbff51d85500a383c3b3c163caafd63bc105aa7c6d3b7e6d669b41e96398a24b658e9fd7415ec559c59373a836f6d4ce5143562ea9f327935f86ca85f744ff3c88a9fc2795c36deb4c4435a63b859d600cbdbe418aef57d6458b3668d4f21eb7ec3e9193c87306a244c3dd88af92ffa08cf50d0b4dc89e55546ea3f9ec0160f02be43cfc3254ef8c22d6df5d27dd8515d98ffd552d6813ba268030be04b4d78da045ae8dcdb559193967b7c8ca9de56f718eeada99a841be6d0f793f2e2f04bdf0c5cb7fd54eb4f54a1b28f5a12fa96e16fd784d6f37d737cd68e5c24d473bbaf2bb5587f5dda9db16c1cb366815509e1372ba410f90be0c0d8b551b56d65eb162558ec35f493c2bd5888e0b7da28bc359443e51c05b7525d235c7fdb1074412c71bc68a8715e4b1c068f37d28c63eca5f38772f1c3e999b2b821863c770d46b3bc18c7ace3d239d20011e1959bb5b2b06722a52a8bccb6f2c7a10faf2d262e37b598b790f9a9128ee71f1964df5e9278c512eb6a56ceece2f2ad0f39b37ab4859c7f13e5019fe7c0f40776e8244825de6eecd24a8ed1e0c08037beff325fd6a34d8196156b968c3d2b749659cab384b877ba156d240947f155a8a3ddce3c38d673f894e0f4f9977134683561c1e81bd898519992dc7746a10ff3c2359b976dce48b7bf64e75a92b2d8069aa6e6682fb7678f50f555bf99a9f196b01901809674754165b89dcc0568637a6cdf2a9b838a76ac466a0e3c3c2769070a609b80ad7a9033e526740d802eb76eb5511675bd6f6c7e62c58b3788091b67d95c8a740fc79eab56a3573358986370fbd46acfc97073ad99fc87ec0c1b93f415a1bb04cab1762ad1d7d57db639bcf8e881c0bcfce978f67d917f3bd7c16f82cbf0792cab5f64173111806ce359b5144fcb739e8bafaab9e9d5a22e982b6ae004ffb029b8647a4562957dc0d97d144393888aea69d17c65c27638675100e2c97b399c8f7ef8846460df25dfabc4e297977896c6f7cce83f81000bb8cbb8ea0c3f14c6a844063838962c63058c1daa083bbe68f39cdf2b45582969022dfb31c9664f6cac35dcde40b4bcab343437a45414a4e7d3d16650420e8365df32f5b56eee22410e1c1f2ea556c2ffb0bd37027d1c51bfe03ab525d7ffcea447ba1d4d57a59bbcb2bec8d7efbdedf334981864853dc5878cfcde48d3492c23fdc0835136d9ea70df1637e8a6352dd8589c775f793a05a2717f5bc75726515accb6beda794038fa67891cb5b4882108dd4451afd4b11f6f17f46a7e3d6779a58d3f5dff3e7c135b2f03ca190def68bd8ab2a4d4bd49b859460dbdfbbfeb24590e9581d94389e821222d6d3b88bcde3ed1acf6820dfe31648fcdb9a4c6c308f39c2046012e00283454ac9d433737ea8f96dc9d5e026b739fc0f33b6697c51658f334361f8220fc7a39395e8dc6006107bccb3f235dbc85e143e31f3106443d9f3e996e6d3092b1945c2a4799fd717672ecca74ad671d256f7cb54c2a7d64fba6cb58ced6cd18f54a37c38eba1120da9b7979b1b74c70f55c845d466fcb62b4bd1fcb997eb7b07c51f8527485b45c1445ff11a14a6645477a99d203aec938cd19f23e8519740b057a81cf416c63c801a8972a85d71acca4b64cbac599ebf413f51a64f4d7f0c5526f971bf72d378f070c3f6042e933733ef733a4eb5d521cfd983fa47bfbde56cd8a9cd053aee0c51ec9ac352b09f624a7da80523ac56de2e2ed3b1d9135da0bae7f5860e68f9337ad3b57e013e1e8127f9e5c40dab3580e6e82ed2fe0270317ffe3eae55ad826f4589f70c8fce2ecfce97a53f8735a02d7269edb367190bda341251943e07fb122b20ec4b4992ecbdd34d9b11cdd2ff8412c0bd97ccc6df50cdc515ac99986009a9697054db2ad443693f0e8a7e282cd219bf19a635ceccd0e1d3c5655c2714dc1dcb7890b2817f9660c2dbb08d441c236783414bfeb5707708d3ac98287c9ac56e80114d50dcfc0459f7b806d0f138744a6b6a97ae037bbd85571a1aafdd7e267edeff8f2da874fa35a140ed5628ca77fd8b306039c969352b7b3f8bd75f1410c4e972260fea85b2fe7e51fb85cadab1e83779f7ab3290e624c78396cf81391f745aca87755075e7996f8db9ceaef1841369a988cafc1be0a4c13d52caf987cdf60d9258a07e2888bb97b6d817bf79bc89cc06f2547ac9e78ac113b7d7b65de0360ec119c89e67c85b8e79a56e5fb7044e79cd1fc11db8f01f7429749748c6355398dbdb0a0b6d7371195f880e74dfeb73c26c66897a52a5e3a0fea85bf0a968df88404128a1175de9373736b0704f5567bbac58af2d217da210812320c7be79164aad7fe321a655c87b5e20d06fceacf6c75df45891c2dc5addd2ea0dfd6c8446c65af45f3b98fb395735ab9a11d4d8bd53572348578c36c2231a70cf3c73defa2646ea749f914048d589e4027612ea5bb048bb955008b3e5c6dc5f3bf5b44e17f3f8d346faea438571fe6585050d9afb842cbcd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
