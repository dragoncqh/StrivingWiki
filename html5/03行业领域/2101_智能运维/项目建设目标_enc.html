<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee0946a074fd88ab024df207545f7e59724f50dc1e534afcca6eb1dcd579e1079cb596e209c64bf473a2ceaacc8d08965b8059b5a3de0a4161fb49c8ef1077a2801200745465a32e4bb53cd2dca7378915ae8377145efb17aa6e38a461c2236d2c9b457938fbd573d6b92fd125d6ef660d1870b5cef1ca8df50d77cacb95b0acb3e7350ac35629133535bfcfbb3a5869299e6c299f7c1402f76f2081b892d356d0305542911bd7bef34efc9073394ea74f9f5bf496556eede95bf52ef9448a9813eb6013f43908a5dea563aa0b22295b0644f93e7703d32d6e208d1fb00e94e8c247d1181c391d320a3890e12842d872c7e8c011065d12f82cd16e6663ac16defc915f33a70aa25355cb4089c2f323e0f81db0b319b7496611cbc4796cf55e3a047e591f8c7d39f14b22d1ae5f14e95693f0d9764aae0b1f11d1bf2fc1eab2d51b5da2a6e1e26d1d81c67986884c918ea67a9df028229b8e75e6476496fac2084f7d316a73ab28f5b2cbfdf6de3aaa9359d8d187c34ea8478f589104d464a429395806d5ced9ae74f65de3f53bf9b22419b69eac23fb8bb0403a85eed54f5bcc4a3622b0eeb6884ae7ae70abfae28ae3370cfad158387f0a9fedc65a14a8da89dbdefe375e87170a9642405336ddc0ae0ce86d37563c8c0b42417b846b2184b88cdd8324414421025ad730f3ff3254933d9f6abb1bf06462bea48580be1dfb1881feda35def6330bba6a74144ce958d0c0b362b77de83bb2b60231b983ffa84e90e5edff9d9ebd3da23d237ec6c6e8603a1fd51f287f5d51f11a23c0e01bb12da97cff5b62259c75f49ff89e01724ecc0c53603b662d6ffcf9005193bf8d97c7c94b52f2191cef9293d8a83dc89d61055220ad28625d26979f178d12099a4b83e2372f6e34532a67b77e547d9bfd593fcbe6c715bf55e76b1541ac524865205a14ec7400517facece2e08245ae4f92be7269e65e78a451e21eef0dc6cc1fcb3483192da945bc877ddbc484fc29fc62612b9a881015789acb2bfbd1a65a0099040d749a565d24fac56f64a337a4c0a8892b178cf10cc42c821f9edd72a6f10250c258bb0eafc1d5aa39716da36e27529e811895680cab86dfc8a4f861c2f89fa28b917a05366846de06b6f93c2fccde22b12668765a9723406689e8f673f05423b3bddcee015497a72ef71fa62676138b6db1fc04885502b06e3e9d7c89419acb9aa3cc8918f0f2f0ad1174a6062b9e94c4a4755d4003b0c8f895963b8cb1c3ac9d1b99f1cbfea44e1d40fd671b12260ef03d4c3f4c02bdb4d5927e76c9793e8fb89cc3ad004e65498a00691d8d77844c63cf62c5cf5737228abcffdf0cec5c58fc43aeabf4eb4666067a079f19a7f03b6ca3ce393ee3835d3fb901f4dbc4b1d67290931171d797d93f83ae498342ee8cfc27366dbe07ba4f9ec5ba81f3c7399f00bacaf0a24a79f75ce719e8ca5ce7cb04eb0fd5c9109862d354d700be0aaec3046b070fd6cf322a78ab99a1147e7b60c9b013524c1c9493d81b0535c8104eb79bb6f79caf507f789d03ab86cd851bce31fd0e4156a414c4f2722e869f13900c5932a409bf022e4790763a9d4c5635d1af1b22f8272f5f0e72f525a901e7c93504e346aa30918fe38a4814746704be08dc41ff306f41f93697cf86ee93fb851f4c01b23ecd2dbed2cb3a654d58e33d6783a4e88eca0e65aa3a6672a8d43a210c52c9b8d133bd05faee3bae4d71619f7310413245d817772c4c73b104ac053c72392e83507239147851f37c7ffa8710df70218d6801bbc9db669222edbe7692bc0bedb0f3f7600383e236aa255a4d6cc184c62cd728b5929c2309c1a1344ef27d8afc24f51fcaf995bb51b65ea5d40c66449959a7e380570b676faba225838afaf370905346e842a9110477cbab9c1b507b81ad03e50f5fb68c6de781d9c81ad9ef5841cddf1f371b6080b7f67b15e0a8bfd6b04a9169233e7b367345605eb8b78436e8ade5123ceee5b5b61cc1fd666e679a698c8e1d4a0c37c3f79ef52dc1f5392cb57d088833b2f26c748c3f0580cd7028dbc1d28b94d2c2652f30b1d26b61d3cd0af09935cf460a92abce9c19835a268fdde12c21ce4d74007c9e297aa79caccd4ead986f02ad29ca2222f17cf7aabd11f94e2255017f56f10f1af4c0b7b8aeccea235e0835aafcf4afd15bf0226c94d21a77d6057a9438f89d52c38ed70160024c682de41b1fc496b2aa147be482fdfa0fe94776d475b2bb739d3f5aa4a2ce0bd0dda19955ef74c63fa9bf78db546c735f0f445a2161feba4d174fb75c682ce770d8d14bf2ec4f9b8551cb293174074b235b5d18c322f7c6838bb31032acf4054f5e2b3b846a0de93cb9547dba3cc0fbaa31cef55f537940f1a14f1ba380b7db3883e180db742931722e37fcaab116826291b984740f420af464db0798a323ebbda93252866fc644477e1d133a9b2db6a9a115b424faabdb52ba86b8a9ae8165e7fb003629f55d437b037da4cfd5195e87bbb9f4b4aa95fa44cfc08616d56c0992c0c12a228d0529d83326f75d0ae1e8cf01f7a59c5f024905bf1192b5874e12ff61fb39bd5a0edc8e88ce7f28bf47b0f8a0031805c97f8262145b8d8908232c7f427444a13fea2106dc468ff88de2f727efdf5ed24a254100fba3a18c9629232114049ad98022005d07934520355abf4b48473f3b6d62f9b3adaa17bfcc7a67e215917a130cb2f4ca8588acbcb11622dbc51df39d16d1358ed595e148a592f8f0746ce49b8cd4fcba0f8824633b2c6b8c3cc16349c1110f23a1426ff0b8af31c374a95ee707a87434fb7b75708af421078a3ce81702c455376074de24681d33b996b5a47ff1d5e60d8bce7afd8205e44269dae38c832b434c517ae2201e4c5ee319a8824db64210c42fa496c9ccb76dbc752198feb1aaf3315a082d7c5aea44bb8d5e89db1cf087e2be6afb3efc4942f53015c535d5f9cce0a07da47c0de5a891e95f06b06c4b9088f7d2a7ffff45aa3192461f3307bc8f1723f89ea116e25fb2aa6176720c6a7b396e51fc5be2ad7e37be3976717064dafc61c200b13c5cb0c2e7911cbe2793d7122b2e9c598423815dc77823e1d622393eaab04fe2b953b323e7298b333ca19d13f303bb9480bec7f42aee41f1b60c3460c8fe69a4de260041632d92e179629984e95e8bb5f349fcb6626a3938f72c62c2a79cfdff6994f4e06692b61bf8468ab510e63454a625bb1a243247a56c5fd009845f70a2904448d5a3f4fb9ad0743bb73bfdea95b0417272d389bf3df36a264486c1be5062315bd41c0bf0230db83055fb4da1fdb2cf322bf1920062560554f03dca82b73f881a7dbd4b5eede0c76aabd2c71bbffafa9db0e1721ca39f3b13c5f25d7c1589a1d785d1093888bf1dd7212fc4495f7c7d90bbf24cfc60faa1dbad4fd8f879cccd7bea2e9551cd11aa4dffa609608015aade91bef907d3a95f6f249221ae10227ede278897776f673106d9129d29de29d51657f7f373a9eef4025693cd521d882064eeae159d3c0ce1272796e4b0724f63b3e7f584ee3b390a89767b75a13810961ab0a2d93fd53f07b8b636c1b86d420d96e6d2694e75cc1d3274f1687e05a50c96e7047307594f27fb66e087f5b12ab971dffe530faea6d47009f0361f6a75d783d78a05c563af07109ae41e9d04cb9a57ccfa2dd7334cc0888fc687f9d08626545c86a26c6e749ee70bb31eeff8d7475197ecb9d2cc3a37fa784c0a51a99edcc7c947b490088efc94c479e2154ac959440977561083e865921939b8a42b448f58e1ac3a57e8175c8643f0b381723110dd3be157477f3f915984bbd60382e31682b16e73861485fef4ce2e9772c46e45362e1ac32e88282403cb6cdf74dc45ab9766e53a1e38de00b03dc2122c27f4ea0a0bec0918d9d62b429c53f267dcbb0a0b3a4a126891db9a7f36ba16ee887111d044a3d29c3e317ce69000e7cfb0ebaa61fa1b1bd2b84c83f43117ae5a1dbf6295be75fcfc73f6381a18e9b4553f23b6bd517041424f42b1148ce7d0f3284e6a3ab97824c4200ac1db6ad9417ab4171ea75f6b1ddfd5910dffdccea0b216f5df9f228a3a59ba48c40bf829a5e62bfa863b0dfc8da46b6a10050e3d5329d47d77057561c5eda30cdc239f582e2ea9cf28d9fd3edad808063206880e310017da34aab80010c47b4fb6a239b6e189d0f6fa6fb60b7dd8f840dc491b6e4a8650961c8703031320c37265d72077235a51fe719c5067750195a56e93c4a2a35c5da01adfca41b0683c852553e6529b4f806762d6337588922dec33e3e53fe760cde26759bfc6d8a38bc24f0c0aaaa4a6683458c461e4e08c12f91e94803bf08f48f491569a62e78c7d13afaeb31b5f04a47e5d5d850ff750e3f79282387cc43e7e496c27fb51702e97eb6ad89b3e8599430262e3f91da398becdabd919d2e3fd50425c68d323c1ac63c2f383b57e1e1273de7fefe591fafe03338058fb24b1ad59e18dd068814ccc9463dbf4d36f9825663b5d6f219676e2a8dda5624f96027b9fb7fea2659882eb97f21e54883c988aceecfbcd73069b5dba5281d80288cce56c7bc434d46385f507eddab25538cae85767cc1fccb454a2a71fc40bb77327dab474eb4be4552b127c158beb02512c1cbab4b4141ff9c8199726afd79c407b266068706d2a0b218bfe937d880fdff7cae1255a24b37dcfa26c8f5189df7ec31edfb813a1ad03a3046b8a1ee5d8b2069323957487375a8538010a4cd160337716a9762e3d2a2d804ef5ea8e9f3df0fe1da0eb9852d902ebfb7d5fdd155e0895fc69f5a313e0a378e893e319a6d1e645c144b899923477e4ff25c376c733f0d202f6227d00f03657f61fc660290e50780faaed6970c3017baa76a391baade053eef29f1e2374b2591ceaed2bf70ee6026e17a48460c4f0cf0967908568dd712da90df7dc96c3085387716f269e4871451a95b8ad571231677d53744a51d0d778b53fd73dc3ffcee231644f05b950f235ecf2c1f867f8714ae72f3a5f9a48307be28a6c743499cf59287085a99b4ae8972fe2060c17977ecba841ee90e975490f6d917f50199fc21c3a357f658dc604466a1fe693f829a9d11b4a6c905690c866b86aac31102e5d0761678a544e81acaf4b137b58ffa38fbac34e600cdf957edd8790a48e10f917f96f5476be2f7eb801d111648ba7c3b4f269b2f319288d4cdf77693a0b6b64a32b17c8c3a56c4d82e60f79325ad54c296ee1bfc9d406b909bd10445be2671be1b8480b3ddb9b9721a7f0e315a7124c231ced0ade9249a9b5edddb2b7d6346e2b0db9bf230bb806bac43380cdd3741dda0a5d34d3cb39bd56623abfd612f5fecb2980203453719b017514e3061fac474905ac391f28ca82f25288ceac20e4e58e405a8d2d0cb6427ea4bf61ddbe67c3879daca3ff140627e6accf47e4c67fb12518f9f228423e1c4f5237e6bea015323a0086310a1c9287067b7e3893eaf797cacb1e76ffa18b057143d95a7a71d5806e198ec49fcedcc87f071f0f492a26cc85986a20125b4439425f1cad896e3b0882d10e7e79484030cb844eabd6659c9e2cf0695a3840d7cd3b93160b6cbbccae99004a95ad41920dc5652995706181dd90d5846efc19c75ecdf01661a4104e2c8048ae04e7a8c05ad5dcf86c712efb89cc04d400c60e895c79653e67ea28098a939efc90c2038dfcdc4e8835c5297a6efd57f79afdaeac70e3dd541cfd97f38bb5f2c358bcd0f0334b3e0b92ae0bcc4569688898dbadbf5f82b9c9a3320861d8e016762b4d6d34cacf16f77e0c7b857b2ffc2d5ef23afe8b710db991431094859cdb80cfb873afd91527b5fc9e1f975daf8e6359b8a7658ca274188639a648338183870a3ee16a0d615450580bf4791aaf6a6852c6ceaa4f439df67d68f3cdc2a6d3b3b1adea355b18803df346bab3b10a8d1c039838b4e119b8af0e3e6d8bea7fc7cde5925d13941364d04a138e6d72ed7ec9dbf1d2cf8ae9b10d1bb8328be85a469ece0a8e60aebfd2f0aac789dc251bc4fc435793ec26e2c617331cf42e0b13588927edea423f40c7d173ba3ee38e6f229f39dde0f258f05351f8f416936ce136fe9e3df6b39b018222ce30bbccd2a157a96634a51d6cf26ac84a07646c4c22f66b240c68b2f50a46a6f7c6efef5d6a1ed6ced6ec6847fa5833c7e61a732ddd978244470a32377a79b9036c171ebf2467f6c661acd7a5d0e781717f0a8d64b1e2161dcc6bf299d79cea7f213f1ef7ec6755af328ae8c52e246b80235d53d35d9f2bf76c3e0598bb3d01297490e0ffc78170f668f783eaa763f188e561f558586b8878ed5236c8ebee28eeefd80f0714ddb38d203071fadca04547dac406bdc01063da6ef38bc251c15174176d0ed086419b8fb328f602d0857b21764d346367ded8e94b9a189a492dc748e2bac7cb0de8c9b900f446288bac2eb7041efdc19941f35d66fe0c4686ea2fa94a88ab08e2a31b737f3d3cd25182616fb14905d2f13d7caba4332487e4c741f7743ebe396ff7e45f854d0c39f929afa2e3e1d02a718745ee73b20f4a734fbfa0eb86236cb82650012c97bfaaa2851a538802c86f7e60097ac2b208238c997173037440971ad6e497398f69aaed970712fa6b04647059d8975211fd1f022bfd2de7628c9e9df861799e69e816346e6f8e2fd4aba323c05d572724c8eb6847e1718d2d44543507d79650dae35af3ab261bc02bfa5ee6ee36ac9451dcaa2c7af415b4fe99a08075e8f8327f0d506a0a30cfe4c98d301204f1da8a16ccab81b7c6e474ebf9744398cd4baf66d96cc603b8da55232aeeee5b5da1fb7cb9fe953449e5f99ead2faf43da067d06fc6f754a7aea9e9e95aeafd9aa5a1c84586a2ab179b2b4f53676b6a8d36cb38cac7a2f174e7972ef6cc2d4f109825df3206610f1f8a9f0510554e694ab88ec4bf14999b2e13a5dffff1ac58655fce41e193990ae11ba9bf65614e57c561b65303e73ffd47dec24ae438e814d445baa2b35b13c5003730630fecead6803c02bcfef37b0c84e13f4dcfec91a0167f4647935ca20457c482cad7d512bcaf05b8656fbe1391df53cd4a023a318b27e016f78224f12f843ab46878c9350a908ed58ff3c6193a869b3c12f652ec21882873bf3ce800b1d8c055d0e0b2aeccd1e74b341fa8be08f959b8a388783908c3a2c2cb540d7866ad9272cb2e01b8bdb5239073727466c49837239caf367952ded32b96f8697fc2ba72e95861bdc0e2d0d0257e38d08a7672cb32db65ce254ee61edeb1a9078750f7a8a69334f1e2b98de0e78c01bdf8187a7e96b6366e5d18d1a7d1fe4fa80a925f4b772e799d2506c79c11b9109f5bf67227ad11e7fe1464a0feeae5da1c26e73dde5a328a3da5fed34ec1569d6c82bf2b9316152328e890608c1eb019239e28f0a006c1c954441129ab8a36bff4e90e9a818e2f2af2bb4f787376a00c1886d845a3b781140ea904cbcbf0da533f56bd9fdb5459a26da285eae237521ccf3b066a180de2088ff918c01f16aafcc36d6c22793dad511ecb26647d6e3d7370fd652676f8e9919c00c638890e91ca323d961fb9d766719b45c816c98f17f4ce42026721966f34001d4a2b72be0806ecf02670b98c0c7a5bf5e25580d0d4d42047b6fe295f1beb906dbae7eab1d95066fc7b2d86a4802d88662a81bff54a51a1893729910900b13665d7699ae5808a34c93ed47632b8d916a2703a6f2dc1c8e7ce2de1ba965dfc69771ca7c667dbb3e1f0003a0a45390e6d2c506a24afeb5f4f61d6eaa164a94016fa5ae030fbf09a8a23e7225f5d600d5be9c508a0c7539cd3b937c760ec0d5db836aeda115a3f1f6d781562c38520f8ccfb77243695c12b17f13da99772c2e0eaac1abdcbfa1e7e27f1206c07b5f0751818f5f2f1a199664504e03cb076064ad93e718ce430ff10542224a8062fefebb780a77efc378c4b9fb223ad2366a7d77969a93c732167302799259073ce2c1927b56e395ae3247bb3d7732a52313a2fe44e15f952234efcff148e4f1fdeffbdd6f04c5c6e36036604ef55d19e233a592045d3502fbf77ea1e720975906c4b46eaa47f6b5073655c761bcbcf1721f7bb113b3ed11fe130d62e771179b3be11541315f88f05ba5d9384c52fd60f05e37e71927809500d303201cdc2ecb1efbe7d224e276667e3391a0de157b6779df735a8d9bc6a6c6b3c1d49be46380457a5793208a229af84f984e3a7ac8056a8dad5493dce50a73ba59f4629f2f62ef598853bafdc0a4c092b3c2c18f15e954e93ede93396e3b70a191634ae2958ae5564cf170244fc841f515eb6b416485c9086c3a602407c9b28b73ed47e2321dd51a9be652f195a0b44f936eb116981f8c280d0306c2c085ff5cc35a3bb1dbfa1ecb5f9646bf82ad2faa0dfc25e06b03ad65be613f49e15545cfc0e162dc3b96f006eb2feed2d878c3bf50cd46864fe01fdcaa1c40ca1cfd5c5eb7a6eb9e94420d593163eb1b6054dc5f2cae740868ccdfb08cd6c129b314ddf82b532e83f61cfd413f865a1b1b397cf70704f3af9062051e7ba4240c74167d7f28ee3d22b869a81528e16316864e936b320cf7d858cd4e660299b9c1d5eec7ab8d1cdf9ff9fdd0c8f7b3c04dd6423952f19231b001f96dd804513c119839956e43598ed06c0e7d56612ee2851f1f7e62d202f710f1cc3a51f784262711397a3083ef5c9b2ae9c8d1e47e55edcbaf4d609f54712a4f498f6739196991bc054a1062fb5c0b36bd67bcb0cbd599e5005be7d7686228f58e191b53b98f0015d910f8b2b44a8f7a74296ccecee0b58e341f9ecd1079fe9eb5c1610079ce63f1687f8691b7ff1d53d0f951e3561a2dee55d880d02e42381afcaa0664387400fe57c31854af29dbee62f5fa580887d281c0da90ae6b3a2c46bc69666ebd4ca9b671748f144f9b3c04c7169d58499de4481e56f9884045c5a80bbb29ace52109fe4770839f66b9ebd2cb320d8637b6d58913274ef4d9af97cd8682d731057d70330a3b62782209b668dfd5cbb59f3d771c05478239b330aeac8713bbfcad0274ceb56fe528192f15f1b6ef8955f31ba70e56ccd958ad894e687e5539744fdf0d2869d96dab220bdb4c564ad56aab0335850f7587c6d14da9ac022c0f59e0108ea7fd784fd8edab5de90e8682754e64cff151df48c45ef7aa3b2bd66f0cfef08fd3f8803bb813218751f80fc8cc91ad7e3545022275f22275b422a82b107e887996438e5a8176993ea7afd22bcb5cc9168a37cec664abb6b2b61e1524bbfee7090e24b2d4736261096eae3704d910298acaca635ce0de77664193eb11b1519fb2079c89ca449309c21664f445711fb3fbf3675ad24168b27c219ad3104fe0549f8929d15f89530f50c0f22271003a32834087921117e49d49007bcfe2b61eff1bd0cb4eab4e29b3b326415339f5df888a8770a660cb5555b7a8715575281b39d726791c861435a0ab0f98d9107deaf0318a2a6c40af3a113a748fc8426bbd58b1cb676f148500cce9506ab1394b497674bade84778a9491aaf325db55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
