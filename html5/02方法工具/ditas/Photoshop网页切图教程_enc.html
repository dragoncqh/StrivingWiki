<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30da40ee01a6c87eb73802321e2147e5c13b8a58b75c4a2baf37727b35edd0aaeef2f03c07275470be66a6687de5f27782b69012fec200599205b0bf2e8a64ff69f07c9377e859d8c306bac1123ed596ff22633acb6361ec2dac816a3494cf393c925b0764d1b13ed4fa4f249389ccc09b5eb83309a72a5b239ade91345afb3f95a02d74151ab87d01aa4ff9353b2b3cd3d0c2e732803134a85b9a9714e8f7c9d5ea8c942f94221d58a7d48ffde8ab3de08e14d3cd751ec41de8c28c9c01f7e29e0d42ee839aa740a26adf00890e7f935cf00633c3678a32cff99b6112e19b4bd3c39aed6240b3332cc4868c41d7c0f39202dad607dfe29705a0c65984f08db15a2c51594f6f4efc201613c1e9620e6f0d1c61cbd10d082316ffda78e4fea8366a3f3d7c7b3e83dcc6ce9b1a67f955dde6c22146d8507eea21e3481642d0c6810ce16687f29b0a09d19b3dcf4120b161bea4dca62a737f76678674029fe65808f448c3c93e339753a26e76fa44c680968823ddedb82f0313b678932836702e6a9afa7cd541fbb1333e959fb99ca9fa8e1707fe6ae6fd5f70ebb2aac930812454e854adc9449eee88db79ca394b99afab3d127d875de52773e52cd0ca250e136efb822621acf2567bb1200eb8bd46238675e13050a9cf332b4bb5cd91fc363de6905c027b71e7ba658445db6293bf258ecf88c7b90ab49976a838583691cd9cc053fce992e2afb91d6982722c527d742fa892b9835b4f543a123a5d0dfa5b58ef34ccfe1eeeb81b9a6c1a0272758885bf1501537bc0a25175cd45c913a4f9ee58d6c14e1ae316596fdc736c72655047c456b07f11e8010d08412c3f2a258d09d56c95d1b005c52de2190b64f0c595664b048478c10434295c42c8c8674a16d37c270f4c560f1b102d2cd898d513b60ad1a6fb69fadf0fb821cb84973809f18687982232d49fc20dc5a9578f3f67bb4570e7cc9381fb38b6568443d165121dace55601f145309fa8d43da28af9176580bbff1eae33d56686a53b113485529ec3d29b2f109dc7dab765b5ba0ebe9681794d98838a46f3df9f392c8d344963aa93b495469d1c171eb0d74871715ddae0979602502c051749ceaab84bb89d00abb09f919f850ff4a7ec7f8322d65e5a5ca39b87631dfbb5158f14493cf594c8bcfbe84b1caa1a85d238d60d16640d7051eeb2eef4e26bd6593242b67a76c023995b1aa1d1c3b081600e7872b77ec29cd41a455968b225b21f4987a3cdaf1aec66a026f041bcce4231181c8f8c41c5911cd6004386bfb0864a9b632639abb5ddc9afd6ff34a5558021b0bd82b0aa6b4aacaafc1aebd96b7ad7eaa39a79d2158d878e491d972a32f2ee1911b560e2673b3e7112d45d02ae90cd56455baa3b812c362888e234e602b0c2199df0eee4fde13bfcd87062110a00fe4228ded5be32c56283269958b8c6f20e03f8a46abc36ce673641a5c07a1014e20f3c170a690357220badb0d40605d169d6fb12c0183cc7258478a0b3fc4ce6884d5d33f62a277dd342f4711ff3dafc1365b38b60c1540a4b1f3919a4db88e244d588d91a55d602665ae57a7ffd69bb7eee4dc8fc4cc3ce95581c050b323cb4619af39a1cc42888b98c44642e5e149faf7a84001a6f509b733853cb2a9fd819f4ee6bf8f66813b6e3f708554463b5cbc397d7354a62a57e65fded8d59460160d85c286941339f6245a30afd0f95f9dd1b4620e3ee564538ec6cb3549b3a8f113f4305a5a0ba4af9a24a4221afe00b2cc16bc9978a55a163209ebea40e5d5d270e21b85bcf8e307bab55a15553b9ccc83d9b2905dee17c944df30d9e64b247af1defaa659cdf2d11850e520104e740f6e9c1956aff9dd5c7f29d4c353c9b943cf1ed2dd6f1ab24a5396f0e5ecdb492475c1cef443f24bab48aaaef3f1b46366d3b6cd76a2b73e50761912b3f0fe0ff2c48f7783b13e20751812ac39ce04d9aa12b7f60c9d8d3d4873bed0c9fc7be744ca24b08a0fe0c16b5800afa14cbaf550cdb5ba029da1a7dd605af4e09897051cba71c38d89dfc70fbcffa7f0a9c6dda4c6bf6515dd08bda33d7a16a86469103d52da53b1aa47d07d71b6f1741e8c2b1ee7bd9bdb6fd2f25fc339f33dba4352b509867dc3267f7d2e3f74110e01882501eec3aa0b021a37e8ee3f80ef76a2e61774df38560950cf357457b435deb2088d6247695f1f71d764a16047128fb142dab13087eed4c1117a96cf758d9c87307808f50cc339c7feb971a7067154c29d1c74588bcb2a91a474be59d9ebde04e314c44c75799ceb21a6004210e2281504367a20916970aab934ab58998a1acca887e91d6e306145bd1a63a81c73fc9372c71078d0339fb7116847b1d0495fe0769e8c228f7597d91bfd70afc7a33acb08918de5c8e2c6ad09f6b5b1cefddb9644233372987932ceb28087c5476a27f82d3dfec1bdde3344a4250b74914a73cfe4b6c04260545de3339f0d89bc660ea2e491421af92f2aed6166a73aca102fd9bd9d9b474ac1f333f02d8cd9480d2d15bc7c6983792ed947cf35af24165639dd6533fb3af8d53e06b67fca27ffa61876dd40be9ce402c612583a0dba6c87c96ea337d95cce99d977a7f9f0cd54e5430583eb0f02fc372b9e7ff64694adbb93353ec50a5702197dbb0253e891ad235478ae5e52c3df5b78405cb263c2a774b6d451d6db347b13f255492baecdf922659d3da1fe483704a242bee298ab304be908e8a7e5ece369d16adaed78f5a8c04d1fbaa0df1081e1b32f5eae4998320403d39b8823df41686e50246549ee59c39e21b00469bfb17c95c310e9dd9cc635a2c83cf25ac63955207a4bbf1dee0b00c6f5c8097d92d73fb6ee3d088b8b926b8c4ff7111fab6fcccf5cc1030e0f0d5e26ec46999571477546bf5e5cc86e0f09a82a2926d5f8b5753105336fbe530124e6d23afa94a5896e9d2b37f24bba93acd3293ba30abbec61f379323dc30be8e108a5130c410725e615a4225bbe12dff73f5a94a6f34d0ae5ded04d7bde63630b4ca47dfbeae786ab7eb018463f41d81ccd2f26bffae0f2c6f4f6bb0b0168b156fcfea6daf5b1b7c951948dd369ee81aef975c28ac5b198f3e5fc282f89f52db03640309c9a403e4d859e48fd15c31e55b328c8be4e11540835dc393ff275fe58eb96cbcbc5322e7fe4a0957a08cc938eda39d551dde769d4864be0b00b43cc0a77f5cbd91a2904c46c40a44a03258c0de66ea3b01121562af1a15591d14b1898eafd2b72e850de02dfeb54c9c7f9c84bb5a1c3e4b1da76b26e809b6bdae5dd77b1f6fa29aed4044010c04250e561de62c6ff19dcd5f98c2b186d9e2f43f23d4cce406a18926ad41048e179a4f1d0e372504e3ff86865e28dceae84eb05f1a08e758a33049054549170c58153b8f405c1b80ceba6bad09648ebaf0af55fe59b4c15f8e70558726df53e88506b6bf067d68a4dafe25b1f8b2d856b5b824b5da8ddfe10e281e9ff7da163f310c38011f5e3c3a80aebb537e1594072811da579925612b76ea01bc941cd9c74cab4c687087d0bb7ce5556a1c203152db629ded6d6fb512dd3725cdd574885a5ef803ae6c5883905973bd5cf477ba50e695e555023b3516224907978afc7ad6405423e5b8be5dd84a5ef3665f39adedc31fa73390b25ebb9ba64db741ad4842b13375f41498d00112054c44e7f516558e93ae9c9574e50b0dd9725e6e664eccbfa2a6cf332a4178bb6ed1199a28bc102664810fc15277d6b7387497f3d1b1140b7bef6c43eaeba55460e82a9b211c6e204d90a51e2e7fec6f51e03a75b035bd890412591cef966383c5d383519de608d1229785aac63c42eed237eebd3f1b620666cc590dd59dcdb4a7223cae4df1384da19d6ea6cb0c57dfe3707f5d4c60d4813051489c7b466884c55ce343904a69383c010c261354833b55b45e564145d7255bc81fc20e06a1d0c692e878391a58778733b6defcbd8297d12b563de89de9224565977e4071a935d60bb98cfcba8d083e9db3f624f06b68f24b9949f8ddaa2d400b8c65913f763e8960b1ac20571455a1c541ceb9c8d4148c1108d64ebecb6867bb47794793c57158e0f720e21c78f0a2c65a6ebdfd21a2d3a899a1c0ad5b531cabbfafc9b070f456c8a11b49426c3d90e5aa4f84fad5adea39293e024a7a9c070874458e7cacf9b425b09b54317724012cfce79fe98e1557c97a328807a89e217f8f40956ac267063620b5552d3c4ebe1ed97784801613bedf49d4384c260e59761b8d7326307fbef575d912f7e1d76ffd4d6fa2df450626f9bc8624ed1c8bedaa91b08ce951a82b2cdf3419c8566a5b45bc6b233a5ea6dde18dabf750f6988ca751aed8756f5ab6dd2541ed7493753717064e80dd9fb39f98e57dc15351208d952d517906d582e33c553a26e9fd58daac1d08aac63c172fd38b49aeceb759b5bcfc4ecd45232e6a9ec2978a0db23abc1f3734c91ca2bea0f47872834e2e476eba6c2bd73e2198b41e23c4d71f1e5a76111acb75bf49b50ecd6802500ebb9912487b2549e7b939f4c61962661d3349edba6a10785ad5d417d13f9cfcf89ed4780a318cb0e6c2c7b52dad725c4c4487d61a1504b317693e1bff5168a652f82af73964b1f0fa5c80b8bbcea39a8db69f3bba6620fddcceb0d81241bb5fd9ec191c2ba72309ef1062c46c9301ee67d019768d15744af82bf9f78569a19d9ea5ca92363c3b8b9163a959b70a0481c84dc011e5e26122b7be7bf7f1d65206bc4c81da2d4f1c926934e697a907c458b6a2934cc24108c40bd6cbb183a66e3c3d76539f37220ed27b1d9a7dab2b9af641855f36f0c693da0acff81123e4e0fcd325ebceda41f45a80f0788764db375d2ee4da2de822521037fa738417b8257aa45b30212049f94f5dd5502caaa3b191836ca0b1a7181d76c5f8f91cf1970b19518e80c82d868d597f0169e5cf2df117f783947663d76322eceaaca83d4eccc7ae24757ecbfd35927dc7eefd4c75bd38009701c1e2130a62353e79af487800d365eb19806962d33b47c266200b7ff729e832dceefa46ea633e289997954c27123e83d6d4015027fbb8b3b76cb170bac52dc3c5497a583c94f0ae23b0653ce57804a2ace5145c547c2bd8000336a56ba603ce8e67843005bf7ca86784565bcedad2af92fe6a46d988b3b1995fba1b8da9cd1caa26144f437b80804bb3997bd2de76e3e4fd8482c65d0a92e871a53971e506ee9fcd6c4bdebdc1f47cd3d324e8d21aa65bd02755b82429617d2568e1607b043c59c31cd69a1dc2278a321a50eaf3dafc8e2232329f48ed928df6b9cfdd3257daaadbadb3f74c03a86dcc2c2afe8e8864a52ee5735a507c7e6a361b6c1811964c483b336deed423e400c1e045e021a2ef6adb0fb2a8cd8e8534faef1a8a2ce65e5ab9bfa5ccec937643127e64b00178d2fe735c4c3f79b03cf21d43f041f1529b1dd0d5b9d8bf873714693f7ea21da85832047be2059d06f980b594be9f34cde731a8886208cf1bc6dfd76ef3a8368e28a3eba58deee26a8fcf0b2dbe54ee7b5f9c18d0e54249525bb9dfa0d0b9dc855737030cca6d883450086588159689d1c3e638a4d1be5f90aa0d7bd96fed8ebe4bcbe71cf378d4e217d7930691f67e337024fae58c66faa41797e46c6e10f59e033be893573e4740dff5cc8ff116557e3776307fb1270be44dfdfb73fe86f2a0096aeee3e2bf88f9de8021718d21b63d32ef3aa5ac51a18f16f4bff33f99a1ec1b419f346780a4c8df921d7aeff8b59a86a81a749a8666330d2f80a0a9101ce798c408c4fc50e59906eb7bdd60f790806e9b0d1c37db329713e9def6ca48ac1f757e441b800bd65c96e20a516dc81657ce5bc0e2bb8e5a5995836dbbbb590c89f8a688de3dcdf67d35ad0cb70535a9a14000230063a18923ab23c7059c3116344b90980dc91b79d787ae2511913867a14f884a30a18bf29552c672d0cd2726a07ff8270217aa9fd291c4c6fd5cb20830da0e0fa346ff96e9ba88cefb1567fc5a2f0093ee2732ca4a7dfed402b1781f407ee6b635282ebfec8ffff2299a1db3a22c99e62cfe4b4709194ae0761aebdf28a8fc2490a4456afd0356ab72b1b75159b059ad0aeb882009e88385ec0a3736c6f3e21e42a498998dd7b198fd33491897259df71d729afe23a8f8f9f3b5e426b16f1728e3cabd8ee2d5c5d0afa39234898a41ac60b23e9da4fd8548f62510bf09535921abafa1f642dd9d9713450fd9e0e6289fe4a0514d1adee6e62077c05a0a0b58211181abee917a614eac81d759c1f1bd5baa77a6268e6c78127694efd9b88b0aef4431840283b2278b5cf9969380119e918622f8f1fc9a8eba3a9bcff1361b1a327bd010f9a8d61e4deb417272778701c9eb41168fddaae5be4ef470b4955cf2d21bf20653b7f42c3b261c1d5d685a6491bd72534cb7d089a3f497126d979fce608f9dfd9ee722a30489925e5926057fa1d956f777367eeda7705ecb1e45aa9cda219131a15d532d34ea13f105fb73cfa83242586409329009256d41533dceede9d389e1fcbac8e2f0f2f65fcb327e77bdcb3c4b32645a64bf3235e7122f1583d73fb890e304b733ea8dd755ad3e88db3ce9d72e1c9b7d4e4daf8bc9dda67f24d6203890301abb303f645b74e74fb6e034de9b310d7df72faad33e88eecea97bf5c5b8d323f95b38555d5c706c9d892a65d4faa8e63a0c0450be73af9ef7deac88e8616e6d5a2cea410dcc1a11153682a0b592dd1f9ebf340e92c9eda097459711af036fc6dd839afb0240e901244b5bcabf2edfdd8e058dff241867999cdea16d51624daaaf1629696bbf9ab2dfded11c4e4975230f0f9998885caa5903b90d6496fd1f72aa89482b6dae7b43685c3bde8ef51f362a441fc07a4fd6999562ea0d1f59eda2c1771aa6516ed462c8f0070dba35e218b21dcb8a80feff28e120f5590a8a7d14bbfbe121654a11aea932b0c2b448e24bb4f8af5678a625107a43d7e197b9a77e45423c5e5701ff6330779c005fa342c8e178074089904f2c94eb93b86ff2f38c40e10624d76278287a42889e27e192dd7d9a590251756b0b802db0786472e3ae53d48968da0a4d00912e805a0b170dd62e7aa6e59d3c57922b95fd648a5fa1ac4df0959050cfe88f01d3243ecdd9b0d268a1e14d37d6a03e1eeb7743e6b7587a0ff29ff00be4b514d173cd92149281ade9293b3c48139d6e66d43c024b79f160fce6ed88fc757010d7b874c530d36e5952afcf3a930fd3d995bd3fd068ffafb6567ff0874147207b6551995d33a0a18ca5cb484d6dbee0e70609de970c59a42cbe15388afb74658351ea66f45574eb5984ffebe481daf551532dc48d249203ee58fb0f4613d930572b39098b7efd7e08862ca7b95838ee68aee2c0592b6d59bf9a2c952bca31c7c1a9f76356defe4992446a194357a249144d969f73c4a22bbeefa12057728e066e184fe598c6dad1f8148ca1cfe53b74a355a11a08ee5434df1b77a4bdc40e2080c0cfe861a18649ea6b5cfaef4c958f8c68b062e168f2bd5f53d7f1bb18d0a7a59111317891e2bc53ca63b7417103d253db77b57b7e87eeeab218806db51cd3099bb39d13482e4e8b8291f6887200a071ef45870270cce82a07f624857c3cb7f06fc25c8c19824ee4cbbf8fe59b45cc38d6889b8629f77a54fc56f4b08265c89dfe76dd1d234b3b69a2855ad2673e2ea37fee5d95f4c5bc8b744ac8b885155a0983deb074e79f7fd3a48da8a3409dbe6375c245d90fd0574edb26860517bd8054789fd1b5ccf6b5a2b035820e6fe69402a20d9b0be650e99c62811fe59a254162407ace0f6f038a86d97f34561c01341e4ecf9873cc7f7b44bbbf60d3323401e2e7277e615a45edbdba7bf6fcfda5abffb71d4b2415cb09fde36f20a9d8caff09e99034c755be4ac68efb91f39bb24c7b1276f589eec8b97a3de811e4cd29ba1dcfa70ee6dc0761727b3239faf593ec4a5227e322e7524aefa1cb9cc9ff5a58d5922c1f5a3cd8ca51e67835b9de28725d9a996839e63a53b1261a24cb530d56c67dda6be062bd7b61670f8409f4abd372b4b0c797c7f1d135b78ed21afb8c4b44dd3cb3e14fcf474ea1ddf697a3c677a58250298dbaadc798ba5ef8960a0199e11e838de68c8423e7b7058431e6f0e791a5ff0ad8b3828844b6418c7b7bb802ee27cf9f3bea9a5630782b290278fbd0146fcaade9fbecde317183cee7fb130e7bb905bed582c7cbb0dac45d307b76d6c00c5cbfccd2305935f5f4f5c0239d4a4826c696d3f1589427c03563b8f099036a175cfaa749e9711811146054285107c7d94afb8bd79b23a1d7b9bceb583befc6af7add230bbbb5c5486f67aa46f5e470251346223069a1a7ac8a37474c9a783450fd7b8a0bbb04a23f6d53ed544b1956c2fc1b0dbbfc3d9f8b62e2beb171060aad47bb7eea53512eba0d9c7981ab417499efd67cc3ca346e3f37fcf93dbb462c342e4621b933f32b84f56806d284df43e25687fd2c64cb1b45fc276a4dd1e619a80a1f26a58eebdf72da5a68110a756c24cb879ad1fcb599b80d7bf745d0c74297fa3ea04d5273e3b48e4b6f05d84d1647426038f37877a65647f6b60c6627504a0e5b3a7d089b5e6150cbbd24b337b43dd6037a8f5cb7b25d6814bdfb2e4f089d0d1fc07c5273b05be666f2457be0b00fb24e417c579de0507dd663a7760da87d0dee7a9f71b9415b6ec654655b011e87bfd10b266374e8afd010746304769f9dcdfb3d886c21bf36a683bd853f8d6c47e6746d5775745989bf94cea586437a75728c5a03ac67f424cb717e7e18c024824d7547dbb019b4c36eda03ae409c523f527657e17a5cdd0073c8595a8d6e7a331eb3607fd39f41bd3600d8ffdf9e94d27b29d2b6d0470ef91297acaf7ba790de0900a19f0e26d88d5518e20a8752deca82784bedfaa259c14de4f3a63d4cd152139e990ff7ada05cc50e6393022f1d7b4bda999d18c8e274d74b361a9733ea96f6566033546b41757628dba95c56266c3d8d5e9b6536956025b041f14ea2c95f1854a25dd41decffc6ee09c0baf6eba54a9e4ce826492d894a7909269ac0adcd516858db966491d2593a44230a0e7a3fae2ccf56d6aa73d42d2c3664fa9c28046a9e477d0bc28e149e0783ac55c22f6929af6bb339bdb76556fe858cbcae4009629a6e604e8e7ab601c9107ed2b6f1a57c8425c03b1a9a5333f3e4fa35a90e8f01e9b011b0e6645256a1c23a2b91ea1387a96c30799447db7db7de02549da0d15f01b0b6aaba7e14df01f2af713949ea8c0511129db7308085c19e2ad2d4046db3f9c3405d8dd227ebfdde60598faf38e14617de08b672aef736801464f224aa297a9865b01a7a164333371ee569eca4deedf9d3f7423137594d092042e11d2395aba20cc4256bf7be384d2172e66f8532fbc9fb51118d716d1d57fe837ed0a5dae05d336c8de82e9244ea9d168eca2fdcae19f27ee66d8550f573b27cc98a4d87c867415928be2dca24a0086abe5b2ff93ff30c35d24c224ff992b3b6100ef44a82aa422d7d432364d822734f34616201cd977dea2f1460416e0085198ab5e2b1bc01eac55dd9e9bb336aeb08044a56abcae474ce16196bb57a82bca3111525f5c62519f98e89c23fad78d7e844688eda4d89e1e58fc42f79bbe51da81969610b9ad2ca572bacd6271a35e5ec37eb8ac61ec40e350063b954e9950ed510f1ee5ec72ced7f4f6598f5a28fdf0ee814d3c8d8ad4e64e5a33dcb7c0af6e565384ddaa5fe2917c7cc65cd30d1183da3e272ca483ec6b7cc63c63e35970ec93409470d2dc5e67579fd490f321d95feb31d79f247b213ef03bfaa239f10fabd3f4f275c95d39fa9a8f10a1c0242197d08df94d4f85700a37240021c8feef9b6c23cf9926f8cd62a142092affd2f19b4ddf902e93a0875b0db203f06afa07fba4e1fcec7fbb11916468fc482c1424497a9fa4bb2c093ba2562c1ca7123d92ee91ce46d65ea7d2e89ab1b34b77ef9e53d75c0e15393e4532ff491f1f9117962a235562b943a28547c28b2ce50146035e1194d91fa4a287e9569b3d311e4b8c17cee5c3705c53330724a1b2b09b991d05873cb144f15a304ec2b281845e6c1053de7d4740df6e84755d599927ecf43e795d3b02a91ecf47020b7f51b176d2ac654dd1cfae4cb993da7c4760224e564d6dd77518d83814ca6be27bed6f398001a77b5a3258957099621873d16c2b5d08c72051d71a16b4ec0bb727c49aa2a8475863baef596487a1c02172f673a5c1ed3fb5b60d7982fff3d037dd8f17722dda09472a1cd8f456c81c4ee24753f0bbb040a622bed12c5dbb3f401e73857f4cf422035e549205a9a37a52ffd8dbafd522a2d2eb727448b6909b6823fd9bc992499e26db539ed523bf428f78208eb6d12179bfdbb1d8cd401970a5f09d8fab2b9431c18efec920fac4f03bbed79f043338126642f9297ab99abd969788937256e98e106411c921b7fd924dfdfdf8784bbf8ead57ebc1431b7ee27745abfb43bd2cbcb954523c156090e648e381bc80c8dab0f11ab81db275ff69a4cec5ec14208c49bf15daa0a25e3a0e43d5ba64eb3c53611d5d82ecff4b10532357921d58c3edf400ec863df263c62b225a7a3f2bfb86b6bd00cf30af1b0f09c3db078e39095e47543f95f366a4a6b11b6710eeb472063c56dfba5b27b7e77066d399fa07e983100a56b0bb73147a6b6495bebe0f1f5941a8011c0cd4688cd95aa43ce438c0a3164b17132f1f3563b8f4279082cbda521182993c013e84f19c9c9dd196211d4b5963c3080ff11bf945456cc43cfbfdc53c7e0c04560c09dbd1459aa552f1dd399173f916bcfdb70460ccad57927c9e5763ec1f2481899815407fbdd5ed5d56cea3dce96a3724fd73b37b4bacda0d9565af883a841ef80bca1283e021aef31bec5e5d8984b4dc3141eb584dc3c472aead6057b122c7ad7f3cbe9198c4e74fc101802ca68cd8af615d23fba5c200fcb959a0c62cc87ebd276cb3ad04dd626536cdbbda901c9cd97b1d7627f206a9c11b04ae0fcd7d4307ac96d900a9703b6697a7a00226dabfdac1207c938075a50c9b57170bfd26fe137ccdab55247a08d61d5173d4f59b2a11ac9b7dab59d5318d7fa77d57ddb7b55381904ad00b1f4313b24c0da3b9bce84a271b3a003ac75a27039dcda804a89ca9f8fe170c85d15bdf40ffb1230615df87f199bf4c8439b222980acc82c75b2b54eef0548035b925ca7b0c2e61d96615c04eaae7f71889e88e54d83838df3d42e25cb392971e5e03ea088b5af11d4d764fc05d4192bb078c656ae7827201c2b75e02faae3dc0f67d1bcdbc905145c5cb6237bd2559af9a80677d9cba87c0552dad65a439ac758dda63d29c5a31f4dcdda2371f0bfe0df60edc258f328857dfc3acee63e7632f8a6557c327e7cc32e7edfcd3851fe0328e86e8b207e9f1492e8b717bd8db216c6a5efe336a9c4336189e647166be6b69bb7065e7757bd1c65f3f7766de1418adb5d142720d0fb5ae86f2b312249f986b12ad04c3d005272a592d57381a92eebedef1a0e4a7898e3289e816e5fbe6ec5c6e2c2929a5cb29f8dddb89923a78f58339e5c88590b9a603e2350132eb29a377af45b81fa804f18ac6233ad0849c2f90c19e192c0e8488a32edd674b6e9d426d2efaf836b0a72de50a94668c480df4f0c3789435f016475df1216d242b21ebfe2cf1a3cd89c1ab6b6a82886d757f3532da86de78c90ad2ce5c830c2d2a9eebd9d4cadf237ab04fa92ca0341c068809b699751b9dcff32aa25a1b7f29b166f848bcca5dcdbee4f41d1cb913669b4e901b542086c7c93828f0bf2c7f2dcaa4dc3b395483a6d215c6cebacc4132605f75fe139fb9b641b006f381b9c36484c8f9a48cd2c88e23e72548b08bddb18db3f457cb6d19dfc2d73a8c39d9946a75a70afa30beb7446ace0752d1f149eca6f53b01b036ca3faeb024fb58d173dd1e3266857eae6dc22e0d88042d1458338ebf5eacac3e91fe59a3026ee7c89e69992fb791d7c69560905b1b26044e620cc8dd2128fde17307fb8e651fbb24d4348ac0ceb5a820522f2ceaaad6da1edd2d35086b05a0e7c2ecf083810661939e2d5247c09592a1b12d336702fece89d5e72bbf966a35f1827dca9bcc9b41ce20cc27f9d57f9afcf9da318ef78937afc2d9d0404d58ea0b35b628291b1d2c0b5bb2dec72d1105acac9794dc13de63577a3d852998b26b4de52023e46ec3c5a0581a808b7cd0809641cb2ff603f8b1b263cf3795b8f84083375ea2a76eb3a874fd9221a07cce709e64b1be0f6cfb7cb9d3c5129a9e5fcd7374ca51698cf05c78191a59d0a1a6875fd8b020b6bbdd4147b29a30dd2de96d8dcf8202fe7cc35d939f015e74a869a45bce6f578a0654e832a41e69fe9b08926bbf40d711b3f8cc24e6cdb0130b337884d37cb24595ef56c881eac9f596185d38249d19e3ff56873ae8e0c6e06645bc6431bd8f8566ed3946e9c8605489e33cbc9f2eccd7ccb8c7443dc49bea1583e245d9a23e68139e73204d745f60789bac666ac58d1f5fa6511789bf9eadf1c29f63697f82d16dfcb390e81b5d8f2a1abadfbe27f2fb0d8590dbbaef8caa951076f8e12e4aa085fcfc456349e01c729b96f7e01f2d737942b32d65d1d4e26f3ac6ba5a48da8cecfd956a69ef262985dbf9fbaa665770e8e656bc230c266989380826df4a492e149cb0111d5f66ad117e4e3ad3ef1116833ee49f70e4a31606d63f56193fcd4ec724b08c60cda7d0bd233eae21c0563a7dd876544d0b3acf8eb4543e5608c3bf101bb397788cc3d51d34edb5b7ee91bd6275f18e1aa9172ec49990f10d6106b2315533ead04de0f68a328e477bf1540e7cad0a6cae90690fac0746769ee94ec4f379ea458bdd150ee1ae72436041cfbf266f6ad9dd0d7a50b5a90756c0e58713598864ac14cd719121c11149809a0f6e2abb749d72edd6feb88d56c1f3d187c4219cf5f0876d6800fefadc04bfc7dc8b7364ef08dc5bc06428ab2463b8912f755978663b8ed256421bb0121af12a2ceb865408816ddce03fb78df727bcbbf8da1271cc90ee6d5593a8bd0637102038fb2bf272b0d154a3f87cf09146ab9f0b4b64a4ce14e5f6c55b8cf81e189eabdf735515ec4ec1f8b39a7d0af3699972255ce4330e3b4910ccdd0318894cd0c78f3c7a8a368970ae95ed6e390cbda6b8f8118381262f087e63e2e0c5e17230e18b4010a21ee65f2d92b06d640aaf44aa735b96968e6eec3fbd4ee8036448790c970484fdb6b71029c4f41afcb6db7a962a1e9e3536e4e18c62fb24cdf8288af48a87137bb9bc4f3e70362db4529c6a8438a7f8a75af96360f82e1d5e5ee4f9de670335314ef49b5bcc8183a51f1ce27abc0152224377d939d2e9bc83868f9a1899953ac2a16bec5de52bdb4eb6934153cd3b2d66005c62f3477dd0642c26f31c8a79b99c1e27967d9a805fc1dc9cd3f308810392e0d6d5b29fc607e04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
