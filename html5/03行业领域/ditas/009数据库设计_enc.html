<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1dbd888a37fd6088746e61315647485159afe98e9cd39c04f8834796d45aa6f652099671ecf3486bd525ccad416145f6f4e65e6c9474bd62746ec9a6b1500efea618ef3b17174792a68755dc5b922fdd5fac3003d54efb70f386780c302c79baf55dcf7f11e2e4e070754f45fb7e9a53b2234b7dabf49da10f571d7940b4b91f6ebc957ef19799e8ae9b96a978c5d3de6527afb7986d62e22b0f3356ec7840c114fb9d4ab6aa8885a594a3fbbbc974a272bada0d931ef3faf260b0d09de7fe55297cc2c9ceb896ed41a7597fbdb93f6394c704100325c7c5e31aee9232c974d247af25af3e16926d4d4d74685948b1a1703d01a7bec600839be92264e54db54c1118f527cbaa051a1090d2649ff44256e3634a1fb3e7774c3036ff6a02f766cc49dde8bf25a092b4c6f39e8216d41965760ab9e3a16c23c5a203561f143a8f8a1150dab8b23dce5db7945fabc289c334b0afd386d8550053aaf507694ac47f6760ea073b3eb095505b6fdb10ad8b6a165cf12f889a4962c9f4a5f0cff55c4531123269201b4064a25ccc13cd6e9c9515ac3877d5392325d668976d53e7f41aaf14ce2b6f563e6c398efb146cfc085a556c74a14ac3fb1414cd9d316b459558084b2f0a31ac55ecffb13e595cb0a1ca97383216bc8ee58cfca1a1d0ead71908df5cab4d6f0ed4b48f723ba879316c007c5ee6ab7933e444b6cbb757de514a3710bb5082aa393d624a509b826af975afa2f75542f1ca2b46b0b63d46ab48c09b24281728cb92622a579852da315b2c3872856e468580b9b69d8f200a262d2da77c90c286794f0f5169fa2cc6c5ec85654b492ab2209704d748a11fe778321ac5488d3e9a0fd6e6659d71efdc4f38801fccabcf47aeaf2141c31ff717183ca5aefcc0133a2a451896c3a5ded3da5c724ae19e11643899fc39fc20bccc6f0e785418c87190022ec226a2183bb66232d0dca03fb3cfa5b9c22a8075e303494c85043b47733b72bfc211cde49165c7dbff69a031a7452059908b1f963fa9d3f9ba747d0746b23b4f8b63cb4169d528a5f4f2b77a684ba5947dcf773b5eebcfa7420de4e4d92f65d7e476018c98a2cd00d4c406e0582a0dda6779ac48ed98f9a8bd9f751f0a818274fcd64fab587994ed1acbeb20c499df242bd5bd09f173703a79a708d461e77b9e80800f20dedbe941be5e4373b1777d837fed21f44d3841c36251a464e316d0829a8c0d7d03807415278fe19db1dfcd52892a68baa92a27a3418d80b022e74d0e5ba6fee32a7997c89fb9a11a454c22e63bd8391650292fce763f8d99d27a547402d0ab2e56e5d6f276eca62a83b9c4746b5971c3a1641c7b51cd33e5e618ac28e029783852d892ad5754029a5d828390d1cfaea80593e13badc89aba5a1413fc03e6cfb3709315701368eba3c20c2c7b07b5cd181986d51c426281fbeb3e932500201304341173265339b7d5c1af2c95e6224272fa7ccc67138dbf83cc6597a16efe0fc6de681f5407e14d9fe04419e7e06c7457b37286101c59413c6abbf1c9b5fab12a39a2a1b1a085d4884a5054b0c78005147a3b24e592ee827175078fc13036a8ad2450c33aa5da120f77607704e766d0a235f8957ff36b460cb89bbb03d80262e9242cdb89d15f9e2f49e653d0aea65ea1d6ac657ce3aeeadab987f44df744f55ec329f2ff2c221e5a3fea0848d3bf042fe36bf29afef20f5ec3877064fa4c928eabaab554c7deb18d1ec8c34c4b0c7881b02b99a97a2128e272b12457edfab4f3a9b54b1c5868bfc47da5cfb8cad0f7dc6c43a051c3d5b454a9657aa52745146a3ba2b5cce8e77a081af5ada34882d4beb3657822dc2db9c4eb05ef800b368a492120cdbc40bd7f5eb12aab2e6747f7596068b6150f538582a81b7322fa333888769d6b0c33ec425c921f28cb43ba99aa758443faf579853e944fb7eea20b8d53742ebb07efee9ece35f669eb56e287510525532faac29aee70f48f07c598eaa7671706ad9d07ef3cc2aeeef66f11f0b039a49028edf29233cfd806a48bcd47f0e9f2e43c876c77e06450603e0cdcd2eca1a7df7fed15d957fdce0cf58c32c8563e7a84ff641f9ff7c91682d12d528d950dfb191791bd6b6179a9329d1dea7b56c143cdfe65123412681df7e4e5f941cebfe02d63526d2aa6cade9af79ad9a7e681078b1955f3f96d66c2fca665908591c8e9b98e300bab10575b4e4b1213c332adb2f62343fc675108cd7ba2a25165fa9ac0c1fdcb1506904d388aeb88902c64158eab193f29229571e68d1082e71bae6f36d1774c88828e24ebb037c3780c74e9d06286cafa3e8b24c47ab57170af69d7344d2c31b526c06429e0f1b5b0722400440c2e65f32674f960c131f8063af53b33f46985959b0082edb9e67692dc1de2f1d03ba7d8a8385a3707e7c02d5ba990f6dba452a4197f89c74f2b525bf1bfee3df3239093910b58e825825f1bebba3e404d3a4c72032b3db15506e114f453717edf8f66479be156084aa050ac14ff790bd3a861eb35d7d7362a4854db264ec3337ad1db75384a00aa50f02e71c833a397cabdfd51e685d63d9a0463c7545df24da0ce6d0173cd92d158f0e4a9af14c67528707e975d9c9bdc257cfbb32afd67346bdd9052201ede696fb136b37f99b61a939dc3a20604e7f16999c6c75215944fe05364e0d7eabecabb4d8b980f70b084b17a0b407b83d8227d73e812642e58327c7826dc96f0f37d6996f5260b078f0a707d6ffdeb4ac6e71c9376b9e1fa425ab222118d51b91c52cb5d1506e809c43c8b8b2d034e9e4152f8477d507c0b3828085290f5793ea4399204f269f3addd04f68db3d253b7d4ebed3689679a8c78a93c365ae4f64473b1a998bdc15da43fdb594d690c7666c5c978b97e352307b5d792cc3ce3f4ae842af336ede148c3d9bed43b7becf098f3d7b96fad07d153669f389f5230a3bf703cd3d928ba380954d996ff10f7380005462f35e2c644d8a80d839cd4313bb621477da1cff6eeef59160d2cfa7c734b14b2991ca6137596e50ca7f0a56cafe3eabb36678e902554cfce532ef852099756a8825c189b3fe4cab44d5eac8f2c8bbe0d9a2985c431274109fe4a73a6f9b6b4eba42d7e5a0269e68c39fe66ee35337de2f22b248975abf8077f8d62b1b3f4baa738db87baf120dc1ecf2ff0f6aa9000d77edb9d6006b5fa35c3821536efb150510e1fb60fb819b6cc347c6262e4931a437c9e21b2d6a4d9c365d33e5a0723e66419b6b6f5dc367dd7dc0447489e6ce8879b59fe9fb574c204e9216c629ea2733e098167dc826ae6889a3d0a773e110593c2b1c9f2f4dbceaa95b99577f66e47f3716343b98e968acb648d39f4d22a55676b50cc6d93ce6d3c9f35d900e4b2306ad53cc02aee27c249ef062ec5e4aab939895ba4387558604b9e6d39b39cdbdadb2100e85acc1f9dfd9aa878d227d535cae3a6c856f58a630983629fc0deafb13c29eb030102eb834464e11bdb37afce7fec94593b8890424141a448c4a6018a029053820fecb4e2b2b8ce8153e3856a0a8a3956cbdf400e0bf079a4d97cd669a7b4658a708807453b649bbbfd3ca1373208d3812d817ae4015e4e0517c66198c52e21315012240a6a1e7bdffea2b83c067abf7121879264f8a80f8f452f4ab5d2f29dfc0bd5839c73dc3cfedf26c770e6c07516f3649e5f20921c8f51a1e5b11f9dd7a79b9e81102d7a99db54e68f57c3c5aa2d122d9a7492753253ccba1d1454b5969213db72a87f91ba994c764f36dde844c3593fa393461b61653f5bc8663a4bc5ca25758fec442c973cd317ba5f09bda403ac89e813a527982c612ccee2cafb5398214f8592baa4702cca4aaab438c64b7acda855aea3f4c8ad9e86d7be0475371aab2b5adba18499d6a345a67cc5ac41bd8d72f71f357dad164cafbaf83fc318b1e9a04651cad32a3cc26bb1172d301ddc3e6fe1e607eed6ba97fe1247d367d9963aa72de274b19970220c7cda26ee7ebf351fbd8c16b96c0deb1757ac47d70daefbcf9b809fe03adebaacbbc11938e759086e195dfbf2872457730cd2bcb1c853e5426d4589603062e021e11fe33cf2bdc98e3c419654ff5b2080806409c1794860eece5fc3d54374cb998beceb4abc719f3535d531ef0956f74bc3c1b586bad15e7ea21603503e6ef41843642e315a873bfc0583924594eeffcaf36be6be5ea36ca7d4502a8403cf2b0a285cc772b89062dd169edc7b2fcbd7f414585ee3037db360f4a11e53f8d6fe8d6f04cb10ed327579aad95b49bd32e0e4609077b493be13d267ef0b4558b0d61cf70f1d11ca12edc8f516bc221ab689f0c3a04f934c63641f626b30abdbea53b8e598bd1e2b2a26e022c9621ad4ef420d108815360324b022d46a94476b5f49cf6bf9c3230f1cc8e55e248f1239bbc4a686853640d42f753b68cc530b2e036833eae2d6ab0c93b23de9a6d36e5e18db9bc582cb6d99d5395e54c1ac11978f0076fce0e160a4d924dd74689012216e7d0e01fd519ffa35d49e7aba050642cd39002079e041b047ab85a1d517bf959bc9c9c981da935291761b7c82ad892ff085b538f18c6fa84046d6c7db9678cecd258c32855a7582a4353bdc32e6570d7d3dddd453c1934b66f3f07bf697b8cb5a76f2dd3536f56ae27cc901b0d923cc7a22e3c7286db04427b46fb0b0bc00ad204275ac0a8c550259287b6b4e8fab9a0916e3f42a3f8b7841161cb856c17091bb39a2f0b30770ec2b030c515fd34e9680c299a1a88ae9d0dcf4dd3ff4b798e38483af0adc396a77f9cf2a0d01274f18508a5a80ac058b47506c01c619db8a6f835fd8ed0067f9393bd22da8efb930d98e28bcb68a013756ca04af2f2d15677852fb773ae928e4c0a51fe0f495bee31bc6d1bfdc65197066ad0c3c5fe9e962932fa04d71a332bdca081a40e7463d6162f10691d51058b0ffa4ab04cd07ad4614491beb6af9252be2efed7e4de5e2b0bc09079af44a6b47c413dc477b8ed0b9a95adef2eb1e75b51946ec07b8c6fd386a1f6d2c8ba46dde7bf833b9e59e85fd0e2d5b4b32fd8d8d7438a4e00614716483b430fc7756ada07772562b0bd8eac900792cdb1c01be01ece4a3a90a8ef965c2e2bbbd32894f309e3cc6b16721141989385ce892932f2cd35262eceeb20967f285d8649c41741e4257246f88a4e4e55104350d4ace1e81827638e9769cd330b87e999735ea5bf806ab80dc25a3b2d9f31ee76ac4ec137d21279fe236debddb74063c63d4c3d4b51186670b67ee443a678555a3db7b11a77445621705e03b49e4d7055cd5fb5a16808bf92f6895f38fe5d427fdf6c2e3c56cb0d97ec8cf9d6d08ecfecaa771be049bd7e8b51867e673f3d49044ced1917aed20362a443fa111898a23535d61b51688a91a9caf5f10f79e077f99214c88129d6b877aedb7cf1ab8c2df86794c62d3aca3db05cb68bc5999d217c8823d74d9a83ec7638c818dc00648fe40e76f11991bf66ff630b04c3c7271a4e8b99cf94f58e7e3be6a5e21f98c34df836402c5307b1b051ba9714b99c1ab49b2760d7108b4802b5e4209ea61a0c5040399eb4b7d0a3f7962102d3614c727f4b6e731bb8c267fbaefbe5c6d513dbd60e78b535f22626d0bf80f78b332b23e68e6c5670f7096a5d07e7ffb09c9cf546a3cceb69833d5df860999b6446425480c18d5fae94228da6a893bf3e5841d1d08e4bb33a1759992acd14a1470e97d11be2babc8ebd0628ed30ff205eb7cd9200b19dd4ec5b19199a445a9e137ac2ad6c78500a2f0eb94c66556bf2de773151bc93defdd761fc2f0cd1733de121f944ed20c5f2a6239dc991d937c6d329d44cd8170678dc46605ef0c910e2abbad6550f6512a08cb753eed1d77fa279fda10dfee4b46ab71412c3d073ccc6805146ec69d672035c87cf1a2be083059d03b90ecf097f61c1d974c46b9793e76fe99d58357c85bd5a114467d5ccbac8cafdf3b792c7b3e5cd2c45f9d209831847dc22cd49583fb61180f74398c325a49ee539a1c948ccd429f65fa11b98a2b9fc03a493f517734985bbb725bd4495708be466cfba1df89d96004101e93b105a9c42ad0a32319e0bc8b803fe1034c9bad50520b9c031ddd2cfe347409dde09f712691b79f866729d5f014e28c0146102bc87437b1cf86c3da2032c7a0a8d6a650d89f16a4c0235d2e39a312f97357274b9d0514936833d354e83ddbf5e328818659571e998dffef6cf60a1d7f315af1f5388e3eddd1deb9dc2d161f4c6b27d098a5439a7cb74e0503ed6e017acb26aff5d932b60ff37dd6b4718bc2b22b04bb11d929bcc0c028a9b497a44a0c4c93d1189dbede6ae04c5cc355a1d4fe6bfbe79a62cb40b8f395c86be553dcb9d30e9814bb0fc3430d6856fee31323b2d010da9877646a95b7763a4826b34e9ecc87a440e5484273541d0eff1e0cf71960398af4c89d6625ffc6a931b5ace2ad7110f2f9c37b87ce9e35064c42ff0ca5f6e6eb11208d3906dfd43441621d7d29009ae679e05092f6e8d3a18c2d2e3fc0ba2193092ddde5ac6fa5d08dbb381f5ef0534c490648574946a9ed1c5e17e69d5961d396f72ffc0f815f6f29ee3b68060f7c151f62b41409b6d47b5505e4611d40d22f09d6a48d37cc9e5e99dc29f6bd97603cd99401c6ca87a15d11a24dc06090425e962c53491c49a2cca7f277316ca01ac715585166a99afb2b741fd76068216bfc7f556f44c26a11214b55d16640894b78fcaeb5da6da0d3ee881c42fa8b87423836067a91feeee3446b20a0985acdc7912231c709e28e1519ffb8b9cdbe1812537c985018958a4045b26403b42f38e2d1f416de73e9843ba00f62d25dc6a1b27a8e075c79251c1b2540d7b172f7fccd3bed9fb6513406ac675ba2dc6e1e397bc62ef562aa8985482b16d37a828441ae5731dfaa87cd43057ec4ec77e372a0f0b2306bd84daff40037ce39ee03bd5503a227efdd3b8499b8193c9d931b7739ec4c9c120df8d0bbfa892ac2c0b1eed89c0fa5d8e5c7aec9e0cead3a7644eac5ea8d1a511d86cc1c1b94542aaefdf7be500c23f8c1e0eb8ccaf6995969e9b503e1f0df88bff4dbd2747341cbc6b4e4eef66e6cf82a52c80ce515fce4b35847241d1ac996fff76036a61e3b1a75295dc80309e07d30fe8c47c8ee1c6193c3d327f6d025003ae223f18499b5d978e1b64c50cd1f6bbaa555699885295fceaf36a45a6b05c7f8e17116408962b36ecd1ba56a4194e07b65d78a631fd52f60d7935e761aa81df001d8933273744759c3741ada10f16da9630be8968899ef7d3477b411f1867f693b0702e5c0f78cf3c7bab26bfc578b6a84f4523f74dd5c28d7b0c630936936903167e541e7c21ea139b93fdee5681b905363c7d38bc860e4cc7017c94500a3bb6fd701607323a78c0033de63c951bf6b70e83a38c4a123b1e79287d0c15274cf7a01da22ea3e599ce4954cea84a70d316003bfac40a93941a88cd8cfb0ea5f0aaa7f4c50808eb8efa59783ce178d7f8c881b41539ef7d3cc16e338be380f98e40e9541625aee812c0b80a31423c9bf7e8194593287d91b960525f3017ad01a70ee4a678fb55cf6958a96539377682b77f8f8700010ce7c770844205a19aa2792f25dcebfe07e6e9662974854949530b49ec88549a369b70acae431f55207491492f91882bc1e1f0d788e701583fb9699c557de7039830ee451d4bb4fab6e066ff61796208a7bd475592eca2a550f3811e067bbbde2cf09ad74b04639db60dddc5863f8f76a8071ed705a3f4a58288691595ab414446e3450dc1249511ce7f38a4e825b14f9f2ed5a786a816cfe795e7be24585f9918249ae46956d1bca28ad8eb51cc76fd93f8fc46aef40fb3685ae9f8c582a5f370ec786ea6b9fe998bcc7d50d1b3a62cd67413ff8f46577c369aa9e24482de48edb16ca4c4e55db3d8d34bbff871e2ae59accd619b5323da3560d6572ce57106ad71a24868f94439b77a1c7554122d6e219c582c07198e39ad0c311f48db709665f060162bc33a16789b7b555af2841ce574f544b909212befc0a577aa817eae9699186fdb50537dd96735bb4a4fd79552ef1b76927e9a7a86abb6bf97e10c2ff04e312d88024ebb20edb46db208936a1512504fdf55bfe428a51a08f23294fda8baf1ee1b27deddaa37a03d4fee4750b4519a530d723eee169f8ea1245bd205166a1fc17280140007861082ced5365385befac7cd144a384fbf913293a490808ec3598e47f10ce96a2a9d43fb17fd707e051f5044797acd3be0ec34f04d990de2d707b715176e2ff809505d0eb24bed6ec6dc7fa2454f4cfade46bc788a55a403cc0f2fac48f0c02c083a6a2d7b52c3bc31e7869fef5f67e0f41b03864e96a861b5858472f6fe91abc9118531cad37628cf2411ff9794a0658cd69c2041653a10897c342b3eb8cd1ee5667f34e8971de81932e32fe0e065d4e3fb719209b25759f7a1fc1d7e588d32e3a1ebd77c43cc63e20a2447417c1965145689f9995d643de4935761e1867f1eafd8268390a5003de20d150b9fd95616c953504c6ce9b2e0c23da30761705bde756a2fe7e40ff14533c010769c74175be9daf463c79f02ea850344fe31d2e4d3fa3c1993b927d3667e7afb6d4119e5e080787069fe3f99ed6657b095465ecd9d4a7d75e4cdbc01c7386d2867b392f6f60fd201808bd1c450c49103c2b154ead4737a74e5a76c605dc8646b2367f315879dacdceba013e9929c7ec5873469cc779f039b8e1f650f0d5c15ffdb65abc0482a1b5d36c3e61bba473c8ec39079d5f5579ccdf4b5807657c702ff77aab169c59d7c8740df1883a19e67c7c55c95ce5f24593d584d332034e1993673eb703742e21311cf1d2826fc8bd3c110bc7e104925b08339e729a158adf0dd3c5531daa324018fe689a565c94255bd116ff3941fa8d1382c30f7e6a77f49c8e1701a483f8463d262b9592ef1ad1a152bf62da068d55fa013fd912098e015ffb820d3bdf8926f128fe9929a29b1923c3fc1f6217b26a94a4b633d28625588d491ebcb5b5140300e350c2794855172f41349c88af4a693791a1e732d89f5956bc2e31f61912d2f557ddb0aa9ff20341516c5a06a23b3d4840dfdf88d86e36e961beea36790f5333fc736c0dc2535546e562952941289f90b05fb19f259daa401f4b4901d0b5fe986c69b10a4b04c700b2464720c6384d43b712c3b142c14786030d1a16a9f9fb18e2ef1d735d49277c0125ac1b23aadef14eb35f2820f80d6aa0bd4bd29cb1a7cf8f2ffbe531852e65390719881d4d59c756d69e57fa536b3bd46b609453fcb0de886c5dbaae407a191cffbebdd1048edc09e24c5208962199aaf71ad174d0b12544eaa9897b09d8c84f8308c70d764a55ef47cb674fa3632f6e2f0c69bc2323f00fdc6dd4d190ef997b343b90a8143e4d3493c6f49de9a2276f22208c40d2ae835cbaa078ac73becfc3026ed1e61f9ef7bf888ffa2852b6985b95832ec3970dd267fbc081646f8e139e56e810a19d3b97866add710c8ab8e14989a1bf41f7d13f4d6cde7b263f43ab4635986e76c16756c064511176a00ba7353b0f0fb7b697b3d9a43e47e0a7efc670c5ea5125dbfb19c449e58e0b079e169762976d0fd546ed9de8a43be99669c0f878c8a26c3a654ceff89839d444cdb8d82ec576583c81c62e0ff84477790064bb07dc4185d371dc47f600443e230c5fb48b60f868a50dc51bc565760f85ed9004ecbb8a346cb8ddcc3f747370bc68fd93b0659a345c8017474d9d9c2f648553e9442065c4d36fc55edb284277ca299949ea38c6a42a0b1d624728a714696efafb3d9d511619ff90942e7330f7c2f9e513428753ffe994920a8b74ed0b961393ddc00d650f853531cf0977718e1e3a62227f30a98c0d9a651858dc96b6a9604024fdc9ee674d2597c47a55296643966f3786c298fa1c875d98ed2599376b87b40d90480fceffa729b84bf887fdd4a77659fd88810928af8e53cd30deeb5557af6716eb6093ea8460b9b737bd6b68672eee9e9f5cff241ec00283c8032996da7586ad04053f32f5cb698af11d8107c5b03a0f6ab661948d29e2022adb3dff83455f2c090f5baf8c51e131681f43d6215355079008771a41647ea5335d0e09e32581dcb436ead58523274353e7f1636fd57895a5600f485ef787e5668e94c22ba42acad342f9505919e3f5fea9caac93fd60b2758f5043da1b5f2cf0007c3e285e51235c41d0945d8bce0e03dc6068933e360cf0d31ce57addd1cac4213d27f6cc3c6cc97803157dd55956ff665499ec4426ccb4dc0d951f6efa42ddf3f9e658befa1af2cd5c48d31bac9218cae945a302f3112f6bf8121d3ca241cf659d4cbd58054e26d4326a8ebae6fff307fae0900bdc9b5909351aa51eba414a174b01d3072a122d81fe9eb043cdab28e74619a44fa8c4a55f4d56a3e4ee48f10673483919e02409b6f5167888237e8befdcfe5774b0808028b183c922c421d232b530db72505e7402c339008e3a50057ed2ebdce2a2d45e92f7bcf2b3f5c2c7e4c6db23604c893e12778197f3c0ace94b4c535aa1255d1ec95aee7d3a8d40bb1265ba1831ceea29e3cd3ee2a23c0cb9ab7d1cf5c1232cad615dce56b296d57586d9a3f0044e27fecad6aeceac639ee80653df7510e47fcac6d697e6375b499b2199ec5c4eac687468a457997a36fc66197c64ffd8de4aa076653558369ba2a519beac1272e35fac7e7ea41e39815a85e714b358a5d1235a9fb4bf59f8cdead0d68a9fc5fcfb7cfafe80c93c2a8ff088fdf9932d16bd1b9e7c7971517c7510200052498d47dcc5cc707776221fbd5469e68b8d1207cebff092fee31cbe2225dd28bc487d36d2a46600c7a21b32471cdd35ab4a412daf794e3e104f51f7578d6d327ac85e84d5ea8ea3ee5c94e51480c96aee168d01cec315455c623a55d670d1d410e1d0efd47b92419782fe48aeca69c88c4daa520407fb6fa46b4326cf2ba26ba332337b32d861fe9f9eb52870680c628550440d48502c1594a05e62689785a7b49b11c75e5809b5c59567950982f2d9d859aec3243acfe6154f2c0b0b966c6e4692678e5809a4ec26be4dc67b9e014554c348d0659a8a13a8fac880896a43377fd08afd6dd9ecf6c52a3b0cfe710535431874774579f813195c2cf1b684e33cf5c98b5889775dcc98e15ccbf37185d23d1333190bba3fa11ef8eb2d57f8c83646f8ebb083e5f12d59162deeedc70551feb2fd1c5b5ce52b53aabbd17a5700ea5bde9b25ca5bc1c60f769f6c015f8f05c925a341c9028a255db6952434cfc03cd1350b87194de52fbf416e6a47235a72d571ad5aa96963608bc4bff17b211a74a4d1168ea99c111696b08dab789f5317357ef32d01823246eb75a23be10098393c32d23ac1d8a9e6c912c89eeba0128ffd886aeae487b16bbf48a9eb51aa3f282f00f37c394109c0fe7703db476f8a576a4e2fe4ec3fe469d7a7370fe91bedd4c84239b9113a1d564a11a360402b1fe2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
