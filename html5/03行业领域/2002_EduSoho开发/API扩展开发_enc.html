<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e92a7b133d6f0514d5b69920237e280328583d05c5ef1212a4aa89af06b69329b1f85fbfe54c9b9857b1e59ab50fdf73b10246cba096911e02aee593a5921d06392fc78b8f15edadda584d72dcfa315b703def4044cc3d1c0b791c10065e9fccf0dd39cda3992cf3b371b06d610dda4a3b3f6c7925c03a28ba1e8f6faaa9d889f8790490fc9341653b3c16417d60cf8fa77fc3c8085f5968993138377c1db0be6a8316192a861c3bbf8bc92f6ea0c7c7a5274f5fc1bf4917b4b3937e4e32db541cbd7c3ce89d737325dba08b540e50cd3405da27abb579e52089b53f07cd1d4db79e7b02a73bd548b695a66630b42972fbef8cb7a610a649c7a6301ae2479fb5b85d443e8e3e4c86ce9d27666ea6f18ece2cd7dafdcaa3d9e0f728dfc616e09cc7517891357319c5170a066963890f9aeb3056dcdc885e516eb76c824cc98c3802d4e8f82166f79fec48c64d122b5669df3757ecba4e1520bac03e92d22c96ef5100a96198706faa78ab6bc5b424b4a744d4d7c2c58489ca0d9cca676dd42a695ac9f5fcc66e9e94ec588fb25f735359275b698eab06b517e0b6c0b1113ac7160f1b61b160e08c5bc46c658dd30d1e72383b47a4011aeb0c7c1e2bd531fb637c62ad74efbec8ba7617553b5293bd29e8aab9fed9609af00b07b662a41c6d71151f82874ab2086e33ad089f710845421dad80147f97d0126583a071a8328d0a5f988bb9b8d804fe6f3f3158a715bc28353e6c341318b03df4554eb771a8513d00dbdeeb351013fad2a398990f308bce488e5e87bc63f4fc7db51786214819e57f6c31101a85f1b5cd705c0dee6566b0501d068ccde84a2e75dce18bdb0f5458ea08eda52c4070e9a50c78d70ae6ea1d6b6b31ca2839f1dc4ad441274f03be9b17c274947077e2d71e1c8fac0ecadd547daa973e83fe3a5fcb3f29bbb89bd8415ce4544075e1ab91cd5f94a6aaf451c11eba124d2b657990f16cab74c45c2465c09cf8dc3579728dd1b8dff92aec7c961057b042e05166f0832dbaeb5cfc4ff2e7b63fac3fc5d6a05865afbed0a8173a62468dae610949eebc7393d82da935512605e368db373d30415438526094957126c234251ceab9a29d683ef7ad5f2bb3cd99b4158464b1a9662a07c5e96766887e6e3f55415af4b7011dc6e074f0af81ce0beffd141546e51f19f2dea9c984b03117b3ed053b1dbf3fbe3e28643862c13e769e0457386356a6b8bafa070d8fc08c0ed4ca6f9e911ffe0fc9a6291d4f8c850f507f5d34bec3912b3a0807970281651dcbef286b767d418388ba876b9d4c6b6cefb9eea78501bae2d59b012e9e39afa69d13bf9ee15c4ae2f6f9a178b8c2555a827bb9413c7658f06286ffcc02fba73c9d01a7600b1be1ff7033e6df9a30a12d7e37cc45e6ac0ff7cdf1fa2002c6685aab36dedfeb0419cf33faa9a94a4d2bc90956945ff490d0fe3406c1721497de48188d34f6c7561c725e48ce299a4532185db2345532727dc558e1697791064b89a675d713a8db88b89c80f3536f1bbb309aa68bfbfa2c21e0056363b1878b89caa6a572c84ccadea9fca8264a824631a4f53951578c2ea00fc863aa3752b09b2f988149801672161e0e5eb7fd503abbbc6101ae4e38806496592c542f88e6f92bdad7668b35c9993a54d054e1b4f307008ea25e00c0fad9b2f599e44b29c3a977c77fdac51d78a3bbc81b4cd49f945b81f7b39f20c236b35a836544eae581b774678e1ca31f83b60eaeb2ebaff9213f724eb538086e5993a88694b44c2a085efe8dda45f3358cd928ba4425da323f327575129cb5702b293ec585941512a818b52abce259bac749058ffcf06fc6894c429bf596efa3590e9d0411f85b7eec929d1018bd40b593be694d2bb899750c90fbcfe3fc5946104e886f83179fe93391089a3dada206082e2506ad8443728edc9e19fc3fdf9035a7f080cb577ced5a259802373199d65c6de9d6f118e9b484304ad0873599d3e6f2b7641c9bbfd96ba5c0fc623cfa896a30b5b0c0d3ff737d02389ee11e6a41734a15de34903af5244758ae3b934226b286c569cf6ca4038bec7a00ea90ff0f1d2345a476b69fd5d945b2afc53b6eb0a06f8d748b2cf8fa90e96077cc6bb055f497b080cbb07a365e17f1e9c2d077cce98db2b4ca3e33661eb845d6786cffb2d7f712520f9a2d486ce68f8c1b3b1285b394d045672a9df27270c14ce143e857ecffdae2ae3e74242cd19cd028910246469a77457a52bb25cff1fc00d0ab0abe4c48df79c6cd72b5fa265ba2623ef3434668e28a2ee13be777c0871c7ef7f3d693a101cc2cd43d8f7c705a2d9ea9faa7adf81125be11899ba06950c65b9558f06ae2c9b5b081a7584ff1dc1b916c6c8b3f67e037cff1a6cda4d284be8deaae118d73d3aee26140bf9390c478a27191bf75f55b338ec59724dd97259adf41075a43fdfe9c05a889c41e7db1b06b1aa117768d4f3ae734ecf9126619fee72539eab6ce7ce45334e1d858912a7a88e02515103a9ae5ad6827e399360dc6b6710d9adcca5a039cea8ac76380f12963b2d1cc8d5cbc4b8a28d2f733064b25289779bea0cf8e7aaf3e66a03e411fdcfe3124fe3eef1afea1a8522bf1e3aa961876e3215375d85755b1d9a58d7df3c0176963db7035254ec1657d78fa2e29a9c36af85cb418f1aaa26bd2c231c8f4c57e2236bf29cc5a718702888526ed7492ed74e4126ae7771c502aa7923850f4cf3e1ca332f93683dbdc6649bedf2b0c8a46cd543bf6ff9a05b30034a4966b4938db7b6a47de83db50ae53cd776147f8e9a396b8cc26463daf213d9f5cdd80d9b9c9895381b382ea222cf4f70d07aeb2621fea3c8d77c4922e2f4fe8c9ab22a66898a2cdf9ea0acb93f2b51e30cf655182b8a2921da2348648f1a2054e1470d49bbcae3dff8e217a4aa16bf7cf9897a46103fcd0323d9937122141914950caddd0015d6eb407fb747945c39a730598ac01ff2f6a5e10746279f5e0dad8343cb920f7c0fafd9c15225e1bd5bfa1f9ec1bd524cc206a9232811f265e2bb32bcd7c5a272553fe129f9cd3631a1e7413f6ce7e98a53d5d1bb2d90823f1617cd22fee0290f27334b760d52ae88bd5fc9846732d141d3d334e51b592fd71131f26006283e78c78f5e785860b8c1385044a0cca3fabeb60c92f100cd2949d53598e67c0e23e6345b2869c9d99a6e9a52e9a86477c89f84500f01f0ced0e82d21fe10b1ebff7f19c8e6334c841b8cc8bec35cc15038bd4dc593936b3a5f16214a68a180f658a21675bc8e8f8ffb686e868ec47832084b203056398f6bc276a8a6b1dea0cf947e3205c5a1bb4d3b7662b3069091031efaeec0078578a7caced564a945475709bc732555df142561d469912f90bd70c3872f9ccc5e783f76b4ff263cbc65470386e98e08d7e9594e283997f4d3b18f07c4eda87351aac4ad32eae1373edd8723b3481859b707cc36926e227a6781120c3aad015821ebe447cf947c6f98464b51b8699b09b2a00b7a04ec44ab1e61e0f10f511ce26f5b297821e9861dbf9859a93683fba02fdc04a1b306d0b03ad5030f35d7b2ddf040b18f76c4c9972b8f9ed562644f3e5ee76c24cd10bef4dec4850dae3c0c6334fab555d6446577b0814bca38f2ef0678c73c476b1297fdb02dc0326bf2d5b6e3ca6a3098325651587c570daa5c8496e159c1375dd37a424f90e1f80d3891668e343b4d33c3cfa28bb0a399456c32d7dfaef821a4d0792fb42c95a0c2808b2ca2634de53ff1f4263f6efb5fdb99f454ba3dc700a37f67750121853aeb447d854f1a8ce2491067666af6b2446042f8593efb10a7502eadf1ea53e0daaf7d2b9f206013480120d30bf9ab6664d23e9731c4bb113c74171cc52b5476b0b1d62cbfaaabb59e158bcb7ed9690129cef89629565e469786e444405969902daff3f2f8c4ffbb85f3deceb814119397ac56cff7b29b66c1c3a02f1d724b3df21cc1f8972e875639b62db35a94ab0aa3ba6936b768ec572321545c34f5503ec1ad411d85e0a6ae1e5cff11a9689c1d6aefb3ad727a244b247dc77c32471b0e67b248062d36bf55f410515a3ec33ab47807a435f7f06e0003cf5434439f17225e9a3e445258e3d0acc9d7691286ea919a7461baf2519b3d4a8beb6d5c2a7be60bfe4efa971dad422fb2dda34fe274119f2075950bd0d18747b10adbdfc6d022b80af943174b7aa7c1a22fe78acde748b2ad59a39bd3e9e6761e07e4b803f37e254a99443ed96047436b9d92d898981813136dcb62cc6e97286a9376985e861e850a6528a6c415286ed96ac5dab6452b14288c12d886f1170a01a450cf9cae59d1bd269849e137067733c3e226b9c6ae6bdf6cd65131c3c60a9a4f65ace4e60603df4f09fbc4324530d107a65169d64b2cd377151b56adb662aedd48a7d284216842524591e1987d93d76cedf5d48b96bc980715d5a6145da79ac244c8f76e5196dab5edb57056141a0dc210d5f5ab71e821d03c65de746ba4b53ffb9d21182120186d5a5a99d35921d658b07381debde49aa03ab3e477a4187034e9b83ba88a307ff122013da73fbf723195d05a7f4975a628bd5d010135310a6afdbb8f19a967a21fa251696d373365794fb59c0629e6d212c814474be8719556b2a01ebda601d1db2adbb4c95b6e41a36ffe835e17ed76e14eab966f4fd897e0079c3e542a71a0ef7517681c8be7b417fddc780c72f87bb7433902d447c1cf8e8840a543db8b536fb496fd23f119e747323f7232183a144e8e0f1cd6f158b796fc6438dd3f8b02b4c3d19f4fa43347144bc8a9bd5ee764b2dfef543f27ac38093530d19f0f9b907469f7eb924690d72e6bc521e8bca64cc4ed4f1bf0d9bcc21f5cb926880df4f83df08598fb0d8fde2b699af550dbc19d24db0e0cc334f9bbd8ab07029a6eb865ea0c6e618b410b2af3cf402b81d90f58e23352e1643a722a70c47368567d83eac921ff8618a47e9a385a9d39610c23ffdf1cd86f26b734d80f99338ac5a8e57b418bb6f054002485db34b99d0b1e67d5e9bab1b3d616c52bf8c4c4be18b9b8de8821120693319e8f369be41f0dd56c632273d75fe37dfacd51ba0fe182ab81467a051bc3c432d0855753f274870e34f7010f657b1f8cf2975c894a52bab7258b17dff269443a2acfcf3fdfa479bd951d105a902370ef7481c94bbad84e707bc0051ffd4480f552c07ffd9bd688220bddf74f27007f055d90c014fc560d84882b78a36371a7b388c99626e1c02b65096caefeb07450beb5a258e5b1fdf8215e6e33e323b3295551d06ffc92b7d5a0156b15d3de1461b8eb014272007ba94e1fe8582b3900f8b9a9a9d2737d0aa04902aece0c95b727d66334dec7ac6e194811c3ebc72e1965b63e25f57878604fc923ee6bbdee26820aad0c5f22f50d74fb746595b82357afcce0c988414f9b779887e1d8cfa0784f62b483edc81d337d06f6680554a2bbde10528c4d6f400636deae36356f3d7fce2592aa372f47e7aa395e4c5db38c02036e9d45ed4e5903e1428e801adba6c68f491cd647aa75356a9c4e98a7f09f4d11958a1ab79424d1e30995e9791c1df3e59e4d10bf5fc2461b47aac2f072657a16689481f3b3195bc4353d7d1b8b16d2f3277b7410dccfca0f4eefd1cd5edcffbb780ad8cf77eb86153282ad7d2d5d2dddbef5dc53b03e2c6ce83dcb45d9e44d43b03f22d05d0216d0c809ed63794a46bc883f70995cd647d6fb5b30adbf5b1e5927fa5452abe5b6da7042e7ad143b4971cc3832fb3ada1b51987485aaad3b62fec8855ed3c7881a2326cdcd403eb5b94ab6bfe6eafa30970273a848479e181dcb566a75bc5a58552b26a6c274312464186eda6970d58e7d124a818abddafe44abbfdd4c5139ee517f3d438f08aa203781fa41700a9972b6f126db4d1081f8ce95c49a63000a00c3bac9994f6f04b5c30302e3d0195b0da35c4edf6fad0e154a38244311ffe8d68fd1c285130c1f66cf3a5fd309e02b0d9048dc0a6b4539e27ec160876738c7602f2c239260f969a8fe4d4bb342e65e5c6f4ac3897f50956276e7c59a72503d8b2de24bfe6bd5816e6365aa39c239712459ac8d274e9ab9b1b9043b968d02083be3b4aa131420624a0a5f973ebde85145039e9b7d4fb1a9dd9adad0ae54d4a8238f3e2163d74623e162bf920422c8ecec8eb13d322be0564957a915e1134838537cd06c4872ab2e59d74425af4c16a4a619582803fc9afa38e74b366f8fc9e4d13493254006a75a17c91224a03cc69a5b1cc7d4b26d4f2ccea9bd21f83dd96c449b4d8f0370ad787b53bd8eb9d330e9d9918155c2007437321964c42bba0ee1606fce112ea974339dadf5b19bb4afcb290a893981c179b767783a789370a93cb9999c543f30fcc507e32c83a0d8b0d244ae16540244750ffebecb9fec3c9334d7e83b8e9cee06802374084352bb7297d67e7c06073b51793a329d09655a60b94109bccb42863e5751a78e693b35c3f09e746297fa5e9555b0e1c1861a8dea1a1675fd7e865ac2f4683daafff47333d859b85414f27ed1b484df4fc7b9d686b0c5dc856fdb2b089077d96aac43c8c0b2d060431c4bb5cce4924d19b4992c15f980b18584049c9ef839439be9eda72f23c581f3b2e03ce34d50af6c336b41a3c8d3236a45c9d1f61da7145af327fbe6b184ded31ead00fcdd539c14716bbe2d1add6f458cabc6ec841e85aeb0ee6e51ea6213fa4b22db01a200266ed4f9b68c7e639073e3b9b5d3204e8bee859ec3f0e74d76ee42364e1bc95acb1bcafb9415d7f7123e57cd63dd486fc5b727c3c8df63ab6613a20fe1dac9ca6d61b0242d06f8cc1d4a793990f24186929faf279682600838d783aef79b606c1b133b08a2ae54a261093079e47a804093b75e93a877dbb4a449a9f27b7e8317e96c79b330376f77cf84f623a60e3cfeb03bc2e5960dca2f03b7afdf0c2023f3da014da2f919bf1e0be1e83096072279953687ec8f559944f1b62a0c3d205b56e51083e649a6ceb977011f5b7fedcd63175a640656b7de404835ff81542169d60316c1f33afade49b69deb298deb42d093a6b9930b1f09e9295303aefabdfefd6a00d76b0a72775f5f36abb3c963cf9a8ed5a38663df7890ea4e4b455fd325080a475b2231ec268f763d289235a8c5f980160540ab03baf849ba25d6ee27fa6a1651e8c9c311625fbe0345fbeaa713ccbe82fa8fcfd358aad2e756a27c7cbb62bec3641250fd7c12aa44a3bf5ad4d3945183bdffb1f55d318cb35e491d9ac9e8ff8c4c334d8cdb66868f558ed775c6739853dff361a4764b32b81e4a1de17c9c2d098cc26fffbb093a862890fa4f9601750367cb8f4d011e3a4e9d223fb085ee64ac1b6308954bb8f7cad739da5c913bdfb9fd299e23703afacdcf7473c2caef1a2709ee690829616d73194c146415c9a0d10f85e6c1e4b0710311d7d13cfeb661e773205ec3c4c32d6ac1bf91c9f86233cabfac6559952d413be501c37a610d3e71bf3ec6fede2c5c4ed145ce00edfcca894b2589520cc14447cf64c5b6aded2d9317690501183eea54b2da55789ee4829096d741147b5c8cb7c4c54e81ddc0dd0b39d2fb44d8b2aeacea11456404bd25a2a794ef41ba75be24f7aabd5f6eeb1988aaab0af71af406c3df8cffce5db83825f9d0b34b55579c9028c684a6cbe22fe83f9d575fdd24f07a90189d95b85f10ba5f28ea24d969c686538728bccff35abb9bbc8ce9a7e350d5b95da3b379e1fd40b7755127bdbd069c0a92c41944076ee4ee733c7fdbef0b5dda3679ec0bed5094bee4360cb974e3c98228b869d68ef721638817100ae79116d5caab8db99d2ce22c5c4cc9f96534ad90367e0886baa9d1e1d4a89a4dd3e6c465ee0d7f8997d4ffa06ec90b86b7cd3a78b61f5cf7ae9406dcf9b67cceaa9326263c1497686e90f103d841d312825c26f74c85fa4899532bf819be5b92138ad40bfb6118fb05e388d75de36f8ce78ed53fdbf08bf08bd51f51030d6ae05809ecd9e0a95a10502dbf7677ec64de0a737bd3fc41b33165769851183be6fb6b55739377c90d74deed641e8392889460cd88d624e9aa1a62c413cc8767764e08d78a7720d8395a8f4c5e2867b281527b4dafd8dddbc9163a5e49f4e89f35095cf153a63becbd06173f6972177b29281e9c91192fcc58d5233ca66cde7ab30ff44fe4d1b30817b8af3a297c80b38ee8868d5b0a57d92c5ed284793aabc85fd26dcc1e8e02b12710d69863cbb0ab133e4e151681e811269be8929a71e3817cf9b132c5ac04fd351054b5d54989cfc3325c4861ab3e08ac3eca37aeb27e8248ffc0fb95333ac4d87ce81c6bd0c2a3ca6991d973394e932c3a56e42c81eb69b7393061abe5f40081dca796f76645a7cb4d0bd659da45e9b85dd5eb6e47b205d285e043be2b6a07312b3f4f9fe32eb6875efe7004375e5654bb5195043ded90f4a80725f60959c6e11c3dcc7ce2802b14cf41d33ee58e9d4890ed207af6d0bdf92235321a33a82321d408fbf35ffd6d56fa20823493e90ddf35dfff93e6d1ecf71fab32ed7df658122a4cad9ccc9e9a56b8189f0156df05bf9a658e63c6feb34401c783dc1dc42783a65e9e997867c988c217b524f9e663990a72e7b315b424209be0df7fda113dcb7df5bd64b08f2b4e1b0e68bf82324cc8e1d31c262fe3af229fade5a4fe697ad7583d6e784157b200cd264a98bfbb28005bbbd4a6e86c75eb3ddfe6f7c4a3eb6382fd614ee3f1538a9e3c990c3a95d3ad34016d08b567ef90f947959cdc24e9d11acabfe85545f40159669ce3540c2475ba1a292ecc47ff5e7fb97cfec9be6c6af807c5a251e77c8a8c812f3df5415308bc901c61a3a9d32453cf206d488f0ca33deabf3452790c2d891689e5cd30b0ff9557d98fef016689aeaccd5c6d544a9a46de665755f5cf675a8dd6d17f3edae0c863396a294ea6b69dffb8956eb97b56085b65ed137f2cf874e5a39c96a3f9b16402fcd6a352e6d6125ef5a73dea71020a24ed4a0e9d34bce49abbf1c7d0db52aef5828cac4afeb24b2a4031c9b18e4b2d38c5ef82c208a7e9cda54bd04644b2988ca877068f74a03ab001053d2fb31be555576211ac96eeef421b3c1cb7bb178ffcc73e61c98c5d15f17c51161400d334b9a9fcd6b5890f5b3e317b3fa02ce5eebd71e65713cc7f494b098b564f64e16060525d137f8339d240d037d96ea861a67e367d28d2d09fd406c15d7a0b863fc23cec7c4b926a4349a284de9d319752c4a2b046a12c7f2865e5000a5176b6f7a94d957c9c5fab3b14595bce6c40934376279f064c91c6af2fc25ee24b7d1b0f5d6a1b5215f60fdd93700732f78961d31e641a0857170e20d63ee667188c9a178e40e4d242bdc3be04e6721c721b72b130a743107d12b6ac01dcb5d88444cdd5378776c5e9558a6d8c2d8341122eb5ac5a5ad6d0a83bc0420d751677f1eeb3187b44c68376d4f77dee38c0812a3eaff3098cdae087a7bcce385a8f22001b785faee0f0eb74d4160cd294afc58b0f2578e32873e87696e7532f6ea50e1bd2ef8788b419f007e929fc507d295a4846b73bd1c2a79b55570e177ef54c1806e1cd5585ea97b913414ac34e6fa5a7291d0bbf05fef5398e98d9994a368951001f4af6a79f286992215f3ed6da61e594bda3371224b70a6addda67b4f27260352c34188503fda88c97c7bc6e8fba9efcfe54031968e35857f126ff29c80d115fe8259e6ea6158c8982624da6fd135a38410e3a19f0aa7a986d4bca5e9f503490ed8ab3b68106217d8032411aacce7bd04189e506fe8a7f1f919a6ce8383a772457d33ca2426f1f4fa59caea2f779f45631e18ceea2b273724ece03933b8cb523fa8ae5a537f3c9870d110ebc2240577310a07792744356520102d8d7d0c0d6d0579ff37848fa7c891e645852e70b151d090b896a788b90c352ecf57bf1d94c86ccc58962fdf94806416566f3b4e0b8066cb1f84a856f2db690c26a7616ceff3500dbef326c25368e060bc0fadf13201b7f4d22a427b2229571c2459340569ea650b03a744a4a1b7ae463ffe8b0911604f586b9e1216633a4aa76bbd08ed85b6eb2854da99aacb38e44d12c7262e662991c9dbd50ad311ee101c6dbbdaa99b231ce0be0695a1e83eb9084eec8ce61223b1886b0c8e62253924ff48abe1051188c50757e12d61b5328d2196b80ec7c88402b7fe85ef9968a1f0be24bd8f98a5826b892cbd00425ce5840c5e4c8f2816d7950e949fe6a05233866f0f8743dab2b57cf74da18ab901d36398a0580759416c1ec1f5bea32a53d8c567f5ab1bf363066e0ae20cdcb6521370c7bfd7663bb79a10596704799e02c1045b614e794c93803a8c7efadecf6c839de71ba8c6f4454cfe67091d1de182f3ceb20bfc567d40a1dcd68c0da461c8e720ca0e4fd37a2be74975eabe099ea71552f31d340c5f88eaa22c6d064276ea57fcdaa9773344aee2762d5db1bad383365ace75d7bc7f4b9da886d696d2fe56ab89e34b0e40bdb321163e4deb03ec4572d40f2ab82770113b41121c28043e7a95ed45fa0779792a8c0534156e197a23fa228ddd2b7e7d001670b0023c2ace3e41acb5e437dd1cd541bfe12f4c192786f7e05040322a7115e45dc90b1d3c56a94daadbb69420cb58b486ef547934c18fc14dd2fc5b68be4b78206f1ffe42b221c48ed5b4a5ac083d2fdbfdef2acc600d60604501432855daca4107520793a43e9ea8c412d6068a3deb284553a95ce952e0693f3eb485cfc2af6e1131bd62f19574392e2384054a2b55515714aa2d1ae79cd464e522fd76c52971519435ec762d3b062b5739409889c6e810479a883b35aef667f98a1aa6ae700635d1c354ffb3ec41041e01579831f22cb3ce56f4e9a85aeaf8ef95d983175130f79d285c5817fdb5b1bc82c3aca236fd634d912ffb7069bf17e4cfe60eb56bfd80282999f50e1d6d186ae504641f64d2f57e4dcd81078070fcf87ab67726292eb48de53891855a29fed3d3bef6ccc9dabcdf7c335ff63fd42c394a6369baa8ec628295d083e587fcb94d317f392d3209af66c8ed18be7b0b477a67151e868c1c46ae125fb2c10f43e2e859d1461605a9c2e2f30d343cb24e879406b9ab0a435dad063820b85f0a07910236f0d8ec605d52cddbc6996855656551f956633d492eb8597668bd87278010ca2afb25585586a74106afe58614600479b44ba194876b647d218bf70e52caea12e21b2f0e752fec086f6677345e9884b6ff739c01379fdc7965a32bdcb460d51dd9a72e8c9eef763705b25f5bd20d7d1c769184a177c477704cb6e9a92677b38f67bd1e49a193def75f14a5ded25d995f384a2b90d979a3966dfbef480ea62e1f27e9f40167cddbef967f3470ac5108f0243649076c9324874cf6e98cebee2fcf73902ca5fef01b42e032db888e5bc02f6aa4b7a9d58ce15386c3f209f8a6e05a5f4ce1af4b8256e0f444471c2bbd7577ab79280d24d88828e976a11225865373e3ddec65d0376bcf8abed6fc3f6a01e9e46854612c8274f136f5a5ae61d3731a2010b027c362f1f2803d24ec33e6a319c1024fe764f190cc92cea2ec5d4961fde61ce8cd51d87b43c529e7993e05171010847dd0212d86d3bc95b5a9362e20e8f1f41342518fbde38b8b8c7ee0d6cb2988fe330d18d9722d644bad81fd94385afeedb892524e04357a67ab3156617165308a0ed40ea62e54b439a2170119679dfae694e91cc5fe5cab7e1060665655866fe2db1d89f8539be1f26a66c56cbbc382777e63056d976fa30502fa92261718942cca3d9ce5f550284381358365b1c2db801d1c20edec31b6fd4fe39df3a6b87722eedb8feb1aab93d2c7ec2b4e6c0c0b50e27a2699f1ca9d76244aa23f1be98c23dcab575e4ddd6ba0278a6520cd53c4ab785549338206807ebac96eea0a5ac3a1513ed85d6d130fcaf2fe80815ee04ad556c9f2a64c5a94977e7fb4ef0c7abbfa0ed5d00d1bd4fa81b1be44582b88cd8569d84dc9821e54e5e7800ed25f940f66fa2fe1f36d394e63d86a68a4230613c9e8be4c54841fa47c1720eaa0b5b6bb3b8e8fc826f06de7067349842b18f69953d4a9827b1e816afae7099bcb10374a2f1c23599e26f4489fc1156caef0c45a3564cad135773fc0384737a73ae9de3c3ed6b44b4e669d547df92526e5bd72c95b7cc6f7cb447b2e1da48c05518be767e876f2e1198ec0da41e6279ba1365b70599f97d886599e84d1bf741e9538766d4bdf19401679ae237dc8c7dca1d03dc38cdb2b65e6be1bbc0cddc4f216417028413c24622ded5e5404f6361f4c02d31ca6df0d15de5905209fcea2987ecf60f1bf63b372ad4237c951695148e085fada9d334837ef246b6be7a21a220f57b854f5e3a626db8d9d5bf8bfd2e1297a5f884bd9dbd8172ec98c083d57452eeb4bc06ef2efc0faa2ddb47ba2533d1cc766a3cecfdca1cdffa7368009d8e7dbb23d9dcd983051886da2815b04c68362bc5d53eb2e55970acbde9d6d54d279aa4bcdd5a8d7c7a2bd8c90f0ef0a419db87a18e8ae938a7b92ce87006d9acff42ece6c136dfee859f0db99619c846bada9759d499bd54a95b56540c4a197c7c941d0078bf3f3b95900cbf8a75f4c646c26222d1537867e258f7389170bf8e089016276877f06d85efb85c3b2bee4bdea8c24b770fb9b2148add6ba587d72d1d4bbf2336a622d15dd03dcd36df3a8a9b9983940dc772ff9560586cbd5ba801cbcd67490c1341f2b1e6502c526fd12e0f4d550b2ed5b2c5ee2d35052b587951f81fbe1fac6ce1a22213707aed826a702b61c38cba2f8c0d1ebda69ae86e844ff2d1fadea0ec2e79d9f18928a5ba8673dfbd6ea0eca05a46720a0bd6769773f4280b3d14c13f9cdcc1b4277d4b0f00364c2f628b61736094c48ac49b453e7699fe663c4dcec4921d086a934f43c24ed4c2165be75d3a6ad8bba098691d836331469eafc73ada35f6bcfa997e1e7c653a6d129061975dd3fe876044d05a2a4d256c0c57f7173b82ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
