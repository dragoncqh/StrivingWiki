<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"904ffe31205218b7c8da38832ec27c0f55fc745aad6b6fcb87513e0e05604e1018e379b48a2d44967d7eb153051f811a44672a7d55f4b53fce9a51ec824f2aea42eafd5114b261d3db7243becc7623bcbfb4981514c4239a566c43b1d725b19a06e217096e492de0f307fec2a54691b6e1da942ab50fec0816a722c275de81d1c1ada7b3bfcfcdfbe3cf11af20036747097825c048128a0c974f810e5360ba6e632dd8a30d2b0cb2a86cbbe95d21c03809843acf89a9cae96249e7bbda658168b9bae4df21f1c2e8c72ba3bd96f573ac2ff206969f91e92356884334c946b15754a224f186ccdb6cac35fb8d21e74e9689bd859cd6920193098e25d9c54539fe5480e064e61096fe6cabc199c2a3973397b9ad3c5f086f5218b3d7a80a182703c70b96d2e8fca5ea5dec18951c753f565428074de155edccdcb9ae3e50ee1cebdd922787369811b5fd346897286b814e5fd732cd4c19cc05f3971e3942fc69b1ffcd38fe3553883c1cb1be41c01d5525bccebb9a0f7e2dda7dd07ec311f4821d81bd6a54e9d9e1397f545fc43afd55d8b194a2ee38ea23e6b2d9ecc179355c048933b0c5d831ff09c89914f806a9d6d9a74b35de83ee344a7fe69e6821ffb30c7d00e25fd438d8a2799c954e996bb2c3b2a76ff7688a2a9f72b86a547581752381b05cb5de2235c2f1f2cf45b29d0a9a68273c6c6ab5927e2aac3283a1085c84d60ca1ae25cf0a35c54dcc5833069df5a42376a9b6153b0168987dc5ef8e90231a725a7925aaab050f105fb99efa46ac5d68dc97b75a12d7bd0ded2bceb2e90b5fdc28441cb14c6ea51dea086daee7404f955a7115f735c88bb13819b8ce286d3423c17d53e90b1fe98b07f9e835f84b18028dbab7e3c0a4463bc6b371cd376ec72b83bb290c3b0cff6edcc8b9626e4e1eb8515368684e13c13cd55bed7d0ee174b86350e1572d2e20398a329b2d7e3113d1089caf6fec617c1c063f203c52d2e418a38b179871a1e35019130f3303841b5704e258a888eb201ef8578ecaef126e50a24ee45765d31b1847c873ba844678fb5319c14f5004e6dc25ec7d371fe03170b1ca2ad8c2d2f1951bdd8ea499351d9d6a7e085c8fd27ff9b593cab42e18920c07687b72fbbfcb5d3599809a2294555f378ec3a9aba755583ab942a46480ff8c576eb7ef3ef36525df5a44de1b1f77cb6120a0f8970db1c7fc439bef6b9070eb2e77d8c4af9a5539e63cd0b137c6d485265ac54d65bfcacebcb3bd4b559f1b70779de1708bdb94b6d63af0714422bb3ee5e21cd5b83a19ab4083f5ab9648d86773c7c554f57d92cf6bf772a7a8ed2b3c7fbdaf7b13e8c2e8215bbc2bdd2e25ef9d8e70418bc04ff27a56ebd7c41d1c5d5d791976c7d89c717aa511d9a32bb9875ed06ec9370d1f5d00bd40c0d5b306c4d0de3110a15985febe34ced8e6c09026109bad4db41f44eaa49586e3f62c8a26cd1338c86bec28133d5704894d5ebe17270498e537bd2b0091a5622a50803c974ab182476c3adc2128bb3ecf71cf08178654051e60b9ecf67788bf592839564132dd5ae68efdaa867f595b42e0a85c148bc9701a8049fd4f8940102dfa9053359d88c7a8ce302a5f7e21b568723dbae773d0901930a22bf6daf24b1dfd82c5c3338973f9f187153339f84fe57f49678bfbdf68b6df82662e48c07095e8e5ea583246c6f61ee90a62417502575bfa041859ca31acd457c3620b1222e19c3b015e5b10d14d571a06da3fbfa3d22d1911650cbc3a3a21ff0c97c69c7e7488c03bc15b4243af70d8a78c6c4bc4a750ff81d07a51c9aa7668790c471ed5c62b2b1c5c27fa2eddd1d679742d2efda49f60e21a9661cdb7e99a30837183d6fcd7124cb6f4cc60b02140e08eae1beae5bd608264a8ec207590aaf00724d1d7aa10127b95d79905f8e82e23fa7597d3a0177057d892384cdf4f0a3b653a057e31bee3960d8215dcd46d911318bbd7d0cf7703736e3004b60a1c6a28638b5feb9fd9158bbd36bbcc3474e68721dde9c0f6a8cd12a84fcc973d15095bd8d2c04d283353a7f63e5e31974e6bbadeec5c3ded1ba9788f35473cf0f81e957ed458bc2a65af74d160d0f4514317ee9133bac1cc80326c77607d85e6beb4e85feb3ff23c88ff8ad792db26f36f4f718a658ce7b855b0dd8d8d9dc2ecf39245572273a55a8f5184f0e89bb781b470943a1e9be778776a60279d6c44d113e6bcac15e8bf864e7aeb7d0200d65dc170716f3d1ce94d753725aab1b1b76d890439e1545e9b365c7761b9f2715edccd33ff6c237f44848239dcf0e1b72f960a59b2b855d5da37fae87469fe0b7399a5cee744ca7b6cbe46944bc233cd4f2d0fdea1c246413f5cb43faf7ebf41edc20ca4994a1731480bc002c0f404c93c4f1979a67928ced29009dea840e4733c038e9ff66f1c110df2e4195e32762f66b4d5f0c56da147182fce6534743d578cea92dd20b75babb32c3c5910a14bc1df8fc7879125a760e78818ec1681f4928d106031704adb709fd7e5179137c8ccb5d1b4414ef35390e1b7e1106021641f9447017161b444790781afc366c9a132a4070f7b28f6097e39ba42d81bef9df3bfe03f5ad163cc2b983a9fc03826fa77788d529e6a748a62a995d270eb59867654295d6b4e797b299140d2fbaea2d0a4cdd7c6514a00e2c2d38bc80bb300a640c2e9fb949577f0a341848d84feb87b0ee08ce89e73540eb0629aafa2e9fc35b13252760319d695de4c25d758a236dccbe62a0b562be6133e8e00ebe7d44dda5be59a904db1339fc9dcd6572bc6ce1a59f8e5105e1ce9c3f0f0fc404a6bbe4c954e610c6698ef750bd687d7acdcf1b2290ad6a8a7cf1d63b8daab3b99f3dce4190c31198e6c84bfc6300ce876795461bb825af9104af1c8d69ac225627854d6546f859286b977757c5d048d6c7e3ad3e23d2813dcb17963a455844029e2a3054ce11da6063ccb0f7d90c9042211e79dc7f5eeffaa8df178e1b4834e3803264a8906c4aab21679bad0beb4b3852c896170249a855a2d90397dc6e26a2a7595e92c34b0ab946c47d6419869dcda55982431ca58ded68a79c1528bf6da8ba1b32808e7a60a33fe6568d08a5efd529e265483172a52f3f7a998b4577b3f5cffd372251072de22acabe04cd3d66e2a3b3b86045a731119133b4226a5c6097ee56fa22076112ee060741929e63d37a9ae503fb859798b8e355a82fbb32365eeb61afdaf8fc2fd782e31652bb72b074c5abc5c5d6c36b66eae5cf99e30a9184f7a60d821883a1c97f834f74de607e155e970ba4f78083d4bf35fb9be5ed401e972dfe8f3a7b8c3a09e9cb53041d613e3b064a66329048a6d2709d1bf85835b46ff9d83ebd782e760911bb12d6fca16aba4e29fc26541392a543f59c575cb9e8a87e0f0b6cf6e04132e23d80d775517e4ace321f4cbc85b545dd7aa6cb9787f0fc3e52a23a0bb2d606d56bdc20a26495abc34fe9fcbe1e68adb97eda3290ae59e6ff855d42cdc177e165480aacf97523274f8c86f5aca9a26a5902470e0cf30b463e3885f21ed86bc5ea005052dee026bbb240744ab1692427f077b3c33f17f0d0e13317b44336a04c6f46c13319ccdafdcf981a150924a1d90ec049458f169980612eae45590aed8ec2fc593578fd0de7cee84640c762b6cc0f5c03c0aa56c73a7c8ef1b805e6eb6be4a849ffa63e157f582092b010df7f9137f35bf23ee7e6b7761c0869b0eb951d16a4c59528e21659c851e397f7a4f90e49402c0f76b0aff30794e5261ed4f54bf736e4576746050c2f93367baaeeff57f01e3e7d4b4b75c4b693d99ed72e7d05e37a5adf087879d3bf1d31289d2a0e01ce6da3c51e8028eeb6afa2aa100480fe5035eae5208227226e8f7d154f3e7fd0f159a3fdea3dede28f50c478b8c9a12c3f4594ffb17e7169557ae9e646f24e4651b75bbabf1e0455879f3c6f2ecb8169967b9d941ea628c49b11c61198b2a3be457850b617b8ba0025fda7bdf51259277b0c40fbcc540f138d2c60e351fb3694c58d8e340a53be7074abf24342dcbbd9379eb67c8ff114148b0fb241d86898194692f7040db63692e6f8309d868b096fd45ea7566b887f790c742839d608fd3dba61e8f9159f08455c9d26f6fef53a0cae0476edd492de5450e98a0852bc0c5087575a5f5a0d1925207e678b63515176e58984c0b35a914bd80998c2070a2e8865387bc9cd60e1bb05bb7b4ff6ca4044338310a753117e469244e6daf19668ccf2859e51f7addf80b20fac141a8802140e330deb1a50f1786062aa7e2848e744009010a29587f377f27ef4047191ecac227aba331c7453e567ff21301862fc2dc3aea8af31ae7a7ae62f9421ec947f35f463e01b4ff3b2ab74cd2332fb8df31a4557cec99238ab173479900569d6f84008bbe7b78e24d7d5fa8ec37ca8fc249e94d7932b85dcba3a0963cb492cf6147a599f62ff944eb5e5d4ad1fa406c1fd4ae705aee32468b9a1cb1248fa68daf6cd0dbca31393b3d535fa7cc6fd468fcf2dbe9e4835fc6909629150d45b049eaf8991d4919efd4f572a5ef28d7cf047c2fbd1063713339c073f487c366e6187e7ba8f68081ac192d06f56409deff455bd75aea366e370164bb0d7c6620075ac3cda06174da72a14ee79561081f52f00ca74f288f28335232f77e9c57b67d745725131b6d670f5439b09a29ffc6f7a99e1cfa7aed0a75b5cb890ee7bef640950e577e6ffefde421a3d41363c22a3ddadee7b0cddd77c56bab02cd4a083c49e4bde60ff2876285e5efa1a5a9e78b3afdeef149cb2e80cdc41252f741af116b65486bd105d2905c4a22946b319fd43e294608b10de358efc1c8d77a96f76a7ce163928fa5d9ac805dee4f7b53d46ec574119ea2333157d920e8a816b2e3c694f4080b21555a62b4e1d7c8d96ef6cd85df2b2b0f73ae2bc8e56fe1205a71d64e4f1f9ec45ca711e983fb5b7f09a87356aca225dfef63a8529efd976531bc72f65c6290219cae7b04e0f8f2bf1d8a9100775e3fa0b61bf718680fea2b93ae91ed21bd4668ef6d9b8ced4668978a92a1b308e69e7236e53fde348baa7d21c9dcb1dfd11b17168c812b0a42eb8dae77d24f9d0f947fc142959e20e99151730dee18b7d399516c88a3afccf90d78bbd2f2801d8e90d4ae1cc269e763099ca07c0787e8c49b637bad7c9db50be215dd7ebd5d328fdac883ea6a92df52b3a5008b07eab278df6c9055945bb79a234ad09657f27071c648a61daa0dfb5991c0ccd6dce9e8ea05af648f7a4c961788e4b1f77dd0d4b64b975ce02eecd8bf16c869bb975053d2baf0f4db2cd1fa96f0f0b52a4b73c8f2f6385a9aa35fe80890f4b692293b6715995739f23b7acd5af747530f186c4eaeff12942083ac9dfdf40f4ed1fd30cb2425b736baaf9a1916bee15f057742a5814c11af2792b758e95f6454bc19ed9e6a7e54944047ad6370afd4e9e554d54acf673f053ae2f4c7750df94a9f12ff47fa1c267437e2ab29fd49afe70fbf07f37affa6bce9f0f78429f690c3de179672a7de4cf1388ac9889b604bd98119f496e71b6f7a52f4fe9c0bb2603393ef0c99e8dcbc4ac80e2ffd128ff789a79c4a449aad1b171e901ef3f8ae7778448476ac0262eb72b9bdf4a7d8913aa2ad5871b70540b1ae2a58ec8da38937cef57d5164b93d02b7484b72ecea113386c164d0904f5b2e56b4e7860979977d95df24350077ae50e08358a6cbc3f0c6d423696324ba534d5552ff36acd189d33aae47a0bd581b247d99061713c4bf70a3ef20fc09e8797562543b6e11c983f49c395c7a0f6462106d730e2aa481ff3a5b7fed5e0870956fbf9b3dad90836735cb6c985807bb81c94acd51cb5351364e66fb25c72566a44a5f9efbb9f2cae3fda0eed2d66529b39a96f6b52b103dde0e64f7bb45027f0e01316df5e6d584bc44aef4d181d54bc9bcb2eabeaf97a0ddb752a01bbda0cb1d5a7e19b4703e883fdc0ec3ffcfac730a56a6b18a0e676d13525816fea8fbd5f894dfc103254ff4cd30551ef2799f7f18aa445532d5b0d17ef0c420694f35317d0dc5c148e38492f6f2510eff433ab241a6dee1b037fff5313cc0078655c9d2abee7e4a5cb7cf6759c22441db35e7cb6e493a6515d64d65b54ad63567239720fd47c36f2c558f9b9700d4f1b57626f12ab584dd652e68ec34c469df8843287856784cfae2f1b373fb6dec54d8a16f92eac5d6d4ec7e88252c9d4fa38c46652dd5d4105c5835097fc4aa849d32e30859c76b41d1d757e7e66b1e4e66960ecf5d2ca184ff930ad29af6f5139c68db02de18d633313db2080cad90dbf455482e5c695d76c75e2653303e1cadfd2e5f4f0d027cdd757c18569067224db7844da4a864f5d49f26317f7fe4ce9663cbd3885d07315f8cc8557a792ac8f9401c87ee440dcd9657fd5ca2b492939ca602b3925adda06995c035d4332b912bd17b0180ab334ef92e4ad1ae223308741e2085f73679a12ed27dc7eeb2cdfd44e67b2041cbea3392b31d15e0d637a1bca0ae61186ea2d6f538e9074f8d651313e4b661f9ad18f0d4249628055b9ab8630767d6603acc5465e380f3127f629d7484bee74892a37dbc688dbc80aa7350bab744dc2779a6b45afb2f96ee6e51b11a7d986176c1eaf0722ab53e2b379b55659b78aa657549573615ead75452362fbd79c1ad9f719b71785e0727a211fca2b8868a9e823d9afe26b5a339acef5c384697f76d886fb18b3a56893a4541a714665ab124844bb9f2d1e53f0e1013bf1da70f2ac326b2b7e0b14e82c4b55a8e61827c9467e102f98d1031c3d82c701a4a9238d97e23d75353cf356f9c06a40b5dcb7965e8acd553f5948cf00999cef403cf15edd499a2f4889ced0121d0eb40c3411449bf02ee53ccb4537043db4cf89c146a3c9d30c2aa5d97ac157b5802e4f932c0aa604ed6a7c3e61289af70ba510e16185db171206c8e6bdced9273ce04035f2eb05de5419a13cf0292ea2c41e62a44b9fc7412e5156ece7f36de133d88c5c00877bb63c5d9fa2f624fc1a6178e15338f975a832e02b6629d78e3dc89534b386d75c2fe8d18f19e61996690fa3b68c00ab8a1eddcd7355064a63f6dc52b5551114cd1f10173e57acef47ba3ca90e1d1d795d2e848c0dd7820cc10aaa50b676eaf861e26ecdc64f028a34d624a374b7c44d47d92e0f7dabed05c3f7b786c21fa033e870b211dbfcece05b1375395d82403b791d7319507cdfb6b5a1fef11a4c3b3c3cccfb6d837db66d6ec8af848e182856617a11deb173295372a34d397af14ec31e6ef733dd79c64aefc94f08abace6ea9ea5ab8ca1e8a586f0d51b72ae12106f900f1c477fcd0f4e8f3888390948a9a703a365f1e0540758958bc06bc48fa1578dc3fa2a241994f0828d5bf023f8d58eb101621b124963ea302a76bd0847635d5b8c407963c7969a69f6edb9344266cf194bc2966c2b1d37fb07c42528671d7c28feea6c39839083fe6fc8c3a4c5f19871230691cdbec3f9cccca6962b0888e2f43799c60dba589cef56c2d371ee02652bcbc0f8ca0c175297823ac270e291df27a7ae5d146d70c0e5a51112b1d78c94bcafdc55f3a72cf0f5d7f255e0b4c28cc98c1b40d5e18a9065ebf409d6f253c8bf3937bc9435102cf6644c2712a2bf258b94c333f1d39d0c19c13652b49c13fd275573d255a9c25d329443f2fcfee87f8972ef57be454e0a33dbf32f3c7de4f529523319d7eba5a38de4bafeb55565f14f0851db10eaeaa1d61b8e9992c40ead58b931188ad21adc83d5ca0bb2b5756f844f043ce8f59a2cee7356976c943a4a63d17153153a94b62a153845f49e87085bb9a0c522a10c49f0b74ce82a6e8650985ad6d3017a5862cbbe552059ebfcfc6bdac043689bd7f8421edc7e8d7fbecef1c4c0a0ede641708175222341976811e0044f4f9162357695fdfe32601fdc59ad5f8562593636c5c5c63d874884dcaf9a4103a6777537ccea3c55f306da8112fb3af677dbbda574a3d52c55b3c2fcd8f1fce9f8295e423eab802d435244e3d8f0d8d40974ef1498ba38464ae329907bb4e92395fe07be80e6fb27171cd4315ed9c0c913ae09936b8c20752f61ab16ef2866a58d89ef724c8751223f3da63fe24aaa0f3e7540e4f55d1bb8c40866ef2e804ac8c78d9bb322e45767f2157171a63c72f0036cfa28c373bfd3d21d1515ec1ecfb42151a5c8de7d48060b4508fa3c50355d467c87feafe35da60fd4d21292c44b0d17160b65738de15203d0ae6ef2d08b0b4e1e27ae7d2ed892ec0b2da5e2fbae3a70622d2c08dd3968775b573eb1cc46db67cb5de2c61725af1192e74da2896d7dac9809993ee1d84f62785b0556cbb3a45eb3aa830e668da28ccdd87f2559218efa11457ef5a7acaa4a2148afeabb0dfac9ebd1d7b2d3a64acc4516a16c7b404398998988e724d10e6711c80276ce840b4fa265ea8044a98fbcdf2e6c7bcb52d732351f3bd9449ceed29abcebe90665b6ffbf2bd5fd18337b6208927ccf9b9b857f70f1513d9448f4a94dae91a0d76a975476455397dec7523d1e5134446a7bfbdcd32a25f8a043d086123380b9341adad50dfef8bce11cfa2c35c239f089bc85c67116a81ca0191cc59c79fb1e6df3d644bfcf62212a138610d4831a7e2149c7164782c648a3847961b28bc6f54de7af3249ad737e79ea7b7352e4715706ba8a72fdb2e75757502c5ba2ddd583b2af543adc5b7739fd217564a74b75f0e6cce117d74db261ca85cb805027e81d4aa055d7f72fcee29048c84e3e38880d4ee07520567a15baeaff39346d3c123ec2f18c9291b84bccaceb62e474b17a4572a7a3153833800e3d488904dd465672f720ef09d05a5deaa708ca8c4a0eedbaa7643ec1b7ecce815a910a4805a4961d381c7e1521f56fc1e80fc6a20fa800f79ede572837bd5e8483b71299df24152bf882f543ae6c402da105b28fc59a7953594a8dba8720f9af185357cd1cae6a0d2dce769bfc032684fc5729b6e54549cfe5342829ea1b7ba3fdca782e28223a964c28dfa212b1acea887af71a711ddbc1645b77d72d2a85a2dee5ce2ebd091ad56202ef2ba4f04e4962093826e48d3fa7de7087099760aa5cef2713563095756d99e1856afff3d69068a7e26d04c6006f056a8f0a1974760ddcf188c3e48b9606022576fa52e17e18cff2277c6cb4ab8930cf66b80155b66f7dc90b890d1630633ac793a9a528d667363d328c6a25865a8b34204dc665c20fab08b369d5da232f3e0460808a9c31f3301bbd229dd2e78b65d7fb44cff4488e6ca15a42bb3b5ab87b6c9a04d7503673837f75cbcd46e68ec8477c06ed75010f4f51ac9b75989a05499de6568cf84b5710f0245a0ed3d3e1ae2c60676992473d6348f37984083c58c9b02ca56f2853336b1090a692e26b51eddcf0af5b9f1c7b56865444541af5330559e7bf9c50bc4046d5aa841817d6c215e691193e7f34b297b46843b97959ea8d46c3208ec492a79cda9fae8b1557d6909742c69ba15ee0393fee30bd02b300f294b1f98b9d62b41ffcc8b64b4484b0af7fd420072d667c412f847f93e7dcee386be355c0a992bcaa3495341d2d14a6ff91fff9c13e88c93ae8233df8204730236b3385a370250dc028eb4bc2a5d651f362b639b72f0b702472c3a89fca19d54f7656a60a4740abd23892145d1e331165d2b881fb79a49eae0fb132c9bda657bbc988b63f790507f22885d9ea431d119f1338cb3b05909a9c48f536548c391a1f883bb447e4f959ddacfb9031bb0fd3daee19c2bb51ba03492b5539cd21f8be3e60ed0e9ac7acec940532e0ae27bd4f44e96464686e8a5efb00bd69fabd512988818617e69835c119f5da66e45349d40f5ba1ad5c39f3f645ed37496f25af4ed49efeba9295f4aab2b5918290028a6d0e0093010b93a6c89106a870325a0a3c84c0e5adba282a73ffe8af4a86f3d3656d618b3b7e4d4834e8553edf8b4681d234da6f95c340cb9452982c5de42b44d3706097aed4e3e767ba48c4882eae09a5fda62dcf3b75f1f753fce99162153fd7e1b7e9a19c9dc2a6a3a6e0a71840fe48bdbecc3a81ddde56498cb25dc595e19d5eb444c5ed7d540ded0a327a2c75f0866ff358c763a1b7fe5249be76a66a15067ff7e799287684b475d77618b97605244e5daf39cae6d5e442d456b4e47ae212d30b7912a4100d84b732bc6b648d119f10e27e6759ddce2e3fc5ea017ea24f6aadc5ffc5a2dab69777e96c3115d0a25e23eccf4ff60a96b74bfc1d706f4018a9fc0d48bd3822daa65c299b58fcba4b01c576b3657d3019bf8fe81005d5b2f26b205bd34b87d312addb5148fbe852ab63b4f24f621614487e70f1264b4e0f0c1b0e3f56be391a86e777c1a5891745e5f229de00cd17011af4a49451ddcf2ccd66b273aeb42b34d12d836e575f9f405635d3a29ae6c9f1a5f632f1c878e2d3752c9965ad8683bd09b9b01fa336d51961ae7103a6729ad282ae2303e1be56b03f0de6d6b6ff48f16f6173715df3fd414ab21dc941a574e47749add6e9751ca21efb0feba9a15c3492055c72632ce488199228b6ffa22f2e167cf238a7ec06c1b2f1326859021dcebb20c59626af763b1986f67af6df9e4d8a18ac5f25490910aaad8e71c79d6b7700bdfdcd8f57fdd34833c55bac86304c6ec7028b4731ca207c3179ee09f24cc00e1984493cfc2bd7b203d3a8878cd00ac8a35867132a5f2783da374e890ca8dc174d5f3e1030f7b15721f65aaeb3af6c845bcc33e0cf606d211a98c6315254ea7213dc9a7ff8c773f58325eef01f7375beb84de5e1c02fd7a829c2916077312c8d0e4a70ac4c166a28362580f36044b57abac48f0baabcc5e2d59b661badb64873ec39bf30f1b0c2dc3bd922747e3fd61922ac98c0bd052756f0c4bb76d0575d3ea1e564a5d69d47206a1e1a89b0b031123abb43c9d5943bfbf01f9a2e65a65ad4e0d9e9b9db0a6f389c0913e1d45d0fbbdc3532102ae87ac8c8c98b8fb16a5fa619ffe04598b32a71013d8278c2ab1c103a85d118d65a3045a72c8136ed5fb1b1462e39f1dfe5db85fb370463df6ce5cee2a272212121c9e3eb4722505620e11319d9e49e0926377faab4654cc595b283817d62928538d7eaf88203f279209e0f473191003f9effc49262b7960d9e5b97bf8f61b90ef46fd5c1b2c364d5c40aaa3bc8cad6d003acdd22dfaf076ee86901be33ecd6febc2650ae6f1f3e4d783358c4d17dd36538884fd5405ee603628ddcf6f2c043f5dd98e7680c79763f19bef557dd1349cb77e5af0c8cd038360f6c109dbb4b3a553f95d5ee2d0923d137beb153c77bd4169dc65b3b0e3cd7f78736c0db5985628a827b00365d85a0888d339877d2ddb3894ec5bc47c66365d61de0417cc0b4dec3e6fea9391d31db6bae073838fc0098a2e0d5ac901c53a052c08eb9476534c17f4acf430bb590c3dad5aa70a67ac316a265f2ebcc0fed760f7b0d29d0fc654b255b1b287caed9102fae4090c81b019fd48f98139a02bacb27a8612fba03cd65038720d34553baf5a1a5ab21d0280ca9049f5428e4dcc3b9886c21a0efd14e592e613b33876de59709311e82fcfd13ea8096c8c72408c4bc29deddb14b32f34e71a3e6e8ce9de745d4b74f307238b7ebdbe09711f7b3dbb4829a212de20dfae7dcfdaf3f2db5206d9c6f0a383771fdd21df9da0606520fc1c17c2a774b08db7c4625e8ed0d438c46da9ff13a8023c1921d4281b3a7c16f34a6a2183c7cb194ef5329e6658a6f9b0e9ad0ebdb3a849662e8dd6937b0d0ec9b407393a74d69c05dfc35e719b4994535cd325c66b5d91924ffd604999dccf3ac28da986a92108aabd39302958fd292dd94a3d69d04fbd08e08242d6c6ad51c99514f648007dc11fb3d60a032097817f8076c958c7f8f0bbe011854e6736bcaf9931df34cf8b6fed006a5aec227cdc375be86eca683a59af5f65593f603b3f5ebd6e2729645fda24c1ec352fc837cc84b54380fb1e361187c9e48682112589050b17f65d32b2a05cd9856827a865f4ca7cecd32742bd70f7abbad0806e0aa66fa3b6110614deb3fa636095a564575c5efcbf17aabd888263effe750e8402743821ea98d4b679c16d7480a302e625ba86269d5b38492471e672661640f7fea8f3b9c3cd86934f91e195268575d6ffc4ad24990ccb66b4c0fd95616a91ff2d778b21c55daf7e152a39898061509e7a91d56789332fb98e609f3de34e613effd1b9f43ecb86198a58ce89392fc39c4875e9f14da9a30afb56317b01173c240bd1ae1bb5619aa03a913081d2383b80f6741ef526f9b84aa03bfcb5356f9e453e417a788fec3aa8180806b6970f1a7815cfe9b12a7251075d4c1469e46bd3359cdeaae51f0c9b73c1fcb9608b456b173d3ecf6aa46be5cfba480bd68caecee42a980d1bad8b88f4315fded1aae4a042a475945f8e21093f9b21d0558d8935a95685cd49d9406bad525dad9cbe868bf15d05eabef3a70b95563dec76fbeb2149d080df859ed6e25fe758c780b19e54bf4e579adc2b993c070ae2597e0e6377c3d5135278d5eaab7ceecf3df4ad0f7276237f892bdc3766e40fb8e144e03384d712a31c5a3d4e57e7badfdf0fa923d27e8f13f5afb0711cbc1cfe17e67ea8c76516e748bdc680a65da86b7bc6609c4d9fe1220a197f6a67479ef31ac5e84ceb1cfdae15d654b95b885737206c904cb73a8badef3129c0cebc7390509239741780123535796d628834a972ef79f2eff4282186af8266b993c7cb31806cea3f7a862e69596c4d04fe705a58537e8088969400817d50240ca5bd509668f5de3767c18f0f83dd1954e854026d1a58357ee68a9e6251f3eb995fddc667b6fdcb3bf6bc86a1915be85b3b6543c016f89cca3ff92226818ef1a979de2621ef3c9b867a02d98d944eefa75aa180d8c1340b22bcf45725d70874e2a466747b3d3a287984eac074250dd4261594d903df023fc8ce92d7b4e52a7bf6a751cd02ebaaedcab69d11e5840cb36fe76cd8eef6ff24c9cf31f09b06a87a52cf413928579d55fb9cfdfc3dd56cdf3f29830afd4bd7655068467f1f446d8c099f1f48d55ca32763aacb40b37fd89a410a84724fafa9b5385b600f122f3a87b08ac894cd4353f1f5628073826188ca7d5fc5d1e577038e24cf70bdaf8ac0c5e83a23e9b2cd09a7ac3f37e5f084f1e8e00426a3c9bff22d32e5c163192452b13d97c1070608e67a33368d11fce1a061b6ad587f63241dd06855f4b1c0a6cccaafd44d37c6b1bc7f492914710b9c586b7cbded304d341e1e771bb0ca2924f25e921636c230abc8c3f49a72e6c4edd510a674163d366af2db164ef39b22b42e9ecd124f2973171cb978a78fa74dddd2e65a08660968a4ce9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
