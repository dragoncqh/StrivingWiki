<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4bca1714b8984f6896de6f367866bf209639e189dcda8e9d913dccc349c72f0745fabc35de3f349b2a58d23d35a24cba4803394128322cbf9fe971962a7c27297c048ff9d472439ef2084a518cc16c4abfb6129f500fa54559238eedd903d9caba212bf093b9d13bab61f1b743e85c2417c8628849755f55991e63cc94d72ba9e4f6aa4c4bb8e157d54353881adf22eca8152422114e6ac61b47c1491236f4c213b00a9c44c31cf9d91b7000990e3ec0d1ddafbd65cd0d4bd834110c1e59e4b498189dc739c81b3bb68639ae35572f9ea0ed59e72e27945b756ce5854db9a0021fa379ed4f606b22081a2b4f20b081eac47578f366c73425f1e300cb6c6be7ebc4230f95bd6f0e6050a37630e333b47f624469efdc3add5e424cfd9e45507db2e9c5d6ecac084eb6187cf5daa377795c82cf7ebf16a67b44fe4e6f168c9ddd64c42975557963a4b5b1953798f461007044a06db7e4f5b076e443f500b5c951261469d424afc22844405ed90aaad9da0b0e7f0ca88f268dbd5ce9925d26f867766f4dbe36a0e1dceaa5f8552cdd56a125d66986bcc3990229b17fa8bdb256661d9b761fad7ad63174ef1935ddd2c8431bbac1c6922b0a9768b9fc746f3e8ad0a4b58c213f7daf58cd747daa01b40937632c86b89367081a52012fc764bb147b0b536816bd4ca3f18d62529343d2975357a9635fe2e1b1c95db8723d77e95063e8bc58a34c4f61a15ba170b0d014aeecf0930793c162105e82410e8a3a41cad4eb846a8be66008fc05318e14db32ae2d8b319978a7b583fcf05a72e7c0e4f34e819b6620b62b42c71946323429197016dc45bf5eb64eb1c2cb1e9bff13d40751abb39964dce2fe3d16bbcc3bdb1263f624c61a55b2beebde0f7e38c31dce6d4fcbf67d8f4c197bbccd155aa7e966815cea43d73d198f50d354854e2df6501d8ce56a99624cae66abae44062101c83688c8f9cc08d34f01ed534aa98305c9c5cc670a208a28175d8dc4e4203ef8f39ffcd76fc9aafd8093a24758760c8f5e083dc0500a47a518b23d637a0dabcd2b9eec73b3911a91dab0ed85f16d5c239cadc1442edf03a3e8fd18bb2ebe4cb8377e207467111a32bb6d14179878b24e3031769fe2eb6e61775bad7a8f8260e17f594d69d86ab8e1aa241bff84fc70a1c769da193bbc26efb53f0d9ccfb7eafc0b54a6d2092fedd403fab680d826fe83a4bf0986e9bc79ca48612154dcb86a4eba557d7137cb7e99da3876295ef62476e0db9e3e466920a4abd50dfad590ceeb1478efe72d3abed7079d6ee946b6cbc77984063ea6933e60563ebbc1bf8eea2f4a49781e159ee2ab12b47a3ca347d75eca3b4b8f283d7dbb1e3fe58d11353547b7bbf5d0c83318133f63db797bd66194fb56808896c0bcaa95ef0e13ef0a437568140d31cb736606b454749a9d7e9c59c1b4d65b28272a079fffbbd38f1749866402c2c2f1c19f9a40f617a24d51609ea2b32375a99d46ba2dd67ddc52f8a5133b850e6bc9822efd92804ab3ff0337e0c4f463bdea6e5212e136080888d7800b6a009eee23489dfe38425fa7b44b6b0aa687eb1f14a7e88d9d093cd752707e0631f4490345f5e2d9d597a3f07ccaaf19587384ee6104e5d7116b2e65c652545cee286cc163ec5a6d02961a6bc0e648d298e00e96128065c129fd1bb6270ac003ca3f36ac3c8997ae06c85e295127607d64521a304ee520361f1bda4c1b2ddd5adc54a4228275556715581dc61347b13cac148292b73a633e73e6f02b801b841a33159f54c7f676c993a43c7984ae79feb31b901dc01096339da671d66abbe919ce6db6982a81b9a3f4f81512d04c2dae95c363619e35bbc165d8d7d058d84f49ae66b5072701dad1d533661918f533197a31c17d4654a5ee0cca779f5d27ca25c879d2b103d78666fad0ee31874508b21ba50db7a6e4cd7b20fc40af5ca3cc1f9af8a690c6e5ae93971e5a53aa667730faa0151b38af0e8ab1f8583896cfe7772d24d3f8bea4523b92753dba52e1078acd1ac6b7f199ac335cc894eed1ec6786cb45cf1ff82916513796cd4d8376d4655c9abec5fc146950ef19e03390374caac708c41a143db7380db23be94fe19c2a7e329a190a1bbfc0381202088acefa2f50b654ef5ca3d81ee15f7cf3392676a3110799c5a9a0aaca2613cfe47a66fc6a31531d3bda54afa9261b04ded9eda8e374e69a51a17ef374ae0d970bbca602895247524d4d0e1c1fc74273c784ee862b4e0aef8e4b38f8c83c9bacd682befb454225c9c5aa324e7b4224a13abdf8912b7e1c2c58c9bc53bb974728c5b41eb56bf8012dae109635afae5162b3034e1c0a81859993c83e04b89baaa416178f42fd57462e36239b47f19c20ce8c5234b80c5023dd10465f7bb5cb883f37b2de565eebdff397a559109735ac073dc12f18fea634c066e6e251fe920fe2dbaee9f4571ffb88961b260aa38c90bcdf1d2d624ad93dd369e8c93d1ff83d63e62b0090b4268fd7b92faf47b9d19409fefa4899d123016541da9d5b591938f88f70d4a6192320e82c91937efd592568891ca91000dbc167abdae5a9577fcb6ab60bd12e8791e409bd4be368a2f00263b67a89e00fdcfbb4d0a082a7c7aacfab188347cf2c0dcccc7248b92e112e95407c2378d45bca99ef9873b2a1fcaccae31c46c0d47ea1c48e8b8a348a64544036bfc7e9194b1bd10ce3d788d7a7af389b359724da40de5c60a6bfc733cbb9532ed0cd00fdc41b01d4094c4d3f939040bf07be56f4fa5243b4d05fcb94525fb79eeb54c6372710659394e1c6d01f361ba202b1e8b3043986e2feed71a965944b6459eb7237b28c8fd4a748a1f52b32fd6726bb1d003193598c64c819887f56eb8f3da543630f72e1849d967196a178be5f97953069aff9ed65198ffec5898da752292a04def372d5246c71ce87581220dbe2e26b22627aa2c1da2db695f8d0fd19c71fc114b14b370a0a77e2da7c49dcc13dff82451f7f6cd89738da512324c5276cf2ae6689ee8fc823e0e940a395e4221de3382aadc4fdfd0118d9b70562cb1b529952b08a8dfc3d0df9cfa2bbbaabd45a43bb351f34b764050284049102747741c3700073744b142d7aa9fc259b2681fedf7259d3fbb60a044039676a811baee2ec2bd704dbb50b9885a63b58fd21127646be20707695d5cd80b778e04cbf4254e62bcf40a8e421ef43e248d1c1d80962e1091d92590ec55d7b3d8dce8221dd4ba5c43e1b09e0e8e63c230760f129f625cfb650b5ddc3d8501d7e7d4e3c250a2d836d907e71b5f397797b2cadf3da49b2ab6f1aabc8d0dc36d4ff39fabfd355e746a01703f760ea1ada1f423996d90b78f7a4b41dce20f45702fd344097ed638bb618b6f675a150a6e0e8492d073149950a0a1484f2abe7de04f653566b41499481b5830b143f6662ef8ce0cae17477a126b45cfae6748eb4fea7d68801ace902a26255a11107d9514c66f518d147f3ea3152c90d0b2276b9d56e5242b39ea90b54607e95f263be80b9509f5071b6f2547ff823da65ce0675804f063f42c68af34c5b824083e79268a7bc1c97b11670dd5be23fd481beb693d6d80693206e8e064373d3d5e0821e30a604161810053178125e69c39c85595b9d7be7cff8444eff6601a545179e589eb15fd481dcd20e8c00a5334818bacfe05ac98a01c62f9521ca732199719638e84c21120f3c0de1c3e911ec6af766f7cfa9ca5ad277fcf75786e00e3d17a86dfbeeeca00e84fd65c5111d1f253bbb575e299b3ba328db89485d164bbebb4e2760e71e15601c463df34052b45d74a6ee97aa84ece986172db5f12a9764feab58e7f55e0e006a895f7b11850ed9afe61e0fe9d90f1dc31c6e7027d7ae57e0626f5675efcf816cd556bf4cbf17657aef331c4d44e9c82226f26754968461a6b1336dc5965a27660b1fda5e2dd47f6b7f92ee84f6f5e9ffb8d823b3f1367ed610a9cea6d2f9e454571cc9c46414702bc8f20a18e877173fa0511a5d081d6fac831a01344a2aba1f8179a9bef8c5a8eef0b9c9d061d5e38552f7cbf21e8d9cef03c80d34ee6bfbb8228f9014f701913c1d3cae58f43cb408869770e0aafe6c5c14fc57239a5c761521314f91d7f141fe6013f13ca8d4221c5c14379242715ab1b989cab3e017423a6bb485a30b9b29b2439818bd4450269fb6a66659c0c9687e92518cac2539ae6eea36ec805326eaf307bb9e9d41b7fca1cdadfa15bb5a0e2db7e6fc96f245626214c32df0de69cf375bb539b1d299ba22215c29ebf906fdd296a82f008448a1a9ebdbe97934eff2fa25a925ef046c7204f4725b0eaf8a4aec49448d8e390edca5068c3486579309880f5d19e501679b8940cafc45a847e78438f55fd523e14bd9946cd1909615bad1817e78c0d1ea00287f4039d41c5e86f0353d9df9357564864356daebabaede1db3ad4bd11da28c2533d648327a91d15104da2617e279897246aa104b882fc7d9c01156facae3f2bdbcc12dc84e279af16cf0b972d8d00073a082170b8636f186f72c8f50962b96a10898120be703ac3d28d404bc6402b4d3b988926e0be019f0ae89435d95045534224259a3acf3ab324a47a74a6500045043db873bef786d4dae7e89f0c08e1b80a5fa47af42bac68e266793880c0a5d133b30e3059416780fafd100299cbcfacd51e94943879be48a2cb891bc319e5208664c7b113e737dd14367e8e09c2eb0aee52736a5590437003a205962cbc88864122df41ae2eeb4aba76e632eaa5f516e27321e157e9140358be7b7c37db7f794da19c54acec733cb15da7dedce9b89cbd7927e22931aa6e715f516aec8704595c2806cb462556c00614ba0812fa1feef01b921a6d768744d23f6ad332981ff0d56888e6cfbd8d5d4aba32c3108f45dc927e678dddcdb7a7433298d47b14e29cb56d2336116d4d39ba86b3a805544a2913a38e0e31b86e69cb795a7c124b45113bbc6a57f57c2b8ecaaec710e128bacf9a3dff713751d6c912634fd53c5c6041e4975bd35dd0f1223dfe98457a4f5967f59572761f8f652d08a62d915f6456a907c0ca02d72f7c6f9909c2372737bf34d4123dcd0accfb9a6470179dfc2196632348ed54948648b24e8dd63d4cc958d32a4cd2d81d85081ce8c10d1a918eef5c1263288c40515eb199d093fe66db9d8c79dab3dd47dc1856178ac1f91e6b73b34ec6a8a24ad20fe330177be19a2214e78177aee0b2c0a0d3d58ed7a333410091ef153c3d41288ebc2a64d79b9e38a97e5e3eb5deca8d4fd20231b5aa4e75743c3cb0b217d407a5cf7168ed001447737a4334ae7a997b307ef476ab5096fba948515090648511f596b2b58154cd4e41d87f7906654299c65956cd31d316017db4504c7578394a7cf8aebe34b3c173dfb3bfb39cca6c3f162cb3fd93fedf3b2f2fcd856887c237bb17f93325a369d0803a8f8a876f028df0db1cdb2263cfd85a383d8baa97f81b46298f7df649459029729944ec4b0762d2f8df5c256cb8a8358c724d6e6deb0823989006c94e16fdac07ae29bab2502e7c779ae15ddfa53ee3daf8888bb3355b35202def7e20d0c3c7fa544282901e20569e22732ef9de7f12114d80fa5fe2953ca05b67696ef63c5bf371c82f7b77efb3d72dab7b0bf54074954953950892c594bee2c220264c539b3b6de552702a7c2350b92d568d2f537fe9c861f748790c37f07edabd2ecb4012c607df8c68bcfc18a9ea6fef614622151131c369dde63672dfe55e63f3e2ed1aa45d3b84f96e0f8317fec0e1ca76be402ee5a715faec23da7bf61c3f79fffa7caaf30cbfe556c804938d1dda71eb1f6929c130cb89f767b84944c7dc545fd9153d479bcd86fec71e8956e3fecbcafe0277cebdcbca92dfd47c3d5b23829f468336b368e83d288b4f62d97a2f8499af11af215f05f0ac3107e552c21ba42291682e3096a227f4281f248b21802335d24d42616e3964b035057e9ab324d8596c5f486a3da08c7a0ef39504660e85433f07a64efa745cc9e0afeb9a3bd89343635517d3da1eeefade44a69e105a21394f3ee4755dc1457e4cf8879c4046fe5ca2d4ee75d6526e08491dc9e8e4e2239f2238f5087cf4fc6481d80caf10752550ed6d02e0df43504282fa350c7836b6b7438edddec548bebbe3a42679ec030366976b6faa7ba8f06eac54c72270d6e21e7fac9328ab8246f3a1c91162db975d81d44ce975c0be5b6638e8977f1ee084a5f9a4a972db162c7be8d9ef5ba8b0177f1529044182457b015559aab525310cf98b2bd215bf5a67b3566c0d3f015ae97d73196ea9b24ba6bd43ef8ab2675a60020498f3653bcba5c0dedb51be0ba1f0fb290d5aef3e039929008e9bed28c295317ffd352874c78033e9018893e01fce0c3cc8d1688787ec2f5dbb769a77e13a9355e2c0bed81d040846e42a915b77ee351b9ad367b1e526c7a748678633a830fc8c9353ff5b4f389a06555a3447e6777b6d9eb765e7a27339c3c82e77d95ee78cae3eda126c945d23a28d13297a8cb4ae93973e39ebf8cda527f61cb8145206a96e12570f4b3d31a19795e70db0f3b693e8f94343b2fd4bb98e491ab3cb9cf71dbbff274d6729aaa2cb095238d090a16ed46a76a14509d75e8dbbeaa345ec22872c8d50a41601242d0d2e1cbaf6f9279d4b3dbd1b7cae353e8e570d9d86c9e988cf6cc009878f05e2a0116ef12bcf3941b32e10314491feec1d7e2e73d236d215ae85332cecb5454783a8b619978487acb9f3f374423eea7f253283e85c07e038f2e0f4a60388699ee8b16adf6db39fc54aa3ff2d0654243fcf4a2c75bc4ede5b13d6c3a635333c68f4f43149ec5473e8da3faba1f8e3c9ab6274a3f0d29594937bf5a9fe578b025f7ff229c364bd290b6b42154cb082d7d9635418a64b0365f9fd884566cb00a7b2d0681f55f6aa7d121fec23fda693fc1ba49e624b9d84b2c1143f3fdcd3f07910d88f78615f026e3006798316a68b8afc8cfae034a01f633f8b630f8394346ed27a140cdf0209d5f022c62be506c2728ef2dfcb6f7183ac6ab1b4766b07f1a60a1a9cde98fb2ab653dc0795aac1808829f52e288a2836828d2a396375ea24d6f0ffa89b8a57c9beb9df2b4515495cb323ad3d3231c7ab55c06ed9bf85ee2c64a24e47b239f88ff8bf970557c2dd7be13575e250f8ffed80087e3a322b27cbcff3d2289050fb2931e65e113cc877d15276f519be8dd1a11e4ca96031fb4e49179b47d16798e096af8063537372a68041aebb9696b79446f1eddc8434726763dea06bd3c811e43a316c3ccf2954d9aa21acc58a6069f83fcce977626b75803e676f932fa7524d71d89f6f8df9b068d27cab9a0c9d7d65781c760e769de659d8a212262157f452180a491c79fcdfc7719ab9b1b3c3c8bf016377cfcaa092cd663df06f5a110fe4e416669169fab94a059535f1c25b1abfea6bb2ac53e2229b559326bd59cac25c01f343e4436aaafb356198cd52de61ce24f039e5942d43cda1d6825a3e2b9c4f8c38e79eac0ad31d885aabca52b955f476aa8e4e465ce4e9ecbb50fcfb085fb29b1ca47476c303becf2a200471a1db5602490e6891768363dc6427514a0fc9b30c69028fa39a87583967844fc093df74f01870314cad4814e776726621b434aa352b090e9b87fd1659b8a27862996081972c0374f8d461250cd6a8b2086fff0d05040c21976a61ffaa25ad60e0766afc081cf760de89bc39adbd51780020a80f98ce1b82e72ba5bf3f069ed665d33a517ff5dbf0ffb72e2181d42926e31226ad2df4e4573eba45fe353bbbc297cc273325349af10866c389d57a17259bf5ce5f9c6d5494a997590141bd450d39f1cd5a4d58d90935aa2856409b0ece29ede4b87ecfe11c155ac0f7bf10eaa82ae9c7c7ca38ec69694543bf39632350089fda87f26bac1063b91d029ba71abad814eaaf5d95f42cf174791a03a3705ece2c8b77ce20abd8a6965e759d1aa69e3c3f78e360e46fdc8c83d39c600907f5bfdad23e6d2f6a9f27166f71f8ebddd507c05ee81b48344f4bada198e67876050b46d5913eccaaf4a11b59ef110f6c6d98f4bff6fd58c30ac377faaf77c609322f9ff9f10835f375b3eecba3c9e7cf14a161285e479c5765b1a723cc99f6a213f930ecdc9858836563120c9fcb1407a478bd15131c7fa631ddf8514e56ae21c2c8086c3fca9be19c32955253817e26fe5cd4f5ab63f2e5df472228ac5ee86ef60c7546c73bd62f2d7e658beab3bf192e76a0bce78c959e609a39dc3914f9fa8eac994299ce22490c4d232af0d31edff293c394d7ddb2b36b426100d5bda4d044d150eba8b532f83bb823b798a57a44c7be13f34cf2a564fa9b9e795865a78b13966286dda1f97372c3beaed8476b25762e18d3c4789978d9af52182ce1bc45530371b9290ae73970387bc45d9bdf71137858003e85271d0375adb8eef6bb77e49bc07f05ef6d72a8e76aa66d5f38bb56588c2696f54bce0cf22ebefc7098959af04ace9ecb9efcf6e70c8c26c57415729571c673da56c5d9621d3b68d7a308095bfdc8954b5557083eb5b8f500fd661d7ea732dad49e521784a045b705cec43d89f9a382e2f61ad7ebababafef9e0f8a00f0d33684924744c2a207fbe7025f91ebcae92c513b9be680317ba2601b610a665cfc95148ff3e43c4afc060c02bc498fb75676272e4ff9c0b6bf7368bdab13e47e1ac19531a30dfca5ff5595c1210136b954bdd3809aa77068e329d54c1799ba175730be5f0859d5c52dfa8e13d3532e82872276f5189c92f4036ffca3030add56ed8ad7f455bd0b5bc60b3e96835940e0f8dcbf5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
