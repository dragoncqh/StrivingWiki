<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f3b15b8c052cbd31d13746664cbfbe1ebaa979ec4476cd46dedfb1b7b772be66e386930bcc847ff1a8ff2884b7a71ae922fe1eb5846dd8aa820ffc0c1970759349bca64c2984b2292ad678b9d053491a57cde0facf3825eadb77cf690f75fe199546d37014a154a8b9af21ab92410b49dce8eae661cc61b3dd95de94af573244efd0af7cec893edaf5c00a4ea39a6d4bcda8c0451bcafd06e01fa16b3656ce5852c1c32cbd7894133ed9349c8feff00c25c37e037974ca1dca7b11dbd0ff0d200d15f516741970c16272d78fc902e85101c5ee05f068ecd437dd8c493d04ea24ba7d8d01aabb579106f4a245dc29c5168bc1c547f13a01f3fb074ce872239890d72a2cda18c055e4203a2aacaf76f8c8752caef38e2f8839ccf576dda4f5e5ade9ba49b20279093e884c34817c76ea3352d18ef5676178abb7f26bc4b7fcd23f7d7774d04851226425fbe1e4d880a2a2454319c4dd911a1e2b5dca85fed0ec36ba7b518456795f109a3d7d169b3c6ab4222c003779983fd6edf2f690404f4be54f70051a5f41997d9c6d1299fb5ddb974d142628732400f4c0523ddf985fa45d1eb22d140b2f087f1b5d9208e7966e330f2cea9b9afb868929a74f836554397c47c6dd0d5701a06cd1b7f96747d979ee423148d86ad52e62e2562bf44b29e69c49284b2baa0cb5ee1ab1a48e3072c4789398034d4c9c127978e3812ac6eb57f4cd139e265d06d64e64d7f1f15396c61633973543224af7a16a69713aa2d8a5894fb4cff5e1994fe30187586fdbdecc37d15b8fe6251bfdf3ab904a8b4e0931993e33195043c12fdb5132a6cbd4d853cff013f19285c844f4a2776c2fc855073ced67889228e99d845863e418bdf12e028aa5f831dc2e3879b4598ee5812beec0590092543e6f7258d18458be87000a97bd93eaa8a22264ea4a319ac7e45f542aa75aa12a4f55bbef0df6eea6df04b0f2a42c02bfa0661fe1f3f71de59b798eaa23323629ccb9303c40584a7f447463033d9981fad196853731df6580c5492fe532e0dc8348fa37bd70b28cfc108017ea3e6984392131da03f4fcb4b10287c1b890401fb645e00558b07a1ccf5dbf1a096e62b70dbd3bbdf562bfe1307b5a66e9a927f29f702b7ccc3f49dc550d8d98799e5cb33c6afdcb5c9e7dd0a5f5422e07818781c511b530dfedf90a716e646e1b80617a5aaa00e04154c33ec05f80be13b93ac613f768f1a83098a73619a76e831fc63497f600c1d36c8f24ac6bd9867c668c9fe5688b280c6e612fc8d8e82240566c83d06a6676cd7373fde063c1118cef211fb4456a65d705e2cdb3d03ec3f2424d24bc10905d70641590cd87e27df0603b9cc6ce0222ca411de23c17bfcac4d57e42fb91850972cfb680b31a2afa7195cf94a84b90d9e653f11ee4ebd6dd64e871f2dad98401b64e9d6a03c5e570d1b8ffa045670ee4c4a443d091e18356576bff861f4ff2aa7424df65b30f223def8e54ce1f6e7d9d1c7379c49943a38db9b05d7af2d1ab8b33511faceb42a50c708bd2411de92803ea00e121b5febaf42ca5144bd3d77fd342ea4703666dfcdb75cf1346e1b27c61ab493d7102822493f4ee45aa24cbbbe303887664b9231f9626ef4cfe78281551650504a913575bf6f6924ed09a282b745b5e6f23e348c2cddd13b1bffc0d6b8fac2df385ae2feba7d01f36acf827afcd1e7f88ab3f703a8af88eaa8baad001782bff807e993955c7ff8f95e0f0d1546df393c6ffacd6ad0f389fe12c09ba679b1350eac1ca8e387e5279689b41bb5208d2b8e4cb2769b13e42060c7ac77b985dfa0806e51cf8825edb60d326b62c081c8ebbbc7f8cf580d6c4f76d53c6301dbbd1c01359339bc3604d516dbfc315f7f1fc40d5ccad03a418978e096d292f6c9d55f421a9567259f95981f05adf864d9fe3af5400054872eb0ad52ce59a3ea59da738c93cc10675f2a6a16ee91693fa0f0a9e27b67442a1905087a0ffe7b3cc305d3fbf73f67f61d2636c49631367b273ca8660a653bd72903bcb5c32d4d3b7cce564e760b5d3072df29221de869f3cd8a2b994bef6a3492bcfa7652198c39e62afefb15602cfe41d7e58cb70f1a73a9a1a45894a8bbe1490f9ac0234312d25c888f67631d9896cf3e988986196a74c6817852cf2c66433a0594e7e0e3fa4ebad6ec22ca94e876c93a6e2f3613324133d4bfc7eccf5053901e89a009e59f65124311d1d27fb08b5204f9d724414fbfb817d5c5c6db08dcf44655e5dd781f9d79775f6c46008f87337741e4c6c22f041b51b3ad230d57a537b9d30f6856061ef526a812e73fd0669d157f4513eb4cf1454fdaeff3ce0e949cdfda8e17d58f45d5b0a9f12a4bec29b4d0721e51fe7caba9e13a6c6c079ba69752afca7e3548aa33834b7cc1daa8745d043d669a1fcaa9c30949ef75762de41ebb9ac960809c827f2b89ab5df1a6cc5777057baadd29dea7645cf067af70252647746be654b48d81f1a8b8e30c6f4a60e9c4810b668d622625eb1ad16ac2291f9664103e504a4be655b6c0a7a68f9ba513b90e27fde3abe9ebae26b2f0bc9010846c85e7b93045007dd2466b1d94cfbf3cd858ffcffb37beb3e4c4d937d7efa47337d7cb8bda7680721446e98ab3bc4c9528eeb50754a2960b821e495f49d993e81a7d538712de759eeb36894edf63121d93dbde7a79696b4e0f420a70cdb04bc932daceb59da3df40c1f21c0b43f6e1c87d2f48ecf9e66f59ea523877719ef89f242b61ad5e0915d48ae01e2e5cc2df9183e95a2b6eb4c5568d539912e5c12e6bea48464005ec169348b0f651a73aa9f674c5d8263e3924e67f0f193a9eec8641eb223f382d7197262bc586fce7fb4e760eff98641afc8138478cd7465472f78b687b7b7f9ef8a7fcfa1b7f7abc9adb1073ab7f6824c0ed7f487da4554e85f97ee2b124c786d6ad93f5393b91ffb66152df82786c22871f27b9f2f308c273d94cc305c12a82d48189138ef8b225eeab66f2963fb4d271cf907b63c661a7cc5386de5c68b836c67195dc6d4a5d2ec8562916ca03efa6ccd2f313604d9f743a04511e4565a7e8177ac59a898500faea78dd08b4882413196cfb7d6f7bdaebd8d9c081995eb1bc7d57366e631fa96ae03d99ab2ecc537721c2ea8e73094e5cd6b14f0caf550337510311e0a578a33eb92d6edc60c03d704f1670f8284d17018f7de1742b0ec9cf96497ed0834db3836a96a6b05c3a6d4305a47496bc22d3eff6c8013c8d4a86e947bafcad33fde6b37c168dfe68601df6cfa6ea72b83e32662c9ef989aeb9ffe7a5bbf98e32c69c0d469ee0be4dacab7bc86997a3a1ed8e5bc14fe8c63271d803429be7abe0fa2f5f17012d1bbe2a7a0935b0de193f8a364d84b5fccc7bac98eb0db29c4de41d82af50d3241098c5693680101535cbe3d8082081b05856a6e4cc2919b4eff16576e14580028bc17632fde75fc6e54d5878de001a543175094ae35179bafbbaee35776c419ba4faa517e2100c7c964d85d6c1f83a9b72f0f7558c51215820c9c34a9195b93ce2a4eb88ea8aa4fd01197b2ac9c96c6a4e3b620c543f5191a4929b52af57592064aa34eb4477028a8e174bc9312e7be1dcc52dd80f77f762bb4b721b0ac4b9dacfa91e7bf5e5c43823196142e78312d7d9abcbb73c4df5def6c3efc054d248ff2059a971ae75251dd9abaeec6cdde4b35b5106a323f894ad400aeab24cf2a536fdb914569e178f1d28252e501f8e11672fb373f958cf1af3ac438de748a64b407235f6fbe5360760a5aa1ab8f0ac25a0160e6aa46fde46c5ef80a24b6932b2efdf15c97a45b137f20a24a61b0e05f856381557e2c75009ff44ab9b753d331c1d17d1c4facac9092073ccc1a07aa66921f1d54dc2c7974d9e6a39ed40a2aef664597ead9ad3ce6eb0802131ce8d24c6fa631e7dc24c995ad59d11a083163fd55abcae4e2bd94b9fb469aa34c1241faf4cc72eacac6ae1e3832377f119dc685e416ee1fe51a85b51a43f518cedf46e2749c8f23c2df105aa97b7ea9af59a99da0db6c4baa57513ff800d678d78438a7e5404cad23d016adb98a141455797f7995fd9099ed1c7332780e2be666c0e304cff32291c4741f8eefc0244d961d56497926b0cb2a6e4490872f101e1b014b6a846ab74e4ce197a4dd9c904bdb64a2f621a4c709b4c7ae81bf6a1e8a4cb1e62e67ad923d1ce33920dff75fc3dc73376a6cd1c4b8b7d3747c439545c384c56ff03331902df15ba53ee77a6c94d6406adf73fc2a1497f4311b1cc35e65d0d56bd12e6edc1540b102d1f44d01a1c9b14a01e530b17522d78f8a56e13ae9680994d62af556fff274192bf63eecfbba87962f2b61a33aa136432f1a65a60760831fc4c44cbe5fc1d4202b48c31433904970cf14821d4555eacfa94c05d144ed3774edc5650969e27bf4a000774ec969c9ad1c0f9594d84bc56ae0397f33bc80634e147889ee6615b74ac22042a54f8b215af41f4d0720d785a76b7f128f436c65518b9886e577fe7d66b84bed89a647a5075ac82976bcdd5f158ea2741202949e960b55495579873517b19590221b325a67432303f214f098ea28a33c87ab568f13cf1d7119ae98520c60b16d686e7e363506cf3ebb056582ed4315a064f615a077b82f65c4d89fafc83194aec559134934ab666f22c016d304a299bebb2367e7dc3a74a74433297fd35f168ca35bf693756dd7e5c81e9343efc57339f053fef3728192fd86acf157bc425e9ac3f9a32f6377de146db37fbccc47fbd7cadc00c9a5e662ee93329148454362c5dce141980225287b0b84f929fbc39ce270253c0fca096cae4c292176be81e426ccc6ff4082ecb147a1bd50cb42de1f96d08fe43f9213df3cf2c2483ebdd881a273c2032f34b9b99960d127545704f9a4adb44a177204ba158114710376e84d947013728ce4c0761af4d33373fed1cf58eaf057c1ef972754d9a4c0a2c15e08e52eb82695249c30a80cfa3418717168b975e819e1134e82e51223d14b45fcf9dff98d6f01389787bdb2988948e82671c88508e133c9aebe7b5ba360bb12c093a1d5f7bbccce0e95fecf4b9bb5aa90fde44171b2d0dfb4a9efd6786ce2191b6fae9c467fe2d05a8bd23a332e5c1ccecd9bcb17cd233930dc0a67da84560449e49e069bb77b3f57b0169137a692d09c9c9cbe820e5750a96cc8668d2b309545ae77fd4c737f3562f7dfa768c237b3efb0c4fa339a51131f55e9d11d2c0a8993c899701e80842cafe48741a76f4aa57cce06c13cecc7e263bb1e3f1f1f8434c6379da9eff0592456b113d4c862935648d7b5a6cb58c2794d5e9913a002126fe30bad5e29ecd96d3ca73c9f7f5047053d2579cb786637c6b8990d31f584201db4b56e50501ef5fe63c7a666a9c43d084e07c56a4f843d0f467e6aca29fca372dda06df4accbda74a1db0fd3f03fe0354ae5e1ee496a6371f2dab62dcf10107fa212efac1683dad842d5b4811f5fc60b2a190e49a38a516abbc5c23d73b01b396a864de5f72d274fca643891fcd64f17ac30667934e702dd7629c4861c13ee3af355ac881a9bfa576bbbd31046fdf3b22f50200a3d5afca6ceaf025af7314aba7f4ae2a3afd8406831a506cc7c15632fc7226a417eb4c8ba2ba2b626d82a22378232cdd59d47de86af22494dbeb5479d011db59ba50f6965b8406888f687523d62a5e2c1d26de6a04744401320873b31b312a06e9850dc0aa62be451aa065c5dcd78ab262e56db1385d3d2a633926fd08f7fa34138421f2513e376e2649ae546e3d53dd78c615b9d5bd087ca95b5ef1dc01be0e81d25bcbbb8a36b1f6eedb845ff5ea60b4fc42d2776692a0a439ae0983c3956e562300b3c76ee07f4050f1a9a30717fb52e6f553412b5abd63557f5e19d754ed70270504d07fc13df1cc11b925474b5f6d7017149de787a5952bba2b8d093f6528eaaae3e43060868a1c151aed54b144077f26691ff5f8351c22abc9565840440a595e76eef3db5b487a7d11f939be63bfc451d0a8c194b26476fed117078b7656d7dc41c80537d91bebcbc77d4306256533e2f7506c7798badf07a79c3528a02bf80cb026b0b377162a7b5b0288a917eb8339d9b04ec8578d9d8db561d8751ef5109c9429ecb24d8745350fab5551bca426340a64c16ba0e4115e8f3980134f2a7b55fa871557f52ecfd4ce46b0025a7b01bad131fe79668d63df0aa57099c35085ced0531f478fc98ab162867260d30bc270ab76aa4d2f3ff0d0046deaded3ea25af05369fc4aa61a145012550a90cf70d71ec0b3dcfd2f452e0e63654d1021b78b72842d1c6425147594389cbfe2aeaebe01edf29a4ce3ee7c70d695b27c79677ac9431089c971a9bf60458c073402eaa6c9d2da0a36d7fb1234b5c329da04f3fb528cb82413f3701d2944e4f5d9052f0484e6144430f1497583eab03c16d851244144a6329ed5da78d199dbe1f56fd902c7190c81bf95dcef0916f9ae8db4963880e9db437ca098ba969fbebbc01b6a40e4860795c0064fe90a1c639cdbd4ff6f0cf04c1a2c21376a05fc797299646992c645551f6dd1bc22cfa1fe37ee872a1c95b7b9f0e8703008b46b83e3724b1af04bb4927ea2a89d24114cbcc6aa3a8b5a2ae095637e38f8f88466076b1462847b3cac75c52f3f34da0d82feef254bab58ff8332f3370e1ea95edb2098cde2733a04c16a4544db321fddeb722e69bf278a65d27a2a76b9e25cdda74cd35dbe4f45ae526ad3c85303c967654122179c46b966d7d96cfffb31b57c47e09fee42e3dbf6ad625947b88812f934c98a2d8eac772240f070632f11d700ba44fc478b3b48c8060ae65796ff1272f8fc47dc7d96534f8dc1f806356fac9d25de8bb3a9b5713e8e002446a3197a805a7fdec0672e2a298dbe941ba0b8dce92ea8fc8d9e1e0fb237fe0749dcf73110f39f44f8fc026b90728b506e368c7549a5ee90c3fa9f31f908f19887d2f8cdc8883f71c406f02b07dabeef41e85591000544d4d4de3c6ac1de24e406a22db5b1ebd94e097645a3797df57b485ec21026d153ede1114835f5f5e09e0f3d444ae3c2892f459ea44c4dc663d56901119e2eaa06cfab867f7ea4d39ffb30a605d2554ba6432e482a71f13cd453f203ecfd14fb3c41977d552429dec3aa9e246c8b73ff9fafd8078a77f2e63d8b38d4efbed73e218eedc186489f211f61e493e3847dda66a016c3064290fce9d9825adc3c3df01d153527dc6dd5e8317a32c64c2becdc230d5ecaf346648a3931c74ed084551c0a4b77f326f4b592dc0c15179e5c65b160b7a6a57c356d77f38aed8f9ffb4957ee1635369c1e6c7fff5775b1b4de7576c4b95a52c0b00555c91cbe8010d4efdf79b8cb5466513d5d2f39f3d9af711d260e0bc4d8662df4e3e4decfc3c9ffa5fecdc0d8e8163bb4f3bfc9aba5e759233f827ff896cc2ad04c13e1a4614906ce4beda00e95965df69fb70bdd0ad3fdf0b40c24a8e7e0d469a41a6931865fa1fc68c6e2457427b73c370b046a82e798ab1fd98ccb8c88425ee7aa06c55af9fad0f91af6441986a2ba61036e618a831ce177402eead15399fb0e419c80b7aa52282c0082fc19eb1d1e3cb605ecb823bb0704401dfd9a7b757c697899caf4382538519b07f2d1fc862915153a31159083abf0fbb9050ac80f7c84dcd1a44f5476632dfe4cc6ba30d68bb151f117354e82d11287761e0e228bfd4e2e97b5c92e6f2c1274c3862e970183bd9038da3155e4bbfa6757fb13339e0b9151df39eed137c0037dc02941c20a2301fe4f1ed6cd5b6f63c1e84f1af8a4fd271df4731a864cb9566fe0e262bdf10ae2b702e3c14ef049f3079098ad8a781a4ceb82781928d2a61ea03aaec9cf1cf9209e6d28bb391a87dc4ac55b735814df6b97ce27c7ec0bd5144222a545cd93a9463a24263188a6a81e1990ca3c9b6f215f2c6d605cb4daa6264aca00b48b34d16b0f74e738d183b94981650f8e203799f016a1cbc64c27b684411b9be6752582e014af6e1a72a8edd6dc96b84defd0c3f6fc50f3321f5eedbe9730dc918015ca0de6ef7920468b046fd5311a7039ca775ed2c5c125e3e1549835b3a258d2beb32952f20663168fd995b6b4bef09f546b067c042e652cae0e25347cadf947e020b2f2d3af515052e3ebdc3c8ef73164367e7de8a816bb3b119880246dfbaf0f0b40b9903e14d764aae1acf0108039616060a8556b6e0f3e1966821f9cd89caed3c6f55cc3461998df9ea0004adb1d6235208a0edd0140580480ccc035c0be161600f9ed36c5c93675ea54a1467af7be456af927808a2662fc716c003f6f806a2162dc54fb0e22ecea5b74a24294f03bcbb20b8e1a2734ab5ed0f1386f94226b2ae496055972d52ec3dd8f8d374aeba8b34049344137bc42ff81355b2315bf5b2d2754ddbf3124ce9900ece2991a655cdbedba3b34de852913891a42a8439cd5d490cd7bcb62937fee42842785edb8dfc149d12e6d8c77bdf52b3f3aa17e10f016a1a0c6096887aa84b0c13b34a63d07c2419be9483b70cdc3f33eda7f6d0bbd84cc130afcf4fb8a5ea3a882565a2c58f96f7fd12e590d3b39e36e5285f6058232c68ee114fc2b3f293dff0f21700cdb941dc5d8d61c7d637d5e659156eec7f4829f8d1dd647624f23f24427f13d655bb953f07f4dc0aeffcd8aa3ab9fcb10d593a719353ccb947b447bb820955a425e286c3b88017d86111c7dea3454c6805ec1d56e2ae10f8c1e3132c4f2a6bc38a81fbd11a8d7d4e4e0a5b9a905627e92180fa3bc387f161bede8abe0240c968ab0c065fad2200d942caf99047f4dabbffe00efe3d7c51130eb5be2dfd0f0122dda722929eeceff10bab4ee6fc757e576f6753a329547cc643afd5a2707ae2236c4e07bba986aeab19135975d4f785a931e14f98ab055759b27c0b7c7f2f32462a52ea9742aed6ce1d230cf8c44d394aee33b136658f37b04d7256487a4996171b64df4f193f24387716321d903ab6f0d2de9f8ba996db0b32cb481932af891063d15ef34b92c9d3a7229492c24e674026e7182f9e42a2396880d1878fdcbcad21c4c0c7a981e72fa4ba06da6aff6c10852fd927c568effbc72f8ad060358193310338095db457eb0ea838b2a08c1a7699151ba3b940f73d0954e04959bcafd563c8eda85bd8b7d91d3d0e44cf94f32e501b59aaad7aa9be2a8fde498a44c66eb95f9afb7cb70a68605f9d4d1d9565b6723e6ca7ac89442b248525c7bb9b2a7dddc64b4bc695f8b747461174fa3fa15300eac47971ebd633492561133c90cab4f0b8b17f3ad46ab3028fe365e3412a8bb1e0b50f2ba72bd4b20b245ef421f94a32f514373521b6e78379c3e4246761beb9958395f5cac6aacaa0a2fbbd356428a08f70389b6186ff29598c4af061a2375b2705a4e75293fc79233dbfb402115f60aee0a4998e99b2e51dc1b4150c3ee5cccef4f3bcedaed82ebc1eb719dbfe4536c6fcb9408e576619a3c2dd808a3182168f8f835c132d7e143400d63ea73525aa69ce3f59ef688adf77dc71e6ea7bb7eb40a801dda17ea280d530154e6377ec037fe2bf53fd325ab18501794b6654b4fd982bdb5dabe4c01747a93cd37856853d1d55db9f841ea26ca8ef9e4f2c65ef43c5b42f12f3c4344d21d6dda1fc8eb9c0f67b103c9674f07c9cbc816e38dd1cfaff56745fb83fb34e247cebbef15771ac90a829acc1fcd127b7c80396e98714e7bcf8923c7aa66a655b54fa3fbe0b4abbb5ca3ba3e2d01e71ff063cba610fcb3b7e424102e1486e34fd4185e7aa940d805f3007ac910e53fc0d24309fbe4937e9c25482675bb88d8f81ae23a90c1a2d515b74966039d942055700d21d35139d698bf854ff128a77d4a222d2187d7c42f71664da038e3b530987051f1c3b9e4625bc6cc1590953f982476d0bad34770b111fe2c463b02d5493d9ab6138020f914e4fc8935708ab89abb70c7d859d3ced903e4257eeb4395b4aec0805b65a2b62ab13e156b4120e8770e43fdfe5777fbbe8d4d049e7cb902584d9351d3e4d59443843ed56e83a6e3781d45d4b1abaf2fe5c943eb0a926ad7b644988401c933a79aa6db88396fc63563be48b3b961f662f62034c8fbd686c9cb319f4883940feef53e17ca2fde3eef35649cca281ad3f94142d2f02d5dc0dc48052ef7c680665485529fa80c564c0b93539e0c23735be593c8274be9e799e75234567f1577d96b46d5a5672115789747333b761d882f7f9c23f3961650a5414f6bde9390b73ed9eb8ea069ac076134b351a60f98745fd2ab4c99c1061d563ee3bc975160a9ed7ff96c0362f33fde18272303aa00d8a2f24771231e4179610f70fbb5232f5b5e3115af850ef837c63a8d8a677da6ad8ca7effe559e6d781171cff2c5c62957aa33f8f681f39dbcf8e0552be1d56417ad724e5cbfa675019a33c4fd002f89f063f0df7516d26ed4709652029cca88830257a42be7fbd387309c88eb2242cd4b3f83f695797cdb7ccd7d098cc6a3d735eed1e9a6518e6429aca74dd8cf34e268c4744cb93782f92b93e0d7bf7046753a31f635bd29789893d97285f70e5b5fb11f0592fa3cb530aba51a2c96998debe94efcf8f8b3bbdc9497d07bb97fe85b710d8c18792a5f7ed8cfb1b6e1c5b030d33111d3303c6e4fe75725ba5422afb31ffb540d43823a745c8507c21784e80aa87547b0e87a3b0fdd49bd5fd2c3bc95f8ed6783a0a503fb1f04cafbfdaf348c29cdb6c68944ab5d015472dd896150ad3a7333b88ae709bd0e2f5ecbaba1d15796773c628b48ec417d8e6205ee11b5ddb7418dfcc2f407c39a5ce21df9e13c4d846710a5c583ca367dafbd39d07bda76223ed90ad6e569719b860b983b02ef5a76e61b6605ee0ac9208be8bae360ad720d1f29ff847b40d5d9e13db8b85b5ed0602597fc80cafd353f71b9ba7eb7e63731dc73850ad3fb74cca5ad473763a0a4cd8ca92003f3cc4464c633eb71450ba2a428a29f91ddefce3234662a8b37d54dec68e9f87a1910081f36c2f3bc072fe6c3b8793b101f0f8483fa54beb2793e4695d862b4fd5cb1a10f66040cf355006e1c6b16a329dbac5cb383b378104c3e507c71722942edd48d2c9e2b600ef144237e6c1485ead9272523ff08fd0c130521d822c3170ab1db1b2b21d472a1b3785b8e08c25bcb47bc865be7ef003e102d2a6e34ecf9746f0040b7949c8b98f7fc1bcd2e58047ea1aabfc1c7b6c6a84c4295adfbffb2113841872d8198a16db00abc6e9f2e29aabc86da7fe613454983037e40534c1d455bca3c39a39282aa067663b20e6c1facb46a4298434274e25003df7131ce5c6398e422cbd1ef86ca159a31e0819cb50bcf8d9ad0302d3c3ee62043a404a38a7b1ed8d8d125a0d83bfa17af5af2f20a01cd600e98043bc670e5c997b5272c3a924fbcc4771a44906ea10de1bd15f5424bba215f17f252779733edd2b531f22ac09c4410b91dd872b871f61528622cd1b41f82b675432bfc3187e4ad6beca61503e55d148491dab47b2c54773b7b85440aa2907ad64a17fd94599f0da82fc111fa5c7c557bd678e5ab0e946b8510c1b379b2678bc9923e9902950e3c96ca22ed8f208168f8c91820ba918868441d72c1d5bb2c97293c150b37e744bc3adb4473cccd06ed891ad748f6d9e36b2603c86e91fc2872f770a4aeca704e132dfcfdc2437f33febf9dff9658b1e2336417ad81028c46da632e2685c9c3c4f0628cc3d3fdf7ed97ab2507e8ba315b48590482cd0020648647c16cca93222ef52768de833bcd80ed46704ed1f3cd0b0e9573cb96b521f13de7466d6b92f532e96519f0cd26a394244edb901aa4b7fc072558df7467180709de49e34c4fdd138d940949301fc28b97da72475ff5616809f57ddf12b0e4223586b3ddc492e8941e4261e31912adebd641db20968df303f5e8d2394bae8b66cd67d9ccf664cbd3331dc763cdd7427e314dea0c1a0b25152c9a435ba17a5a838502941ce156581bf816dd587320532e5384f85ed1dfcef13d267f6fafbb65b728ecd9799f30e035cc38e43261caaa217ba021d26cbb90fc3f742d6cbdd6e32531cb1d8e82c7648c99ebadd8c36dd1188bb9aab4f8663af7601405df9441b1fa15713ab15d6a94dbfe6cd783d0780a46dd9869a7e1ff23eddff98324a193d7c67cca63cb86119a35ebfd3d55d6bf8a0c98a610b88784e0387aa2a3d21400104e4b59f0e4bd7d43ef333c9c8edb6574338082912eebfe783288ed37b3356c13bc164bafb60ae1a2674b3a608e6be38cff1699500149a7f691916aeffb6b80c585d81debcb4a5dc52ab499f25ebd4fdd73546be128676b85dfcba4dea3200253f91a919b2d838ca619f5ce992a79433d5cd874c2234ae74de290b21460fa76222ac0922678989810233f000fb194774a92b524d9980c01a6d2ca72380069ecb338afab2704aa53db39c1351635234b1042f591fa5a3ab4660242a09ab418c5835df3c3d208d130969e76162f49b0511aeaf0b18b44e49ca1ef3531cdaf5c9299eb86a9bc40f9fa47f1627daf221d51fbc6739803f95217d040fee4b18a372477daa2bc9376a31b379f15e0b1c599a8b36de0495d0d549235ef71e3e52908d709667a9bcb1e55506fcf483b32e0b723ab097259dae4437211d72846490f363a23d5af436f4807ebd51c0f5c09cf2cfbb4ea9c832b71584862dc25f736d9aef2c7aeb16fb725c6ae91d98de14ce34863c8e45c311ba49019cafdf4336fb598f1e5483d0c2768479b2ff025563287c9c11ebd3ae0dc19285c1bcbf57fe33f7043aaeee5ab2b7368d3c8fb332070e17f7623ef745963595fd98d8e524ff88ee1c7cfdba8f45b57fa893e55fe883f5fda86cb1c64320200529b1d1f5c3cb9a530d56e7e24ed4f1b0bab64a92c9e45a255fb2b741442792ccce062b0424a89bda2f8aef39e7701d01d1fb63e56c6ccf179ebc40a16dc59906e9d097416d6bd7da38af7e4fd0148f6f7dee25b52ce99c516acba5c1bae861f7d49c73d1ddd45b9b6b9ed60f55fc99258473cb05da9f19c8dfaf7640bde18b438d576e0391165ee6f1d73af004f73ec7036a9833b8eb223b5de42fc98214d6df1998b5bef3d24192f4fe84a776227633f62aa8987fb2d91552816c90a184714a11734c63cfc673a02904c1d905fd36ae337fd48b5b0ddc47d27f6041b46881cb3782a120fb72eadfab0d0f36400377b34c86e016accc98dfd95b3f995c050f34dee2235aff2d9721d5b3e0cfb9f6267e5c8de241eccf25c03611dbb54f0a98629bdb97580bae18b14e8dd5c691ea711b73e548f9ff56e63bdfb37a30a633a27197ea80f9c5e9601baed78661780e2fa419800d494b7ae9c27ab569f2401f1b5cbeda41b0b8faa9d9afd4f07bf33625ebf76d130011f4c74acd0d167be22064fc226bec47de6a0e50085c50c9bd1532d6f1a6ad144d6e240678cf1a92c55493e3be3b17e38e4d40e604d0131598754efe3c1278c61df82081fcdc2073f40da3accf8f0328ccbd2e795f7213293db33188995bc06c4f3d5742c636be39d50352f1f8bd79792a3b4434b82edfce1f07bab09f7cc28e9cb14f701eaaaad00c349ad98258734df2a3094984206f594509709814cf3a1c64db39621e649ee99b142f77943cdfe5acd7a3890343036b79606aba76d134d34eef431aa79c5ad1e8aa414ab2e0003baeafd9b33f9103585ea68db687d894ddd834fa4a2b3dce5f8a35615580243482ac8ec664d586e5354c2174bf8a09e5d24142932a1200f6f6cc1b6f5e27524c28dbe3eb76c0acf6c9c23bdbb108c64ecf5814406b50f95093c31c7540543a8f5fb278cb4c3a5d72321b740af389c962bdbfe77e85a81b4f1f93f5c06bb2f8e0e673ca7dbab028917fc50a8e22f7fd955560d25ecdc059b70296ffce183d18fb1e6a32fca9cfebb86774692596a197c56ab39e9bc046b03622acad60b9479970714927bc3385e1d871f1cf3de30ef207c50a9780295f2cf5d22b34271355a3ac75b8e1228edef501aa0738df6e69e8f487e62cea7ed3bdd00b123f91fc048b543b1277689d9f796416b614c69110c016dc3dca6554adbd6fc71d9eebf8ff3acf5e008f29c9f9a094ba3f4368a43401fa774f0e2c60a5519318b1041cea3591649f16a6ed5ee57483ad64dd3624d71b8948eed2a256c2312ff91a65336ce47f1c13ffc94b4cfa6d529ce1effbc66337d23d3a3eb186a696f61dd68ca6e7d3071da2479b4ba3336e0bfd8bccf3d8107ddd7f5e18402ef04dac8d6710e7d2c14d98ba891dfc9cb519be6677e1c853e8443515b5555d517ea96ef1c55226f9b3cb67a2bddf9363a04993b48a5c16992505cc78d7291765e86db0e352ccd7fa30cd63b5aa61646104832bdd4bad6195db15a38838b0435c9fc79acbf5a3e26d5e319b52aeab530e48a95d37339d4d592fe4dcc5fbee7186d2560af2b634c51560e202a4da8ff3bdaf5e0a6c49adca4e72ed8fadf84ef6ad52a09d09b593e89243378a7db037f234556a72ebbc94b7d0c908de7e9fa9c280da3cfa6ac17bb749d16a0f9cf6a54bcd103cc51f445b9b3029a24d442a28636bb598a1e523755b48c708737052d4274f035bb4442fbbb70beb3e3249e2508c268611c1f09954a417a875e8ff23e835ef7ffef33c83c8f32cbffb97e7cfd5ee3ceff6d451cf758348f95091b1e8d5e0e3ef016741333262eec4a46b4d7a5a2ac40788d71245f66ba02c484c77e92ce8cab43fad5810a91fbbf824e20ef54695f178ceb566a818f50cf59f9dbb33d087cebe093b816d8a16488234a3e6a5c07083a04d5df152f73d04856af50cd86984397e91adebb9787defbbc37d5535f3ed526ddbbc657aa18e75ebf25b3528ebcd6a1a037677adce6aed916c9149af75e33834c47ab63eeef61478ad857fb8b18026c3517c740f4dade0bac7024b1339d6a693c61da3c46964afe0fa2069229fb12854ae284265414954c867af9e853b274fa5bed5c58ee979486602a855552dae1ff1236b8e536bc4556bd73ddba6f2cc93a3cfb5233b3182b32f84cfc3265e1767408bf15a24b828ec4eb32cd470f1dbd3c03c8c07fd9aa695261fdbb7b5a32da0c6be2423b21bb62d97a30018093e1561b5a3c7bf747cad70c9434c39d6ac757ed5b86e47505f2ccdc100135bffadb53d424b30567e60cd220b64a8da784af5eedcc5e292be92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
