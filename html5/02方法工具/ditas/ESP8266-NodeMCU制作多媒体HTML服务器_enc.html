<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e18be8805d5a541f296c4c45a4d9ef561d8d13bd5971afca5f95c4ca6d4f1c990b103eef672835cb897351b33da8a69807fa8b362101c3eeda7fe70e8de3505003ff440e91208ccc96319b7f294c5710ea3e2dbdf6eb3c09004c5b8ec2a72797a2e22e07c30d4331be823653cecf35a436c37c37651560da51d37487a76ac0fc270955b6110c9cfb6b3d22c85143b338a2c0b0bda0dd8c6fb7b0820d3948ed5d77b2f466052438d727dea32e8394e0dfdbd0cb281a41c809d4e15e35c4e671909c9ace2cf9ee2c5c01bf9e42caf96568a049e492e49fa9a2a3f54b76de899b95f923f96b6bdc3e08ff24ab17fe778a8c576eba178f248d66c8865d91fe7492bff6972dab69242b210fcbc6aa09478d90dcb85fa118f8bd40f651e65e3e5c57dfbb51d9ad969ba16cb3fbe3b4a0e6213b405c532ffa98a6048fe65894cedcaf368b97383c5fd5461403647bcd37c4295b24ecba4c4271b2d51f3f3bd9cd66f7207797371588cce03bef4f321f3a73d2531964e1a8bef0bb1c8f7737a977b65bbfdb527866bbe9a8fc02989799d2d6ba8135cd4e88698a3536c777529b41fa26a441ca9e2b5de23f7de5a50bc78056c75528cfa38ed55a03788728c2e3d2191262ccea8f220fa11fc043b52031400a74f98c023ae8fe521f8a2959a98b7cb1156c2aaa05360814831ac3e3205268076d5bbca04d7f2854f76ab56914b67d5e68a5e500e8e8b790defcc3dbb39769275befffa937808c7f1781551fac77741207f3532abe38a21441782cc51b0856740fa677dc4ac65766ba87fe3ef41077208ea683292a7321d36813f5d632e4863528748a4506176dde85a4094d9c22951dc1141bcab5c524c1662d85c39dd733d0681177d67082ba99ddfc22c83e0d055e48a4206cc33aa8af134c39bd24685917b479e34ad84f83ce737a5d28f7c449fc8241618f44a25b472d7693b1f0c42c8a40c60a6eae0b72162077ece78b1b638f12d0872c00514a47afd63a131ab93c55abd78069576b63e6d990303e5219e12701ac8d9c9f41fd900562bdd1d92bec866766e69834e891d14d32ae7b42f56803bc9f11e6bde3db397f230a494d47d33fa8147d5cc7f56aebd421b72f14181e7a6aedd1a0e9907da3bd8a9389d7eda50b4900ac3cd3f005b5ee75d02134d3ba84b262d65ea6b499fe0cfa6884ea2489676c28b5292ef89e1a32bfddfd3caae394508f0e64202fb0b26ecff167ee48a5d9c4c444e3dccf3944dfe5094c07a4a8d52c9f09f6793ba8c3cc236176e1f5b3cc9703a7308063cfb4c0180a224dd94a7dd5fb47f58be790f74972776dd078839f05cb3d1c4aa6c4aa01c8040e223069ad9cdfce2a661694048c1f1c1cac34a791b0b76c9aaad04e6bb967eb58d9fae55a1f92895bddde225621f7205bf6df853400e9b4ba84c40294dad723aca706ffd18d4c93fa9194cfc2facc6ff6b4e37e50628366894491d9fa6c3d0f6b969e68889f48f17d46f5aa06e93622fc3613f2bf73219660942794a7bd60f72782f78f4bd7be947c7e13042d76c22809712da78453316c58c95dba639ce3ac8189484d6d271055bec98e665adef33980f72f84b435839a186a5b46653e70e746c4dc3b90e384f7d7155548506a6338a3761675f302554b026d96fabb4d95e3e755c52820ed968eb1148c9d723bd8074ec2fc275690927ad32b51597822cceb7b19ad9d84f6ba8a7bd126cfc299391161f1cc9814f747a285973fe37915239125d0a530169f400e7aea70e038db3eb4ec2fc50380701092362dc30a4b28c7de5170c3999b0bf6b47e05b22f998a1b00d5db0310ec132e822a9a4f40662431560e91312408613e064411ab53c3f41b3c298acc79e581470e307c72b6a95113de4d9715825e041f746a70b4c64da4ecc7c755c8ae64f1e986a0d03198effbb96898c466580c82ce85cb75263d747eb97475cb4fe33c2dd37d169b7f5a0333f86996427549ef967ade19c5f3777602b62232f09dd78106915b4605e8fa586bd1271673d77a66ee49f0eec1ba2f6e47d630d28a053b9b2683becdc51dfb3a14148338e046ceaf829ef2041fec643024d1d692cb79aaccc2e0fb2d05e186a8c985543beba64c473a223e631b3bf9cc426d70c8028c8bbaa72d105e589d46b9d6d1f004e7a5ecca14bfc4c8f4b560286e8048d5cc65a65d011f2af89b51083b547c784b4f1adac7c3391a8c1e830ff807b57281990d98a018bc386d1ec03cbd67cf108571d6eea8d0d271f93ae30bac5412c061a3bea417a4fbbdda851cd8f1ac18740066d93a6e9bf65c1e4f631285cfa224eeff7f22acb3c662f0a7bea2493fb0bcf9b76607827e8d5c83c4d4a8fd6e2ffb76e994af84626f49f1b94eea846f6af59839de1b21dcaeb77fc2cea196f389ce85fbf143b597bf3336adeee97b535f0aaad64765578dc43e6ad52f95102853694e15fc4d9882e606f5a984dbfe3d499e45cfb981d62513d5c7506844b5dd483f142aaa33d52b01aba87f59d70855a2ab6c7528058202d844c937cd0014ae5fb1765b4fe9b55e718fa4b9c35b24e9a3d773b6be7ededd2a435940efcbe04f0e21cff58f93d81d066a2edc68a685f1eed2b9459bde87387d4f4a8e3bde46199cf68ec2b064437149710c9dcc9174fe972399a14a5b59445838cfbbf16b0aa56c768dc4d85a67227319a0188b1c2b2d1f76daa9e4d57e76eb570739c4509fcb1acdf39f33d11978d30383a6ca19ec7fe0d842e15a8822d1df571188a99292b1f7635e141c9ed9aeb758634e9bee3619505199010f1f724b020785013cb93672bc037cb13ebc0ca122c264583d966a49a41158bac761ded6f333abc626e46ec279fa56742f1e3bbcbdd78782fdddc5558188cb31598dcc45d7e46bc4726fd1a8b3340543e9072e2e1d5579273756de9d4cf6b40198e82e67c8ba31a269c4a43d591ac0d04b106152c5ccd5a8785fdfcbf164ff7f1fe5035bef59352f654db87699b401b0754529b2b6aa29938fe4f0dba1a25f1dcef119d3a49eebc0d437816bd2677271efecb549d6a2be0b6d81d1b9662484e2665f89583fba7c043e77a5b7ad60b218da27ea416e18c84083c69f866297d8efda8ec28e64cbfffeedf2294084210052addcd9c0b872a62ff7cf1d52fa6872600b45172338d3a6e9f86a49c4a8b5953ff59ad2fd8f12196ac03a23415afb012cc82f7d0a57c38abcea751317a9b11f2dd9de3c2275434a812c64ea162654645b451434368ace54d6d2272a669e04d52a7b4505be21acc8e5dffe017c0b31f83aeaad7f659999d251d6b31df0881a4f21d6e793af2fc70d62fcc29edf1faf6e1d19722b5ece0e41f82376ee07066c9198149e2ba09f9e1d435d77313e5da037b1e29cb5ed71e9a4d923ef351b39eeb3f958c662c1f7d05c3034dfe4304117162d8abe3c38847090551e345a776f28f1c715ca19272651e0af853d3bd12656ae82e79aead02be97c19d6ae921c43ebb1281a0175e1357be931baec28a5ca4535333e4ec24aaa2121976126095f0e0d26f335ee4ae066f02344f6ae6ce0ce355c634af58b27f0b460987483590fc0f9f20de3e154b76c38cb44f3426c726a6061aab637fe48119740e8a42cfad3d87aa936ed1cedd4dcbac1062b7828b1b33a0af806747831a2bfac52d74dc130718913ebb9cad114adc6c3263f16fdd8a04f7463f2e650e6491838ffd37c9112199609e409a3a763ee792caaec825e9ebe608d4e9d94f34672993b7b616cfd0ad7b382ef97ffc8d1ebdfba8ea9cad53925e3bf26233e001337fb675726f13499880330a961e36ee31d24026b24fc0f29ab79c594255808e27351ab77a0d6997a124950061b2b7fa78553e9a159779373ded9dafc8ee3985affb7daa21936aa5c0fa5591a22a4aba3857f3a26c159ad224b23abc8f75f6de6d404217bf3dc4dcb0526ea5ce39c883c033582c4c920e4c91f8363c776094c871aeca231a3dc24e87736ab34157483bfdbf4d2571143e10ab136a0e1346ebe21562e47d2c641d150cdd03c2c570ae8de005285b4a9eb49cc709b58170ad0562d93c26191f4c4bc31d755b0deb9f7220d3ac520339af5471edfabb5638cee1df9405acf9b22ea118eebedf28de6311b12f682ed151f559c1594761deacff2b775433646248698c59aeddf389709c62c0448a16c03a2fedcdd55fb1f0415b35d931af1ab309aade1d3a66683b0a2b686a8256b0ea0ae783c1bbd58f03a7c0b2d8fe8f30177bbeef8a8a56d18d8b12845faa953908979fc0676c854a894718e0505290bf7b9de49ded075f1c275ba8c24a4b97af5330d656b4fec972f638bb84c924fc6544b713ed8f9c10c42382dc74b18423defccc640dd17b95a324616e3eb9f12c371fe3b1a29cd562ba69b35748713f3adb0e68bf70e9749c1304693951e4829db1a22c6d4f71cba6dad5f18c88922fa9e6e24600e717b6b8b125caaff2488ba7c7e2cbbee749d998fc2a3e771ea37ec4db31d1b5be1884383410fab62ab2d3bed9fdf8bf417bc9edb807d3c0434c7fcf126cba3755c35e68d2955aa6cf4b491e76715cbb7b2caf2a458a95d40da7fd5b007750cabb1b8286c663b4bf58211135bf57b3c3a8c1e7bdf4644cb9aefa9038ab564fcdf542b41219be6a6b0acb1d387e817453cfb1b0ee1f1277431f65ff8b24d0be396dd64dfff0256569b59fc5604c5702fb1f7644d9424a7304ac6fb4adb54349e5b63b9ac6b4e722767717129ccb1e13282eaa3d662b2a465de3a8399e711649ebc25ca33b22ce38b3498dde762f4a1338fd64f108d34c4c567db5b2875bb5cd2083600221065c7733eed01009ebd684af7aa4d03c60b260184982451d83f6b138da789c4ad80ade87c8ba33c7ab8f2e3c426764bda33340d5d3acffe39f88068c932cefeb3ec595e2d51fba48c06c5efcb10133aa6f584b2ff394b4c0d5e021b7f87ea5a77af494e10d88267bb2d3081e96a2f369e6b4c0b056f212a90590faaa9556882c8a7cde466ea6219ccc4a52d88cb6cbf729989b6931bcf4dd410349d7ef5387bc5f9ed74ad19a354be14844e932ad10ce08901e0d8627099ed1cd149727e72de119b45610c1bd16b8c84fb8f7d198058f4c9ba6786d7156a79320c68075963daca8f754378b2150b9778e6b5a392a01b4322c0c658df87c7180483f64b8ec07d156380ad4f814038fd01adbb6062270bcb122d73467bcadc3a6e713ed9373b89bff1768517184590565466cb69cfdb8320bc4f039acff8987fa6c2e152a5a0615bec63a7ad135a4be01a1aa43f54c7e882d50cad5113d6d1465ae776c09098984c18e8d42727b1e392a997c52a6ea4286242af4a7e2274965fe81499f02193e1082b5ca30049af358c128ee2e8ffedf3f32ed0c26ea3ba980837cb72f9a50fdb08518f54fefe56ba69955fb591538e31cdb00bca01f3d1cd6b8ba875fca86825818bc5e9459360fbf813e4762e3995ecd4bb6754737093e015742c66ed4a4aaee41dcbc50b490bad5c0b1a7135a5c26d2bb1f6b6cd2dc5302b1a00c2d183d44f968c4594d7601d6d989e25cc3f5fc215eb9af8d8c91a76885c06bd55698bd410d84de6889e6001d43948e450712a4841792aa54c90833f765c4c5d70483837eeb77670fd29d86760d8794cc47bc75c8ee4e1ca92e030b9adaf99e8650ab39b4f623f45b67d399b4864eba428fe834c434394284ba65c5b50913283d9091517dacfa6aae666f87f47c7fd34bcf7e26e5b71ee756913726578c927dfc8bb2d78f223c904251a5e693169fa5fcda1a3376b63d305a319601afde752a25a04e58bebc7fe0b448ffc5490017809daa5aa530c59ae32ef45b7ff8c8e5297c8189ffe73a8801afac44bcf7abb10e60a956b5717728405a88793e3239ae4ac607895ca9b1ba8780b7b133ff7455f8e20000292f912349ed943d77181c888ca7041fe6d1eaf153e93057ca78de9e4fe0f9355d5eb9d93750b429edb654a9d6e0be2e93a07d81f9c51d3ae86f1bb0b7ef0e04276128b757b141a7e6c3d2dc56fd47ca37fbc9facbb890b5e385f4d4f309cb22cea31b9882f3aab90303382e364ba434194564d0998b264d3580f8fe7be9ba61c5872e57884de1c29e2bd476347d196111c3a43c6c701b87a773abd742c8825bb9e376a30465157026d02c2c945e0fa4c12ad0170893440e5b438319868e8c8994b681ebac367e95306c7de04b00b65632d41f7c8ae4cd2ac571783c7a90c6546fbc21c2e90cbed8dad985ec7a7a1fad80cdece836dff03fc508f507fb15f38e42ba6dc94b96424ccf34628698f751d7db1ba4359f3d632194cd1ffb54270eed9992711040c4b47f504de5630655795c3bce88745ebbdf93cd103ec2a312b74b573d5d6d0ba853f1877bfdd11083ce8d0befd1ec99e226c3030c4dfeb5ec9e2ea5fc0bc1af7e51ad736c6cd5b93e5f3ed86c2205a65fa397058879b27dd340d9b5b09db0e5f82fd1fa61c5c5f62e1e7439505a80b0f190b93dfee8f481bcad7eb7901b9c0ea58e37e19a5ffff58a9741be4a92ed8296d3f6a986fff6a09592625bb119c967767fdb2239f42db19864058f665038c4999440f0f070eae30c20bd8055153e8c9146ba23eb7f739999c239daf0787c0b5e5a67ea8cbade41e8024d3e520c64781bfa9927a3f1fee5fcf5f6fef11c96c5896c5e97778649e962bae76bde9bbc170f19937ce79d28ee2bfb03f7bf279216822e9977af4aa3b0aeb7672875910c834c26c99ea639807ac3ee962059943e5510dd254f581c87a74601d04089a62d99cb50905cd09b092f1743a660c08df7e2aeea3b60c49e49803a87a5f3925d7e9965dd0818ecc454e93518ef7ac53984cfca68fb7fb94ef553330a3b45e93863d7b6ec599e47a6a0ee16fa7b4a1580b4fc2d507e2e0a3fbf0b2b25eec11544ac67f1cb25e6f2eae08fbe9588632195cfcddedfb3794e15932f0feec8b1aa79b4d8ccea6e5eccc1e714450456fcbbbd54a5e0ad48889259693287cedf36a380ba2fe9a4777c11ce3a77963c2f18a5a45c0555f67a1115a7e6881f9d0259d74e6f147347d32980a5cec66bfa8566cc339de436c78f174c519b962c870acb1d5e17f8843082335371713051fd2248b43e2c9c83aef42ee0658a2f7ddb2b9cddf8bbc5ee3121518460374667f576fb78e29d70412ef5d749f4bda471e7ad27b0faec3ed691bd04b0f7c712f880e10e963d491ede515978103e658bf3755640775eb7394c8fe82bbcd219aa3af85da4ecd50ac256af9256cd91e581de88232c8757d48ef1268bc96ad59bf777ecd631865d2318d52d9f3b53a9d605ad4df9702b71c2047b578bd08f59f9243d78ae0a7c013b6aed0aa37e51ae82733d7f8bb47c6570ed6097972c2e5a8264b8e55a8734fbb65e5cca355140aaff425342c3c0ba62bfdc22e69d0ace3b4f1835c4b8d1dbc2ec2844c637b4c10e2d9d9dd73952e5156d87834a6f855096d1461ec271491fb63989023ab1ca1019c1e79f828c03ad88cdb5f29620f7dc5ef0c83eb30564b5619267571ef117cf326b78e81325d4e250357202084e555329a19f66018e778521e25fde07c80170b33cb0fb7c13a58d338f06f151aab19a1328613984ec04748920644ceed71210b4fe15ec3816fa50edfccd5ca80f65eb3837bd97622d3d56c1dcaf80e08393ea01606a9d5c7ff56093531fb0fa17478cfc6412ee4973e988ac96de268b59a65f91463d9a30432e9efd06e1b4bda1738117ae4623b830579a6d51a7b177f7dcea7f26c379e1f37fea91d9cbfa8c7d0946bfb5f06d7a0679e70dcd3cdd518deef5daef666a69eac35701110037a612d07f4095a096fd7af0e3b336d38fd9c49631860bf70d55d29ddd055e7c3183f64ae3a1cb5532ff4b75b800efd7f656641f3119c3aacc5586f50d8e5f305f3b0d11db48dcebf04e39300f6ac253c54989439d82baad247f3d730f730cb7ad70113c78923566855e195ef87bc800cb2fbc52e8806dd10be493c139cd111cc44d7a749bb224fe760a6cbbd0bd6881a433714ca63816fe662e3a307dd8c9c33c7eab851f189caecb299adfabb791eb166363e914686c3a641a2e4fb596fe1ba47370591f8817c06e5fe24d69544b9900f09f0bbc642c704c795e48fe03cb08eb42cb258da95152ac34956432c0f222e73b74fe7977a0c1eb9d2b01f47925551d13b52203f008fbb4bb9ce9cd9b3d0c96ed9f1d84686cc02cd573f7d608b7649738679a1eb59014a95aa9edc6e46b8911e1e0b52dc5a8c8a6f11c62947467b9dc3e1a400bc964f9b41b838ad0a21a2a486c7c96ea895dedb9f15bf0f66dc6ece2b116104817eebcb8f77a8e4d60bc49a83151d2d96bd6e8ac9235e62d8703988c0171596cb578363a30dada9e89b81f56186d2c9f25fcd854a63affe24ec5aee77c9a9d0f2b88521774a0f262a0c4ac53482bc21d12ac8ac260e995c07dff8d8e0b94d8b4ec3c481925c631a7dd51441261c3a244e988c7066b7a58b805df8ab4acd7b376719ebd763b62b73cb4ea64b7c8873058a0fea9f1d6816211261cef90c47a94e2f34078975b1c93e2b6ba8cc38bec7245adcfb5dca2f8350f80dc5580b3eb4659edbbec0fc042cd3774bc2256dd18f1aed0c14f3f2027b9cd1d7cd8c37c142fe194d35bf9b3497209c308e332652611fbcdbe60eb917fb944d06750649a60880faacc893b231c1f382158bce72c479c8b2660f6d8cfe1c002d1095cb9e1a9699ff11191b3d66e404ce3fe6984aa8ff3a28d97bba134e3680d9d39fe193d6b0095b550783a9e085831659f9b1cbc05ac8656101dbf57ffe83d12f9b3d744b830116bf3375af06d4e9571681a883b26e5c63e724ea4b4fd0910a83c5c80cf41af05fedb85787a13970b30b7088ee3d9d8e94660c4abc59fd6519b394ae400c18f384d5d1a2d7738a3fc90753fac4b27265d75064227829ffd1327dd1d2beeeb0bc876584564bb37f5105dafe50d422981d4fc235f08da6da7f7b02251882729a69038ccc0ee0802591be0c4b3ab04f348b8fb794d17232e85edb8ab0f85f6928ad38e229baf805efd5607e123033efbee7f0e7038b82fdfa62aff61b7b940fdde5c27686fd332758dc8824cb8dadb0b4a8e88e5406f9446267cd5a8dc609aaf47dce19d7d7f4bf2c9b21851bdbe426fef7ba2a5666e75a6eb45c2d8269d24aaff66123655af2ac9d242b05b208b01de74f397409ae12cb14c23dceac30b1399a071c1c92c1c42cda31db84f8c189e948d82b9ebacc6abd285236c2fdcc9a6535bb4674c29de6863f30f3fc76f225935c85443263494c74bc0d9986505141c5b0dd51aee0e83a2c89a16d1e8f413cd11a4d15c027dab7f9cdadc5558c37e9c475eaf34a6934f6a218c72910f77d45a1ff8d2548c4726a9bd757cbf31554725bc7b0c27ebfaf1262c1363a34410857909448e2cab45d0beba10357a24f76bcdacba39413643c49c5aee3471febf9012cfcc5f4259d53e52842bad651943fb03c5e23f3171675dceb6be5239cfd4e487b9f276cd698f9f741005ba3a5065a0590d8619f7eab71589afe79f7d036bc05d008be543815773cda7f6af700ab335d35a2928c7799f49e94883952796b272217f14ce46d999656342e2e8e3b2b5543147ca131f57bf5d1e0b3b79724b2c5d98b3d744f82f548dbae615282c3b103ba12b270a59018ae8600d03a955216b1cfc2b29b5f5b5db8ed76119e10edce5b400d54733bff520094a20af7fab8e11cf3e2a9355afa3476406134143ab96d803606f116a82641d1546a2a437dcbebab675d87202fd5d89a8cf82776969d65086a0db396c8e5e32a09115b28f029eab0dc6542616d26a4346dc114c92276a7fe6ece33c859c944d8e153f2787664a578cb9805e5a348dfb5af42e0725f415c01aa1072057a0ea6d88f98c6885098efdc9563eba7c7a7899bda6a8edc6a7d6374cbbe7d468ad8174848c9288b2414a2762094ae845aa22726a64f730e0c75db397e3b9f72c9a5fb1db0add967c28f867d35eb6963dbff0bda523d19a354e6f350dbcf8d576d7cd56100b05f90d706f75a7a1b183825a6bfd1cd7cf7f14487bac2d75494ea8f33dd8802e7943a694b85ea142aa1e00699d619b764d3dc3902a3b739f031aec43318e21f79cce0d526ec15e45ec0164548fff1ecafc87ac46603c97be91b2867c0105c2c3cdba488af3074e7d20a49c5ae60be0462ab971649eb3af7968df5b5d10fad4fb0bb0ac0fe3b6a11f4730d1d52409049de16a7b8d3cf26a01f778a26ba03f5e352248009329b821977a5076d1a2934b1b88ef346d9e2169351340f9264c158d008a2130bc63b7384f7d90f378527be233dbc867d88ea188672e9c0329f6c64317ce4a4ce0e1cc53b47c01df43035732feb4f516879cd12b97059feaf8dd8a89041525a0afd808dc3663ea2e64535f4d14c798bc4cc96923aeaf07812875de9a35716bd4b8488bb11bdfbfba1f049d6ef5db68e48f1f4154b10f1b2ffdae295830adaad39ca8fde16a5556044f5f560085ffa7ef4e548097d5cadfcdd80aff2b530c8e2e80e4f60097a779f189089f9f9a9bf99af004deeacc383044329459343c0635c3560cee40a2f1ab87857d04e3aff9111355b6a2954c0825a5de821fdf75da6cd28a4cb8c7a7a24abee0c8116f1aaf8bb1d1042a359a5f49546f5cf8d7c4e1afebbd8e2656e43b0af05af663edce6e8e6b21e8eac1ec537d1dac3de854e23839734a3f09312de89529f1135bbcc19fe9ced8ce8c7128ace26133928556ce937700b90889d975270c26f603d00d4505c28830ad84d018f0307be02a839444c0ddc73085d845aa848cc10680b75add579de30fb07a7823bdbd1c43836b41e8d66d18161da22a06ed97f8f42a86d6ddbffee14b0abf0a23ce3538acaf67d559519d8ad9fc81079416192ef987c45784700021c6d33d2b584f606eab35fb6f50687a59e210c892b0d2ae11994952a4c1481e6132d07d9a7149a4201713fbc02102c1030f60c64535758e00144a6c7d02791695c8d62c3674a671dffddb849a35b9b9abb638f05c95a97aae749a95e4bd83742c9143c3960ab60a583def6070db97fe09fdcc7d5716a8d90a153e5ddb128ce5f8603db7e087095e51c776ae3cd9491e5d569cdf662ee8248b9452015076a58994979c04ecb6551d8ff77b2c8876e49de965fc8a1db759801b333d4b88f1e78b92e2b75bbef191b7aa04b2d70464627540df9f5ca31b20adc327f15770b44ff7d8e537fac67ec3ea0bf10af38135b4d350cbf1c25250cbb716352ae2df8c54bf6818e1ca6e7bb95821c19a8309972b9dc8c1dcc477d8a72173ee1d5d4673e3135ccfc6a0504826677a40470625f055c35d65548243ebd66c24024c2e359ea934d95890627dd499cb060c2f392734ce45ddeacba3eaf44a965175b20a5ac6f041e710337c6e23f68d74f6e9a74ace3ef49fa3af497af2fcdca002c57586ad49ce8ce26a49313589e7c212266ac3dc1a7279693b86b2cb1a891fcf290bc841bcedd4155906360c63c015eec4782c6845d57620990f51fe8830aedaaed0204c452da2ef425ca76838d5dcd5fbfaa85223ec0ee7cadb8b0b64bcf33c70ecc0af30b66808483e035421ac61e30252ba53b238f2e2374aa949e0e24ebf5317a77668fdd78d5ca51d00f2d758dd91cebbe8f88fc01e57b16c19e766a31c264ca098f8e0aca35ad26bcb451bc3b57e44c71ae5df161b06f55656c231fd18326e18ec507d9dde1c300ba0e27f108df5bb3ebdc18891cea8ad9f0f110d103dd842abd9d828e82f231cb78a60c36ec1377c50a2065cc5b1c4eed33591f8613b6e5ee292502bbcd6a5962f26229c7976c638aa7b60b5badf0db7fa41b916c54c0aa4f89f24e53538bc4f2315a7bfc8502c76c5ef36f06700e85d551f8131e62cc0f059df3653f0feac713fc357f330a12abd9c4106e27602367f105e26787f9c4d927ce7c8e6812f74705a53c60ba40f7611736f62415c26fdc948867dc42d3f638779d77a0556684775634fac5c897fc4118e3c831ffb83b36226976a26c07a83ee281dc152753a81ace5287a8c222a9f178bd882678079430bb332d8b83066d0e5fbf4f2f86af8383b4fa1cb8444b62caf6bfda33d74452e6f17a7cc9a2c79cceb37dacdf94d4825d2bcfe5a04b866b491338738f3eaf9f6dd58cef8b964e3b877b5719170b8f768035b123ce6ee4247f33274d09813d56cf0d7721d1d8d315c8ce1d0fd165b6c891840de1c2dcf3cfc665dc3b68104d43fc0dcd5e8eda0869209426d23e96783362be78e3d1ddd9551a878573d217d34536f4c6c9763f9ad996e781a65de2db6e3bd5f977fff920754f7622baafb29cb9e3ce590e4e849ac73c6d5b1fbd010e3950fa15eea56bca6aa17d01c43f6794982bf406948a6e23314368264b60a64f4322fbba03965a95a826b6a898e77e1f9dd2078894a1f542b6a9291cf79883cb57a50147b558e6c1521e3389d6091411a7712f1d1915dfe088527b264950bcfa0d90ddedf92c4b7f95e91676f59a10dcd2547da626984dbb7b39180b702a7f4bc91d2b154c89b058189ab23ba73ba4d579140f94c8997e7981fa78f1309300a4e783cfc92f94238fad324874bca187ec5fe6429753414a94a19380fe0d1d58b56956180f102ec7002a6a33529fc429a4d1492583345148ad6909f9cdd4e7d200643c86dc89f0bfb5eeefd52dadc47d5a9d77de2b56c27fa2aaad70c7281d450a140714e0009eadccf0b237e03107d59b3845f0f49e9b4ee12b715a2da5dea843688b1031d7359ddaabeb11c76acfb8905a25e1f114097c0e138ba38873759e121e115debb950f92ea6c5480868bad6692b67ff05b37d01984184e57bad0f91b74e359469117851627ecbf0fbca459a3c43d2fb11846919796cbfa32c5a98f7a003185c31d0b753303e0c5cd8fed26fbc5dd06e1db668f69c3fa12a2a8bd6ef09434af6d9a33f352b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
