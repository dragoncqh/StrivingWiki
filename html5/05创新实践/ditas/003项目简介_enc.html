<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbcdcfb87ba52588d62d0b81a40d9ef7c36625c9fdef17b928bc6ab0d408b8929b21e0f77a97cdc3d39dbcf19a07d618ede3dfa4342a5b052256d9aedd18899952250bdbaa88db8b42ffeb0874a78b3c45957933e7345741199bdc759d7152ca3f9911c6cf25841ce225ebd04540879970a7787df14b0c05225192de39abdbad8534a50822bdcac4d2b1a8a65212e47c1919cf2ab2a007898ede5d36a791e8dbb49fcd92d1241a9effe9ed4cd02611d089579c4f28765d286673b6ad242a85f7d44dea46f1f0c83bc04e23a45307f6fee1ffe02a0d3d5406aea30f5257545ae2721045c661ac9d445932689836fa2aeb534dd2045916195f3b4a0383e3d0ce76a7140e3d00ab54caa7c7d087dfc6d55d846dc710d1fa83b7ef35f715056145be0930e07e1b1889886f12d264611b4713a0f06c27c6653b41f45e820642ded72b0aec00fab0df812a070cab53429d6e777cf66d40505a72f12a4fa9622522bc094b383c5a06882901b35724367115b97fc5cc2e93af9c1d9acda4b19fcfa4ae2502014140e76e8b0901682acf2d0d3974af0ba9cc10570416a06599e9644372364d9333bdee3e05c874b49129f7b4fb03f1aad76e2602810ff4712174d51299aa00b5a4ed8a4023b3f0de4bb7694af98a691230c348c538f56ac9b12ec1a347dc2e16100d8d6afd978899a87b3c39189c05384fc4c13c35e1c3af4a7c546d61159e039affa9c7542d385d2470a28946c5e98c7b297ab35032ae081400d3388e68c1bf30a5f72c8f8db0c7e8e5ae88d0dda2ede80718046f0aa7fc5a5669201500f13cc9995c150671a4aaa31b7bed38a30333fbaca1a7965db300ca3aea63e1f6115535a90166406f3498b56574762ee67febeb294e6f59c576fc14ad7b0854b9ce9b0dc0121d16c7b70f3ddadd537b0b464e00cfe71840525e951f784cd714685a19d7a31197f4b816be084b3f2de7915037a7a8340f5f5331db3a421bc38a614fe236fcf66bce4767f782490020145008207568d20b2be80a9fffbf83c6886b2104e0b237ebc6445c2638cb4f1f0cef9b9aae314d50771fe8d8add728e35c6b11d4e6a3feebd2ab20b2280fdba8d41659ef75b0709a947d7a4378bf1ac6972bb0103587edb23c08b4cf0d4013dc1f471ce78f43b58b47e45c5d53d6b4656c5152077254e943dfd67fc83a8aa3182d47c4cd6d487eb03a5c188a482dc4c95324f5f1dca6fe0456b1e2d51755db33811f9aec7ec78136435e595e890034a0d031cc6385bd272b5b7e516b00538191e6522e6c68c25ac508a3d36127f4f232b69bb08a20700e8081031116f0419c368639e42ebdfd61983158b43c1c41272e2c475a64f0f2f4729b4efc6e3a7504f7aef67d8a327e69605333c8a2f00ff10db450b8d627325bd1f30143925db91dc76526ce46b5d60b3274646b8f4fd1c06f0499eabca3d7e03784aedfc43770e7c9ebb3567b662a32c2c758462f84ea2e70e442d13359743115b3b96facdf9a4f568c049be5b370e3fc205d66d3f318b9d640c2f82583ab8940d9dc75498d237a2958a97b2f81a06597bf9da0a7d7b0daeb5b8c9b796a62bccd187e6baff6e2d1d84a330a99119f5d39868cd452024ffc1df0421d8f4facd6a00694d8bb580a65f8b1eecfaa65eed1cf422f838bd5fc711f79129ae144e3cc5edd3abe0f7741392a3351a525ce49e41319c8dc0dabfe083aed4478d1dad3d13a2be27018c8da544bc01bfb984237c7a51d44cb9c5499d3ef037dcb331852fc49314838d6304b0b28eb821e671cc869f718e4ca877287ab46ab21e0381c7ef0625faf205d759685e9897948cad3f0c84076835f064afa5425c25d8b5287330df116834b9e54338d1b597c4fb3064d4855945f35afa99355ee347a2b48a1978351f6354eeca77487dba648e4f6379d90fff22b1c5687dc123925fdf0008c13cabecb3b1c344d666a108b1d147fdb39bfbba8b540715725c37a57cb4262b13d05d30229ace3cb18430fab0db78c551e9f6ac909a447d9cfbc75428895761aab1b5a7b4a769112f757d999a9b26a8aa1bd6cfb88e71cfa7d2f17e90798bfc25dad12b6f5674c091a06786d9d3704a37a87acf55f83d4dec94874965c569b58c98592ebf904f6ae2affd641da8910f79716f166f5c4fd4f6828fc41f7207128c952776aa2e9f9b44d4c6a71ce3c82aaa08325be791c6fbc46557aff7a488f3172a64b98dba8f5ce68b8d8df24967aff5f69700dd1e27564a286d69d478113e455131718d57378713295cb9467c9a4df2ae8376d4b3b56335ee0e074fdb718c496bf025a5d0776e23ce59614b3e321d606fe1121511d0fb18058affaa30094c574f5cf0026ae27c1281a51fb15bca4c004a45c6fc39259e8bb4bd04e04b4be07d35c0e4f671ee8556aed83d3ae4d06685e063a90bd794cb5e3f57e56340c0f84ad41457bf740fc12394cb07afd3c648eba774a82179d161c2a4a4c5cd45fcf96b31450a5d56794e8b45dfe42afc43085a67b85a1ed0be92fc086df909280c2233d19bc7beeb0178b7c832d372dd7f448a7477f4ad795755fb8ba87c6216aeb9b55af87297f70500b2820ab5111fd928e10f9fa7e468087902b941c0ed8bb3f09958c75fef28861394a68a62a1171e7ea8f2d7233e3d68b72ec0807e5edae7bdac27eb72d50dbcda3e68d52b3e3b0f66a7aa92731dfa26f82183238da7930a8ceef380ab3bb6049298e3b35af43d770abd3476b6712917d38d6602dcbf6256f49713279497eb5000a4c1537ea642441334a57f5d201e864e50d98d6663603600911e47d90ce23f7bdf928c209a192f33d715c7ab62d6d93430d5f07bb43bf657b6ad1351e22b3c72f4c363ad98af7013996c18cad26339ab1b022617be4840b3d3f2473c4963c349735d913b7ed44e63b28e364eb36efeb87c3f5d511496e4a225770db6d2caadffdf84c41c0b3fdb85ceacb79be997d5b1a70d97f25d77372585c716ef84aba88a91621aae398b03d847823f38a1aa146ba305e31d93f077759ab823f00046a252dc0ca4afb14785e33907aacf27730425c0f284c3fd98e38323bd2f373d0ef632afa90615a1b59d89adb4e3fe2ccd1090f007f0028e02de2e3009d61a5df124f93ad91dad69cd43c88b044d940feeafb86230d1b35c3d1c85f56ec0a560cd7f94236cef3f043a0146142b1d77f9aa596038982ca09b25a795eb3e682b70ed209344856759911d96f96ec417d88b1c12d3f5d7180245173b2ccf7babe557a3379b407600104f9459db260a46709fd081b3387d5e25f1abdb97bd9418d662c5c031956e4790d7c3aee5a3fcd08de31690b224abce07616fb3ef47f692c80a7fb60ea4c1fce563569698de36d0a4f2a2b092e1928b1741d40575d257b841096ea3b67ba3823a686b6c731c6e4db4b3f54b1c7d009c24ad6855659bc704897edabc0206ba4e16c9df21586f3f222e4821c5cb26b315cdb691a36851d0f9c2e298ddd70a3db84361a79572f34ca67e7004606a4e1a368fb62a00e472ff3891213bc46778507f6cc9cad5f51cea3a0adea2080e9180de3ac8479357fe3bb7345b93815788caf6f3002321bc29b832a0046c58a5b62d2481c94f6dc6ebea6e6a73c98777b2643126f9d477b640a2e5b5900ef1ff8aa82f97beece12fb7ec7f0ca98623d7c48f5633df873a7977d9153afad1773eb77cc0328b11050c4445b7486dd2011e2874aaa2581b00e7da871a9c5265e92029560a72b43874168f56741869721a7fe968db42412d03c2b2da702c096907f9e6952573de6fa67d8c9703b586cbeba86f64c9152b9e60c6742a110d0e463a264cef1b6f94de905f912652050adf7c27b7f464037096c304e65cb7a499f71059bad5cb9cb453e65d5224c892432936237cf084e93dc035f848da8278d711cc64f1d27c1149bf032a2faa5de64c343e4c18eab95fda1c22c6e49f13ffb6a0ce3bcee50828565e990482b482fb6eb1b1d5192ff0fc2903f787cee25a39f419e13909a6cfd366b44780d51ee53e5aea3c61d5b582df7e56b9c92c761ee3f7950412307831109dfa7e313c318ed283663796ad643e6759dc9c945997d888cf4b8baccc700aa0ead84aa809d92d65067ea2d6b0dae29937e9fc47165a0f06dc5d95e17ce0ecd2cf96dbdc0fd2e61d9253808864660d0e9941b54d77ae1359d27a725f36655a7403c976ae1c20491771a3b812c93f85cd151b61ca8f9f752e9895f0572e5a6e0e63f23e3f4ca761993397e2336d41690b3999b0d93a8b3969aa5ed22fc7196bd4f88c4a9ab05d685caa0b9c4de37a00afdb2cd3cb8661a9cca63b955a306c8bb5696e279502decc97aacb86a54dd24c1c401a7e58f26e3cf831a2bb2aff6f57c68b267838a13c88a9bdb022fe8e031a649160fc252b65ad6bb06a01f76f7b1123225853cc28a1e4dc2a03eeeb18c6d7cb1905efbe46462eaadb7016b4e9ce9d0d9439ea44fde47c1488ed92ab4012b4f61c267f065653a91ba6db226ec0b067aa6efbebdd0bc9165d4395d48b93555c9021179f5ab765edc39da9fb5054097fda6c1939dad01d40801c3edbf0c993f9cfca6862ba65054cd1bfa96cffc199bf85567c05ccb479c4b71192e42b9024d36ba3852ac9aeffa435b1b4cf099148dc3542068b471259f5f0d24cccd855cc1ccf1db20c4c7a006ec16b3662706ef4577f77f8c7e193a26bc9a84c6ad25a77b9b4585a9f50f9a5c05ee1e44f31929ccbc4168918ed6313eca5894f4d47d5dc0049b6576e810d0cfc2c7cef692b47db7f27e692b65548a494188d7d223ed970a8ae22476bda9e3cac07e74f921a5ecbb72bafb421474ac1ce511efeffc0fc947c657a58dfff9a0f3900a436b92a27eca9a01e077ceb1a135f60c7a8dbe1acccf239d16e969234c79341a776b763cca8f4a08adab3043ca95fce5e1c47a1a951ef5de82d5e73b8569d5dfd9bf4e8ccda6212c81bae3170353f91b338577f7a5fd372a0884814ff1f84ae9d24bb2d40d952861cc95ed2388ff90d86134682ee2b8b4302a2fe172b158e2385a609792baed767e2867128b8e1befb0c30d221c7510b0cb9629398c0275226f2e71b6f5258645c959969770e1f591b4ab3552717f395ae38019864be6281bed53d372d5299b6803f1840606a10146e35de496ed2a0b3edbb47ec744dc5a1b211dbe43727ab3fddcd1f95fe37b38d8a33c0d3b6f113aba09d2522915b0ec7873de5e0b873a9ebc2784125670bf1d58b2c83783f04f59ad791bab77619b06e4885b0f7e9e0b9821637fdbfbe232eeef01f3b7d786a9397ab0054385662e305d074190f5fffd0ca6b8ecc92d8c87c2ded6728b77b289369edb2211238a592c8e4df5cf8c3e0ed661ebcf1490e907ec2e381631e9211eb6f937062b28bf7be0cdaabe92e1542cfd304f53a7af7064720e5b781515da5c0b96bd127b58e9b9a305663b3cab625c0cc7ed713329918c785e1b4e7ac88cf9e527c6c9fdef231d6e2143fef33323413c49fc1fb34df43c0780551143e3525557231cf6c5a2b054d24457f2d196adc067bf265d3a03fdb33df5638021b170d86e07a3e15c8b1c963cc90573b8a7445a9db6b51615a1437953ba5d101c284b342eef527d167281639af82d292cd9fe3f288100be0e5323522fa193430da5f1153a562415b29fa350d28f44918687baed6a6178a1e8e7a7d2366a728adfbe3a7ca004ea7f6b6d14e9f300814dcc4596f1a1f8fcb180af811792bbb7a99402e2ef2e82ffddc2c76e3def7d14470350f3af7e87d3b0c73170b367a4d88f791d02ab66555f83c24bf50600dde29c825a895c73899cef41f223265e69e365f3cfe901777d90ca6de20b400d4cffd9c5204b2a8181fe25ee53e29e2660d902bf6b9302d993bb4ccf8dfa82423a966d460bfe3cf1c54b58a7ca64fd576f9591bd6846e9b1c0851a2f2e343cb29eb5e8839ecd794cb9fed36b931f60f99ccb33ff256313c3c3fba32d8fc5ccd722a2392cd89d93b8568a6e3d4402f0bd58224b26392c6e7adfbf2cd540b5d8c397e60a29f5e7313abdd90b14011a76f2af334d3f62d3d1849ddc01a40c886fba158052ddea69a4200f5ad9a7e83e7a42d02de8f5cee919ec35b45b07e1f642d7eecb8e1fc16c0c8b9d6e8a9bf47cfcb837340a85768620248adf20782cb67daa7e127cf84e74b19fc6ebee5c770286a78012edf4da8d54e050ce14b93b4685fb833fb79078d4009cef073b6aa34203216326c6af982e40e679345925670454d1426cce631304df54347d80ada54ca0eaeda674b0d6845f678c38910db635005a6e4198c11582663b56f31df55975d8929aecd808ba6273b23d9b4e469c9af0a7c73a0827e58ed4e8b08bd5055861451e4ede79fb0fc4c46aeb35ff5dc921dd3ef03f78cc8158c17835bfc7cd2820160c63e42c8be7bcdbf99cf604372f2b10eff189363df617204931bfc4d284c94a8328d9c5844058a686a26cd190c1da34520e8370796e469b9810a9594f883507e9d04a0709278fa80f49cd1b50ee52cfd9bf4ea2ea4a1d9da291f95c1bbf15df342202611f0f4331693b45897da0cb63d2b44b8cb25a9e9515f7cddaaa77b19aaa785f49244e6b83fff358b31aa9345267c963d9d1846e3a5c379530236c6638eddb25f1def7754ba1ed6c0c5eafeaee2f8fa537bb72f65242e02a34951355ff472c9207142988a44313782159845b065a06b88fada844c002e17f7d5ad786a17793a23049c4125193c09534f16f67bc8a1f43e9ccda396356125fdf91cc5868a0ca8a19fd4f286cdfcb36454468b7735f32be6e6eca26e2724d84c13e06eac7053bfc00b750359d2e23c796ecd7ad4be3b270fe21336b16d3b630cf0e4400fbafcb9c24e343adc4817e6740f5aebd94ab1f3c8d0f87d24d62f641b9c8afbe42f8fcfea70cd7801431d961707bfec3b5e1f5120ec3a3c48acafa1a56215e3f811d21a7b9496f1efdbbed1b0e56811528628f57deb7ebed206ac5948b6928f1c36ff2369d92e3a14463667f224b8c6976b2ebf5d1d4ca905b6b796ea3f4e4c16239e16f3aca5e5f3ab8356ece8d3e71fbc42fcc233040e10f0c9a5bc69b547073992b754c051363de1df167fdf48e7f04973a80e268c5e527238cbaf6c6df06d8e96271eb207e0729031c8bac9b250ac8c6249c8dbf973d83d411a5c8765fef54e0e98371c4aa1658ce6ae0622eec3333772b8c6cbae4c015eb1d6b2e531c8c8245d205206e4a3dcbdec6212c78a15c05b87b43aef85302937c001b50f2ec2fbfa9ae4df057b6ed52367241df48a35a8695a2e4bc885b8fca4b22ea11c4055433b1f6a48c25ffcb1ae5ceab86c6cafb1527828d37b090c1155fec4b893f6e068ab56e664dcd82dccbbda941ffd4e8b4b043d373be21ad820136cace5985acf1fa3ce48a408acb35095669f90517588d5b8e571f5f4cf21aca33d8285a60ebc3e03bff152a1a745ff8070048a4b6ca113b5effcbf10bafeb6b4749e6b91b1e75d01bb3220a508f4fcc3a9fd3109507f710c761926e26c6f05cab5ecd61b1db274b0b9a7fb82571cd34e0c53efa886532cdb4a2e8f1c8c5d11a4cefb731a6ffd3531aa2335740251bb6dc57618f6500e054565920078fbd20eb57ade3a64e4caa000131be80aebfc0abc5415c8ddc800f7a8efb2acc3fabb4eba1281472a2d4cb5c0b9c6d99a87cc8764fd2fcea1e0e61bc0b14d0306f4fdb9a78c7e90827ba4610ea23b6350695b80ef5342854ff19da3d84d74e8ffa401e697497c2f33b443516af1e928cb43f5c00bef95b8498475a0fd451a224a3c49610a52960952700d9ccd02096ad7b5a6c9f965770add30dec31253d5bec0e7727833a22bbb1e2ce7b637c9516548d1bfc02c8f945d00a623dc5e595d6f9e266ab222089f0301745cd11a93e55002aeaa6c44deaeebbcfdc25b5aa7bab9a9bf20d104bad93f2ae6792e4e8b58faa7f92b95a212245d184ae09edaa6bb80c7cf34c34467d7b60c9c95f90eca17b8d790b9aef1ceab75878f9ea616fdbe6721bb0e7ab2c329416c2ffe6ef8393eb0e74282a72b4bf2df6aede9f5802d21c547e37997e5c47d9dcba349ce85c791ee43d400fa803ae4127f55f0e041df427912b911f356ba6fc03ee9bded848f1a3107ea2609adfd19564f19d8ac65d89f5f49d5c27056718de05c3de56b1e08e2cfb46c0d606b0512d7dfa97cd5960a888a77d048b6efdacb7ec1bc12562b3580f33c881c5336c8a8f409c18c1db8f5f90185dcc68ce4bc79615f1a190d32088b8e4c3702b80b5930f311dd3e095c608ba199dd1143a83ba95dc0d697aec7ee9cb2fcfa25931b4dad5c1a5c10af1eff1165ece019a850d144268c57bebb392e57ae8fd097e791d1d757c408ea539e9027a19d056f0b5b8ada34c1cfbcaf7fd4b363c9d968df8d2c9370c3cf40937529fc5e1ea1d951c7b9f87aa22735e636ec55911be6b17452500abd43b6de9b3f7e3d4c9b912bee52b39398f20fe0a683633f09ddd33747dcfaf75d6f8c724278065866aed869d587606d9557621084e34ff246e67c606c7e6b69018f534d43045e4911338404c0062b927b4b31107e61a6e238ed1699e8ff89b8b49c2c9b23e54f4c444d4fda90822b5da9e111511f2999b02da6ac2b32cefe1e2b0c100b0bafef5df7941db696f086ee2b809e716d6c0f138cf8871bb780e14c89f84a9ef9a6b47cd63928e28952e3b59c22898bcbcb35ffc9f4d140f09f8746985479b4ed188fd71f2eb87f3c8063fd04b56383fcbe317032cd05e208eb25464bc0a1ab65902deab5d3bdb165e4a48fb829014478c29f2a0b7bade837044531d4e8cf83f64e1f9fae5339df03c8fcefb0ae930d335ba98fcc85902b63a642ddd6dba8bc08b8b1fba1fb37079f755b1c2057d75d504f1acf5855219da10c74b7b52fb95e87fd8fc2c584899c63b51a3102f8ca6296004222ecd867cd487deb6ad3ef240a35931ecf13e7459527dddb0f5a063d36ac38c5570fd072d739e77f8960437690e46c023ea2fcabf7047b67b18b9826042fd33d714c1d07acffbfc63aea253dc2ccfac405716056dbb31b6d5ed9aca00852ff9374ac69be9180199b687f700f6ad001074796edfe6ecd597230a164a00134c579e57bccf26bc1b308f42b4c7abee9ded757ea652961c9878bf584ff2a0d53c304d2758387e0554a6c78b6d77b2fbb2b0f273c0313ba04ba05bc9245c1ab48c3d450108d11d51b6953809051220c62646ef6ff9fb46565bb344153da9a3fcad9dd0978ba0913a98913b99fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
