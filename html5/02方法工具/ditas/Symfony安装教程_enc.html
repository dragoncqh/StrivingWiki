<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f853e528b2467a9fce3de97a5489ab8eb45d08bafc0f6545d897c269e564f0936f4a0566008fa7a57998a3d37254481390e1e95dc620215b8a66cf986c909a9e55351d5d3ceb5a3df6e34910d3603c9a12979e03e31522d5608770e165756d79200f43706d020962596e46d5c04acc05d0d9d5fae5f800ed75325c75622da8d748ca9217b5c35547b28768ce9c8d8586ed156b9c4ac1e99250c2291a6d5d1f3cac129f2cb0793513bbe1925f6c1c3c183411b430919ee20d5fa2ad0d2e681d5e7931b4a5c9f1794e933e36a390631d980fa525a9e176790287ecff1f6f8cfdbd3b9da10a546bff9b80320b2be0a5dd57b7a1dacba0ce021b371703fdd33ab20fac90c3efdd5ed0e10190a71c5d6cdccbe773ac1370c95b90e4ef4653ec720fe7034d173031d47089f920fd6924749f6040c662ec6622d6dd135e089a747ad8877c0850825131187a4fdbcf5322be7011ac10722476fa1a34718532625ed62c25ac61ad9006b810a19c5ebb347cb420acc381dc2c916fb25b25a4d08ce24a4c11f3e2ff78c403aaa48e55b37197bb693c713757c73cffa83a7f809bb18378351f128f833380004ec71d51e16b8c5858fb303feab12d23e024d85ad6b2a5401237a80d518d05c249c5c47034f093ae19e9a639f6f759042497c5bd525e096c070d2fc4ffdfc1a5ed3bd991c141c3ef9a3b28b5619edbd08068ec7e183e839fcbcc95c3564dba771a2ed671344bd6fe3f07d4b1b698115cff408b11864a9bb2b7aac663b97569c7c1a0e7dc76b1a7c2cdb38bb75741baff303449f6e640e91f548aff6b7865a59e49845f48a3f8b82eaeb790b1b46e1f52880f997d6d0aa4a6d14515bfe0cf41dcd94dd33b0f21f352d6b7950930c237b87e52a1cc138026fcadabb7162664eb545265e420b22d3063c74cc1bdfe28ecdc6f5613493e1d5da2cd54a6bb9501af1d14645fa03a59f3bf974424dd011dd02d68c966533356db7505dbf73f7faaff46ac9e2a9da6d03154c183414510e7a7901241a872ac1f42123e091a535f3c7d3f1c8e4e7b599f3eec7192df591a35825c35a640c4add84284fb8a88802319d3e278bf769c4c8bd512e47097af59402cf974b7c302194d83e0075413352499274358a48b5f91da345590277dba9ea1909d939a0da035fc0428b049e86daa9b7bed5945865a9b1f10456557f5ba7b68ab837f8250183a05528aa9a7443421bdbf26fe77995c12517b404fd9a4f8498648cee907040b4fa53a880deb6f98108472ec02deb2c238f3112edbc0664f0c8194b6d335499af6d9670d7b12f91b5ffe8ff5483392a6183110060d4c364598e35579a05099b607491dba85467add1a9ae0720722de87a69ffe2a02abc3b9810f78c3fe8f19084afd59a7bb1e60a97dcc1c43ba04d94b3e00755a03a8646f5b0f3ab4d3e4c3be7e9b1b99a256a5a5808eb46246c52dfd5fd155a3d3b443233a6697bca03f9fe9606d9f59429725aa55eea45b2a3ee6d93280a78eaab3a2642b322ec91f0b7258a635c8fc221b01ea8420c701037dd935ad669fd217dba43fd5176e2ce4a6eeacaab56f531b29a6505b05baf6738cbf5030ae708be6aaa4bd0addaa81bd0a8aff9aaf6aade7e5df45acc89152e73e5e0e4aa35b6f6739ea94c8390c34eb9e0c9fbf815fb2bdcb1d8fdf464613248196f3f553df050bd7601be0151478aa2dca61ad8cd90c48c891a869f6d7446bf98bc03e01522a25bb8ab25b93a063b0eb12e11fb4d9921d44393d2f921022989901c3a286413f80e2f51d1621358248365e396d21183822dd40e2e8f8183fe63e3ae981de1b208875ee9abbcc207fd5e68b2ad6fc79331b00e63ad5ee46850cef9896110bf71ff163a454d18a4309cccc87bfc996e57ea59869c50125c36ac042c9e68ce4ac5870f708bb27a7c5f62e297f3236fd00454a362d8791a18020fa486369fca014038f1c91cac5a9c67009de8688382f03791df817f59dbd0299261700e98423a12b43ca54128846fdeb9de0cfa7f84c0102bd63589ad378dc196c19885cfb6c8d8cb43ea5f9d43fc652edda7b0566c09906a251e1cc81b259cd48ba253b2fd61d08cd95a0e34799570e379a6cfead5f141ca9e0888d2adebebdd40b6a615bc5b45fe98c6632e1636c1927cf79762acf5a50103801f380b3cf2a9a5116488cd3548c2a752e81f8393d299d3f8ad13fc224fbf2bff76594c206e7c065eaf5a84fab335e0e69e663c42aa48fc1a77a2bcf4c05ad5deb8fa4efe5899efcbdf98be2fe834ea18e8868d3138cf1d02dd9ed91007604bbad23fad9b5597a5b0fcb9f4b413282f948344c1eb50e4e8b7914e2c852e84b01243c13d60dfb1a6aa73581d06c1c44a504ab9083480f57327835f17604b78a76c81183a1ba5389aaadc2df94bb5d596c08c0ffd98e64b36b2668cbfba506fb20f4dfd989962459ef8813a141c568cfce40a7e358d89c47e91d858ceca864f235bef10fa7f8eb7787fddde762690461f80f5435ce05c7c2aae470ff22caaa395caf006d146e8780dd980e0515c87c5d53411e1bf3f714e0a2149b10276ff566df2743035471892729f58efaf53fc3e112a26f4a5dcde164e8cd29b56ffccba530a576a9d3563143b38aa0bc9967586ab562d474da597c768a27464ca0a3c83c9c29030a717fc0d70a8e762df4c4da7b2c760c93b3e73b2c4424aa01ee22aad8a03046b558a277264d65d5bf0099b74539dcf5b83e6edf1c370c0396174d5f18c6d415269440490b2b050862737defcf72223534f43876db86b3eda930043fb635fbcfe7972bc69fdc6507d96fa52f79452e1f4a3abc03b4671446551383235aaba9a297d4b3771526e6abd2da19ad363eda491c44360811b5a11ca39f469b136ec712f2a08af59269f98a1abc30c13b92e10d0cb34443d5b69c2631a2247524588003612c7bf1a809ae92bf0d7846b49aaeb8f429fbba5ec3395d864f9ef212e012340598d7c97486fc0334dd3ba3df6de6ca60ef0c7de623e1f2b2fa37a173639e059170e078be1b20963f3b9039c15b00d025b50fb8ea7d744b78d054ed4214d15658593297fc79b05f3ccd2c38a7491a964ad74c03a90f4aeef15956e30af49751548ca8032baac8381aa20fe7f4a2900f8e2791a3a484e8f95ede0b1dd822527ece23ddee7e2f0aa7c4c44e320114c2ad77c9e9d58a4d5683c87afb0a28ce1b6925dba62f4b94a150c4602df2491d2f6e72424a59f1eb92c6d32edd168eb376dd03afdc1f2ef34aacfca30a177ffe3c76dafd92387ae02dc692e0515ca1d5f45e2f969619dc95d6bb76e62f9bcc15bf1639a41a2a5efc493cb7e5377fe3f224ced3850b31c3d0f2e715627170cd8c130dd6e2ccf5744cfec8ff244716a2b183b1003cef190a5b0e9a8057d642b32a11359f9e4b8820a7e6d095794f0f8144c545082cd0f06ab5cb5ec98ab527de6ec97c41d3382c2c92f32baa5496378b48ff9fd7f7e8102d75a3c2098603630272b5040fd5a02ae2bd7d4c213e1243f0cab6ff0e7ef8fa70166ed09b22d488e0f10300c2f76c8dc30faa48948525c1b1649d4f79cffeae620b34b05a2fd2f8b4fa99f598b9add7ca91986ad00702e4a8fcf9ea318768af2e9a0659f623e45d2b685b3955d2e7e95d0defc11e6818aa0afa7879195c93e6f7d1fa98a731886f2da921fe67c6e5df4fe468261b2536eea421c410133e03e215e78110d27779fcb695c2c823443ee453e3cf93dfe56bebc2337bb37af8d34de52bbb643996c37dd8e4cbcc05067ba0f69fb39dca4e685fa93b7f02497a0e5db15d208429ee764b53e91d66696f5163a446efbf434e62977dae0918fe80ce0d4185d97c6054e7febd5c9de120edf0475d626165c5dd09f931434728612a8540ab301b352dfcda9da7b098c8d63c20b9806e2c9307bec717982bb6e631993cc582b640c8dcf9dc0f0db0dca48d6effef4003850592b2fa638d7bc66cd62aeeddf2b1b92693438a89d9c12b7f6fffff56f0c999eee2d43cf2ff1e1b4074e932eef59124bfb0e1bed2284446026d4607dee1147fa5ca39ef2cc2957e582286c539b0f0dcaf3c9b38da89b5331a59df525eb391c07118908d5008fec3f037270f7a4196667a30e4977cb508ecd6edeb5efe89fc46216ad1e28ca5975c054eae617332941971c15d6a2c31a758e0604618db5d20e4482af1cc5f8569979a3c1a80e3b5ac76b93953df5c5b28a1e6410ccbbc5cb39a44f87bb19b8df0cbf3c9e85ce868460c9fc0e52ba54ecdde9a59bb6c1a53d100147d05d0a4fed3ac2deed1ae593dc4ca5dfc929236a0a733b6ebe093bb7d285b53539b5ac151581c904d9f3b728a2de9e09ad54d30e45401685d4471e8b58edfd8ff8c65b137bfecf20ec0d4bec2091e673b3b9115728e1639b0ba2dee6380308b234d8d37c2ecce87c16c36ef9ecc351e27a49f4464255b2e2b2742f16e64cddc95d1b98b3f9f0103e515af3cf445df45396905d9b6ef1218fe6b3a6fb00e3a0cf55f158a9ab645d556bcebb1f64443543acdc40090fc4703bc36b1a6a4aa19ef75963db85db68d08c818e276492d4963f29a379f67cd57b2c29b78eaada83a0ae0324780452301074ec4b96cbf589acf1622eb49e41dbd1e0a72c93f0783d7cd5c215397d7c2b5e57ea812572866fc4ad473c59dd1602b55832b533b808e845bcd0b40d744fcc246f826edbd01878cc7a369ab42edc88588759142a488e13858638e7a7aee7a6bccdae4da790c246cf1dd8e0f1f162786792e0b3b81f7773578415afd14b79de4023aab3b12bdc66c7068580d71b86e613b0939514efe8850c157c6b64be81b6df1617f845345d19054be8303818050b8655fe0c5684acbe88c91eb9c39a290688e5c155eed2476f08a6d42d285473a34f5a31346fe85d414d2c729f045eb5a720d245d7302b9ba4b044f688ce51dad1cf0c78d0451b4c049fe1b96c268f409ce54a49aa26e4fb4f7c7b73b8e3676246724976f8bd9e62c83c878a9c6935859d034031a7aa4dce9ec7f2db6dd0e8990fc9a593dceedd80b9b11755ba2bd14693de0e8758cd2d92c484c499d79dc2bc5e18234e174d73c0d79af0fc731bd2f97c1610989f3a6296ef35886a2ccb005e40868ecd1e5d98cf2bd00ed14380a17f021877302190bbea56b03b6527ac52f0f0893d3e009b824a86d0096f51a142a6bd19588f74688e67676e95f180c8fffe34c2b9ceb12a2a33f7f6ec949d05177a257f4277aab652ad4b65c6e09907b567f04b725eb0059e3ee4dd538ff05e58f1e6218118cefc4084f4a2489c3a8824adfe305d8fef6e88928c5ad93159f3cd9b8bfcd7df5e7fffd2d1490da7ecc2b2f38092a9b9bbe570b6b77515a1542fbd28f5880a02921b6a685797b9f7a5e6088beb2ce7e3da7266234b1543485cf000e732747baf53e623e5203c7392bb5238feb6876ee9b27d516a10e6b41849636d86d4002203b72acd68932f73f112bcb9a22607cb0d818d94283c97748935c7a6cfbb1de2f38c6e82bfaa0516530e5638b066cfc795cf61bf3d83f766a75139c9b9947e05a5c6a1c39ad15d27bb983e648ce1a809b7d6740b8568ac418ea899868f7d989310cb859a63b5ddc8cd1f0f62d3052745c11f13912f55d9aa0b340b2f13140c8cf171a4fc7ba4fff898ff6e4105bf3c8561b12ee034df5b6fd9f5f0bcaa72d116fcb92e2cc3256c895002204546ca9f219449ee798158f0d50aff2d8d52977cf526daf8ba86c7f077f5ed0f2359edbe0ddbba15c95d8a00dd3dcbb926b668ac36cb01ba095bb5e7ed31dc5287c9fed108ebbd5bc50ce40d65910c1f512efb0374f226d56d5f3777d59272c057a529a00d98d2cacb0e5226c47f0144c9520772035661909a46fa033c04a9bff8a0d050f3433024e4cb49fc47d547d4c26e53041908f5cee71d598f0d9ab6976eec488df5e102825cc65dfc4f05f9200f400a70cd8a5e3e98f3d510ff077e1cc023a59cc652a7fe57ec42c1ad8107428db9e9ad891601ade461edb7cbe5e50dd22cfa531df3a0c489fcf9a8573e852e7f3bee09348e585626cc38115fca0b8677f71f442f8db5d2a9601a6e12b04b14fe81093bc08f34410abc7ffca230f3048eed8315b21875c321b58c34dedef89d7ce38c6480ee955b6e279a0d6adcba4adf8987a7a5f641332d6a8adc2f8f0c0a48a713cdbd97ceb882420245f7e2ef278f71e6bc5f7f6d3d63e1c641b3d01e985f817daeef07574158059fd4b0e8886b3748a20bb7059c16c29f8a2942b2b30735e3b9eef68eaf62227f54e98f3cba411568134fefd7b663878992eb9a33fcca3c3c8dc4116c79b9d2e42c93ccf4f325c80b285b9cb41ade8d9db4a510959529dc9f861649e83bf91fe8015af95aca496c3b8ac03313391ff4bd36d42cd214123b27290964df629012368179142633277c4a7bbb29d7b76874df9bb0ec37c9a289410df8936ba84a3c857ef0da05b70e6e1f7533446ee468e7c60c0c935d413703305b5fa5bb1af5ca1b615a98ae50f7b41040434ddf874711b64489c10aa2a74a3682d5c03aaf34c8c5f9f19d66bef4eccca610dd76c161f4d46210dd2e1c6b05d2c7eb4447ae0cd58f6a0cb8e184e99db4ef809d188dd62d28f5660e6a50a8f09e9e5b81727c2be1704b4c7609b1c42e22754695725709711712519558fd64c2c32da1f19136559409b24db78673b0add9dfe407c1a3287f8bfa897aa34856293cbf63010478fd484fda3596dc732825835572c1340d3ffa3bc6cc80d8878e2ea3f018edf0f8dd5bf354c3321e6d7aa306a70dee6774bb5f6c44429211440aff6c90430c58994680d266f5833998945fe624bec4f9c333e34ec380d207ca8fdd68a91de564774b3b95c27c6e8838209cfd07531c47b321879e0dd319c4b41aad9aa319dad821fd55804c6ba45594e7034021fc1221b805d956ca0c403f59f73230892cecdaa11ef71901e9222a8ed1e735971a37252ff39543cd63e39e387c5d13a921091ac640218c5e636129e9e498bfa991d50a72073eda3c4fa1b31ed4a1c3afae96a0d096e6b6106152dd240c98a9ca0ec5fde14fc8db62928756496ebc742e45a151b611bc9300a0335c0cf5e47ce1f1cd89d26c43918acbc5f004d5dba246b58a8099aa2b5ef424f2eb497c59dc692018f07267d2e77a8024c5d3c6014dd2ce6e37f63dd836bb988f7839a0ef9bf129d55be9cae70594aab57aef82239e47a7b034bab4ca4164f146008546b788ffa7d95a079260841e6f823a59ab0a0c323327dcb103ddee8c839e940279378ed92af50d570893bca1e41d8d6ff41ce36128d1dd486c121cbe9364770285576d24ac20b7573ad0208bec8e6515152a51f1e8d13d214d797354a7a72f4414db371a80a2a166ce751865b38ffac3c0999076e655ccbf87365137f9e910d7371f5570dbf0b6b86bbbe2dfb4226893e90e352cadd41f892c73d0f8dd0bb4c3a964127477868d746428e6bb329a9ff8fb635ed70a948df48a8d677ccde27390c2fe929e8b61db0f31cea40b709caebdcfe1d3dbada82451f2b78ba1e61d9ac39786b7dfb9f2dab54d55aa8e61b6630347bacf9885f28a290fe3f5b4bdfaa2bbbe0ef46f3469834b6133211c86bdf96429dc32bf4f64351e0bd5b5e06298506cc22f0420a3599f861f26a7fee605c491573aad1172cc2044286c65a7ee1defc9133b4509d8268be978fc69bd65e86352b35978b24447c87f98a20a7f7d67478d0f97fc19543913704a636d7acde8cf5ecd0eb37fd39d86887b228815c3a22ba92671465e38749f060e3d95c4479584a4e6dcdf58b499b83b8da4d8d6a63b953e7fd0aa0d5d10d09696774e28aaa6a2f9277dbe203944583c02566e578fcce65d311e64079ea0fc31edf31bedd6a910ea781c38fef76b396bd0373dbdde8122db99de0bb7de87a64ef4eebd126379d24d97fe1ac0cba491782216270f3f50f8c62400bf015194a8c72d8a854f464afe65f8415837bf22735de68df83daf5c8b141aa6e4a7536878c1247cd941343aafd470a50f914bcaca621e9777a93e0998613d261771828ce6f9693787c0ad1b6cf854ea39602abe77e9ae6810f86d544cebacca63ece9a4964bbc605e1810d70cde7fe5714795758188d5faa93297c2dd2685bb6c9eaa7958a74d99739865415e2c22d35011f6265484bd24df830f8fa355b411c1de15e0bbff848228bde67520664ab384ac60530a438433aaad4c8c58c0bd02faa7fd7686f692ee446b8f80a6518d099bbd77d0a8f3d1fba51f77024ee42448c8448f23ca9fee27ca926b536f4e854e468d178e516233495d2293adac35134ee3579a06a53c2f726b971ca76f99b2bde3434946c69626e4abb5e4f00d915b0ddd31fed1c23e333daabc275641c6e88a3ef0143ba91b0eb33b119ebfad57bf2e8e4bd89b56c946e7fa485c1465a6c55e8c9d1bc8b62d53b0f5254efcfdb086865008591864a4b5ff9103ee18631f028e460037ca87d462ac28596c0a08cb74c12ffb4e418324da09c5ef0ea5825448531490b147d7bde3fbe3b0dbb3e07ea8d78cc098db23f2fc446f2d1d9775f3d7540d67a0ca4611c3d592219a3613bfbc9d4e616e7a4070b637ea93c1bfd3db1a9ab341f2eaddbd548e183267d52ed961d14e67cb89e09848e9dc5acfbb0826d24d014ee65e623dcb429a7fe69f12d4485b8550583ec78e3df915669df9da38b8338851c5361ffd98237a4a6a313462f1208ccb5a0b0a655b92b946cf64b3810e0859155525c443c9ce2acb219955b93bf9393049b2db54a9e990a50b91b224ff132e23a8b17947a5a20e5352723de296f185ef31b4622aaba025bb7f52ba63babf8748655d48278cd3a5f36aa3dc6a65f3c078941b9a60a5585fb26cac337aeb240cb09c7a8bcac21b0bfb0e0a80143f4667797b318457dc2b0726f1f02765c5a00baada5d407b3762f70ddd7a9fc13a58e00a3741637e8fed5a2a591fffc31d111620f786bc89c220b75ab3c671f5b91aa1515a37f31d46591e7ae2ad83e1f5508bd351fe1490ad27ffde05fcfb71328aab207f29eecd8549bfe4d292da55c9813f620f2804fd9a04a370f13f9a68dc1d14750e0b574fb68bc4db09851955e54c4734b7dcd8c22e3417b8b58ab415c6231f2bb41c197cc08e9627a664a7b29fe08e5c589b9012206f3d594ae6a660c8daf244fab034fea955a019315962b9cee72395823c52653c29d7733704836e4ea5bb52d03b522b3ded0f9cf99fdceafd305e4360651551cf8a38942d4c6961fb854caad9fcee3a971489992e63c6e67aa42353a9f5e31a64324cdcd9922f7109c689dde0ee72500f571b4f718acdc338c84571d8a0d3a32c926b483277dc8dd325eca713a1a5ad9bffe53557a1b8dc30e65b11c0921d406f9ec61f6bd4f37ece9ff1a67004ee66eb78e8cc175a61aac4d9dcbfe30135653b882767e2994ae6a761d39c87aedaefd176599a34e721bb601b32e3c552aa978ae76381fe437fc0d3eca1a9a07dd4a00bdf3e15e563d31e9d17733997c2eee09719115ac9188a40d4bb203a34acec90ce9580379103c88e616859c6dc92878dc29d41ff0ab3da145ea66db5ef815471c0c99f2ce48ef95354f1573f921ea3349503db81646fc1131bb67143ac4daac6ec34745a3436331f7f21b0730b66cf35264b1047a5f916e42edbacdf9b647d4fb59444db282431d53e538ba93bfc58f133314d073fe0bbe7e9cb2e1602a95a76f9ce40470fccaae85fc25516288fb5630313a4c262d426623f557f20a9bc77752fecd3b704f7912d3d779213544cbb313ea1eaa2af956c00c046e6bf086763b288982241bc351b5d647a29fe0fbbb2b21738560abee89d7689a312e3e9993b502d4872f3a12fb5e1f0fd51519992552ca556c5159c9ef3287332df9178c45c6cb1de1a059f959a020b9871670b28e8390fa8d1b775975673c4cc93a016e4172503499800b38d07c1dedff281f9804e7b0425fccb8d58b91ac23cc04c246e65bd1303e02cf4db955bd020a6db4c7359cd861a9676762e41f5fbe6f6094f84446723c67aa31be97e3c50059ea084bfe8435526de7030ccaa6f89047fcb18cf3be7d3beb8fca52c0b99b13b8e5da5445e21c1c9d03d668c52efddfa3c3230280ca3184d5d989c7d6b99b2b059a71668b9e9c1e7a095a345f943990b751734c52f47974c13421d198af0263735c58255b73dd113b34c0e66687dbe776deaa5810d07e53ad01fe9c1c67420a9551305d7438654ac9e4139f63095b847dd0c606b581f49265751a7df3009680b0450f72dcf18cc3622cdf7934413c0a0024e453624124b293ae263fa209e4770a5ef59dc08fab1f1822865422f77a61d75cb601779c768fd15d5ee5d226e704077517f6b699dae604be448941832440701e5d98d3a9fa857a491b336b87d38f39b3c2091e78949438e07b970a382e10ff2e31a601e5dce51e059f179120526dc9df23572fa60ea41dfdf45ad1c1b74bd341f16285f60579041d3d1349339103236d91ba67af8cdc6d3ecac7ec167c86b78cdedc208dc791b52594a2fda6bd173f1fc3998f8ab47289554bdadebb29b30fbff21731dda3f2a155da6ff02762c01ea377d02f32ccf1a366d1e751e5944a61733a4bc4004557735062bd5abe4b135cb39a06a5d785d1ccd715f19dc9afad64dea6ec5a79c791f1dd429e1eac6a314ab6d0a9becd4732757bedf3b15276891301bfb60a3d3e583633c49348859cfea461992e9008c1d7f0fd3c5cfffbf403d226792b751edafd17d467a907642756df82bf9f0b62f355a2bca13bdf8a217cf7c0818907e71f2a19dcf8a1833967e8ea43a8b9e84d1bbe249c15ab455c823ea972a5dd916db7cff55e34ddb610a11b29516390ec70098c8e8f012643ce10d106365c1c5aa2cec881f975b1e212ec97420b7e2e5d2f670442d85e3ffcb8f89435eebbaffd921e40f1f47ff72191ccf4e7667f1c64ba6f211524f0a727deebfb930e8fe06fa0559b5dc628aa7797c3cec47f62adb8b9bae4ea8e89ab2379de0fecc99a992da62a8adf359040d1fdcc66f9668bb88ed87ec07515f8770b02cf212bb4713616a435fcf05fbad1c4f21b6cbfb7e76f0d2b3582774ac04be92f46058733aeca10941ad9b150770bcbe621478ebedc3644612ed51060662f9ee78cff048be5ac7bd31c803d5e84467507ec61c9b839ac858a1e7d4f067bb885e1aa5c699a638544d445af8f83d6945476064cdfa6aef27a52401ef90ee58c8f0999409f097beff2ec319dfcb1b1248c5eaafb088e57acc4cb41580b5b7555a7e47ac259c2c36b7dbb741f145354ca41dd21c09e68593354af01e39b87e685e12ded715ec0c8187098bc510004799cb6bdaf66beed6c5be22ac96898657c3b28ed8ea254c5475fb2d8ab15d0ae8f3ddd5c7add3bed77bc343eb060e0de293879971cd27e386a3d4dcb36e10e97563fef3646cc33863e477024b029aaae447ee44ce816846e310d84bf9fe541dec89ba709cccbcc956dbc39bf00d8c3f28f6332144c955989e03b11886c179f1e6917787bff81b11c7c37e755f0c2d47a95d4a4091ea4d945b617c87afb28314896658d78ab10a75f6503eb742a033582c2f73a0aa1f9d5844e291f98ab64ad0e99e60506c4de2ecd2cbe090943745d7193f2965df6986ca966319a9b26106877fc61cde9c3ef1707c237cb3a8d88c8ba7b7b4f72d2330f818882501a619e431c4458579eccb889d74de74d73d67d8177583f6e58cdbe2cc782540e5a2412d6d3657658808a330fde16819d52cefed5a2ccf46aa9f2d47961be5449b47341d278f8f1685b00512e9df786953a27b15f005d32e1cbe77c370dc9cfa05e3ad514292bb54225ed894ea5d3f43428a912b58e513afece611f18ac20ee115283b28d9d0a283effc6e7ed82dce0d7bff9cb4fa69aedbbe3c2d3acccb76dcec7979258cbbaa374e52459560ef92ae649349d708423116215a62699f69a2bcf931ef6a4c8c308213080002887a85d78c13fd0b1db174d052825412b3a2bb26c64f44dd9cd4350700ba5b9d301212122ff21028710909895c1786abacf34b22ab436ec87e2413827e57b332426b8f763dcfd4373a88b93a56b37168653b0e4ef6b0692cf2ff09f46f8d77449ed3c3795b5bda6395a90c0b25792f9f95b6ebe14a99d89e66ba3818aa99bbfc0fe130ce44ab11841fa3fac019a9ea609dc717cd80ddc518606d6d6b83a4ddc457cafe32bf7bea1609caa845e0471a85d56c5ac90e4ecb1b61cdb231bfd1483c6d8e7e23bada71cc70fb07d2f9d8b9e6a9ccf2ce9523ff4fb0ecfc16788a7f831ee1ed311d96cb51892b9ee86ed000a1d3a49a861db3d82c1e2e564ed9c5679fb50563434ead013eef3cc71bd90613fa7434bcc9006d30c6a39d7e190232ffec1575d48e8511316f03b3e54bfaa07cb42b80c300fd24622404909b98deb52d92c233d58d6f81006eeed77416b61a07d6d1f5ef649bf346ac416c5b4f38c934d7e4b069ace58333040fb3b365b6d4a3db8f2a6324205ac28abd8b819938e1a2620b1833fa4df1173554028b3393c65766d3358c46fde684949770ffd2a893d4f914982b10ffd7162fb021617e561a7156a3fb66dd78faba6032def8c2ab425dc6b1c099f8109f073ec05df65a11693933a9d7a81c51c98e79fcda887d47069178df324b679ef24f8345c2b33404fc02faa7c0eadcf700664f88299e00140afe7e6b62e0e891c3f146b99b2df0baf6c36426843ef8836dd737967f59de49eb0e14826907c191b1de41b3d5338c3c6d0f3ef194f30441f6dfbdf1d9c48f81f2d60644774e3b8629aa12f293c965191a1186d960893a024f4f873b07c5d1adbc32def932e84389ca812dab61d26e8a3298db989d860c97e3cd3b97c440587d44c374b64d5dc79231d1e50c3b88c6c2186fb6151ae1f34effcf12e1343e9df597cfab344ebdfc1d0fa8c9df300d894d1ca03f558f03cf20de9a76b1384a1cd9ab541badf4bc6634a93cd412a40da74679b09d357537493d1246742cc6c1fee2c497209ffad82fbe136b08ff60e9d0a29c7090659de060430202403dcb775c399768246d65e34b3d5d8f50ab6b1a320688149be7ce6cd3354503ee64e2596004502c153aa37134cf9c40bf82618526c1a803713e4fcacf8cd945e046892735240698637f338144b928e56d16562f6d1f2191a9febdbb1884948f3d3923f392c0c49ec2ca4dcfff87b2b46bf76ddc603987aa0078a5fc8392a86a75b6ab4f4ff5b13f659e5c89920b2dea117608bc1f7546f356642b832ca0821e15702beb128ba7ed1547c31ae1bd15ddb8d07b87047cbb95ac021c13384e1ce6d9c05473f13afc728ca106e1ca08faeaa596451729c576c51b1457da7f6543a50fa4da5420631df841484abe6f40a5e3ed1cc11e29513c202b40f288ba6d188ca67ae2de704338d56d9df0bf09495a613917e2383cbd1ac8124cf58af44f31af56a79809a29a3f77c6fc12b9c4a80e45b95663231437503e168eb8e2c4d4e2340e702bc5c7bc23cfb7d3b091d1a52dcbde3b60efd8ca7b28196d78e1add4114b767ca54b8d9c3f89af17272305f49e9ce4bec0f7a00f19948f9083b5010e9c4d97b9729b39ea1c1fdef19b035b08b69a8c52f46e42ca0ccbf10ca41316485ea36d8040fd5103d18576e0420ff598f4764a8eb0e61f3e20c676e2851cc4fc50afb4be52ec9f45cf4e6d090b23d0f3f7d0ab96c86d2c9aa7766c6167cb52eac194ef5229ddf0852a88c1fc18575e2573cb9378c1087a1de48f35e0c098d245dcb031ff83e95c65989a523ac364d15159103f9477132efe6c8b556477b67bfac68b6bea2f07470e060d92b027ec6b638d7414b1f3cba0ba3ba1f8437f07c57359a790ac309fc8fb3898117924b1ee6ec48565dd2729be96ff3ca0f4e3ba3885ee593e670e4b11b4c278ca1d8674197e78d803c76a9078aac091dfa44976456b5e833a11ad84762bbe66197ed420ee0028732b355759c132c93798ff8cbb78a10acc6d4d217ee9fe34b352425b03e6d2b7d1a23f16973cd4acad810b96ec063fec6197b89e15a9fe7fd396c4bb67224ffa2aa70fcff2c14376c7a8a63c6c21344bdcd67a4e063764ba2b11e5e2550e94b9c4c23c7ea189aa78f7320fb96ac22ff707a73961f305049e4e8acd05941492dff552b68db053109ea8f795515ea626ba2dfef2d6636ac044a7528783f46aac4ec857f5fdab207d0db45e64723f044dd1a8070d9157ed941ed665d9281aa21a4d7a3f7fe0a595b206cad254a1c07de192cdb315ca79abbc775404debfecf2d0b53db89bf4a20b78ad5ac775bcd9d62a6b24c7ba56c1ce1be6a86f74dfcb559493a7ce67a6bd15ca2aef1231fff99b8bf511c1d591d987c737687854bacbbe868e539c03863fd65f8a82793aa933b4ff1ce5ddd6843f337619722ab56e7ba58698de5c967cc5acfff84bb18afcafbb97a7683032b8236981f3363a7cd6c63a5cd3eca4a9e1ef329c9086c97ab59e4038a33c7441e06f7fef6deb20f3d9c44fa2af46e4ae2f4566f05ee88a40abd4227ae1bb8297bf239ed3a6d219d1f854af5fd6412a5d04c29a03cd6e691b2e686ccbbb6e54fe4ffb6c6ca1d9a1e8c81f86f00844c2a5a99a40074f5c52ffe5516583bfeaeec6a15288b4ad4064212c0a7018daf12106e5e2734414f39324792f4dba986ec100a082a82077e228d13dec6f6e8eec13b3dde7c92de17deacd79be97204a584a3ed6e8a9da6b601a9eb751d7c1a4f8261e5d53a4599070c45b5fe90203dad939ffe2396394a7be70a2145670fa268b06113356396aa98cdd93c3c063ad6373fcbef4bd5b6cd3ea240a1d5959e536966f8d85c2f96d778142d5e90bb452f25db7647140ff887b9301016","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
