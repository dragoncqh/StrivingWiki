<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7a9f100a8429fe90546d91f06d9295e100e672e53909dba131bd80ed14ee21a50d13b830cd580ea0b47ff4373d512a392ef633ebcff51c299243c77f14c645eeb88dcdb0dd82f47ddc0f6bbd100f1d10ab8de8078ec39b22a221502a5151b14f8f0d46148e619d617cb1a90a76ec9a34a985f0c1451552a32dcdfbbf03ae771aa6d34f8a47077888adcda8ced4e012e640188b86d0632ea108c8bd46620fedae9a2db120c16f592de65263d5fac57b6ae9feff2ff5c1d972d90d46fbaaa84d64d0243ea70cee5243482394f14461ab99ab46aa42084ce251133fe1c0eaf15695b3c4305f62a58603122f3f911a96ada63e409ab4cdccd94bf75888e487722b907337f2377f153257054941e9028ba2b9ccc84a04c57302f31468deee7f017f3bfdb8f665258777883b14a6d186a59f569a0cc79cc4066ea62a1424015df0b50f5fa9a39897dc0c205394c44395342801e419750f0fa3c917a6c974b04ae3259ec9374ec21aaa192be21c375e0cb06a32a4df7c6eb778b3c0e7146ad1be338d21de779a46feb423c95e97cfd92d03feea2fb3e67640ab896e3371c305a07aec6ee51cf8dc84ffbb3b369e16727017f26ebeb6c3d15047f4b670e253e1a19ebbe0cc2f0d0150f2ba27c5a0fd44d47fe367e9dc9f87cfec4d1a74e1b7a4fe64f6f330c901598897bc726b397701325eb829ab3c243e639d7c1bb2c0996f379c5b71886eeff8b102368ac91b8393ac6246af750a62546c1bf8693697f0a366d54363c76e48acf4650c6ee72e9002599fdca5ee5f56e62493be7235c791d78744cd873ffef0c01488a6bbb2b843dfbc0fda85c1d2debe952ef5d0274789cccbaabec0f30aaf039d8de67f63d51a7cd09be7987c5658dd16ab1c415ef48b63dd7ab78745e3459b02e9f0ce7965d9f126a7436d993840d5681a585f7e4942eabebca7130ca66bf784430592e9933a6b6bfb701d805c85631a2c6cbf720571324ed56e64f68027cdb75f0a646cc2ed313236555e083c1722f33c1926ac1548df3b7bee5661c8178e078818a845bb10162d42af569fda1f71ae87b67c61381a2eb5d2a766622b2f8e995cdae4bca4448e130ea336f58c12b3bd537f9351be6cab8096e41cccec8a1e0fc8c46012cba9d295436b56a2f00a2c39b1d52fe826a9651bd305a90ab70e8fb3ddb9c406eb3ad58075847f787f62e2044c2ae1c04db35a5882d70c4c0ba33866918ba5a196d02d189df0c844f30550226b19886262c734fbce54dd8343c95a833ecb360085fa160c7c95a06ae09ea1131e56a25c583f2fecf3e467a30e2cfedf58e57704f0dcd79599ac4eb61c94e091df685cff1cbdcb603c6d4959da5988c219fc9a9ebf430181086abe91e6b9bbb55b5e26d277cff58b8e82acc3f2c0e8c91adc003f0e57fa32aea4b94d2b0d0a53c7367ef73768c26e8887334124ed21687854a80b921257e30150a31b810f7733914fb2235834418c46fed3e6e84e0e2b3ebbd464799b4cedba67848aba517414ead3613dd0ab5c26045c67689e88fd459c01c52139cf63202d6814dde0d183ec1bf433d07bed0438b63178d8673b132c18e2045474a26a8d1875adcc295c1a36a5b7323f2fd83953429f3a7d40897f43659273024a434e1b599202dfb731dff6bd7cf6b408de165967e723a402049e30c58d3957c43238f84e72ec571fb22cd1ce671866fa8d9697d0aeaf7b39817ebb2217d4b6f4d310fc2ffcb6c44211bdcc1bc41074f2293fcb141b2a5e83b69dc66c0010096316feb06985afc5d37c28251d81715af894ce438c3a27bdb01cefc8bd024b828c806398c0e2b3c557bac3d67fa69ec332e351204aff42c5375037b45ff0a5787c7e81a4a2c11cbf688491dad64bce2e42674d9905491ff3d7cdabc4efbba2c781816ec9f9b957ead6aabdb25766cf4fff868f6b6d307e07dc6cde0701bc302913de5a952846b2c41614b40a538070d935c4ec92e9b7429e6882472ad5375812b723282ef1d2c498c91514e347f27396fb27ebbc6ece1865ab8953e353f4b9e0c3bdd82a7c8a994e46839358ac8f50a1b9aa6383e4bd717fdbce50ccdb3147db04eec1484eac18cfada47875d76fbf1e83f19e4384085cc4ec43eb32ec813f8f921ecbba917e1c6dd33fd4d2ab66f1b30b9f1e007293fc47a219772940229e52e8ea44b6fc2b6d2ba0ec25b8ec5645998d082d13d86022aebb84009fe1e06906678b7cf8b2e6e14fa44d308229604e8373b2c74d4c298688ff1b0c2de405e4cecc8ce771f6049394dd982013fde8a6e4e079d43adcc3e7086c03950d4d09772601b0db3245a7b202cd4fd60ee74464cdb7302811073f52ffd96a9f40cc5a5ef3d4f34f2076c54099e335dca7bd5698cbe2f6f3a5a114ee37c87efd16cc8f1368048a9b853c0c161d9e4c6ce5cbe7c70700667b9ee7c8b88d776f2f62e873c8c9fda20320cd8e8c1682b10381f9e32ad5d585c3dcb8bcbf471a0a2f3eecf821e5a4823f2d1ca5eb7961fe0bae221c784776f86a1368afd397d9f057d6aecfcfdf7e03e902ab48fa0c6f5bfc00478d0b262d0776b8fe6b48a6947f0422a78ea158fc415aac625fe99e7c9d6b21293f55aea57b563cad233141cc73becf3a6cde1fd2822d9521ac1c4ebbcd8369ccad050ab3cc78850e36e0731ee9ee182557ac9150e42572a30cceb02842692742cd496240146b30e27fde641164e4541334d730e634ab230573a4566562a3805fa5eb6c8f693d0ea643ba0e36ba57e72f38b7e70e302164378fef4c36ddebf70bb16cb02dd6ba4b16c3c75a6e5da5eb7cf1026d80b0b9b376bfba3a00e6ef03e09cf91e6f8c9d9161a746e784841ce86eb457255c9ebf72f0284251cc2cf718b1b6821c1bdfc146ccaec37044043cff9e9b016b6da92123a6db65426cca279800b07b8fe8226d7c65a8e4801a766662883d37d07b1efc92487cba06d69cb430914dd8c7b1c1ab78603f243971c4cee0ba378c8ea3b30aac7f63dda08a88f6fe8d4ded7cdc3121eb4e6667593af64198c3c6a5259d7bc717a441f38cffbce280b54f7a01bb4c842090720a3cd97b325e2b4e1c1f5dca916e481cd58375f135c090d677dad6970da8af2b33357f02e3ea62e49a4f8180ec5b9878e3df48f829147955b749c49f4c512b1ad4a08870511e3d334adf00a7399d148a23f584bf0bf20baaadb258c52d3e22621297b915c2d4fe92ed613d0ad82ff2e3b1be997c05c68f13d6e673f1282d02340dd5b73e8534aa879179d0344f903fbb3d544b777e32e7c58568b6a51f79f1b154047ae12d530a3552546f141bd3aef6a2f24066c48e73615f19e8c56b5abd59bad8aa0ce14abe57bee3edd954e64eb91c8c72ce9cc91c4fde99657db8b3acb0dbe77583f3da774a04e0f3b95fe10dcc5d86b1589f918a204d87f4bb675fb280e002d38f57702a1344f4dea9c1b016cb5372b70bd4e5c8d1ce9f12dbff90d81f7dd38b18898a0b74c09b26fd4923b54eb59766594a0102fc4b26372fa67b5a204dc3f4346776301960aea38b87256d0a74ddc44e6f114406fb02f79edc5c3e12e1d744e7c9d713a4b4bcd2c0c645893941369dd321da62c8117759f21c689feba27f48edb751900c93f975094c222d97880eb02c4b2ddd26a7d2df35e004f2cc5f870da07eaede10e95308208c5569b1d148a0956ccdd30afbc7d358a6a0df8e5df38fc7162c4a05f385b7096ca2c456d81b99ccbfee3c2d6f990d61c46df7afd1f34a57f6848c14f899fdf50daa6c8882b8d6c3048a121234bfb4d289d8aacd95b9db9c1dfb5b6b2fa3751fe12bc490c2d04c1cd02565cb360aa5549e0d11d6ef95cec85250a4d8e7f01058191a1597010067de69b3eefd685f935c16fe9c7abd8005c351b3efdc4cdcf046c2f76a4b62bb3738b8099077955a9f4e22566ed999df59684213dae5237f341828f6702db3ffabceb2a460844037a52f2cb99a1b4ee3de1ffcb2b1959096219b17b7035cf211b9f0e4160d93ae09c9f184f58203c1e7d18be48af641cc1c835e33a730da496758f2d079302916ffcb04817efc5876c789095b7fa48336f9626563a897f633a5271f38ad89420823493acb07abf86314e5b4a18f2411f8cf76df717ac346466303e8cd8354d33cc6329095934dec5c19b982e664436df2ce3e5d50ab0df5d53db549cc2f8f86b570596b19b61062612035b944d2d676c0b1dffb37a1b5889953f2f2077f6c05bc282dd28c5057740e2eef99b5591f8976a01ae5e1e5e286ca2ff395a40fa4211842e8d6a0aa93ffb8c196b60480d7dec3de9f717910c79f6e048fbc45360f8218664decd6cb2e23183006aa936eb3fb878044dd3a599b32ec4d5dfb4608d7eadd6a5742bac7666a5c812c5f45d913bc9a9196e79649a4cc2bd0790c4bd5672e9d2856eb9cd9b358b2c468cf6d657f492d27aac6a1f60496297a6380ee4f50d882a34108c23d3dd118883269d4d328cff4a4d49bd1106c949f4140f5e56edc39b4116b82b6b33c230138b5025165c3c64953f44c63842b2d32775c54caf7bc8b157b36dcaead4a040196fb7db2aa7ff56b37ab4d67cd692d26acb9d205947f0528a1a07f821583adf8ef49330d19894415782fd538a5889109c3648d54f58628fb29fd4fd929b1356d7a58cbab3b5e62f8c9b66d4a8fd45717882cb13ac36b455a47643cf6d63209e1931599bcaa756a12725191515fad940c4fa7df000f1f1b3de3c454f5b05b2cae27ef433b5101eed353a57b974609565858be6e2988d21a7f1944fcab42a71a39a864c0451fcf3446077d5f8108258cd4bc8bc07b4f9cc4b87ae16f6edb5297e2e112b6313e8e67cd99f3eae92fce9dc82a43822713a9acd617232fd71b8fb447389854611d9e65a5718236cb649e804e104190492c252b1b83b89501147a70145429f12791a864334a8fc4eb75c7b82da62a0d4a570d51202c2c9e8202d1e1da625aecb30dc45703e35aa3f182dc1d7f75a0a8c3a41790d323824b2484484e295b9ae746a45130bc79cba3dc3d4915917ddd2c0fcbde91578164d94fbcd2880cd883fa493b1d1fb8ce15226e86af76649a4111128b58aeac84eaa4b1707083178781e6007e95899ec2130b3fb931f0c1665b9645fd8fde6c473f5fef1e97d0bbe89a337399138dbf2a3d8207b6690a42bd14384222f5941069556f8386f00ff926916a8144d0abbe74f9436ade4e435c30ae3509838a9cfe139be148227658a45fb0b4a3351290187a2a4bc7b23a0ed9985bd6f77f6ca63e04e34646af711577da103e8860efdd8a13e3cde413c4f247f8acc0d73d73e58af6a99a82fd066641d39a329a7627816282d864055225b36bd5171cebddf1781578f6722172ea1d5316945f23d56dd84fe267262edba7142bd5e98e43da951b409ecce000141a87322fa6329aac45163bf95294014d74d496d88d55113e92b52d2eaea007ec8f3c4a6025245cda40f661f2d404f8ebe569459bad9f8aaba2af2629e6c2438de87979e0a6cdb98091219adc638d3146f1e3c48df2b81bb75bf65570a2e77df736334ba63d3ba446ac47e118e940bc805a158ada6718fbe674ff60d6883aa0081ffbc5b18728e5f40a3e308fb852f6b7b7e3ea836a86ee5c9590778b9bf478212a108948a8fcdc2acedc49c0070fa9da8456f64092ea2946f0094cd31fe3b2bdd038723763d22491bd54a94a1c00831900b0fcabcf270c3947826020ad3b957e350d752a41daa5ddc77af275e0d9ec30ff5606e7575d46d4761a5f26604a8bd89934acc17e3d06d97996cf51a080e1a17303298bb1db24bf3b3676b8670dac12e9afec94fc583c9d40df3f4c1ffbde19739a8c5c84d326fc40a2a5b2b6e7bc64d6ef5df72cbc3d64ce865dcef42e5c7a087f24e2a386c5f2d472a4aa3bac1dd0632fdd52a62a2599795fd23aade367a478efa268942477d99212e89dd99a7f4c691f78c3af1c54444feea82ae40fb409ed3c990b1d13a762eef123d28bf87ce6cbe63a1567c4aaa6fee8be775de781c895748d69857108bf659c76c4fdb001006e5ce04bfb840dce6b19c2df54608d59b88a164122ce1f0efa1d26790763b38b6062a04fe5d0f7f018582754b78f5e1ebf9678aa1024e693a3775a2a53532c052f171ab40cb03fbbb84f965052f1ea26c6010033dd708ce9eeb91ac9e46beb3e07621c1e02f089618b692eb401fe71ec6d2bc78437905a25daac944b63a668f197d8cea6528580a4dec43937435de44dc218a3bcf1f19df3192e79c07f3d514aa5c6b2fe50e2a36f19b24a418db31aee1ff5c826efc8bcb09a3c3c350c7784bbb99194c04090add13596ba8fa3d11d27f9ce55563379c150a04a7ca6a446fbf7b55be292c5dd233c75d18384d09f047215a69cfdf08a23237697ce72bf662f5e3a979339c0ade8e5d49bce642434c82f12ef92c5325cba64f9ed609db786aa91494347d2f356dd2df7ea0528e0325a4ea3cdd1bda8ec70dc0d7b6513dd69c44ae1fbf35c003c2e9ff77f80c9c41871e4ffe51efaa9ff6041acd849daec0510a19091cb82689f0e49dbb53a7134019e379c70f63af0140b00023bd5a385c921ad0cd0c5a6478eaeb3a947f172b8c832c9325402d94b0e33b12b1cab29f47552838beb0dab37e913ab079c20eb859eb2f12be77824c129e57c30e2332059eca0f788d2bf83ce6c6c6dac5078cebf4fb54d8e7caa9554837b07339da46131e709c68a303ddfc4fb8a84f8caa8f9383baee30c0031c1998a59b5e3e03c217d64f6142b2e3882be188ea7cca0e72cc25cd66690c6f508152959cb2160ff2d6674fca237c3ad9c760ef1ce88f3a6240424e8474828c84fc41529bd97060a6b106a6fd66635cfe72f70175dc921b005399c2d904d111e6032a402f7b82b0bbeb0c82104c8aa67cecede8cff47ac82f8da1ce79587e44a78b6622e9c0cdf835e8db2a13301b1f9c2858a1447c9396e388cc65ba0889e7a619a54af52df939f867b2cde353bf66df8efc8a6944ea83dbd1d590860ddf536a00b77fd69e3ca4810eedc49b4aa5eb4db8af6aff1ed0d1685f782edeef8ee876427288f3f226cd666bc80b0bab4cda98e1d186d9261ae917a435c1b0641be3bf8e12800b976ce338e131c47bf41360d718c0123245b786a1820b35f8ec7d7afe59c21357a1b9d7cf508b2a90cc495361259abe90ec471fca4e7ca45cf5a0d32943949531eb932b73a031c81e40932f00900de0ce5414a0cb81e69359e009f95615a23973a42e81ad77187c1f2500c4ff4cc1179d67a4663ecaddd84662aabdea8948fa9a3de1d0808ae58b0e0c7447148b81606d366abd9f629c2988ecf8bb9c06bc650dafb6cc5088d397c869dfc9e0000f508075a71618025cd1ce15a2d078053772ade1bf72c750efaf023f721e3cd86ca3f9e170ba6f10941a5c9d86f8bb3585743851c9c99eb2bd1b1dcf9e87ec02a88c71fcf23c03d66bd4085243be994db59490521687c022d63b621301c700191032df9b0bf670ebcbb170cd2b98cd4158f649c7c54398a52867fd426a9a6c895debd353d66f61616c82e106f60154927277d0bb3ddbb083c9ba5a8ddc64c01de3ba226c4c64285a54a9f0cc9afd258bdf8692044a271d2daea96976b31d6751e128e275ae6eced20db6541c3aec8d3fdd8f68af5f04e542a9e2dd5da689c471a490a8b2b0279506eb91b20442cbe99220eb09fefdd7d52e1cff2998bc8b735b07e93a1c6e30d043a8d4beb91500fb147c13ba1e62afa859a19b13dcb08e098eeb02c80f671ed5fbf28d8438d345bbf4a03cdbedd4741eca84867c7eb88386bb870f97609382d21a4884eadf5c1182e55d5e14dc47aeb6650af01105e8f9689f883e2583a14421b4e16af9dc7805702be8ffea8bf334b595c7154f93d16b685cf2b8079b0fe47b902d36cebbedebe24f2f16e0a0cbb3edf2952d7e3735f1dd64bcb04ac3f3b4a618c774aeac06436202851921cada14aff6e6491e8a105d48c05868d3e1323c56bf2567ea552788b000fd19a507594ba8a6f20690aa8f68ef718cc99fddd627cfb95828263651d4700072d657911cdae8b8c885fa61b326d61b208ce230d125af79e5874477d1b86796878888206c12fcdec710cbe9fd6111c3cf30ee8fca73be33714f6d6b741787d171bf7c8e7b755912f6365d6343f6f96794233244b76d9b9bd6e641775b7c16afc472cf6b7c2782f74c3d982ee3dc4a36d2fd3539e7c24a1ec9f3ec5d1731008c25d4cf68a20c68eaf890e8f70d6f75247f3ba8e50ec2caf6b6753c08bfa80f6220a36cbd20a4c1344d8296e4b0255c4c507a5cc5658e722052bd38a832af5a0cd7050d0b7cac5d8d1883fb3528c3622a7b1c16b94d34bbfea5f44661fb4084037115a4ad23cfad4acaef94a1e38ec95b2de87d343520511aa8c2f04153fea8dccbf799d3039235f850f221b41d08f0824aa1f4da1dba5cbcfdb6cbee0cfab558a4924bcf69dfb5caa4aa41237d57c6c363b9a4f4364c9a79fd396ff9591547e66a9176c735b6c3e86efc1cc49a5ad7d71e3eec9238a20f32fca26de4eb5ea36b06eb9cac56071044a66f79eb549c5c072c65ac38f8a8f09c33437bf654e0e0db69aa2202bee1ad55a9d20d9d23211ce9ea7291ab73488f5fbf28e30231d9bdad378604dd1a1c88e707c6fb6ea0d7102078bb2eb8f87d1dbd6f54552e1da4ab58da8791f3b544968d7ef951730a8dca6b2640fe8d98b862b0b60606cce17c1a85111a7120d7fbd87e7c7ebe2fbde99faf0f79c1d352a700a072dd8ea7468834b2771f558e49a65aff68d0bb3e90be83a8f6e208112ba86f99c0e43b34d9ea72613c64a75da73e726e99152806f1dc8219874148ea148dba6df538db77c3c30d1179fafdfcd18bc9bf6bd5ce7d2ad457d54687b09deb243c921688199c5d6ba2efccb2e2d7fb18c7881eb76d45d2e3937407308f732b988aa1af3a96fffd970d786acd348d42896c5a898f6dc45db326f686fb01d9065d4583ef495f536079179644259d400defe2af32d87399ec2c39581f7c70329fd08b2a2c933e7d1033e14d2f1a376efdacf0e74a95125d3f03ccb1b017806580f913091ab0976ab02228eea9d3321f074a8fa1df4baf78e20ca43b4303b54a2263ac9883132d6e997c4f3f4a571af93d2e9c0bee173113c82f0735647220e0888dcd95588164b0be11cdfd508b6a5db2605da7bdb3470fa2f93d7a5c23054e6587b0e0200913e4cce24e1268ee69147ab0e1e36ad9e72811aaadc9c7ebd9223035c0e890e8d075ee59117981a49d7728f8cd7a673578cda24f276ddd965467202d1892623bfe3c8385ce06f02a26140763dc9588e871140bd56441a777e7b35ffc7b40e5d3488937865a68ac4bd27f4e4d44c6eb15a130d796a827c33f80ab25eb78f5799fa977cd2f72cc44204d0b393f6e1d0e5b70e320ae19baefaad067bb5f55514356fa5351eb8222bcb264630f308f176ef91351c40cf37c19189528a08046f4b96f1dad6bce796a049d496ed4fbe67b62f1a2d26aa2cac483558e8eee051743f51540c92a076d8b188ee280d9027afdf4cd8706f284e4a488dd5ff26d902fbaf813caac99ea8966fffd865d84542924d100f2b878ff6eaef9526b75f4b5a7e39d8b7f4aac1308ad3b604539fd06750bb23d412b8b79fed223c76087a498db9bb32080b7d5ce4ef17cbe485fcd20cbf1b5827bf51bcddf6ec55c48d46e94cf6bc1c18cd063561baa4828716a3f5815a07bf8f0cd10aaf776d66c9038d7e9c5b18ab79f33ed5d162a19a98e29545a7941d490dce5239c0da0596bf6bc291b6f4c09cd2556de1e71818df285dd65f43e7eb71614e4375066a6154df24656497e76c80ce3fbdc9e6b8ed37024c47fab7822105b83cc9621f5f01705e306e233a1881eec17257b178777766f2706b547f59655d41ed21564218780e5259c489651ed9d4d7e7dad40547fa3c5112b7c343b20cc5e0f2b4f975bfc4c6ac0136247114a52648d8fd2ce4d3b03941520913ab7bf903643163e1f14bb927f761a0bcda1d58c66c7644dfb5176362a827f465c63be6ca8659186d2c490a6a3a553bc95ce36d20153a53cf6a64e9f7cf8766cfc7ba7e38826ce80369e46daaa2756f8355dc943b6703e6eab424323c9c850300ef2c7bfbd8c6c91db0d549fa595160292183f0e49b21f3f6428015728a8fd150bfbf05d71acef8809c5c6e2d2c5b787699dcc876a5b3e3ad3eb982fb121f334f1d8b63311ec7c9bc0cb1ab732fd23ec926007128963b2b3a2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
