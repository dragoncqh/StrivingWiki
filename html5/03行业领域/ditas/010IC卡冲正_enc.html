<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f430df7c89e73561110c1c0a80f754dd049407bbd1615b36a0981d5ff3bad59ddbf23e7cba14b280b43b95945bc3d2b2637becdd897acbe68582223db0bac3c7203f1e9aa056705c4bd73d98df68341669af1517a39a4cb678d8f37158bf328d44aa7cb896dadb6812b376c371d7b23db7ae3560c5f701f958c6a700ca1858a8d4c51a2544407e40a2c483d6a9999af626fa0ceae23f58584022a330c927918e7c47ade38c18782339f81b6a6fe09bad7312b5e9168eacbfa82f27e29da9509c363b4854b0d8298f5c7c703422983f1f694e8c32cb82c9a000fdad401abec5cf9bbde4acd5c794481f5bfede735785c33dcf54927ef42a2d3bae18e904c8c82ff16e9ffcd02a6c62788df85a54d21a8883be00e221e287bce3ee89876be45962d97fbc8ffafa0a1f5211c731fde146bf1c5b374c859495afb5f79ecc1797fb2ca98d9b30923750d331e48df5cc7da8c545b016f996284e5de97c460b714cc5d1eaca087b82140130267f7428cb39155faf15b804a331829a446b0aa1ef8b53e162d05dfa2cc87be6ed49fa2c782851490096bc7584d080fff85c98a4ac27f975fdfb3d8ae18157eec0bbb209ea94c018b55f90ce9c8436f4fdd06f8ffe78349efc632061fa388f202e789446f3035c1d4358f42644878f434fd744626d5d5e23b9c08703d11c0a1c81ccade025c11bd9b26fb470c8f75cebb68e51cb7f8f00eab9f276dd0ca52417ddde812417810bba9fe5dfbab8a6802d90f0d4b90641e0582318e86aa377dd82438ba12b74f873e4dccc97680ea7fe3993d3cb89d9bfa43a9c35e915451c62810d48d8c264c4649aa56e5d6daf13a32d692b3195766b9e1fb4ca28378f13d87dc39c2d8ef2d0ae78ddaa729342dc9bea65483bd8f67af2eac36c2d35453fee0f17daee8afb1236b1c387a39784b0054405e7e449bf6e9635a917b200d5d5e5ba5978458143180b7fce879e3ba7a153ba9960056e33d3ef6f6a3131a67dbff6b61a9be6e3d2f8200c9b7225dedcb8ee55a22b199ec015e98a769ea3615933fdc0ca3d9cc6b0ba046fb0bf1a3637686d045919f171b0862c07708f3d9b4a75baefc069147a887c64782788df3daf6a4c3ab34929cee50fa9b6ceab631ef5b473ae4921a1d8000f008d69ebd6721e90dce6948670e71d5d152971ae62d99c8662ceece849380499d92f52e5848ef77b2abd1e0b3120c520e5dbc90d0d48bb7f5dfa1aa9f2d83a9d78b515bc7e8ef14238248330fe1c908d55e0c1590812320a3db5bc3558c91fc2cbee60f32c3dd189f5048b946679aedd5f385d7cd6b8d25d9c23f3b9342abf9623193dfdc2223fa395785a9ab937c263107bd2ea4386323fa6e5e21e5b648b0eaf4800825b61f44d552105b6c991f97c1860eb4d992e3a2addcd15a7316e2889dd32070d44dc8280171893d024d1b3f9c4a1f32c95e1efb051bdee970bb1c5f42d0132e055f9f2c37fe45d943c9e3d4a83e7968ac0d397d7ae08cca24965c0a665d59480e4cbffb4f149f87e8ae06a3aaa0db0ea323e0dea66f586953084bd569c2174b2e54021480d95082de1153cc56b2920e33e2163e8ac39ea67c45f882bf18c84dde682fb2befeaec84c6c88d4c231f58d793f3b62b2f4ee0217820dfe4dc0a8227efd1918f4327177335fe3b3815adfb7e8dbac67cc10d23699d88b46e02771a98c2cf7cd1a7e5d7b6ed67cf3b7b50c9984b11203a4fc789403b425e6a216c6238c8015e125949e1e2c96a5041a4a7438d21b0133407fa9227160f9a63e9a0c2ef37ad5b53c3762965cb96f0636a37c4c2f7dee651c64935655718f74b525755a2acaca5e3b55a18837e7e6c52fdf8f18e4f1ff3a9994be74953b9eb555f12761108a573764865dcd52ff47db12a977f1965f4210fc08956e88904e7b45900989c4eb88e8f293d7bcb03588caf2efadbb432b0aa4cd80f8602fdc2265633253d9bafb5b7140617ee8b6b9cd1f17c76e9d4d804e7db1649fa751d622842c3ab8a384254154ce61fbceff5a9818d2b3346f0c3e20d01d4556a0e7397291aa3b1ba8663c0d64410ab7a4d8b4f0c5b0b08290219596eec429cb26443a1ba7e98f452cb6e6f4168ee9b1eeb4185ef3693829aed5e8c23fa95371fcc464bac84a955d1e559aefbbb153e59d1a13ed5d7296cf22208ae49828ee79d52f8e97d7f515da6864ee5098e6bf1bbec5ab2b8f385b79780a69ef50b486c92779b3be1493fb4b0a4bad71a595afa8b674683894d366df12e05502be7c2216fd69f1beb3b8af642a45e9871bc1885fded11b608204adc11977f5689568a6b2fdd53f25f595bc28fa73c9fae853d9c91c6a8870eb243c2edfcdc0e918ff0a22b7de4069b3bfb2d26cbeaddd0cbdfd43ca48ed13e40e5ce4a102acdfc6eacf7e22091b6c67201372920295712312a4a4f80cd12c8d3eb20ba6973112bc3846358a2af30435890332affd4f0f907286cf26073e87e098c1d177fc0528911b593c0f8bba3a32836fc304940e497eda1e78f097fa6e09a9e6cfbc9fe25743dd64742ba1ece8655f27a8fc5a7c6def7b0bfd0a7d2628e0bccaea7b26e2ada835b0ff49b1fc2901c3816dd84c6e0bb64effd33a0737b6180c87434ff9f2ac21703ab7a751e360792eb685d285a2b0ac367e313d55f59eb549524477e2e7a8f27eafb61bc2e0e0193dd80e475d3aab9a96e98979fc1f76c15ec03a02447bbf4d3cb0678ac6af7b7d776f91993090be114b7b73abe373fd2f7b24be7a01e56e61a12b2822b20763989337f256ffda7245e524dccd30433b497677f01a769015e47e50f4feeb7331b541adfcf6886585517eb01595a73c4dc23c593f865babe5f11b7b7944b5262e3469df5dfc5509393cdf1120d8f1a275240c7740e6ed9c8452465afddd494051bfd49b76f71817478f09e49913227ddef5ded4728ae114f0bdc6b4221ddca9d597fd71b7f4eb06aaf2b917ef0ddfd12eb8e12731897a5a6ef5d43cb523fb7068e96d199a1da44b8945be6a70b0c5833e5e8eee3d1e887b91b70333c24e40d6dbabe737d5a5a39bb220512540bf945fd3172d5cf054b1dc8806fc30a228687e65c426f4120b66646513bdf9dc18251d16b63a0b16afa8a7dec568d368bd22325a337b3cd19345a61be3356944fc491609a81bb5242564f27dccd821b5d31a2824dea17f3d46296cfca616bf625794cd00b0901b1123f20d2ae2ed078209fd73eb24807f7e01bebed42141a328b7f7116a6122ca71348bd940862df41ededc2a60856aaec33474fc99beea3f4c0749631f911e4caf46884f992d2b438893adbdfb49bdd7b896611bd9740e2755fe11cb02b8510378ba41922ca55cb332dfdf3eca2ea991c9a76a971e0a2e7df68588ca02c88e565cc7b02092d0ce1fba0aba5d1a20e1248c20416b9953b564a72c7cfc96f9b28e9c00154eb93fd3eaa0625d2b8f00e9715f3c9b6f85bd7c4fcb3e210b14a305b9267cf7dcb0d0b51b5ffb3646c783d2512235ffb1f642c328034c6235422ad2a4e5519ff2c99c2d3eed9abe15434a91c451ced6915c86943cdde60d036219f9162679f2c1d0184ba0c5c97cf56008832bbe4da0cf1bcf1667969aa203001236a92d93085fa0e9b88286546b96728ce659cd7b4c79a4d99ae29a830901444a8a38d4ba5c8cb6563dc0f4057f122728ad31fbf1dddf907e2dd68659b98867150ebe204c89a6151cfbe29f8e908a6a329af7ac039db52af53a92cc1e334a1b36bf308879718e6078a87f7fe416afdae73d80384fd92ce51e65982507e6210e5ab2e1f66e2dc5b19075bb1bf75e97d3a3f4934c7957b9af50ec195bcee0222f1340c670cd7c8537fee268fdfc49c0fa3a59303642fc0f256d8c2812a23991ef6b17506951910cd4a78d160474736e0939fb5528e113ef4bd6a76192986d3e6604a3c1ad769d15011b874405b74e451dcd5cfca16d76267463984782d515f031640515ee97328570ce08b79dd24f271b321a0a360bd242cde1e0851b6c999618c162de65f5858880c4847bd78fa2a99493cca83fc6b853fe50c50d58562059928c72a3a8ecbb5a822f25e9d4ede95cf8eb99d9ffab1aa6cb48b5477dd33dfc0fffd60e2cb4e06daa0e2eaafd1a7884e3e8326bfd417780608dc8b7031b3a4fd8bf0c5479d3c82ee36b3f27b2586767fcce920d090aa9b418e4676bdef79e9491d6a64b2e3176b66b50da295164f0d69bef1cc599dea5590ce1dc5b046e3468e8dbe82e4b29d554888155301951fb8a54c6e1c48d28046493618af555112b7cceff8bd07091efd342838540dcb4cb61e92fbcd54a5d88379461046b03dae4ce21878bc5c19eb999d8c373d5b3dd1461f29da6cbef80385c50583aa917c44b0d98a4a31e9134f5e84895fe76c4b4431338f4f6383a5de16786daa76218a8715fad330198d3590a920132b6069653f58dc55c538128a3c184b82a0c7c5dd39b6fed5bc70ee4d7770a0edfb03066884f09d8e31ccb2763fcc73092fb4e59ef9c0d689f9cf16505628954651a664578f9c4765851c8f97c119554564814c6db01598053a0c3a39cb312e43b7d0a837db280b3a807363b358b7a604d3958f25d489a730c60cf70fdca9c7725116d08c9fc4afd48026acb9c0967e6d2ba0188c90545b2c88ca478d4460e749513f2aa55725702974598ed6e24ffa1be6556842c33e2b5bba945452ef351ae0753b7070e7ee70d87145aeacfb49bc2a65ae6ab8c5ba3bbccf4e4838bc92b9eb7bcf4bd680bb1b645ba88942e4b7411cb19d14d6d784eae70314f61e1a32647f84e3c230488b816c31c5b68bd1069462564628e75f9a57b1fe95e44b9f251eb7f83517c77d6cf387851b29ddd9155019707d7d1e6c642f3ef27393c36b3153c7a6103785c42d5716850c362e55af65a569ba90af01db336bf4cdbbcf9df2cfd8c6c1fbbe2f9ebfa22e49b03cc95ffdcabcff35f642599716c28acacd551e9f00b1f6d37602812011f6977a8feb9ffa047a48ec84895e55270f8c17c74bf001cc537f776e83c1bc85b440fe082a450388c4340ed35126fca7678743c5daeb9e7b083a4e4cbc46f14cc1a9eb454713faa785e30584c982ee540a32b97fac68b409da3b26463ea58f58c764ec9ac76a1ca2b9132a9935a00c5b5703b14b676d347996d9a91bce2a654cc5ff1809dc407ccbbc4180c5bc595b05723b542e9e3f169158579a56244e9b17a33f267b2728e698e0b5f20030fbc845fd3417281af2340e4b3ddf01e31047fdcc253aee23249e09da6c5e6fd4c2e2930cbda6b6c3074ed9a36c28744dd7ba001a551c7af78c2f3c82927e45ac6cab56c24543588deaeae9b988e9158d2b905412d9231c1e05bfba7d5ff830c21f540d247856770041934e0262fcc8eec6127be482ae2f8b384d21c6b4cc8a90d28494a8c18addf172088356529eebd322237908aa49c752c1dd669e18f20ebdca2d3a22ea0b0400b89f131d2d4e7bea3db300a4c803d91a887172bbd9c79192a0913e6e155c8593a483caadcc57f1983a934a016482437695e5568d36c9813b3498caafd149974f5b05be54177406414de4f6f8a50780b4d502993b7af3ecf8ce209d6ccb3c11aebab2a4b3ee9b4166a273103883c7fc4b48fb640d9743dd73d20a1e2bfd110364bcfbb4dcedee9c092b26d2e4e26ae45fc25dc3dc92a6509cefdb2fbcc5a3b42f5bac88666e09d47c512df79934b76bfc12e4271a792cb90df996b730168a495916a8981f7029e0c09c39e2289ace6a21c7b207423dff7644bc19a36c2ad5a5add3c92fcea43746f4c683cca81622adb37ab1f525c40c9bb991e032bc2321ed321633f5c8fc2646ac1c75ca223bb2d7295e79f43f2c140313bef3ba9684c9ef790216fde6cbc27c182b59f09f09b90fcfa2730eec8959468ada204d916e3426e03442d2b579708459e3496195da5cb70741993e98c68a70afc02f1b80e95f13aa3d022322bfc536eddf2d634ca31056c5a5b5487065f977584569be4f8cd3097fcfb00778589ab71cc3731543b452f552362ea7c58912336b2c2b50a858d6ca1c2f2948f8d92f177574f7e397a5de4fc9453cc75c2dcb4f154743e1fcf3d37b2def27b2cfe0f9843a16a6c0edffdda15e727abf9dd946f4db162f24b94b14190d82cab0087e2c935062ba5e39584d3eab766bd9dfbf91543af10300da38dcf7093ed7c69b08d9f5decbf66d93e9b3b3cd72dae17aed2ca99b612cdfe4e68114968504169f4a5ea00d51fce288cbfcecf98c7bbd79d1423fab90bed5dcb4040ea6bb4fae775dad20d5162f055d9ed81759610ebe276b75ca4be22a3ca0d7209abbebaaa953bde6199f141b5b45ce3baee6ed919823b71d29b098b9d736441b866b1d18ddda26b617f7557181abad0ad7bb1dfbd9b1c80eb499e3a00dc31bd37adb50fc7628b349dca042ef60c9da58d72ddbc844e4d25f85e75234580e5606e938216390937340c14a2b02b2c186ac2aa25df1667929db861e822f5f26fd49c935624eee86e94b4e1b07315a68fdb5fa63439ae8f9d728b60732d2fa62929422beb6486a7e4f485f5082a1b27f0549b9e6e95a949b5903bfc7af1a9248ff285f441f72ef5a13ed7a476b9ca25789b4d474de79a7d3dc356575336230d9166d97547ab9b68f688609bce10a358eadb131cbe5f32c1c29ae59f467a1851ecf9efe18644d03c639140569d1ce289bfb502d5920bc4f30194efcf0276dc59a9eaf25ed6444d1f128aaf56560e3b1c6c931f5503fabfe09709d4fab9971146d924c08060427b9fb5353040172d33eb7569879b4d4082a3f4c64ed51f0d396a202643130d700fcecca3927bc830ea18f22942ae82b6ff447854de5ca06287238fd0a36fa87af78eef26cd4343996eab7e35d57edde8bafc1ccf49e44cbe1da9cabfb923b1a74cf31b2890be58ca47c8467f21f4afaf45e1dc3af68107000d9117949c99d36ba9f98c60d570e7e226f4ca53163a29d37b724699920be1090ea1eec6b3e6b0d73566aa4d6ff17a05d4550a0576a93090633a1a189c42be071bac9df9e147c3cecb32b22d0d560c5ce5dc45be91b344076778b134d418af3b687b242113d64273157c03683a6fb0b538596f3006fe90d4f2e00305e61b8f2d0e8ab86aeb755cb353d88c04deea0f2213f7dbc01b9a22c658e0b00fa8983a159b6263f69debdda57d6c880fb9b838699e8255b039e8bcf39ee5294408587fda6952eda421dfda9036474eebf705d3934d17419c36d21df0bdccab61718f5f8f89f6f45aa739253561a7f067f832602030f22e540a2333afaca35971b76469bfa74407cd0f1805261e6e410a6fe925f5379c6456d6869e47447a5067d6a4320c73498cdde29be056e55ab6e5e04ee52f35ee3cc500d7c9a7419923487381f7a74dca37e845e160281f980ca1e76572d53a128a017553c90c4945430ec2179e7d212d200f5c5f68128ad053dfb3bd2cc8b8238ed8efe002f3fcf4fd4845699c0e228421e4d35d905b6faeae5abfe4ce34bfe17b37d704967dd9cbcdd14e7574fa259c474f2ab4f4e10145cbf7cbf8356dccad71f16080609d2aa4f33f48f88cab33b9273f03a06ba89a0eb9158c200cbc2c99623d064ea3291f5daa383837a09f578c45664090a3cfbaabbc46fd68f03ba347b50427f58fbd27eeaa710c13d7a9ca29288f8a6721389ca30c89c2b887300f78b9171683b56f6e9b1bf13cecd22ce88b1c31eb85596903b154b23f773c4976a526852c8ca4bf6a848643e69d8d8c4a18defebc96b375ca2698975405d3940588b075298aeb9175b113f9acadd404dff03f4fe6072373fdb553b363933dcc4b9be19655fae215f6b7a1d444aac23bed24b33f467f2054c8e919e62e067cd6ed673bc16ad0997aef6f9f505bbc4bf5ffc23f997963d7a5084cfda7aeea6fc899a26289732112bd51e9658e4ffe34aa90fc3e3bbedb3f76d9055cf8130b8dee52e7e1a124801cb497db339f68e2d6ce94fa62c21e91b447d51d8123a6f412ec76ecf0e3c12a0e927289b5b3aa557b3b779e61e3b03aafd0120a357667cc4f2753275ce4330cc8a4261a9a283b923e313d1cb2b4bb536607b1f0cb282ca18b9d15be119870d3c105dde382409e111499c21450561081f787d75f95043309d2266b8815de71227b63314944fd520c3c4165987f12ca8881b7a5efc75e677491732dae175f3ef4f4d857aac5acb9000e0fe4dc7c14abdbbb6cc53d3bb871ca0fbe96fb6b838cc24ab063ca3c2e53c46003f1240f4836a6c052eb9568a11c74b2ee9d84801ed4e7a2800a80bbf09b3a65fc4ccb06a58c7b57e5a86974f759d689a8475e17d58f82993d6fd767b13169c820d5deabd4dd28ef39ab6ebf600de97641ce35bce67f2a5674fc5443d263187f14fb6d15cee50994a5a67ff22564b7656e7275eb1b2b69eebf957f869575f7112abddb958b79a3cf9ee1c6c8a7e4b3007025d9675cc710ffeb78ad612010c225f6801d7063039738d46166b6b45ba9832b221783a9c19762b695f230613bce43d14e5b0f567bdc88b8f35001c84e50f67a861b5ab16700cc348d54be8d37c5c22c40237a969d9df1f4479375636f282b1d0bb3c5bb35ea161204d817e61a128e78239ac33bf6b6a0dc2f9ba6d8daece352dff8d8c345b85af7812814b28a88c5a796b62df61d4279b760f2968d76f89e6b08cf3ef9ddb874bcbb78095dbafe3f8486a3e4974df5d4cddd12affb7bc29687563d3e3ce6cab28554bd2afcbf66f0220bcf75f2f5d920cfba76e6c2a567be30e926eda5ba0c09e5acf3a465a8c399d0bda72ad2972adfea60a4531b6e6cbf64a74e93a157062fac631113d380e89ebcfc1c8a06efc78917d275de6dba50fdee9968d779402e462d562c3567db16937c2e54c8d48c635101574df0913414fd6c411dd2fcd6afde3cb23e177cc07409e9f8f63bcf04ba1d7a116ca5370f54746aad0d25dc599a0a81170f8bfddbaa37991df7b2a49253d66210eb7205fec35da128c505a20d7f26365a6af3d44be1289f506610fbbf7466b4c58fa743de2a4f2263f9b580eba33479b9a43708200d0e6323a975ac4a29c44bcb2adf8631f14483de15810e3a1e3baee36455df622fa614ca8ba0a20d07fc158000eb281e65c9043d671cb6608c7a42567e6e7212f3d0294c3c40b2ef9eaf241dd4e7af68b5965def41641a354c244c37a274cf3a3c1f7d6419be4f4fafa26c8fd5ca93119616a9372c0aff2d4c8a3e8fe981fd73d6a3a60aa148219fe7e3eaee8dca2d033efeacc7ea0c6033ca5ae8386af1fe7a84f00e7975aaed9751573e6de253da8555931be5f47c19c4f4e1e1d72572ba8ce05f39c3fd094503b654526badb3e248669ec87ddfefb5e8d03ce2e304d2255efb28fd00e5f4f84eb7ce54a9d4597e866f6b57a505d73513e3fea004fbebd1dc243498ddc5ad8e24bdbd27047b92dae6853b8b06b103a01d311e01501d7cee2bf305bf1519290df95eebae3c875c8bc460f9edb7fb4914a14759ea96b7bffe629c1a1a6c956a8704cd5a98157eb685f0ed0758df3b77187b51a69bf08a29fcae381798dfa1dda68672b06cdd1073c5a2c299d72951c58f99595a16dd15d71310484d1284eff23a1eadcd98fa0d2cf605c467cc9c2a93b674b82abdad5d48e2164dff92baeaceb5454a3e4ed94d915851a9393edb5172c9ef656857ba0b5074e68bac4fe4b242e3df0d7863c159a264e4c6ca5c87a8b800ed1d4e3b594da910748f3595929c63a687a95281984292845be067aeaa9cd730e33b23104e1373740d51268dbad1c73f722fef44c538ca34e7d7fc7d48c70fa60d048008d9f260113d09d4b0bac6629656b038a5d4c2fac70fc1815ceac6c1e8e656d4c800778a2f6778269d9f9aa13615a65a54e10c8b66c196405c0119d154396aaad4db8df01aad8310de59f85d659f251b2339ebe00736accff7030f18ec46ab0f957f6c2a92a6a05cdea23acb85b2f0120891a5a3a7c626bdbeda53ff0914ecb1fa41f64309cd135fc8bad4985f94083da00cee9322f6cedc2de076a16111f35e4db9ef938b09796c67d227f2dbf2d66154d3d640a8f8c2bdb22b76770ae091afa657646ca6ce04406791d84d4bf4810afddca904299fd91446566d21a921d86ba93d165a02962ea5a3f91cef27183f4a267a6fbf77bbf8ed16d1d8acf263d3a0376462004979c2f61b1b652abf814720f8f135a6faf2d4f5616ac0dcb3201f378c83fb8c8880ba6d1d9ed85acab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
