<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"692429c847819c6af6734eb97cff38d8780a8f18873a34a4a082dee40e7a44dad48bae39f6061a9713b4de03fd3f186bcbcfa585ca3564428ae95e43e3d96479f0bb7e5ea56a09074ac9c52d066a14cfbfb7139ed192524bce389de8a5e4e107bc69bff5b28e2ddc588565ccf1101168f3ee001da99d61fe5f598f685b36301c8c7db9adda143de9258245a6356805c02b752000d3f439d402007a4ca0b5810216e836f871cbf9dfa88126b40ede81a2baa090150b768bae4282101e79a045a0d0b12d528774af6069b6aec220c1e2753db7f3fd3efd8f7542bf0e7614e48b99f2ebb0c69db0b2391fac6e823536132d625ff4c1b0c49e5705e5b8a1ccec212d63a41e241757bfa90a38ff2adef36bcaf1d5d6e4fab216128e75995c70fc6cdeb3e7ffb5aaee0438ff094bf0bad73d3b6f2a21b7095d1dd53fe2f80c6208c255bd72e6c6fb9be9634bc6460272358897a3f906cd88ef3a0bf56d1b5cbc37a3a9dc577f81de85c1fe65823bc8ebce9313687be3fe00762aeb7e202cef79db5830088a29915af08eeb39f4a64936add42bf7cf7333c218f14a665b720d3220f7a9890c2dfe5391ad5ae435e289a571a29739934cf85e6dec7c3a9f9edcb2ed2f33aebb62fc956208c95453762183217b036cec21b60a31623f303c960c3433ce6d3e67ed54fe0af6236df6f43b54e3c402d56dd2b81038d14062abd12a1a1acf78ca7c097b846b17dbe81b0c628067ac30b0bb9128eb360b21415a5c0d82d568aad8569e34655bb4edbb05e44d9158b6fa66768842f119d65ff47317068c0dc67b5dac7b419f34ecd4f918eff1fdc558e76ad5ec60c22768fe43a6846154e820832de14205c74aa100119328eaa84a4ca776619b32e9948c1d3b0b16b5e1c72e38b4394873df416eb79ce669bcb162c8e33f3f6930d13d5e462b47043c2445ff14c4af8653244d938f479ef7cc87abf2c76bbe73e1edd698575ee65c1d8a4b0a16989fe83bcf74262c74962741b40482d6abdb927d0ae276fa52125b03a435d3eef3cb5b94199b6b6fa06ea88c1af05370f36e9a66f6ab3e067f5c78f24b35f149babecc3d6d901a892bf0a33d3628ba2aa72241c89ba1f94954681a798c8a2aed91dea9c2ab6022d0113b24d75cbcf9aa5568e58fe52e1c2bca2d2a55f52b863a28daeb26f61fb73eb0559d386cec3cb01c40d4e005b2ce36b8b6b5fe179e61e57250c27e025f22df9853b3884f5d6e31434d5afae33fa4053bfb7c216768425cb2c452edf0c8ca28b3c1f31f7749439c53f6cc87fa5b711e974202cabaa40180dc4700f824b50d78aa84f7f2ae099620f3e032aa1caf2d9ce8d3c622ba9473613864bdec9c81fb3f18276a817f3a13a3eee2a3d67a570ee821fee021879a3a8161b078e8c8153469aa1afa82adf30899ab406208d58173415e056d4815cb2bd71b92a43050245889f1b3f811697e929f824a693f7987af48787e3ee9a5f45aff1c2084b8da5a6ad5fd76cbfad0b2957a0ff1189b10f9c7c8a768e6a03863448fc4419ec345febd32ab3545e009c706917cdc7c65c731b0a03b16f49cd7ee569d1ae17b449e01d5a3174c8b6452abe2aacbee1e56cc22d29690f5e27ce18c9bfd05c13471f82719d63a0f798dbfa9268e346744b114cbdc7f5e4e46465d363669c18d52b0f71db441e1c4bdf249fa366a30f84a2ae19f6d67ba823aca1136c80b5a83e045ddbf1941784102ee05c9ea40f713df69ffd2aa4a313767c5429f04eabbdb1a4a12d5c597b71b93268a5c2d9bdcebf46066a9f992fc3c44bdba391615b5f182f81a4281ff64c7271e51887356aa182231ddfcf8f3bf55174ce7f0ca0a7ee9b62fa4d46cd468c13a1d006b9ba58cc783aaf457628b797abc35593116562117b8557b39ea250f8466af06dfbfac1f494e2885b87bbd975dce3fb66d99fa9a1d474ec9ede9a2b21d29f6574ac3fee2c4aa9233fd4f24ada2325e10c8368dd6c6e0e035ab9f761a922f9651bac1aebece51e448a31e380f8ad70393a2d24940c173e93e66c80daf32b3b0efc2e57c7f58540802e51ee471c08217d10c0b02b1ce71416583fc45843912d2149712963deff3f2753c9b06b4a9612a4ce533f2ac60053f264bf533c2ddd85c620a179bd5a0caebbe115e0518be577d0d8d36ec285902e1e63e949983d0b6efe14bd18e079bcb5589c3a64ccbfe0454a39839ca42d154f1de437ade0cc41e712a386cf1237ab411306021eaa2028dbfcd1924c040530ba1e27d814361fd65baa4497f59ca3f14516b10b8d835146c1e159cb7b40a12a0e65aade016906cae0b92d440b7c47389da8f8cce5e02d4f09a61194d719a5b62d30d69b00f0dc09f985b70b5f864f0dffdbdd300fc598765bf66d0fde6f9fbb1838a5097f0a925faa0f9edadf9f41226d70a13df9ea8c71e21daf49ecd1852f6ce2404b2e61f5bc8d0e8c0abb48ae3d813e05d9ab9b53f12d221927202f17895c110a3bddeb3e99ce77abf86c7fd00b0bf68cb0dc0834b699ac51ade2dc52c42fa0f50b24a97f5e4ef855b05d5c7b09e792ba8a387951ed43741cda21d9b3190ea6497752c5d9edf26dd7bc3999a01273ac347195b748b980439bf8ec05b5a61f4c6af59e8610bed57ab8d7349d49497fd0004628b680b664edaa34ab07bfd1795a7ddfe515ad175848d4bddd4c4517b3f6325ca7311c229bfce0250663a5cb3fe1763f75cb93c4db7da5a9ab6bf9388f7a691d38f0429854612af0e2222c38ddf7fc044d562a0d53ba3ff6597e9e9fb588ca247aaa03c1314c53e26b0e46c4ef5291c1be8dd0c55f366c331728e9e2b52b00aeeccbe7149a5210d2dde3aaab248810de229272b87006b0140e738d553a43031789b7f2276c23abbc9791d020e33f5f73c717f310df5807765c00636248f0a48ba004a1495a75e36aeab21813168db5e888a0784913b58b801acdfe3988f05959e4e543ec177c5006f99da5c35715868c862c6344dc073568271822692846df2bb78f7b2fddaaf7c91d1c4dc8df28e4f9f99c7fa5ca321f6eaa452e16682246e857212e7b0b124f7cb308ec6ac67f17d40fa2d477f0faed3615eab058b80580f33d6828f30f5629f9bcc1cb3a7763274d710441f516d628ee3df97f1a4b6e9c2f56bed71491509ecb36f773e63958c90e33a1ccc8e005f2325aa893a17e61d8002158cb83d211f6c094e0dd913ce75f637413598e34855f339f39d745f3b13979aeeabf2373236d869f8f921d6f4eb76716592c15fbbaa5fc8cb1cd42d63c2d20ed4d0874cad7277049d8cf76aa553cff2261d42aec21198f3a6f03604c03655c4e3672e3c246482cdaff851cbc96a376c9de276dde26c6ac8cdffd51f739e6da37b79413e9274a5d5bdd04ade19133b56b856d7bc3fabfa9ef2d4943df4083213d48153537112dcd92696b221df79fb1c5ff8855b516f0869056dff32d8a2c70971b24013c0eb99fede363dc5c8ec476af73449cf0e0715670d62e2703f5def1a4be525be6e28aafe0ecfc7f2c0a5433afa87fbc707fb645e6c392c2751f5c925bf064a0fe5ef526a7b881a5fcd614110032d77af51df34da353369ed773d0fc55d756f7abb9140582f4ffe034146a66f218c892faa8c97b523e47e8d0cccd018e575edab443fe6f307b5729a3bca7fa810555efe7d3977b35f0bfc00a4f306d548e4604d61c1fbd64611517e262151f1c7fcf00876e6a81f56d1c2972d4ed750efe051629e1a6365494219f67179b76d7a2cde5c7baaa38ca1bcc1ed45c28a5d7e38ae39060741ffd29e73e50267dc4b6dc5f107732a4f6d2da4a304d2c060136204ef81f556549e5369bacd96fdc4fdad7a65ebdc4fe8b4f23690755ad86a27b3494e2d5546885468782a79902d197803a0bbdcc7e3a9cf96574e87fe050e809f3a78035cfacfe1e9e2e05596344799c85704fb4eca38619771c1f742dc58a681df12ff2b1305635f6ecf10486e08d277833a856505f9e7aee20994c023c596abff2703337acab5d34426436945888bbf082d2362eb094bb9a95a602de5de3cfe101470676ea5bae54d451f6937f00b5a1130d6e29545b6b8b11642fbed021c5caf028c0545c1252cf3b490782c32a3c21ab496ef1ea1c6e79caa15c7895a75d7693d4b7d7be11d1488c99c53d738c3748104cc2c8f5cc75a905f8ad0f227b0ac76e83fb5c9dcbfd3a4a9c164a3949dca165c14c7f616278631b583d2c188d0006e35a6849b1712ff09a505c62a6b49d66e5f5e066fab157fce3cdc608cd427aaaf142bb87f3ce42e95f307f04401ad3d6cbf7dce758d03ecbf03811efca8d1e122eb18c81f9a593bfacfd65ef6eb5e1297f1e44223b858e97a2d66bc74a6fe4e7b8afa92e4f2afa65a816783e2610944570ce66e90de2dd8d69211b204660b23d8cb073fd4bd13d72371d3fb2143f3fe6c5f6acb8c98df9d29d7012e9aa1bf6bf1da10e2ce376eb8300cc4c441bd9050f945f2c8f988a1b6bc335ef81e3edd8de728e20bf6a8abb0f7c2102b9e77183b104eca7ebb0414ac64af8971a0192cf5964015b0b53adccf5392248fec76dff8d755dd5526b327e457533e50ad99dfc0d117988c7deb349a881e9facd58203d79e753daa10efe80d987344300979875ebef0a93577820376a8dce22e2d28bcf30d4ce84c4bfa1175597426f8b5aa1945261ca344c44d0d5f5750360f01fa3f4a9bd00f08c2363cac00ae64a23f3fbdea248f79abff4d4ea318a8e0618a47a2cdd8e159f1676a530da8c7a54d0c75238ae01902c1b8e5c40113c191621ca979a37c88a5dfc8963e7dc8f99e963b3da15fe6a0e8f64bc4f819b58ee57cd355d7a56185edd141314520cbc6838853408eefd295c1c38c8ec45e6b8994c5ea0044e6ce3a457c3b2debb4fab7e0b62797bbecc827b45f32b06c2e4cafb38c6751bd0ef1521f30cfd6611fa763e104987abc41e2c374966913fc90a2ef4f9165395761093dbd7dd4d39e6e5c6b3fda9831179555d7ec251f964e815d5060c5b3aac0a16ce18c5abc6b9dd567541b3ab879245483e5e0e4bbb2d0ae39ad41bf5f301d71b761a7dc7cea127deadf5b85e066040fb5a656a874bae900c68447d45c8133d40df6d90108112b94d7b067cb7d78c9f5654c1034c6417e35ebfca1e6b94d2c4cee510fc456a28615401540cfee8dd2285442ba3100766140394725dc74f7954807e2bb2a087052a75639fe5237656012ed3f52545197a0fd1ab54258f632720d3930dd460dc4a8593c3d9ba8ff709610d18894e229980c917a7a1fc036b5f5481ceddcaea6f8ff1d30ee1cf1c2fc61e0907bc0f8f53c3bbff4ce2ed3c85e6589541f7108a12440443ff234bed3184d13cbc152a089efe8658d607112ed8f3c420fcff881395435294dfe9485e0a0dd1a4d3cbe52733d13041548e7d29d7935430e2c7af8ef4c500bff01e31000a5766cc44ba394496a1a85ee77a9e542c3cfd2d0e4c51915d0b250ee489b33ce4386bccc5ad6c51c506c4523901487aacd113b85bb8aa86ac4eb69b7b3e1d196cd2c9a29f021932d4113fe2c8fd5bb2fdd54222d9022dcd6a4c54fe263e0fc3736871aa10cb5b00e348efba1261353dca658975e7034512f4b15a71610f71b690453a4eff55fd6d4affa6cbcb53f18a88a990e15c8c9b17265ce044224ebe2692032db18cc46226200b4c3fe5d5477490e21bdb1e4eb655a3b3b4994a40b2c81fbd10ca407fd31c8de238608cc50945fc13775697fa7d51f48633ad77b3428e513ab13854f89b7b5c6c14aa02e949f40425c461b1785900dcaac088a4c7ecacc2b51b859cce57cf8d61f50d3ac7e337dfc22fb1f18d8fed481e93c87be587e3fc403ee1a88e2170d822d885a1dbb69a01e4f81de1ece13221746954af2aef737cf99de4f47fa3bf419404c6433d67ddd33156938011b52cbc8f5ca82bb4278a92911e6c745aff30caed5e3833d1e9c76e8922ae546d499e99f04f6484fdf7288e131dc37bb59f42f90e802aa4cba2b6bc9b0b49e2329584bd083262a878ee3d7d22eb704a824b5d392e7652c85dd614a499b7ccb17d660e84f549e3bbbc62c894fca36678ab8e2de83e8e3a170ebbc8836c26c4313f261044aac5ca53c148aff5f330aa7c221873625453e5ba922a016c22150db1e0cf886fb64a0201155c0fbb6f04353cdc7c668190f0eedf5712c1faa6222c700cf1298f1b3295412c5f5c95b0511bb47e27185b4c79cab1ed1f2f74ecab09b0aef79a1ef4fcd51100f268a3b6ddb245d373ed2d7d98dab1b41b46064db17f5aa96964daf99774291bccc9916988f274712b4b2310e0259f147e2e4540348c37fde2d255c30ceff21ea7b3bd30db93d6e07a6dffdf3cb8080b163d3f3fedd51e3b37df5f3b5168e874facf9ea52f25d66a42a59586d3a4b6e7ea90e979d9e70f62865a26d6c3a17ec511337734f82a9a5e12f5eb7c986d5e0386ee3a37f315bee14518377337697cdb8942c5c1e8dbc436757d5f58099361cbf1e8a1e72dccb98d4b57bb8ffdf7c4816873c2a323dec391c999c9acbb1b8fb87447bec19ccf1e2997532b6402523782cd22171a71c5e4331021c02f0e6f668870607b80c94a479ee3eeacdb57cf93126b07655002b439abf61f78a051c66a2176929a5ad8fff791d198b0c7ee597d6ef46486f44b970e18d0b477f87e654b1dafa8327221e387b39321931546f80e02661ed8e0e044e33328549b38b9b25b464b97c11112fe101a9506694f5cc2c2798ca4d58359e5392942b27565551dd6e90d1e60e3eaded9f9b55399841f6fd8df679cd78e1faec3f41403e0df406db93e36eceb5a478081fe0330de298d972d2c0a09ca90d84e14031849f1f76679240388abc08618b72cefa0a81ffea907f1584c42d8e8c5ae508fa9792b50bf84d1b0bf81085901b5082a13ae29f470b609951fd32c40cfcf47cfd14be18c0b642f54d490ec06d5e54e168785491800f697319ff6180e506f4afdec33b835f43b07fec032ede62f2431bdc5961a1d69505661eb881ef96ad8191f3ad691bbed3ee7bb48671fb3269f98eef7ec09cf72009bc250d8ec3cfe59751db35bdbff599c7950ae63d73fc1d77f1d391119e571fdee6dd29ff7d76a7230c160580d8d4147a075b42ad1755e3e50b1a2bb0a8eecf2fc37911e11627713dbb48b8f1d94a0cf702a4331d94ca20469021e9ad999bd6255a08c90f6d66b2a3215cbb4165d3ed688c7b3607e7b6bba65c13f29d677525913cc87d39fdee69a806dc0d19042c360a60cfc0dac89ded1713a09acba0a31623ed3ebafde6856c3471e18550a495acfa8bac5dc8f7b12fe1ccf0709a939f9701d4fb651512f6f06245aab640cb001490b128164fe578ce112fe5a49b5dd0c2dfa4f42ff92ff1d0241061e4d5a9c4aa3bb5bf23176675f979a99b40346cf92652383de0303d6afa9e720980a53612a8cc8b4e1c84ac13c98db7548ec5dfbe728c47da61cb9d3051fd60cc34b43ede89d9708ede4f08ef07512e4d48cdc00a072dc80145939df386fe51a80c36eb7a974cfed2ac2d779675edf8b0e8a404ccecd7907d1c5b8b2b317d4d97c32a4f0950c2d934f3cb2e4696029dde60f37f399ccc41ffb63bb74eacb6c73d5b70d66ce58ed2feadf42cd56fae52b00ea9fe233dc7fae1421a5d7cf7866e72c9b89ffb39983a68e33c29aa4679a8d6366a67199f419e85814b6a54c24e1cefa5cc44534e86019f1b7b48b9e3fe2f43db439af660b642256c7afd9a5e447e4b705f0f95c8561af7fcd330ff898356866b79831faf93627acf30f7132af2713aac4cc17d7188126649fa075902be217405961994e94db2235e0696c998e9b7b394398e526629c2b661e8be0d3331fd30c95bd4bcf7d8b5281a5da9e2361aa651b43b10a36dd7d58e90620b68e935277def5af954e269eac62ed870ceaf998a0b47246603e193de8b7638fd2b253bfa317535b51f9ac7d72f91344764008a7d59d3c32e1d734528c64d4312443163d03e15a723e77b9fbc4f51330001814c719a31a9ac63d8e72295bde6bae4604e922e4af290d9ad50bf8c58b7bf04f9630185e76019a3b9e0377fc59fe48a075f33e33196942005409ab743a1d2f529fa1dcddea3311a66c7040c83bc87e7d26a8ae82aad14f079a2465d67cc6676f6967dece7c8010b1b20a359971aa9595dc50ee425e86cb8d929895eb0dce9fd8c0a050608e44a7fd5cc0da39ba3c1f24ed3fc5931f1a514aae11f9c6b6d47d960201494f53734475f144dc5130cf8d21f05dea6b95acaa37b110c82917e4df850107e8cd29222a7fb08db5b896bef534341df03c6abc41dfadf958f87431073bc6211089c80412f4b946dc61089b97ae4c4e751e9193575a54912557dab4fa901e7b2d1dfd2f6dfae50cdd6de55096a45d2a48ec7982d2251d50c7eae1d0b015800bedc65fdca7bcefd9dcba0f3eee15a3a7a94985e0c4c37850df68d0847182d9d7eed98c345b212ea23a47b7872b20288fc38e7aac0ba68e922c76a7c7d890c7839444eeb0b660859568007283b09a9aa5363da6ec7be4c0ad21fb1dd695fa05c29120711d978961dcff23e35dfea37e98abd4fd83a95e3d3cc3b2ef89b2f5b24e15ea310341ebb16a25fb4efa59ec230a9e5baa2f659b94d4114a54a8799de1c886ecbe84c4d7fbc8b41fe16e9dc82beba6d5ba48529d484812d2802c636363ab8654f29971c33f0f04a09d0fa2ae16aac20b6943bd3fd3fa038e186b61b7e889fec4ea9f4c46457887e5948fb4c5bf9abcfa3cbf77ff5090bddcfdf71bfb4ee2647337f6757cadfdafad3efeccfa1cfaec8efaedab8925cd0f3c0daf581900be47b6995c2c59f6dd5e9244b864c566e3deda4f4ada2d1c8369d248d9f5fe0dae54e86c1b6d87dc1ef561124bd75b0c7fa3ebbf0e7c9b33579de9848ae29d74613e096a2eb18f8fa0a18fb08207ca136654674c32e9dbb89c43342fbcbbd3ce6cc473b9ec80b2805c3226e82816767fd5faf6d5a99b9b9cac2e62cd0f8de93520a66e721922469229ed681e409a56be12660c7198016814d55480b3c1debf6dcd8b7a784b29a20e02dada6d1b25f970609c42e621f07ea707a394d1e66e1773c3bc726052588c417d1cd08fec21aae72e37ba0115d98c7b832b580cd8990ca69841216f9b58553d0a29d343ff869da59473e7a6aeba5c28d0cdb97411959cab4b5df860521aa9e243c7f44433b4558df0766748afd4615c881332dfcce64747de3472eef565b7a159db17cde8fcc2ba28359e7ca985dd4d524fd64f015ca32562fc83f6d174d7ffdaf2b9acc1319e15b857b5cde28b9fca6f7616d34d02b32aedd4b416fa9a9df3d90620854bd3ab9ffc6f7ff17a73d6a0e2726dd6216ec8509b4d3acf223a2a75e8a097cc6354baf7c8dcd2be2d507a0b8bf8f36ff0cd42659aa60053bbd624a08f344de45147941d77f921c97acf7632ead9f6dd84b855bafc1d2f9f15bd75b6c6b3a89a8d9cee94ab4b8a3499216af19f41553b88bdf0a6262651181473db3f9f82eaa228e004ac7466692e8208d5d9a392e0fdac39b88cc2536b61f4020bb62fe85196cbe4b59ffdddb3c5ca71757d3fcfe2b016669d3c8b4a13a5166c876f2637a8daf3ab5da0d40479b4161037af96e318224777788f7c0c7639cc6b86164c42f32cfefdba2e8d66ce3f9eef5100b1a7173d560ba7fd082069753c2c6fe7c1e5246abfdfce9d2604f170e74c461513d4acecc5c31dec690fd597f88949aaa50247944446598ee423c8253cf006372edd6b62dcb1e95c0b9d5f80c7dfec76708bf84df7d4b79a8bf709b3d0c4301edfefa08515423e21fcef3c5f52bd5a6e7cbc62e59533e5fac76944e58797e528d0c616fcbc2db49035d71320b432f7924808b3f6456c8ede6ceb0887b26173d141d2fbcf9af5c27625c5459d9fbf2e258db447651a9ba8aa67185034ed996b324d4bbf330630a701372c6e88b76605a3c46420b33c2f29d802974b8a4d530b57fd87c4668fc32668cbc3db6f184626d036faca58d13a1bcf4a97071efe730c3fef9bef22fc5c3a735562b945e9914e5714995256b9c3404f1a1c65fd0dc835ccfe0bf61d6d073dd481e0a0080c0f2d8be35d08cc7f0d99d43eca5f939337219f1bed9f9febef13e46eb60d69db0415f96fd1304901f3448f6df3da123c20f1d2004fc46a72281fd3a58a1c0ed2c9e93bb6034fb0f7c4b14cf9a60996b62c0877c00159f5e095ef6b41900a1e422920370821dc4ddd88f285e1308a44b52157e2f446c0dae1c6cab7f3ece612285180437532a58bf81b61d72c32fbbf386dbd3b1bb1a5c49f40a17dc9a410690d0a4cc2b5e49bb2f295e24c31fecbe54b2147bcd0f382ee75d3b9cf4f4da635b546ec9771795547479b9fcef146c022b503b327041182cce52d51993572c9b4aeaf3c7310a4588f8f6990b9187793c9622e1ea837bda583f037d75803a69f77f01cbdf2d50616e3e0baab26239c3b4afbec595c2f24b672b80020c52d65e2aa353a00779fbaf41b8fb5aa0185618d89ff9215b98dca1296eb191331807862663445b2524681e214171a9d25720282ab82c2e04bd2a49630353401579b4d19799ce1901dcb6e6bf67dff22d610075d2cae1eaf8449ab461b9c6b19e6726ce70a0f3cc2960b1f6930e4f994fe5a3f990004142cb1439afa4fff38de6b2cbb88be00900168500c40375619d965d5250a2cf4aa5b0fcd8296bf1c13516cd373673d51af22c8b2c95cd78d9a61df4cc2fdac873a5091ec19d97140cd3d46e05a177d95ea5a03acf5ed1996fd095ac6a6eb2b2c37f15a695704be85b464d140d1767f4304aedae40e6ae2e11a7dde85ce672579216aaef04bdf5776b0934be3cb3fcd489583424be9b37ff6230ed1ffe06635e7cb6f4aca50b9e2c249ebedfda50534e0e0ab9668419a316611bbeac5bc837c8c07f6ce63a377e9cb7835ef6cd0787e9837523210a764fe0a64972921370d3a768d4ca88beb40d4631533baf40bdd1820a165262730d8b431ee6a6a3e9265a669ff786a0fa30f112be1d5f0b2f73617a6b35d555295ef2b6f9bd1cf6cc215f02ad074cde976a6c70601cf9b8ffe369be297501072ebdc09405b396bd33e2888e75ecc4257f0a3db78db230fceaf02e3a34330f6afd4887dfb474fd7cf80e4039e9c5f360d05bbe9039ca9c5d514ca8d4164daf7a4e458b79a030296117cf6794e07185a352e00358b92c8c8e9dd87eae9e833b71b91eaaa320933dc89a342b1f823f701003d5e7e513fa716c92af2e9131455facab68bae3ddd2abee6020bb8c8f3003957ca3e8484a7f23827c311c17ac029aff4b5fc3eecb9c1f577932e40b953f117dbbbf661351c80842230af88022afe537dbdb5a55e91485124351195ce510e4b6b3219e1517a26e374c97e8b991b62960564683b205a1951781388236fda0bde8b4bb7589de0e9a2024ae44b95a5101a5bcc4f8c8a738a0faeec0526550f7738a1bd97af07ff93d79d8bde109b19cd6eb18ad8de5a75601f1535b1cbe55d37d99d7dcce998c97dd05c9c1d0323e0b0c553d64a8d639457ace63a4684bb61111f03181b0e64c735ef0c90c52fd648a837df641fc3719ec1b77a95272f4721465a78e3a89e7e6c946a067cdc95bdea16689901686f8ad778a54665a84ee41a2209e422bf2c0be44bcd7b9cd45cca81b02246d2fd35ee765198422fdd5d2753910d18c8ba9c94329d49ee9b138e874930d7276e1b316f482117b5b4d0caadf4cbd348732db3933215ac840a2999edad687794dca5c9fae153e7928fbe195e2291334e7a1b902c5138d49a933f0e45879c4adcf8605bbfc263bc019f497aa5eccfcb16fa87ec4e0d56b48632019fd7624e757e80fc1e6f1cf34c52482b7346d803e0276492889d2f52bbcbac332eb3aa27537e703fad340c6363ff48a54fe12116375e7390ac18244802aee890871144e42f909cdaef31660d861cad4535d62d13621063a7afc07d2a499bd1ddcb27ba2cb8ed726d2ed16307b5598a98107e7eaf1c066dd1096d35275df7b06b6fd8e2d55aea3a1a72028027eb13c5f035de4af56443b9801cf72e83e031c4d4827e3bc9a2240017981ee7f2809e76a7e871011351e08aeebeb333515b970c23cbb27c4914805481315dded2aa9cd1a33d632bb09c40f57a16dff7f14e06da4eb2e792a1a745aab7dd003c175b4776f214c67bf607fc54bbad7d13b79e604ac3df31e8c464726ba6ed97a1f13bfeb2cf4cf618f5d1316fe5c7441667dc6883bfaad1f654720ac1804c796a80bfae35526672a49ca4a2e9f8cff06c71584bfa837f774270a70336bce02145743cd804a6ffe166c3cafd39dc44e4fff273557c82fa087d6fcb085787f758ce0b5220fe488c33f9b4ab36deecfe11db72fa0cb4342beee526dced41e9d5ae6535876be821c600a3c63c0b909215c7bdb3a68776ef7e2335c4dfcdd4626b78e17297ecaf86b112868ea9316d5010eec24bd883a53032e6bac0feb47a8b65f5413f6b5dcbb96d397437bbd42e6443d349e94a4379b16ef8cd772fde61a1cb618d6b8dea6750ab42a087290048e4a1d246a8227999d064f2ab49f12f13e87e373984fdc1e5afbf2721ff225eb0269062642b16172e38ba66a77994c717bdace147dc5c1cb8855578d31d7d997802e5eade7fea060db127b3c8fddf60ca4a182d645f403148fabc203a92aa69353f74ae81b72be01a6d106dabc24409b3ef3ef27b72b4145465e8c1e27bb1476829851aaaa9c62fa3dcb6c86c92d9874cf5cc5187c0440fae379abaf0df2cf3c967c79443e00525f030793089bac928f6c6e91026bd2b08042d52319d700f58c751b74e56676fb7bce34bc9542b2496400cff878e1dfabf6498352fa840d8b5980c1cb0e49fc9853dbf4e713fda8636263d6c8fd20cdb225711c3924d731405813659e1bb16be3b570d8241bd3d64f2bc155e27c61293c783c4675a3677bee8618cbe024407dfd277a4a6fecb9ae2f22b82e669ccbf0adcfd4ec7c16fb6eee790e68dce493e0e28ae9e58bc6a11f5f73912b1c483c3ffb7cdbc1b200569c7cef93414c789c0035ca6467c635bcf4171050d00905adc16c7137da14a2ae3be001115665750fb1c77a49d638a789a02efd2f8ade2c1a7057b2459919b7aec97f925d849d055cf2f3406ff5bcd834104085f1fbcaf108f0aad0bf89718910fb1708be6ff86cea7d9084f380560b0307f42b218a587494cfc71eaf982c0db964116999dc6be6dba6f01e145c63557cc8f45f61c3f3271fac23a7e8fb9c82e0d072c5bad9c5c1d0455bf5fd7731f87a32fb677b8267d384bf101782f4a227594ed1f66352995238f20d0cb919e56812d9f8d527b29f58c1e8d48011a23a6a8e750c2b828f918855e3d212cd3af3c3f9cd0c4ad1adeb5d79c0a375caec25af8d205b4a9bfa5c5d0d58de0c352428730df318b60df359577accc735b12eaf13dc59188f3d7ae2189f94cb6f3e8efde0a84ba4e7a9f2140365e98eb96dd18905de65755c13260528840f020c2dd88c1cca06b749f853a31ef3feabbe02813a6095f3b1c88265a22f8f79e5d9f05ff0a79379c27e78b2fd1fb473f02e6ab00774b328ddc591a04c5f6632b000428101477624cbd55600cbe2da6f25f8d750be44d545c938688ea0689c98958c1505683d9d7f1630ccf51048e70f72ad9ba816547058ed1566a09330852d7c6901defcce1bac01208ded5d8565de777659ecfebc5f461c0edac3df71726e139eb448b36ccbec51e87b258209d3b5d4c4892f6a038be7a3f2a0bf25e1943ede3dba40b76a20e348bcb26c4872cf78c1e402f3d189618b7a2548cf1973a5674d6959c6d5b047466bbc06a14ec724d24116a401d5ca9432a220fa006f6a82136d2e3a2e024e48ef751620658fd63e9769e28e7ca754d410fe4887463252174c07c04c4784185c45514fe939a2fd67744b41405640422de51df501d44f5de2dcc5a7ea7f6f03bf48958d8ab2659824c7aa110500ed889c974f666e06c8a030481dc153a8c6002f6b8044b742f7e25947f7fc1b480ae0f102eb112c49cfbf5ca281c6cfc7b60b8f137363eafb57342cdf3b40b695ad486db470aa3f8a63bc203a67bdf08ffec7a61a53484422f02bbc9f62cea58f883821b7da28bf1eefd8b15111137613fc0485386f7297ffb6c088b441a3bafc9ee6d9a0b5e2a0d4d86a6e5a3854f04fded73f3e15c8977832d4295fd52f34ee8c77369111b25f7cb1ae97246a946f963f6e9c9077e4c6a57f5dea80f08dff6152e53043d99c7ed0c0a8841617a780bb3aa53f05b63f3ad60901f31c50e487cebb6f6de0dbab33928d1ddccce4babee9a0766f79d78b1624a9fb8c870fc710bfa212e2acdfbef5039ea563f63b46ae175a2ca1c6bdbb141d56c9062d081f3b4d3f270fd908df7a33054dc5c7562eb0123ba38e9c3b77acc26a6e97a210add0e24a538f325223de994f6e45c08b72218f4efa90964ab2285eeb958bbd28e5ed438e0084da991e7d77fe344d30587f824f2c360e0cfb07fe54013031d5afacad0e80c101f2fc6a2d069164470bed532529d1f9a9a4ed369996a7b6fcf5a9cad0e545388884d49d5950b4f6590db51c8dd6e98f3cc30763b4d0e01de046aaa2d9887c5579da3296d9b6b582fcf927591ce93fb350305bc2e0df0e8490850d2ef7b2096eee4986921047002a32ab4b1331c902c1f19b3a4d7f965217bc455f0833b4139427200e8a6bb50e9c157e710f7fec8b8fd457ba6f7f19d3659a8b7e72e024511b9b71e5cc1dc790fdde896cbb1e1de3002f771eba5933f81d905467b04978b060160f98b632e36037a12f177db4fba2c2c577868a44c8218cd30201822b42c9ffaa55895bf1dc17de32c57a8ac34390dc2c86de9a1e4a32e0a260a8213c31ea8e9cf203317c35b6492999d29f3643948f70a97a5841db50f01dd2662ccff3002662eb847fd305f57a9118b34da36847b0ba7b8653b91ee42ede4471c8d938c5dcd375a58549454dd7999b208be91332b71e0716dadb59cf6983b74b0814c0aa1e30dbea0bf9ccc7daccb0c7a0c2d24f1996a2d1fc3dc828394351f14564855c9fb399668b89073e12b74a394f4c13ef149e85e420e230d7887a9b8245238878706fbe4c22312d7ba8008377d0df751aba76974f325ce88b2d63eb32384dc3267dff8e85b44b7d1aa29aa69aaade8d4bdb79baf72b2f783fee3cf9f9ae12a7a4cf77a18cc4f4848140856d044eb980cf1a0c28eaf1c6913ccf1bd21655d241db4a268e4cb7e77add20294d1db2f1ec16f584bf12d7ce2a249de73f9a9f54a3aee6245e8f5fca48a3c471c3afb20642c0710976aa4214c6d9e1f731042b2bc5d8dfd5b32166d794ec1b2236a19ea34d4161697eca73bafc2c52dc51042b308d1f97131b7a14a2a112eba3ea2a88b2b410f0ec35df19093070e9bbfdeb836e8d742caba0795c76f4c82bfa11fc826e041efec4323330a3dc5c05a8ea003955a6c2cec0e12a06233bfc7261fabb1fb878be781d827fbb63eee497d71395ee41d8714ec0ab81cb359ebfe830ae6f1bb99b3d7ceb4ce73cfc32876afd572e0fd108a73b35c50c3a7264c817a0871e3c90e2e702805730d5d97531dc155cebde87cf7011c73a20e22d8936d31554d5d3d8a437882ee9cda92db1bea2c7c60426a04f200683dc1ecd93fee4906970cc4d034785563574a88a86b353b0a116a5a4a968b5f8009bcffadc33960db4bfb8cbfa6d02315758e6275aed43b2bd8c31c3178c378a8c42d596e968ab6ecacbdfd2d3ea6cf8889ff4679de6584f5330d3c2a81f43da0510deba39224786c0d0522e92b89a9ab6ec0a9f2e9ee9c5d7f08888f0bcd59f6046eaff438d4cbb55cd9282c61f5e940877abe13a653e95a0ed96841fa803b4822f873916b094b9e63bfdd8ea2a6194807ecf27ebe39e0983844207ed38debd4373df5663de3c317ecb3353286921248b21ec853dfec1b232e5c6056603f033f9193c724c55943c6586d9c71147fa75cf825d050c35ee5f5f01c57bcd63df6a90bed72fc190627c201c25fea656ab6a7f635cc7b95c3e505247029ea935cf8da47e513682c5e34acc42c94c69f1f656ba167a3c42274691f01b6effea6d5469a950d935f15220471538b60bbc559e9a35dae2e6237c9113d30c44cbcb03c9199a299e0bf80fabe6d67ced0bfc298718265c8601a755063dcc1406bbd2468f05cbf908c06425edba3e09163f866933b401181af0b8057f0fa0d2d839811d8a34d2b1eb144148a93fb4e0279dd19f9b980da66f937bafafee26656f66edbb794b08f90aa92515010ad738f0e4373e38bef041111ef9ddd871dd9e22f2daaf874c5918a4f1adf5c4732f041dc77d6c61bca621e9b49e4b7043e6c5cfea27cca143c1a9e745e413d412c2c1184bd3dff6b8fc47a1772cfcb5c569b00c0905f165f5e856f585c26c5f2ec366847ef72a798d4f435f765cd63982e438369eac9b9f6cd55dd7829d37ee479eadd1a8237d65c044bb24e70eb637b846b3843ed3450455031fd23f77bc823d85811bbccbc820de6aa356b6773314688d1206f299f1101b1bf34a134ce42efc5806aa724571301c212fdcc3dccd2cc3a58cac78550f045e5a3b8eabde6d15994077d9ed9ace5d8dc5fcdff00c85f9eb1ce79c2359b6b3a138edf9aa3f98eefdc6bf3621dac9939da594cab54c3d6bdcda00e95b350a4ca4e6ae68446f32e1c59e56526464ccb4ab91f78f128e704b42775977389b21f75fdf1a7c1febcf3a52f92a64e5a047febc35651da94a352269c5fd7403e8754e8c71f4db7be6a9185d46109663de09b66e3eee5002710c81a00a9158acca0c4bf4d01c29401792ce2f8677fceac4eba9cec5bd9dfc47d3b544abb13c8769e2dd79a74cc326d6bec42806e64fd3f9578048a59c7a83de086ea76cbb506d281ce5a0e39116c52b3eadbf214fa7033d36de5e544c49147ebff807df75f8394e7c90dce488731265b50730af79cdb303703f364df1ca4f36d2c0844bff5c34b02a47a91ccf06eb5cf1800c60dd57d92a866c3c2fd8c93ef276b075854007a61938aabdec91416d1978a3eaf1eea9e7df0ac19cd76d6b3f2648eaeb8d61b05e140958bc2d64efcd2c1e1cf8240b2e74114947c58b7231c5945a6bf7ab218c2466b192d857c59cad78b296d4808d19bfee32430efe8e896ccc6cb74a92722394208605fe2a0851cdb57f58d90667091835885a422eae6406d9212db517cab6a61c2eadb697aa7e1e6ca0dd850d8ca74dbb3f263440b495b2185e94d89990c61c33b35d8cb54693541f16e7bb81f064dcf092f65d4127c8d6f5fff8e8fc1ede948fd725d38aeea1e33e742ec8ff5bccc843178dc882e1b3efcbda07a006bc97751ddfa3074393e427f352d48a405e51b564d070dda22d7ae676d7c47352593f2ba9c325b3ce633912078a5a2bca8d9d9aeb239df3d510a50aa50dd74de395a8995f4c51d3cdfe2a67529b46470725f649f7cee42c116a090e31c71864abca7e44eb61ba55edac29a292701de5d20f2c800da4b12cda2467ac97a0476d7af2204201a0061be8e1bf2a3d487215a20f6f4388d174fb4cdcdf88be272ab03f315ea91aeb3ed1b211702dd374a96fd06b5f2bb8b8c7906ebc4e0b4968ba2a6ad5d5f68efcf4ccf36a10627d6ba4b59ce4d48b48e424b4c0dd956398997bb87bf8a6902eafc3ff03942bbad2249b98537e0edfd801b0b751bb4fc6c94f312eed0656abf410ea408fe748a166685f7eb7e9a8fdd417d08aa846db9f9b51e61a5d39332eecd8c4c1c9e6e4f97db843fb6fb181b32eb16d84edfc3e29dc650f4ea992f4ee0aabc71333aee5937434b9aebaa6987d3d736812ccf72308b1920a3ba18144ef2a71e0caf4f7819d0178a12065d8c93a5df09c93510ce3f06f430df14a3db24b5e3e546d37611d568677c4a73e7eb3c35a6a0f8c95a7b6110cb6af09ffeaf166e79758f77a98e29806deab28cdf9f401be50ed62cf3d83acf591dacc7566616a859257302c638ecf31e5c5b74332bc31c102e4532209f79215862954c83825d7cdc77a311dca2a62b1be6e3d1c09a756dc6a6fad39df36a440328c24b36a861f2074aadc4a4728acd6829b14304875c48144265cfa33f365a34652187ccea392b71b5800af6a236633cf50a128ca47db77f81f505f39726bdb19da613c0d2da78979d9cd15af41e31e7581ad29636a90503a80449bb21c2fda1c43720693434273053388b074daac22c189bd045c303cb43cf0cf0034f3b05892f63b16b1e9e9a64336eab454274ca033a35ea8ae78953d391295f200b2da1370354e7929635010b36526211b8128ba3294a329e274f05a351a499daf6c2deb39210c34b9c6b4907df5c2f2a57de106a31737539ffb0e8ac4d6314ca1e1ad5390fde0c93a9412c6672d6f684fa12e67c92b4a5c1a612e4a563d7b53bb961921ef4bff2ce6b32cfbd0d76eab17f9413fda611651e28dfa39a650bdd8c4d18801914665d268f9778d326ef6cb695400a58f54cd4e321e23bb51056053c7f009e8cbfe85d43c156ee122cce2696625f3e12de1f8e25ca5c88c37acddb0993a8f827cd9fb1fdf9382fd29ea4c2cfed500c88e2415228305056cd6b7e324a609e7cea05afb29dd600cc42f75fc202a892a8c5a87eaa3bc5ed0409429f489ed8799755070fe629a7638ed711fbc5bf4435f5decc6e2e9567d12566c23f7feb1d9fc99800b0db42653897355548a462fbfe8f23334ba117c0a27d3ef7b881bbbde5752cbde27f799984f1c766cb329707df7883f2cb63e9da46c1e9f3f1f96a0c82d5cfd0050bce6589c10700f3ed6fbb4e8acac8a0473bee0bb465128b14738c237f80a6edb61cb042812a60a4b78f6deebf228040722017a8048296d18d30be3da3c42642ca1890849fc172854b5025bb8a7a09151b2d82baed337c8b2516c97244a80a62d8de4330b64c8f46d342c87f8aaeba6a5170158e676a1aefb1c1daaf23f9510de29f1423befe3f12abf1bdff50778f6423512ba184e6afdd992852b346c698d88679d986bd7b4bb778d4178884ae1c5974f10b3bcc3de5d13c32dcc5f6ac6c00c87b228b68bc2b988963c8a15b8d2bee4caa63c48d423feca97801c59466197043b4206b3e81cf16ff8330d519a8ca13b66c306d8b32001aca0d1ef3724e2c8c41b345b6db2ba2ddc15973021c3fd98832c5ae8d27f7619b86f26ae4c2b946f999c33859b8f14b2f69ec2e52803f8e9fb8bfb98de0ef420415cc3dbaa8d485075f61eb413ccbe45c04ac3fc7fd8954964e1237e90a2737eb45064249a3ed50c8e79ba13b6b3c61e26fc0cb9af7ca1d9128fb268248ce405712d905e4174949413c9a61fec9ccabb7d00eef5837a84b54c70e8d3c8984f8411f30f801c3001de30397f7c7ff5806670fe0ea47050c69abccfad1f01043325f713909fd6ad277f84560775e3eb6dfb20c1614c6823302eff297c2c866ed3c9c7294f5f54ceb063c88264a2b3c7cd518d3c9ff3d157233df52cc259525e7df0d697443adcd9cbaf4f62ac7f20bf4695e0fe20c5124b3136ad2bfdd88da892dc8f47550e0b893900fcaba326d6c60c4193a8d9d0551069f8b980e0df489d402e525e7ce7ea71da38d9e63b80c109bbecd7d411fe925eaf6d212fe49643b88d33ecd539e48b6b0a512a880053628a2f6b17e2d3d104937eb3ef8e67c2ebcf39fc790380c3c3f91933e3e18031a127f613283dddbb01ad0dc8da56256e00f63d307e260421847fcbd82d65bedbd2ca99ebc8ac8767eb9c1db32f64053e96dfa3f34fe426b456e48c021d7e2b836f36dc20612dcedfe39c9b7dee8d97820942823eed9ffb68c634ece575d190eacbdf7f33b0b7619f36ed73c3eca93dc4036927c871ffb7287883a4b2c58e188ac54d58b86aa8e31088f1d85da39e0268969cfb3c6cbbbdea9e571c26162d94b778331f4206250ebc403b96e77bca5130baa8dde4814d52175db8afdad82ff412120459cc2cb5cabfdcde1fc7b3a9a8773642808385efead5a0afb346a88332ee84412119133734b62eb313b3bc25c00a49169ef9e8bfbd2ee6e6527ed2cc0c72f229bf28862104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
