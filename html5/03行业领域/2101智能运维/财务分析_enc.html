<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b5779876b53dc481bbb2ab5ec63a667a75a491f4a7d8b021f723a5f63a8702511ea90c9d93ea1bcce51be24412b43089c042a038d57e0576b14da6863b051468099bb08b17cc4b0a490e9ecccda7a3810c0fce8c49df764daeb2b8df1da67d80d67468fc1584935b11ac5f3b36278c0b05415085b713c28970b69b6332a557bd1e457f84350a836d37123fc19785c146035b4be3cf425f808b3101a82f3e43b709a3fc01a22b39b5db352c90fe418fc9a7ef748c662e35b04339aae11e7d04fa55261712e6636ccfc4739ca09791df57db098a077a3f7ca75d33b31b005f6975c175bb9289c51d304ffb8015a88f65d182bea13154cd0adeeb7d2dffbdb22747b7b17c4aec8439b2cebfe127a3412b5f9fad07a2169784b8a3dc9d9220806132ef868083e80ebe48d5ddb0c60a04d166b2aece32c319439cc9958054bd40764f38118edb9545e0970bafecd431bb89789022289612c90b69565fb83bd1302fd48f5c0e99ce152bbae2a8289ebc55f151d8ebfd0daae187f5a0af648911eb022eb0a61a101b1d1fdba527c3c7a9e493407f6ac630161453aefb40a664233b25979a2350ecfd13ea312e61657b099778cdc518b4d46a240a9f8c75f5b28002e50a0d292475813df766eb0e9eb00bf3c4ff04b0268cb06e6277a6cdc48d14616d6928ccc43077984dc30c048f61de9a8f31184893c39858a03f2773f7aa62d873bbfd05856dc84efabe77fb38d21e04c27cfdc47d801550be92ff284304d5ee59be93348e0ab7144548368000e0f6ece25b85420461ec9abf99c4fe5b804e3b76f065b9aa8bf5670f33426e8de75dcefd0f1de020260a0d2ad028fadfad0a7c9191f72aefafe8df394b5a4bcfdaeed8861ce0be326c8e7956d5964011e5550f86d2fab78eb6738988481440e065c673f51c28b7ae7a902cd7c7e5f4046b6e4ab7221d8d22fec40e1a021df4daf2d1db95a325464daad291c92665b425c0bd2a3bbcf2b2d909f09728ff3c97347362bb85b148585154b4a9bdab9c6ea0dadd145603cd4c6a04f32468e395eeb70bb287a1e19a9ea58b1c4e1416131ca16826efcf8d30f036309c406dc54381cc9f9dfa031820f52c5e5cd2ab928f0aaa0f3e61b52e82f124575c45b389c95f25e4eee8d83b645f5f4e0f1217a63558166085c793ae399069d3d7790966003ec842265f6ef711b948dd65779d18e4859d648e2ef67ca0b3d9a97d75790e33598aa9c03e1e65578d12e9bb397a922a61a0a8a19ef09f708bbcb4d66dd452c016b75fca0fb3a9d4926e6cdea7009aff0e688294d30f270bf63767a43415c7b0347b512af91631d414de5d5cf6b8bfec27a9698bb4379f13e17c413bfc3102ca8dc432559a27e600c8ec40752949926bd094b0ace58979b5cf50fdf095557e45c1f97a6c3f7f4c937541babd5204ce23113792bf7a5a7f6b83a4baf6d2bbbd067a366ef56e4829d534d7e1f344a0110c487220481af3b4a68b2bba5094d7635776374f200ff765a690d6b04947a4e7c5981f3e3cef0295542d79cdf530545acc526fe08356027d5548a08dfceb9503e67d8cfdf301974cdc65d4ff029dc353da76dcbc2c63f444d2ad293b98a7debb0e4178460723b97b6ba239697fc8af687bf0952e9cc407e6f6a4a1bbb0da0a1af3c214d7364810c80120483bb25b43ab5a96b6bad18b91238259fbfc1886da05c5ca49e7eb04a7f01ce77bbfd3a4c36c428243f1c87a94597f29cc4b312520ef1baf2a69f141ffd5bc0b5ba5f4fbb487863e646eab827051b889fda68f73629693ed69ce3031ea226106425328ad7e0e55418fbeeb9f0cb9359d8ae66643a2934b5e59058c9954f16ea9f0369f14e148e21bfc20b4c4fdac4108ec7e9ed33fe8d47d3be6fade4c5900ebe48ada8948311e2faed5cfc50dedf6153cde29177a2ee643c5620942208a239ba05ae38313ff93ad9ebbcc4be08364b8e00dbe9bd20e936bed712929ebcf58b96b2296a85ef2ce2c3ccda6bc885659f7e88ba1a735cd9268430da96dd5cea4c104ac4314731a916c0c02960686089daa61135097083e1f993c49d4e7ac452e8c663e7011b5af56508966d40dc8f784b48578038f29998f3e58a9ff85dae607a5217ea1406e3d3d1e2be83c6d43cabca4ecc9f847e5da5404e5d7061ce735cfe7f24e8d3b0478dd35e556a3a73e24f393ed51c8fd819c7ca41e2dc3a63e5e82b318a9cec56c8f17908aca8a9b73e7405d1b80f136978245eaec8d270a2fb25da174e1559adc44ff08bcbadbd286563e6c4a87d3472b40f5818074a6578ed78b5e04c8ecfe2196e4d57aca5bef2e6b617bd2be3424073bd21d40155405f7d367c31ffc57df81a69f1533c3cde014886dc90129515df6214b080b836c14b116a2059706c1d83b00994f8ce34f46a739f1a2bd2634a663702ace2dbdb94c28cea8801ab4483b5021abbb199f57af1d73a2895c3228589c0c98321f88e064d4272efa9be18a6da948cbec191b8cb1377b1f8daeb9d4430e44374dedcae316071140c2fa5435eb0728c6746f991bca075f9de5a188ba031da57ae17d701f94dadc24b1b7df0aab750782d6926b787c225c94cf0ba1851248681710c462dbd58f32c99c56b9be87e5ba51cf14edda62fa096d17c2ac705de9b9000adb07ae423128d9d919f414613b483e16561483c9ac3a5de5b2d643809ff6c09c05c0caed4b948e66e7fb623868702bf391cb92f2ed9c1284549e5d030a8a3f3387557745675aa89575797db1ec7ae99c550c61a1c1a5598551890bb8690251b48bfd7f068f450ec64b94f1648a493052ca0b10b65303433ec2948ce30dd24710c54e84e434708507c47bf2ab9e5407a33a5afae336fa22be44ac45ac2e8e9ea8cbd33158d2e1a0734a42e4257c3a2f5e37d50a194f432b1aa69ceb0a1c2f29bc566f725150210412ddd03db84dd1d74f3d3f18ac3ebf13cdb978485c64f868a04a38c0f3b3db343fa54ae088d81a96d7827c7db5c5aafbf10b1ea34ef91a712f8726724ab331dd3ddb1d698b1c92c2afc1883ef6bb84ce7c84c48917ce847328c80b810a249776668e0e795a5b08ad2d87eafa226010e2da3df48e02df4a51611c16d8ea28d27999208b7dd382b406bcc34d1d2365a51975338c70e70edc40bc72f0be2cd16943f9ca7a7d021bfd1e688f6bd9bacd449657a2de303c151b83d6df5da2da56ef6dd76d32ed7c76d3c8f74d57415b44a35d716ace018591c9ff0f2d300bf4656579da3d26e32ce53b0141fedb1fb3609e364d44d6ffb1c23e6b915317129a2f49774edfdc66c9936410801123c75c172f012a42426c593bc3667a59d0ffb20685f0952e2b689ca1a9d3f3e7a5fe64d3972241e152944b395fd9c525f1c0a67cd54444b7b34d69e8731526583158e97e767e0b401ec481ed87760fab2086ca2c60e08cfe903ef3c083fcab103e68533c30907ea1680eb64bebe6fcbd4a5882f59a3452ff5b2de4e67cd036421090f9b803d9e4d03200d41aee4d9a46bd875427787e1cf80ec1e4bdc04a8d69463c9d9a13b977f1a56b16fe8db0b7b107544c6605977d2ed2d1ff5b1984e1d3f699823e0c17c48cb604f23e901c6b4b13cbf661d3a73c63c8e6f49c48441bcbd195e8c2f1dd77644e954c7f5f655924ddd14c9346e28d4d36d26dd1f1f1add9a37eee015ca8c33aacad64c5e986d2787ffddf967f6041d4e8a629bad46287ed89aaca98e83a67dc0730ee8da7aef74cadf9a2c40e79454543017ea68f382abeb5efa0c68f79e7f86b7da0980a66995380297647ef5c6c9f3e2965458abf6583b75237b94d896b4c080e94c1c89bd033e83d33795405053e23350b3eabaf47288939d4664c9daa68dd2e638daa23b12f483e85fa5a87624961d2b967800aeae1511c8b4933e3a32289656022861d4cb74db6311a55da287f0d4dde7ae85e557c32b94c2f714b42fe7c4f9966a78b4aca5c927f98886e4bf35c7f5ad5ffd8fcdee12f0f9e419428b8cdf0ed3901bdd680f59403c3b95b677a0319f658529b81e309e6f97d433455cbe541006758c4e96c3e7d0901c23c813340a8da48c1517d7fc6bcda71229bf73b761919be04c7becc538477f181db603620967ed1f76dbc2aea0089883d55de2829a5551c0fc50c91d8a27014e27142e2c5b61510b5810bbc226c547475069489de6e8f827186e2d72acbf8cbc000de5bdaed31025fc8fbffb54c2e048a2474a575e048ce4e565a64923f54b984e6661d100dc0b0e9ad4c7c3ff0a61df0ef24c1049784cc20cf419dc1c0b1560f36e48c83119d61c1d77faaa0870f2738977811b38dd865a5dbb528f4adf2269fa5b4625cde0ba9c763a9ac13a00c19b4567a0ed5104bda9b890a3927935aa726832a6ccc55d14e75c812a99d88ed2a8216b1e91d1a71836bb5b1a309a5e2b2c237c02107240b720fc9c4575d5dd6b6020a58eb5faee6957bbcbf486c6da7870ce53715a66f9f0ba751a87714589417afceec99a07426b797ff6e0879bd1769697b848b024d774f11040a5fe8f6fef3f43acb41400abba3bf0cfb605aa63372a452c35434298dad7e471a8a817654f1c0f0929d21b6069c4af4068fd66fa53a9fa213d13e98a008a0ee7320b14884d6cb0a6cad3f6783c50231d68c12881ee18c2cb4871427e6993e898f51ad746642bf9877774aed625d89993453025e6b225ba82bf9e609e1abe15c499be0ebb736da5de29a3788e81569093571240f985ce45245b124d9ef37ae61c87c24da7c5adc7618d0bea49c4e464dceb845ef2b5d0771cf69f0b377ffaf4556f53f57ccbc39cac32d7478b22b9a125fcf01130dcc9880b9d45b686c129c611088389cf1daea7065dd77e5605de41af4ebccfa63811e36c32bdc09ce085ea44cd2fd41d711dcdf6723b307eeb30550a309ba6197253c98aa793c12889c5b3ba8ff6e610718ef1d1608830771886604788f59dd019b445b40ba72725ad00252f0f7018b3e790fa8a2bc1a4793ee23afe216fcd45c0a25dce0a6fb78a0958dc484d420ceb3eabe41d7b92d1e33938f63af9675793909875dc652e5e97dc642e4eaced407b05e7a55b983e07556eb7924bd4dce446234d6365491f5d7dbed9674dcb1b6f6cfbb56f70482e1181e1af57b8f7f74529f55f1477c2ed7da7d0f792ae3061b60d175a66d2096b6e9d8c572c32bf4fa49317159de673b3189b9c6a42f77edaae5aeaa2a9351d8188cc409d728d8393450d6823c3fbdccc68aaff344e39a50dc1bf43c1496248a42c01eb5e38ed69c7548076aa9c849ac054dd158b2948355808f2b07b73cd01f12963d5c24a543544940a17af8cc9f214c9c847b0d0ca3d4a99e08aa22889b478b92acf4fbaeb03059a71c3c0b655e76680b07379077d195f4c16973a0b8c4c49015942ae33f2960377f87a02dd3f81728e193b8640a385346af7aa4b58caa61ca6dcb0ed7c44eee877a79761d8eb52681a09052536e7c4393b8de88f88a967b318c362fe90c253d774b03afc5324119ffd17f051b77512056d4ced42c8ede77de90a537c64fe4e476f9660ceee459fffb2421cdad10771f8ce4068fd711bfe607c1f0eadd009bbda3b6106a8ed7cc76682fdd9324a7601af88b0c5920a25baddabfd6b1d7b0bb3b06c8e6224e85573cf5bc560436c39ec98123dea4803c5283c60171e0be8d3d762c531b5606bb9670465f6edb92aefee710122a6e28cbe04538ab49835629fe35b2634dc94ef3c6bc5fbb37d2c9dacb662cbe4a293e366f71f7a06970b9e0bbd6f460686d2fa8097de6c0674fd3368892b3abc3c908c94e89c2040f630f5a58c147b26409da521fe8234eb86fe6ccb63404205bfe7231c436eefe14ab1e0890a1c90b040433c29f0d6734798fa8c4754a3cf51a6d4db8d1af92b923636988ccbb068cc94bc7326460aaa8f2f0500f4c1ada78c089c0f87e3ecb2784a8948609e15716c4359062df5047274134000a85f3bf178c1e941cf53a61fea23614b023c8223ada14a54cc491459c18c3c856f2651f4e59af2c600b95041f0c0734b3088015998e9a5071fecae045ccc6e1ff38f1a66d79084bdb25bc785ea5635228d6648fc4376f3a718e03ce49d0b89634d90671b67d791d8a2166b2375affd7a0a62903226dde08af020bd92644d2a7f19fce95ac8c11b8b80b2157ba98b2574c0723fc571c525dcf725a43abcd5325dc5e95e30ca03e5b8ff57881a2149edd3bb7a097f7e8d6f19a831b4b52657855a2cca6b328a619d18ed7ae8a0153d0fa283f5903ce11edb39d3297f76898b0ae86861a589005bd772eb496d0d39a99982c2ea78f33e5c4ebbf2b60d462170b02e1e787287a8fb45cf7ea9a75aafc43aed031f44bc995d5056c42643530d3dc608f708d1cf9cf88eb032a591c2d2764a1559398f9e43d009ce74a6bdb5842890478949966df475493c28accb9424cd51491fe41cbf39303fac7b439da7f86983c951caca26787307d43efa7a86e5aa6b90dcdb32eac05c913031e922278c5bc79adfed752c6840e57210832be0496ac1e3496de75ea0869d7291cfb785a09aa172abd536cafadc9a7d1a1725f8353c2a991f55bd6c8fd496c706295804a8825f90db0fa5233e93aefac7923cbe6d641a44bb482d45e7ec57f540548bce1b1f55d3c030ee7fdc398d5d7c6727a940561f6694f302ddf149cda2dd0f4e61c134518480444753ab914848ff1eb61d0c27cf939e32dff33cdb58d37c21c39afbe4fb71ce61282ee91a23479c910d699ae079d9123e2e30583466d5f84883be78e1eb2585d1c53a0357be247a84783dfec7b8c6d7d901b91db3ec88fc5c1fbc02a947fdcaa47c968e013e5831fe5d4bf09d6644986502bdb35df0dd8733ba60a21645f1f48f93157aff5937e36ec0c20ed2032775878b6f5a3b609db78b372db0894624f378153baa3fd8f0b9fdbe631d440ed0bc2b7a6553cfc40e4c91051835cf9cd7a823c1e0466a669381e3573b393872e876f3e241e0e4486bcb15ef9597b6283317352f8d5f8384514297477c2ee3b1561de22d5a3ce09598074854c83aa6a44a3d6328a5118582574f8b4a5af86c67f5cf2b3e8c6a161374ff1faee6e8550d0ad90d03704e3051ead6d7636cc12b2f055632405353d7870a6397db92847c4034b21d24fa05028a566057329fae0b392547049976e6f917b22536db5f8d31c9fabc873ec62ce3d840d653490ac2574ac994a3e34ce50f9e3f450a28a366029a43e28e30504b1a6436d30610d9522d9bc563fc68e744a308e1e63e1bf963ab5c48ee2ba506505e1e213793c68cbbc52d80cc574f3da7abea5be0f2ea524932917f7ba5c9ff1b793a19bee4916106374d32b540d27190739735e8a45097a38b7105861f9328857564cb7b557ee24f6a81598f1d77fffcf286ac85e7b77087ce2ea044e0f5aad487c016ba0dc25e180af227b43324d15fbba47230e92dd887e50634639732009db3c163fb97385a6a2811dd26cd15cc8e0811a035bd53c88c5e97689b3d56453dfb0a8224e9e19664d9266e34b565e58f0e6ea2a85ac2c6b98ce6ded33e96740564b296b9aef8ce67dff17a69f2c0cd163d68eba3e0362b854ba20f248cc7e1c9e08da7f7fa569142266fd66cb0e9cf38e533126ffdea493bbd78894a0ee46c47390db0a119e1236f5254d804a0f074a8db9d87608296c15f43a2e8832128763e1feab72284e050fc2ac55c9c1b96868bc98da3c8027602347a94e5ec6193c3fd62aad256bcedd40e3b58c0bff2b003510ea990e414643700c5915ce9b84351a2661145d5e03932aa97d5d163d5df9cfa5bf83669c8bf30ec7e8ed5a0abb0b9821fcda71df9c13aa21b5016db79759aeb2e623f2936bee316e46251703d83cbfedc5016f0f48eb3416b257a1b3ea90d71d50d984673593dc0b0cdb181ffef5a29f8eeae338515c517980155e8d4e46645e977be05f9bc84b529febb398d9314811401197301cb2444d4509508488d0b40fffc8f24bed0532165fb9abe935e069051e1100ab7f04fd7ccb254f5a245f741b774a4bec436c2939d590fb3cc0f225bdfbb6a1c62cbcf961b491d4bfbc9e6002757c50c38af87bffc19a7bb8aad1e03a051d4f7dc76cf7a817e6fd240c5660caa1cf30772c9f03f43d570f140b5f2e3da2f072aa51df3aa38bd6cbbba95c25854b6edcd18a5ac8e5c299b5d4464e3a063a673cbed188b0d05dc0ae3c6aa5715f9481b394cd21c0912b60ee5b77bad4b1224000318837b670f65c15b836632b72895164ced8035c1501e33ee6f617a8391cc1a379e4f59a8a7d8b971e5255ef3f3bb49da369b967b67ec964b37eae25705e91616c14f85081a3dbb3e14d7dfd52f57c82505e47b8aed65f25eea8215e8bb522f518daa16ebf77c296cda5b0cfdc1fa43fcabc72400c8d8d6bda36f82b2a433caa7b059d23e40a73440a6d04b8f5237fc4f58e8eda8abbc151d9e79a2d9b672d70a2bb11a975a9b1dc5397e4da9f49fdb3d5452cd10df30e5efbf57c5fd67d0235818ebca5eda670e9170965d4c218c507a84f88dff452a26a26030cda59b1d780b875e75c644684b26f00544dce7f95479e56711cff04ac72b0b436fe0608684e5bbf82294e208398808a62a778b2568c5c0710cf942db0ada383b2ed8c08c34d859b7ecec52f2936b9e9109c65d30ab55b78268e506fa7b88af4582a89de708c596e27256e1a9fb834d7b45d3b80fe6fa0e9f462874e9e28fd7134226c096bd0d3f575e1d56257b82283f1b72a538b9418ce7cde6913fc4c99eb004d6bffbf5034ed442b1443162c3a83916df7d753922dc2d8e516f6cc47c9f26947dcf8786c3a895225acb079f09c588cb011a5100a15dce5bc67c60a37a7dd2783220579959b6c4a9fc1fe92c0270cefa187b3acb5308e0d1fa0668c1fec4774b5bee346fa81ddc8c7aa398687208efa6bf39b32070e10bd62314e77a5bd516a1e53c16cf15994bb53715bc602c8292ffbbe05feadcec9b10eb4b3c040f8c624395c0514ca4a462eb83ccb7ee233fbada0cdbad10419f8f8093d0a40fce1e0faf265ba8f3e58c683a464395a1de96734c277c889b2f507d3f226ef6338d939209d0a1cb3644e1c55dc04972ad7d8c1b962ea98b4c3ad968c8037a3dae0afbe0107df1428f71e92347f3071d899c803cc846bd2cfa37b82368f29c4bc24369566e8cc9d854a4d465f4a2020d2ef89a4c4ddb5482e3aef09e986c749e3a045acd5ae8e8ea811a11b6427c01bd881a8350bd10bfd207ca7fa5dec518c751a4326c7ad739ebdafdd4370f04e50ca6e326f5fde9c0666820bd33b5c7bd63c86e1f8006eae8f3fea8f1759a45782c028881d7e96a1f637f842c8ef1f0c5dd8695b3afe770896be6b318a84daaf9ec8bf6f37ea396b45963e9e742e737fe15b99102db56a4080732f245e38852765b6bd18af1db9c6d31f8f07711807f5cc5a0590c6deb3a3d1dc06a94198d93cd4b410786d3a174fb2c98ddec1c4d31f29e8e659e1b63b65037a45218fa3d6a51c38a82eb0446f95e9477fbf23e8c108a72671fff5d9135bafa5071e4eeffa2439f1079293ceb4d768ae254a711e09eb2f558344637734d4c94e186eecd203bb5d5b79368a3ad5d9c049c970a35757c7421b33fabd70d9d06d60f409153e847bdcb4bdf4c5c71bf3a5f008d50c58c1f4671f67de46cc6fbdc7e529ba22fcd1a91921467799a105d2f08a0d84b1c58e04a7a54c14b999dc7c85869a5a6e1d016e51b74ad728c608104ef08fa7df1ba75157c8dcd05b82296b22dbc9d3ec4aeff7a4be46f195b5ffa33f2f6d974253adeeceda218e182c481177e14095f7cb1db8af93a1f24aba591fbcbf21b0005e5d4a6945cceed637216141c56989d83ac50ec9f105d5023b42f4eac0e7e348a070a4d58bbc643289ab4ca5184e9411c18072cf7b1a2c7058dba4f8d0018f0ea0f054d3827bf3ea6c1807144afa3ceb7f7b6887feeef285a6ce2a7b5e9732e52df9d12bdbeaebd811d8cd4ea8c7de9ead9335aa35ab743a3ed9d4341","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
