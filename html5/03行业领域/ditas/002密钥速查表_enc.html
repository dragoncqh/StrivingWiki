<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"564a6090c2d6b40d7965a5950606848fd5c072a19ce50f7960c56be1ff7849a8efc40fbcfd722bf4e8e8a211fcf9ed5ad2a3f3fc5477165e7b9e263749a2bceca3fd87c46be4dc12ec7ae3fcd06bb58b178f1442edf7c2f77dad757532c4d9ad65e4468d9f9fb4fcd3e76ead443786731b99f271d343665fef5634f20c8a3287b2a30985b2df4e0c80a8f546b33182686f2317a3633e8c9828bf81cf7864173f0715e4d6aedd3e6c28b7ee854d914c6b5a48efdd6fab7adf4327f566cda9151ccefd017bb74e53a5a647f4994d15d6bc090a97b16e354cad1689f1c1dc493c17ce0a2566a0ca4cdc706fb42df0947fc928d4a50022bbc3a364e89ef1cc994575639a9adde8f40c6e3789b9118f010f62b9ac69bb19b7b6f657694f0ca198b28fe6c3437b60c5e775abdef7d37c6374b372da3c62c0bdc66a8169b8c9c255418770678068a1e65103703e36930d456b6640de6b56659c7d3b014689a09fb1dd60fb0482c375cbb2957043e6909d6df25551af422b09ac1de6264eed60a948acaaec2e8a4edb6d885d69ee6d554b78d3edf004f298ec31c07cc3326b0534eaf8e568563fc340bcbd818573e048bcb27d8ae3660b3e954885d6d74ea2a42d7d1fa6c338d2ad31429ad9f3358535a0ab5b9fb8310d0121eaac32025f3993481aee98d4ba118cb0985b902d1d515a9d55b123e19bf60e6de9204122e9e32568adbe83be338293c1f1a013c3fc3db49138f3b2c6e9028424939e3d41387e8962012f3e2ecbb0506991d09f1ebf1367f8e71e9c69503b837e190a87144f76c35890ba93b059f1660d8b5b9a056a3a7bd8b1f65d7a7ef9fe4bc66d0b3f659b8acb804341bd55b66432619c76d3824a40c719c931d94ab6c4f959223ee04512a29b4e49478594a676f69fb79a7547bd98b1a1efaa5e74c1ede45d765079affdb69a5a8e366a5e578c906a57c71b759581a7d0ff42559e0f7d4d4d036bda401dbdf5de6e53e23785f1428cf7afe01f3785dfb756a0a007cbc9a7c1a0f18129d6ccf79c2f27600f43a4232501fa17d192dee71029d93065c77b8486dadb1e1ebed8c4ed384da05cb6d6e793dd1b5ef9f6d685b163f9dc65e3cc80ca6d92f355762e703ee60723224bc641c8cc6d11686ea5ab04807b5cbc7f3651f981eb7da2a5f39a8d9cd85980a8c6bcbc40f3aebf8eaefda7c73c6587ff6b90b51c49398e89455ddff81c1d0b27f14102db855925a445b181fdda15d3d83221fda0ea26aa8e75b430872dfc4a0021438492b25f6ac4a643d7f16cfba4e61e4a88378030f6dd55e5b440f95f1b16ad829642bc4912ca541a3d9c4c5a3dfc571233b955136f3c5cdf4a8068048e5aef886a202a53fb8ec1066ff2233e647d882e26b284c0d1b5c29e89435ec3702cc73c4ba52511dd1e56f09e91900fa5aa13a08e13fe6af897663ef8e9812ab40112c6a3f612cd2da23f14cbf218fc39f78553745e39a7e6a139b1d60686935fb5a4f596bca05b17b54026e1e8a4a12842baf245a159c532b2cff8fcd7733ac79b10fa5377c7a6bdf58f14aa27cbe22fbbd366541e13c7c03616976c7106c0b58ef988cea9e638a47076ec21dc44306434dcc970b92f3a0665bf689d10e64b7daa9343a70a7004ed33f415adf30a83ff7ba2878722f44c426b56111b0b9960919639e84973b50cc3a05c6e846e8d71ad52c6f0aa9eda2bdb6a2bc0ea39007a54baaa1f7d6510157751ad73b60c18f00e0277c2c7d21df1e96ddfaedfeb9b1be470cfa361352a5727587d3b04e8ef0932291e2dfcb42ef8ac2128b097580b74fc0cd7f49f0666f068389c32c40075fb9d8802d31164ff22a534d07d578594a5ace33ef281c2205f360c714c429a5e836c9bbae71f109616c62dbbfd517b42042b6225aa8d0c95201723d187e815e33fc1a923f3a69743bfd9283d9d6e3f3c28a6c742e734849fad5ad8eb7f22582e32cf62265cda3d908925e292214518803e6e2c454d4ae8642bd3e327578094543c886c6c363e25d112b85db713189b0f708435f918fbd7b09eb67f9b1cd56fcc67ec76383c547e0435dd0030c33fba21aa7c61ddf08629d1487221db8670f51c99bec94886b12ae195e0458f215700827cb010fccf9f59ff2758a5898b1d4c34a56b53ba45a21601078bfea2a7ef6786b7ac67206353b5cae7a3eb443fa6a8cfdb19afcb5eacce7e2bc33e5889fc1427573d11944c64cab0e815c29450ad34489a6cb73bacaa04c13f80321ebfacb5f55ccffbcb0e6634e7ce2ae3ba5230c1dcb7a2ea3f6a2195af73abd3c63893e5238bff2746e4b8d5d7a3a43727493c7a4b16f1bef580e8c080d30374cf5260cedec166b92ad1ad433989e011ca9f9ccc82ea8d77a8bd325568f4f78893a6ca6019f5a351fc7e112304a070c2740141157e58c254400e889a954fae2e3d4f1a494940f2118cc60e8a1e923d865f8bbcfe3ddd896be9172edf155e78a2198839955614a363ed5e8d2c099cc951c863b74a2e7774c3064712385198e5e40c0881cb4ee308b185e0c735b67a59eef0f669a1bdf878e5575034ac8db9a294df5cc2788b00c6c39df3952f4d33fb2098baace6f5bce0f2849fadc0bcc581bf2901602e5bfea8d06773e5c13bc5ab3a6cb6622a12dfb298b868e6c7e23427edd4912f9d50b4ce687758ef8c7dff8cfdeb52d2042556829b0cf0d1ba4823af49950f496f6fe9736bc4b5f37054994856a6da43ab0748999582f448d4b7d7f914f427beecd70edc5848d1bfe296ae4a2e688c764ce24fa35970caa917551de6d344904b560d81faebb1f7d838fe366f4dec0f8031efd7970a65fda5e9357c26bd4e0c78852d14dc7629644521c9b163e3f0df9cd71ef4a6f420c0ab75d6a2dee8f4fca86e9eec1cc29a991f209376e2c87f9efe471ff2e800b831ac46f49049304980cccb9a825c154806b891f577b72b46f87de08dbf7f7ff8421dc6c41fee6272886e66ce8771086253a2d21902e939eeb82c3451be54db55fb4d58aacd2746034ce4e7ca41bcc76d307c9628f9af4c96f4e0a49e54361071cabcf0ea4cc5f47aed96835bf277f74fd8d1a957feef173c1d4d214dd96bb21a79453b6cbe6b0b766e63ca22232189bc18c1f8d1ae9a642aecf2b01b473813086c54392d52a4cbd2844128b1c0a4186d2fc4e2c6dabd8f68cd73e40ea6c3213dbef739d6b163df3e1785433a2b87c3f1d0e1a56c05e3d09a2d95547104e91e9b93ad4b1740aaa4a9c1dcf7e9ae55523d97fc4f739e354d877381fa1682384d9c03a031beb70c5b1ac82be2e4c5324eafb3df78ffdd06b97a45d1ad69d64e409056dec6a9e29e407752593103643f12c2cbae8f6bdcdddb73b6fd28210eae4cc4fce9938632d8fdb092e0c8cbf6d04d2f9f75cbf2bf15c330bfa3afe5057f333a49bd7309bdb20c821b8ef9ecaf652e7180059b6c8e343496c349742a69ac04c65c0eb4269fd81dd78aaad2e578597df2cad540ef9ab4f04df1ef88b06d0fb4bdc84a1da4c139fc355ecf453ed1f191190ae337610d8601d693736bae8c4c21ee50830a26da608a92afe7acb8142b4fc47e18d9ff8c1704c87ddd783cd43b47a848134276c0cb1e9ad3a23582e47b39926a1babae22251abfe8e834af6f47b3c48761d44669ac2773a6c13f784db54fa8680069e6923d2aaa5ca633d3c81fe83aeffb126e2e39b243b5ce3c420463c066d7948427439f2537f5bf2a568560c17b310d7bafffd256448b7a3bde854403dc4a74014cdcfac83dc508f0cb096857520fe9bd6bc7dab90e68dd2578ce47b5e5cb58b5ed94e64f14fc9a27eb011c021877ceed17d94302f61eaf5336cb1171b1d01a3c666fa268c9ad62cd8d0b7bdd0d537cdf64d0bfc53d2791652ded4d79cacbe9c6886e89ab34608317f5561536de5e45c1e1043a0932e83c24d69b04f7ff15018b9ad22d8fc14dd52305e7d976c0482ff1264ad148e2004faaa382c909f28a4cf666f2a9083e01db74e1519570b0ea16a6e8aee7bd9533880ad625966d604fad9aaa879d1ec80a1d0cbc5132e6fc709ce5dd4de1ae38c53f61be623dfae9d2f36068230efcde3887ab08f0c451a9e2c2296567d432c6e7641518624914a1cfefe056f98f285d6f6779de8a07dfe0d9b87c0086694fb442df9b8a0d68387e5c56504b768f99aefed6d684ccb0d948765822b4e446a7d96cc7f5e512fc27728e5bcf21b1d35d93105b0220926dd004ee8f35afe0926448a9d758693265cd6abb9b6db16b9bfcf54ed99e1db693b4274ad41c427c231102484f5fd8e97d2ab49b288336513de9cd63c7c73b2d516c05b1debcec85a3bdd1cce414d6588829ff23694e45d6cab9ae29dc5d091beead713fa58c6f20b22bdcf111ba1705149333233428138f85e40750280b0f341b4a6dfd0d5548ff4cbb92dcefec01c79a7f8a743a55556c2f9431d608ef2787192a366e94beb4214b0e15e8278d977e1f4bba1c317fef62503f12d897bf57b078d4a2278d17856a869889ada0118f119b8a16ebf4e8bd20b160e9ae4bdf5ff988e17c60f80139dbcd65de770bfb36cdd93342d1fbcad760dee8f3c5069e2f3d4fe075399c832811f087baa8068bb0ea6aed1b295ef91e9a4815294879af583d4cf0ee9f55a28ca2c7b9aaea80c340460ad488e7d7ea130864a47792743e9068233f58fe0e512f399cba9c8350ffc61a9f2b3843322e2196a504dedc382acb5c416ebb09fd3a88c551aecd5a97b8250fd4fc55db2008636c6d2ab603a152802de5d6ed3790279de9a19e579fc18eeeb726471551dbc6c135d398bf170a070e115d869775ca0cef82d060f40c4c5834b6085478eb8a68c7b3724d27b394d63afdab4e00166c50e0204be4c96b5f75b46a9fc2ff85070cefc7818594f6a198d71a11fc702f89deea5cf24b6035397c65fcf3dc2b1379312e9d5dd715caba495d029790a40b7bd5f910af8484e5e4433e12e79eaacb8a4510c18e20021e8849dbb07e345e87d1dcf8f7965fe0424f88c399fef0a5ba4ccaa884ec8418486d4ee824ab9a16f7bc0e3fbda2f9e87792871b2adf0cb002a6f3334cfcd64046ad424261f277f948fb0725827452f855b1e5d3c9771202853f26f34532758c297ab5a84e6132fb267bc503e747f09a2faff1db10b9e64de7f9326b818965194c54aa97bdf0c5d269260fa8043b67dda5ed46f17a7bd4d659fa56de19a7795d280d581482e1dd901cb8a5a30860abab497b5f35fba8864b5e28794a681ad1d9f757bda34820cca00f323fc9139196d460e6a923ed731bc6eb092e2d3db4de9c2116ec12633a3cdcee2dbd085c016755e9286006ca2d2877b974dfa3281c1fff2fdaddf9a03d6b3e95965e1a071f6c2a9af08cc9fe58f73a2f08256ff62d3773e5b3bbbe265fcd2b97360d16a7c366aab9e4578dc499d92fc7b3e6d69195ecae1a31e471fd7b4b2a3a62b274743982a9bb47962d78120c27c7decc2d0b1638a7da59e0016e280f85811d32d59d0f55c75c4bedf3cd7b16dcac34d56ad8d28f68f4a9b2e74f16168925355038b59a7c2a34806595f5e21bbc8f0837d3b14197f4de5fc63dd8738415f0fa1a2c423dc15151ef4b0d932bb7c563f0320597018c9750b5ad4f826270edb5e1edd0ecddf9fcc405d7f868567b01d5063eb2be0027f120b1c0a721655af77a6b5238234ead7eeda4c6d3e842b6012d94d4ae56814e5158d1a69fcc62ba030bc1feea8285d80ba59726da52ed83041f28b033b1c6574075f999d7b5a6de60494ae9c4e810761bb71a2767ba13bcabe9259a79c71326029af885646f1e2f9b94a15b4117370864ea9c7ebc5d4c757c3cb94fb398916be7143afc9875573b91ad942098e739bc9773bada13462dd833ec9d410b45f909419c7e7abb2dfdba73134352bf355bcbcfe1f6b5f3fe6e80cf62a7154176cfee330a9d169045c4acc65720be6cc4ebd4ca531b06c9ed627c88af86aeaa675528951565e9bb90fe1c284ecd0ec50337db7f19612556f5155bdd26223574738fc427bd4c2b93aadda41d978f47e86827552f68478efe15ef285483af548ac57328c165592584b38e4d751588c9eef2c9ba88d6cf4435313812bffd5822a1b0a338b150fe862b1943519d1da8d2ccb9bc92277e7cfb02f2c7804f2de1f7f7148dd327ac364476d1f49503f2dbb58620a4b7bdce55cf4307d8aecc3906547f3a409084301c75d46ddc3b7766578e5c248250af749e0ef9bd17543e679632e59355dc097f16ca7b1b76169e19332d22d82ea3b7cbf0f77e0ccb61893747c22a7127d91f507c4ece6f0892d1391e52bc8ec5cdc8eb6429317b743a95f6cfa515afc9092d741d0bf80b69dac6e570d59ae730e0478da4c6b44abd27daf8190fd9c0c26070db7a0fd5fd48e8b39442a005ac7ae47a1b78385d4d0315122082585796f63617e99dd7161f4d69d0af748a593aa04795cdccd18186bc1cf43442105c33c28613ab2de862f55bf818811a32653fb768b61d346b5af036f9176148e85a88c885e4fbbceaa804dceff0ac174d3da3918200abc2841667eb49486a096972cff39a1bdd5bec08cd4ab98976c672a6d19e80df2ece67f568faa24712bb48176241138fb023654cb20c6498353a18c2a6631485926945948e60f15b15766b5945ad20d209b007861e050d339c29272afff49cd3a4007e56815c9d55cd5521c19cc29d9f485a814fe636b956b808f83d5149eb8054dc23b9538b07c56e1eabc7f65392005c036a37f18a905faec55928edb10b3a5aa46f579c99085daecb4f26ef78c733b22dcdfeacc7b0352f85eaec0a14ff468b7beb7ecf39bed4a02a5aba58de93c26ef019151be6f54011522a1858a1934d26975c09d04243d48d2250c34fc15cd1e19be35b5eb7c961aa41ebb6cc32af810ca5778f4fb58a820f284c6ac0e072f74d3818c5102d479176d36fd7c2acbf7346b560982af28798a1a053fdc54a54c746d81cacdba1e2f2208fe9ab1acb557436ce3df69801eb2c8f7966135507ffb231733078af4858c7bfe6bc7b524aad35f6573d09da909c15ef83b07ae49271fd9264d38bb2cff6ab7396dd87ff03ebcab9d774703fd050bc50aa275f437b14e8886c94e10286ba61872f0c902d3fa8fda69e1972615d47846bcbbbd274b2375d7e20114af8bfcea83d285802d6add5b9ac730be5a37b376387f2e4fccaf1add56e726d4df547c5e304c354f4cc38c8505a2cbc9dc0bf089ddd556983d0db00c56b492a1f4a0a033d587d8aab46e332f96c772f535fbe4fc8881ccffc909eb2d001973eeafdff9a52de023ab9d11fe3557b57046c80d7983b13d8a44b15cb086afea1771c052606351e777bf380a3da5acbdd162f95f433f7ab1ac338af1a796c978acaf53fcde7db44d405f3002e1e4d932e0e573a2b2004244f90495320fdb4c3ee2144d976f23237a10b9a1744ae3b59a271e62c3f61f594d3220e34ce9ca1402028367a730483792a4483f95c94f2a87641e530da7450f13d6ba87849fcef30a23c1a5d3719f1a78607fda9b653c2100b69b1a27cd2fdb62c4220296167b70e415833baf2c71d6c4f6993ee8bcaf0535bbd0c06867b2ddee305e5beaa590ac0fd72105364b0d292e39f3c57f16fe805061d0e12c96f338a7fba64c591ead39c7a49313c0f0b72b1d91250f8f4d5aa3a3094be86c96e1ad362e47c4b116e7280058aadd7131ca28fa514e8724f7149f7fc64a16dab4b82582a591fc6e40376f7d74a6cb8118f61b9db70a890a477910360d3dc2cb664b9bcdbcce47c5b728daeb461df83c2e4f4b2ee9e2628f1dfeace70e307cf55138d4c49487352ad42d5ab51e4f7e5e375820f94cbbee023851b7e1d72fa74ea246e6c4c8617b978473456ee900c359590d90cec792b379d0ad9ec4559cd9e3946f3ea316f9a0b3eec56a10c115fb8c24178c34802e40875195da4df944193b5a7373eff26e7b86a50878d2878ef48aa67b1509b00c54baf69a223f29f57b7cb650816a63174392a747f226e68f12a37204bb3f324433e1b387d44d64b6f80ee1fb0109eade19202c583b2f2768a5cc02c3dd07a20e665dcde792c4cb4df00e84836b00be330beae0d247800979f17168a648af26ab59ae37b74a2657eaec9818df9fd90dad56e1cb92ac86e85be25678848d71573e6291d238a57a29c4f12c55633e95c5f86019b20ebb4b6f2127ac7612fd41681f866d8a4116169aecea1c2ecd31f3565d2b73351fe62ce7c5fc7ba207af06fa7605d34668346a1bcd4ea73124cc0c3c12d80e6a3db58a95b5328792cafc808282db8ed425adb5aa21de05f532208792db41c72c8a5f114a636e5e626ac98efabb4c5fc88000a924446ef4b2aba54fedf10cf76674a518b9c83885c609000c1a70697a77240761d85e484dfcee260ca76a8846127e2ba05db46909f75d0269f0d2073e1df1ecba3af204624a935e28546315b68563c91417a5e204aece1fef3d09f37fb103418841e688a1c5ff1d56d2ac454d07ebb76f7a1f559449aac31524049ed3e94e3cbea9e664e73bb6e49f6902726a6992cb1216150eef5a3225ec048aa7eeb9689af5980a94b0a57fa1665226018aea86beceb2204dd7b6997d964c9d8f7ae1bb74e96d3f0f2b5654cffc3c0a1309e981220dcc19829025d5c98425c11f2441592ffa795dbee53a40e8ac70cb1258b5b5ae92a22ac767c47a3c87166ca776407a486aa20c93f100182b5d2193dac62ccc8c688eb35c061a43ff2b0d27c97855297579995445ad20beabb5d1640b4f8a1e9256a73072e82a5cb53437843359e945e01353f9ff4ffec73ece7d80bd193ebfc53656e3cdea8aa9d7473feebebacb1c299aaebdefb507ea374fd57db0144a36f5af0f254f139608fbb02a12e2809216570f6d99144bfdeefb8b6b470cc55c1eebd0449d9c05f5b3d2b3f97ecf45eeee5f6e53c997de411acc859b9986f95e334f6709869104d11f49fb23ced038adc8b5fc325d20e11e3e5532ed5157594b22fc3218fed58dc32795aafbf3ad8a03b6dfbda922535a675cf1b7194ea8d338f9b616713090530134adfdad3542335a1a022b3cf8bcd9382d6834b2ac6912c73dd72f9dc503de977105f01271be2bf1937c10d75600d3b1643792fdfd2485c4504ac05b52cbd110cb65049502dd05b6b6e57b4cb88eaf3ac6cf07d5b23b0e4d92065101f3725a6b6c849964410c0c9df9006ae6bc00f2ef28531adf52eed66c5af36944bf31ab06052e9dea3bb69c6ed78b5eed4bec6893c2b131cc5cb6126edf03591e3878ae490b769c18116c5368f32273e99f5cb9e637811eea8be7e4978861e7482e5aae9a665bf7f60856eb6f24a069a1d03b8e259c3ee71d8a17c81f6d518e9af8574e238bf86893c9c90aff69b3546b46e52b8600e53c2ec5f95e5f5695d1adf89170d5fe586350425269de997ab1fdabcfff0e7a95e29ad8e34ab0dbc02e52ddf904135661cec9daf384c6aa48eed0fdf4fabe63417c62c239a0a92a2fe9239ab09ff80ed1877566299011e877d5de0a3fc7cfbf304312522a32fd796d458445661bb35e59bcfb3eb2130863919c93589f980625437c8c35b507be923da0ca2d700065c7cc60d7e647c93f20becfd9d87b2910427b196cbc8569bf5c9e2fab3520639ff7c32457b04ccc049cfe81889981509929faf7930b117781f445d6f60bff0e0f20c070c49c42453c5f95108dc88cb8cfcca30e9cc23085ba757eef581d674b35808318085e1e17d3e72fac9a90095f9818ade71d7df82956eef7ef807bbd7e78b280f20d7e2576753aafe17f15cb847e7b386915d71ef437f94c8a99534d758f744fcd3ca83a96fc23f4599bee177c7c47c97ae849608d85d2ca0d8a872be3a19bbd0b9e76039bc7cd328374e54e09493c3ab70880cc4122151fa7d1c692130878ba3072e2b6651e569c464991bec1208a7b27f54d7b65f7fb22a78f5404841fe780cac3ef6b4d25b510a44c2b8c17a38899bd92583d5ec79f665827f474b264134ac341939b4d8c3fd09d7e7bf8a941b8ad1e71bd169f0fa643a54b32585a2907088e2870c01a7a95565581da781bd82e22a5dab3ae18524eae85bef2566c29fe64b694d87144ddad2d008f0e9c6ec6e49eeb589649aee6cc864588dba8f2d89718ed799cceb5daae91f207a444caa0619233c76fe81296e8304eea1edba8b02ef45d3f1833778d2b62b6c5c1f44fa685d6c61d5b3a8a4ad6d63617f2301aea84fd73c725bd6239340357d9aca4d018313f831647cf4860e3522c433eade83e181664a08362dccf6c2e5cfcdad838d1003ddc53ead995939cba1f885178c9b36b783a6ebb7981bd6597b0fb043020f95ede40ba158e97c057ddbdbf5f34311c11480640c8df89df0ea2595e5453bef5ff8e2fb443d8c64984b806a71c3c3e7e7b1685a24cba19aab837390c9c9d414c1aa1214c6e6eff5ec7efcc0e79b9dca51f43cf441397b41969e87bc6b6356f3da765a24c982212e1a55e98f99cf48982764ca06888972b5d622f9a114d81b488b54cebc560e70af04f0e8c9b15932470c0569a3dbd58bcf2d85ba7ebc3f3f92a437954985bcf929a3d054f5a2fb3038e3e1c17dbebb52c1941109e2f2f581416aca5fb6de7412622439ca2b9755db1659b467769960d07b3236b2541d3e484c619810c5d64e16ea871b3aa4f9c59263ddbf99a12e7f9932d7bd74907bf3c4324c3f062454bd201d25676dfa20f8a71cb530568be532a2264993853cd081389f1c4070364a8979d38f8ec477593ef8c2988347509966e047f93430cc2b8313dd1a3ff6d7a776e9a19b3d9437e3e7f6ab6645bdc8054c17c76cc222441a98571626f10624ce4fe9dd38eb3d445f0c96e0bf5e985a3d7095ddc4f8ee02f652014a914d77701bbd859cce40b47035d397ea98522976617339cd9a1340c4ed32af998de54b172b6a08b17f144eb8e767b264733ccc62ece41b159495321e63649e8ecfe6c7ece1da195d4537d2dfffec59de9ffa0e4235b5f0e12f89e1bfd1447cf85e38c8b9a3dcce530949affd8dec1373d24e664863617c42a3181402394712be022a48cc9fabe7e558ff5cb7205a6514db0b215026e87e8ac9b58ebe281dda6b72a0a7a7e1ca434ce65ff7b301e44fe8c58f022dab194df0b820393712a21880c76fc05322de00f836e925d8466bc52fc8627a7230447cdc7416908653341d2637637f820c75ff1fafe2484c725024da394f2b5722db77344a48a9e36588567b5417913a1fafc3fa8c49d287db8ed63a04295fb44c8ba49f7c28a7f4184d4a5035488910e8511476c03a31204df328c5815aace9e08da85e0321dd31840bd969a6e50906c50c5499390def6d834df4dd0fc277feee61c5b95ff6206029eb28a274819cca970eb45be69e77ea697d1aa10131f28c5b794271ee252a65f30f77464fe4169c6c518be1c905d8b6f8d1dc2bc0653d104647c993c72b1bddc0584011f92f5b17f8fb7c87085ffb0c2fdcd2e16aea5ed3c6e7b5b58da63740f6e3ebbf3aff17973755cfc92fb7dad7c31c947f1309a5bd8848b8f4acee2aa8e6bc38b5aaf29e73ae0bdc39194800d66b61d5ca6cb95ffbf94bee2c36653f75daf1951c2bf3bc7d4fa72282b3a64f3f6a004c071a627c6839f23ed5a92f27434458edf184c35767ed1096e6767a62c7aa23bffc98eb7c8efc7a6748c0e7463183cc3b4f95554d89eaf63da2416f4d125bcd3a62d0b07bc161919d524f6d1f755dae83b77544094362b81191a06826acb946effa356e6f1c5ecc3669f2e551d539489ac5c4da22d645fcbd5e8ebc20cefb444d1bdeddeb856ff49ba7ee06ba43ad44c7d12fcd21cadf593178db52bda2414fdec7b75e04c31ef5f925b1fc938120e3900dd5d8194395ff4dd7ba15ddb0836ae0746304861db8e05b02b105257307d3bb7fcf92e178f4db9efc42c6aeaa19e1483ab36a23d7d552eb444e2122fbf47c5396efb69c94433b86fab019fc1853240dbfbf17315742af16d64839d571e139d5b16dc08828cf478db994a56a364ea99a6dd3ce165d71ec2bc82b37e0538a113cff6af42f0819f97438d0ff6e5f4a1913caed6d3f3147e5f9636d995d8296827a527e7c86ec26a501bdb2ab99378454b9c66b0140f71b71e1a8d98ac73800a901a58c975f907ff225a78051a8e1c0c6304741fd46fc8fad97b46c511071cc5d84bf501d9742c4e283e5f9fca4c3c07c903645db1057fed2ae38192e884ee4d8921b1d515948ff166b7e26f82f85017cfc93b9f3f38d2eae1ec05b3ffb9d927f44327631b14a35d754b4b7ae6d5068b32a6e0084c5752a19724c440f5486400c6696201f3d8b60211a613dba8801968c5ce6fef58ca38ef64f86c134d03b79f270f915827b711378a2d430590f0d145ef1fc19a37c625814d9b76d481a56407fbeeddaab782df8199e8bfd37f143dba24a4e30878d241cb29dfabc1c20e64d7fdd57df7011a9daa21db9ad1f8b6379995b576da55ca021ef2424f582b13569a4ae3d50e49ad5e1223305309fa8f9426f87231df9373a738f379d3bc05bbddef217ce4c1ab01edf95d3ba2401ab0246fe05d5625bc54b1609acd8dcb90beceaab97d15bddd337e2dd1d6ba9f5075ddc3f71ed4d9d430e2a78dcec30152017a05d2a257cd1670699521f346e59a04056fb5f2273b1dced4ec448e66e4ae808c8273ee1647e2f89093338243c2e0134e9f06569d6d32641a771dfe24b68bc6a1bd4f5dd7f8e2fb4bdc63588b9432d8c069da43ac8e97c50d348d216db523064066091ca158fae9da39442ac8e0378ee16aa04be5216d8b108d12a87661a39b68068cf6ea88b5b1e574996bf744c80957f66f79a634383e45c66c1d429b2f1ed425dd203559b258578016930c288e3e398b0c016d0f3f0b57ef5bb3e7f43d106c1eb5b640b989ebc88fd6bc58db8f9aa315202fb05b023e99f428019d14a083ab66673ef211e3a881f9ab98a76c0522c9cda186e198bf97e83a05e88be7efc70a1847f5b3e588154544a44e7258838273636a9c8ebd8a163202afa1aece94433f8d208ebc4d31c090c22999bc466496a2fa0ee994dfb5aa3a0683a998820175fe796eece4968f4bd2b1846b5406c25ee5b0ea6c350a7c31fe085bec1f82c498fd14350d55356d6ebeb792bb83f702fc3499084a34c7e863251a021b80a157e9a705f5e7997b4ff46b4317e21818fae896fd0ded2b26620109432c04f5088fabfff285655689885ad141a8daae2db78594b7eb47a4a6be52f3b3e729e9e70fab298ae868214494cda324391a47149dce3f7bd7fd127a9f3646b111f7e3e3f7c29e34e03af19a2f80e2aa6d3740e900e102e36b272116c37962e53cc531829a9926a0278ded01a878ad7d94c4bba994015c6b82ebe8368fbc87d5b93272bd9cf89960dc64f47562bd77f9c10e93eb988dcce1ceea17b245cca6442328922e996fbc5aedd24a82624dbb8f0ec3ef6db19a61de80495980a3b27e91db1d33da3be1173438946e3eef2bf4cc28e98b99ee3294e3aa967039ec7c26418c5be78c16a93dcd5ffe5d506d86871d306d674870026da6f189dd811e91c206b37d0daf2b8aea65a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
