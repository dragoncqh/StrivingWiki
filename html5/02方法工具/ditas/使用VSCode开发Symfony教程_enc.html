<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3bf7d59b790e240fb339df6c1a32d1ce214619581196d1aedb169574f4f9eaafbc6b7b25ce4e43d7dcb0811b4e7b3d42ecfb72d28741bccb9dc22973d5475df614619691aef60150a0dd162721c516cd612ae8e6c8f33b50b075ec50925b56b5681cdf56ebbae3b1ac3dbde8370e669b8eeddbe6873ec2b3b8f5e4208eea20b99622b198394812812063d28693b0036ffd95c9c3046e7b402e0f1d9ed103eb015c5e2c96cc845d7e92fd8bfaf3bb43718ce21ba3e1741ae1cdda0ab5c67d85f2593f00147d71ae5b6c491da03aea1a9b29f761cba06c9a8c7e102da8f44ef8b1514d4f10cd0d04777dbcaa848299b5c0646c9159d2a576777073d6b3d7c23fcef7443bfe82d3bb87081a3645ac1ab3f9649a390af0c597db446cd122f8dee62d060cf9ac0abfcc4978891377c5f7e3ed04e0b61c1b8e5b9aa9d63498680176a18a2ba98662538d15d468c7edca816dc2c80a56470d8353719d0dfdf56df65fdb33c78be21b9b10a5a4babc5239f85b87212e56088b548654d7a35302f43f82bf60fc68e5ad19aaad825d815dee32d458f76067078d82769f7aaa161f0d389737d9115fe4e2d28229d75b0f07811cc43d5c50ca693b1b2126208077c036b705b32fe3df21b44adeb61fb6103e28c02fd5ba4f29fbfe15651f604bf4a72242b88ffcd5c8774e87901b0a4908d56de36daec6cd8c0ace2858de123b82636d0d3635601a683e3d33325da8ff6d9bacde177a03cd3b994ae9bc028ad8de2c9473a5b7410354d143db134b96ab1ee0c5b4aefabc1a6f34c79793916e0b1170dde9dcc04e8334deb2562eddad6050ca688278b9d4b53f608f5d2a181f9c3d032e1ae698c37f5eb61f66c735324951431809b6ed48d50d88b0b45c97586fc2363bb85b8cdc4296a0417597003ff9eafd51ed6dbbdf3e9fa7a9f410f7fce0fd2896a3e66a5eefcf8a61078cdc58823d56ea2255683892f561ca98134c793c0cf3ad40ab91e47964d79770a0eb9a85fb67eac1945bff895ecc5b2369e6d991b90189a9eaae5cd98e0cf42a12503fe5d68755ff2584e0398e91c5fbc2e283bb500f3454a26788968c49ca68c5030473c928b644c6c485d2a2207bcbf84db3e7e4f23fb3030f439ea1c1130bbaf58bc861ceddc43881dbf90289727583c20aae35165ff990d4a12be52265a5665634baefcbe71945da4f64c60008ef762c04733d9086901a96409184ae76a07aee22af8ce4a2c08d80caaf0caa5e1e350563a432d28c480770f6e36b3fbf83fc8f609e1d8601e91679ab6817ddd574d1a3bf5e473e31e833dca497890192aa20f114ffdd2218ca5232f6aa0e56296a370d5c4aa547ce8e2b3997a49ab4e67e0b2b64f5850169ae4748bfe227b261328a6391627e7caf273a2eae847e759af63798a7477e2d09f76bc82a9c4a264ab327fe04924e9077af8fda2cfd252f9b6903bef16a40037533d0e4c5d0b70fa50bbfa2e369366d5c78cd46a1f7a28360739a90d4f378ccc508b01766a445b53945d0ca8ee73450ef765a585fb06f81d1d8c265269775a6f824dbd9bb39a29e89d9f74670a6de499acbf6518ce2d1f721258100c32c5caa109433e2e670068b54b90e1cb0ec27be41298f4dc08004d693396d9f3fb9c36a4533c1b46e8ccf33edf8ef852c6e8d802c6abea0997afc7e74c8316394745aeb27c483e6a4b4d0e149ff239f584384b283e7a5822e59cefe7874060e1c713b75f5bbe318b15e1b097a3f4a83f9e44208733340ae96e40ca603791aaeb938fc23efed23d2a14b25a795bbfbea689052a07fa191cc37a6b154b9e21d3bf5d0830778ae678d68e676f4a02887c815061fcb6392295bd213d3ac37fa78feb286abf7e3000935a35e7b820d6d1a83421b0b3f73c5016d91ac03f945946af1830b3c29a901ad728eaa1500bc0da679b9f37fcd87edfb9ae9f05be5bcfd755d91e47b9e8183438a8ef80451648fcc35bd2f69f142094e44b46232e6ea0593652929d3060f3b0227d68e00a93a6d1ef5ffa59bf0f18a386aac8e54de34519d9a5fd528fad733818b63ee7fc36e84aee454550583dd58c5580b33235a13bbb976bd43afd3f2c82ba67fec0821d11cffd3ffdea5fdf373f50d7180a59fae4cc28d605ed16cfb38de3dd9706f429edb5eb32e8b79ded677d4140240d924acbd582eafae335202f63a40194e7d2c3089f9dc06c7b653bec21cc6b3b22575153651ff80343d0174682a15ddfe1f7ec3e5395b43356848d3e26bad03fb71b1bc45978072de292808ddf49dd425684ed4b08f8e03cc2754635a320b918ad9c431ad8f3e64f550278a0f6cf82f4f141baadf87088bd28141be5f8590004183529ad065350720e5bf39e8262b86bf46e206852fa76ffa1086dcad9f755140595f7f178240ee5e1b35d8454c5a30130f1a9c8509c4d0f22ee20c996a4d497e5f7f705e840c55f0006fd862b7655a541c38d6aaef456b6a0e62d053d551bf94fa033e2096d203b5e048a9ce2f76c865242b6919d1396ff5fbe93403c23f20abd9442f1908cc77c8f9acd6ba1643243f4167cf4d8e6bcc55cc7b4ee08847f88171f3203a8084ca4a9c91bf496997a46c9ed39448f26974d7ee04bcef4652edfa4976bd747d071595e99d0e28bc2236181f524c9687334bf7c10d19f202890843c54e98a2e9759a4ffdbcc22bd608f30028ae2923e54580137980fe3e1474ce77aa6378ef3b03fd14f98d8b7a10542ac3a6c8b697b2443e218812afa6a194aa9adafd25e8266edd6f562386e5c5a89cabf48479a292a714216f52628d1b96067cecc04c0bfff93f048cab783154c6d2a72ced4936b0d7288d244616b25ebf128775b17f16dc4fa2d73b39db2354110993c9d1aa2bc3dc3cca273cfc1cf859128bbcd72d63ddc676d80da34eec35551a3f388e7400eae8dd96ac591f5d0da316d641b526e0041ec7947598f94c20435aaeb0c1ead178e83e125b2b25ec814ac0abe9b25df8b5d963f55168ba3b130a91fdafbe5f4855e2a388e250dbfa35186447f3df21ac65d1e356bf3eebb3fc86886ed46b01b56f6290e478b0fb626dca1ec8184dbe0f23d2f3c891bd54524bef8d6bd6004faee55f07878a4b948bf264f08c4dae0ea2e5111de10d96e180f506c6505b00dba991937449ffc737cce57925554df67f509a360392f9acc77d08b550a38990f730cac5ef2198057cb8c43d6f587aa13a956e86b2494a3da176bae96f9464bae0bd207bec9ba25bb99612dcee6c96f57a8e4db8c44ff7921f0b5f2f97bdcca9245ef059c85326f5cb569d13adc637e4f57f14d171cb60ca2fccf23c21e510d394fb2bfd467fef0c9891e0214bbceb546e29dcd0326df65fc84fbdfe84f591ca0bab7c90a15aebff7538c47a4b8f790313e87acf6b57765cc2366f887fb51476c027ec1eec456fed1eec5c32fe025f2128a9b73af913a611d17f3e494d8d0d666f0b53ff3ab25682caa60f5effea04604fdaac0e2317962c29749971f59ef143e9cea000c845d6cabacc439d585b06eb6d4a3914d91ed2145ccd1afd3c38414e59c9f8baf9abf6d27772f38b891c3fec068ce9e4139474492d7461f28f9c334459422b2be7ec1c12748cbc2bf73137753af27251d086192a966b69884898cdd2649a0d0dbe9cadb2c933d2e2faaca50f5571459e9701711822d7e77bebc217ac695d6e6ac014f923f2b49c8c345e45b468eddc0d3ae0160cf3369bfa9ba97b7a3bb0efab14caf42ba16e2c6d06884e0a613a2acfed3d71b030ea7ca36eec6851ae659fe2e0e3e943f46312367e54d068db6b3a5a2620c29ff1dba0e6d37fe94a477b49ca49c8eb1c37ea71e23d7ce31bd4876f4773a2c8e6449288fc45817aca31c7217027fcaa8c475309d3613bb92023ba1ff02bb468ed014ee26b814d8c5a576a9b4fd56b9b5d7a43098467e2357bb2636c90c0c5061b5c2f488214ebe8f9a22b322bf6a858fcf5322e98f25fa1030f97a93c8d2f9ad99fc527236b6f258f1e0c116d88dc805a60181095d9ff16137d786163664cc16bedc4f953a3aa1fc0bf1c0de9a8b0adb81204f9af8cd5609e8911a7de72c30fbd32d2f42cbad9245438ed836300921187e3b7ee6c56d9623aa0974b35eff94930dc08aed6fcad0c25441b0dd249393484b672567a1649b8f1fa746ca30d857cdf0f2d340cec3bfbff15c808ee7fe79732004eaa4f7e1e04d2f2bb70c6dbbca63eb0b238b8c53eca5d7550a69fac5c4c7dfa120316e3ed28835ef5aa6c7810f350350dfabe3627dcda303937d76d751da3cdbc5173dbe7c93db8c97e003c184910e65ae7d9e751a48d0a36cc2d62bb0b7e48aa531c8c04b271f94e9c71c7a9d35fedbe2bbf0785cf4753a5bc1ebcee7c65d9267dc33beaf43dfc3baa4aaac13225801258c44f858b4e862a4dbad238906608f168cf1c3375d20a063d4561b578c48a751347f1be5eca95d73c6fe8df0d5526acce3e3eef9e36f7a9b9ba52ddbc897b9331d333c99b2cc5e444aeb9461a937ab749289474aeaf81f9c85281ced5196dced8a06a1f42baaa115e772abad6820e549de9c9842d75aeb8d280a18667f0e1ea03e71fb3e3e4c98d59ea12a1ff99391080bd0847188bc1a41bf63c1c7dd54a168d613cf38f5024a54d7fce5ff5273aed442364b3020c7b3f73e57764d7bc3d56f011f57668bf0b3b6248e982e18399e446a52b0a42e5c157a1b0a128c6204d3c7b9d11b8ceaeaa7a9ddee591280634f7ffb3263b8c8c8ddfc4e8accc5cc73f56f01fe4b9a8e212c08850403545a8a52d2dc7511b14c25aa95add603be0cc0f773ef3668f8edab1babc0639db0e2a70b5a344fd152f9dae72255b594be0df5b0f6a3aa26720e692b2c287a2be0a978e78ab63ea63e81f55cba1880e732b5023be31575bdf251da8c8baae1d5f1348d7ac249e1a72a43af42b2bf1195f1c13ccc09455e8435114e84c5356930138497158585ad2a547cc06bb49143961a390b6f7309af408ca119220025a2df5acb961aad3bc99dbc40dab77a43e6d052162c878110f052a23892553d3b4401e842d95ada955bf242fe8b4cb8e5301b7abdc3ce8eb9ae0045cb190e22037f0d1649e63c70c194a171eca9277cf240fc8af92776b7b34bfa87010c9896bd19b4625af8b381e735c36209d0687ee4c35d376718a93c25badaa4c70a7132b23a9af09ff974c4a2024cdecf502be13a9c33ae40efa43c6631891a434cef05dc435530890a4c0f3b3b5a3648c62aee7bf855320c9ab28a24e474da7ff4e83dbe556e63f29939d88dc015d2074757931685c30e7b085a46a729a53a167ed40aebe690ff3bcc85f479bedef04fe54de142914b5e8a43bfc0a39b35b01e102c2e23145fc8cd5cf8ab13be3711364eb5771e26399e84121d0283a0d750f9c9c943f2c0c5816601bc805a2fad24ee2f3b8a5621f76fdc663700362ff932af59eb14537e1a26071f88c0289fa3f689a93d8248a5841d46d7d36925c731d00273ccb8b61046ba6250e9d305d36ff2d3d5bfde6a610b17fb8a9ea3d70cf060644016405d9c89652da446b094173d1696b5044d513c5669d0fec57dd1f089e6c8abe59aa26a32c3b9f8bda03552688906c60544b5b3a65eabd5087775a4ce64a76fb29395da5ff4c0f2fa72e4d038326b4b2626b9bac7d86d0c13ef80c30ab764f25fb50a47e48863d69aceb8c9517519644e084be0daac75a900dee5bf15e119ef403452218d55bb90731b057f32778f03c229a3883276261d6e6a54ba1c2546292550b5b434f0fada1b740b839fcdce71f68e7003880fedd06c0b0317cbf86bcc0be1628857e439f07cdcbdb1cbbff5fbf237174a264366684441935fb4eb0785e762576f9685675fc6d0471624a533abd2ee19045a3f3b8ce773eb74b728242c93f693528745e27a42c176964cc3aa892d676824c9aae29426a95c9e020c659eda038c49cbbb01b4874191e9dd0bbde3c94633a13d7a56406983c293aa2a17b8c3d25d5ffabef5300a9e26dc8f9d7e85b4be478a90b2b5227d74226f6d1f87d535b5c824354d49deeb452411549c6c5560d9ae0e5a0675d8d8f222d7313ef8af4c6ff4846a42f8d65219144626806a1a9b4a9d75e8684cae87af9c826dc3efc213e97c1bc7caf631f9509a57b4662e17ef8b25c62597160276d7b5449e024c26995509781d67efb330172597a5916879a7be99c95cf940fa8b5673d5b83741778b3ff732217ffbbc56705937ac24804488180b36b1cf1c9d1059009c3e1313b603e5d129bfe78aa8095384dc1858b50c3efab081f7be31d7fc02a2042fb3e67a65f151eb77dae7e89769aa3ad7cccbde7886cd65e8886af367f1907d742d43bf11455d9fa3d244e5c0ecbee03e7957b58f94668b0e6e0c635d5cb9864f3c8f7262f80d95e23e59305e6d039b2bd86bdbb5fd0a808adee1aeb0f5c72c95f436a10d2b49876cfa0d7ffdb46b152d6b145b0f065307304cd1dbd8fc65195e28022a01d0db24386521a933a96188943fd3e8e6e55a98ca711926a5c6caa1026f54a8a7ca622aa4d3bff8cb82e8c2d01face5b8695f1cf5e0eb87c0d38ac73496c68f25f4a0da67037bbf832c2b1af3f5d2b47d30c19df371c110b5074629c645a571ef6c166672c2e82a93ba6e01851378d33361ece56a78894a4bb7f43bfc8fe13686e00b58091635818c2dd2f4d677ebc08e3639926dd67bffe738d8d10a7418e6b910c40b60a2af16d3fae80a0d23cbc64b07fd75ed48d57d14ea23230b6534234543a72d2f8e1a0e6a7c98f7bc7a37c69e3e51025e1b517ced3d0175056aa8471fc1ccc98276ba695f3cbd1244fe885fa9a1c1bb6fa7997a4ce50a87f1e008a21af13055b9187826f1530167428637e32e3c7bf361d93c650551b97b3f9187a8bf486d30c9bff43d8bceaf0b887a0e48b9a656da5f3d22923cec07d1a9ae83d4f9ee1fcb2660acf2d6301ce293c202fc15dffd43b85d511be610e480f254a313d9b2a825165bbce78a308ebfec3d17d69e170295ca463e39e8addc3540209eb6f606cee2ea602fa4b4114465fc570776911399e9451091618d8e9d9425e5cf322d54bece755e326363418072fe50b5e59bf18b8c4b29bfdb1f7e394b5c0c261f08f1373ff18bef51189d7c1b066a343c78f2d426a28c3b5aca12ba72008c38157533b9f1250b65c7b289908733fe482f17dfd2031f91bd967bd9d833b800259ef1aea3abbd9838042764359bf868b2e0c934f107579547bc8cbc288532ead5bb9b5311daa6e37c7c58bb7e3a5bcb932cb5392cbfeec0fb4c675042337e5015bd76297a4cb81ce12d8155140423c2d305befcb0db20130b53b76239395d2924fe2ee4e8e921087f84a7fd36be8e6981a5959f4252ff0a8aa504849a5f207490d0d7e2836ae7ee64049c827ee53daf0694df54ca751e6de2644b81c4c92df76ce611234cd2c000a4eff0254cce144933486a32e851482188e2447ec1954d145193992227f903709dfd229dcd7f19496ad663d1afbeb61c3677819df1b22f9d019d1e9849c31821eb2444abbbaec03b01b97d1909d529550b95e89fe17d81b4ebb7c36c701a5fcca403ffbcc9d2a3b537ee7a2a1341ab6ba643e281b5862ea1494bd9208eaac62b60d4f5d69e4d640546c700d26cae57f544fa78f9f9f4e87b4aca6bde8c8f1b8e776c26e4de7de223bf6f78587f0c235b248abeb67680a285e0e8aecdd1f9662632ba2b9430c1cc7ffaee2bbac5dbb08d65a08ee94412f72e70c3dc95b22af293765f04873a0a0692a94e20b92cd2035bb72d7889295589626afca75e5fde2bc26597c588501ee3c10bfbc4b1b4d6bf07d7bdea771f446e80b0197b72eb832d87a754f4d587599734c6cb0e04c0a2253d1137b175673e732a8cc9902bdce3bf0451228e626c1cff3afe8178f996af08dbc64050cd40ec17f55e44fc3004b3064671be3172c9e881058d632856760756294a740f6a6550ca42436420e61647bd9ba5a981ecd68e01af1a839103c67a417b523e465842ef3f0e400c65af75ceda32f6937ca8ebdc6cc0660ba3218097890064efafeaf3d0024fa8a526e47072d0a547fc22a6908168d95321760b4e080c040571a9c6db68073f73020e1fceee7d31a3ea2c5c1bcfafc9b755ec0f6abade84a9be71326352b5e902600392bcce0ae2375207f658000584f99000f69935e50c3090321f4d74e5060299a5165d5519065e636048f29e558b93c2bb852ec23050503e26bfc7655f83decaaf798bb2aa664a643bb57263887a47c5923f51b976412c74e9719d65b21ba2d268df571b7ec0ae30baa17291cc15bc446e2d82ecbae9eada3086b10e0daba3c219199a3093325a0b4da96f4a94841c4856188973baab28fe8112e46d2a4a8066f9e8c5f652ac9bfe829bc2df163fdc4931f2f8e6f925d1de7260b7a6fc95e10c8673381b20550691d3d7148fd929e513662dba8b4e0e0fdd2f8fd697b30adff73cb791dcdd04d5440002c1510d3047f43edc7f4469802873c6925c7c015510c72c1c0d3fea6f3b4941dbaff3490a5425445ebeae3eba81c9177ef4c180c2835d807b4fcc41c10565c2bbb59e22a7ba4a6816e4955bbeebff8a76082085a79a0b786c882277ff2279b7c6d3fda72f6b94da3a7b80b38e1da57065b42b2029e40115c3e8ab32c1db6d49988d6c279f1954f909fbc05206cf3ea2e940c0c5ce9bfef07beb82e1d76615ab816b8cd722c13274498d7544c812f5923558cfbef493dabc2419bf494a9170ec438ec177f9f77ca28ecb3368443472fdcd967472da5ddc1861d4fbffa9391160f157","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
