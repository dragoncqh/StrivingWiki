<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34384e6ebedf60c7317b09415423b15d54577e25f345842d6cddd8ff153c34d21ec378d4b6746b216235c57c2e5ab5d1d17d8a2c696980cfaca544c131145af8ca1b929130a4769633c01878d2c19264498028b4c2c29369e7033a0b2a20238c146f59f0035985cb8c52721b7339a4a0e3d97871d54bd3b10a4550a916ce25c157b9670936fe59a6e815cbd3078fa6c174db7712c36349d61bcf586d489df2f826bff62f168a4def98f89c01af0d2fb9ac3272071991d474b76b6c6f06a92c7c105e8c30e3114bbd9ed3c6998cdcd778efd3a67fc94d3151b1e612028f33e7956e92ee558c2c97143d661c9e34f4bc4dbe785828cc6f0838e5b9190bee6b1ddb4cccf954a66e20f6899d4d6a40f3c1f53c675429077ce6ebafb85bd724a20fa67ff484feacdcec05462e75f8f32289a32664c48e69293fed4c21707023cee2334779525f765d90d3ab35e89e8ef1c488e186a9ca29202bc45270ba3f9cd2d582104dff41efd10c7b2fb5eccc21d8b6380b2ab9637e8e3cfd4d6e6b26db56e3de2eaaafb5995ff7e77b769cb8474e56f6df4b6a7bacfa90fa61f6988a96ae049256be384a82278fdd748212cdd3e78a3cb96a070809d41521fe1579dbf13db9c95bd917778b717d1b8e9f83defd1dfe12b4157fc19b659716291a400fc7ee1649b7158364ad515fa0cd582e185143aa2bc9867488039d11d3c6ba2b47aaf0dc0f7c4df7c08d4ed20d6ea4caab74403cc2408d2d4b7c85047950c87db7ddab3c95854bc9b16cea297293f489dd5792b0869e76a62ad1a018437dd4d18adbc5e963089c0d6ae3d7177e58578495609f2e75affeb1fa38418310eee1e605c41110fe0bedeeb9f6e515fb28b0049b9687c1d82dfdfd81bd6410a2dfd4bbcc6c803c84e52caa3b2db7a42554aefa49b48de2a4ce60d41ded7fef58dda102ec70c6649e3f9735e872dfba30cb567e8aea3f2e8f405a208b79745757b978ee18299ef1cf376bb4b66a5962d9815988d8b2e1449aecff18e8dd5738f696af62150726bcfbc7f32e9ac0481af8591e57d72eadf973530973fbfe08bd0a56c765f8fec1a906315b8becc9073d81599d918db55d4b1616870df83ab945fb33fbcc9406adefafc759f192df3911c02f23562340d73b84dd43041fbbab0c673eb7a9afed213ae5b2b78af76110b6e4fc4f36ec7683cb2f319ae8fae20af7e15dc2fd189f0879462a9225b4038eeca4f7f3ce611a53e60fd253fb607ba645ab407af73c4af034617ecaecb427545905f769cc66fa4f9aff1308e0f42face9f3af3ba138b4810701931b7f22de4e78619a8c8c07197cc053c98928c7cef4f07ab90961ba82d0ffee2c0bffdd3b44614715caaf54010f3e4fecf5bd26d15930fe2b4b8e87530431b9c91a9b4c0cc96f7124ac7d8d807d021f098ca434a41ad67f6519c700ef3f3b9791bdedd9c6820501405aa881f9fb7519a6c14ee53096869f14dff8cb83e8a2f3cc7705310bf3eabfe282f8bd8761663cb24bbfd0d1251d5d61da01c2679f250f94cd70a8f4ef7922a49423578f5e0743cee27cec84a7ddcec2c9992a9175a53d63842c5d552bf1e0e2bca3ebe9dfbffb0ce88a9472c0be7d3935e2cae2b09e4119ab4c045a6890e4d33d34ded1a7d8e5c18826725c576b0a74936a3d304a4ef98fbb5bdc402ea88d26fe327c43c3cf901271a50864d3e4d3f441d520971ad50a8d0e6cdeb9a9e591e35dace114332fd942be404564308ee94bc5028742168e355c8efdd71f7d3394afbea2c3b936e7b421019b85f677ad03333bbab810c7616172ec971df7d690976deb9f64e6f90100981407922187ced622d7da1440a4189e1313daa149e0083b80c733fad64173db8c2e0bd2db9a1753e215b5af4614282bcd571f70b76615e4fcd91379ff16583e6a29d6eb4c2de08acfafc9f23b52cf19be4b1d545e078d78143aa53b94682ad6a9cda55997c74fe7bb5b917f205058356685bfd0db8061c97034ff193b7ae9849ca0d3a461e04ba95ec9528dc4ec849eabc31ff42b65d0b12d8a6abbf376d82639dbd36c96b27bcfb892b4562593e210820b24e2eb71ea9c444c17aff93f4131a83c47a40de4a4a5b4802e31aa849d1f465330293f28741ea5f846c79435970c943b51b0208fde00505e6ab2cc3c19f0974030e15037debcec0a2e9635b47642161aef6c7d2068ab87c2e30a2e6ca3108ac5223c60189b9eb843c902b45d2c890733444bd11872478123bb75d9c2767a94ace05ab5d0ad79188a4a1286c7fdd2172c826504af9bcd5a82611c5f8a7de19e776732dfeabbe417ee8d7806484da087e4a70d04dd85aa8ed482ea36f075ef50a5eb410087eb933f20c668a520f4979249dc942adc3bee5d4a4064beff0334ecedbaa27a7cfdac6c971414e9e5314fcf450d9356849046b32508ff538e5919c3d0eacccbd32c6b0d09aeddf6be2a0e577691bb5489754c5ea9786b3def2ae84fd085c31d2e9d049518be383c76971b2ad39221562ef62fe202a186f8df96ad35018363812934dc50dba7eb51e23f6ed72b2f9e9e0aa7d97ed34d141fe575397a3a535a001f26367a2704f4e77479f6f0900a7f7672f4228ead7fb33983ad2c127723a9b5e3ec2d533b014ae702367a1841de65586fa847fbc7e467209d8fa5e886954767692c34cca478cd545ac4ac8b39a9882eff6bb412f92dbca59a726799ecb19f06e9910f9994ff5da6be1eabc9ad6fe19dc1821b62a8976b9589d9694541aa3338f4fc3c456cf90c3888186481f6379e2dab5af4b47b7f48346d8392150e92322b908b54703deac74e3325f57f4121f35ccc99ec3b1003dfb8d789dc1810abda6f5c5e3375b7131b95e4d0d6717dbbc4b3f4bf45d5de4fbd40fd53cd2cd458ab32dc5b2e56efdb4c99a839787d8003ee10ebb6b02d5237467fde8f699a48e5e69b8e52439005e4da2a3890fca1ea31acef2f511e25242ddc2d4ceb9349b6842066ec979d58b2010ace7c809113578f98341c1370f4f6109dee20af808c632b8044cb7dc68fdfe6178528b82c6432bc7abe532a96c36bcc6e317b65bd26198b686ff6db0ce481c727de39ee79c292b230034731e3448e50ccc12f5bf5755725a3ac103870d8d44719c3824b730cffacadb0e82a9ac7ba0d4cbfba7b88f77bdde9e38e5940771b889f9fc459433503a16f325c37139727eac21a425a6318a8f97b35a5334806c0cd8b127bd3d48e842b7d9eb3935bb22cf1aeaed2fedbbe0e011d7f2abb0ff8e7742d2b3eff27b014a924b6667df9b5ba3be28ae6ab5a9a8e95f631911e0c3fcd195ad5038a71a92245dcdeace7fd4a48ea926a59ff9d81edba2486b66019c7df3a8ec58c5734d62f289e573d8097460c41981b9f68b0eb459fa8b565ac6c3966060f2764b1138ddd87ae193d3d3d2b9478dc6cd725b476f7f024cba88e5f413d15b26e7b4d96dfa77ad4686473284782c048fb5a57a1b5f7fb65ba1534a6d51879420703bcb155ca564da9abdc5d185dcc8eddae16eef89087a8aea4f4d02ef89f5561010bf4d2a6a12f513d0d1fcfe98b5a6f2d7de7e276ed0aa96c885a1e7a2e4ea069486ea968f182cd4434326e214f2bcae8ad8267b5d900af57cfc9e8697b903c01832b529b1e4a8e5de8be2d33fbda612a27fbbfd2f06a496a934af3d3beec32064d5109088c51494303aad18765bcb6389a4f7d9aea41d48ca25b8be389dc2fd9bc7bd2367c15790d93d69fb0c376b134538f6b6a3a30b1194568de7fe6eddcf68488299a9c30e378daf6731ca2325109b8790772a3ef811f5d08a13a36a717cff38491f6db1c4f0226f11c8f26730f3bbc244a5578c7a0bb8150cc22bfccc5678912a4c73de8e46aebcb92c3777d3efa91562db1d43f915f694cf3afe2c7c60ba89f06c6a1a045d000a04789fddcbf9fc539411de6911bc0601e6e3a44d3c9e3e9de1392e55cf4e9d9aacae7c395498558d0d4909cceafa9551f1d2a5f5518fa55d68190fd849c5837737466ca99bfd753eacab9aeabd7c05264ba20af869aea90595cd69ccaab2c780741cd204c701831b0fb13aa429023ca7ac27917eb8a03d910450604608356724144a0a70f2263377b4412d5ff4007d839f5631912e49c17ec9d89a0b10bba1f723cf3fafe2006b367e01478acffa6637106ddb8fc20a0e8f3c77426f6699b0fdf746fab761c611292a6b99587e23c2664a15d33dab44defb2bab517cf229a488f74626d60c7fec69a54d025f8824054764c93cfb900a9b388954744582e76210645e8e08fd13d1a832bec5c65a6372523e81fadcb674d279be3c36f84dc7cfb4835da87732e430a8a2671de983d743b1079a0a7d11470ac717ef70b579f51c11ad8056f55b7324a7aea74cce8fc3cb01c8bf0f43e7b5a34dd4d475425de927f2037457190d5f1850f86b02acdd9dff2fcbfa9b6fb9a33ab05bda016ebd0639dddc4622cd2876cf5fb17d3450541a736220fb26efa0ac015cfdee9f746e01561e6c73adb4ed42f481dc6ab8069c920dd93258d7d5110e1daf4f71b6815c95a24cbf39684389e07aa0e282ee229bb3303bd091f7979f595e5aab1878a27721fe4b6c2686933b903b60e3f040a137267e81a14069a9dea43a7fb394d2bbd047c71dc055cb0f53cbf3f01b54eefd1c6c1d2cc5f2902b7faf4f2db669517eaa04a61e7289131ac1b2f360ce1189b8e220a4a5918882338742c0339c560216855cd953f8c3048423655240d2697fef357340f4c1d44f496bbdeb5ca9b4bf4a15ffaa0b5879a88c0986787462fbae9b2de37e5edebd0a1214126186948e3120540000499fa09ef2dc91aa794228834fe7266f67f8ab30196bb710c742bcff5b44ee42b0c053174f1f2dadfb4859f397c5b6946453d69695f937f5b7de8378fbd527aa434513baafd895f2f9e590e7048d5bf2f75aaa4f5b9a5d2dbc9686d6fdbe2c952b1aca46c7dfadc8b569aa1a3e1bf5e4249ed45856320804014eaf804c266aa3ed4061622134c97eb4f575a9923fbf3abe765cdc69a6103898456480714afa95286ca3fb8fe41586b15f518a7dd47ecc3697bf44214be6d9d581b04b0484a47a185e330a9099fd580ca89aa8fe1e35fa96e7baf45b9a27e51229eeb29e65fc493349d42265fb6bada693589fb09a60f5cb23e8bc4f40606227c68538ce650cba5b6daf8ec1ba851c3e801aee50c9b2c3847a04237055fae4a3dca70dd852781c468b4faec8fc3946a3197fa5a0233ab90126564c85af248e00248e9c6d17d0b8f498b56153108dbbcee09a18d7aa9fca340720ecda0d7b6bad6f32122589161fd08216138c02ad67b8b9fad15d66098439de3f7caab7e147cce9bae4f9297c2222107da9407c358c7aa63f35f8b16e00c5f1c66a63b1a3a83c40060e1cb9319522305cc4432dacb5824025a3bbca10371016464cb87f6f0e9588c642923a353f8ba8b6f4d91ff0681b28a5a6399ac51434d813359a4b8f6ba65adbdcd878a428c765f688c5ef58d9be9a119eb13ee3b179a503046484db421c8ac2809520c3e66c6492aa14a9a5aab92a644e75aee603c209203c5234db45c5b5cbe868afbd4d2b830b9db6e18fe612d94032f3bb7a9467d893f7382d0b47c3e2e89e7660abfeb602b44b85a79cfbce22fb880a33f1231bf44cba73c766df78154825554f6e628d0b671f13d7cfe075cdc3bbb8adf97b6d04b5992baa0e77ccbc6aefeabfc580030b386a18620b118beb3560224661d99cd6405a867722529b2388fec1a5791ba4273b7251ead83df3f707887ea6004ab7c2fd9203a243d2b26dc71a690ab0f917ece98efe3ee67d9df383f11b2c0b216f4f27c87643a0d726bcffbc5e6504216e62806766604f5045b3f5ad8adeff5d1cfb35bb70f6ebc4bcbab3d92f59229ebcd4a5ba8c25c57fdc52e002691c1db6fab1532d9d62a8c2259bc909787e452ca8a9bf76bf578719bdb724de7f5054f266f6ae935a448cf29c92d345c9e354987cc6bfb4a0e187f54349e9882095f7f6b498825d2621cd4b1f19d1a3f43f811627d11ed136594b711e519048a313391fb33cc245bba0a006ae92b57c38a7d2e8560f9da0dc2716151b8e8a9aaf5bd18e0cbed5802534d1c0f206701b0540a742a775f0ce20fef720e1da8f29a546c6c0bcfb3241220712fae293a03ddbf0a6d871b8bcf2c94aff217ca65358f3e10e4994ac3666aae607225e3b2f000215f20f9a059cff98adb3f8c53ac8d9bdf3d1bda726b9caba5202837905f4fcc114ed020d99836d3e32f80e25b21799a13c271782cd91a168f505c5a5951b6e157c060f587529dbc6815c651fae818b26a0bf3099570b42d97990161a8ea08b88d76203ef37fecd86480bec632a97dc0b49e7c6524e3e70b1f999f6e7c1ec38fc71b4ec4a3f2a58ad04243eeb69f5e549db493fb01adf73f96cf06f248195e3776f82a52282bac31646b9a069eab94b5a5cf06656ab23c2e74f4d98ed1c3d0a9516d39901064bc8ffcaa6a3d321a5c1ed15e7c873d6767b6c8aa7b8339d7ee8485c72aaed5fe9b98394c67bcfeb906e52280f86b8f48d05789e3ffa50dfa23017c3074560686371f6b0ad19d461e65234a59516d04cc73a6f9eb6f2796b260e5ca419d2926ff8e927bd76147c8a6181dc1add5bd493ab13243b8127b4202b014b2356acf972e5a1a5da191142bbcfec23c6bee8ae5713b1db9d72988a52231e63b11559ab18b778a23f04a73790f63a959b35fa507acc390d3528e7add2d1a000291a5151a887aaf7d93a059d9029ed324f05a585ecb6d981bf493c46ae396b4c992764adfaf747585684754b92415db60513da20b0b2a73f05c2992d2b6a3595697db6540a9eda023bd54e0b5f6a6278e288e8acecb125e8510cca106f5b3af2942ad20308c104ed783372970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
