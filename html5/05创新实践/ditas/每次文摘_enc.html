<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a038cd014709a5312dc510eaaffd579d9c5810ceb3103ea8524fbc448b40a4f09cc22b4674f9464b5342359815fb17b7cc0605d3932bdc093430f656b8ec2041862b1e33570422edccb86eaaac33283a56c8fd377adc14324ac43ce836e5110e6b02593deac446abefc88d0fb2d61883b8b37ea51befbfdabdc949af4456557245f942bf774a1ccddb1e7f57c4ad041f63eafe0f453a48fa11aed25137476b5c274511963ed1008163924db492184b07054923047a886e71e8ccfc444d66248c08b34a66196dee24eb85a0efa04c04ffbad3ec3dd75616be0c00eea21ec60ab14285ef0247eb96b90e70f6fec08afc645d5894e67f1123623aad5ef8317ca324a3ce32a65ba9c0cf26024b62aa97b2cc643a6851545aede21579843e3b8f419e71520c417764ea64e28e2e40c284d45f1059530486ced998d2c19a98f756f7a19f81c9e25d1929f31b8e3b81f1bed2dcfde73fca8aa85744db6915a6650f9ec2dd979dfcab018dff6e8ba8e763fae641d78a0ed49beb57fbb0c3f08971162f10d804ebbe839120f658d9445ecae64b02f7e432d09ccfed88abf751505ebde9ed6e155bb6a5707c45a951d7decf1728f88ca24bcd38d836444e9a5f439ce84dfe4d37c5cde567150ed4aa74a9fb79a17f58f78b71ddf8c253742ea5c8e8cbb1f817ab790137b86984d1a9fc5304aba29440f44b22080c1b55c71983d23b5de244af60b59ad1d2ab2f63b317f879c015c3ed2f5f4c3d01f9303879446bf4df2415e9662526dda8351c8fd283366fe5588306062dcef35f4e38a8f007e479379a1541a317757d988206a8f2fdca1971504f8fe6e5a9ce30ef1cb1a21be19803f07f171c186ca99f40b3a4d2007eb90a109c547db4b3cdfbaf2dd4620a7ee856ee700d65c3f9fb11de767212400a69a80466203da627c8fd90b21f58bbbbe718bdcbd00eec2bacd5753cae89974a1045c81b8dc5b64ed619f0d5b15c0f904d4807e47769ae1597c8c53a47e7bd39d918a4a75c821cff82c2ae138263b38e586b9aebe44e4e315723d73683ff52db238e28145a69bbce97fd8a47a81971c20a2a0fb7c17fe0d26cfaa6fe8a21d3c4267b556b838448bf37af870097585c497af2e18d343c449332bed5bd17e35586b9a2f0c13436b8aa566b3dadaae116023ef421e522fc641cb167cac13849d1ac3db8c44b0fa3fff232516c055b5e51f0bf87ec5ed9207e4fbe4d02c1532f6ef7431fb4e7fc252aebb3c7ad7864f4561ca3565a17026b9728b527590c60807b249070e6ccaea010dbefe57cca6eaba0b658db6175156b8fee29fb81c4668f96fe39eff1b98e9a0f118f521b418b62b01df382fbcabf5eaf02bd0394a89b1bb5318879d8337a415a6fe12a6732be227a6d2210038f91ec255c612bdd3088dcd7965669fa16a9f5623d55492f1832ff4743ea4be7dcacdefb5b84b6bae986ef12449a56faaea20c2ecfee3824537602fa2dd3c83c37e7c73835e55b250f45a9985aec3321e40b400aa709c6314e8fbbdaddf25ce2e546ceabda0acd9d7ef60b2507ca5e119b2ff225fc27eb2cbcf8f9242d52394c4356c6ac8dcd240cdad6e0108b5fe6a4035526a83afc2b9b32db58c641bec7a7baef721c55bc171ebfab6bd70ae74f491871ca2a07920b5d9cbd2d742071338b377fdd0453be7579c00f0361a200c87283467ff604e94ab806798c37dcb961687177d4cc0a022ba7dbea92347512f9853b7d3f7517e776952781ac8f193897a0774dcd8b23393f73f2c700b3d9c89078cd285c371539e7e6530fc01757bdc7b6527b1ddcbb4dda7b862b624e07e661b49059162b32d0ed819ec537a8547200f08f2f69c24359d1a12699dadde980836f141d4e5d389efe28134c52cac8e81aec5d93536b4b72a54aeb49d6482ffc06c0496df6ebc9727392f752d348c8edf481bc7f26bf4c52af4a7d52227d24653f4644b90e44a748100aff016e43b66dbdadc69d59d83d498a751507185c7dc60aadd8294e05594b0e888b8bcdf5894116619030b69c49f3cb8eaca11e337c28dbb7255cfed90908bc92eacdba87a72a68f69be4188079f3e5ff642abf6390c7b42035dc61c14a144cb45a89f15f00b9be9d02a47f5988c38b957d7eab500b2ec192fd910d31987d3954440622f18f292e8279feda328037200016c01709de96b93b543365b0b35d4a27bea758148abeda8ed0820fe45c984bc3452c22dc19240b54d22786833ca816f37564cdadfc9a5ae58d955b2d49dd5b1d95bf145932adc745d1ed926cf6531ed300152be21964d494dc0bf6ae802e496569bf3e910232b26b62eafa6863d9ea2210267fe24d37e80bcb72c833c1caab39c8564ffd9b1f064ba6f8671f2637988f973a7cfae4968148014a61029faa7ecfdc0e4fb1c8d3793257206b9728a480e6e7b739add996fbcf647884288615604b6e93d58dd47666fa78ed9702487527ebc23e999b6b695702e396f49a1874a7f82db0979c0192f7a40e748224f4350efd793d7e35bd6159807e7c30029d01d2937c66fd0f0abeb3d90520cd53540e7d0f35554c82e53b710b2c71ea8572f2ed01b003bdfcfeb23ea1fcb3890b69ca2c73a812ec14dfe1b5e94f214f86bf5ea7940390f73b05f546e29c34c309198e4d793a44c4d8c83f8edb2397bbf50308ee72fa2633adccc0b14152671192e3f0beeffb84eb033da299876d093bc9d51a9488311d12869c6753a766cc399ce03cbc508c5fd996569bae5bcdbbf8835285c433591205481b17387b41ce90e6035f6afb423b367fe42a5dc2fa4911a3b5311f0e270246a11b3e4af0ecb5178821667ecebf4db74cb6e5b287cb24cdbdc0d91bba111dbcd84f72de98182c14ed5eccc0ed1a3cb6479eec2b04a56a526d8edc083d6ae2df99a02a26f240f5bbfcb95a2b5d1871baf32d6911d22c37cfa518ab9ad4e82a764863ba5fafc67e785ed040616a9ca822bef0843e02fbc8eb3f7885d0b531d3665c4accb6be7924c36f692db4e34e408e04b807daa255298caeb0c90031a29c77cc68f72aac24e4161e9963fe523fe6f5b7438cbf62aebc0ab0faefb8cc354dc7fa22606382f306ca4ac8ebe197dd74518f06bb968a4050c55b9bd8b75911dbad7826bfc3e63ca192ae3e4dcfe928d308ace10454fd95b0ffc7211ba07379b87bf2982e4b7c808a19b4c80cb043ad9b89dda966589e7ad0d57865d218fc90ffc1d74bb6461d4afaa6562cfd156714e4cde8a49f6442fdd1e78de8d729a36d1d41bc2cf0edb80a9e52ee632e72ca970399caa29a59b7182c5646174cfed475558bbac207b031d39fe94f9772ed61e595e35c7948002010ee1f18fa0bb34bb12d7d22996c3efbfc5a89589b3328b73a76d7791a42f52ad350ffa3d304cd746a0cd5077c790bb6fdaa9c44149de188fafe6629eb32a81f4a6e18f7af7a159478e866102261b9199840c41c11679c0ffe66921c586e8db6af3ef56f3602c3a2e6820dab392593d8aafed3296d1b79d55df91aeb001485bbdaf84e0c6ac6937f9f0d864450b77a1b4c89cf0b0ef8a6b313e3529a9c5ff0b9f9d15427dabb63cd497ff218cda08b75f2a7f9891dd7246a7102a8914ba4a1b8db016043dd210824a5ed1886947a38cf987e142dc9a26be76f9fd2f2390a9ec9d6df3926a4428d2635b4067b5d13160ab161438da8454fab2d069c7c12cc73a551e8b1106a09b853903f831fb3a0de0cfb5f799469b12783228cb4066d8bb7f60c91ee364c1954e355f9a89de076cda049a151dd482cabf6f001f8b88ce8e96cf230801fb70356ab727dbf59ea35a972ef2a34ce767c29027ddde14ef240604934546fda806b7db3e40bb84cec6aca1dd9b4a34b5bede4493e94e59e59f91c521375f0d39c780101a55e83539c422298edfcb72b1e8e7b30a1b97cf94f6752bf540143471792d97ca75e512eaea403b946ec1127f186bda147ea5b34288b2ade117d7fbd49200fac5998c524667cac08f809f7ce6c77baa9cf199a72d01add99d6f7081bd470ca09d7bcedf3fc5e974e6f5ae360ffa38511ee4e214a56bfa07f2d46f190bfb55adf90a46002661139dcef9b9040b87400d4f5ffb7136f31497269f4e97753e0e25d84eb820aa47de415f1fa3e65bab1a342758c25be81dbf9b7f1a9aeb5fbdcce86f5cea001021834812e11fd3ad2da84107bdcc798bb32e9283e83eec4eb0a3a75fe4f4b4e46e6750d2a6b501ead9a599c0e68e299198bb346fed72e6d3c81f7eaaba40dd659cfd7d1d80282385e973b87a7500fc93a152b28d3acf9368b2596fd585281cbc37aeea2609ff6878a4746f02a8f5a99292dde7526fc4d5c41799b3876b68fb5a7d5062fb23a6efb8659fbd1de9bca94ef73264d499b7ef44fa858f001594f8b093b2e4826506abc49aecf28f0113b4c1a1cf951b535af4589fef7dc85eb17d7769c5ca68266f923a543a19cf5d0c755ef68705ab27b0a5fa2b8d9cde1ef044f6c2f66fc5889de91b5fd317df6b83e758ad552c0cfcb7c372fb7e9a19483b3dd79efdb55b0b9e4c14056198bbfbaa70f5dd1111b1cbfafe127e89d8f841de32761e26188bc3276f3a3cfc1309632e3ab496e07b83b4e3db929cb419c5e0e5a42e504a193a8d85deef121f263edc32fde6e2ae9d45d9632d0d516f2b981e3ebec520a26b258d04c13edd329d9a78025e19513e64e1b703dae8fa3b24cb485b1e9cb5a85bedadbce30c71b9926a3a2d01f8622c1e59dfb8962a96cb06ee8f6fd5e8172d38899b49dd30adae4d9fa006de58f58d5b2558969f29ccf3a442c3aecb723cac86af9cd354b6820f928532da28a60fdca23836f31899a03a77ce4af9f6e4a30d1f2ab3ee72edfda0044b3706c6d5a09ee53020652f13f84cfc2c88f743c3045c91ec982ff00b74960d6c4f12c0ea7291c3e0b06cf737259d4ce3cc6b0bdbef8fed0734aa788cad511f0ca6ff93aff57f800b5d84743d0aefbee855086f015e3a1b476e175cec1b1740e60257d040c2a0512001d64d356fa5af4a508421d262181aedf8ca3e853dac4229b6e4f4105c00e1754db00fe0e0d8fb615012988d2de0a6030a92adeec3f3d595312bdf315579e753c7e3a512d0f172ab0358da372c9f1c0386e8bcd41b72f384e8580c2102fbf2488a89aa19096d265d03919052d6a6f7394c91f88631e43f267e6b7117f4f529bec564a3003d0140ab13f49b5016bb674b44a123a37174e84a18c7f19b8c8834d4be60c654aec9bbffef4679f187417f9956a674a5a5b40bb9628a4d1f64dbdc0ddd9222af4929f0070460227be1522e4fb8e30001d5df99dccfd3efb49f6e5ebf4557071a536d2925c59c4d7db7e8d3cf6438cd61c922ae57af190ffee10e7e68daf278c684e53bd35a3527a802df3d178435661cae3f16a1599db36108aa7fa5ecdca20f434f5d577fc8fbb8eb2f576727fdf7a1a5cce17441153ace66afb289b40f2cd511a47c9f00ebc533eab9930290667d0694cf5a5e66e411e75c24b6df91a78b606f6e7e0ca98a4f1352db3eaf927ab3e1b6094c12fc2d0a7ce8e701e6a729e7c286d921383b4509a56d147a668f9dd0075cedfb69c24982df09b196a10e2b6a83162c6e37d4956b594efddba1e7a449296aead5880892136b3d16f4ae3737b415889f08b09516a05ab4779da070e53c8b4aaa4c769fd0a975ee64c0b686286d9c5b437fe666a3533bd64b76b66315e765f333eff0c29db51bd4f91aabbc5a37643a6a2b0a1ce4c83eed33bc78769a42a9d6222bd24132d03cdf6741c107849474fa1bf9113c3031d28fba91d6e939e0ff7929f59dd8267317c6e2289161e617b74454762fc8694bfb2663be3a17296cf8caa68544af9a29efaacb454dc9f88e59037421859ac08a506c7c23d2869f4bdfc6c462e9101eecdffb9e79befa1f55a560a1fd569bcc9433f1f77a6fa9f134b56da7a4905e8bf0077caca2ed18af61690c6281b201a5a135cdc438dcc676aef641f97dcb28ca94ae522573d158aaf7c98f690c78cea18e1dd211df03cb4655044e0b11b31c43051d3b75497832239e3c306bbe54de2506b5dd7e278776a28fba374c701678c0d0757a44c4ef2d83593b87b460047c6400326486df4d06211401910ae6f76212f5427ed6c244ba46a6b8bed06af7f345ab1b249822fac7db2812f2fcf9426801eec2fdd24290a5cf099c9469fd6cbfcafaa1e15bef562d5ab91a62266e1e780c97fa64bfacdbca1a344a273e562e39e7586a91a2dfbaf3b024be7e5c40b68ded95d41e55e699ff2a338896153696c40841280da4bfe21cff44fa6ee232e01f563d9d90472f06b86302aae0a88fd50716e2e5571731fae14cbba2daea7aa14c9e715d0c1a34fb4e7898055715b0c7a5bcfad65fd026c97a5fc2320a94965c9916c2dd6fee52c4d88d4459c482731b1589a06efa18914cf137c44eae482834f08ee31b7b649c138a8ba48e041260333b4a24136330541d87e3f3fe21e5fe04be9ce40adef71ee1f625eafa7b92068194d85f4aeb91c0d28056c9d39fcf47b173d542ea8bdf94955c421034c0a894bbc5cccd0bd3f82c430820af96303eefb0d6a81a1f802ab2062a35dfbaa11dc5321e94121e0145007ba0b6c69e132a05f0eeb908d1b776b14e123dbbb66bea2e2b2d744f70904ca2314db7ef5d4979594ae8924f3f9936fdd30471b49e6b8358bdaaee712d483c260816c8252acab91fc7d1bdee0afd691c86181b0b84c96231327610ff1f8acd4ec79b5f4a97f7ff9be0aadb7ff69c68bc1e78f9f6577d669335a8e6d4f8acdaf506f20b52a33e6031e4709d133c3528505f066003bb59941f0de9eb2cf3a5986307fa3d298922fd50a5f13705c9d23e16d586291af6538f2360b020ab5dff04ebecc35843b4b89d4d4ac3f17348e8f4545162c1675909c30bd8d5f0639d8cdca124c59289ec69f4cdd3138fc7ce9417bcf0447272cbc34d6d209403222e14f6f436d44c8da812b19b6d84052c136de0d3bdae02c69c14092909569d923f7e26b8409079ba7f8d3e77942c6a7bf36f1e2742a68bfd1d4528de333031478b2fe75eeba9e2bfbc01535ec96e27c50b7e304c990ed999399e5a83c052f9406aa855578185b7957c3c986b80bc0e99b3d99bdfb7660f618d3dbe3a18ea0c4f586c339c92039ae16c4f73fb07fb1b8389e12a8650cbc1b6e3828673215e417ad10ef5992d928a9a4df9a905803f31e99958c1a6683c5ed202aa2ce44eb7913ca6d695050a0eba643311663a5851160091258e49cf6dc7642cf3ce374be8f4f6bc103731619cb2535eb3239825dbba59e1de3b841b8a7b6b97a00ab56e0d1fb150448eaec78ccfb05195d0373bbd12b24133b075e329527f429ae960cb71a704e18a7d40d7f3adc042e16b836631c625876d752766116e2b66f439884d691fabe01dc075a833a75769f8becdec2561adfac8a67a19083aeff36315917f589b2ae382978b84eeb2f496cbedc013cd2e320bf3774520365bd0ff3df522d47509b4ee68497e4a006a1b58bdd83d3a439c70c30a5a106c1a8630f36c72cda4eeb8ae8e949a018d925ceb2ca299c6bfc9923df126f58772cb022d43d1cdf4a9ec7ddb181c0404972bc112fc890379f3ab0a899322252a7171a1779519e108757d5824b42762af21af38672e5c0f9839509dc7d7c9ac8878c416f7cade0f6a3fbfbad2abcefdffae605d2cb842c2ff2d51355eef16c6b0ad0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
