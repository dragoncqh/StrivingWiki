<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"416c7eb4489944b779043e13abdb9ee9803fb2bf63961525315dd9d2ca21d5404eb7a2e9c1f0d6628c5337ea06f862717fab9d3d7f1c8ae8c441197d0f87c9c628f396fb1ca2fae5c62cf6123fe8d781040b27d4d11ac7d77c3a9e4655d434e88d174eef5550db571bef9f3c24bff686de7ff6cf0e67a1b46ad9f6e54d5157292e020c6a4150a7ca0997f8eb15692682e99ef32d035824dde6d4f7642ced49b8a229d2e966543af27de378b525cdd25a72e240404b7ff32db688157a8c148384d037edc3cd5b24fbd4e2f8f122dba4eb763f0035f3ce6e726ded342d62ccaf72d82e409bf82207632e160a5214d7b1f98f407a41d07e1262179aa7e7bf440d3557dbd82098f85814388ea6f88f394de6671c497056eb57d03570e9cb3ad2ea357a69e384931fb5accc2fa8ed79c4990b85feeff6e4dc61762472e70f25957bc23bf0b03416accc0fc01b7e31e29816006727351e4ced90042d81b3605f4f8a949d69806dee4e6ec691467ca4b906d8182991c1e96b0b7c160fea67d8f187372e9975e8e5a08a868c5e878d67a72da33faa6519638e6332b5956bdb7cdecfa90c477fa4ee8c97ae5206b2e3c625997cba3098ca2079689bb22d0c52fb193f0033a76bc543d8e95556d809de5d0e4b6fd401b952629f081fa05b3f6f128852cb81e0aaa88f68ecb7bd3e430bb01884bb0a23078cbe9598b8fd68e0eda7c8956b17e2c2f86d7cde9d84111274f2c7468cb30f386a85da1ef012814a60f4347aca3d49a7a69e22d3b0546cdef613a7bf30c25db0ace70eb82abf77b4e354d862ad4d1617c9b91baa0a43a1e837440e2461959cc99da670f6b97764d8f343f1e5f656c72aad52d231b19c62eb4444ceedb82ba48c4389b7c9ccda43f170c04774e77d61753890870c352c00c3d314e80f97b22564fcc97eb277495191295f90ec34c5c8e105ca331f9439780d84bfec4a78d96b404f9cbe16a7396e00bd1380765c8ccc7422788682fe6755c175b62188c118e019f3f5934808345244def64d8b0ab00384f6b416252fd7679689cd0febe4c50a38c93f1583eba4ec8c2cb10521b15c618a83e3e0d9ca0a2666a77075d24c402622748e8d0c9988efd082008f9a8f1f300d1e58905ee438c45ee790660af2a5b0d48645ebc02c5916d8f074ef6c476ebfb758cdaf8ac5dee513c3feef02eccb6466e43dd11b635633b6cae330e5216457a9502050680963e6b0941a79ff40d715c3b7707536c2767f1c4d0d0b9c6d17a14f26a4eaaa6c75c5c4b192aa670008cd5509109ab36167e0ff605ccca3cabf300c85cf31d964586134aeebf0d95763789e8ea9753fb770807bcb0478dcdea499a2c5e587c73fe40c9d0eb68610d442001a4028b58f77301382dc51babff7d8d4d3a6763d8892bd7f05563b2789741190c5cb6797aff1271c6129ba6d071331008146abf00abdd6b6907fa929e8dd2918a546cb3d8c458a9c44e219424817f7f6443d15e480c7d4aa44bead80c2fcd0571267c03e21f69313406587f360ee8d67dc6e4e55597bfea66705d0973f89ae8962d9249438c8ddcb4454579ad19fd32b5d5ccf8e4818a77dc85a740deedc7bff0476fcb90976c2eec551294365d4ffca8c90516e05a52f2778395554b16785549f91b9fd27edbceefdcf13816d1f5e5ff533e441069e4113738318effaadd44b25150636a9a33ee5a3f287ef46c08fd957d2b4b8b05d083da2139137d7f5142fe4328c0d8a07560b5e0a8dc4ac03b377dfb3bcef940580d944f97bbacbb78f01496bc9463cfde0e661fa68de56da77f8c94101e084b6c92c7af6bc783fd807ed6a8ed9cd42274e62d1cd922fcbcf0335cc61dc023eebea02378bd4c82becedd4b64adced9826f63ea0827cebdb4e2c30d8ff2bc62f4e766c1032fda7dd72006d1ca2730275371acbfdebed132fddecc4963b79a3340d2be9ed33cc23b23d3b09dd3e808e1e69f6791d20cf64cc37a70dd4f3a6d74aef5e1be10b339dff8c4d53d391ca72c96e38def9c4e2f77c6523810f59b3cd0875864e3a2edc78079d0800703d0c3ca42532291a6d4cde2198d2e9338cb60aeda9f79197d580aefce20d25f2db5e5895cefa1d5b8b28ac126112d8da0a2aac52570676bbf4cfbb682e17a4f78fd407f61abb5b3124e3eb351f463bd63f36b5957bf4d27daff3dce2f39339fd8cd2d5bf8d2cd90399c5378b0bd74825cb270bb56475e6129d6b7ea6a1f830a28ce0f9d02b7c556e63bf261e4c2a0c7732c1dd05f316b7f4df47cda8dd27ca0edbbb698d5e4f4f579725a46b850ffc8961f5f57a5ecacf4f03daddd7a7b5c84a4e71c2cc44639fde7f1646bd1b6dbd50ed7241546107aa32399aa936da81ea0249adb1488a4c05901871149f7047541c1d81776bdfc9c691abf937ba9eeb6c80fb220cfdecbf9666cb1665d9374d6b868514c095f05c9afff01a8b7f14d3a32efbf5d6f15e376ea3487e693168e4e6247ff1a095b6275a7af9c49ec31b034294ce9107aa9257b7227bbdc623f182caac45f4aa844ed34407493eadca80c514bfc1e87cc1f75d0177e390adfe2a081e37758116e48d77c07fdf85e97f5453406250abbdf7156bb144d4e267e74c73e75264526715cfd202f6233fa0de27f6f733e24cb379715795de76ecc4a1e5dd38e15b2109a32e2a0c4b814cfa5c1f1c357d5eda490bb253b21bc25dc9bdf83142bb4408a5806ef283b41ef4cd56b961a01f86dea07343ce31653e060b166ee5c164c9e30fe2bab6516d071ac753b48d939c9cef5fe65c831701c0442df8fe5aa225cbf256417d628e347c7830c9b3079891ff93fdee9f1d628b22a0345b035e2924f00d200bf64c682225addcebe2e377264907b79b38badbf865261e5184de3bcc4dc667b6437112651811397c08f92353eb48bf885afdc930e103f6f8519a87335bee7adeda253e9c18e472e330618f931e94ebb9066a4104a6e178ca71cc97fdc56a32b2254a947e901ba68a86d9f01088b5f4d5ee2d40a6f3291a7cff6d5ac3e7cf917ed94c02895305f982c8df9056ed1dfe71b607b281537d1dcfcc40ab630ba2a8f3f7e73bde64e814065fbaedb0d8bbed99acc32dd5b9b6a60bf442ce9c712b23804c9e939e19823df9e5ae16f5b180aeeffff30c14c60a498ad264c7c6a676b30dde4279eebcdec1cbfed413cbf80d4dd1f34d29a97d38cdd497bdce670b316fb1d324296141150319daecd5bde304405c97a9e4a4c80153ec2f9bcb6572bc179e9c281dad79431fd708ccd7899b19486b8a7ea06f6fdfcf6858e90e2b1c6a7bdab029ae8a6d30d9146c02bb2f93c365162d52c94b92ac751be5a304769dbbf2a5a5e533b88e961dac8f5ad5f012955f545bac46dd0f753a2a09ec388f6e0c67152095c1b1a30ad2c9864daca60977594d98cd37a0de189ac34c072380f5c141bcc08f9da0463dadbc33a4818a685e1f5c9dedb0ad57d12fd3f1f2c17b23b1aa021645ca5288f94a374bba28d88991eda1691baae20d4f3f927f994a661ab308ea13ed106f6d780a79816519d31e9896bc95600609eeb2776c1521fd164bb87499da74e1cdda452aae8c3fc4d6a28ed7d54b81ab97160ef48b41e9ff941b2b1c5e57ec3d8c0a71a4bcc060e02cb70bd605eb3750ec3fad3bd59dfa1a0d17850a7ea9659a115aacadc98f8b2a0ccdaf5b55b626106012d8a9ea705d7079fa1916bb10c859d133e8d32282cab5e44a21f714b7ef22ad23782ae745ae6ef88a58a331a4dca6659d0f4f63d31656a029b0ff347b67ac197f8cebbf8ca538dd1e20171ecd340defed41314675ec791d6b36746357d35b855f7889d9e81f2b2d2a5c6be9c0fce31f6d7fc0f075f37faac0cfd07b9ced33c398c457a8afee4f81b2b769d8348dbadf2320defe9312fd91dd76e6b535350027dd30e3a91535a3d2f3d3f9ed2a9d3ba83a979c14a2cc8abc7c42e7ffc58725b0a265a966a593cb390e2bf8176a9c09e0d2de8a93f28a4bb7bcaba4f2b368433442c4b6872e462a5890dfd239fcae83928c8fc731f91c953c70a33d1e826ba96ccd2d9454d97b17401b91cd3f741d9ca5cd5f5348da9e308fe2f4b7b10aa666ca0b68d43614a1a9d3d0557b61294289938c9d6f075a57c53b97e8bce7a0e0a2f4a27c0c4e61bf990e969f340274f667e1615ba4d1a03ad934f3507b6338148b00e0f87a4d53096c1baacde5399c334c9d550138f859de10179a848d3ebc1332bb4c409babd4f16e7e6cb98c893370b49778bf6392bd36cda84ff700f33ed01f19bc3408d4dd6eccc976c51d9f8a965428a79e8c5f402a1e2052e9e341ef719c323a079fa8c83b549f69f84873b0df2fbab88bde82c802c5161ab7ea0c7af63becb189e9768f09645b3f6a1b93906afbb36cac705bdb0f9e8be125bed35c5abc20a2dfcc22fa0b3eda6b359e9224a37d795a24c2a8bb50639b8f61ff5f4d57bc372f0ca87c314d250916a7cd2b24799c98798e70e601019225176cb75507c21db489a82609d63cc0748aaa51c57111274417dd3eb766592487cb5bda5ea82189f6c3d528c3c80c5028d66a3e75719b9e1a4847d9b62a52ed8939eb51cb6e0f605aaf1df6fa5dd575d0a1edfb3073dd27ce0e12db79e82610c9c2ffd86fb162de4e373e0c81d27dccf79dfe18e941eafaba9621bd591e7bb5c184d0eced4d3ce24dbcaef19a8c19533b39dfe2ee467e3a8130922dd2bd60ac88a03f7935522392698bd8d37082bc806d1ceedefe49addae97d63ed9ce10f953be6f8472954426a1011c4ff696e5eadc7839ed5326f66ef7735a2d48e9d844d7456b135d8bbd62fcfdcac76232529507dfaf0e11d95443e62046cbf9fab63334c51bf15e54fa9a7843286d4286a92b4494405990e8f6e25814949bfb5464603f1bd67018753ebce312feb37c0094602bdaebcead324104d7ac5fe54e3b80e2e617bbe7180a42c015bdcb2a949ff923d1ccb22f545b384b934ca56eb41ce7a6ed3601c4fa15e78651ce63b8af9fba52fbd0111f06c53b71fccb81438ec47b1d8ebb252df98f16102e1a104459c2fa4c022efa59478bb93a75f68cce3fbc5bef631b3b1ed9c3ee2afe8f8e2c9e47024517ce7d695993e2c82a832652cb3830420e3f42d6d65f2fead8b1400ac0aea0b3de7e1c798989e4acdd4bdc139d875049150a8f353f0bb5c9b5bb5c052e64d732043f771c4d046a46ebf37c99b6919ab31b00818e5b84258b9539110fe567f9f410d8cdb33a9da50ac14f5d28f31dd78cfc3c78aede979a0d9713e15d3d3c6ceef968a44cbb6de6e2b398ce5bc4072a9fd575a80b46463d5248bdf5ae10ea9e58f663bd0d6ad77210965e774290cf21ee6cffaad0f1113c8c30556900dddc0b51233bb3933801b6c6001dac87d36411516194cf0e12c32d02b70d492e8db641325c0e3fb72cf345381044178d36c7b5443c7e113a7ea64c7c95fee0ead7f5a7ea51effcce56597fcf63221b423039f17b1448322cbd95409d7db90e160b423d2f28a87e10650e652c981ce670accc1b983ad584916b96cf646421644665481cb5b5a1abee8b3a708855c3812f2255a26a2a00f17c9fe3aa2145fbc01b0a01aa1e50365d8ab1c375d0ae452ccdb0859fef39ec52826b8a37f05d252dd5932869e72beed92d9bf060f3b4b436f5a433b831612f89dd3671eff9f4a42e5f234225ab1fb7f5ff64b388be66778c4c58aad5e6b4a62078bf6f6c0ca37c5e30418dda789c6e21b9e2d7cd0b4cd70736da8f7d16357d4384e4bd6575efb5a14fdbcfc511befae1accfd3b953acfbfdb1fa41d341baeac768911bc977dc7d35e7d1e366cf79ae3c50ddad9cb77edbe1927ca7660bb6779007d56bf5180c1138c1353c379affbe4bee3f015b6090c34e303df99209cd85db6cad6dd02e9c2089e0cde2213ec6220ebeeae10f55cbcfe0196a5fc0e60ea259b05789b51fa16ade04cf5f8bd85af81ab516823148ee47cca442de3d3767f5dc45a3e4d3d319dbf662d760d653f15d6482504fb224b32b18a583ba01800b564922905a201201e08a569f0d7e630f3edb5146838e9f212a18b755031bc462ea828749a184a3ed8a4d55e0d6f80466bcbef224bcaf85d0506b7723fd4cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
