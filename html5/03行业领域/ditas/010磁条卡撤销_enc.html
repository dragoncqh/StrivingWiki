<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1714e1bb84cc23cc36ca714adc2a6a42292c0ccf56cf176581ee36146e1520bb0bf563ee822835486292d0f3d4da0c797492ebff22a89bdbd8c58a987730e45ee7f47331253859e377f805a7dd2ecf58fb7b6d63cf71d181befede58fa2e4d4c857260122d7739345a64ca75a8ea7aa713ab28a30bd66e146b4cf9fdecb427d4dbcffa50c9b924c5a787697cce7d260672145096178016b344019325e96be2ff2a828cf01d588d61a978e6156489a7e1dd8e4fc9012f33e6d29b9cc1343a43e428a04c7f2fe8d2322f9c2d8a551d67606371d92e99f1032c565a050079cc5484ee24ac58d25040ee662d498e3bf6bfcebfa0e707f31433fed564613e590cfb181c50834d4125f8d1147353b3eaefca0ee0d4277191e21fafc0790cada3746517eefbbbbcbdcc734f6d7cfca105566b51e6ed7c077332b7d419e97e0f984233f56332fcd06dc640f5a60f5abb00d2e991a6f101ba5b07daf94535efec6b89ea269aae8c8f7695d7db13bd7d11bf53b0bfe298671086d224416d9a8f5a880dd0f991e7e81b1991632f9db2472f1bacc6a96bc61383881211b0eb0a027d3df91f1da427fec8d6d665686356c5e684d9fa720987c525295435114539827335f4ccb81d7d60aa3d72da383fef889d9321b580ab3ca5d283c420a7c5aba1bc015eed648cf9660ae9c98dc14d93cc12f4e9a3df4a3d8bde0fd63e33927441c2a451367096447e9780fd8cb9a8059a8fa8c58151576c393870171ec0549a0348a2eb605c239da0a94501e726d775f77ddbff43d2e5a1d71f94672db38dbbe916d81cfa5c85eb67915696b66c28353d66209834a2368dda96dbba67f4a490ffe0aa1ae62b50a0eb7fa142cf34a7b6a9225015e3f12cc024f1fcc7656151333c9f74d511aa563f14971a7dae377307ab9c9ef3cdc6c2b8d563257fc3e97ff76933db581ca8b65992ea1542e341a4ffa15ac89cd5862a4f22cce42a2705efad3c840408ca3667d9dd7b0a6ffc03322be70ae1be8bbe89d51f2babe1d8d43a79338c5b05a6f86e8d871b882e9ac3724775798945593c1005c4701d053fb427d9166668895512958e64e7fb48a4d79a5599a15e6ae839e9df0ca0de793808f6964e6bf472ef7f3fbfb1eea0ad7366a49c6a35558d0b1251f91c87ef3c7d6cc30b3860d94e42c2b55d9290d6cc3fd42874521bf327b03b0bd802ae7b6aae7d994bc2241e8170bea4b51668528476a7c3a88f180c5793df81022bd9a37c0d36b6bd7ec191eaf9b6d42711f17db24ddf0749cef3ee84927e59e4706143f6bdf4a9174c31b9baea9b76aebb85f95cf3d82fb64148098b86a0782a2d73fa4093242858cee407ec36eb63428c1b63401af7df5361eaf3cdfe66450cc8de2894028199f15e6679cd26c7c17d3ba242f111a174928d3812873e235c3ea873ab999f95b8be45de975d5b10e7dd667e894c1e37730c26136256c959498301b0604aba5046f40bc9e8ebc8b8cf106aba7515f998d1de2ddb8106093fb4bd3203ccc747ca90d977503c62bb4c1e5909b8580f68d6a69f6cc3188dfa4070856ef17452c87c7ba31b732fba3761bf5bc847a30481c3386337c06dac2acc36c78530ca0eac7631453228f20f07839883360d18137f855015c164c12f6666f475ed3bf690d0fca6c7e73d90fe2ddc041a48356f5686b79c972033ad5f4457c31b07c02041a79026dd76cead0db9923f6766fd6dd51b8329a2734160cde3a5f93befc7f4f85ec22979ba50c260735c937cb41154d1866aa7da575942460546c76e834c6d329ffb56ebf95d31af3d33d0aa90d66caa8878c1d2ac6dce08c442fa3ad8191ffb885bace0600c240a57b17466bef64b1dd4e2d85f3e2e11a2f5a0fe640284c6c2a941eca646c284cca8cc7cca774879b4d1a6f74edbe09325940a69d0c2b0e0f74b32fdae326460adf8fcecd25a7198e5a8b708168da03a1fe014e3d6360149d79a636a56a11cf50d2f4630758a2c3f32b1e95f8c371ddcd7057a1fd25e8cc88faaff0fa008858fb6af2de98166540a4409fd377c68c024281dbab4e21533305c5d36ac80e7fdea2f4bf481d33c9f8aa5da67d12f9470174f2f637bb87786d62cdf9e6220ff430324fcd42eb4e8d9bcb38a281a72a9c535a3236f772c9e0c4ddcb49f6c10a421f26c64ade14c544a56a045b8cea2e4d9b688767fb0cd97f60de8dc0bfb070639a94529b84d3d55ba57385d0cb1b324ab4b7e187b4192baea9eef96e8e5b998f7517f3ea3634df2f93eea5503bd321f804f98d01991a5730e7da583c2cba079b9feac9b581adc2d108bb3d0ea571721bef603eb6c0bcde9afbdc4bb277feb61e9c281251bc9dda73a6a9fda207c65a0e1e7a0051e08df94312f5596159d09e0e0c0c293ab212c1c5848f2246edbd79f41ad46b80fc986d3c366f73d81225ee5591e751654c765c23266d042553cb6bb2a3f09326da2237d519295a9a250b84a1f91b589dbd81fbb785bef74999f0c4c7003e87aa2fc7e2685406c8014f3d3dcb2e5e6534c958b8df985051fd4ae2ff497984b60061a2b354cc85e9de9c6e74628af993b4d745e765bc6de45abb6cdb6d577eff58f71b6b6a56b069d62ca7bb670c366c0cdede59deb5de2a2fe76be64f6d815b3fcfdc0a865d38a473c860f7a481e6126d9fffd5051c892d54a6d646eb49871bdedd16fe9a5649288814ed0fc076bd7aaab8235d944b1cb43ff4311cd0f0a650bb0aa5ba4ea0a66819229a8468a0270ee6efc54aaa172024ef7e11d401d8392ad7d573e96843806611e4e5ab2a58b88be2fce1a971b9bc2f17a06e0ce6d023176a01ecd2454bd6aef3d181789c99fb162fc807bfe60416673c83bbfb64af0f070ac7e91eee135da9059858cba361f4978589dd4b91c0ea43d7a3a17c8dabc39878e60380a2f37d89e392b6e34e4aec68db17ef53d12f8992c15ba08dbd2f720cfc1dfa21350fbf723d889c953c3ab0bcdaec6411a5646eb05ed4a1c9ee1b6e29513ea914af0fec8155a3197cce2f7f4b71aa5c1225d9e4ea2676e2ae4696e394d7ba5d562ac8b12391a11bb32be663a7011eff4b3c3397a91f2b6c428a33ca1bc5aaa8fd76ffd46d829f01eb050012de38a1c2746daf8365b97b8ad88c838f98a95520af29212f76801017be5200942f828b2614a167690ba77fbd3d2c33eb495e6c7e2085d3a02bb684c0f0fa8536b9e36c344ad6a374a2c39daabd84905fc5049b016902b2e9465ae85c75e6e6f847b3f5218fa8e6fe8e7b78acd37f91554880a8147a627d7ce055828921733f397f5b45c51eb308eeebb0a8abb870d9b07880808196c0c063070eacf4203f67747faaccb7fcec92cf027343616cb434ea4e3d36e630a826fb8e4c9ea2018a7f8f71ae91ee895950b0d5649be1c7e3c1408f95d62ea2f54616a9c732d5ebbdbe24b4e0926a6a5da25c1faecd61b3feb46cc54db082d8163019e1bc5228ac7463412a94efc4db73888dcfd3ca34ba81aa0a51ade53f19df137736efc4283c76f3e5e156187667bda1fcbc6618954aad3face36db1a680121403ceb12b1e78d27c1f28aa8e7286c33738b76e7f952325df3494c457a72211dbc3084abec5043dbfb970716a3ce1b4b6c7d7677338a39f2549ba011a547c9f95d87fd174b220513651d80daf56ffef423169eeecd735c8388ab271e740f105b744dcd057a7794c07f4c1905995cf8b775ca780abce5e4bd573128ea8878863e2919aba921c6705f867e42f823e76b5d444a106842fc8a0ea950f19deba80675b62d7de055edc729990f18ed423f0386411492446aef1c7648ab5a6e06d461e3dda5e1d90c9a49a5755c698c8b75f92a53316ed28dbb387e912d3f180a9224e0deb61ac75bae4e69bd788d9e473addda78c8ee8e73a64b06bd603912865396ba87167ffcd78d2f8db0935dbcbc309eba6986784e931fd1b39b63b546530f11e91e35732c978462c8281579333d35e785c2ddaf5974d3aa5b099ec725525c650232aa136395aab0deab44842e8162cd1bdcea030e980aa5aea75d3939a8a6fe2232f66e9df1efb2bd9ba2e004554446eb84321eaf873aefe3567770f10f95ffee043f82e8626193a252c2913daf26b9ce3b4eb8dc1bccaed9be5c3e8b1b95ff1dd693942e282a6e6affa4bead4d3a867cde2a6fb72d1f01ea8044dc5061ec34d00727000897886c04820bdee1e00a3ba0621b1b19c15bba9cb40bc1b6f7ac5629769bdfee1f1e35583f7c57d7c5597b23d1ee234cccfd4c2c2ba36881b1d3b32df55580a957796e7208e0f141bb189c5902bbc5b543c263ef38587748faeb5a255c115bac7d09f9cbdf3d5b9a0a69f82efddc5b48d1632dfd307821a95544c91e37f7ba8fdcf8161dc829fe5d9bffa24089a03bd129ef71b04af413010010387b74c1ce5afde81ad01ad997e818cc0a1decdf884f4cd88919c5e86c6dadd89e1ec78ee4d3733574e39c4dc032032d66151264a61615297fa9e5d6346f22579b447570bbfc71e455331267d23ab47bafd0a7c3cdcbe0b322a403331af242114c4aac008451676941c8f3da00a14795c6ae783cd9a556561171354306f219915a88e6e69a576f25928052174fa575e3e443dd607d1952163a8c186245aeda89bab197903de93b3341a891a5886a205524fd79fa6948ac07da64bb1a2345ac2e590e1759d4d650c87971e13f328cb5a12ea58139a80a654f1f21b3cfa0689faabc3560d5dc77a93e87d776f15dab4bbe3f352312c788265328a49be90458630f30e5fcfbe4727cfeda9b8a68963302ffd36c4b4aae927e013ecd1a9f32b40fbc64807a6fc97fff1b0b0b9f00070552da9f5e5e45131819880b0122873d32f63ae73f7b1dbd8ffebf9be023607b0ad33b6d67fd705ca16414256cb506c49a62bcf0337df8a7dd411929c96c0a85363a043173bde81731f5fa380bea6fd3ff5be417526bfdd1d46cc4bc048a438df23ece1edb0031028080f29617b276ac13487c6850e681a28368d1ff712a25d1838390da08ea289e671c5b2a266ea17e897cc07cc221d0760927f521aecffb9f55a09771f2126842c4ff9473c647065ffe76e5fb6198563d8cbfc6a347c58969870ac41763cb853bda96b67d4211781fa0abdaf970e2e907eccd9cf6c67ffd285a1fc6db3adb824b5a32635f676d57a6dd967cad50f3f84881dbe535a9097ec3478a667eddb634d83eac599527d5c4210f112e7913036469eeed26e3c19551b77f35e614c58a5443f5310b6ab9b186165edf9af28ec3c2e2e3adeef34f0c958d43bbba09968e3821309744cae2fcf897949fe8ff1c10659cbee5ce92aafe76b5ad793dbe45d55e31be98890c1deac6199a44375cffe038e1c74f9d0bd343426ba60acd9600a9cb1e18cd0a9433ad84b23d26fac61361a782b831edaa8f739e57ea762ff689ea8afbf57bb65f72df31557855608a5f9a53795c5cd21f853ba928047dd9fce7db44bd2365c742f35c059308b1b11ace07f57615306347d4677f02af3d060285c257ebc44550ea68ab28a8adab25e89a99611af2c41d3679ce677e0e983dd8987ad8bcfd70bb8637362d493852ab08683a53c5abbe6e83a21b312c6909fbd7287b8078cd16cbc9879aaff433434f819bf5a46501bc62a4da2942bf95ca059d1a36ea2f22cb2877830ebbb4a3df27c3a0318bd07817863842b4ff50c0e17de6d0cb1cb8d8d14d1bf4323336d3214912fcacc8be1a7261700d838b456bef0bfb3607bf308ab66b743851807f516d23b6fbac2a37dfe43ea1b460ef1446945bff7a1d0a7f1130207217359c7e2048b02b3dcccd211df64dadf5485b3329f538de2a4e2339eac4b5012e463f7b90468d8283681a536c2215db100eb0e42254ff9b5e047a4287cf5e3741ccacc1705c62f41ce79045af87df737725fbfc041c49ec25fa308dbf712f46ec94fdb3d98a2115991402327f79973d24d98f4264699379d26cb21a5cafd4ea402878d3a65d9d6a64cc3526eb34b63909e1c73864035ec5907f6ef36a8e7e0685fff4716ee44997280fe6b7998af7bfad1509bf80b50e32f9d184db23f20a6f57775853fd8a065ae89fb98bb4a774334775dda641d05c7ba49e9b1c348b1d2762063dd63533e60b5c6792894e317bab01416cb116c5585d9449b315c5e00f53dce6df91aeef50b0dcb10aa3235146e689ba17fd07dc51da0aecf0003f1b662a88f9d39776a4ebe57c9254980c00b931ce4b12cc24b7528194a95123940dded4e7ecb082e0239b9b9c71fd289f58c571a58e13f094e2e1f812712793021e249b5092e1706cc30716e924227949adbaa09d04ae212ecb4ccf012bf43e67b0a8bdeea95c981590dd49d22e4e86460330623a200a497d729a1fae510d17673e96b5b24564c3098d882d022c1ef188a64391c0fa238a67c71d3bb2f16d0d004cab650d233ea58d158dea46be4f2a485e0d81959bce2825a1c0a5da737dc8ea53ae224088e6d3da9204dc48c951c4bf211e71a30616fa3bb6367095e78aefd267ba13374746e661a6c7d382718482981b87d6378c54a82efd23ff92522ab6ab5282ff52b4486e40e7951b8521aa2acbf2b796ab846667841211d3c3b504168593e06037dc734f6c1438447e2fcb15c828d73e021f816885fc3bb7e45792562bc5fa93fc6b7fcde5ba8590a18cc71e2cb70a41da0a93eb3a3c64a8084a5936d96c2eb5d3490b5dcce63c3086dffa70722a8a77cb919170f17574221987b42e4e1c9d5ae3694de0c294383d609d686fa74cefc9a93d11e1f0c0320cf093b3fce9d4ba28c2732ddde1710d1c64cc69ffd50ce1d692bf7597c146c8ddc8cae40e4c4208735d9207610e7e83bc0eccb4524493a3f25276b75f46ce581fe0f4c79e9679dcb36f2651be7695488d070c0c73aab598249dfa8dc6bdd5558a82a580e0dfc887d976329f4c724721d5e4863386b6d140e30264f90ac46cc76580c25b3e152575d780f98232f166202b731de38a32e9bfc17f769928b63130ec95c026b1b9dc96c8fc6428940e0726e79a85f669df663b4c2ebf7fb84526b0b28f5cd97105ed255f9ec1af74b5331514c39758e3801a0bb544175e78212ecaa1b9cb09766456682e585cb3715cf15a3ca1e5f4696bf87605c4c5093d15f6f5c3d12467ebd568420459356bc5e64e47694d808099da6b88bda25e34b0463e760ee83e458c883d7add57036dd18f9702d6e35a0195e918fd4566e892275b8cf69d943b49202dd3d80c54b31a2c2b2ff8861501a09745c367d65afc7ae12483784beffec12e8a2f48d20b4d3403625c6dcfcefa54c540aefb0576f11a982f40d6da7f1c985775d2b1ccef39ac12e8ccd6bd449877a95d7f9f751d4965541882fdfdf7c8a49d4f7a0543f476233cd1059ca0bb7743e0e23943cbf2e2ef5d89b0c41ec612033ebc3df4cf6206b34f404fdad0396e0231f904377d3000c2e839042a4941ae15560172e9ccea91f70a48a9fb0e48b589e708856bfdbfb9da21e3e393da222357f1b1062742a6d775d96fc1a72794c3c284f6126ab55b12495164997a465fb77a7c38a0788b875abbca4b0e6c31b73bc6881d28041e1ff035069d240940bcdf2504cc3e6bc48da05c192da4490620aec163e997b392282f0837d35da5c2f812f106994e392180d2d065befe8cd900993637949fe23f35be59dc210bae7c64522091be66bd9810daa3e44f5c0081532b8ac10654ca2b4db7dce7d96cc3704392483847e7348d182fde12b6fad6ed0c5df17dbd5e3a4bd3bbad1ffb8dcc940d93fbe2594d664928d62d407b9ffc61b8ccbc41c402650b0936b945f615024e4dbeb544a26ae421a1237d339a649f8ad5fa7109f427ea6201110dd33bad915c5ed20f8a2b358b1ac6364530d09ad48102fca7ed7375cc9b5aeab5f0f22d0b63385c2061b562fe5810af8909dea8cff31ce4b577c1e115aa62d7401f42e10b41936c6e2d09b204fbb290bfe1f333875fe34fad8133f53f5d37ccbc6ed3368cd5c5d280cf0539280805d45819c117fd3b6fada826fd8d664d190fb96d3ad69c907d7e54003d1095788693e8ccf1cf04ff03e2e77d0681611261a57e801e4acb84d1ec7fca84a3e9d3be8caa792c68395fafb4d533e5d0f96cdf1e8b07bc13c155b22c6a453e58a41fc85654636681b50bee332b0dce600e097e04d3da05c45cc6924fa5d3fa8ef86ab3a7ce1c78340c0d121a182cd3c99ed8cc8fd6ddee9a8f9dd0dce63c4a9375db864085fce04387bc74747886056cbd8162d53df93d067cdf970743d5c52ec2add37e81bd4e2f04e779bf98f61b0e5edb43d90157dfad895a00bafb840f090006727c1899d35467b414260c93eb50c433516efcf0ee90262dca9f73009588cff0cef246f47c545b09e7ca47ff105323e0370d0182a2fd8169a1bcede4667cebd81ad0d762f473cccc83258bebc67e05272ddfb8895368196958a857b34d56228a6b6cad9ec496261d09662db91324c1c7aa55958faf064aa7467361538c2e93249999076b276bb6522b87d299e39dea84ed2599032aa88de88ac08cc5a8d629520065099e59959e218d2861e5d71ba058a5bbc7d637ee87811833120a5f6a718dac7438913444bbda652d5062bbf7ff91e429d50864418997c28758191f7728ca8d3de0b498be6e9dae2c6926535d6a1e00ecf5dad78dae639ad5949d54f40f5bd0fd7875ad7d446bae326fec9169a3e2d7d3cc6451032fb2c3e91a4939024db35d17fac9aeda7b82b94ee8cb2ffd9b340510d28c9b07ca9de54c3f82257b61426b688b85f69b7d9a01911c07e52de89b7e7aaf9cee344fb3c9d785e9810b2570424dcf509abeac5efd736fa2469cea6f1d02aeb638b2cb50316b07420d32ea52dfed02953dec58ddd13d2a593eeb4035d5d52f28ef6a513a6f5ffeab6d4ec3b32cb16704bbd52d1b682ae0de12d3721c45daea036bf6eab9ca55c68fdcd396bddf60f6dee41293c6b1125e3fcfe280c5d7fed5c9605f15f0671ccf17bb73bb9a15d3687b12e5c0ff3ff53455b14cf78a31e3c9798b3d48d2b7a31411e2dfa713a4e8994abd320277baf5a848dc7d6a6c59ebda022edf8234371cf704e7587b4c59bc7803a484f3b311b3cfb593a649193e3043e5a760ec52d980587aae4c3e8ec86d914433b925e3108f205a4ac582eea4db3b8ff257c387b28165058ad4ce345159d6811a7a0e52c43b03b9f1ccc81b56b373637a99be624f1548c15f5911ed6d7f45924eeb363bf86dd3e2db5066afbaa07f52fa679e65c48b16952736f8a14da7e20d482e1321e8a7cda1fc28cb31c3bafea44c1f6ee634c5b2fb98a42b5f95555d7da67b7564bbea72355611243a6d1d8ea44560076e510c4f284f8dc99b422e4dd2192232b40df429b176a434d527f62320d69f2ddd91e1cba9b02ab91e5b79fafe3ae7b3870fde1c0dd43ce28d5c6495cfae627fcee564337bb7705467bd67e69263afc8a9413250a0412e5835f5520e6526d7a1d5d9e3239cb7d4b80093c60eb8a17be032db31386415996fc355815daaad1971ce59f95f1029e76c6eb61a2031a2a3f6622b34f7ab21094d166b801fa391f3643a808af85e0ffec6a9ef8408c6504d4bd649010736b86eb24d0509257a61d4e840fd068f47dfda04f650d2cc05798a044d545e99459b3abff46355e1e975f1950338c3b73fe0fda1bd97c5ec2cd1dc6f5dc6962e01452a9b9aca0054d19744e549fdc32b6f771fc61fc61d59b4f24014fd5bf87845b7ad2a852461b00f636a202485a0303a17056cc8e25d14969e5adbe191c3dafdfbf0b007ad611216e3121ac446d71b0d75647505dd4e6c9931638d888796d26f4ddf5553d1f8817f13739c2430a125255eef1e90a4c90b1a45fea38e5752e10167e1914fec594dd37a47f3b3eaf92c3541457d4d926863d06370cfa5e0305186d170e7c39d16ee5ad647d14fbb38d401f5851af72e7c2239353a1196e8bff20abeef20db61fe91c9c066f817eee7a27ba875e8b109ef890a8f5de561882e860b293965f4f0d0836c3eaea1becef39bae830bc253b048a49fc3411b2e61866edce20a57e1321510d9e6d1d836abccd37774fff6aed894d5fc3a5cb0aacabb210d56f39c14cc74fdf582abf384cc0e3380d028640afbbce5230d2fe4b985164623cbada7de061d97945d9b8503d91c0801276116761c64b378fe51ffbf83ed6d64ef89cbc38a92a3d26c14ec96791ddb982e621d3206df51b85fb569ddc0fa6eb962acff6cca04c9581e9f1137cfca9e33a1976725afaaf69c5dfcf7b6118acb7d31231971d2537e2b6c424c685252037213d1f7b61c73360bbca8e1063304773157a2b1728b72262f15ff63620fce071846f0b6a9dad7a2e7443ccd01073efaa5019af1c11eab3a16b00d30c286815862db5c2f13cec55bf2d0470be2b0ac854dc02446974441d7903","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
