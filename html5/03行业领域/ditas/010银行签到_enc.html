<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d1aaf72f1c3804f6f69da927f17aff02da7e3f4aeee28c6cb42a9dae5f180432a2e601e636827b4793c55d980c38ea73f0de55232b58e838186285a80a30b6018cba651af30f12ed62bab5556f47c12306ac18eab3a988f3a39a678e59606f78ca95e988b92099862de9554e5470b6e7b18c32575b4f5788af62f58de20bced8f2d9488d313170f9adb1b3a695f879e9367b3b705ce6ac25fa065fc5e1ac7213ba72859cd9e1cc92412beb1de99bb7f185b76df1d8a3b02c425367d04311b1b579663e43f8d8e0323f271c20f3451039ef49a8c7cdb9a00ad3cb97c68dff4228cf35d87a8c76d261b86bfd3541e90cee61c391015857b5fc5c3726262183d1d41ce565f812429679832c1bc69e6c7b90c8d2e8bf6f9cd04a07ee19fb35e81ec98a6ea3d3f4eeae33426514ff0371c87125371a6c4d70752e056cb3a7ac21cc343bd669f0cfa2be0b2847e3c1f1f8cefe1110a27a747f0b24aba9c1411e22379a90bbdd040ea52a55c19e1b6040ec8c88318b00323c6c0827e65c2b5b9055ba459e968efe4a9a7ddfda96165a5461ae9586a7c141be819f09ae464b65192cd28f89a1c887c16e13af835522be61f80fed1c7e9623c8cf5799bb8dada87ac731c2c5fd17e1fd4ab0cfbcd17147b87dfec451a1e80cbf00e710f046ede861f310753fc808c773d5d751bfac3d8b1e9f055d089f20948d0d4ba6103240edbc55c2836642447dbebd45ad22d5daa6d28bdbfca6b319c8231f84f3d6c07ca69afa852fbf59ee0d2d5aec8e218809993c21f80c5f8b3582c3b3b9a99b53b5ec0b74be7e00af295f04594e8f8640322a4e355bae4fcd79a1930ad79022ac2d726aaf8cf150dad10a750bc70f619e0a87f43cc57c12bc9e724e460d1bd8313764dbf7eeddf8bce0bbfa1bd3ac13e0cf3067ede5eb4c7a242bc3acbda3939526f46ac07b4087a2b1b5aff3d545450400861585cecf83d5440749fa1804375b21b833858f1bca06ba480f234019a96054063e8df2953ed7135d40b831d596ef4b6c27df7c5beb2282191a74d390020c2f05a05bba5f064b0de645643b1d6156e21c7b2decfd68d6454e5fd8e499532be60d5371178bba25af20e6a7bbb1532a80ca5f6d7876e2a6143b4512d369a6542e5aea956023ae3168a9bc032ee45696455786d8ec71a1995cad7a22437c74c91ea11601c5101d6ceb39208361eb4e4c69d15302d19511b9ae6815a3ace61a8270dc2c2434df6fc661064d5ee41b3c0d4cd89813469a12fddaa83e65c0aebe2e5bb208f66f9d2bac33e69b6ba601294ae96b4c7c075e537d8c7e7a0fe0bd830a930f22cab6b3b5c00b590dc03fba575fb9f4dc60c88eba200384f13ff5fae6f665d9cf28cf89bbe8605c92dd68af689d7c9bfcd307975d796fbd5080065356ff56aa070f5591d24a2f2691c46e2da2aebdd4ca76977443ec44dc12a8c7f26bd2504cd43c6a9a0c0ee278ee44694b6ccc7e4b4331d282bb8cad392c91e3e9ce865507932f40a77571a551b7bf3ecacce78f4040fc110131e12e972b785b1bb3dc51b7e942209c2c673eac3fc2a0038bb8a01586f9cca2e9f47c07c0973299ce953b9974168bee616928790979c5d2100cf07aa30173f7a8530007c541ab4103ba25965c6a55ccf115cf6d994089ef34e6a810f4661386cf29c05aec293ee9adb3851338bb6ff27fdcf9a5352351850ed7fe02e9c2d17b90a1e9622855e4f42eb01b7dd2a9b3557ce6c125f27bf06ba7ccfe77cb83708ac9f26ed305af76a0ac8b210e4fb1ebd45cbc1f9efeb26332ed99e416ee44ca18206a20e4675942c4658312a497a254f11c2238f2b8f6ee0c23a7ac571684d81e1028a68ac5c64a7ba64739c5072dbe24c0bd153eff31f1d5bf49c09106a7006767ca136c91ac4b948b5b00882426d002fd2c4c9d47b008ed21cf38f7d0c3567e1dc634cbbb0a5eb0e059f5c99d475f60502f4fe4bf3d792d6b924c74ae440094ef4445a56ea24346f55005e2bb15fc7a1792d224915fc2735fddfa1eec17c231f421c2e3cef0b62c73e182f5f0af24817f6ba40f78cd263ac5d6e6a24607dfb5cb58f3e5d836aa3c14c1d0b11572850a227da14af9baa24df16245ce18e40f31f4ab407b49fb0250b2d92133789d693d6677a235a2b8a42493c921b1edd2648feb84962aa83804faca3f799ff3981d1b04df60d685c967f79186adafb8ddfa8c4c4fff4bf1ad5dfab1b1045e8b66fc0174792123aa68ff5ae99ebd814231b7d7200f284e9b8d2d7355adcb86fa179b6547963d52bf45f82fdc7a30a7a14659935179d6b475273f8d106a1611be92c41b5a9c2adb057525e3fb923f74c657a811a9e21dde8253659e63cb752d6c55ff1bd81a15a27fee894dc5d2c60a66927a527db71965eaf2c8c50cc6276d5354bc889632a349d1caf5727436eda3c829fd780a2f396734c004fdbe1563f6a5c3990781eddd5ca0622e669d6e1f65e226c70d8714a51bfeea288c22b82df58e30fe07c7b43724b7b5f96a512daa94183c352002d2a411d4ad37e99f60c60920d4601cf69cf3398308dfc5872d87ee2053a31aabad9c962a4836c1d9cbcdcfa92cfbc947fae291274ac1222739a654f8d16a3d36fc8d15860f6dca061c9bfac9bed8aa626a6a4cb28ebe2bd4080b065d3df7d7280cdf393cfc0ace39f5f94835e757d7260afc2e105bcdb8d724b5ea6ff2510b40d5f78654b544c9d80a2e0d8a910199612eb0156321803cbb9d076ce05e0733221e00b00ec1a7330404203df96e1acd4ef9419fd76a7ec746b09f6d8ab0e775af3cbdeda338f931c9376b8e1467cab3ddd272a25bb4abb494836d9306c1ec0a402e9e0aaab68dcd9f66b0c28ac3af27ee72d8514c1b4416258701494606851d9a3dbb6b1305d711c340ce99e8342cc768e715c04458b4b6001b0c6581828ce2db44639ebe395cf6e0a1b0605ad355bd63a3dd345ed7fd613dcb3a8c5bbbbb918415d20f2a5bd4eed56ecef9d19640ecaff91e6deb4a3927ac4d2d9d5798547295c7a6bb290198a3cd8ec4bb0779541a71c0bc143bf4c0b12081f3d79e34696759936a88eaf56c08cc9187a6c90d3a693aa31016e5b08b1b12bc8f91ca9f4b5aec09df08312ef243a58ba82eec5eb1fe5b1d9425b524b3444c4608c46018a047d9a8723a1ae42e8ee58efc3d3859069995ebfbb8b37377dd7371734af75eb5b3e72d76c42254cc39cfc644b83fa9c68a3d45f8708dea86cd5f8ef3764b76ab8e1a5258a99bb67ad4321f3da8f6c8ce6bfb59abe49e22c7bd2aafc0706df017ea420c5a047e4b3d42f4fc83f67bd179a0fc72cc83548b0a2afc71ffe70885263291c51468b42e8b027ea59d2b9b63b0ac2da3e5219e04a533a1de262b084002cf7a54730264d66addafa9dc6138ce7511e003345588b29ab32d6268f983fe4a5721a65b9ab7a3e2df850e43cf293ad6529f790993c60540ac33715650a4219dfbcd0d42bfbd29915da400c66c1e7de879ce5a398d4d1ef5053d3ae342d4ee2f04ec8005fc49994408c960c5c63b52e8c30090346d8a9b81c51be7f18e616825fa1c889d32ae4afacd6d0ddc6ef4aed270a08d63a7dc2d615472ce290dcd26b037ecec1fbefd1f0d79feb0cec127782fa50d00efea1760fc07f79acef4120f641a40e9b4562293be39ff20e72a1e64924c33676805401fb1c281eccccffd8dbd537efffc16f196a6d1e2d65caeb9d54b842e5e9aa5f9bb885a89951b55acb8fd01eebfc898bf356b95a73eaab7a9e0ba692246446917b10f0498937ee0039e42f15505e973e34b79473b7daeff1dde2e540ed1acf1a6a9fd86e12484ab82991618b24179f077bbf66991da02a5e6c15462333e009e4f5d90bda4513b4d58d036e13c09c9423d79580d46f6ae6f028c267ec8d4fc49624fda1aef10053ba8b8a9f55c06faa37c8d9f477aaadcb6f04320a99f22ec53349aa050f076cc56345ef514bea0f0782c2764f3841cdfef49e465b1384828a507a0a2930f2eda44e4f3d0c92d542c754a8de23772d8d3c1e5a052354631c817cbb813052acaada75e0e1e9de59695810b627c8ff5788c18bdaad9b24101d9d691ab972d80febb0ecfd615e373490722efa6a8deb108351dcfc410113cd6f56f0ef2db13e4bd1afc74a06dc329956e84d8dd83b5d65625c4c6072b58ff9abac388f4e8e56deace74988c0a77bc289d7f5e5d6cf12ce0ce8ea758173a819cfb632a8ada01ef75104c638f3fbed538fe5ecf3ee7b756d6239cb586ad3e0384c4d023805690bab066ce2ec59def60ddaa472a67ac63e9db3ae8860dc7df9a6a1ee50c1334dc1cd7a593c485a6c705aa9842bf2666b620eafde91744a5cc92f6f644707605b0ed9b2427cf2084815f28a74e90423624bfec41a494ba0befb94edbbd0ad7393055143b17ec233425a7b9d3bd95131279a4121bbd014337b100cae181d894f077516c800063437a4f80c138429c6d067e90e5a168a6f271dd8c3a2807ffa7ba6037cabdd2f15235011b3fc1aec9ddb54d954e46f94a1913c5cd1290b061c1481a03250ef2768032b3345f8cd2bc2a33bc907c2c992669e513af624d7522a2ffaeda29f231f8bfdb615633afae290315bdd6bb8215aaed740eb2fef0fad2155c5f343b80c569368b254e4cc31fbd1ffd34db2be4fae1f9516970e8f63337e1267887d2f5a6601495b6c61aaec9018e39ee4bb687eac21c221984fb4c577c6ca6e2090f67ded0020fc9236b7fe49293e8d57d6a6e81618596c0d8a691da73edc518e069781e38560473722ee6c9852de2724d29aa1a494a494541a631761ef6706127377a8d31dd378d9bba75470403ac60f2a2a511eab49ed16fc19c10f8bd43d486524566fa4ff9bc797101059208d8ad7f06979f951c5d3cc7d2cf3608aa595526295e163e6b78194d24bfbd2cdd2e4606144f013153baa58c878efae66f261950da19996e797d0d184e39ee74d508a309fd2deff26982702a3630ae069030088ab9667f5f7ffc52911491bd2b83a9e8037f201e7e3657ce492389117a20a05adb33128b8a6d82b29b8cfa031d28b4c006227a2e9abae33b2d7c86072024d5ed1eaa027ce6a931a273219b0bc6ecdd982f5a36aeb3c7333d30b267c0a7aef2abdf6ec09d39ac6cb693ceaeced0b47cdd6c11d1f232b0ad26aa8df6f4cdd4affe089ebe0c56e3401b2f581efc6e23ec9d08c1cc6da074ed032fa0ae644cf35981345e09bbb0decda83ace58e79350acc4e94df546bb6f215c3ae18c7e6f4225ef9ca16e85e3fe28c5e3f03b7219431666425b3666ec4b85c3ba900a35ddfc7ebe54b37f3dff90059d2003545e8431079fba558742ec3497bf196c512de304afdf861ed1ff9b1951cb2bd12f002379e9af1612a3c0c98c47f3962e8a01fb73b87a5e80981ad03080d576a6d9530d2fa9ae14b13d293f233ab4c7767f3b4da351181b218839aebac94dbcc6a26fe6ca63c43206f0f076b85137071f6ac1bfa6faf046261119b8633892420a4707546d56b538504fb057ff51ef396c9abfed97f47f60be9ba81aa26d91de26a51c3e3125061b1525a4584fae86a450ae003c96540700fed1fc6790153e63631b7463e675e2a3cc8e728a6a9f436f1b25b9cd4fea9a8f8edcefc23c82368ebe3bbaf1a33f401d5e1f54031fe3b1acf6e36e083d1c3d3d7a6a04f2adf0b84da559b777b192241bbe4dccb32f25de27339e9f4f70105a1f472e473c642e41399aeea1581a988ee5aa1beccb8747e3c09e44126eb4d4fe2da045f411e1ab2c1d91270ea53790646172e03856790f656e458aac330d4ee9d4ec8a247ea31e640c9796c77d836542c0e7232678b45fd11b95113ff862db7980f916aab388aa17e27a3309fdb0d1cd0538745593b571fb4b267dfa4b87b065242509b95b9ada119e5b356ef5266fe506c9e1626fa6fdd5d2ffb0c9e818a190742519241529dce02471b2a334bcb74433899a8753d305932bd5dcb8e628b51e3e5ddf0ce727921cc438ee5164469abcf0c56172b793ae102990ccbceee9fb6b436f59260f4093a42749131c4097b88618d572df50c79ba28abd855d1b1b0010be11c079462cfac65c33156cceec4980dbe034578b6ac9ffb6212a82661cfb8ab181f6f88a4a061efda580a8e8dc522b35593b46dcc07dc0031ceca48e49585addfc6ebe79b5e3e5f9b2dbb7c1fc19276fea67db9ccb856cd548a805b0a7f3b7686611917cace5b6f62cd648c39c2711004a51bcf8dc14229bb76373c05e6930c0f3344d1dacbde5a0fd7f81a9d229e6385ddaffa57fb5ad6ec2a045d3e0c4737ccc96f0c4ec9dd1f165938ba8067873f422d0362d362a7331f6dee1227874fe159434dddf39bb44121d794a1d5353cc57a7756fe0759947e34f83a7e63fd5563805e43d0e5192816c98aebbbbb55af84cee00dd5c0923a96a9473a7bd66facb4023e76699cea9d997f3fd0b0cb4fbd839514b9648514be8fb2e0d818c861d1aec7c9695b6d06c2a1b046833770513842b7cff440ab6e65b653b77dcf9e1980418f58fcda95b4218303628c0216a29adb7250510f066187149dc8c999d99951736af575c4fc1cc32900e54ca0e4e16c3f33a94eb71ad76dd2df3e890ca74139cef09267bbe1f111f3dbfe8a9e75ec5248c2711bba5853e9607b831f2f971c4ba404ab5ca23267282a2ce8536bf204e0ef36a866bedf5000589232c068ba2473c7c8596b2f875c2ae6ee90ff512efbfb31a13a2c783fbd98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
