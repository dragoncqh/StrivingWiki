<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f3f31da2ba2ad1a807ce18be3c29341aa6f9a0c02652d6d3a90834b2cfe5fd72cb02fabd7c43794d04cfcef2505b67796e74d93709d42caa006bdacb7b011474626075d85907db3471735fe677cfeafb1dd291434acbd781a076223b357a4aede803f173ea36a22fe03c00870c0e5fff40d82ed1693278b4cd9a4faf95b6e840a764931c44e0f353d69f114c60fddf3511b87a957cc2a132ea0c997b7466c9acb335f7ae738464f2f026ea0a57e3fa43ec4220f0893f542061b031496feec094848cadc9961545bab8f8da0958180e0a2b567be80c17010be4d2837b87ab2f3138ba32c4b5d482c54c185d099cb08f0847ce5ae6898f948cab57328ce7bed3af12497f0ff8ff6c03adcbd5720c923d4a76be94cbf63df16a6d80f5455cdfc52e221b530314fbe2bc81f42896393a14b9a3c98845748428900b0b7b30c29e5baab75f151c7a5e1570e93fdce6ca5f0b2affd5e2825ed1b7b62b70f81edbeb22df65d21e8c66f42dafa464c41eb0c0ebbd64f001547d33ed37e4d8798d2eb902f520aff9df907074cad2a31a4805126b89c16b2062414e50bc15a27ff83ec6f6c89bafbf6b03f1a2ece334eaaf519234a5fe443efc268449c22db80f91dfe238c1cbc7b862c61a9ec64e47257748eddbaf94942e29ad14d2104ef7110573c31a002be12820a667215c9b5b75031056511cd20bd1564b35ab57311d9e71aec865c8854f74f61feb27d045835924e0f441a9055d552cb01d9dbb6e2d8192738e9507750ad31c6f459b87766ed66b9726c772094e914b576a0c95edc8837ed6fbca4ee804caf7112bb051dc1304390143c28586c5c45e350c4dd0f713f0851ff462385d1ff5bd2dd6efbf99d8ad4ecf1276064199e365686890d76ea984e6030e54d0d29e483936ce62454cc121c0fe23170553a9c99309ae9d82615ea625eae59919a7e4d82cb579e1847baaea87735a0ee068bfec40b4a29750acbc8aaaee43fd7620c26c5bccbbd35846be795bd8f9ce46331384512f76036472e7ef3424ce1ea74f51d15c10c9424cc95170da35126d557de98b5ab2556273d7d9f0066a82e36113a0fffbdac7b2305ad68d95d9fe76f2da4761b9bb3e4e1890be80132b41c824fb31779dcc838f2f1f47dd263be9527552d744bf733b23832b6791b8b3e24fc68120da605fd2f8fc021891d44fa5926acebea39061d328afb8315f6143af6087be69450af0ef716a2691079aeb2dfc6201990ab72476797dea8c6e2044ce6f5c4b70956399e2cfbf4f991e5cbf3ea3a6934b33e32f6ea53558d498a8a6c88ab03f50c77a19bd15c15d632f68d0c39b5b68d809101f0721b81e32c0b87f66a0e7c67911cc9091258cd52a381efae11215999f7851c3b3f761fbc5e938d32faa4d0c139b09a78e6ba2931afe3e7fb28f6e189295dba426b719504073492dfa40471da1082ef81032acfff048ad0deb99a587e9eb9504b7d54ae92779960fc3331eb32b6077e44dd424dea673a4f104faa6307aef2a1201a992b5ea3c3d09c225b472312d2a0c877120d9f9f59aee041fa3f6295ab79f01d86995f458a369332e21cd41d0660f4a9e867f0eb9765a3209129197102ccfcb916550e181b3ca2b4982d00ad9a2f69686ecea1d694f6d2b2de3a9b46a4cbe0a37557054325db4d735a834aea005ec263217577525525b1c9b9d9280d94cb87c06e0065ca3f13ba7718d8c87642d62fe4baff58b8507eb1e33d700961b58353c544c501b19b498f80f3b761157deda15dd178f020e4badd54d58ad2a81153a2572dbb0504b1e4fa709f54db3cd7bf983ca63dd2e916f1b9db5a9ba2df45b22612dc26fb9cb830e5c487d99d6fbaa8115d3c4023948427be06b64e29c363ee1b266934497aef7b4b7c670c64fd303ae0850cfa66316a7b0ceeddd187e42a17ed9dcfaa22903768dbbe0bc29ef7b6dfa7640ac523ed9512f8c4d75349bee074254aaece8b59a6f36645babacf7f76a3700672199487b9bc5374e2b0054759af05ae832bc113d7c4d612a7ff00afd7e05d8e73c52c79f1d1fbe70a0e23d805e8f5633a8a094286c0697840f0592fc66038a6914ca43cc982454b79092ada97ddcbb5d6e1b421373d271e08982eaee666798354411efaa1839552f7ab13a362790e224333d016b07ed7d319e7ae25d49296129eb9101bf82ceb8f01fc5bd1ed7f7ae14c6253caea761d34de7592e6311f3f42630aca927d245c10143bb391aad2879dd3944f09fbd106bd338f4f4e355cd72358282a4513581f0c426c118d778217d1b001db55ceb3bf4d16b408a57b87c8292b5566465a9d48c823f0aea6455d5c716bc9e06b5b713a2e2f2ac14f6aa6d0c16b7f2c87556c7cd4f2f640a997f47f5daf77ca77e5946013d5a143ff456a2cd9b43c0305f531e47be7e3b1f12f5e06982d27b5240140e97413e39bb44cdbddb5b45d7b2756dacfe0b7abdac1fb8085962cd38744f8ac74cc20f9c7632375366ab822b426eea37fc360f9f2415605bd4391116e60e2b5962c85e1cc35c5d5532b379863a4a24c05496c3ac0a0352f09363717ee6e86df28b199108eb595ae72903a23dccc5e0083f1e26a1dd7627aa0c4cacedad211039bdf332f7fbc09177b07a3392c7ea3b9c8134690318a20bb41903a01d48a02b13b6826317bfa03fe2971c0b65f293cfd7edddc897d28a7d25a07b1cec3239d3d17abe4ba07d671a6e467383ebc7d1505e3cc8179ee4c9c518f4407547e4523995c846a9f5669883c7f2720a48ebd8a95d4df86580a49e62ca873e337affaea6e799ab387b72ac8198b8ffd30db4d0ad4d701bfee2218569acfee24c0128eae1b5941d303b05e4e0542acdb8389162f17dd82fcb282e985de0b15426543b5f7559950003ac97ea2e2b4537a95501e1fdd5036e0eb70928b8a9cba8b2031c43ecc769e7c54d580cc15dcd954fa70d4e8de417344f53e6d1033a2ec8b98450892df9f2a8697f4761670ccc71f0eb2a6e1149d6a48ae17633261b42e24027f3e958c7e22ec9b4dd2f7b1dbdb5cab7396d9386f1e0f59839dd08ae8139be2a99a9ba9f4b9dae16c8e208fcb062034b1b86aab861ca8b364fafc4cc072ce35bf9f89eadad6dfd417b29060d461761f6d261ef606f998774465da7178d93f8219217e56c422ce190c002c2dd178c5cdae942f0184d6764a9537cd6b8fe55b908f67a774aa5d57eb7d1f30e01f51f2994c775bcd869cda34f4eaecc62a21b120e848493202c7e4905ac37ab0c43120fc638f98dd2728270c4c3b499e117b15b1804466badbe724ea7063ec43185039c4eef9c0737bfecc58194fd3fe3ac0c25f4ffe0bb06c033f135b49b946e10e780818cbbcc0498ed1d33959ed20c0c6604ed0ec2d88df69189e90cad837e04f99574e1cb06f7cf7153bfac0607edf387a6d24f96b97552d5c38e2789596d1053e8285bbd99e7137f17f8b405d272f9908eb6e17b53e8f02c8107a7ccd10bd29ef0240be52d4d80912d54f842f6682802998034af194c68ecfdd294341104771915bc180a72d0f0c6d4200abe4f08b5f95ac9adeea12890dd24836d310bb6dab123a8cafe8fecb6331cd35465413cbb69107c24286263c4e81f0aac8a2196b45764066f44b1d6bacea966bfd1cf9eb4a7168d2fcfa12a230680a2395bf690531afa2e482d2cc7490624ea704c56b1858e773ec0b57cdd07f505ecd0bfddd0a27e79c70605ab518b699c7e5cf99de1ed9309ac72029f1b6f50706501e57c946f90552e1a8e733fb37b55f438015808cd553fe778c591fe32dde833ad315ed45d4a4103c631321d916e659a2a449c5c2ba49f4db00dd82c5f96524b880bd335f40b566e41433de565feea3572b25420a8accd28d5f2b1379122db99e2a66f77a5aa5fdfe50e54ab11f296cce4b29185bf679ea9e3cd8c4c6893465b8542de0ce48f792b941721a80fca03620888ef340e66ec2b40b481e972e296465b6099f747a972b51a844973cbec546834ca39e3655227057e398a5197af3f48f842ccbc1f333fc1a16485277701c100d5f54b4fe2a1d3e173cc5e2e14aa6a6be90aaa2340c5b7bfff1d3126d0247111b1acc8a1bf99392dc422547d13c64f109a53ce9fc4426835414ce5dbba012c94c2dbde78586330d97bae48c22698b460013d51a17f73a76cca39b4e32d95612da7b52519e3d88ccdf69ff131f12186f3569a89a75a663c0f8b69629e5364dfc329c2cb763a91dbe3caf466f452095f344afc561da08b8a8ff91d734ab9c59480ccd388fb5b67ba917635f6bb4cb09d3e5f2c83ebf6caf29f93b576de05634a2cf7ed54f653b3f6f88092c7375e493e6740a2ef77df320e6b2177f53730e21eaeaaf8736c181a182324ab96d5d2f8520fba66d36711e6f7fc62c977589f9adc5bef0e7bc17a00151fe0f96e80e3776f25b4a196fb7c7812679b4767b8608c5d28d9e97acd396e7e84fca18122b978072d1559c50d468cf45dc0a81dbf905b53cbb306cf2247e46ed30b387b7bea940dc3cc7ab4da7ac6e54256af47b6f7500a21d69a966f6c3c2cc4ae170fda3501318fb7d41187902b7b62e6e6bc9d771b89ad2fd662c658729f3c41814bc9f1db4547c93253a9028bcde9f76224f26b44df048d7264b04299b6a1bac863f58aca4843417244f5d8ee834049208928982ffb65f7da31344e5e5b03d02ae84a68b62a40c63aa6eeea725183c0e81e6ddb83d184b54a9e109d2d642bee80f90080ab416227e239807ebebe4f76cbb7c2cf802586e5008635d796169631490959125373fd99001f1c659ac69fce5d8ab777770d82d79db4ab2052bec04af264a53def5204adf68ad0ac091566e792d9854c2790d3703b5ee51c87c4d306df5096e87608b55eaa39e3a245ce469e58de33e69891685650314717ca6abce12e32af640317cfc99ede1abaa9d216f5d66ea75593608ea9786789b69a4b776348f4a6fdcd837a4a3cd76cbb45765c468dec863a2ed5c46e23d91b407fee9f35ce298e3d09f40260504a975e517c9dea145655302a7b7f6d7e5e3ffc18d7a841d55a16df92f7aef9dea2bd9501bc8d498bc8737b55126666ddb45c197a8f5434fdd734031c9207445cb81f9fd2fdfe85cce23912dc1a90bd9a9b6ed20e0811daf07fadb6cd709426249f8e9f29f1314e9ea4bde8a7e9483e2c88b25a0c49cad9b4ccd1e13009b6f371be115b8db0c0868ad8125a67cf09be9a298afb2582cfcd508c36933236ca54534b5a356b6f1c8c85e909e8bfe5473442334487d0585f3f46b76c1d511d4825c43d219ce03d13bc1a4ae6820cfc764c21b14f115880708a80954db0d306a8fc9de26244d04bf6ef4ff8249f2e9a8e7799d3b3eb584cbaff3871e6e02e84d5d76c2397a31df55d13549fc4015d412fae19be2a0ffa1245b3f2d861677f541856ac9fc5cc024946cb3ba06160ffd7e9ad4fd980a4004492377ad79e8adf523e0077b5af1d775e1355649e05fed1f095dda258b382b6225e4872ee663958965f4fafc5e9d399cac8016aaa61ad4e269e0d35bff88ad0b38c42d248765fa3c34c5c7dc1e9525d21accae2d10c8f9fb97cf42d44b4b58b3ff8f10f287552d7ef496c182cb39b73c12ea0a8c134c3a689f4e90dad5d096c91643e1881d252229b75d60b482ef7dc552a841963cd373d68f88bb1e829a045ce9ce65b8b567b9e2752f7e9c8a17a88a0df502388dfc647e6addb3ab326ab4a9bb94e1da4eb9a183d100995bf2051fbbb85b19e009472a1df25320ac36e0871dd43d000d160ff0bd2f95978c6a2503588112d352cb18c787e5ca840bb8856073c97cf314393ea1e53e250d70f51b47b00d1f14d0a6d3e266dc85a325c545d614d6a81cb31c422cc728dd72892194b2453ac17acb7f0919f2fbc6a39be1d2182151a5897dbb36c029fd8445593e2bf5fbff20cbba6c1c1797858b837cafd7c3b1488470349807acf62519deafcf123d51b151e1a74aa8f7188a70dfef354b5251cc3fbf765a65229afa5a372a7aa7b08b295fa56a6cb507f7ebc9f77f87babf456ac8564c8b1ad2c727552eedf2d35ee585e042db9208cd1e382565bca05a9595afba3361bb44152183274790a63ed1aa63670811d136cca81f8f22368109af57e39edfd479bb817c9294697b4f78f63b2cdd5eb51290b71624713ef142bc7c9f2f9452d511c1e93fe076b244813cd22976339f53674d6156aac72c62ee8fd897e865d564d7a9364cd1158b8650440e48729b8766f214bf7bbf7d552ef25de4e7c97e3ff1a0b50d0cb31b10423f3a33e0d5c666c1b3b5c17febe7f3f38e84e00b3658c92520aa2e95db788c1615956704c0fb500f2aea5e89cf83fb00fe2b1011c2e60e9bc5f36db890797c47c54890482b60c674af04461579e64ea332494bdc7c6f87b937c031c5105477c9164d74abfb2139418195fd271eff2d27f7ff04d2e9cdd57fe7df155db82be2872ba3d27db3818cfd3c30b973066a6274f778ad39e06dbb56a64ea59aa41e3e9fbee6fa73d448612bdf708f0aad07c44568bf630618fc8fc509e44be0e7a1f3963ac18a0192eaf94411d53ab43b40c834cd51b6ae2356dbe5a15b801d750828cd5fe0abfe9215b916df659991b68b291a7c6ce781c9dd1505ce0a358dad903a982666a3414fe521e651966e4856f5580b57181102203e1c908c4d95e5e6f133820c32fa54e0143ca217d5dffd40acef66829d38cbb52a9e84a53fc5d8a5210f222e92f272f8b2e89a28775d413ed022d57fca666898aec1fd7933ad3a3b2eddc924a46230d3242be2cd6c277924f9073c0fd2a15d741b2d44b26e527a4089c6f2b55696f990900e69e24eb7f97f5657f9ae7840d07883ad7398a271865fb74caeff318e0884e201caa93e2d51daf330a57a73002fc065d9e37022d2023137d29c9e3bd6dd556fab892234b8a2801c19737501063f4bf9954d84a4f48305fae9d0e542bddf2952e0a674eefcb173ba00c51ae85a27bd687c40f0169edbe95ffd61f4a0dd9f9946fd7ad6fd533e0f4be172214f3cc06fac64791feead7b83577b74e9857b9f3f7141d96ee3e56a00165f234398b1f0d8ad4cffe6d2592464a8b6f22ab99b8a0489535f94432d922faa6247f03e22fa2fa03b83fef6dc8f0db702b2683411b543b39ac522299ca0f807b6b2a0ca48216345a3a648aa6055d3ba5c0c4d604e9243174ff804957429074af18eb3bae7a2b9a16334600be26a6f7446224fdc9f1f2c5bef6b5c41d13b7ee46656339df922a69ae876443cbb506e2515fc06ccaaae6098d075e634e2e6840fac5f08c7757c1a81171888a1dfea4115f18c1bedd32a19d3d0b9e7b3266c4b52d158e22e76d8b63be118f865bdd4cf9c2f9876d69549c29bfcd5e6ff2eaef27cb0b93f9fb9fda0ad36da554640ac2b335168076990fb0b1824b1a11560d1beb79036436f43cbdf1a0e3c4468267b6dd4886d1a15196aee52d7788def2e9c53f5838b6c155f501a3de9e0c2979d7dfec2067317755840dbade541fa81780f81031fa44a08e7f9b52ab35bfd9e4815b09a68497c26075ae9b30c4a9bb3d3974e23f55722a6999b1f21a0ce86e22a154bad5ae9b2726856359a69edc5e6353910e39b4f800158d5f1cde089df97b5f3de8714374610c7cedbe13114ee86731dd905e3753679d4d66bcba60fa526f6d44a80c53200c6cb4aea2557006d9761f63e5f284ec6a2ca1e6cb1b4b0d454449d4fbc3ac3805a7ba6cff2685ed30cb9523d07a13dc3c9900926724c7e3e80d0930243761a8a7467fb419a36bd72a119d81d7baccbdb2ba615fc5757fb771bd28899896fa7e42a2ed13d9286372c16d284630aeb58ea2a2d6df71d1b4a9f205c378534d76a4628d92e84632f0bea3ce5cfcd8afa2237acd87b286dab957816ec32e0bc2ab09df770ed015ac794e553bc25ecd308084ae5a2b695c615f023bc81995986a04d6ec2de7448fd4c7f6819766b2f0aa7e31164354a0f9b71c1c561971e1c7c078d95ae8b3ef1a1c70916772c799065a1e40028c39e16de6da71df6da467da3c62c00288c519d1e3abf319eeedfafbb4ff766ec787c31566e726238cfd469d94093a13547c85920bac2b5e284127c7341ca6b6cebb10753e586b7a6ea86bf2ede64309d0e9f26acf3aaf59f1c424c4c924fe65d57807ea7547530f44af8d797d71c6d25c3a0c54d2830e8e9e11d4430f79a14a2b6960371d65c687a97f3468de2f18290468ccafc48f89f85de1497e3f95f6323c947211fb7b058efe6b8817fa1e0db4bd5138377aada457ca971cc0f8e9e726c0cb7113834cb360a4df30d3f4cf075b8a83d56e62861eefc9614beb4fd82589a3a2915369de719b7449ecc135fa7093538ba0e0e262a1fc6acb89f4973da8db5fbf5c5dbc9da86268b6e42273cb40e890e4fd176e3153d2a4021e453e0650bdbdb1deec86c5fd81994218d63edd91b6b84b84a5dc3ef1b90fd97b81a4ae179defb6966a5bae70276f5535c351f8ac49b0f5198b23751bc6613a25f3fda49324519d68f6dd85d0011afed84c239d800454db5c2c08c8a066e440d2361967369ab110b4a1c903f0b28195bd3045147ca05a9a2d47a208e99400d190eb1951d2baac6247347fc592edbda921a38444dbaf075a98b35f032bc4445472f3e18957c73cfe677fa2cfa9f2d7e1d8677c716a38f408a276b0df58e940fa4427f5bac1eb371295d2d44335e0c4620e32477b4bc56d6f8b932ccfa35bf95bcce53044576f1ad64455dd2dccf51b90788ebe2b8d77aea2f15b1899f5ff715ae087002ac3bb6478d17e8f30749164f5d27421de4751c6ede033512b7f968ddce3edeff194e989eaf3c07b54a344be54c567529fdb10cec022c4e988f85472cb8cdef0a0a3290c6e3062b13f8a39a306b3a09027a5e6bddde54bd4ede393da02853d3f1983dc3b64051cb10c26290d8a6df81108749330e28c42258fe856d8fb32b350a438267318502e660692dc678b01351e1005b63fc2fafca2ad4a6ead4bf4609eda475e56a91ac423f6aac6064dd413e93c97d65cc71556571f1545687389128efdd316d3c27cc486cd6d2ed713c8ba08e2ec5271a01a632619bbf57abfe3bd28869b5df7de8d1bc01cba76ec3fd2c325d8ec61ab1bf658b94e710cd11c9a3b488b5176da301e9f02e14879972c97cc2fd14d5c9b0176aaa235e4a9ac4b183cc10022409efb7ad9d53185ee4b163d463464ac75b1d468369f3a68eeee962ca64b96ada8d64e70373f6329ff88067f6a824494765ea3208e415f3d1bd7136ab9aba3badb78568c2321e305f1c2324c78731121d531fcf934d51f497c276349c07b3cca78f3ddb33e29771549e26f2891d636630b332742c37352f45a0ac5447e5ca7ad0f71d3f08acc81158e063e242b4862f785d1ad11e649c300399672aa19002517de818d6ed452f5ce145107cb852f75a1fc2b26a60eb62f04e66917cb45c6425a3f7c8da9078c5a8af57cf2711dc38184833691a29f7c8a20a9955f3217646fe68d023bdbd48e754cd60b0fd576e341e8b08f8053f87688c17f3de169c5673b6d70c9f5189a09705f837bae0764f93020581ee3863873e4bf2ba418d0e595b2f8f905e95ad78e2fd3f450031990142121275a695ea9755ac308897055c67d7a54a8a0d8929ff79f2bbb9cbf0ca806f098f853521d9db369a13aa8191468cc0ee9c7140474cf4ca332da054e529bd9b31474a0bbea03c4e674ee417882a6ff3b266884b46c92e0eaa52d340f2799fccb102d6111937138f81ca53a2e793a9185419c99bd450f192a0550caaaeba9eb1a048c264849fe813b6ecce6db00d24e297a724f07217f2f8fbb5928d64b407593b83e066d6e029ae906f0c49270e9fdf059eba5e5386f05b0292ff32c77e448aa404645a84e356d7747df0a463589415059c824eb88957f78a4079ad773332c10614634cfb69730c36a26fd19e3421cd2ca410ca169d0327b407ff52a8cedc766cd3a2face394002eda4903b40c47059a13ea2b18228aba4dd74233e71f87b45fbf846002e3e332a6d361c7fb2eb057518b63e6c2a641f0ffe39936d89d667e0cd08abe69e0a94400adf30a539c7d4ee94b123c6f5e707769b06deb1b3cc05aa1534ecb0d6941d5bc634f2220d01c525f49d13a25c0687c0463fe1b6a62303ef432821105a8447dbd5f2de53830f884acfb38a8fd6a3e59ae55d5c92d4426a9d5ea8b838bff25e810a1a52be582070c92137c1c48f36d0eedd3219ea2fc4c790bdeddc2d21cbf88d694b257aedbcccd0e4c57d6c209095d4d8689c85ad95fb54a67e35925f8c4f8374a8856f45a0efa4b6f151aae9948f0783e93ff6f973afe5f2116a75b232c373f7e9edb94c5bbb486244a90cb0300d4111c72e1ddd8825c01e547531dbc369e9a4d449a6fca5d0ca4afe81d782bed3e15b3337dfbf03aed5ed972a615f3014ac3e0600d52f8b95f623119276ce1e672d24810ac9af93efd700102c7fa1e12f8795845d5aac03b989720a79d4bff3cae315fa5e4cbd49b9259aac7919bf71a8208ec1d991e97dc77f0bb48a9ad08d389675f0cf9c66a904b14b4f208d3f25b5857f09769a221faa0c1c182ef4a8822aa25bf8620a54ec1e699c4b3da6efb4d86893cdadc08d04cc4c1096611f8c44cf89e0769ed72418c678e24900c401ff3a2784b38c7a5e1ae60dc7bf8b9c7b940f3b5b16a40bf42aac6f14c61930cc6120171cce28e5e9fd6a3043d849f4d458f4c3431e385e7756dd237c0a147526dd3da7e52f41c6ca8efacd5ab86063ca95862b318745039802c37c7d8e1e8b068eb6e69c5d407f21bbe7bc5aa5adc008c7029d88ca397df47f8cea90dc805d66e268ef859af19fdeee3e8ebdfec3265baaada821b36fcf2eb65ac8bb8f71cd8dc068482140d829f089b093db9722a4721e4124568b21b31d0223f163c45ca59a43067bb5bce2352161943f235d87976c556058e2b52e9b5fc6845dcbcc1c33b20448b5b3c8747ab891dc864e6bc528c03fab9df6dddafc79b55b3e864074e52b0aef411e16b9287cfff27d9c7c9b529dadcc8a6da9076d1d1cf0104baa7f248a400c240cba8189d8614d6eee8bc5789c08bc30e861414929422d583e391ecded5978983ce04e3a58df0f464b08fd6022518782ce40d0681d7e522a7cdd9dfa7136a64a64e2b115bbaec68cced55ec03f2a69a28b404afdbfabe0b218b2304401328c3abf136ffafb8aabd7e8535ca0c7f6710c43ec92417180206b8fee79ba9a2c08c6780da849df21e71c605baa0d498199d1256863e8d20e4f235bbfee4a7941e455bd5e1b102f1cacb94f798fcb360bd3431f0daa2c51fe9dc32b5eb12b39cbe12365a2bc97f38d5cf0e9529efe4e47295ea03f5ae61116cc0b40a8c5d29e68279b1ccc0b2ad118e42f58ffc0d9752cc142ec3a555ceb640db745a2aba05e268838bf29289ff03593aa429d2b4662f3c3ef0374ebd9a3f63465ad45d2bf01c5b68a475588c7e5daa30b497f54c72830a4ea1b54a6d19425ec27d7f24971a971482bf9af45d7b0d3923af3b539cc7a496dc7765ca9a9256576baa3dbeec096cb03c0fde785c217ba5367ae7630230d73452081545bd84baeb81b10072210e1bd72e7c2593e9189445f59e09c10bf3f3dc12b108a883d51d3af12b997467c93f9f95fb950b4033a3af8ab25ab4faa124b0b6e5e31959252565eb78d1e9f59856c2b72610384a5689a25a567f48c77c69665ac15beee91586164d09865851a6f0585a646033f460fbab8ceb00cfa59d045cc33941aba6d075d59df2656a7d226d7dbc3e9b7f63db1552471e9c3a79a2c91080ef7185c800bcd30c2a601035e410e299b1f506738b5a5e01ca05e5ea6b3932195a17fa884e6cdbc88d1db6bdcd13f0b598f5060f48c1a046d8d406a47bf08c39c30b22751fa4d1ddfc19d1586e1dbb5fdb6c1e005c7d1cf96eb4ac30cdd4385eaf6b62416e942a03e93889b06f91eb192da0d6521378d785403c44524a6d5710208f32a50b83954dd9e8c77a4cb3c026c12be3f5a7abd2fecbd362a5e3b3a896cafe27a92d0d718b5e3b3cf5a6105acfae9f2772ce08a7b640f3c94dc21d4310a513fe8426978eb09a79767bd8b67a9041e7a9f2c6008fad9d75293417dcecc70d38a2a70761c7b8b1d5d35a9261d50e55102d9958a5ba9c52626219aff9e1452aece7588a21ef2684c772dcbaa4b54909153f340e373c065f8490f7bc2a1fcb9339ab6738c1a9248c1c2b005edfaf402ab507e03662f815db9bed9f18f327f0d69ddf24d6970487d7e0b5e118f0e870d549c577f9999cb6c87ba04c1142399c3805db6932aea0a7dc715c4ffc356c7e1acf822764a682efe71f258dc6a9214ffa3210366bb06536a76e764ee801cfd2c66794ed14c3fc82a259f10d9529648634547611f5f9128f8ca371d7a7b58fb682290ce1312107b09898ee7c83f591fdcdd05f7cc6eaf8ec859e28718aee83cdbc5082cd6fdb8c11181b26df91f4f11d0a16c20b7d94815f9607f32966ff8952a8d88836fa56dfb7cd61bd59b634603ec1ea4b4a12b2e32e74c0576b0f97d9dbf24f4322e375408853bcb85c138c496bc702e90e579815e32f82408723e8393aea6e6ec2cba1e22a989778aae84bab903ab5d279b4c9773503c6a6d867d8a9cbf7459298a46d017c535ec95cdb774065c6ffe5a7010a3c6f3ca585b8478bdf378c62c794cfeb2d3466a517fc52885495652495df260f90f061c2240ace8ed593a748f002f74863ef3fe9e1e5a11fcd385c7d82543bd45ad4aa61f30a17221cfccfe6b421332c8d05d84c0560ef15e18c1a99642031748f0826330dd161421a5f43e68c676e0a4e7b61b1bbb5c25bf55be6642d5c53b8de9f04f7797dcdebfd5606465b9e03c198c6f4c88e3013e7b8085e34c728eaea15695c3b13c4a9373e2a98ae4870bade76211ce2b9e7b253e210d5e469f0b33366a05a69c03135a29ef7d23aa65efdeadb8d0771fb8a510fa40a628ed80a221829be04ae4443ab7dba1eb0410731d0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
