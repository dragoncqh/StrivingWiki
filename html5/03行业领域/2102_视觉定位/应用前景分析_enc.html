<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad4040d4170db6c9285f6a5cb072a412e8544a682390fcac73de6772c71b16854a24f153d509266581a9aa26e2ae62b8b5fb509bac518b2dbe40033fdf590ea4ff5e91a9fa432cb019406ba07d99e2ab00176a313d99b84ec8be66c70157a9efa261cdf2790456013fd9c5717d7eeaad8c541b50a7ad081dafc6bc2f992ceb6b606c7cdaf75dc604d7107f524ffa8d9740910077f901212dcd8298a5e0ea4cac4e2b070ac00ebe54ce5a65925fc927db839bb8de3422e38a30d04921bc9e0d4b87260dc0e0a48c0c721674c5faa9d04100f4b42ee15fc6e0b141621e24e0fb8f7ae3d88cd50b5570dd7f8009becd13bd30a5e133e558caea3f5b40bf5ebd57da5045715d25f4b64611869f77bba9df6c2073df48ea1b8b976d3201b5d917d5587d67fdac811001a5c8e01f146b2491deab03c8dcf6fb7ba33057a57e601879dbddcff4089921c0e414472845b2d2f20f73e9cc558218327dddb9dcd9a65431ec3ee0c1aa649a44e2f00fbcfc6c589b0a565f23cbe24c87ea9689c7f8904afe5f71aecfa0b942f60bc7aef45df7f4d20178cf53329cd4f388401957d2abf4bc91a711b9840303f343dc6fbf617e750608dd454006c2d839055383398e1df30df737d788c9b0e5cf29cdf6beaf121aad25c0458c069b724840765dd6d73c2e38a008073ab9d7fdb2ea497502ca58e7f4b45958eee2794bd0425d0449bfeee9bc5bf8d63593f1790fe9d58bd7c07fbdb89c389361abaf2ee8283c080dedf4524448803b3b3bd37bf90fcad78364bfbf634e3db239f7c543c77fb5bc2fb80400cf9130b10ab95f1b3f71a98443346c03d68f4ac97d8e5f81d0e63d058100c1e701a49b71d1ade92c03c224c264b48dbe1a243607391f7fff05f4ac204b68ddf7a64ef43051a445d535b497d074adcb381856ffa123194ee39aa36b080404125b15c39c64df54ba97c343da326238670dbcf72c71cec119d5728a12bc451257b2790b1565992852c6d1ac9492e1b90dc40d14ab1b79a51da278b03b2e812d60c24788b8609db2a2350cf55422fa205fd5f93cb4b44bbdc7da13929bde952fc672f0b5348e9fdd7b6b4bac3e0222d0e03e6a46000e431c97697af12f4dd39cf90871658d347195b3f64500f713873ad167c23247b52f7d5c59bee55a5b758585a125e566854184103764583351b795e1f78a0921df00ac25425bb883c1d7b589fc20ea6faf5c0eeca2a3b41036d7c16a85e86c2ef8443d365747daf38b8c498e435dc9b9a39a81ed205b39382f20ad54afa74faafc6d5e936057b806dd5e3b41a91c8557380a849db648a16eedd877053421cc148da68046087fadcca9fc750a195d96a15a99686d76d4f223c70c6895129f73339bca520796f0b213954c8cdb02a00a7b1f9d3e620d57a5b217f3ea72d32cf2347e3499de1709c29512e31406d65d339235b7cb18f5708d2254c7462567e1c26e6d2177df99f0b9d098df1c6d7282ccfae56d4e6d2f106f16bd34dd8409f273e70bcd41a8f699b8e2b2112c50bce1b35362e302339a8bef933d867459ff672b902537fea729f5aabcf592f5b237d8c4a5b0fb6527b5a433f369c4f2559cd61f1c43c360fa6c67f56195b53909e476dd9bc9f2c3968815d7c72dc7541e73905045e3be5d714ccc229d19b69e0459760ca7843e5e286cfa844a19d53bbc3caf0160a5226c01560c938adcb36aba3403922b19413391aee2afaea4e487e38b06a6c16afd9404438e9e2ffb5a7bf5e96a999c62050e7277b6b8f8519d820d05e457de97a778f7a646122c4d34e0fe04df32276316010bbbce35067d621c6cc70f4d9c1650184f5bc17dca85b83e85ac2bf7d98a4ceb91517f2cb474756e5cbbb654fc6c27148591658c93905e44eee1308d58251e88ae35fe07719f1688b5ee50c4f4ea48e4df80c15de8846590f360182a6fa4889ef84fc68e0b5126be9292bd249a9d19bf8b58c52cf976f2aa24331ed7415ca5fb63d01bfa12a2c482a75dec9caa0a42da9296b78e6cc54c4adaede2fdf2ac41e6d2f36238d6f22fcf1a53ccca3988902d93f351e2d67be67d73d55e0ba2f527c9ef1551461bb1541bb943bd073a7c7fd23c306b638eb3180c86b1644bbcd64b989a8ce7b3f20aa1a575f573b34356f1b77760f19d52bec93f15a583736d0fe988ecd3d0159c75ad5d5c9844a8628abeeb096bb6e1d53748f08c323f3d14817bfb32e17e2c6aa817c75469604f2e14ac905be3e43814a5fb3be8c960e3427b5c86d3ddff87b564a33f449991b4d543312d0453983f9f38906c96af2d133977080f42a840d14f88c5acc2d83f59d4bc9141472e8dbf16bef883d28ec8692f02254def3d88871b80c691d1f8e81918a2362bb588f4a958c193c1b001a974091069fee3c7845590df8697899d6a29dea1578cfb54fa4f25569432f7ec146e4a6ffc8b97149a3369e7683c785263a56584d6ed4d44047b1d61e4ff7d5c507fea81db945d6c22320621346fef3c494878446ffd01b92c45af61879d21f8066b3b7e2c2281d6f1f085f20b247a22b752e6243375625affcb0636c6ef5928ab1e1aa79581c6eea007e6e905eb698afcf73b8442fd24cbd77b2471e7280b481604d5d0d8f8aec993bb4762f5445221e94bbcfc397ab11b44d2c3f4b5b32f047f78ed56210072f275ea833e8c818028b23daf94d7c5465a2f91e0bd62c74d7ac52941b8732ecb6d39fdc93bb9dedbf92fb3b9b4d712f95d4773d6f075b0739c1064809a0d6bb454510e211b4d9f1dbb35e5e63c2991018932a39bbdae4722c3a73801e7655141921bbf6f176fbb54e1acf291ab51ee174689171798995e2de324a52f071b2bac89a4a567e0748051f74c25694fe7a5b898b3a1088f68a562d15a0b22dfaaf0b21029031088389d9ce1d014c88704d7cf49922334fffdae0f627274f94add751c975911506141be7e35489b14016ae98f577599d5a839cd223c371f18d6c091e26770e52a472ed5abdea38407efbc171c4b7633e69a5177fd85a347b4b651dfa63326e7efccce8d9ee02f2d183970560fd2124dc9851bab7682e567521a50413890d54f841288f3728294df0b21652efa1f44469f75d4cefde156470b13d0434e167af1a6cae9e0b9c7a46cf22f48ceec95aab1272914a992dd7b2b6cd770013d7cdbbc5b57cc15dab5bd5e1d7ba5d337e0972b784937a7455e43c52c8f72fd3f241830d739c9440757ae43f79d16119f2f1ede4aec1c9d11c09a043c2ba5f2c0b58423dd3b043735bcac4e0e1333e2ef00387b662393b58edd8fa2388b5c5bc53b144984f214cea8d0d5d62ddeac555e6e7dbf806a40d622056698fcee31043752107dfed2a07238f40fcce6fba037ef583ee8c32e67f949654abd06e13c98a613c0af8df2711639172ea4ae2c4ab3f87ee1a724a3a7e82b795a1d991bee1633702bc95e6569711cdd2257c3f7b9713ec6aa62f937b71f2aeb695fba84cb939fe1639f50812480e357bd5cedf4391979e18b9ad029067c23adcd848c756d6e0fe413f27240e4693bf0a838283584e3df6bd5fe51e361116ef3f5c0ecde54b688cd2faa1e62bc047a0ef11dcfde6e7198a8f346c5fba53b0e9567af8bd8b1547f7feaf11a90ca241b44fc558bcec43c65697d74e5d03db8e9a1139dfbe7f66bc7bccaa5a6507dab1c94746a3804c4acf830be6ceb26745fb56f6edae32449eae8bcc2381f8e6d8d4b6f6cdc4f533e3fd92cd8f1f4c74943bb0aa36f507e21d9b0ddafaf16c8df4b8907dc9bfe40a09f649036486223564d61cce0e7d57a7a2b182d62263b2c473b4659a793a4105dc14b8890d3babf0c7d3db58d8856368384365c3efdc5e2403097c7757cf9d9305377bda41bff021040f55fae3674cc8eb33cd6e36a011848bb090168013e318e6d3b337c8ddac8ff296f162603f168add0dea9f373187d5dc08a88790faafc71cc0534f7ba7eafec92ccd36183ab2f0e34095e51c6368a5693427e4638c2749787a1c4b9a1821551fcd68f142a9de58a507302d22eb2261d6c6ebe8b1ad5c3acd83e457943be6f2f430ca102f6f496ed80ef9441fff51b412812aa163017b987f8c984cdc7cd0f58ba4e1ca683780b6ff794c8ea2cd637349c410314d7d45525b72f45abe8fa542a5046adb00ad858bbaae49469330a9bc85c420dddad05f0ef7316836d073d3579aaf6d1ce86e3f426748a49934faa27316a682b3caa4a439413d5aaf6bc17f4fe700d5ef16aa1ae455f4f2faffddd2287cc6473e19d8f8cad507d4cb57824e10cf10b4ef4aff0233af613193a8589589022876e5649ab62241270e354a47d8a449b5cdaf37e3517bada397a4979bd0d14324d0db29035c52bdd081a7e0ed00506b229614e39edda48cfd4f4ab80ff93494fab9ee999ea998ecb2d06f716fece5361e07ebd4f231aa296d14446c14f3702ad081b1c4b7d6b4f73d9926d2c1714aeab4b9fb3f72fe0bbb4fab84d48e67d400d623aa30e22239d2b8c1aa3b776d1897921483a89aa0c5818d1c71113cc048d3b2b73e0f27644a31dd71bc087c4c593ec22ddab492ecdb94076cb69f34d72e2c552108e12ba2406017b47dc3309765baf31d4fc68887e6f53037ef90b6e79cb873dbd2a316845dbe212855384322e25538f603b90f84cfe4a46c212bbe949758d06ce48416497b9c9a032afd0881a556933f9cb9e45a827d294ab601495efc2bd5eba7fb25b1f5e2574d91f14633af9a47bf79dd4113ba714994d3d5db2e186894fd81236436ead010f490260ef06e76329b7478143821c004115d41bdd7811f1a170e4e7f6c654d3154bf666d438242f3a7127d83a18bd53971fd8d96c64c88c9a7b6f1723ae0fb15d889df8320ab5a86d1645b548f1d688ff062087c5e6756d690d8269c2d14e22625a584ce68c140a5f0ce1cccfaa9e0d53c972c26f2e2ac993edb3cacd8648cfa7fba493e4c1e3b5e82d6077e790c71a84ea9b2b7b9d4ee528515755d1e32f7844d80383184ea2399e17a7773c4c3083217de0402336353ba086b818967b5200d145d06043c21471c853955130d2e97d93fac80f5b5dd01488a6d944b98b35276b1d08f3b8528a1e3e67f5e912d4e978d28b9c42ae546b1f0c80e807de49f32cdeabda88447e51aeb77ac3bdbc10075947aa47d370092d71310ff8f7516c074c59b08a03450aa5dc4d076d705de6e4aa7a87927199e0d68d2751552699aed7ac292ccb3a7dc8c0a108a0106cefaf6c26538c2a5bd1b8caad1f2d7b3bbe932e6b877d614e4da9637b165e88fd6ad051e49c41ccb4a7f6477756dd71004ad87798ce115e284da2b9f8683808cfb3a0a0efe9ffd5b658483c5a36a8d3d47ff5c06c48fe9a4a69232f81233c90e79b078f5390f4f7fa545209e020c0af4d873a00631da30e9dd99c5ab017b292195a6cc7453897e0f2ed40ffe1ffb674909912645a3ae516977e874b68d818488cc2a71ba8d69139503e07638333df4a2e762b2a343bc439e137b16a9def1912ceb9361dddb71afb7f7db99398bd36eaa3175f98aa321b5bc10709a2216bec898f09009933f249021bec742593b60a4a23222b6cd754dd35fa839c121558d1bfde0ea5d8684cf4c70f85f1853229d195f7ef4ab23437501702857bebfaee6693fddda7e726c66cfc5fce0e38b69d4c52acd4863775bd07cf92cae0236f2a3ea35f493364a9c31a04bc326d3a556a20b0d904db6511337e6842e6276ee0ac2bc528f851e43eb5def547cf4030ffa91047a0b6245ff9634eb4ce761e95cc01dbe3e629ddf3cbdec731243d10e89c266f21c2c6ceceecdb7b99820a91579eef65a94d902cba78da308be3e62fd7c5830d86be8d639e36afd6ff74d86ee3582e6a64596219022c12c8b3f57e8541e5c8fb8aa5538193f7894d761f45903fde95d3a491ca058b8a6830c2f2447faea4b68cb76d023f131297cb5426370ba01ac0bd668d663a8d9243005bf36fd034e29882c0af9ce947290317ee3dbe6256006f42cbdc8cc58326551e1d818487239007aae38403e95954084b56b9007be7166b602fa021c5eb59e7e97966c366bad73d2a7f46805a72aa21a6be3114dd15de4d3dc751bcdd3ba170f77bc1701b6749fc5ebad35468a646c4acf977109815dcbac6e53f143a5f2ceada7e702e8cf390c7ec388c086e57b391e851fd0841e85b33cc3da915dee8688e281afe3e800476a9129326bdc85a95a476d38b6e3fcc4f35d3da29f284112241355d3539adf24b9b388b1e4d0184a1d161daec114b441ddce81a0827b95789f231784c87c33035b679c390e804d1454659ce61c010ee660b1b7717616350ffa849e208cc5eafd38a03983f28928e6c57b3768be8fd44fcd161e46655b31f3a9d8d0b6186ced2ef2085d8952176082bf5b23e2a8414881d20cc4539569db5d5727d827b6da68e9aefc67f03bfebde2c83afea5a286e2a73cb769b6b4fe209fd5b13a80c5e19ed6781c128fa4a6072f3e9c14a51092ba9a809cd0b4fc37ba528e532cc7a15d6d18ef815abd3a29c10bf62a3edc063b054a0b7dcab96f83c2f817095784d10e008083ed8dc6305615e22bdb8898c12908940072bc06aebcb30ee8c7a65c412bf434a4191ed6d22aa63e96cee9db6ddd8160c623b362565adc1d203152260539dfce926bb27e1353c9d6e0167a2652fe4efb53b7dfb62d517a16eb269de5837758fe99ddadfbb7165becabd619b1b7bfebe551a4bc546b7fb43d74637b7763267f7d517d17b0bfc2b7611e1d738bbde1077a75e7e777e057f0d08829cb355a968388db67be06cc263e859a97c241e3ab39eab589af926bcc41324f5b7f63dc5eefcf75c2e53aa5c4054d2574c0fb341615bf80bc5fd47c360769f1021a971662c06f17b29ed63e9e2903f07fc746655c19bdaa7ac4e06435d7e07d670bcf9c3bea65e1a0c9203d7e954ee3c16ad3efadf4c0f27e27d8588226a94156d41af14c6f2d1e445497c7899211527636899105344768acef4bfd903150dd30611ee3b94a622fa3aa2f5f682e0c723578b1f87c360672906561ed2617dca10eb3298f1c1b144f78dc006df66cf57174366764ecec84db08af5223178ccd7e03deb0e81ac403eac0c2c5b6114d5033662c424ec48eab79d796dad31d4ea066fffbbddc30ad4ebb5d3978344f557a8b2b46e7c9be8e83c30287e204db00782991fb79a470d97baee26ad54b4a4a9557b834cdeb470513a92e17ef4cd64845dc85cf0dbb238ffd13054ab63cb1450e41b52731178e97f68a879f95ccd091a5d289af9b6e29eb7d07f292f776b14b4fa54a20a13a6dfae804c10e6af65b1b8e65160b517f4a378a139ce893ebde0353a6b68f9da36d5301168e0be5e7ae4ed3540e434e67b8a8e73da87773db6f10d1a5d3c7c93dab53ac78108f1401db4558f4c9a478ff709ddd4df16c5749ec1e21e709afb6cb565a8dd9ef0040f50a3361a10f7baff12607597107bf0f9bdbcf98aaad3a15916f95831dc56e0cf17af25b62fec99f89096c65eb874ed3989ba060811a0562c3a7bd0bed5a74c5db9c4658a59d5fdf3c87f9754b165ba247174dbaaa1aefeea1ee385dc37dc4c22aa767092220990353d68c79f4fbfec3b3ebe75b452613bc49389d97e9309166c778ca42b78fffda280311c57f7322955d533a319799ca276c52d43bb56b9d751f40c06cdd655c11db7710430012e7ee72376f77d3c1b75e07334f72b8619b7eb35de6e95a23874576e1d72be3ee236bf545550a4574412f64ad0506ea6d0051114b8b1ac0c02337c0929052fb595280b032c9ce0dbbadbd7503487e63d2bc04f71538b07a6fa14154c2531bc8873922d37f1eaacf1cbe74463cb85588cd60992adcf2d95b74b1df736c2173f28c7d13687947bca722d2235357591fed3a54edef850e424588265263aa1d60a9254a0d2d9b9af0b5b5e3d0eae9c6a761821b3deff00905d34fdfee02908215b3711a3a0d26bd6064d8eb7506fced72d301958807df8d682d0f6e359258e7cf4ebcb0488952273f643c66f7c078a53aa7c14cb6b6289e7c79930cf6e1574af2b7fdd8ab563d7138a509d6c2cacb9c173c8cc1538166dc1ba41d410e7273c33eac99578949358cc52b5fd767b26b93dcf2329433405e54b48dc0a48a91c857752562e113432c47549f69e92baa7ba093e6b6e967efc8f5379c3de6c851280d2223c54bf384a23229448ba6967dfb4e25b155c5aad7c1543fbe9e565afbf68956bf2135acfef599b5f17f1fabda5eead30ea1e3b81543f77f5f2fd86cdf020e3b633affca1a90fb933cfa1a4f4ee90fae9b1bdf801ec2596bdba0dae63deee0a5cc8039d30baa2ce581c52eacca8e844ab83d135a5acbdb64f124135b5e5f0b70519f3689450befd5a4265809461b338ce0c9be4ad6a11a46fb391a600d4038bce84475af6933f836b2398515480e2cf76876bbb94a9b99b3468fe0813a0b7ba49c734febd81cd044f88440fad13e0e281200a57830ba7173dc01f799ba95307b385d36e6c074284cd79b78eb5234eb4b39692022fab46f8042b8e2fdd674d6538cfab0fbf355547ef9565abbc4d7fefb6829464ce4005e4ac17686a25d8766eb774627f30e69ce31e32096b30226a9b61a86f643ea8d40560977707832c5a05eee6a421dddf820cfdc1679ffaec453aecc3de0c66777b87fffcfba611685fbbd6bacf706f3cb58288c9780c731c986a12581aebdde620ace72fe8a69ef3ed419dfa29ff07c86698f9bac8ea26253109afac059e3d7c6e982502e732aee9aa84b924362f5f1f653ee9208afce0e18e8b97aa132a1ffeb079354a695fb4b925e08931722df0d8f3891c27dbce8969c75b214277543e1979305ee110af3c53de2cc3c1ea0297c54332c1762b8c2269474bf3779fece47a5b321970c2911f39fe4cd4fe7a688ccafaa428ff1be93638ec6b1a603ca08f8a7d4007631ce7eccfbfba6d52b3da446ccc2e960f345e21943a2391f387be371ac3d30d857c03f366e2d5026e55ab50f3aa641bfee642d39143e1c0cfd77b7d0837a14f3181d3707786a9fa079488bccea398e2ad0f596d62f714c1985de4ef4d31559da77333a2a51d690c5252e6f82381a102852d50621e5e704b98f9e3de889d60046ebf42f51a2f8ad2dea3d6f12334a4775cced863cc8f4877905f72758f7d6e195d1e595d9ff0e36881aa593b914cf76628bc14e1cf1cdf422ef4f73881484dde73a89c0c458dee488848be629f39e5cb182ccb7b514745c6728879b7ada23fc2d734a3bb5ace1c4fc34cae1ddc509bb021190649e1cbbd8b6bb02940344627f38088df986c1ca24179f62eeea4c87df73fb1cf0e4a92aae87329565ad3191fc9865cc4ae34bb9244c9497ea47a721ca8646cf370612c3eb664f56c9b200d13c3d3dfb5bd3c3c0f81657336ecd2afeba2814c26feee3f704045d6c2ab44f110980865192a225d8f26f1e4aea1f070faae78e45aa9c644b5888985c9f92207ecaeedc35566ec0229462cbc8fed93a081a5fdda0dba005ee3677a4eff5ef713131a3d4d862c7b732a3589db010369e6b362c4f0ead5800139314fb23c3be80cef499b0b746c0a5331d0fe95ffabc1d17ec32ebffab719e65a13250d66c3ee66821a8866a2a149b0ec0a49e8d1abfc51c9fd2b06caab3086b1c9215a82dbbf9cb80111d5d41d6a5f8ec472b6ab67159bfc4a3edbdcb3aade2386e830aa27720146565eff18a280b26608ce47cdfa2723ff4dba2c543e1e96206d7e81db28e2da79e5de0519d2bd239ef3c22c12c319fc866904a6c6dd9d84f3c8268c0e52902a5687efa9c24788da38f47cd91d2ab13f1b55775f1cda2c1b0de6e453c932f42060817fd7fa40f95077ce66ddcc9c2de6ccd466b696e1f26493f22e63f852299a93cef4258f69828ca609bab8b82ff2dd10b6a9c56457d4af2cc0958f9d65318c6cce4e1a2205a15ca67d53cdf4933f9980d3e652e9aab458c982aff494dd41b9f1faa04b283c9d30bf9a76e052c3fe9c6dce8139db86a68cdcd8037d7d398235ccd5d7c3d0144c7e814e93b17c48ccbfe30b5e3cac1fd1e9369cada578b5302b6bec5dd74955ce4fe772a8c123ad230b357e6d197d6335c13473f51b961510a6d81f7227680e44628445fa602372a7b77791582c0538f2bd92fe0a71020b5543ce5b47abe9fd29d400e693c3e70537c516a40a174caddd3279dfde44b30a5fc263ee959d93236070afbe6f72ba31b0f53d48e0e5087b97deae3c594155f121defe1fca752805e75c0b3a3807dd9fd8a84c99b36c7a4746f96925623a7d8adc801c54a6de01d20f2f4f1c27e6f411803f1eecad8634c5ebd3f3f2e23b1b98bf2ec138c49c347f44eb73b451aad08b78ae5bec429d742f8b0c4ba534e2d919160ef73a01d6dd0b1ba4ef83e44594318a09c1b495d3efa4691941509a96c0de30cd42906518cdb48ed4182a89a0b4bbf7b96bbdd96c2f34093cd4fc7f567e5e7a23aa3fae32f216bcaadd5aca0f4d7d1e14cdce438c2af725c4d1592b85a1fee1fe425a76776a8b21b68d98257f8a1b16a52a22c9bc0184180600143ab68eba0075ebe47228700e1b0bcf2164e419b4f93a0d6ad603ad874c125fabe48f7a19b25cbb678f934e20f1b8d94cbce1bd6f2ff251b8fad3c34bf2230fa8bfbbf8ad52b70ec8fc16c7786db4b5e1ded7a48df666518269ad6db995ded64985e112823f1a592dd0bc3cf573c8e6b3ec512786bd5a96774d0ef4402d8368c867898e4d752e2ad1ced7fd17105956295c27ad507df1de6c22027515c50324c1a55e87bcfe78d4a43648a882a1c52f2bc9825af9a69879e14b0f2c95b32e1c86b3b8403dae84456871e85c4970a2e76e3664f46e448585e2b373ac24b6d6a2ec1bbbd580ffd53da516c6fb91ade61b72f387115c6bea3b17f8acf1ac43f4c16ff3a2a38bdc0152f01490e8497311d563cf117e1181166283ee096c24ddf2d516f36994fce08efff888e4061ba80c1ebefc24a03b8b4d6a7aa98dee1b4e42ccc3cb77681f350782c660f3f33fb06430b84f7debdccc161afb5ee758ece39cba2944c3a9e7cdd0daf3075671e3809e3756aae407313aea0ae2248296ee0a53d5e53a4d4c5011ddc60c62cd56b2d1b8a2cb8da76eb637b98569fec72514ed57bb6d2c66a9689d970966078da27aca4682e29bf5db1b2662c4db594b110787f09b605eb862eb04410523148dc13781894b320d4f62e28970ec8f92ae2475dfdd342b174481d93f199b7f5274060b18ae0bda499a3866070346bcb5640926e1ad4485f98bf4d5a8e84b27b970b28c1a9676122cc661cbcdc9a63e9e2cdc77660e7e24e72aeacc0a045b33eb4ef817b15ff4beb48b444789d3a88e1e2a76198293fbf1ca1b6a3a473fbeb21a74f2c4b9ab26b37ebdf88dd5d4c61e49d43278ec69215bb16c28f233c56b9360619ca5183f5328acd04a3f4f2d2a9cdb47f3494e4243f5906c2c073c538fdcf5e4cef9d5f87626d01e1e2b477d11a3f1ec4c61f60ce7e6c3baf7ebd77d14930c67dfb713477cb495324fa0c1e43d887040d31a3e29bad075f894c7766bdf8c4e74550ccbed8cbc2105858eb9a1b38a03d1bfaa20fe758041c001f7dc0a53eba855dba46cf646e2e9f3dfb27641b11fdec8f52762ef77b835b9d68b3478de16e0bf9aa3e97d64aa07d6b9c9cb989dfc715b6c105373281a671a30ba9fd5ec90f8b179d33e332744a9b6cc33bb7f4f9add063f0420c4c8e55a1904468101be3190d69d81b55bcc181801adddaf9efb735797947464f4711584a7a41277e92610ea52f27ff3c51d0366eab5812c11ffdb8b23733636e1491ce95be6fbf987602a6061b6e20b2fed31823971323fb2ae1500962b3f24ac3fc053bc01f4e81eead42960a7438e9b6fd0daebc43aa9a87c7486efe1fa962769abf76c91105a1cc67957340bffeb276984b0ad626f136504d70a9852acfb932cb12db2794f8c88af9bdefd4ae7dd088b342a7f6ec6aa939e5b7f990d2d96a2424f378b9cbf327b3523aea2cac61a2f0f4deed5eb20f36bfcf9dc81a569da3ad7bed067b6513677a8bdc3400d106a8347c81efd40076f7d92cb899f00e5ea37bb3a419aa72c0e9ead2042668d110cfee87e9e79aa0849e03794facd51c2c118eac04605b4eee37dec91c6ba414fe0c4baa86557277625016d7882cbd4fb7f7e7f5c4e9593e1ceeb30fa1134de6f772d00657531cb53c344723afdcc935a9e0a5453e533d594966d95c89d71a6c2fe81c8041426d7fa8138503fc81539510a590910c3d74f7e8dd958adc064fa7883fca29fcb50e3bc1fdb28ce038e131ecd0fe549e20bc4b1173edaacad8ca6f59b6b7924f754ae3828eb3098361afb9fcff98df94bdbfbc99e739661737747ac9f70a21a34a55a272cc170e6ee794f6a92658e4482e1859e4be3a62460b299cc9e1261f4a8cfa8cc55c11adc7aa3852f0eb522bc6a4efbb998433a309e2a9ac87790d64978a76a57be7939826c3bb1fbbe3e811b48f66f35ecb410931c20b0adec4d4453e4c1e2c47be7ca7b72a6ed840ab8012759604c5e5e9a1044cc00704e15677e2033e7f86ad7d2d38b3bbdfd17ddd3e122c9219148435fff8b0ed0c9a573bbed99fd87cd045ab7bc9349f174a368f372b5d5ff9867199d9921f2321976d69760a86285c2c99bb2a3f5bfc15a7d61c78ccfdbe3b652a16dde71a79a55848bfa15865816dd94db0600a5b8f7082f4c612a1e4ada7d1bf09f8b36d47460baee2e261a112ca28e9ae801c39896afe1642f15b69c936cbfaa97de2db79378978ff8d8dc9f9704c7129a7d3c6ed8354c952248a47a821916355e78631fc56292d843cf1ade3383557ad6cd415de92d0fddbcdb010e9686fa0a1e11100dae116f7aabab444a537d6060300211ee9f9cea1bc44c2cada945c5733ee85c74a896e64b48f73ba707fb00ab9fbbde64d4e79f51057248c0cdc5f4360797443f4c5b495079748895dc95502a2a35aad40e443890ddb4f2726eead5be7e7cde3bfd36f2b4d59265f99179ae08f9613ca7b6b8739a58aa5042b1d73449c4eeafff35fb7fd5e83b65567fc373dd0b9f13be3080a9b8c8d8c4864fdf771d7fa49c353f6d7b6b4b047774507f79c9fd8007c76db5bdc4ec906928823a8c5516f314ec4330cc60160533fcbf816ebea5dc7aa0ca134667903c37f5e0eca4d7f6323908fc54c20606bb2b7194ceacc8f8e68f27b0b6c543b1286891048c531641ff3967c52d72fbae1900ff98aec29768b0a279e0a42d478c7841223f45fcc059b291cd52d28a5419577e0e00054ff39cf1b3e8e1a111aa4440cafc719a6b9ec62589a3975ca2809987d66a49e70e29ee21c75dfbaa96485e70b7c5cd5167ff0f08dbdd7c853e19dd6da68e01403537308e421846d1cb2cc14f9824964322bcd1f8b20e61900b27d3b278498f13c434af2411c16ac0df6cf44ec7782c6db17ce34b4b44481cea4db777380682686030af875c1667e78d6f2f0e00faf67a5dfe6bdce3d377cf7d7d9d934a248ee3572d3791ae1a716c71f3c99b0e20df85db40465cda8098d504523c0a9f31f9979813866fa034ef94f715d39e188fa6537f8455b4cf0a7d3692115549245dd6b546d28169defc9efd6c8e166e78b0a27f19cc4fc85ac3c8182f3f9067a4c5ef1e604cdc23861c5063c5c084098de137554053536f0f02b85625a11621dd340c4c16f3279a41db7691cc79623ab972af335b757c335478178db9d360ce202403374a6fdc5b450fc6df3714dff26e022d94e555214234c2d5328ff89b67212777fc6bc134c73789b94aa43a404ea39d29db96fd6e11d4602cd9adda8f82b39ba3340c4f0d496f648f7aac0f6d57b67654569e224cad2033506e1576d77f7aa85b586a9f2b8afaab587f88e5cf599e71f6fcd216fe37931fb80f492a1c84448299be789dc4cb3872e3277332704c278e8561bb485b2c288b5aa51d7df22ac28be1ce278e535ba7f7362b59683d4ebc649dfb00570969ef7e89efdb7dbaf5f19a0b63aca7daa817df831b00dda6c16a99995d0f5d32076d365f42df64efe7e6d39b31fa3ec55242309686efd317559b0bc4468b802c3a282109be9f261dd9a6587090103fb5117e57d2ec9d0899febf135fca74b6574fefe613f0a3e1e6116657f4f75e517e661942c988c96914144be5b958fbd14bcc536b25e69b514f4ec923d09965f521b61b729b0f7cd618368c46fded4f3899bbfcd76c71d6d356bfa7c9cb05ea377710d5ed906f5805cb67079e5eb101eccbb527ec9957c7758216b9a4be1bb942afb0fa24d705fe32df0496fb47dc6579c4257309f9b4dd51f6182c153ba2a36471e849ec81ae4a2d3a7bba8801a95f7ec86cdacbaa78d4e2ece9af92a7b6a7c8a2b3557c15e965c5dd6a3d7d2427e098118817cf29dd67edc07263e93da865dfc9a805cc38073e88c02fa6886fa8c2bd35f604e0551d187939dabe00ad144ab895c3276d0977b2a459e2083e5b14c8a794d3aecc8caba29b32708c35977922482645ce56eee18e6ed2d752492fcb3afe240831c58d1e508bae0fef97e92a5d0bec3d871067ddbeac27acdc3ce86528bf88c38bee623350fe6d5b50991688bf33e742ececbffd75aa8b0281de68ffc9572d1439510f393e966af53681050b53df9d9393767887fe37f7c0f5be2766203418de6fecd95dd57b5905f7d7444a7faf60a59c74e6eab6f884fe27650f212ba6be4ce74b65381a7845ab5125bc86eaf97a865c380fcd0d5042d37380d8ddfcad561943eac4c646e15b42528a5ced98a6d7333c4857d7a35547a742d06f6a7647892a5916f29e58eaf323df776a4c69b185df54cc6e51ecc0ce5b2355b58a57488356664cc02eef2122e3582210d8f85486e7f8b7e0fc1230af4de2a16f0dfbdddd8ca05243d95884cf0e8a51d93c4805aacc7d5311cfbc8f318a234172d5ec9acf2f42d08e7ff02a1219689feb9505f39d39fc4620fd8456bea92e206ae1e84f20bb0415c4c73736c8cfa5d7727ee39f59ff57b32216dedfe6727327d380cd48bb372c131714af66342d116e1b3e996d553f9f5d668156b38881ff247454d0790278e365e0b50f0d9a7b2a5dd8eb597e6b444c85a59ba60f4d3b7a8c6de693b5fb158c32e336cd39ce71b09fc5a50e9ac606fb82ea0ac77e3f8377c1f2c9652c48aa1002ec27e48e14fa5763665491eb6dd30922205e9dbe1886a18acca5a13209e5371cac0403a7d6ddb43066fe5a8d7a6a04476ba9aeff00bbc9614f7c6d56c957f1a10420f9e518eb50217a246b8aeeb9502d13c511e8a0c04879e4ab5a56800d045f50920e7ad578d304cc6333fe8cee9ec5bcfa0cd6c959c8a9761197542d4896a18d37fc6657f7c24cdea89ff155f5ba26ecb65fa424d6d132417c84b573ab821e87566dab2e5954347255892f2738b8d7a4bcd7db1c34a8a1d20b10ac132d4b452ea87832e1e21c7482333e8eb1a056ef0d189ea4c236ef8d0fc9166ccf7579f5effde141219832b7cbe55702458269a684e95711be65cad5b68126bc513a3c332a3b3dfd2331e3154e2ccfe2564ee74cab0fc0376704ea0c11e159e811924415bdf8f4a181ef519b36016e6d0ce24af7ea6d8b38724c01f9ce00cb5277a2cda6184f18c8cd7aa443b77101327507d4774714718914f6a506de023702d05cba4afdd83d870f22de7f9d10a2b4b225677c5397e65f27304fbac377a5b5c691d210c2b6f67c84f1c8dc1a3e865ac75f1459a9abf2847e48ade50d6ef01300274a8ee285cce4867c996d4137b0ba4a1f179181c522f1b66f7818c8b741cc8eb03cdd621e1e475de508dfd2f332f951258560bd266edb4bcb4f4b2e80a72d418e5d4bd46f51ab1f0e233203623f8d23fe287669ff5d16625d89c64f3686","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
