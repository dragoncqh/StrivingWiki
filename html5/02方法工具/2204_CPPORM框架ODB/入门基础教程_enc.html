<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41523a729c0461825f0f10d55552a40aae12ebe8bf87edd9e541d66c8acdca784ce451505b023af83cd83dc6a6c1c91de2303663ba444949b606013eff164a2b52c8f464804ffe4421ac0ba945f458d7f7cc174b388ececbb7ccacbd67bf7f4819470e3dc50f2aa30f86c3660b65a06d2b41a80c5a2967c331d7e3b58856aa0e7dbb6a8f4ebc2309f2176ad6b48b1ebf5aba5743bca3cc161afa5313b41109b9020dd954c97eabf73c92af59bfb8a9ee2798e9e890fff5d7c01a0e0c0087064988be31138cc080a439670690e41aa5ea16bbedd928885a0e4eb70ade3bb9b196a980cb9349e29a6640fe949f7d7d3431ff2d11d59ebebc3cb88a648d117b338c4322338fa86ec1018e053629f555694042866cbf05c59671f51e1f5d3b64b59adc10092b4ab3417802877a03a9e4c9edea143cbf451706f00b70a53ea6ad9843d6a05a8e3277a8a3771483874ab614781613455488e5b3b2d24b8ddf3320649fce79b11dfa6213a1ea302559de8ee184673d3be745b9aff957486f814605b030a4662b7fc7979fb8c8e28b3c4b36cf4ad050362e78a63b78515a4b194e8cbe55f037f62a3b3e77364259910e2dbf34d50f761869a27839597b80e9c168ac6059703e6656d854e7aa8a03c62af77cde092eb1c2fc735546ace352d69660a20e171cf277512fcf5cd65d33bb0576b39ab23d5c1cc369d442aa373125cef7b24414b39931de8686c95da96e33fbd97dae4875c4a2c2f4f5471097c23112abda777b4324fed85843e4bd0a9fdde867499897d42cc555ce70c8ff5963f99922e3e9002403b7f72ce378ef36b8ff77aaaa27d62e10a57bec9a59ac1fe6a5f670fe6dedeac3fc978b985a3daaaf8b99443a7f707ea8377fc462a217ac9e6edd8c1bfc0a86542b9d30c3ce83a396e54091671bce083f0ccd4483b36292e270c22624fce0e56f2368486db5024cd94949813b96668e0207d33dafb5b8c86f18263abf8d5df7a443ae73bd08d25ff6a1121cb974ce4fe28ff22255d3a24f74dd34e13af976853a255abef163bfba55ea2f6f4f48a57b38967e0c1ddffca2a29a26bfe71b3ad12b3af1c5afb1bfac88d8e119d4cab593262885a7c9e10c09631eb58c61f776828101eab282163676c5ef38c087cc39e2b0138a73de90dcd00e28ae9084c51f0220f231f59d5214ca6591e74ead92db8b01c642ce84fe00e0563109c0bc3b98e540feacf2a5c9727b10e61d2b150a60a988e04fda9f9c245cccca9d01cee5dc12449727f779485ad43db075dac261d08a26bfbbbd308bf7d2cdb817e65363f4848123249aab9eef8bf0b21445ebefa2d00af3a30431a09274399aa17011095a8ee9cc950b804d4174ace82f04baf6831077aaac995ccb3461d697bddcbded1f74e9960bd6cd937c72cf802873d16b3ffeaeffcbbb755cee00c065fb1f261f698dbafcb2860e2a53c27083952ca50df00ea55d0d5f22ac2c4bd56f808a2d8b3b92020defe3ef00ebfcb954123c39097f113c7ab994b5f683114b6431e143624b14ed3c041cff0c25e4d3256ea15cded6cc4bdec1f21fd785d0f7118dacd167baeb206f4ee03745c16e6c7450d59ac89ef87015bc8305728cd4ad89ed668abe9a119620cca410908c9be887be03dfd648d841b5533cdd23e228d93829d8e8d69d1189d6b7edbae5f61a92e552cd04696aaa3e1660a519c796060c57415b97b816056c3767ef9f695000d61ee87d08f36f59f47cd6853dddc83f3e8f419d7fa7c93fdae2b0e93f25c26c7abaac664244d042a912f659eff1caabf96b13731622ba441ed2aad286f55e292b176c3c7d4da9cabeee043201aa3e5a4674090726d0d7be4420be705cd31be69b92548d243b5bf2f685b47eeeb4dad7aa726c25aedba6c092fdcfc584daff8e43d64a51e10f5644dbd09f965b280f2928f8607971adae44680a2356b368f915b0b6f0b32fcda6327b95e30b15bfab9c849d95fa7e5467602a3e884d8301fcebf433396a1a15a57e4699c4101e92b8242772786f057e81e062a9723333919aebbe502adca8ce85f197042e53c960387616af23f4d94e22985f1f322c2c156abe1c923c69ab74d562f95d1cbcb1d602dcb9528a7028201451a71e25ccedd56619d9329b65284da542a21ee9e58655497140975968334ccd7b719907f2df0931e19420bfdb3fd454bd8bb5b1d1e09c37c4d8d70f4877b0411dc2119300a09d26645b2b0cd91b23c95bcd475d6f2e628c4a3f8c63c4421aacb0bb4c00e3777d7c4d023a51a3c1581c507ef9f5c2af23937d63fd6f57eacc921c505d5e9f512a5186116dfc0788a4055ce235a1ecaa2237c9d06ef41b9fa04f69bbb5fbb1ab89192940a58a6eb2cad6d50de4dfcf86e48bd35b9abf597dbb6aba10de4a721ad34390553e1378cd31ae0bbdc3fd841681cd60887322e19a614fea4688838d177689b283036eddeec2118c9581a912e1ea34289357075b558dd2493009af8c12e7a6af5484804a90f2e988b986fa2731f93b852508a484de29835b43b2e0be2b026b81099eea734850afa2686856b86593bcdda8df76c091e8dae952178565e6fd375008e64ff20515fc47f2ca96a0390581ee762a49a8f980df88983da2e3266e7ddc23914958441955adfe51352a9e6f3d38e62350fae4b177eb9e44b4414314b9d4c49bb6aa1fed862b39ad47d2674a92aa2b21245bcf4b55e90fdd71c49daa9eb0564f3271e3ace104ac626677ef4e36bd2912379195870b8c3f3eb2e74a6787c48aed13c055279cb0017c32c09f9fbdc57d81c7e2278161e4bea89f3d20574f110f6d64b90fd03ca28709ae827ff7647c05e328577a7d319c64e109d7acedba4ed3742cb1c39620a97f5a109a020761cfa3c1a3a4786dc5dd0b7d71f3decbb57e37b5c4bec54716a53bd6ab7e3fe17427c018c41b5e4deb109cd0b4f7b447a7a61c2cdf0cff38383932bcb213dc9a1fdec1ea4b7f062cb97ae532a4fc81cf7b04641b491fddfe3b0f68c835644ae5207f7cacb319b1838f0fcdcc3e0aec4d9fed6f82e93dbf58aea70d2d3085310d435934535bc4b139ce2f67ff5556b4a95ceadb9de0d2870f1a1467218e345670f361d43450ce40fdb1ea4fc7feb974697cfcd09905d07c402eef1445eef773b305025625bd100117a9a60ee7da699475d7f51c228d6b03ff32ec91454e3accacbc70d5616d9306e286c3c6d5060ff57067367a67eb3e525a4c244e44e68269d5633a87ffcba8cdb1864ef84689ab2ac7f9af1c7941e31a6518a9d5110b10ce22484a82c7e11e132ce594a68a9681f4a3e1651f05a87a51ca58e19d39ff276d7618aac9c5edb6b89839508b14133a5b4712ce5b256b74e6722aec7aaa3bbf115b2cf2b8b269ec38c64b84c25b116e36a86404da1a616ed473d29303821255dc3a62947ec13c3c7348542e48006e37db005d8c42a201f63105512edf1c785fca2f1752e13c8682912096e809b023353c27747b19e4fc72ab197c45f0cfee498d903cbe028b17d598fed02a4ac717470362c66af5b206f818631c15a4877887ebd35902c7aa5c2a84ef91dc5ecef238e55c0425de0104f2102ad6848d579f7297a65fa5cc0b151750096182c6b2c04bd1521518ab1dbc1e3a8711dc2f039faa26e4db1bfecd54e43f08f7b2d3a417fb154b7e9169a5bc47d6da7d591670695eaa1e91cc2ede69a3467f8ad93494b4273a08a076d08bf997e301d109faa9818e065c38be2543b1f7501fc75061e51c57e957ab24cfcff4b3d3ec22c7a3e7bdb05b92014202fef6fc9b04191fb711424e2f64476de97ab4463c1f6f3da3377203f9f81404a148c5db5ef2c812213e772c40fa60de255b87ca8248a47404332b420c0a976457470ced71c81646cdda36cd4352e19a5f3a152b4be69e7c50edfe4178e7c225d6f12f04508ee223e26e0e5b7d85aec91d2fb4333c2b0f1f92af62fff34c906f56d327658afb481067f907d9c3daa33b4479c7bcb9aef09660ec132caa56a02c2ccbcece8fa8601dabbd90836ee97b177e6e943953f97a876d07595fa3ddb1b44682a4361d53203bab24c378de88997d35a1621356fb7563cada15c2ab83aeace1ee15e6edae4f4da917cefb80666416d72442ad111b850346cc8c15f135b3e5a0a7674ac8c505c092dc9d6326b682ce3b03b086b0c1656650a23879b213b19c9b2a819652d2355229560820c2a6fe40ee330983e9991a0ec37d1e9683871316954e1e850552d9129d6dcc8844e217794d478366ea18f24db0cb87b310e400fe02d5003a2148590a254ba35457369d1db959e6a60d90270eb52478810352fec02fd465445e8a320945620cf2322b958ef56e93ac567cff6078e7fbd0bcb5132e3dac41f0d36fe0d9785cec1fcace5f73c7f798ebd156213ae30d51d1256698af93eaff43a9c32233648520f732e4f87cb7c4e7015c061cbfbaac69058aca73d3b55b376f708ecf4e2953074f204abd05057a914efcacb1fb1e32bbed6fd42437935d5d6321438532ef895c69030c90c3944d829b0daefb2a24b2c70d6cdcbe284aacea7efe05fcdd9fba5ea2b6643b37f90e71c964631e06bd0b3cb72dc7ab6b19a3395fdf3f8d8bfd25dee38774c4d642b631284c57e1736994bfa9677d6fc77da999eec9b30573f7bb42baf9e2f9516015bac21ea704623cd77d18eb65561b5b7055d54ba888cebe22d88e770c027c1244a93d5716f151767400085e77ed997c49daa10f5fe1094babad47c5d56ab6496ec82fdc7055290e43d57d5110cd86da4b3f81f72c58cb8ede81542ffe618805600d3bb15411dfd0851989221df1c994aee77b38b7eddebedd72d694446c5beedd4afecc9cf6670a2aed80a0679e7fbb130547546c3b212479b4a964b357dc98a5815a65cbd177b3bb4e35760d25381d919ac19e5b3103ba18a55990c515b211540ce6e076d479888130c9d500a019404d42d0943ebc6414f2d310d481d5b5c5583d39faaa629b2995f109dbe509100a420e6a4c2c44dceda3c1909ac655c3309549dc793dac335e959cd91529edd041903d92ee0ee0085ca408c17fe4cfb08c41adbcbe81ec22c3df292911cc33f9dcc48ac843a8d9ccc51c4a05463ffc01ce8786be83cd027ef4714f75d2ad4444765b1e8e73c3fe895025d22be85b55f02e3fd7fef9541b76302c9997a84eec12644999f843a651a9b950890496f603fb4af03ec2d4859e5adc667ba26bc6973fa6d71f86c7869087fe18e64deaa11fddbb2fbf842819c3d367961e01a7fc4cf68626534f854f887f165a11c45763a668e6c97d0252049cba2a35e1785ca72bbfaf3eb49a7711b4b5fcc5a9dac3c35d6cc20b7dc3e843974bc046a1bea40c513d26ec3270c54c25fa3b09e593d6879a1a89ef2bfb6b65b647e50defcf0cbc9e8b5d1f3bf52e7dd6dbf9a2866be5a5dca1986f8c00b23cb20e83fefab9808c8fd61010a0fedfbe04fae28a037fd181c867576ed8a1001401d3982fc8684d6bcfdbc07ad0d7cfbda15d4a386c95ce4925741fd4b332221f30689f48dbcea183b03d6e1f60bf06a2768468fdaf3177e22707c4d9d92bb5fc85faf64b58958018616b08f36199eee85c3f1053a4fabec905774ff1faa6e6f49484ac8a865f36f396133999f98b1191d5e03656e4af4f692900dfa0f0a497f910673d690d191b3daffc3f7bceb2859cabf1d9b870d9fc68a9122366f5fe5e45d3967b288384442b6fc957325beaab20cbae8959d006e522d835e5f529047ed0f514845dd6752449a740348c16679ec9a026086448a9a8f24f6baee19a6aca05380b47fdbfe183c216da506f76d27bc9c7385f6737a9b15351e349836afd1b61cf942a259b70282c9b12713ffd4d1c3ddfee1582025a917bd1689accacefbf73a4d171726ba48c175a58c055cdf034f3491c905bdda81e796d750fa9c003d8b03f0f17aa9f974d703f60c86e87c4f6a7a2191ba7bf371fa47d664b9ba797ba63227979083918e36ee925ec77b7ee84c28a0a1a024fdd4a8fbca21466fd14bd2a318dc6527f4c38f9a89654ec95fa41f88d883943803e23364e1db1527a9bdbc1cd15f7484ae152c41bb303391c3323dfb31587b2e12cf9cf229f2b8d0914b498683f4ac2d3adb7e6737b9d4e578db3ef7b6a94a21b49f16e83f6e53fa995c98a3ad33843d39b45717dde53f9b7be69593d6ca0296a0394d9d2bf75c2ed34e48ce90b88a4e69d708221fc86386dc20f6011d3da969da73ee8c99c5e4431b5c05c818673c05e2131796abefbfb7a25a2b438465b9040fb950d77f5ec910d87c098be44c4377a61b1027e6f5351211bf69fbe7d39d059f8ba046790d843bcc0cc056f3e0216347fb1e637eae037d6dfa5dca6dd8a4e72e0d4e7a4b530fe93122fc9319c544d135b1eecc7254c4f4c9efb21fa8cabf48fbdcfd48a0b7afb7aa64466536595034149359c4462a71059bbbf918fa9f11815899ad40da0a2a31d43b505809cdfaaf3c0d75a05a1f20a3432b72b8513aa2676479237e189d6354ba12cb7d7a3b257edb6971525f7cfbcc30c8215e14f878d3611ec0af927829a6182a4d72d3418ebc7ff81707ad28ec1af9d69de727f8fc8e2d549488957407bd78e8b15f48cc931b23c5cc6e1d867920624022aad2aba01e21283c270ec2617985b55871fcd237841ab333ef613a0ba93b598e5467c7589b8dbffa2a757f78c86d77fd2e5fbef774a2dd2404ae76a46124fdda12676a19f1554dd98bc4a74b3816a2dc553dd048b67675e8223666eccab58de8a45ff0ecc9a7a9fcd72fa23b171dc0be4d25e6fd7bbc15d094886e954d3075992a424e1db7f2f1aa02f8eea84843f0c14c4ab3976328f12361c400d4da16b3bd5ca667974dcc0c73f884e0d11f3a743fc6b8592818e4ec97a0f72c69b388759f6c3834603c71420924bdf1c7322bddad5a5f344bf05103c4f29f0cd2ccd10fabaf3e57a10908f40578a65aaba6a65df1af85ea0c78bc4c65ec072c1b274f674306aca67a35bcda4b9d526f293beb1786fa65dc5a081ffb9c2c1e418691d68316884ead6c6bad0b88f27f510ded0ac52da41ad3b184d2a36ecfdb265895964eddce187b5feecd17fdf6b4d0f9f8d430acbc65f3ef879e73e07368281ae36cf68586bdc95d296a402a235013a037baa356dae5fb2922dc584e86973a313683560374f4392adac862aee0dfea7860add95a98de2cb3ce983bcc448f659ed62e689dd4077620f08b49721ec0c8dcf677633b4287315f6ce38f6bfa490bcae208ee34bbd1c1be8170526ea55b3ff6fd9eed6f41e5cf69fe525a64fdc91139a1369e4ee6d20b3b316b501df6ccafa32b85989cb4717898d3e80f2519321208088f9b4e595b1b25fed688075591bab98b7fd6a786a66ae618207bdc3824eea17152e32f7c6ca0bec811225f30fc41b170dde25a86a22dd86dd24d8fbdc5545fb47cd4e8928a384ad387fa83c2cf852973e038a57b88470c4f5b52a3a7c2fc7e641d3290f7ff9081333c1996763231b637a0c39fa66e406efdca7dc9ea470b9f22106d6dca374d84f73f02fbb7b4249194dfabf60594506edf52f8781f8f79188fcd312dd26be5889a2a95be35a78da9188fb09414b65b7f5e32ce02ae49d77b016a7e562ae2f66fd0e92e5ab7e308510496b9e7491ad1b742a64c851dcef8eaba58f6b20cdddc206ef644e5b26b662d02e56fe577bfe052240cf5375469d6980a2920bbea8ecf643383af00f9846c9b3ae1d22c3b98798ec590a4079fec4cd440c39c2cf0ecec5d9874f0de7ca459141f378deeba9cf694b0de381eefcf9d6c519dad6a9b614add14a4936ff44596e329d4965f9e84ef06b351f9e6e7f93fe5b6a3c1452c539c21e832f3e325ab37a2aee4ea68824650b1b168e21adc497c92a2530119018eabbac0367f76b54bf75ffb8e7df9606162478b15cd26ccad46ea3f3d0b4bf24281df3313e47cb108e824b1716d1f23421bcfdb7946371913a85f3c9de402cada88022461b202b94d09ef3ee6d49b6a545bf01b0c9c09d7068cb1e55623e495a59bc94b6cdafd2acbe9bd7e5224a649c97ba710ff5a70c681058caa74cfb4e8b88920521acc263bb4c91d2d4837c92646fd489f271abd9bcebf928f2065573b97213b96e42aecb44324cbb5a9be255e19e7e766df993979d0f454bd5b67d33c0694558e1e6b9f2568a291a269114970bbe64a6272e746e73f84c951d47682b8ae77a3d1798362a6fa180a92348cf8568a5626cb986b69114d9a6c2fb9164cf1de461d2aa45daee63af1ebdcbbc73e53774db8a42927d3408f44971034e738b97d443424755985f789548808790941e7a65c1ba2eb997770a2e0968533097d0767507986120bc2e182b7f16a9ee869c9ea39eafbfbb5b32ce1e8351547af9086c3a9be4dae58989477a4273adce7776ea2ea5590efc7f75f83fff1c1d7e789ef879b22c8bd335edcb33c0d4cd7605542e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
