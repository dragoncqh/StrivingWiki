<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaac81180d80581bce0868e5647274c451d202f2e6f8495afe4ab079372bf24befadfe2ea4a9da63e9d32744a5ebc3b57d49fe4a60b8761fbfeb094c53cc2b7270f5e6e1413f0bda9a23e1c3d925d6aca27a64252259825721b968fb4ed20c9ea364e5a8fa6d06e0173650267c03cdd5e80f27d908c7b31d14a0e2c7395fc81e0ec56db8057307f499115324d0beaefdfcc54b277c0b11efbc67905fe5c35b571e7424f09e71ad22a3ea50282f5f68850a57857f77898ae9a240c9c43759f4a2034fd6404999c1f0ed6a71192fd4e23b0a1574f4478e33b65570b7f61ee265e5b2b41e30b65b712e5c60eea53e1bb323c284da78232caf4045c53de882c4781d60033092eb177f7f31722bec8072d457b4ccb22c05cfb6fb12e095b4395b0b0725c4763f4631b35aa1dade8bb4971a1c86ae1c2d6ed4f997598e2976f04a8a5466b10700dfa667af3daedef03ea0e541b9518190395c19ad7e28495618609f7ef1fa9751e35e8b2fe3dab416301b13f71d7c5bdc433afb4aeed0436cdeaca7a25e45ef9113994cd8bf21778551f0161b8ecf7fd545aeb82cf7e9f3e023a32f8a6a339f104077f4149e01eaffde70c28a8abf63c4954fe78f0e3256222e6dac4135cd4d4b73e9ef40aae74d2cb8638f1fce261b0daf3d3fa0972881a309dd917805cc37f803445f6a7eb82fe066d3284c9f282b450a1363f1ad1f2e9fbd640225890ee656613edb3a1cc7669ad38f64c19373ce8c9628b570dbc2c499cfbbed22a83c53db0e6ca50a9d7a4a1bc7a5ecd23e8d32e964fb65c88d2651a3c74b0af718be4a2af7dc9bc2b6f47135a14c422542647717515a82c9a76e7174b286a461b6d099b6b45bef52181c225345f03ad1f54a394916cfc0eea127b68634073743a6a9c1e6bc5bf97c095d7ebb46faba9c6f36029769fb9b833f4701c1b36927375d060917dd6eb862dc441bef56f790801c23a0e72eeaef58a8175728004c5a910c9d20c495f11f9f597e677580ed2426fc28c6d80a034c23316ee179bf3a407bf2380c4ebd76f2323b8e2fe4cb61e29f61238fe354c342fca4671945c7f5f4d560b51676124f9e339d10d33847c7403160e1db617417870d7c9ceddac25f3c1cd242234bfe1cddb13545f1e33205e479f33cc9e35e54dac2be0e61661b6add8ff07496fedf0a11b13148eba6331c1829e420ea280f7be5fed7d7f70957eac49ae971cd7a041e7c45f566176ce535f16e36200f39e7dd48088d5cf8bc91ae9a2bbcc21091b1834e51079fa68700348b3e13e1ab3015c7f294b5394bc87d8e6e47b16f3eac1b3dc6a334f7eeaa798aa9e14c7c9ed02d2537b9b708c9dd4e460320e613780c507ff71ba0ea3e8a0a8d9a3aa5ff32ba2054e0c15c5fdac4891b1257f395eb869262a1a2bebb1447ed75d2f24cf1c3028a606a989828d766968645fbce0c340bd8d5c06925a6cfea4f64d602f983342d4a8183341ec638c6ed34eef91b7ee217a84c1867dcd3e53944b980a5d6830756a5f50b6c89625d1c7ce0d4f89e5f3238e8908700f6014ef7529d678455726e6b0dcb9d3b1d3ae11505e75ec5acc78fa40895170978180d1e44c3c6a513c2e278f058b05bf64e4ef05c9c69f5728c7590d61ba0b6add839a7eaa145d0818c2e3f1d8bbd2dbf39a407db32296648fd8251cfccf6881f06669f82043b59c60ce6f8b52b140d28c31e5582143fc9075f9861d4f15f1bc2223ca566c1bfcd93e8f47de2918d849c99da0ebce9c36d844344499f10be6c73ee4cc80ee941e9663b2bea1eafc7fc9d673bf53c0085ab50418cb89b4aeb7a420c05592702c6fdffac4155d24560f579bc7e281318cb741c37b3309ef1461229298142477dbbd5bc5d9112962f6283dd55e807b274c3b2e409442ca6acaba48f7f1a15f0c6e65928b4c801ac8138e7e22baefad7f82e9ec6c55a2460a74f5441d0d6c3c32eb8d697b0e3eb75a63a21b07b51bb94ba849df2130faa92152985d6f2d122cba45362d01cb3a711d39c40df8aa3d824fa7b9724f9c7987bc2b638f2c95cd3adcafd4ce707361a611a6c269f6d7777339c80aac28cd76fec3d703fc2d836e807798e2963fbf8ab148ebfc8456e4fb1832a1e15c2ed06b6196219bb4376c5eff62b3922ee6e6ff03812c8752491d2eb1b6b73e396758fcefbf0a330d348f328d15c023d4e0ede615e31e79ada08047fc5c5fa104831179fc85f49c3b4d7bb9332794143ef8d5eb358f38c4523a0bd3801b0901e4c9e6de31286c2878a1c9d07c8b093dc8e5e578cfa97679a53f89d7df87f032a9d1031c6987c5c7a71eff7a85bb1d5462651e4b9859dbd056fbffb15b4f31bad22f143d0b40fccc8e1362a82d8deb36ba7876c02121e16b9d2f6a7c3ff2e4797716a8d0723738405a73fc472edb4c73438b922f099305af783ec3552eee28576262e855bc1adc77275e91dc81d014ca7373bcb0e99293dfe6c21c88fb1874ef4a59ed923bb0c218b072461db8e9a2101443675219b3aa1994a81be87a172973b9e8b36a2838897493b74ed2c2d1adbaf792762f07370206a2d94d663744fa598b195546a35c90b5eb9e0dd1d3b48e33deb7d621308acfa0507e0e2392646880a8fd08ca758d4778899d03d49708b465755fcbc0a3dc99c5c4f992ff26fb93618b93194f1a0ef22c36364cdcbe506fc97bee7415c249ca44f81846e8bfba45e773575c560c6d71cad0b10ccf2e47d88e04366f9a1d966a3180419c62bcdb85e252a9f10786c15de070a463371b8b39163a85b4bcf1e8bdea9ac44c5696e535590a7670ad1fe04e1a65085d144dacecd68d20fe6bd22cb268d71af4d6a3a3d748cf3263be12885f8ec8ca5256de8accead0c4f284a13dd71e3856d3ba40a321f6214d42fdad5b49cc0a35db847b3c69d879bfe0bd1387e8b3a22500634ea0001cff1280ebe2bcc1a5c0c64a8f386e6813f891c357eeb27202ea66c48c0210cd423b75681a7e30238286c83b4aa2c19c5904bc79ca8ec44e414e5145991d9186663c1ec1f2ef1e16248088bdbc70827009a5abd4e1cd8c3736c58942f1fee5bc53ecaf21954cf49852bf88091b2e07ec90000fc04bada54f81633dc8bdd7130bca0029156a8b745e7a810522d0d2c7615f521fe53ca7855b4b4b01b6f43604b8fb69ba5122d75da58b1ec82a0cb3a2f96397ac7276fe0b7d2e5d24ef23f110fa842d4b735f2078ee8f67cbe6b0d8180c7595020a3c459c0308b0664fe89f13e6d72fac5548a147d9f7a793b1de23ed1867caa0c5bb8b51e68b7819e90d63c9e2873c58ed77fa22f957bc89a2e3b13f1019b943f0157385cef07552497d44b2a663ba780710eec787f17db81761e492b968b0f42b767c4866cb4571e168cfe7cff1f52ddd608d63cff3bd37312d5d04807c664ac217150307353e2df0e8cfe26753d4b0ea4b5587624345129e6b8909916b48c70a69cc35df21c9dfe5de3061d65cf03fbe72b4993e50ab4bc6cf3e99fae48787c3fee36a1019ee080feb806fbeab6fa128a1f3357f0cfa69b4f08f9961e48279150fe636f633546fcc55db41f679e4945304271e68a4596e97c81313d4df560a025ad299ea0ba03f65ad222e4f0796c0ba514a41a4e40777088974d563851ac6fa84266c430e282156de50db5ff90cbdc7e962a81f6b114b6727f1d838f7ef67b1deaac5cc506769e90cc748ea664a3f439455cfc4f29c46290f249a3236b8d28f62ec16714ff1bb720041ef261f030419329402475c50691a266b023ef9701d0a96dddaff9ff80616d94a9cf84d0b277887a0b5c5243d1760e75bc7c51b2b3c75cfc7a00ee1c0cc70218bc2dc8947df662a5b2defc603c96d311d6b117c2584250b0ea21ceb6762f9a699e98fc4469531bc17a3c5849fb41ba228d23386a2d7bc6a3bab965242e0ee4320b4776359451c98169583aa6dca0f6d141a5532020e5e93538836d7631eea22dacfa0521b6256b1979e07f73952a9580550d7d4d796f2e11c92531576d94755f60135e3f0416ce12d93a2de69514c6f6082805dbcb7920e93dd4398758ae658704db43708b53b7bfeaa443bb79a17f30eeb82b8c3b2181a346cdd31bb6a37383b1b3df85a78d7ce315885925bffedf2d8dcd3a3f8b732a7e640e80f850c8626bc95116d4b2401b7aa66717818796e5b650eedbe8b3a49e19598f2ca5839ca936226bd39894703c0c65e7714d0edf89f1205a98a952c5aec024052e25062840996630b036f6e9f64d054e691cab9f37b65ab320477ac24b0fb941b7ebc5402499829c4cc78fbbc238687af1e69991a19399222db39d45b653256d11d2822c71d9cdd95936df06272b2eb0818797829c6d0821c3de912971a527e36ab37f02f9e2fb2d1fb0df2a833ff76b6da4cb3daed69d93b773fd5dc32aafcf59ebf05d2f4e246c79b4bc16a11bb852d48197b6e5ddb6c44bd7f6a5f1edad219087370f306a671925e9186662116c262aabb2fc3123918f1df787ed1cb0b52129933cf9ce8f89b5b41fa714be02c5e97592dc149ea1966b0c6532888dd0c786f3001eded8b956bc9f261420141892df1e3c774947d265bf47e43806f2be73d0c18ef7727e5e428d424330bd53a72c9470f4771b4428857bf5f065df9356687788d1ae85b5d8038e004aa0ccd4fc75eff86b26583ff2cee75101bd8eae1ee8f38dbba0b6286c4f42b3aa36f25d6a2706a350345de7dcc6840dc26b31ea015af2a9729371d154162d48b59def6a37b09f7148bcdcaa0948d88a13b12322c6b45f9bd4c0cc66c2cbf9c55382a245b418e608495477c5cc97fd6377ce6ef91e4b166b718f7080e6d4754f1f06bddcb5133d9de21d4a6b401b0df924876f3e5549bbf4bbff86e90faba44365987d5731c18a12dcea0e2996cdcdaa8f2f07aba07b06804a6fa58d4dff1345e81443a40808cfc428cbebddf7acc4c56562c52a095a345949158fbdd76994248e16be9c31f7010f388306f8622e2705ca81c546e2b6201705d6807538dacfc1e3725b84a388ff6539df39deaea4752cbd9ccbfc1d834788f4b0f01fc49ada697999a1dfd066eb2455da9550eec76c09598ffa2c8996b2f3dd8cef395b360de5e768e09af73bdd521bfc375b401b523e90f8f3b3d6926eb8bba2452635ee180cb60b782e29d1f9329e4762ed2af2d12121d5ec45ab9a0ccff06e998cba862d28d49fd938a331d754a7fcf2855a0777331f599d984003c848b8eaedc46791558165475345162f9378220ea9320e4775d4652dd79b2d89ce201de090268bcd217d7b89b36f400dd4ea73acf8f85d83ee6e87ad9b46f5caf82319e66f395813c06e87d4e0ca6183e25241de0fcad267bff7166a8b053a2d60c4ee28e6c91a83aba26a1d8960c3e820a1b3998296064ed3bf4b4d38e14b7b70de7e053ef263befac10e32a7dcd33f37d208cd35cddbe8bc08a352c4472c0f943c0ad87d10398e65c1e7fe5f246103a662304bef022c124d26d3a512aca015e7660eb0729d24114482efde83ab32fee9e8365b623fb8caa0db2e886f80d42a0dfe1a83bdd3b590c73a33261ec1cd534ba6ae64898b71a29e589305aa74af77bb78c262be94c91f418304ccf8610f58eee0cfa089c148d0017f2087396abad793b7517a50f33a1fb9bbfb5621e94887216de143770ad7e04fbd30d5d57fe8124bbe29f6df8b48c16bc4b7132d5667553c4f32cd409754cade259a508026cdafb7528aee4827890e77099ec27c38502b358f0438eb3974710558218141667283a3717182ed74a2bcf45840d860ef05bba0ba454365eae937a71865d8eea8377b8a95c89a51e2138334180ded5a51a9d30e3b99d356a47a285a06e53ae2f139674d4de404f197d8cfd6c9db3ecdd2782eed050ffbd16c0b0e9be3b8fdd0c1832c059ebbddc2ff94c6e009055417cabedfa68c269d43008a6b5c06475cd930c276de3e80d9cc93915533de7f1ce524da192d2762fd6f33c6ee835bfb57258bc93bdd486435ff0b79299f53a04d6f753cdc0f51a9f27f0202e8fa4ec0bcf2651214bce9ad696940f284cdc9189f993aacfe514aa9315d9e2c7c08bc5418b0f888ca9b42aef1b6ea4159b281fc1380f022584a56b71c7e3d8accf1bd532db5aec8d9d13af1072ad207d16bd0b51f503bc42b6094140a1268eacfd367e46c68b487e52465109ce73a40e54ecc03fa6ac993a2895d04472d6899f576bcb67e0e4425f1b4542c1e1f40c66a9e8e70da8e086c82f91e12283a5616da5399b74ce4eb11c7ae63b2f17a628a573feca7f53d12c06c3c888ec352412864ffce7bca57693c5041d721f1811b9ecf4220edaf215f68e78e270321237d284c4190a1df879fbc484ec38f0840fd2e79d36a45b6f14afe7e5c47bc5ac9ff3714762d2bfe985062aee5176c6df31c2f64f5c3172191dd00065fe94626d8724b8b9efc84bea67cef036b0be1d32748a365cdd88adc1ad32c035a99b4bdfdc8a328e00189f0ad901a792d5e6974902dd8407b1392dcd55d4787b0102dfa90df161b0b4ccb6e6a07e1b3ae319b0bc9cb2480d6322bf9a2cf8dd3ad2b620784e148f6e664c2dd86545224122bfd9972a719d16d6a83d1a99f1815c1ce82d02cccd6b3bf294b336a9699b9a07bb2381d66a551d324d7530d5d6f28360555c7212fdd93fce85d945606737eaa167887b0b13f2ec412adb2647a852959e13360056dee3c6c5f889e67a32e6f581c01bb50a656a253e0fa9032e2dbaf5dd904cb0e53b3cb29bf01b173884b6ea5d190aacec4e03b163cb200d245565af87fdd8ffc17c03511b30c438917345a9b64491302b58d1eb7f3964fcbf6448131625c60833eb0649a045fb4fc928f64ad801f84535fb5141a29564b71b0bcb10869acc41e06a8b3ab7ab2ed83be615c9ae8a299499224b8faa8baed8d40fc440d132e115ba1232b09306fe70a28190eb3cefe4083ed9bca0e7dca924557ea5e07254925f83da4517b19cce01b2382abee803c42a8a6f0fc2cf4edcbbc6af10927a89e61f9f206e3d7fd69497d79395768073edf5c1ce0db1fece921a4026be029dc96b37dcc40afe9de3cf140df6fd0db354fbf8997e5aa666ccf8b2cca7fd9d4eaf049f940d8901ce8dc5a8a6b097a49adacdc8846446a5a04c70c3cabc8e2fda774435040599b97007385d8d62c7b50dee0013f104c083d0849ab91dd81b87a87f3125a949fdd7e1cc07b1defcc935b1cb9efedb33c9f1cacc3c5e00cbe16c071760ecbe435b589f8b3177a654ddd36daba354fe43487bf78e0dd775078cad90950aecf28b54484aea9fdc7a2e5777d18053709c4f1040cbf1ef05f731da87a2fc2ee11bf9ae82edabaa6814b977077d94f15a1680893767947e72f347cb4a3b5794d292ee7782ad2d894d09a08da14c33e2b3c9ac861ec3688d8889eaaf6eca3490c87e06308f73a05c8efc09ae304a76c0d9170ec83091d4b2507ce84d92a9a8bdd0e03ef68af34e797619f8de2bb7626f616550eba98e2c65543d8f5d54157b1b0adb63e030ae452d324d62b2b792481133cf602b709404188d510af49b50d6ca51bb16bc3b282680ea9034251039cd1c2ed777b7b3c15f343e6272af5794320ad78a904160d26d4d517d584d05d31b5064a32ae2206817eb35f25dd0e05159e9fa1eda7d3f81723cb53802f479f4f59e6711519195bbf45db7f1d4b60be27c77e4e5ca25a2f4c96242fb4991c53176ff0bf1a639359de2087befa9b01d35b27cf72dcf58f6146545371cc4af45e8a83d7a0bea17bef5249cf2eb33b8bea03799e271d22e6a71624942d7cdbb6864252a38eafa3621b6187903b00371acbe0874bb95a5123b1cfddeb5c75687c67e6cba2090eccc1a9d5ff4d073e704592d56a138aa74da6aeba1229423f576aaa9eb41bb75d5a4937d2a09b20f8a5515f7f23f04068df8f6e128ce9cf022a293437081062f47049c8c08ee1efb3b9e3eeb85329afb9456377b47117b67a6f994e3605b1e65b9dae8fc3623b081ede2a73f24f7ba4a2f72e84cd4f9c930dab8a6223da2dca0f897296be4ec01dc699ed4adb9308b12f01cb6b1cfdf730745804fb08adf20810308d1fc28d018cef59ad8cb58ad3062032399a8471243faa2d4abda2b34021b74c289f920b479316c3abdfe8b67f6f384b37b21c344b66a9a11369b743559043e176d732ac60698718e86fc98a7930edfd131c7a6d9cd0fea36051b0a124bbcad85d5a91cbb0a74c58fcfdf4ed7c65524d4e652567a04402145900b02b2f98d0245495b6b25b6fa9fee5268a4e0b8e11ad1f54ce116968227e728800f4f983c20f784c193004201ec3e3ebb6429fbfcb339d77154df26cdd6dba260a1195658cf62b248f68fec49123bd2f71f956f5a42f7cbe1216a82dc31d3c09a896f884bd400915bce3563e4e8d8624d35b8ea6ecf6c1e4cb085ff363261228729575965d1e8cca6fb6e38e57de5b5840d295e8571f0186fe907cf81a97ccc5a6da2ab7528ec377fd55f00b9f921d4ec770b5a08be74ee2c68a2f750604f78eb317bfc9aee0bcacdb98dfb70893b5d6654be5471d67f33239583f21955e942f55ad0553dd056dc6e9adf4053fc79867d36f55f0a1d2e754bfe9c1d106ae63167ce1309f725c75b21f8085ae3c9e9e5003cb60c056f08d19aa9f89cc6807219664261b26010beb25eb509b73ae013ef45a1c0f660e0a3bfa8de50e1f349f1290697a14e459f782275fbd6f06ab8a93d06e446b162b3af481bc04d1aa2ceec7bfb7cf6a0b4696acc898862d61e92855394d1708896a46691f19b16fdecc6615e4f3dbc8991a80dc34f4b7df6d2415f530c88ad6ab5abc80dbddca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
