<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecf8a015e00ea55be283d3bf24c1a1e26e0fed541bc057024ceea1c4887656be1691e7e0af7d2d75c3b8641670465ca2bdc0398d722ae9fe916bfc118f3871bb3ba46f2f43c7a66335f945926a93c8dcdeed017a9d7b6a31d93d10efc536973091be1b54d7798445718b514ba1217f128c2d169459783b1930466110a0894b523e71cf79988bd8ef9c9cb1950c4f6fdf12a5e440323a3c0a7e63b740f869ed0b1346f107417bc9ae83b24586b0890d1fbe1326f4cab5e0a588c0b4869f9e214cff0b86c4ee43ab9f64dc439c29ea83e46bc6de1383c800f9871a8822e2c8743208257286850d1f94fae93425722d31e2a68acc520eccb9afcd490bf39a5978b9c9269da140403017ce64d3ff16fd63b4f9f08bfaf4ac3ed1bc73b3f07655ccb1fe829a578726cf28c1b7bbb79953dc2a0f238dc7dddc66f9f95ff6fec624137be197aa9ef8c565874818bb6f2e64911cf95c7a6717beacb3aaeb351912ff7872196b138aa68f890d1bae097b4b489309e3b557e95405c9c1b0d0569c42962e9375d6ea441ec9b884e10d1e02a527abb5efa55cd6d6241adfefdcbe0c1d8c9d54ad24a78de5bb907f52620c8974771e616beb36dd08ec8c576fa2453b1081553fcc2ae2c2a3b947c3bff4a169f13d7b46d2b45b296845984dae1a379a1de0a78480c82ce924d2fe99da55320e57caf5486bc49f461a9b85a85a9bff8c3debd0d966c230dbbebfdbe61c4d1e8d5e1f60d4b9c79188a680278d7d84818c606f46d8c85f5a9599f7fd088f07b716a38416b5f86dc8db976f2538e1772c84df099c0ad1de83cd047f27f9aca1f02144466151b6953a7963abe214123bf26771700c075e42312ce055e10c3c5109da46e9fdd65a9eaa8f6ee54b0288a5a4abf8d1a81e67c5816e4c7b729470856c0f51c63781336e7cb99565c2aff918c975a4a5d9b81f88747aa248434253d6f956160026cc601f168ba3b10d4b6c9f9860b7f1fceb5136e5912dcb602cc78a40c4b4c1ff710d07739b52537766a9608f64c7b8d7dc9871262ca24f20d4bdd7699663ee21415232659116722c898b127ca767ccc5d4993a47c89f76803db00e32cb002e6c99fd5319d10bf74f65d3b09e8bc0820b368ddc68a1444a52ddc610d71db5ca0bc4454aa2e219bd2b961e9bfcab9a1feb53b697648f270d04ba46a82d738b4a78ddb2d18320cd3ae3fb6d28fe6d77ee880f14b30cfc7dfa41b10415672bcb4c5044d4537e7c712e827bae08f97104244f93cc2245e5d42268c8737b86060aa0ba7ee36c9349105c8c9c3d815bb67a3dc3a49f853fa71ef2196971b45e01d2d07b3d3a1f3cc7a2229264be9eb3c5d2835045c040b3985aa23cc0776541bcd29428d0e8e338f6962e98c23d79ae15b15972f716405a030ee92b6774cb9be15c0687b30b05ca95a538b81f18b7300db2b0acaa1ebcb298ac4748e8057a506a9c7bc0d11a0f455c739f5b1672fa314626a23300df9fc6ae3095d53de0f6a08587719f52923b40b8f2b415e02c6fbf5edeeb365f75dd8a4548e64e33b4ba517d56ddb3d9857ead78d8bfa6f5a54a3b56ab4bf70c60eafa15f3d5bc6d1cd3efd74748661b67ba72147b8a2f8c4149c9b645de3afcc4755f4bab65f4ba78a3d1fbd3146de86543dcb13d5f86650514386dfe788cba96bf03bf543288ae7eb118242e56df53e5108c9439a707f1cc0b9dc4a5db9a087184f972d39579708a64908cf9e7c22611acc5ccdbace3d761feea81e7a3434e7aae9f0fbec350a89b9832ed0ed24c9f277c62e6cbb8d02a7d19b5d5511f7f96fe2a48e96168f952efbd7d42627bb5d3c3eed4de8695ba26888f9fd159cdf44f6bafff5210c45addbe9a0677ac122309f409d1704771382a70d4c655feafddd65e2ed4806faa1bcf57d0ec86054e1a4b5ba3574d042222034d89a1d5ffa1c9fae8c651e9f7b28916f7faa1a2b9e978b5b82a48425b51d2ca8b34cd2dbbf210edeb34439fb26be51153bd2e96f3e1b097c53953a2bad2549c0032f1a31d735b7f68664119dcc812f843952f4abd32df88f1bb2afda470eaa296226d539eb4ce9d50885535813b81a1ebe8bae0e12e0148ec982d2350d378c882675d6b35116d38c8ae446835ad7530ceb2044b5508e0643d1e31968610b26cebe9107da23fa4c883548943755320d08509b2205588429e59382279f5700ee3379a8d4e5c3076c6883db08e823ddcc327574d8bb2fc0d587e9e52380b6091cfe116fa240ebb82f97b64d4c8f9a457b4048bd63c2437189341d38070dcf12feea830a26230bb01e4725fc5e6d40fa7f71de97c43efd0676814012f49cb6a58cff18faf830ae94f525b3992a20f7439f55d2694a7ce4ba023fe853ba9cff8c124f08b49cf07263f057444daa7b064bc46748ed1049c6d505581cb2fee8fba49fe9dc880d75d5312a576078946997bfd60cfe2c6ffff65b7b06e698e1de599e73657ba45622c20999a6c102890bad686ae5414e7582d00158744946926d6835490059ea1bfebdabcb46e82e278d0908499642028588b826637bedfb8697fc8d172ef0310bad30de611c4131914736706555fd8dc556c00da657dcb64e0e80ce039ac5f7332f25057247d2607769d66f95b8dd392a8265003c8c6b24e5b69e088223663c702e988d68e12c6bd6625bdd6142ac7d1a8672b9e53270c7ea04fbde2be7eb2a15541d1eae81ed22fd7477987e090c7f9b6a9e50a8cee25015906e1e0304705271f9398de2d7a957fc16ae76d4a4b77dc14f391cca023c96471697ca51bef5c89c40b919be7d24d693fc2f36876769118cf6de366d15dbc3923246d6d489de1b82e0ac4afda83b577e728ffbe8159d42242c9e946dbdf00055cdb0641ef8b463236f246a96479f298bde8828e3b1a448fa9798c223031d337ffc72418d5ccbaf7fd13a217a875e4995641b22f6435398b535afd0b367c9761cd59cf9429ff42571b426163b98ff02721488ae5e46b4c65c632dc99a7f342a25cb781876c8439aef145816a537d834f90b0b34fe26700333dfcfd1b24cb3ef0e8d095003c40f6c89b08c5d25735485049bcdcd1f61cf3f91a7193680b0ced17cf82f634b4ae0465a9d3f3e127049625badf66a58c343ca54637315f6297f2f0c6c0e977ce21377460ce4114b0bacc23edd9e62798b3d21dae40d6982e1eeaa65709dd7b5a3e14688479c84077a4a05d61cbb35c232a52693bb4e01ace2d8f7f5992a384addcfdb7cdecb6083b7f9179f7544bfb349ccda04730f4fc5714e266afd81ef1fe3edd2a0d41a3a02d3620932a25343a06e116bc8300579f622ec243f45bf418a75f0744f48855759deb8bafa4c68bffdfba0608e78559489a8405a29f6e63f10450911d50307b37b8ae8b269dbf946c20461f9a0c7c21e7cfad3804003e0d45b5f3c08584d5ed480e28b799fc9594ed511b1e9607d38768010943999d07614d179a94d7de7ffc5ba6a2eaed35af03ecf93b24faeee1b5b4f569175a91dd6305afd3370df4efdd640dc7cdfc1b542b94afb9fc517fc4ba4a95b8b20413722f58a685997c61cfff880abba8e54f886ee7dc22884d4d8ed90c8f331a96b00ee28e94ac929d093252fc3348c7289f46fdfa1cab2569a1c54c6aefdf32e94ed3b447d307c8b8b3e3f2ea1fc6014114ae04a010c078897635dffafae7df636805856757774c7da9948f728b8395e931575a35e3113043a1b727b0a3af9f9e3eadace3532ff3d9c20ac3d9b538299f9a1c8865f949257c61946230b97eee2d97bdbda55dbb64dc86c40cd9b9c8e46cc4d4ecb40e4eb582b87fbad90b5713232f7dff127661c9df96a75635146143e1c97415808d82bb4416b4aa4d5ce49aea596bdba8011f959fd021c35b6e2625c924b1c2afbb320557eb5fbb53a00536781364c804e08ffb93166773153f686610ede9546684fb13fd0c202907dd33b6a3a5e08e84e52dc85d841de76d098b4fa3eb45796da78c14ddd134bada35a2ff49ae284fc91b2703d0bf720826c93e9648a4eff4635f1c5652f7bd8eb3781a492f15b3c4d675d155ceb6fabd45594d24d306ff6624698d5eae8577d01e738ee9f6f5ab73fac24a8eedb008418018b07ee012cc8665253d781de8df5d78b5ea92a01838439503f2de12ae7adca220186d83d6d2de438413a821c544296d6397c7b3d59d0926943c57714038107fb36b553cfb643bc603d1d743c1508b7c66309adeb0ccdfb6569551d47f9566e9d2339a297a9b53f7b7d63eaedec821bded247c9643efaa2c10fbbc7a1e740e4cb352011f42e06575c43eda67fb9bbddac53050b97f127e5990496e44b06192bd326f44df7facb3911c0285348808a85f38641c38f84c7d8bbdd85366fcbe8930459742e2748c28f20f6972b9703836a390cef795afd4421fef8fda7d274445a8eeafb9f4ee31fb9a791a20ed5fe6f991521d7fb06108628b6d3b639aa1c0d168529280112e1171811f13312db9f739cec8e4baf0c611c57433edf5be7af5902a8b42e2e253d0f10f83f7f007b804f054bd378f34ca8343be712195f681256bb47df2b53c897cddb295e7b39e74e3bca603bf4341c2a09df5cf90ebfc25732c0062ef53fd8ea947689eaf564f5c4f36934669bd0aa1ac003fee283f98c17de3162146ce13f778d657f411667966e41d5da2d1d4dd7619395defcb09ed48249e0eb5b5b0871bdfe11e9b29f1dfbeaca0addb9ba62d4f1c78d37aca94697facfc7f03721baf25f10a85dfde2988ce87c84885359f61176c572c036a6a5f62bcc1425134dd0c0391e75b15b70995a014ced32f2a90f56a40c6079993f06e32a7f93625ceabdb5032d6994bba144c78af5ab1f9b301cf299cf9c3146d6577e58cd94ad5b60340f7ba402ba9943a2aca9a76c9dc7e732cef8a106ff2f5c63c07071300768eb800f0096b8c359e336c205f21c80626959a3c8e7dd7c841ea71173fe74fc1c61921cd2ec6f57f81b1d2a8d1bd03bdb3a07f78995be11ce218185be2e8d35e7e4541a9ddb81520d3b8cdd75374b6fde4ae7441b9868743d9d36c82bcd0122c37cd0741bb45dfa9a2290a5a94744ff51bc58d16db5109567d957d270479f1bf520c5f99a3a1070f38ea5673b0fc6575082fe8fbcb02b35b37c4f9d6757f0bfc9a0fd75856c4074cf7ce73f4315154ea8aaf27f62b7741b77e5ff1b99ca5f9a37a696dae8ad9feac3ac93d83ecbcf3ec6557272dd4a02fa722daaa04f541b6541774e4472d1d586bc762bba6d521e49d1d2b17b2b5880f60a1e93101acd3d1e3a73e35c141548aac68bb55bcf4c341c0f9d19cb561e7840845fcf78860a0ae971e3527dcf17d57bd979726fa591533fc601bfb1c4b26cd7d2f8cef2b33a08da6c3fedd45131351f256b08bfc9972554e6958486b886906ed2cf068875346099164270948c6bc7d5447b4c8ed3b1aac83a7d2fbfc0897f11fd7c4c64b29672ca7668e90958d4ce59021af1502875fabf61bd0200fab8749a6ea5a9c530b1f010d6a1abe533bddb1ae5f7d9a8a472db303101eb4ab9526c8ac18d3cb4f5d075e06b369e09f6870b70ed40bf8a8a252fdc6f1c127843ffb2119df7797d5ec1bed231bc8711c025482706ff2ef604c402585cbb3fbdeaae2312c1a89818a414a2e5c78d6f91883beba3d03d7eb3bb8dc0e492461e55f6fbdbca6672c0e9f90c3ab4283c6dfacfa844bc6f53c36544b819d9007d75ad6adf81f5be5baf3e863369705578e3075f86883b8bf8bc5b5c5693a46f772af0a62199062f0852a3c2cd3c01e6bdc375e89fe0d98a313eabe26acf49a0fe018c90fde04fbe610ea0df1a51e9e4054bcfb23a59c87903d72efcfd0877c79cdc8584685ee1d20e2471267e0dc84932958c9142db3348deec746e3fc7268ff567097035b72d7a905056534f4d26b11db1bc17a38f94123958e47250c04ade0bc3a89c0d85da20b35c2cad29899e5d31d1642facbe43868e4e5ca56a8e7d19f34ccb15ecafebe4aed423081d5ec563aa7ef6b6f3f47a65d36b6a88fe17f4f2d45381179fb5456e714472a98b03e8d9110e02378c507e25f89539d6bb20db3f25adf57aa1cb8e2b802367badccff89116d06aa96662eef9a2da0a7471aebb2da928f5dcf7e79b0280fba55e613f27f49e7caa07bde07a48e0f9aef149f0a0b739ec268b5e268514635b7553fdf1a38f7e87f73f1a8e6727ebc79f4d52bc2ad9a9f30fe650a3ba2ce60c79bcc9e69e4e9dae10c2af96ff29f5ad14b534e4dbcc4b1041d3312bf43562a5080630252e7d909e1c2f55a04fecb976ed77b737d099e1d35e22362b695f72643602826066971ad87118005c360ab3d72e8d775b6c6844a6cbeabb51602d48981b7ec3f0b2d8754346f8e2a1fd9f32ef4d556a38d1474be335ccb5c28aff5a99e7ace24c16cfe1f87657925669b9c5b9834aca9a1811c68ec2ab5442e53e9db0999b2a438d310c4a62f134d3dc48190b89dc236e821a9447e5625f5f20e96c4b5b5161028ecb1ae1bf1349e3223ca2cc9ebb3ab5e239f51753baaf10f4f8f31a93fad26e424577a954b42adb26afbffa6259d62b067445b98111751ddf430a50b1d43bf8716add69c8547d077d881197655f49c0048d8b891ec5b3f6843dee48fa2845de100100ee40606565831964e20d2a03a903c821dfd04927a1e74500df0314f579144f0edad26fa16876f8428484d976eab74d63f1dde23b3f588138afa6241f2631aac649a25252704cd47916c086c757e9ee80883c542566e9321106c93c58dbc98be17e04c7d7e741d8211885465c8d970686dfb1f226cc22c7e97e4963892dcceb6980a0be8558ac554434d7774904e1f130b4589501d1c0bb3d814f24ca38fb038dd27a99a368c7d6988f2b1119659ea465d170cce8c68aa22c9d5c2d2473da9a1b9948320fca8cb7c31cd9216d90a9398a2bd3f9051aefbf59cb04f0d3fa9a55187e2c2225fdff3155022fb39cdc513643a0dabef3aab3303db9b4723feef518d881b3dde6b077b539ef9b9bb34cf2b08639dd2be1dd4a60215c24086d9cf19017b954e9c9b86c0c8f013ed1d7ab747cba15ebbbc97c00057c185de103f44686ac2e3c065e3b3c48027b52426fe37b678f14f79e45da4f4f99c5da89a39ec0a0b8d09bbbe24cd7fe77241174e7b4beb9ae128ab46c836ed141cfa6248fb10894f2bee494d0f7668311620fc1b577b1eddb803ee13c62291492e28a275e740b099b6f7b209907de9e20ef0b9670808037bc1c539df794c423d2df3d88a0c2c155d717607e953083ebf16effb26c425f15ef4ce776ee7ea3253d6668cea6a0640f9b758a404dfe55317e02aeb2538ea0f942014bda7af660bf9836a06aaffe9c24b92b2412ff939e3cd7ee9cb69bf1864f36bb2f6abd6463573ff26a8a70140f5364d968d08a5d29a27486e54fe35234a53625d9dcf9149b508b0c15ba0be35703fdea660ff4a4ad5dd6b9d93e051acfbd52216cd90c41e6e3d9a3a2f23349c9f0e8a0b18a83c73cd3604c20ef87e8025320ee984e18a2f827a6b59bc05329361e7cecb1bfd1212c017833adc96d2d628221b0eaa8b2572406eb909af0b84673ef63eea5a454100fddb87f706e5b7e48bf8b41eb18bc97a35f24e9658c941efe5d30b7f958ffcdc9e01057e144fbf8a90b8e07eb79b576ec3535cfc0ada8582bf3dd02ea6bf0db27598938ddd2ff798257ac80328b96b6c9e88b2144a6266890c57d4dcda488197817b3e6cee449b0961a55fc6d0cb8cd2d4ac89068bdd784bbc342324c9330971adf60811e753f2cd78b31f6a95c47024a914454ca7577abace05c882a29a65d3acab68b30705f988466ade0eeb934e92c8442d2af91b2801ab1615ae43c3048b9a13e339c015d3f6f83dc66b54f80bb5ac909c36cdc44d1b02bb1f565f2ed2036398ee9b270e9a456edb6fceddb26451ce3c84be60b39e9315e167ff2099a4824fcb7aa807dff10eec1331714ec9450b85367fa93ce3af62d4d583626fd01a8b9cae58e3f83ab67b1b39eb3a56545901dedea50a57719f843747eaabafb0d7acc69af5e202d9727338339b79c4f226f60ddc93c0bf6c245dbef34e6821881b835862a811cc9579c0ba900d211ed1db90277470f8ca102611db3fd371443380adf35b082d692eeabd2294bfcff2ce1f5a4d4594aebbbb877ddb15e84686f2110dd49df2babd29e378f889cbfb6a1f91e0caf51d9f5d346239dd7ce9f8eb5ecc89344f8a6fbb27c0bbfb6d436f756695a11b8b5eb7d95b7d00f7a991f3b9c0e0b2f006e79ec96b7283651cdc09b7ee79bf898010cfad7d8a23ca717542213a9237df92a107f37706a4579f76da6715ee3d1287f543cc177d6ca0e4f5f29f2ff5918679c30b2c520b547b5644bef8215fabacbbf2f01018cf4faf88ce7e59a722d3c9c0c138004fae75e8de061c8b38db74139969e70f363934eccbb8911e96cf30a122a9938d7dce48b46f62ee0634edb088d749711f7446ebb484d55b6c7cd613e23d8f4538cab26a83c3e55e3a232e6dd2ad890b755b054b3a77e82e475dfa81c704d58a81c88f310ef9ea236d82d4818a1e8b2132ff5949a90f8f08cf71d54c24443cbbdbe124776d6bf8d33c03c9e0b2f99eeada4239d72aad58424e640e2cb1ca0af73bbbf1d06f4c56c25b9c73f3e4b71e4435281d1df9edbea327beca9b9bf7b2cd93dd525f4efac24957a657830ff5cfaf757b6f2320","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
