<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8a1a53807c05896963d00162cdca8df09d1b92565391a3e739979f958807b0abadfe244831bf6c0d9e51395005b2f3dc66ccddcc32bcb79c2bb85ee3020bd94c5e7127638d6011ba8c02c4c14efd32125395d4e9613167ebf782d1c741c7a79da408597aee824cfc7988f795fd8d2b9a62445f76d6d9d3f45000c36556268b2c7dd6d1caf0f3cdcc32f3db03d88a3d57103a88cd7cc263081bb893863e50607bd358beb21e1c009cabb14cc8de2dba57bc967fdfb46bfe6efdd258f8b99864b578c2579e4702ce3a0447e339e6cd97873ee19d0c1dea596a9cddb9e470377bb4e98974949adba26db3ff63c1dd8e283ba0be4da5d6325928e66191256a425ea3744bade424ee38a163679cae09ac0ba21a9461f00eb18fd60b109788b1c35fe641c67daa84925295eabd6096ff6d4a707ecf8422fe29d36eb3fd31f15b307006e150f3f54207d4603fc8e77af3532f8e9f4ba5cc8df05ff2a69fd13e58f07b5272072b9d997d5114a00d19ca500c64ad398bf73b7ac18923d691f114c199ba74294c9c0199d883b2e6f4ce0c2d39afa55f567dce339c542ea8c3d764327d686542821eecf1bce0974330258865840558ac347ce90f22821680c31937ebe8d64c8e5ebfced90903ed274e9de1bcddce1c7daa6d5938734a02b8af5b9cb973f263d1750381bcbb9e3f0bb453aef24ea160eeb7c6dfa0674802fc565962798a8de6d5624a01ed506d658340da4acba330afc721572a5cd2ead751662f76bb95a9cd772864a6d8d33d2c649eec4f5f27deeaeec3281b3790a51874ee6cc93ba365d777e074341970ca1c72a3121519e47fe0a5da1bf0c53fa4aa4db901efe2a877e38c208787987ff149162e7c63d317cee607ebc61a8b1d48c647848cfc93b73dc4f9e44b2071c50fe691266a8fe9ee6f398c3cf03cc2a87134e7d2ab6ee583cb8acc9a91b7380fe355c912e6e684afce83fb985a0d24dbb1035ff7dcbe29d78a96c8f2e961a43ce6b7a4cdd02a7be1b3d5340020ea5e9e7bf3d9f049db249c23314b254956aa8bafbd1b6e0ffbf21f5f438e0bc6b325f4b3774dfa828f76936f21bf87c06ecb6edac2c0f8eb1d675d7b4444b308c8239f6a9ec2aa7b7d0f4347367c19ac7154e92ba2befeb01284e39b72282b79b0a011a3a949079c9d81db96c633e663a97ff8fe61f5193171e0d819996b4c07374473f5f205de69636976137319ae2736812040390d77ec73f5df5f226383e140be850b2bae8870411e732c0659781cb0275c5a2a95b0ba0f686f5d70058c948b2e3302a911d7e872d7fc7f5bcd520f0455508689cffc4a19a1e50c155977f5f7ce21257c84f5fadc20fcfb83f3a37ab462799a60dbc8bb46de6902fc14c4a78f5a21ae32cb824077c0c96fad70f80af2b64dcc71fb39b2e21bfa87cd49b08def723020389f3926e82c18a8bb8f705257fc4ee33a1dc227cbc21f6e8d1a0365672f982060973d5b6370db8494504abfae8a155f3b62f33a956d2a99a3557fa9e1a19eddb7b39b6b62624b6fd511c2e62f46d07b54e1792f7fe58b0155c667847e2f08567bec5f12152e295c4f91468d174792455f17ac5a29f42a7d9d2daaef1acd62823d6f05e2c65301cad98825bbec222818df0f88f7eaad0567538a6a92092e6fef6d62e1b5daa8d7f6826342e5bad13fae78e78eb3fd520dec085ec42c944c9bb693c34bd7e02af1e30e7987e6bf1964813e93d7b53bc0fc80fbccf6248afebd718dbeb460326a0276f6a3bb77af9b4e65a402c67365853e4f7cba47525c3cd5584fd991e76caf75cf97db55919828e0173effd8e70a482186adb43c6c5e2bd7dbddf20583a55e223c325557c1e2374cf630c0a7df5c013144f3202b940506a5a5ce1188eee18d9824a34c6e4f5ef6485ae7d09918bdb7cf8eedf54b8a05ace7f216a518912fb7cd33566996ef6ef4cd9ae2e3018df5d193078e2de1b0f7627f30795ff327a6eebc19f02bdd532a42ed6561cab8526c7615829d1e4f016f13808d8c8f3e42f82938349bcdaef1be6bea8627680a61204fd2fa5e99893052034ef374b8f556364c8656b62ac911df0d56ae0962041b36d2f0900a675c5e0a7ffb2997fb31c489685f2ef4f12039692820eeb29bbf474c6255d087370c98f654db0501b75b693da4a31236accd97ff86afd74451dc1fde4624dc646f722dfdbd379d0c21d4474ffac4a7433e932157561cce7120893fd3e17499462096a42a8d444e01e2f02bb3f09603d565ef49b73e4e57533a541f4a49a7b31b30113ac793b4daba2686d8c5859c3323774d889bf329f1b7365b5f396d100ede908e816d2ecda8707f44e5d8be9908579f17b224830502f668b684586cc91981082814cf50a778738fa28514eedc1429f2ca523aeb8d1a8d82554281eebd97c82d6653a6bbe4072430f7ebf72fc15105ea07a1dc21d06d828c5e9ba99b6237d288df35a90253b62a636cda8cdbabd8714c28edb6f8e0617a97e07dea9bce8edeb6c0c2ef6b86f594d0524b6c82ce611ad282739a4b978f5c9fe3a3673ebab3f2fbeeb12eed1fb943c02d64c29b3a630ae5df473ebf58d7e407ec3212ea2c35cb16a6058c5f75b681e28280f1ce131f314f1ccef9c15d3563bd4a28ee75b73ff4b651a046286cbfb5229ed4ec94c422c26b88ae17f3befd79860dfb4ae3d217ff890e51d9af242165a42e8a757083ea10e2174c1f12b6054a60963711a769e41448f9adeb135ecfb914b6c92cd9fbef1ee06ed387504de8e2760fdd0b83d9defd55d9dd37c60e2d11fdf9ad4b3f02385d1cbdc999201de6a98a1767346b218ef48aeb243595b1661fbdde5f34c3185838995de3e9cf1e0ad7fc720ed46938d7e921b63649538dc87b6ebcdd794b8682de8f7c559fb5fc5f6da922e9d465131be87a903a0c3fb16e94f296c3e3087a74dbc7b81ac05bbdc243503459352b8355ec3d0c68add3a988db10af212c90b0a5576309270476b0b87587330677c8b5a939f697fe37bb9164bf7bfedc8df0a4b9727f58becb93705a826d0ee02435bd8fa70f5c9f03d6fc8f6b2b843115e2cc91a08d3a0f9f6dd4ceafdddf01954a70be8695c0b8379540064f491f47a042541c97a100afdf92be50ea6d06ef4b5bacdad05aedf8a3583ba6bd52ad0607bffbc774d245b80a67cdb8820646213bc8aa8379cc191152c5f1ad247911b194f8007cceef689f4e504909aab1e49a64a90b22f637470d8d8bdd1e75d3dec9696a9eeebc560ed9758706f6925ec0632e829fb292482e11a0a63acb082335d737d80ab4dd74191895a3b61e4fe81120c5987f21afb2169bcc9de92ea5c0e8cf6ace39e699b46a6b491975d8cce4f3ab489b227e28ce28d181f222218b8ad3c5a58f13f4b687754e9ce1c5efd2cc089d4f8da57158c71850f33aa2a47a46da010b99eb9ad16106630e1939ce05101636cb28083f2d4574e4d519b3ebae0e7181835c5a1a867d301721bce26d21c4daa0494e2169ee54ecc37c5d34731091bf4c04920b5d4d8aec4667bec1ecb8a09a60c446f1af13c8759e25258a89f10cfba1bcf31c3cf159d2ac6181edd5ea0967eaf31175c3dc01806f9a928970f377ec2c830041de6c56c82fe4ad808d2018600548f4cc48cc312a0d20bd74f5b19ccc8775e7dfa65640f1da035579519760c09ba50b1d19fdbb92f483fe2a2289c3b06ad59f1ccd4c8cda5902ff1c05ff0624cd5ac699d87b15e0f7bc6afabe3e47c3fb750462181e8b7b0ad937e8833d142cacf8403be40194b72a5315c7afe1f24878029658f067a2de01fbe7257c3e7d0376ff5a7a9e6d18d7177e8f1f30d25ff18850626669f92a30cf0e3e2becbb766c873b883dc4f96d6df5c2640370d612784c86bd0de39bc9e5e89a12e40db4ac69fb2cdb86677df42a62a9721e5efd3051a5c22bc1ed909a083ef3d12e620df9ea0ad4421d1b1dcc2c9fd8c41c9d7d4da63c966822e7ebd706e66d520f5b5670bfa308a8378a15053b6dbb1cbb987cfc952fda54ae5f5960ec4d3fd58590c78f63d056b9e75b5204f18f417e98bc58d8d073151da613c66d18e50577a4e46a5a1e935c5ee855a19f4ae93319d96a8b7f4eddbdfd76071563b7f0aac717a242e1f0bad2b4632165e44cc550fe4ac36605b6736ff8938e356236d9c4792c1052a4e7a26945b524e7937ad269fd7e94c4e7021974759bf393e0cbe380f4757dea6d9685da62c776d6fa44e6e2a65749338d2326abe71774f377b7bfbc8121ccf5584fbdab782d59012a831f3c25e51d982bd743581af296271e5e697b39786a53199f4dfe072c4dce09f05c21c7657de442b876f69b426ebf6477c304749b9e335942de68d5d3d4576c8e0a7348b7102808e5d0b447e1f78a77efcd1221998d569bbee228929b83328b47f96cfa577f26d83cb3a27afe496590a17b147458d9403034cbeef2d304a4bcc948b873110379d5018bbc5f6cee5776fb3daac74d295574e2930dd6c21898801e9f50a743af19ceab962e7e32572292dc26e5c0be89f2c304fd6ef3cad7714381b198f716644a3fd4470f4301704313a684f01baf8a5159896bd08c663b6a57ae13cbf583d2c5e5a251cdf9d9c1e13697315a7c1282a8fc52def6c3afaf0504bc2735f311f587e0a12ea5edb4645c0f587eb8ea30f46eee72bce01b653c4a0c713522a7cb8dc54e8b878cfca4ae63013b47007373a0aea73f38e6ea5c31181feed774f00b0f6ff7f411ebb35808103a56193a7cf6064b2814588eff264e4d56307a82ad4a40441c64b96c66921dfc3ca6d3602ec03a061b4f97665650afd34ea3e4f67b31b566b78c0651665d08f6eb288c23a96ecb27905f4f4a5972b982640d0b8441f9b7547f03f9ab84c57794859f3c4a210d25491da76df1d47bcb13d466d4fadff66a4665e20fb140bf8fa1f13e42c20595a3c100a4f8210254863322cd9f27a272dffaeac28aa5d6536907bb01450313a11d2dadd38159c27fcd694a283cd4cfcaa772f58161c6ebd031d4425c935e441ded2f00a29342a450c58bf9e4c93e0dcdafa8d149ce9edb71280a46e1a3effa354fa2085849da328086187123c84c54afba599bb925012416836febcd234cce74ff81238213dbf3e9b0efa6d244c9478e92222e1330b6c6c6b00c6cedb71ba4940ce164b520e299dfce918a3cb814f78b0dcf842eab9bdcded45b554f779335abedfcb10bfbc92283f93d5bd4f32be8611580b837d4f078b80f53fbd62d1deb07b308f0056cc2b2358fdd82e6ba69ad2ef9fd6f403e7435b49a559105beea9324894ece75c9d991994a61a9c7f83f1281c572ae53ab2197b37104738813b6a05b8ac5a446dfd27e9df4e7f9b44b5344ce22df1b75fc5fdc510910dbcf1c797893173dd328d652518866faae0160554d70267fdfbd6398fd2fc4b160bbb8673c280694edde815dd03db4fb11d4719d63e8fee250cc30caf9fc0121d30d2808f6522b09a7e3bca1fdd11bc409d3a9aa2f1a5f7535b0ba35c4773ee5772e4a6b06c2607ee312db3e726e92fdc8c7000c144d933c439bd23476d534fde1fcebb4945bc6162e05ed6f8628c2acbe8c942cb73a98d82f4f54e1c0a714c970f1d927f4e91b2e8bc4d9be8a3693a44782fc494e4a6eb08cf79367f5e4be7be9aa47dc4ced47b774f2c782e68d2d00005cd211cd7e662a32d4ec484fea92cab9146e872bef0616c8b70963521634fcc0b20ab1cab0174df0086a1bbebefeca16a84c5e428aaa4bbe4e9a7ebe514b7d82864cc02208de890c4524c72947417b04580e025df3b9eb2e8c8f4bfdc04cb5122826219eb660c7a2208a3f1ab361048fcaadc2b2ace1819f50a841e9f8969892152f14f3c22748e84a29e15263f8049679584575566d67f4a2fd81d31e07d6aa2696edf481668592d93084a13f1ab4286f9bb3707b5fbb23b9f15a11af4b08111b5014e725868c7ad907a370695956e428e7fb6a6bba20ea7339b0b4d2a5b7387d8d013746c00c105018d8d3a5c26c8d1e2b8d33c4cde928354dc43baf54a5537b77a39a72e311d087baaa10de53de7c65edef8b769e0a058aa4b1e8c5f8628ed736585aa4828222451a4fc185c54fe6f680cdaaeb8ecf869b3e7c86ddd12225a6df7e09893bb532c70043c09019f3cd86977b26e7fd6bdd15f5721eefaa13805ed1e7efe0d95bc66fdcc305a063b0c303c1c7100b0ca135079ed2e76603ad673109dbb816ef00806bb7fcc2126ae19eab2882498bde5aec3d03c2ce2851ed994420c8fce602a7cc61a888e9f4839307715eb761a197e46d9c964de7365671cdcab644b926c5df8838903eaec72f8441f645c55fc420c36b27a1b4903b8808812c597b53082a4ddaf61222ef29ce1347e31591404841a1c60910e1394be42044276e6a7bfe280ca91e12cf590219a3476459b67c3ee64998caf4bcaa36ef7e6b39e1ec36b390aedb958ed90b93ecf9096ca4b7a2f9a075364f53799bf5c08fddaa829124090ea0126ab07e9cf4421101b3dd45c1cf8625b9a7de6d94019ca018e615cec86d1c4198406fd14cde20a3c9a10918a9733239db479160ee1b26507b522f401ea1c2ae7fba5cff2d79ad72d37cafee906ab63c6e95514dc95d740b1197a22186aa10620f00ff581e4d86b70e977e79a6d25f636a1afc34de868be4f68ed6146bbaff69cf5b8f3780e6a0e1a5f8c23363fa76a4c3799eacea02d48fcc353c4ef54a637e1ef19e3f7a683cd69d06875f210a8e910de9003f645bdfecb68bbd56ee91a4054f239d315e2facf75cb8adb40b8374db340b826cd3b5f3b75da970af2d46f607c3ed54123d4ca332bd4092bb62c646300b89d25d521f0029487897b9299e6825499d4d305a1d7c638fc2a751bde37dc34f011c56ed585ec5606a2f3085c67f2f56dd08806396f244b9108d4559e3915ab7840704c84e939d87ac5c59a7c9e558c11ff0ca9b66524f44e6a719802d00559ac230c229473160140629841913a46347a1060c5f4d7e2912bc7bc1951c5dea6855fc6185e005fce4292d4b1a8601eb05a9cdff841b38898094820944ceab0f2bc5c04f78ccd2303e26f26bb790c0a41599676a583b5a0ffbf0f05b9c9c7803b7b2d4a91d6e04154b43993d01c23f872c1ebb4a246d5f16dad4474c2f8c98db75674c6b784e6698df1032fc88667a92b77e26d995cabc0b3abf10ec9472d8a0ff884bffd9088286b344c7de7c6430c882fc5fc040b118ec3a65b2f13ceb2aeb53e2353e4e8e70de4102c5071812d4e4479f9315281940ee1677e6731891caa8f7c614fb489e5b6afcba30e1f09b49efc0118197d1285f456492e50c09fbc5d69fe08436e739f903c9fa27fd67d24fc3e1e29c6d485b8d1ff0339855804bd076e923e7facf1cadc97cfef812648eaea665a55a999055a57c691e0e5af309e101329b984d188d02f3efe9fc6b5ec15ef9a6c0260cfe9575a2b071ee1890bddb5e3c2ae0aefdd33086f6369ba0828e71b3d93f8d54faa1e0c19c91984bd7ef327d7e46c80a2e1f7a7bc24203864af9f4bb195e498c5ca9562eed1038d606871b7668c5acb016446a0d3415b867ab2e45a9d2e9ee1d244134a0e5fab454377966c7af03bb425d7587e73032330ccb704a6104c1a412ef02a2239be12fe68abcc19ed20ef2fa9577664eaf033554bc76e1214082a14af925ae3c414422a40e532b25507b3c0923bdad77b827de0c610a2e4036212967b85ca5b2c09234f4fa1f140e344b65848d651f9f24fd3a54bac5df2945e5fcc388588b781e2185042cb53cff40dcd05f9e96c846de4e3c31481dcd995147a160e6a622c507658e8c699b2bd9d74cb5c94f662bf19f895882f39a6e47a601b1e9f850d75fbe5da01536f7eb83b222ee714dc109c83b2c6d9999828c2b7a6c2b5a18436e327431aaff2e29d1d4af665a2bc3af2ec88d9653d9d3d35d9e8bcaa38fbe25a2769ff960fe944e049e3b73a49886dceb38552687c23ccca3e4ab66002ac8a19e60e35e96edceabc8585c0629f14e4b206ea78ef783980b10e30f698ffabb15e297c1a7761b49523455f11ff148938be1b6ce4cfa127fb4f75e5f5c7a163b45ba7080900d485abe7f0f0d636089fd85dd2c70690948ec566ba210db286adf9d58ca79ea6f82e18b3f8319436d4c032cc585525646ef74930063aeb878fa2b09a51160ccea3b585c514a18da928272e8770e98718bf751d1f3dbe9b69b988b23b3a1ee4135d79cb7e463c8a846d373a559fc0756878c6363da962db5f2cfbf2a76a77def7bfdcf4d6daf7a84b25cdff2bffa33fe3ce884263dab6d4a1c906a6b64fbecdbac551736ddadff69ca160add9eab70cbdd8549c56773bfbaa298d2f98b15f72b21d4704abf5300924e46456b4b252eda8e382afd36c6a2c19cce416ac9ced4f9a19e1ae9e69196340faa1127bcce3891d40571698505bcb4da766776e6af9d11dab0e04124f3fa6e50a470f12bc9333f0cf5d3833d8d4450d609f1b844f812ccda33cd2dc80aac1b1385e3fa14d3133c62765557ec041263044f7e36772a8ca03f44838957409f6e7a65668857917d06c469807b65e31b51d6f2f4b7dfc7184c95e83cb8fd2e275aa6e9865ec3a80a4362c8e5d8a8f3aaff7374e2e0745f5c254480808dd6c3a9b5b68494e2ccc03f8c93ec6960c7b031d0239bfc17c1f1e34cebf6ec82ab506351e4add92fe6bce4f401fa11e3144195657fd7188643d347e17a199367b64931386caec635c66608399a36146a621eb7915bb49935a0ef49a1fcae3cc7ccf5850824c0a61d4b332f5dfe3821238e1ed186baae452984f7756d8d21165a79d52979e1076b41510c081f2e07e5e755b7ad72b03084db34c28ed86a192c1bb01bd62f91e3cfa9536aeb171de633d7034e00d631428a5e6b337e8abd68f20d26f474ab1c1ca2ede94beffce35f323443f12268eb72044270c99e5ca7ca03bcb3b63a3c7435a729e25a87a6ce93522cb475042b2f202076267fa857712971d5c8493d1881a8748786ef482fffe8e84d81a0e5ae465fcb777c8cd254f9fd4a2fea93f5ceae227401bd50097ea3b4ab2e85efea5489003b538967ee7bb39abe15f6202aeadd51affb6121e468b1cd63045fc61b674b2c14d962d092ba3c915acfd3b941e1b7e383643c57328251acbbf90a5dbecd01fdee0c3cd48acf106b94779fcf6bd510fca3c768d333e0e7773667aaaa14086a5bd59d6a2ada298dfe0a8712476acd70f885149e33fc1c5ef3436c1fb691836adbd613bf7308f87fb414b879646a9ec9473359395b3b9b312cdadd74580b7a56cac6e631c95acfef6f054e40e14a69be1f12c571a606642ec1d2bbdcdf819408d765ada03bf34ff0c3d3325604451b0e53672f82babb2597922a7ab246f45b8cf44333a1ed89ac515ee631f3d9993901f364c4fbc17bf705148f8ea2e771ff90566153c3edf6586ec9b3bd348ed97397a9fd5b9883fd99f811053c6bd32e77e127d33c230561beb49949af10628f68e820894393f11698badd3f06e8a6df4855ebf6c676a70d1dca3ad6ce8180fb432ca0d4fa6864d3bd77312748a77a3b8b61f24a5c7d0a94e18c99048c90c0d82a80f585057f85b0d8661aefc5b45d3f48ce13e5683450943dc506b3588f0d26c6de1af1d147a580a83fd158a530e76d14f33537891ae51a98b4849171b1635b00cb9a7cd9282f845d280b2b410f73ccf4890f3bb83f1feb12fae9dc7b18ca676e6043d759d1a55cf42f4a95a3158a341e0cc23c5bd1622779c0f791d50e651c8e470719d2e9b87acc079916135c7d7ffe70ec9a78113d80658b52046f220477bbc87d2ac7db9a49d6a8bd2ad5dd050ec93cc6866832bce4eea44a8fb638a3a52ab3ab64472a53dcf71da8b79893b4778429b8d8df9c9ac7759dd13c238f67c5332ac85ab78d76b565915035a74f1d3d572288b1b18f435d2f7405efaed6eac55085067dfc02fd8c7e726b30ca5601e31872bcb627de8836caf5efa363450687733b7a798f63e733702062d2519e4b34ebbbccbf1089393c264df57cf05f2fb45312399a2a748d58f20b42051de159a4f2fa1727357b48f596d18a8b5ce0d367389c2c52926b60534965cf2b0797964c0ed800dce40cf2d948f71af0f6432af4d2868d4cb3d31ca8ed72eb8606e17fcfba71c82dfa4fc4c50dfa9ecc36ae7119e0986e2f4f91faddf2845c720aa15142dafcdd202da9930237a455ea87d94a72b25b3e2ab94f180506fd0cc2e38416cdd01686d70c08d87c69a30ae511e4f0b14c4ee499b4c4439bd05e33677650183fe13e36d75735bc764b0cf59d645917afd5cfb331ba61fbf714368e403cf9f7588cb4ad73acd317dee24e8ac288c596aad7e776706e1262783c66378edff0ad3611e9cbdb8c45ad06f2b118121dbdfd6f7b084251cafe23d0ac60aa4ab3ee970048966d113514e291e4c2a3c0a8331a85d40f1d622c96df2540249975b6efaf510210498a72d596966a5a272a33e2921cc3d5f8d00b06c383a6f7abc09de29d3283005b5400abfee82faf0958d280d95a29a995a3abbb62e0e3713aee5fb34b1b4ee4428d1ea9323411dd90332cb020cb9be47e7a3da60a5bfb9cd5be62168bee7ea02181ac427148b5b9736b2191dd40ccc29c80bd00a873755531dc84c2a84b8382d23a2084134b3522f412e534027e2a5b6add9307f4b85a9b81443fa839ccf061d7f1356a00dbacd732764e8d198034b54294575c1a30026a63eb43369bc4652c020952f09631abbc0c4386d67766e9df2513af3b841781611ecc127680814b7f3e9de8e5795371d2ee89bfbeae499d4726ee0a824ba9a2b03bf80852708fd910bc3208edd55b3585c37dcde3ab7dc43fed91de644cef1d8bedc8ebeb15f94dc55557bb6e5c1b1e5c17e61bf959019be3a91128f3f0c25596df46456e1774a32efa534f01143eec6ed1f50af931e599c44d3e9b9b952e3c763184b2747e1eb249a8a8bfe923b91c9c32c3943daa581f76f8344f90f6b01615ca9b8d7851e163bf644149b82787d0d2f094368acb6b1a32551ea19b49c2faea0872ebbcbe8b554b9139148090b1f0e1b9596c66df5bc6dde5137ed2358334c2773b4982c7b99cb865a674d51707ccc1c878762feb73eb76adcddbeaa88bf13b03b371bad764a3a9563ed3f2749ae20abc0cef53bd69bb6d68ea4b2c29fc28e2fe58d46a456bc67f32078de3634801b94d702860515d37ab7bc0155825a019e9ff63bface245992d1d9bea9ea2d595d6a4336ee7e32a7fc1792713767f742b08da92c489fbcdda136f7b8235042c51ea4eb1633c6bf426b6ba47ed7610b6f9accae585cbe49843ef6ed86d8fe2e4bbb915238a33bfa1cfb5c75a4560416d39f63f0a841e4842430311c108a0eee258986a49fe2b44d4965526756b45e97f3bbd77c1ee1d86a6df8ed24f186cf6dcda780798f116809bee533a922253cdc3cece52e471adb67f09f367ae4491862a77142eee6d96fc84613162edf5483b0c051d5c994eeacfd24bd1facfac7d56f7c163b6d518915701be1fa163de298bfa47ef7ad1ab12dffca01fc155e3352729b8d334dc762e97488353002248ad95f667b37424a7aecda42821f5d8774f90ef4c5386e0c1c7f6ffddb41699a8150ed285c239818b35c036090871c7e845326478c9b43d37bbd798aa41157fc77077327cf54b1f18752605a308dbedc469afa77d2682096c9ae7b43930f7ce85fa553f87f5af94c87926f30c97b7003689b2c710496dae0cdcdc93b10e229ecb810b3931bc8aef148c95fd8391eeeaffd73ad27457e08bcf6cfcf981a19b79abaf8dc16df51610a25950017cad9e290f9ff8e1a389e191ca808465e382b27afd158c88811aad251e18d5740f8752d44bcd6a7428293cc2d3fc15a0cc1bc5988d1bface4723338965c86a904dcf225d1377e29cf80f95796ac24aee796062047aea02095607ba542a29978e18fa953603bb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
