<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03e32356ab22fe3c0d40c6894eea026338b8cfa26bdc3a2ebd22564c158febc4945d1a65249d02c97946deee4d60beb04b4f864d5bf3293c9eb99572a2056e409248bcce11e6795758ff496ee6ffe2d6e3b2a01db1a58164514da30b5fb69945bd54b3af700f9972bb1e408cfaa5a6fa5dbe50af5522e01664be2b72533b66297e97bfa18e4e8273d3bfac8dbcb0554d99b63c1f120ef39229511015f978ee92ad084e85f88b4ca2cd5f8663fdd7d45da5a336ebbd0dfdb6570b8a6119442416081ae0fd2151250cd5f2e890a3863a4bcb41919e619c128ef3aac4ddd95029d070a59e1e8fa2108f6b72ddc6e15597510e5259b0c1670e7570c240aa82eb64856342fb1ee6c171c8fc91816a6dceee3bde98b3b7eeec64409172217ec830e82daf6af492ad0d8968c52d476d2455489c4ffdf524e15afbcaf7e80387890a42ddfaadf42a41e01908bdfab63cf5fcd80e6126ce4c60d6b93b548c1b74d48678492f42668260381b2e2b45d4f3d63f3832f8adc41407f1ebecc21e845206b1bb2ec833217e214b704f71690686b6f6be864b97c90ab7d0321d15732a739a70a11a734cfdcc8bff65fd7a5239773a66543c7d5198c3717b5ec973e2905b3db808d6ca5f5606d414eca9f7681f0be295af853cb35bf9f5cf6a22fa3746a4507d4adbe9bb8135260324b863d4508cb2200bbab26f71e4589eee80722654f797faa191ed4d3f7e4138192f13f2dca996b6f2cf3cd7cd565278fbdee559689537ec13f78a4f465b4609c8fc8d9b2fa060fe3fe9a2e3bcc9cf1ec4bf6fed7c8378fb1abcd380f0f697ccd200b8a98a2a02c206abe26b5e00a227db1acb4f6b808b54ffdcc186669ed5d0a292650302ae0ba82917d63b10bca1c2ed6d12a57a28664daaed24a26d029501169fb4db78e9de0fe9209a2fc95f76c1c84cf4caf0253446c2055664a2c1fb44b05c7723f29f6a84651b1d7ef6a1e0ab1ea98b17bd7b19baeeef256ed8fe291204c65d014467f4afa54cc54f39e9f11126d5a345f6db406fcbe40382b5ba6eeca5a4aa20dd30823ae30da75c7eb08406391ffc3f2a30170af36b28d860365761aa404112d571952b69f4ea63d1015b3208638eebcb02f070fcc5517f1d3cca1aa0300b9a0e9a44379387a779e56d2882542e529c27456f1112132de85a302e9e17867069a44696b2516321c5de5fd255a8bf18bbd05c9e99ea247b9c06e9db5d26f5d99ae298fe40a6c60ef5ec81030b514445adc0d41b3d237a58586aa1c216bce06bbcb86577052f2e64b81ba5f9e906db8d4b0d2c6e803d8d9bb8212335506415c0e87e39f5bfaf26f8db3b3ec0e4e24148050b9dc5454304b2798b6ca64770f71729e161f914fcf061bba5cb60e64aee0a777ae573cf2a41d5044d6b75fe606d2050e278d13d528edb301179f6fd791722fbd08c260d7eb718867b5937862d6afed7572cde09ceec9447e90f3b665e069ce28f457653598fae76b78311845ba603d1033d6b93c40fcb1357a112d8e2c390aaf4fe945aff9117b34949b760b441d16a0bc71748363feafb78565369572a2e4cb75f4a9d045c4c33cdcaef835ba662df8d4ef9086b29280982612c3e0bf6c5f158885ab26e326320f6dffe6cc7856e8b1bf1d718ae23eb4b09b62c9b39c14954a10f0b108ebeb3d17f6ef11d800eff93eb7b573b3a50047a906c4a27de335cd27b705b49dc06883f506d8b15151533f49f32b3af94798e83bdbab5039f5f840f941b80647227a37a9404aea8446221a9af40d003ded6b98ca3c355b192a047ecf1a804514493991b3fdc7f50e2572f35fd8453e7353eb136178ea2571b01aef6be489b10722942dc5461cef30baf6828c35d26bf39f50e3db5835eb2c2cbf1c8c70c9b5a1a9682922367cbb062dd18f602e8117512b86fcbfa76ab1e6c099d2ca125d44ea44dc58ec0126713f1f8ec417d46597311bebf5b62364be77ba692f54b2876149a55f41b8854b629e1f3e2521a6fb9b7ccb12f2f53aabe51baf6916c000c9682ebcd1216e90b000bb8abd4ea9cdd194a5e5638d98550b70dd177e2875ba4c458b443621f18cc4ad00baab596d813985c78f2c299ce1fd04ef4c0440e49070556bb98c771cc15aab57b2bb53166b5ec4ef137246ffef1f855e8dc3aabd33c39eee1013444b2822ecd9eaf83c0fdd8d0b3f7797acf9477da266a43d41f12a3d1dffd0963e5cded4b38e5bc654ba974a75f0ae080f24d3bbc4cbfc2fb8e5fd792a65f927dadafb431545290b86bd6621c2d4b724f0a615e716413ae07796ddd15be3f305c5eaec5b5f9e67c780a815e1eb92078f5370590935b02b04721787d1c399f84ea81b1cbcd2f71d302a9829b2cd07d270b4dfd318f5ba335ebaefe59f71ab26f1cdbac6ad86db96dd7a861fc9793b1f9c803f588d19c2e4d25d5b3dc3532e7e98aaf3c26799475b80d13e6338326a60e818a079a389dbecd422161e8ddb0bab8cd0992ae36415f8a3c43c45a91d1ac320889d5dd6479fc51c22cfc81f43c336a63744b77721da13c1d45b79ac830feb7ef645a9eedf0ac1b3d48a6bbdb66a52cdcf2ee569a38d9ed680382656d5a22a8ffd3eba8e062ff8463239eff8b872c467c60a3b26be2cbd41185339649bb2e7910edaa8c000ca95ed71383a1ee1ec42df4dd39b6e4587233b3cf7d6cd774deecf3077491c399e8c4489aa71030f469d97ca0a2cc9208956a0696cb5e26c2fd027f908b98df930e25ee41f57b4177f81c0b9b89b17fbf1ad538de4c21e107fb2ddcc88a65198c306ab0079e896c2d9c12c14bc111bce826e0d41e2795b5969098c91fa0c0f9edb4c3a8a4592d9fa3f41a443f4aa9c9907c22f72064816b3b727df747e0c933e71e34800d54a6c8256e4660b94aaff1300c549593dd02f9b10d8a82d890dc332cd49b22eef3c44c313f197d49eee38539e110be18d645f4e2d1f216f358a7168dc3649a92962ff1dd01912d23d320f8cbf8ec228c19188ea100446cb53d6de1a92e6f8811fdca3e1f4ad8db995ad5c23835329bff6142874a059dbc2af1e75595941ee8e50a00cebdda4e782fe00519ee1913ad8e30e6c131b61b7e961de10ff7868cddc13920d2d289db1ce954dcffc856e9882f8cf4636ec95cac7d27914c207bbac2f5170fdeadadc00583de806fff8609c3ea8d29b1da0d2f65d4747250b7f6f7114e08b33290833d04c7a4b6b92d7216fa559ff3e291810cc74b036db6620ccf7f57365e63b40cafdb2bf10e90476314054ce7e7f8adfd04da048a25eae9c4666bed649891936a629c88561921c1228290fa87533300aab35a0dcdb961ee6afea8400c6a4558fe4e3ffb4b716ab9a342a93e78b4c0d1b18eee770559a03f43b2042b72098740c2494e61d1a2df3df922dd012d54ce2a528728293f0e38c24a4dc11a8e5c083bd6faed32e55f1a6a5db10092fdda997b556cb2cb3378af639108ea6e7dc3a6e5be7e683316868ab12d7f2f6c956c3c4cec0f15b7957b77b357b089ad3f2511700c2c90ff794d3e8e2f9ee306eff72dda1e6ec7df75e13629f584545a5a4db770e57c7717d9feea439c473a378e91693708314d73f9b483d9d41f8eb504968a20f19aed9efc48839f47e4df82b4d8338796edd1eed62492880ba8b41001f6ae64498b54c93b5a7a000dfb6829dd09e63d68e90ec5e056f7ab74b44b2fd25f72ada9902d0c2d8c0f66d78fbbdb7b6e2c858066c82de922040f8b2b420483d66ba537621657de00e3cd4915c28c0dffccb83b3317d9a8a4b46b724fc1df2343221522f4c085e218912d19b8782804eb7c99c763f9d4fbedd025e174f3187469c1f327beb0bfb726d411dede0def0b225ee845baa5af0649648b08f86d741d6efa95de09c29f350152413c23a3869c6fe905300cf4c9abb17e11a89d9dc5e456f828c32b03999a745efbe0bc15370af6f7136003777cc5b0b35d4300ef8fcd2d3c715185afe7957c80ff9217ad84b4e3d60b3bf0396561f1f1dc788ffafe557bc4b67b68fb592a405cd1d167f5b80934c825db0eef7ad79ef9690dad2f1762dc6b566f7fd7c5da5252da0668d3615cf81c8fb4ed8f917ae9090a9918b5b0508e07f8f29a68d1a2946ca268419251a870764844d66a235adbfbf69c6fa36a6a2bbc37ce5c13b540979a3d6cf88609b98581b58c562006f1e5ad36e290e44eb5a26ea586b9b868b175bdd95bc010bd7ced6d7a253daac47c2408b5ed1fcf13b52bfdd58c17a06f209f1ff3ed48e23045bcc8cc77497cbea251ebe2bc88679856034a196fd4dac6ec5965f8dd6b7b145528b1aafa8d580c77eb2feada7d92cf0fa01ce1d5a4626dd280246c9db85f2d529f47a0a33fb1867bc5656e7aa0c7bae8b4c28d6a06025035a86aa3602ca3058b29d4aac484293363b196c08a0fe849bda89d0f057ea954af724c905523218269296170ae5c03b1f667cfee706d5e28e25b75f8227c9a6245f4171ae865db54a17fb4b51607d3ee693c36b3318f29bee9a3fa22b3f57722a507f336de89caacec8db7fdf12644e845f47a1d248bc7bfc3727cb2faccd65b8cedbf01e9e6870ce6645f35b942dba779dd527185a20b2f245abed40219e43261750d622d857e8a7d0b0cf05bd2bfe865943d4b4c1f03476b29b4b648ce781ed6eb13c921ef11144ad7dde690540704de1b665f76f58556e05c5658d988137495a0c22f145ce401798ed2247a4a10460ccc12ffc87a78f338b4564e2a0b71d410443755a3af40cb279cb451fd96404ee4003911bcadc90b4afd4152162811a346deacfbf3874277e2823f699e6075f432ed4061600c54e253292f11d7804fcd77f16e2ce24ff47cc319d7a0eccb859e09128b6ecad51be44c0e9d7156725fdcd522db1b059b31bb0a027ce00157e594a537f6b269d16589fc6c38bd363747b49429e492f3cc6153bcc058664f9f2a369a3872c2a1e5dbac02acaba6903dd8430ff67443d8a1e6892cb520abdf4ae857cdf250a25bbabec4ca58d7f7e7b957d58948c93e9cc58d39498b95eaf91e314454c9e18bee0a4792df1391898336cc50f43849391ea374ce2467a7405ba44c777348dcfe9b7810bcf2a69b7752f23ddd2e076a070887b517955f951f7629692c461b525c3a57a9c99cea5174af0b6cf319831eccff523d3cff2ef0806355fc2626273756cd7cbb1840299e43c16e8b39a2dc780481a294b18e9ac7ba057190a745af8e852872bac226615e1b7368fe6a2cfba015dcaeea4d32699a4983beebce9af90d541f21912c71797068ba377a119a7b7e448b51bbf5a55ef53053662fc1ee752a45ad8f29a285a4d3a24c742d63daa5c1f51f9b0f8d173c310a0fccd64248f8a17470743c925ffe832cf0c17d3ec8bee6a670f694072bb3ef959df808f1a5ad068f6bf82dba53bb00f96bd6aa05cadfeda442c47296a93d4738b215c290408e21e079eaae8e5d5baa459ac2b166bc613ec419c78b049f1a9c59b32e92b84d760ff20960e4a2c1bf77ca5bfa953724c398db4803f5eefeabd2fc72a8cb23a5b408d0bec468114e7968956431757adb577a719bcb85c2114c119387fe27b356b8fe27b7d0b78784b3cef176ce1f91e69f75c4c5b74a4e881ca845290eaa684fb86ac1ec98ecaee93e2505c03269f08a746117d483c5f3c89c3b880ed4e5a27830862d23809a513456c25b44a4ded32b951880be185987e5a769cd6bffdbba2290b4a089f1d32bae63c832a56790faf1a792c81f05269e868e0b02f490ef0c4c523680de00d59a402ff0a2a0880530ae45b20a487d8afc0ce45cd378474530b41f12c335b4e34f286fb25c0282629f0b84c7845e9c5b1f9c60f2bd30fdeae7874dfc83bb800a8647e61ae971796d730c8a8cea7dea8b039fc0af4950e0c77f9042f721b95ce0107f164e13eba60a2d2d168987e11b8223440b7e188778626ffeca26f09fac8c0473f464f922e3652a673f971c92aec2e638488cf73dc16571399665d84804d28649c0d16d4dab11971441a70c281564e247d953ddc0ab23fbabc9bdb8ca9595d35572c131b05711cb49b2b06a71d31101991c6d72a9a9ed5dc20f23ff253be955a4f20fda8aa932826794a94a83ee554fe8faa15b1dfed227c6a1448d46a0e0420a77f5818e61df7cc8d9caed41b8064eca3b9e53fa3d026c25d63333cc48bb55b8d3a991d7c69c1b0151272d330b0a19ba98a00c2b5d40bd19a988b46e1c902d9e6d01265f91c3615c5deaec06f3f42053a36ac4c413a47cb91735e840b0a9f881e53f67fb8e31e77f4f31d137a2076aa823b7dbbe56d3dc454b1401fd779ea49abfc28fde385e482bb5c26989c93c5a66ed3f20133d739bd0c8e5f7b22b661586da2b6cea14ea406e0aab33513d34f002a4d71b05ebca8a231a6da508ce3a768c21ab56d9277d5688b2959850aabd7f026c906f3f97e0c498dfc2fcb4a5310620a19561f83a5f195b8f5b308b3b9207c9be1a3e766b25110a5b94ff3e87088cf16ea131d1787ee869f9ecda31ff2bd440fca4b614f26fd1f06984639e80625ab172fbdb10f10a6f7e2eb9e1188b761140f261e73c4f000c2afc45a015946eba654b4c9669c7e42b1b169249c2d1b392c2237c3675809d5ed84fe7253d6860128a4b82b96098fe1c93f11c0f8aefab8fd98d0af3fe76cae0444b46fec7d8c4392e09c47f7fdbbaa6c48c9bf5998300bc8c9750d8629f28213365e99efe7773b0033ae120283d7e6dc5a8d2cd96e4f5ec0586b657f0edd9aa251f994f5f6ba889f92c548f4f7a9d629462cddc8c80aceca958edaf4489cc4036f4bdff0acbb34984e8ecf6c811e511a682a19a29e28b110ffa544286fd9f26003a968777bfdc47d3ebae2a035fcb52234cb14a154b83de6e4801dc2ca35d71210ff060b9eef1f575869537cecaa392a84dce55f81f8ccd08925ce71a323c0be2666f590d016516e4f276826e84c3d76b744af4798e1b33903deb8b7519d86a15624534c6f0ed4cb8f19afb741e0c2ee431494d4c6aa7f1372f95e68b3e474b685ef49e670517088652b0a3070641eea86ec067828a8fdb2535f847ffc9faecd1fefc8066f9e91d3058973ad77c10deb62913e23b77e72d7249fb0967a48c94622adc43efedf9076e5b95ff21bf9d56ab64a143060fd52f487227c2f6f7609a8c11d67a24ba73320f47a808a4d32f6f328000a8152187fdfdf5558bba8ef6cac4dbf3debb94f577d6a91c9ad43c4e20d7f3ccbacbb8ba32a2b9b81f7a7bd4c43073cee9a6db0b62202f250f3df5bc5600d776fc4ce940df1b1178614b0bad7fe55f4fa37c9d4512bcca6aaa8c96841a893f7b0ae674a2e7c332618df88465449d9a72a913045a4dd2387ac2a372da0764c0aff6316950d49b0add3df114d520aea70e4c9c963010e6ec2116fbf165e060c629e026fc70ce6dc2840e1877865583bfbe932d43564fbfd1bdeb00a8589c26aed11a1bf825aebcd9b3e2514cf56b0e10e2d30a3c71fa1e63c6087667d80d374a93e8afcd4723c9cf0e3141d5145e5d186cc3790bb9a8bc3eef430b69f04e4138739d795c3f3893f5fe31a42131be25ec96428e102c3978f198721d90bca9210551b9f09d7d9ad0997a19655ee7da7b19ceb4f81a1c3d20851c59e54d23e5d73139574a34401e1c3c8d05fa2205ed79c3a72ac6b08a97dfda1fa4f3734c0e609f7591d81055a1e953a3b0fbeee371bbaa1ce7052a613168a4b78a2ec25edaa051169dbf39aac1faddc1ab9f41848da051efe6500dd038c5c2cd87b079e09c84f6ab4045a2e123e74ac8319faed6ab787fbcc4d2674e55ec5e32fe1df1037774234e26a47a86896a0f536ca73cb9319d192b72902ed2463c10868498605b76176bba97085244dcb175177614c038060a5e6df0b6fdbd7f283584ec97c48fef247aa2d1a1e4df1a3c37372462cada4b720cd1a249c278099a8dee20f0b070be8b716eb7008fc063be44759945cc6e277f3549ed35900194bbdc85fc457470afdb406eccd91f54062e5839ba6809d1bfbd13fb14ee34fbdd42bc54ec50089c6d872724efb2d35510ea451f8a66dcbc7a7a3ac74e8bc37358279b32d98cd0f2bbe8656d91056862063df686918bcd26c2cd0dcdc0282839cc2e6d7bf76cdf52035ee40141a755007d918a6b71107e4a98913cbdd4f10a39e40913c2b93f3e3b8fc5923aaf8b1afcf5b854e135f6196f7304bcf61090a24bdf9cd250526e2c8696668ee9efdb6b6db2b72dea1d1da9f50d2ce2820e6da0b4aa5b430763c470643f1521ee444ce6d7557184726525893adeb205c58acbc31dc6f9a0bb9c963fa5b1bb6cbe20ec35290390ecb61a202a92fe21895ba0b5ad04bfc547cde1c1b450b8e3ce098e5080254195546c7c6d0c83db5aa93c983ec7a78e9dc73f20d59c5842889b1fc1af3d9da337fd344046dd559c7086890907924d1a2b1734c8c49b821fa3be3f3a06f7dfc642a48992d0d99baa3b2f532f378fc850d25f96b4a987dd1c53543aaf9ac76648b004e690a4aaf1cd584572cef7eb64b355fa05b331f189f6932d486b6a1ee84d3b095f0de7e5e97163662f100827fee56e7de756578ad7fea579fecb307bc0b873dc2e990578c630edb08795f32c822fc76ad5b5d49f1b84f586c4fbab7be5f68d05845126572ea1f08ea71a43a75f7c56507369bbfc6620461ae522ef0084769bbb35db0512e92f86919ebbc78a60c02d9b713bd3026db1ca6d5fac4c0cf506f141ef4e6270b280b4d1612b01a8129d3c8902eccdcb15273d962ebbc186bfaeada8a63c5c7720919428515573470e3175acbac2644b8bf31705fff50472bfca43220890fe1727a40b1bba2aefa078a29d0f51f0fddd2e9054083239428c7794ab23ae1619db80365167c40795affc9fd87ecb4dd8d292a2702216efb1cb4afd016ab5afd508d59485f2e518796e59a1c301918e0fe24fb091f59ca06173597a51da5f4154eae3540de842ab3fed392d75d535a6f420720c014facf3df89d94c3633b0d431429f86629abd4ae674c30b6d23b9135ca09142179c982589c9ea760473ef46f2a0c9af8f931db0702814f1f5a7ad1be8d90474dd8a1c2fa7039d6762c8883a028a1d39d4c8e6bf1bf00ee9b8bbd979271df1d3ac747aff9f5555058fb93515f863e54647e8344143bd00fe3c729bb16ac06c546dbba44a5d7fc6b523ab5012f1fc6636d9963779d239e25a9558e9b309df54919fed1cd9d81e813b4cece9e5789eb838623d793fdaee958d218ebeaf64fbd5db19aa9b7d4449ff9aac941e22b87453493b4c5175b36667c85890e4b662cfbfd02abc173555381fb05b79e7266c6a38f015a3e9c76908e53c319514f37a1aa49f168a96d9d85eab03ea1928c53d44a6d5c0ee371575a65de210366dceffb197cea107790415eff1e8f7a68156adcb0db00db10a80bf19572a87b1cd1b1652f81d4918105305413fdc34e5842166ee51d5d631bad50a448bb5f1ffe0a322e06e3ab550319330adee467f4a7ed7630bc1b804cc9833659ed5dd0b0b339590f56905a6f0fd9e9c4f21b3c849080d1a77b04596da3c4e29553c2ed688c88a37bf61f397dba99e2f0ce02eeb1702fd9291a38f11c4545cc8dafd6485a0b779c97d33ea4d73b9b4aa39a5a572529e16ea497732d03e48e8a17c382bfd3bf6bea8500f43071fa4c200b06930be61329a0cda002dd7a7db59aee2dfbcd96def40b87117322943a1b67692cc9ab22573702b4a6bb61d6cf9db5ac2ec7e3647a947bc66989c50919ca6af01a17a66bb451abadd29faaa3cc919ba5bd67620e1c0036155fb54066a4fe1ab331bc36a6bee21922f455a3868f38660a245be93664b485620f45aa295bbb3df7f538bb58372a874d8a703f099c7b76ca575f25c8501b7528e4acbb4ea087536fde38d3180f6e2f34b590d3aff4e6977b0f3d043b0dd50ecf3fe592e86e6af902bb23fd9026358d0b68e704ae3b21dbb3873a606b471566872e3730cf1ccc4397ee05f0f4afc8e43a436ba76f0b7ad58c63eaf72e0e89119ff5248ea625260665b8df59ab6dcc6d9ad772350522f30e58c4c18a1564a54e8e9caf84619c432c4aa719232cb57d84fa2fe5070b0e1deb79a562f40ac66cc2f9e9394dc78925b4dd30ba396470958727f273efa101fb21a9a39114ce48f59605889b648a05708000cbd428c398b05751057f84d6e80fc3e69f5e480a0e151de4dbd73f19d612755cb46d39d889132c1766bbe048dc5de1f77629750442f91793e834874f74d8ec11a7d448d10642b72ffab9209f7d9eadf8992a8d019eea1670d7055298ee0e05eea9fe106eaff9df969d2886ec45496818ebb707428a035318927a76bd2f6cc9d53e76bb75359b34bea73744b2a5165b56487f131b7bed6277e303901355466bf0a4f16012681033f6c669255c56739318b695d908ea75a4a4d49b26ddf3877e4cab1dfb88e7caf38ee2c4eeea6f1e89781e94517bf214a861e69312d52795ef33db7da1d5db698a7902db08c3a5d78d441bbdd15f6177e80c5dcbad79d947c6c204e0d933f2127498f1621069f8f7914bbf388fbfd4cb795265c525ae7f35f3c562bcb3d813ff58e0f7c27d80f48e03624dc4852d6887cc68cfe4479432ed3ff531c5196b7fa8eca4b3c212fb562396c1042e6a38512fd94038d6449e896a4514bdedc8c8f674f29a1cd87da59224eec3c36196838b780dc6bdc1317c6ce854016260d889f60669f69793bbbae560d759bdf5722e7917201bbaf1ab27cdb9c75fa552a2befc61652e8025b408248ff60a308c3f5073d89cb798a9cdf32af0d807d666147fc3854dcbb2bf1b9f8c7f86bb7ca8816f83fb74d6f79b72c056945b0e37f6b67e03baf7d522fc2e56b8dfa4522eac3488a0f03f0964140fecb6407ef1cc43f03c012ce2264e976c55d61e321c9d2da6f6412559b6d102237df2e049adce87864716eb439483627f837de6129b341279ce1dc1dc0abeee82176b010193093c1be72adc2f7def8d0060666ec898802fe3b1c619e4154c61926e2ae7aabd02e0a0d105f5b47118023fcc69397b9ffb032acc197cd8bba0933a45dac3200fdcdb608ad819c5ebe030fbe7520f2872c8ba8df423760fb4a6107b911b3c38e5ae776f88c419eba2e0c0a38a003ba96bfca27e336e0a562b06c90f9de97d79f2b49fac4318f4c6b0a1692e8d7f944cd12fc93ce29f3395fe1e16946582852c30502bb58855b0c814a289a2d04fbb63089990c9c9259a49c9b16caa76cdb9737623d383149bf1cb3286a6e55153dc6dd7fdaaf2df634c900859a5d6b5c164261511db4f789f0e15c0e91c7a03434287a79d4d0c76a58508e2a294e1fb1d4fdc8916f085e9c7e0081c610979431b310c163a1a3d4d93f24c8f94061285a4d962e2cb377b07891a6b0e27eb6593b076bb02e1dd4c11a3fd3a2b412728242fce4ab2a88e14057cdeb5a3baeb970c04afe71f78bd9efe03586bc6617efa159eac223f633ea7f264cdaa6baf19164375397c23d48af6a7cc6f4462a12cff5e19ed67c60a71e541aff309d9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
