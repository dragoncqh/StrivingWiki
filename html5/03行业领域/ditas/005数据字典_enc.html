<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c38170720ec0a9011b85d370ed9b0ca2c08400e29e52ae3a5096bfd896a678183102eda43c8a18a8f96f9f04b821910ad79636e31b3829499c2dc371ea70216b11633dc90a1850a91f26b69d5a206dcbf9e93922a7a595d8665121c3d550fe88457d8da694d4fc9c9892934bd840204ed12a607a3c029f8b8a9b0a1501334afa639f9aa5653857a9836b54a286ec99935ceeac5588e7ee0f233363bb26745b91b9bad96e106c2d5760f4ef256531b273f1123fe6ccfe7be7931c0b350182e59e242a70c50a2c8a666dffc435553a7e924e3b5a8085301d9328c452f25e38df539569a13285fd16e9891fe488c92e8f1642c443ca82c9f048bbcbac55aea7559d070feb4601b37fcceb261b14b24b5b99794076f42c22a5af563547ef2af508bc80985fd57d3fdce934aa8fdb87eb201c2181bd03f79b96f52816bc3a8c100202833cc6de8980e372ce4538596912c964a55000feb52e5d6011a151d6671351088c1f6764f4cde2da17433a86babff97e1f3079d47d5d5b589b5a3bb3db26075131404faf9447a72b46b0817287f0c4f8ca1928979550921bbe7ec6c4c283b163b5226d0b9bb6cba0fdf26aadf69ee927d2ba9b091ab63d839693bd5f795b543cdc0dbf7d6f35655d63c52d7fcb9ab94a0564d502cf40656413f4cfc3b6f7c1bc8c858d2b51adffe8dadca98f56f8e8517e397975693cc588ad6271ca9498fe1dce2431e1bc1bd7599821957a6112129e072ae3161f2a8dc27d401e73a7f07548e6d9b228bef0014caa8cc921fd219a92e4229416b41c79c935e61107e0b1cf827e9aec6fb813938993a673b3e07eef62af5a29e286d291f61622f35ef69592ff8be13bbbed91d46c4db99b171e0b1386b3488fb42e01b7b5c23b774588b0555c660e32f736b67c8273b5315f3b5091f58abb13b92fa961f3f49c5f304930b708ea8bd33c41111afb6a7380586da981eb57d9e6e0fba07d15d4d31f84fd9ef51217eeab921c553ee7b567af358fa6cfd371e99b454d030afd6cab10f297c14d3431aa1713fad4a0c710e0ea56aaa6d4576821bc4084f64ba5a9582a28d501ca9eff2e26cec1c084312e4ea3948c3d78abe8d71f40dae073e5e1cfc63192861a141540e9e5405b5d9edabb0acbb185dc664639bcf88217528abe1af5986d943b7ba9c707f695f504883448196e06f4ba04bad93e95e8c604c5e5fad338c55ffb1f22e02f2bb9871621773f37655ff6b90d7639d6c2a134873ef1411319edee829824e7e8db418e0aba92dcc1b99c2b597f2facef88c7d1a000ab699754655cb6f405b946b82ec2fbbdbd6f7fdc7af3b5d42f4e9c4fdd061f515e24017bd95be3c17a955c7cebbea47b0b1d53dabb7e43dcf5ee813bccfd68e2a744e48c4c75fca26a46c614d52ddc580159d968ee69743cc224b87e6f2c03edd37b2edc38cee430c93a03de0495f608c93176e8f04e9bc7b5858b5f254d1cfdad0fb8d5ac3fd06d64dac77facb025d0ac4ff0646c4e96fc475379ee4e7bc5958bd08aced999ef7dd28812a5691d129c4f8222f8727c2577454ef1c02b3b126f381187783f22baca5abdb2746d3af9f0b3dcd90c64a121cac7b7a53a329353ce3e57465616aef774f447a5fa1a7abfc654ae13f5ee8f8f8be48b7299009fb633f72014cedefc8c552cc348f1651a2e7a71b62ead86818d73badce570f734fec30cc7ac196cc37979b38c4829ab7213108fdbb9c7e5900bc1e836ce38a3aacd360a595909af37c8c61d5c0d03e4b935aadd2252ca1881b7d36ba4aa4bb061a862875b15d2c57291f4c732e31c8d7a2bd40b6a25f8b7a71cef6bdace08aff558a21f5832204f84838466ead92a7db37c8c99649f5d70585f652ea1bd3533408126ba7b67d3e6a5e8d00acaab8e34d6564395cefb53aef9df3bc1f7c34c72d34ee4f2bb4d197bedb9e5f8f5ac6831d184fd6094964cc6050cd7163f8f7bf3c80bed93621b299265623f80221a0a425fdef947e6d6773169dc9440acbbe829f5e96adb795955d8029fb9ce89d898f97307221b4e45eda59b50f75564685043029935a40e773bcf555e3ff0016247f1b76af00ea9b3bd6a7db9b46cb3a47e02082a1b8637db56e4012f0027b6915103f322443fc64adf81a8769c54ff9b4c5f88fe963edda755cebd58a2c525f17244781ce7d8aabbb0610ed9f188ad8db273eaa3492dd585379368c987a29b1ffd82129136827c6f8f1528debce9c6c4e7a24c3effa24ff889fcc19300b5d6ffb36e678068a10eea6a995f7651b57ea7f4d5163bbcd3191210300e92f86280fea7319e615087a237f721fbc39099aac83d7d4a75d65093a4caa1597510e836c0d44a5fb767204a1ed3030ec975da7594c11ef42972f54651bd8d72d501b1b48514def50cd28a5b79219680e1a4f2cb75a3367d4b65dd298829bff45227e714b3d6dd40a430c57f596ebdf36d3cab5a2dab7fbeb6721d3602b2fe5f1ca65bbf02ca0a904a9e9f4c093e4bdefc5c202c923b46e1c7ee3fe27e875816c891ae1962aa0fc061b16e73d46a01484634169b78211bed212c0e017e36d09f3f86d893e533c8b4d5dc6a085159ef4df494a5a94b473b921e2f0917aa36a0b98007debdee38a546e4c8beea94bec73c556cddd21e6aa1dc5c9684df9b993bd5ea4971a85259c7790a3f59ec3aaf3e5895a7c9dd383c8eafe1640cde775b6674c7b767268d292fe84db79b587e9aec287920d52e6bcb938d463f59686a6d94ace1094006b1ccf141e721ee58b1586a7ec637ba8e2e1e6d5ee42f3a8502b8318ea925e2ffef5441010537beef896c848f5405514a0228f8e284db43dddb6308711537476aef91e5cdd911466d306b9afea4f84dabee9ac52adc206f00395230cb8217294cb50236cf43e312d894cbaf5081930df9bda0578f7c5d2e75eb07f893908d066c06d3b069dc09665ffbd2c44bc00b0046b866689aa347cffe03ef052fca7b71c97e100ed7d04e00c52cf87f3551350c7962b5a427aed047732fdff827fcfba9eccc4baf858b78021e902d2d0a099288697073ac6d71e2de159cb56f88f51afafa9952b9961176a54ed83bf0492321e863f9aaddc3d1a813b0ef0c752b415416bc0c54da89d1e0e706feb0de85a0f0658347799dce3a22a7c8baa25ebc990caec0be6afa7e7fe28126f4cb3e914510c811be277e5016952845713bfa4bb5f6aec4a26952484a0beb878542e5fb1d3bbad0b9b3613911aa87e3d0fcaadb91e7367c8a31def8342b20615ee61c0367a6e8b26877080b99d844af7a21e2cee2e3de8c86c6f263829a0074ea3636f479bca330aab07dc0b6bc59cbdb9c9c9c0a7c5546b240ae64bb81d4cf7c5faeac423b46194475977bc9291688eeee1e276908ec444a724c15c3c12d9d5e365e35ffccdfe519c20b53f3a437a82e5ffc19eed724b8f3d8fb64d9e829284d57abcb26d467e417e9d5fa0a76f56c229d8b5d728a634784c5db77c21700425e42087971b3d410e52a5cb138abad08b672be7999179223bb03845f040b32276f626ce480e6189a267a4e7a13e66c7a6d231ecf41a72c76982ae66883e4e161cb0158fce0586ea3479596d4b77b27555ca53639d2cf703c27cd02f9260540d5e9eeb118ac2a2ce7865478902cd90e3740fb69066bac57272ec7ea1608904f66c7f96495c52133870f02f9f5c4d0d1f87b8a3db7459639b9e6f72f3ca0504a1ad4dc8f5b2b2a90d7270d3b918b4b3f3b389d16c88132c4c3be63bb0adddafbc0772d5ed7aac7fdc3c19562ce774ae6adaa1acda3571fe89629a2d9c4bb5d63b724d7920d2dcf2ee2c4753d439279218aa0b2ba54cd720fa859f0070c3441fb0c3407c721dd19ee3d3adec42b7708cac45526f30307a9c6d3be1ba3d2881ec538b84f6ffafaaf1baf111190f3ed1e104197bf91dbd07e550382fa0f8dc0b966aaf325e6abb4b9aa40a31fefdf2d27f9bc392b91dba3d9187cedab2dc6575b1b2df1bfc06e3ab5b2661b21081fe2b025ed16ce09037a7b5b6013fea4c8bf588f880f419f28d5e662a0fefb72c350d3c5d5976ac34eb060775fd10efba39572fbdae1d1eed8dcfa384172100cb6177a717e8374af32e190a9a565b3011ecb6da7f5b281ba32abe314ddffde2a972faa6c4910221fedd0199e99bb6732f61cecb70d36f90221f01850763d125c8f909501f3b18cb63f6b890bd1eda38d0fabca724fc88fade5f429b5060dd88c0e0ce8eb840ea26a52d7ba64754918ce51dcd50d817a78a47735b832b99102d82dcb7fdf5bf8e530a6bf1d198c050281b51aaa16032706ee036702bc3f8426fb186cb5fb4043c07ff64362b84701f9ece02510503a3e3e13295726235622e97e616d6d3500314df288d798d3f8889828bc74c95fcfaefd283f14ba62bc822282ad1de52f2c9e4968f9c3b71028bff5b351c84330a77ecfd65472feec726e6a2886526b3c53aaae201a489e44e67121ed384002fe37f2c198733d7ace5db8c56ac8c2b833e6bb00250288378b4407b1136ad8e812789f1471cd31820ea8d62ba13395d3d368abe4352985903b00ee3faf1adbd9fff63b324b3eb51665a3fe2e815d0a8fd1f5af1911cf59bafc942b60ce181823eca6aa5247bda48751fd51786b284806c5c7beea4b813322631d3493abc812b22eba420f440ec013bb3dc9350e82c0f1052de16146ae802751126e13f7adcaf91ad0e4070ae0ecb5948441d45eec13858f6bd94e63235451aac6e50d7b1147d3fe1c2cc6574efe891d51bc429d7fd5dd2dd9516a5514c87f64bf4815fbe38572ca4bf77a4780cb191c2be8ecf7437cc1180df5028953fb454a511bc29efccc2057c36a2dd0d05453c8b3847d7b60cafb697067cb44d16faa4e0af8ea1f1dc297a1771c0656f827848210474c6d669e70123ce22644dd255df32d73bf4d8ff399c0a91c981da890c5423ab08d8d8d30f19c50448adbf5b8203af7ea16c03668bcbd621d7e4bb6f9fd7625bcb77279bf35118ff8eb92a8bb532b8f39e53cf73322e6d4441ce74f0e8db6ffce4309f987f61121c12c37704fc5b3490f14d2145c28c3a8a0729ca796d6ddba82edf9b28cdb2e1f5b3b0b36bf9e9d2c9b5b02c170c16b8a1cccbd9adfab5bafa4d686e6a58079390a7d3de2b2e815f8f7a6366d6633032f5b2085fb18d0dfa7a90d1638de01fda278c698b45b4e1e73d31f3ff58ba0520f08d86cf2bdef1733cb273a65b29839d1fa066f85ece1b3535a661d037aff82ba2fdf18e4319d24eed5d9029c11aec085f43b873ff520e7882fbaab46d3e5fd9f9c50786f0136437cca4f883cfb05ad97e7bb19d14dc3edadcffc0ed76ddb823763f14b223d550bbc5fb8a7549b73a0c57bf8dc5f5d29b57c81ddc5be498464370bcc913b12349874f002ac4d7dc1ae89ba26dd40e513b5a4cc36b76bd2b3b2c1f1848c89a9f0a2ff2ec539b02131dfa28e4ed09aca9584ce9b5f8d07d1e0842fea38cb277dd0c14ec8a23f5de8a76a0791612215c22d19c6e74556540f027ad636ceb7aee1dd45895c61fc56dc7731328b5deb83937b68b2d8d5fe93f3fee1291132e9c0d24211f240e93e09e0b9e2c5fa9f843df406824b4208cd8b2172d9053e4a6e7623c1b2019bd81b3b6a5f9fc515b4423ca910b11560439a205d89ae1547d0a54398776b14d6ecf36c80b2d59f13d027038c29c6a3798bc644cb1175b57ebac1baafcc7a1a03d48d00a267e9f7f1300596bae69e576e7f4318ed640c8b80e8ded1eec19bdbb9d59bf455d542320f343c400b007b70e81f411f1bcd138eebd290d4ab443e07d8539d4a7f62524d6821e08c15380f3bb7a5299561cc7231b69c8cc2ac3266120da098aef7b9ca72e41f3d03feae6bee49f0a13d63b61d3c8577b16595ca8e42124f6fd74330cd10fdf9948eeb2922379ace0d9100b84c9f1bd3e9afd97dbacddba42e9f41c9abb0b1e6a9518e0f76e64b4ab815a209949275732eb979f8627f4246707d7e8defa8ce39cb169cbc82617b1fdcf57458422949b812865a1698f7ce40593cff26e0a12641549642a1a794c0375cfb71a2725d76a059e1bf9c44dd4d11d8a9d704658c9460f7cd2c97a778701cb6b208d9036bce4b75a3eef0c241e49bf2b26a5ae3501dcdea9bbbadfecfc846aed70b7f68a7a2945c568efca0cf88d9919a2cf155afebbaafbdff0a7efe35bea823963ceee3b976b012f320b5737182cfc6746374c38acd3a51b89ea2bdf7fd5449a7467caaefd1736d35e7387242d5f9fc075f3a1a82409893e3e1cd78a19574e95364f335ba2c22dd96643bfef1a4a0f98e851455616f8b57d22790a522d9812c0ed0f06532c26719cc9b4134526fa5f723049e0dc2e206108ec2f910b391776e8785329d670a464c0dfa1a4c1f06bf3d51fb8c46d30e2a26a4cbc0ae2bfc14db955bd619f92a3b0c5d82cca3ced2babf4680a3cdb8ec11d2f89caee283a60be38c639b1d1495e5b851c1283ed0587b4834e72fb0d4ee185ab736bb9bbf1d56793f733b1d6f38892c2fc0033429573e41365510858be841cef8092397a3d14abcc69ad2ba5d06d15fa1914ef23645516861845416e9234fdc666824910d70d31de63e0991894b5b6ca36961da9b720eae7297df499b8a2ff81c12bf3914094f909410879cd952876bbb443a9a1b63996bb6dec83e2d8488c45e0142329f78db3299e71bcbc58aaba72b863f510e042fbdb7a283f17904d4585edb9962150cc677383ce0b8f6ba1f9196131894a113493bb18eda9257e8fe82be19f471ccf22c5633fed91cfe5a46135dda3744cd7582c891da9c47c87da53783601d7f71f80ed8f3332f190e0d1078a3fc85904a540ab4cda765cc99ab9a0db05898c7b86caa0ab22c3fb3b2c463f2e3687d7b161717c305da92551aae850fdb1e3d28c5f7507af2bfe53fd77a12a084533cb0f45b7ec3ed8beaaa17fc33b86c8a48db043f7a55d2b192cd609abd02d4ffc0035f649e90be29aa4c7f0fa43f4c13f96858011a2b24f27bdbfd6a7167900f0ce6ceec8f29bb9125f3dfee32ad787e91f59bb61e4daee458d344d367873d54ce8927c582ea464757dc65abc56c69bbe2e161d5e7d476815f5b05ef9b56c7fa3031259420d795b838517933027a7c68d5af4e929d9a6ae3b3f8a95f423f0d1599e0e8266558250d38475a0f2b5ec8aa3360666cd226901df5ce4781bf8446219d868784238a2963ddd521d5f604254d2e5fb5a2bd87473c424a511435310a3ce2313e6b85b7d587486b8139ff069bc3dab201c9fe848c7e72616b61131d717becd71d3dd4b5d8293dd5f6e0908195bedd3ecfdcff46e340f6361c7b0e56fea57b47e3e9190c6e0258ff236adb8a1a8e78aa7417e6ba410442b7333b536f2ef23c11054b2133c8c3d7c52bf4372db16cc15df4c13e7c354472307479f344b87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
