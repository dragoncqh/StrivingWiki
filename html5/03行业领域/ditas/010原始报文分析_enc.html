<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa77976fc44f1072803dab593d55c8c7e50f83519eb27b75f8e20d514531ab713ce792514521d5e2748e5729cab12ab2f16282098cb3e1cf7fb7eae6fbfe2e4abeba12ab1c08009f0cc6d9258e79809cf4d6bc2c9d418d6cac60cba56f92939e5c717356626e886537a8f88bc8b7d2c7ca7149ae5048b71137bfbd73ee3c429b7574782d2c95c314b2dd0d4a75f6abf0f5ec1e7a5d343ff6f6232197171edb14bd9aad3753a2543fa0c54d8c72a34e2e6c20b0fe95407f80414e2910b98ef48d8e737dd783d0700651618fe693f51239b1a315009cf420ce759e405e716a4c3b2d6425f2306f5eb5465994780fcc88452eb20d82fe5a67e2fb253f5538399581e4e0769a2db38ebd94c4db5f327c588109d27619c9837c391afb1bd516525c9c12978c1985341624c583b76999c19065791c1564f2cc1c57f4e43ebaecde43b03de400fa532e735cabc70ff2f79efde80c525fc27f0854ea63cea68135a1e5072657f2ac23f5fe4fd1f3340c7949c0c8dfa2695c4928a7db943be61ef5baccc86f2a3a9e36a1a689108f2fe0ec9401379d009107113cab9e3205d2dadcd53350f2975179d109a6277b0f6b1c7c5661da60d0d2457d1abd970e41fddf4f06093c96e748171aca7d982ca0222356b5b524823c297d193db174cb78391b4b9f4601aad4cba9ddaad2aa512b0fad6198ffcb2cf33808788cbfa5fe2b69d57936f79d62ca21e749fbdd62c0a0b44ad1d53b530841ed143dc14e344d2862eee070ba6a18a61f8b37a5d05cf0b8ff7883218982d235640c7cab53f6a70195314214ddf0eb4c76c7724efc899739b7032b1abb66f146cf8bd77971d96f416f41265c488d1ca5724148cf6376825781186f27728e814b324fd6ae3038d8190a163c5075bfddde8a581328d3320d3b49701a33c241790716fa817e01cafbc825f413727466ce2ac55c3560ab2185f00d83f796d5b08bcba51113aa701c8ea5ff3b7eecad2702acc541e5ad62d3177a262e3d6b4121a7568288ae448485f2f54ab4608497641029c0a37b75ec9bdcf8dbafbe7b04650d4e74f4236c2fd21d77784d22b13524a9c4b6edde15cd219631ce243c0c634cb6320dfd5a53c441da03e5ded3b63251402cc83594618b170be164ad70b020dcdc109fbe902460a81ca193e9d5c30224b241b2821321ba89d5ee1d25b88f8a23b9d72e8185c339ad6f6349ca84996864980bd40f3355caac38527f8232667a530dca7a5962658b4cdbbd4adc0b12537fe376172d71b76853c72e3b56cdc7bb24c57b21c01591ae3475ec4b7493580352aaac91dfe42ae7ec002fa268b0390a4d5696f8b9e7a78414f8359bf4050086c74f0b1a35548a9e680f4a167abed1008b1e8f6970a2e3c6ede0c7472c1160eca96212d279797d202648849c97056ab5c0ee08da451f644f01b54a7c32049129dddc2e9eaa0607275e2a9eec81f55fc31b9c8e03896e0f6f389666a4f7d0da7618b4c5e47c02b1b515dc9970765ba94a5d2b67ba3a172ab9fc1396127e97d23bc4a7465476751aa7afe7b74c270d77b46e7637d080b7caa7dff3cf16926222496da2642b0413c368bf9d0e9264c12a8cac42863959c784619bc88aa80c621651415af47047beeb2d9737f36d7ad68c88572327d7c454e6cd6719afd5d412d5bb85eaaa4ba760c99221933a36c0a3d666b294b1a7c567a2fe03d75faaf40182f101df5aa7d92ec0b71e98e934400fa0f352baef0f772b2d0b7372f5bb9d6124ed1d6f511e5cd880a6a7256e3e8882706bf7cfb3f950ebffb768f03c39dc5bd04f34aa89172776eb81cefb8a4ea219c27635c027316647b51853ce819383f82edd76994a77d9d11c35891f792e33123ea6e9329aa66bd607c25e78c34131c171897b6135dfdf710acbc52575752ed8013045737527b2d10b3eb013ac0c2924efc0a755dfd7d3be88f6173b86d1dac2808aab5a23c22cd6c64e9b8baa92f2b7e1399a96d2ee04c318e59ef326971c96d7d55d05c9d86cbf6fa11870ae1706d795d1e6842a9210337db4671802855516744285841e27c7291ae1c0196b9b1ff0f427de64bbed6b4d21079c886a65f5633ec86a1c75cc4d4512c82f9c6008e6725e1a4fe619dc608928143f8da1193f2d75c2fbd7fd525b2193caa621f83a3bd7e67777e4f20be3f33e84697a8db147cbe638676efb0d4c7be2ce9daa6f40446f3f9df4751aa9ab4ae6bd5a67f26becbb250658fe7f819b87e3b27e1e9690ca10db586855eb814ec4171c711288fb3d13314f146653c03a1a25c617535693bd36ade0e2bba8cc4356b2dea634f829bf1a03d56ca26f1efb8ac0996a936c295b2ca9ec7aafd738172f9b3e5cdec9f74ebaa89d713d9f64ba216f442f5ce773fb58bde6ae99ab55855d69771914f5ca38592710a5c8710e89a42cd67628efdd0035c4017a66fee178ebea4daa62117b0809d96dfd9de1d81bd3d867927659d771f565e98e35f87c0852fdde9dd95d118e6006ea0ad7307ae54e3034cdd71f66cb5e0ead5a496344412f6ba9e8f5e41c1dc199271b19a9b146cb84d897f46c17db1e535b6f9582656ceb7675a6033c5b1c114cec9fd3c5dd26ddaeb3b741d327a5905a34ea4737645438d036230182c09e2ce247cff460df9ffc50a9d337e15b9c231bfbf855c6b9c6adff9d459cd3a7fd4be4979b2d18bd20380898b1f65c764cae38a3f5bd01f9e373b995418cedb9aaad08d700b00625b6374cf6b471f2d054bf73633e214b3a4c514a47827123192f56d7f3715870927911e88cb0bea19f989a656495b797ef095c9d9d96774a68818f28e311e34d008a03e74fa386aa487a4caff445ae486f63d4d6a1d0cb9d90768ecee2859324b9523212e4a025c99852184f7f97e2c4918120f78360f55dcbda7381f67f070351012311f6c82e81ccd7aa8f32a13fe88ef4bc8fa7da55204d1806e76be24d17c29097cfc209cc2a29f8194704839d0c0e3300efad3eef399369c0d83459d955ad6761db3bf3b4345f3fe41d4193f055d122df6e4401b35a2624162d00339afa63e3aa7027b36f3c22f05e2d654e7edf2e78cddd375691f984da4d399847869d78c43aaf9885539c7c3b9adc5adb7234ee85fd4cb75a960f3551f337961e7461428905ede46be3141bd3a9c3f27f9fcc46f717ed3d3462b26161e4972601a1ab5b640313032a9e7e1e090ef2c7092f8e048a28e9832a21261df64a1a01558292559ce8f67cd50e092c39971109a860b91d738dbb9e745c8c211be25081fca3937b192bc4d75592cd258d1bd78f1d28847fa9ef0d602b2eaaee5a791733ca8665ad4e4d3c9d436f2255798de491c23963d6c68c17f7acbdf2924890602bb74328ea76b3932473b0497f0da12ea2300a9b4b4eaa16500b6976a16fb83ad9e2403e83631c0641fa61d26667610130dbdda20f7a9b73d82240c6c03235b5e2364170565b97c9b59d3b30832d0305cfec02a46ac57f3474a2798efabcb0122a40e6d47a72b8e14193fc685beb2f9bcfa23e78ef5d49f5f92d3d5b50fc42054fb2ebc8601d47bbd97cd263e7784d905fe4a32c362665e50a2da4629617be3a6ca16fa38ac8e95322de27b8f074c1f7f0f091890a784c156f94d50fef32109db7eae3b29d411d625e55f11830c6f81d4198a40d9f9ea1ef4dd235eee48ef1194a3da8645e6a481b35d0b75beddb34e3398ac2a4118f8aa7d866bdb031649cd09eadd9a3e44b75c2e3cb46a15189691aa77cfa1ce5b56213d864b75b3705ea70f253fc53cdcca3131f8bf0abba70f7841f091ac249e699e457f3f4a396957f13c7011b88aa68cfded7aeb41d612963d05d6779cf9b266b7a0931cdf7d6469c06709177d79dab816d27d016237e482fb4cb02bfdc6593e6e2cfd0a438e9333121752573c4d0c1616b4b11c8a1f040804b2c9bf5ddc55d9561d0327edd93c4d79486626ae9bdd97b437355a4e7a08e53bb71ce81dea30d09f5b36810c0e148422060fef6581155be4c838789afb5aa42ad51fb76ccf7f7a656be68536dbe881fcc7be28a311820037dbafb4c5fd915517d915ca2166c64739b0f33969c017d853b4ab1b3129660b4db144270f45cce149c4ce7017fff3bba6f10755cd7a6bab7dfcf7272daa02ac0ee044b02310797dc8d79386a20ab276c8a213fd2366552472e64a1d140a7a79c3c6e1e842a73097fa4834b4495c0fedee7cb28b9b1d5f0fe950bad8304adfabd040506df3b2854dcc15c52d6e6c8eb97f9c710593ee1b923657672ac9f7291feea97532f77321e4b2157a94b48c7cbc17729a7e9ed7b9aa36b23f5b1f3c70880087eb82bc835007b917d44f19f663269e555d591b367b15266db17fd062f22e3bc4ceaa6c722269597d0808f4ec892afc1a4c7624ceb38bff303c27ea5aa13a18136255e37d76620f2a83d9cc72f8e7a3e53debefbb5d0d2c078a5e5968fb2ac5f5b7faaa6be2e54371a5b0467c80c7c651ddc204b82eca9e2837153e2ebeec30e501f7541932da34fa05c189303754f58a5bc11dd93598f5b78f18b6582b6ff2796200ffe08e07838c04d0de568b6efc855a31051cbbeab09242a7ce31d080db69f248695235d6a257adaff4be73eb7a628f98553c406b8d48b0ffd2ba642f6a9634185b16e29042781e071565a7036eb37cfe4ca6c34f275f0a906e9d88a8bd016fab492ea5c398324bc7e3063344cf8603123d443601869b683e4f341d114a039fecd1a04929abcdc922c60cd1b1bcd8d5d34ac7578500a42d8117739f40b2d307ba2008019c0c51119e0ab07b3c298f139c9a11b5b0a5b83de23af1a8e4551b44917831bc1a0a2ac78fd795aa5750d63e91aa0a3f03049e14020376d7126a30261b93e6181c60c1963b65e61775d1f334c95b6de28fba36553ee56b77cd1a810b06fe556d3e41d889a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
