<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12f683483f5e59a6ff5e54f2b18fcfe25dfe5defde4909d19d540ec8fe662c765f9dc0a34c72dad90dfee1d6eae174324c7ee680552f0448df0716c20001a5e9bb7c16d54a880456cd9704f36838a30af17df2259fc6afa44e7b0ea6c8d50ab5024bdf87a20f7a4c281d21dd4dfa1cbe37f008232bbb447504ea6d7b778ed8945aeddf8ae7196404c0e5b063f00f6adc38ab51cc2a576cc9f3dab3f428cbb30a0b73dded5c241fb97af76a590e5dcdc966c3fc3fa77c3e67f8b8dbfe062222df581b7da77b8fdfe7b8be66101a9964b6f647ac2b8d69f68637c4bb890193c813bd94a52ccac75b67ba1ce101ec157178f7561f160ffb883126f46c708883e0b70ff0db97a7e92425f4b630b6ef690baa1be107a4fb6fbde5abfcace7dce04d41e3d0d229ae90070e58da648a6c40da1d33dffdb6c0079f225f3bfc1197ec4b6a1cc93f6731c90985c5925cc455e4ab83b32fb35766e295e6187c1694c2344f028432f773f378e07f85d4de530dff995a5bb4ffc0f705ec1a6f0353038617704f5b9e05524bc722f4700315c4a0eb877dad64e3c717f322fb1572fae624348b0049bf3c9558b1cc2ed8708feb3818cfd6290255a1789e2b77f2b291fa4e2c43818461f3c2197ec646f5a41f838e7bed81b3bfd1f0b693230f6a43fe722b3e4fa4d065e2231b2288d456694ad6187bd2e445153e30f8a13fe2a2980ec20994fbd8a46c8f887566af1150ab4336de65b9fa8f158cb3ec19c6d6ba38fe6fa5c8bf98d34f1bf7bfd5b68bc01d5eec510d6b787a385bf7390e56b860a7a1bd3d42f4c15a13a0f5a83a9dcd16565a7415e68d418a62a1138f2d25f9e9ae0bebe23dc6609d4116928a0472f32e8e0595eda978a1e3cc062e581994a3a968b974ab7f12768796ee90fb9914741f6fc5036c87ef9f9ac55f23a1a2340f17cb79d6dfff7a9c7c6d63b95c6afb425c53550889c232a4523d8552394e6bfe52eaa86b196fdaf0e8470b8ce65c63093dd996654073b25625dde49470a58dc8a16c12e4108e474edb1f976ff576c8e200cc69aac5cc8b9834066dcd06d0e5f285c7670eec88c592cda93404f36b9d061d7fa8ddb655c6df98235b1d474cf15a05e277a08d65370e6523e7ae65f1f2a0c0f1e5c77ea51dae66e4b3e3f1e9aad69e7a20b4636c303656db178e185578ed2693e974a76c50ad7ed769f47a2a8fe1a2ca04cdbe4ccc68facbefde8c9be09ddc9496e813e9f6219bc2f8cbef278d4d78551817e02b7119ae79610d060961392635a8f0aeb8fb51c1d977073b99ff1c6537423ef46012b2f3b2b9c353fe33d3add00b30db8b14abad19c511f73827e7ebcfd1b849cc4350ac24bf841b73efba76e70474269614c84a3c3c0b908b4b612a8973b1aebc595decb29c419c5bec2d925b643c49763318cef19b65f445d9fa318b460b0780035747f72239f4640d3e809bfde5eeb71ae7be2243e9cf26850862581fa91d6f2d30b86cb245732d12ac75e67939d9788e56a250e17329ff179165fd13c906ebf7522f0a17ff0f4e3889da6089a65debe94d6e97f10da6b8f479897782fd8c567cb7a19c2510194ffc8bba6793c54508a944428e3615a8c89016f1e5ba81d1c66b5f7b516578564b0959be2e6cc214021bcb5c9dad8b4fefcdd467cb2f7f228e9d9377d082a4faf21d6a9291f65180cc5bd4b2b1db86bbf6647d5f897f5ef7721df337cfe56d397f470d1c7583899e510bb93d1bcf02bf0ae1eae02a92d5fc922acccd0ae4bb2e44bab6352a6f266d3540f83e80a1f788d14de8f6a2436574087f4962306e99172e5f89488b587405fd4727372f91325ac78dffcc8edbcc85e28e878a3657c2b5696f7e0c4c18f897ccfdbcd5681118d73eab8a3d88434524f5e3647d30ea35fd937eae212c0e1d2cd797cedc5755c0f0354b37a6411f6bd34784be1af251cc609b3594126773e645ddac6ca03767034769486b024bec6ad35feab2553285b7b0046f0a3f014b828a9dfb485e7a053d5d00230d5608713518c4237311dface17f0999f0639e2bc5d643a15e0dec7da778b1a2eb3ade8be81bdcb02eec55bf1219df44ef85392bdb98caa69e8dc5494d030c50826e7444888ee4c690518e6e421bd1a5fef2a2c549f602a6fcbdcb1785ed4e6faf0fa0450327dbe97001b91e00e3c4bc18639b1f9ce2d65e64d41aa7887616ef215a4384566e404d009d074125d044d5e3a78cc0c116fb90a9603623ef4b76e16dd03913e60f636fcfb5b272a2a497308f9f8cc5a3a9b3f0e26c8dc1aba200afc2c32b5defeedc1fd6825f3cada2c2934c66ff3e872b784e8e62cab97a340994ed6709c5909bb211018a8a58d5ce85f9c8582db7c18047fba4b09fc30f3bd2e2fe4e17f5bf4bb7a686d3153d7314f305d72c3012c47718790059d35b6dc979873890441bd21879ba6bd562b578a5b5442b3d28fdf1533e7e0afd971fcfdd2022dd47ea9070e047829d11679336851ab60689ed552558f5c961ebcf06367e33a306cccd5bfef2f242a64f0dd25888def1c16f8fae030247b215f335339309ed76ea72074a44fa6d8230d8127a56c983e932b81920d2572ff56daf797b54588998da750e14b733ca9140d81fcd6765260591b28c1c2778a8cb5f58a6270db342a60c9c45b292764e2d01dcbea9b1390708be554c0337c9350003d0701b16f3d24b96a93dc9d08b31bb916d3ac6ac02b1c80c348b992fd306b33a9e251653946a63ac73f9ce298f0d42b2c754eacaa541e66f6aa6c558a827b48169ba76da9480e750e0f952b665faa548a3f71e8a7373785cf85f3e1cd40146d673575617fcc2bb40d8d0f4671cec820e2ed37b5ed59567d6121867a6166d96801e86b655a4672b7075b98ab06c3628056223dff2530a9b07acf2f3768960d25908088a3b8473995060389c269d64917748fb220883f3b12751a439b2f7d1d1ceeb98af8751d59c7ece6edb89de23ceb558eaba573c44085f534271cf1c8a9b4e026a4408617265d8a3a7d5552eb8d5eebaba4eb37a1c82fdaf2f8a160ab73bac2019f70df08a7b57600d0cb06c97321adead67e5a4bde1c06bc86f6304bf6ef3bce1092c69dbfeb8a14508ba3a89e2d240d5f0f217569bd4fc14cbee0f603e9b280f9eaf69437d538497ba24f206bed9897df9b616678f1cd90c3c3020ac6e7e1fd5552f7af095028b59610f529b4b59d323cb22c27251f98dae01aa1ee761b525a228e1e833ad757d764a10875528c0d011244ecbcceedbdd8e7a379e85cfa0386cfe6e6965f1b7ad3174f23c7ad75651ee2a2e51bccbb9fc29adcabeb094bbe51aa5dd005b39b906dcc84f052d10292075d41b110ccca97d9fd1ec82c9191603cac451a978db15ada8b8b689553107be8a6e14f80e55aefe7d7609b50bd58e26f27025ccddb10ae1f176c9a8dae50124ccc77f6132d57edba53fad34f0a544c897e7781636824e065583f169949760a70bbc997e9a5fdf649b22f1c751b3632bc413043e876b470f73995a6e0cf025c6eaeba9051c178f59a6ec465fdccd9f95a9309039f00d2df74a8640994041c0bf3a2f3de9d02a379089c7b61bb42cfe45adc50598b9471d6022ce21d346b5aa890ffa059843e3f0c572850b4a7173cadd3cbf4294f9bb188a7afa924fa5947730a532b16cf80444005db45040e8a09c8e78f461d50eeddaacddbbcf71aeafa7b4d2bd6aa5acafd045968e1c4ef814b9306071f690a20ff0fd88e1f4e29ccf5488eed3ce4e56e7ca0530b9b3f49993441d53711b6dc9f9a356be56c88a463dfe4b201b5c78dcbd99fd7fc818e06d145e0c44a84ac484beb6db32f87a704b36592421da3037bfe1a3352fb383572bdc1c129e734c62cbe32950255ba16d510399f9d7babfe915af536da8e36ea41dc61e0d4ef901cc4e98a6873313fdacb506851c2985f4285d2435881b7ac01bbc96a5afed09aa9fb87cfd75e67074183a88d5b7342db4094b859c2e83ef9680ceeb212eac46d0fd122fe48e2dac1e30a8188252dac7ed44404a527aab05eb1c5be5a3490c480366a4a05b7ec5fe30ba758d2b3d11cdae1bcc773854ecdfb4369727630d59b19da588873e6d1dd6e04549f3910eda6b54dcf14891148513db298fb6d3d580d98bbb2b58e7d8c8b21d86012814100d7103a5624df3b03c24e5e8646247493e06a0ec1a4b2e9fc89b30305da3f2c6309d59d0472c572d683897ca7470c3e6e3edd096fde0ca63201697ebf1d4792977eb94a5dc707c3ce6d2a492ebc2587a771329a462fd9bf3a6adf3811006039ca55221616dda5c4cd298d25cd4582c3a11d84a48a589b9405f888ac302d670cc519c14fd89b0a8a43ee6b000e7a4fd3a7c1a325027697666a59fdf8e5ae482f14f2a38d43c210d88e17b14802fe8f43743152f713e069f45df0586cc8b0ec84b803ac6db51d5d896b3ef773ebfd05fbd04619eb52bbe9688fb904b35cb8664ea8eb6ad3a898636e1adb9172a306fdbb6e6f329c20a8982d2a34c09aeb97ee11adf579b92bf3d04c30044c8662105dfac85d45c607c5e9e1477e71728949fcfdc33f14553f9ebba7c6234db1cab3029a099975caa544547661c0d65f1776fa08810b753a27ab4858f6d2721732ab9bdac7c91e29430879068a4b6e6f1eb46c5e9e15fa76546b540e5f30d4a6aebd70a967fecfe4a267fa6f3f7ab6ad644f4ca1789dfb7808b2250210972904e9b813f4c1d1b53449b8fccd1242b2640f73e50f6d18fc62ffbb173c4e6f6bda3b01a8170b9bc85a4679bf8bd73b588d5d89d299d1deac737a4582ec1d80092e3a14a5f5ecc7ec64f37fe955de18b8932833457860a520665c29d84baf5b26ccf664dab3a044211e9b39733a7de656170bd5414bd80885c3d89f0f9f3971e4fb654bd54375de360f3f213e0ef58a48558268558d9fb67e454a852b5365b85cb4ccf88cddf4ca3e20efbb5d297cbf7a93eeef5dd15b439209e1d5937d61c8e588af3f323864f21a71c4cd50ec89351a2a1367b5cf3ac90cd57659d4f936f40118f60f7180891bdfe5ddf64e0e87b5456d35b1a155be74d1fc0b316a0f8838c9f4ef46be1f40eff9efcbb632dfbfd089d077df6350527c5d66ec8d83f5489d19dfdd2459f1353f3cc6a3c337dbb1a55fb4bae958acab7999ece5d8eb6d253cdc1e6a5da39b68c4851df9e3350e6ec0ac083bee3d3e91a37f637ba59ee25cf2ec6c376eef5ede740de157b20de0d2717381b79ae90fe852ab95548735d8849a90cc3253ac12e4e353838050133c19090884b28581cfc60ca3f5e008ba6d37ef086e9252a52b22fbe3f173a14584f14a31c7c0deb4a327b5d0a4589bda58c3ffbcaf241535aeaeb9f0dd700a77f00d3e308ea19e7f71ffde009fc7a50f48a1f546c859b9f04006d7b34428eced8977727338aca4e38f7644a0b11c8d22acb4a405d8392afb2b774ab9b385a67d086baaa98d84389952691c5a57774ee21e808a5aef9222f8f7dfefd74094a24dff3c5ebb1a734e9a88e01f3a8654b5b2318b1966e6a612a9a40a5f1134dc1ffa66882ebedd73bacedf1ee1cc3a81f223dd13adc07c71f8ad4e68b884641e79cd0014fd8557c780d77a09a4c9c4dbaf9d1377d06be6aad5ec9a361578c565051bb09c84ff233558ca20108ba8efb05b5f2129e3c2b254ee4e2df53f1f5f94fc612273eca712fd09fec83472f86d5926f737ce26239a561bdc0cae6b93d19f897361a8c5add33fd377b92112b85f79dfc4d78d0f77783a55392fc2fa42bdca120f137a40404364766e62c8c4a50929bca901b61e40d2659b2820d4b90a10548149296d1fca8a0fd3870d7a114867508338a8b3fdc443016ab2a10d4fe2b43fe7a0be981179f74383dd3249822ded2a67d17476663745de5814663a11af038a5be58823711544d2b0e7ce6a339f743672ba65f0dc40ac11219584578a508c4f997538cb52acbdc7574b3a466efbfa0344addb00c81e0c5b8f338209ec1a43544f100594043c26fa2629bd60fd59d88b38f05b9a4ff3a01924a7112ba272fafa59f686c024df82df62f5113d43bff347891db0b1cb39d357075925f95d47d21d803211bbfd385594cf2606cb4b76b57d90828fee07115f30f71fb5807046f7a2971ec7009fad5acb5110779f34214595298a75e2f3b705569205082b957d77c0c93d9f615b6babc81feaf18d8ab292b16fdea9c1b153f923ff15e4e81c1e5242df9b4f14302a09a555ea705dc57ecef4d58a2463b105d2a118a5ed46ef1c95643587fb64d6dfa025f4e2f4a2aaf3dab2fabba6c3460cac1ead1ddff4c1b9b74d00d8bd46fdef634ed6521ebae8475ad8b9366fe327d8b4be775d36f9938550b070ff823f312475ae0d91c95a7c9ea955e4b4b9cc9b46192d5dc73a39577be92f1f30a34afc92240ecffdfb4056adc8e68f0b774b9bb7fb4511ac84b879f7cf065406351b2018a3e75e72d23f16238e45984f0f60e42c77fdb8b04f74c8d71751d4fc12353581e2d527ac210a30285f7b2d5cb60a6720e1378ab54df9742241a3c97046fdcc23bdc3177dc2b6a297258d59566176e4e8dc945061ac7fa43ac88e4fecf8c87427851911ffb487159ea7ec7b1bcd765233b604b693533e5f543f8c8c282d8e9807e11fcd26758c3184071049dd2e9ce17712f8337db4a2931cfb664348df5ef92876ba0896d72218fc4a6c53137700d47e4aecebabb299b64dcced0f2a6343b89688b7c2f33e3f0a3ffcdf09a2ae940f2b158b6be7b2bffe827efee47dfad961f5d63aff59804a4d6c60fd4b57efe4e1cdf527e6bb16cfca276bf56d1e0ba624306085cd3c17c412232be09ea57d91e3e9ca9992fbd5acc74c4a16ecd5d6144c4c09217138c605a2360cce517b85def581ce0fda7f76d70fff93e09ff57a1072e56c8e1004f5502c35298129315f69a0129332b33ff370f3e964a764d76654f7560bf09856db4431bde055db1c1ddb993348f4437fbd73aae2e6b4572b6ac5df010842b3e7a26fe2a72de7d850e29a9b47b2a98068991045cb1f96549c35be29c0ce2a49ac99ffc56a3069e61787b423266c21e2e3a267c77b9c3fc88449ab8fb59c2009e18a4f8c6c768aa2246a5f7f20587feaef2c82f87d45574d95d59680939ffb1c9ecd7b158dbd5d0a800cd869f4972c7c6edf0183910ccab3dd045f2948d96284527ebc11b05b30ca1990b1cbf88079c11f6aa0977eef00967aaa6f2b076b362f054824d96dd9e4679523286f1378abdd227fbeec6b1a0f41641c8fea102f96a94f751f1310d66335f6e6d8ab1a6ac8945af787adfc229cbf2919b682e4304775c7543568c8bad7ed2036bca9a327e162347ffb1bb3ef979bc88ed573a7d4968e7bc39582437bc29622812fe70cfad466e7173ef18ce1b33a70fb503cf6dd51efb1770b97db9acc1a672e49b10bfa1811f015d782f15a4a929a459e3fb25412c7d284b8c2f96082ac9ce131a98a736db57e0480e754b1b2f630d0270a0ff850a79ecbec49d7938addb57c3b86b5df4fe31fdad8cec8272b4190b4bc19b2d716fb784806b7992bf0652d733e21fc854b6a81e822472d26b0bb8a98527e01f17fb09139d200de0b08b509943df3010466a9602edb42f16274aa20ce746dddce56ea462e02752fecef8c5d10579931920e7c1f159b39168772e5bc12b82f66cecdad8b0ee8b9f51d37616a9eadf55b19de38b3d459ba8e03a74d8cabfe7421e4797ac20ec2110ffd05b69d2fe6ff9091da6f26c2b869e648b4b8b8193ff0556de77c5f987ee5c83314f0cbb500114bf07b6fa0b99c95b37440b4fcd821185281bb83a7ad02167c6d5c146bf2f07081f17c3c3bb212f6597c2a5d50c2feb9f49ea80b27dcc1d09fd3df485a70e25f9c58bed316ccf73e9d5bb9e53c2f5eb2e6010da6a5857c25fefcb7282d3340788812645bc1cb804a64485eba24f443fb78a6b403f002ac2a319109d674579c5d8874f08687456f3e6f4c01befe99d322b21296453ab1cd8b876e5d047a5da911eb05a3c5d7f89266c4e2a2764886f454acbac2837fe9f22a3d4a7b97d2ff484d6926730b957904ff89a9cc2cac363282704af98f1f0a52021906670cd721d70fc3627415deb391721777ec362aacecfe111a7e695da9d9e178614560b2243d98df3516cd5713928239a13e4040882a2a6df85b7d725442d8b27c914418b12924490ad0a6a406f481724e0aa31384a21920f67fabd9a52fcba01b3babba5745744f0f55d638ba7de1a335c36503cbd812c868ccd50d5ed96acb8ef2a3a18737a78b9ee87b3371461a24462ce902f72b35467d8fecb2829682d5154d4e5d380ae4772b08551d931801c4535f180d09f36fc02c5294d1e88ee1317e8252cfdba617bd1e0b7a872a23a0f4afc709a4f600e63d97f88cb230d8d0127029638de91c72b5f2f16361cd72dbcd64e93e8790cbd5a14cc374122432901259f53c284461a7d4cb8de258faaf48d95569f01d426762595b052845c5447e27d06246b09099d3ed6c930a1b71f5606f0064b01ebf4a99dfe94e757f075a81e2c2f2aa799c8ea4ba0370b76e923eb8e09369e44c760dbe5e6798571be51e56732d8892f25b71f847be5934b77e26cee224c3189237d1568007e6667f173c43f95bdbc94c6e682df070fd23dd0d8c242701bfa46a001f7ebe660668555ee62d198ac1c3ba1b1e7dd45ab29766ead9d66d810a93fef60e48c100668d6f6ed95f3c8a3a08c4900f973e0204b69dbd02818262e40340510ed38d6d65f5d307abc6502042d76018edc94649b680b97d12c476c52397f11584df5af6b65c817142d827fc3200806172ee96977a89553ed37ffc72368d3fbd2c399c3a0772533edb6ef31a55ec9930e55b7613a057b48da80a4cf3fd57745afe396ddee39819af9f10f741d25dbcab93593239f616e21a1987c32f990c617d82041a0231857d70724b40d38cdc5b71ca08ff3c5c1cb4d653ef002248c0c0776f0770fe5619d5109a7048fd2a69e0c17a5678b01076782c0e94c9e85f357a959cb0bb497ddcd14cad8f346c008e5c004a0c5f6c47c8814104afcfd93c90a25fda9173c8a691d613d42d26737fc0e031c2ca744fb24d1a0cd6ed8e5cfa09d47112bc3bb4f8ecf3142b889cbddae5148b2880339a67f180f83daebef9dafeb2aa9056279dc6e9dad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
