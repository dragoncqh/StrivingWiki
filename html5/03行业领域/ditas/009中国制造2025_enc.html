<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95623ab3a8dd302668c65880f35f58c868f1f2ce8ca7fe54bf68281520519a2094506f3d58147d1c1f4f81d3a9e87f918a5770d6abc087479fc40d71cae44fd98a2ac7272d65faea842dfa129e05670dc944566934471c6bdd7184c7215ef60d254b052b9e1ab343a2a44c00192cf2f2e7283d32ead7f5eebf9a0d418fe20fdd9009c8e52fcbb85ceab220a1122998093fbac8cbf6a6b7df937f274208f0c88d1e5e4bfd86d1ad9cf6936f0273126510628124abe17862a01fd41737ab781791f3a9cc4db0c25aa1d115e47ac8b1966039296d907480b9c2666a063061b10a39b7c87451e81c862a06674840ef89d9e48bd2c8c87efa45795fc1408197c19606d816706ca57c1478ea315a3b60351b13280c60c6ab0c65bbd6a718bf015e17a695870af008791b9ec0a9b73c990ed474f0789b0908d6bc875b59ac4e5729f0c9f61a704b2f7d2d9304c5f8654a6d59daf48d8819485177331625f66c153b54d50250450072a1387f235d4d7ac3a018d67c1f261f4934b37f4e71096c669a0739d3e4d50992574bbb2650a35277d857e9651343fbd44245201e8e570acc8314d929437148dde48761edb804299b808d202c91e69c16251b326ad2f5297317a07bf1f514af95772ff381e3b22ab0897332fecbc8e95ff6302541b893ed960e2591a9eeb5de992a8500478f3cccc9bc8ba1b51dac7a406c267327845cebfc10fd1d822d368b88360950cbdd2619e79403d5d00f03f227533fd436553f419f1c75a113a4ba84960dd22711d150367feb8ed1e14a19ac628c069b72910d849e6d22c0d103570b3259fe04fcbe60bccf146fc70b64a4e506ee3b56f6f0a603e64291591d2eb44dedebd7d06caad595a5dc45c7873a72187d4daf217f30acaf5726922772996389a752b2f8111e17d194ab12c27ffab5f9547adb037c343179d9a4dfc4915474110c77042f1d07b0092935de9b2ff880d28b4f748d3d65fae541a9f0ce8b4140d3ba9537963e5aa317ba4e3523f759948a6923c1daa5e1f9fdcf4e86e12b474d6b8f05d75fba7a8644e4f5decc1a07f6bdd6ab863932ffd415670f3fea0dccafd2269106ac4a237960f3ab475ccc102f8e62fa83d93123ab50e0b3cd7a69ca297e8cca45fb9ba54e974e37c9de383fb9ce6d5865225295ff44cd14c1ad4c36796cb6dcf2ad6a4cd9cdbb96fefb3b6a7310d6969e7ffc815fd3a77ec627177e0f43ecabc228537a349816c939de198190637741d06550eb397d56d0409ecc29f6a27f9b8ebf0a05fdd8c64c15eb08735844e648587c9d1611175209484846191f4a054528a821e21b1362a181da5e63e49b40373c24321c8ee8dd6e329cab0d1e7f43c88216c35f0678be6a5bbd474a35cc165e0c5c7d358f345b2cbca4b987784dc833bf49af4e8e8911dcb7286ef3ac7678e688cb63876d8bbacbae72b28f2ff2406a424d4a822a6e3989fdf866f6c54d6dc4afadc6ba856ab6f6b3350039eb455825cd87249eef091a265d6cba1b248e7d9450489874fda1ed290d876a6705c927891c95163c690a2561591dcd62be34611e4eb4ccda732300923fa510a0ad1e04476ce513e2ef88b7db77b33d948fa33930afcd2ac3ea5d504318d45c6d34219df233b523bce035308f2ad648c7e6a7d39e8cce7ef62523950b2cad6b5c25583010edcd956585b80cada270c6b1f4dc823d59ddddde5b1cb6efcd286f547805aa7f24b38dc3c5f548f36da9ae63f604080615b4c1ab09548235dd80570aaac8bec0f7aa7714f1dfaa31ecbb7f80b080de680a00a95e6c53a6d766d0df03ea2292fcda57158ff4a5387c8ea178e8ca9064fc99915f36d8f55abd63b0036ffd8af5277784f99f5d8c8e5081c74c35cbe92b01084e85da1ab572fff31b90c142dac7f7bbbd99ec24e5854ffca99f2a28c4b07204ccba392f6a05a3b4d1e59dd5707d992435cf5ee1aa1933e8c1452683b4ad8b93e54035dec626baa309280ef028da9483fcb49ef1309bb09f854595fc092860b1170b7b91ed68a837130df9a5138bcda89523e5ed843270cdcd5c75507ab65de5d8f679110966fde19273f451b1dd84c026a3e8ebbc85472e79f1b2e17ca8ee71a4d4205ac2c18adeda013abc1849f8d9bfdee88612ba236e006e45cf88f573dbab380924aee7155e8f46b7c0bf4999e8210004feb2f433b204516b5c504408f1c37b9e3e9fafd4846f109981faeb1a825c744b29831987081fe04480e87866e2dde0785b85734422546e3c58ec861ed9663ef34a42a18ba42354abd79d9a03e77755da66875978dabd72d3ac2cb99eeecdce9f71e99d59397ee3152bbdf07894cbd0641878d682f5d4943eb5c6c1558a6e277dd76882c191ef823944681d397b7bca0c113416c77c7ec9eea5c7fc31868b5d2a8eeb525e1ba92dc8f3d914d1311e22fa74a43cf0645372e4f4f18bf403fe12b0e8937f2335f4b4087104e80f81e67fbbb98ef4e7a909929479c373cbb8050fb312a170608728bfd01c3da2fff38cbb21fbc1c64ed8db5552b03885870a7f66ed7e20d40dd0f861f6272d54f695c1ea7a883d0d35f8cca36ed669d64d8c009283bbc5b3c742530e92fd8f9214bc7de89fe23162052dbbfeb20564bb4ab203508214fce0f54290c4a9d38053a6f76a10ea8ebb9b9512f6d971e51e60415296f67fb468de929d70f36b7bc051c35bc2c82801422f31e56b6889d4e02d022bf970768cc0d86129f9acca8d2fca9d3a3099700546d0dcd2739fcd17f49ab14cbb7b805f54b7f07967dd7ddab28da52849c4b6116baf25020ac1f61bdc1b5c271ef2605448251bdd0b58cf9bd808be5eca91f2cf6302e9e0fbf53781dfa0983188798de74d33b9b5e396b53fc34dc9ba59e59b4785f5105a6084d8758eb5be1f19305454e1432f65f0ab60a5d853284b838085c8993b0b3750c8f13a64566d6363a8bb9091dbbfe44c1500301e4843fd81b391b5c364273314bfa9c10862c1e52d572669d75b557b8f195446f503442e63331e3d3f92c86042068ec853d0b48d4ca815deacb1b5a7616c41831dd3326f3383a4c514a5d24d3cef9238cb2cc44a91bfb41942dccb563ce0fc0893f190677db0f52b529298ec78260ca271c165f65de9060bcd66c7c8cdff53c6425e88176ba9c00d8d642194a05ae89e813457b1afe42095e229a0ee0dfbb1385fa3f4364a1a20b130603e26684b565c4e64a840fa925f1fee3161fcf60004a27bb0d4c50c5790642e48abe716c99e98ea04da837912a9d4595b1fa5b92fe791e3c1e2442f837a8c859ea4516c3c2fabbdf399c9023d609553c448372f82bd2e5804d6e52525a26fbd9b07cdd3b5ef8f694475b95c355da2f68b600de5952ebde9602cb269e90c6719861a826d190b78375856179fae76842ef9095f2270cf8d623a2f40c6bb5ef79caf5136d27ba182f2f59e4e55724e006c7bc9aa1fc7ff35a2ebefb1866689129e50ecf1b47b10f20681ab165d494c34c95a51fd46d4ce346d9baaa4647d95f898110583b5761867d694c10df9c775b58c85a3f91f34f7e7f5eed05df739d38a465ef0b83fdfcf352f3231d23c6f47504ca0893307475b7db21105d0e7db0e40f008e0362594b99d2ff739e23c7b05bbb658dd92a9c83837dae436dd12ee12ac0e682a8d5e8a4d6ddc2941a3e28dbb935ac610eac290654f1646e80991689d1c9c417f486a97b1e6922cf8ed7e8cb7cb14830aed9606034dff761e7a5d3740fd69a23b671165f0f6b4bcb8379a2c558515c02026279e25b99c7bbbe280b882e64ff44d79190851ef33022ce42af482a853c5726c4eb029536294ef7df25e6205469906f5df5f79fd7854f02393b8b9ae90e2f7247ea1ddd1140cc5a4a8be2ae01919c303183640677f9fb58e8d43ca4e3c5086cf674df74324af3b427424bf320d834f0229143882f6da55436c1c3ad934e0b433896be9832f467c76d7c876c2d4bbbf562c55f3fc66f3020d8db1cd631fc6ef87b067f60e4dd5731d4a88cc04a4a5f09c9d203c9d071c9582c5cb0333636acfa039405f99c32f6592ac49b483b85019a3701b58b78677a3156e40d1d0c1be02e1fd7c17d6b5481936958058759cfd35bfca77f718cb03d0275538ece561db5d479c25ed9eda0dc16fc5a70b40e748c207687eb2c99e4bb1e146f073e1afec18fde4adabc07fd08ff3959d5bb8089b2ff27e1a06c94c09b28d352b0747cc785af4459ee7ec9f484b68dbd911f183df577bd041e23675642c4e0709cd7b78ff33f149f39f1f2777bff49bde816a47e7b9c88345c2d21a84b6b2db763f5886097ceffb09b19681c5914691bc336b9f1e6c69f8765a8f70b462a17835e4997500e3d2f4bded15457d90fa74303f6ab144e27f7b07ad7f8dfcdbc7b7d338e1182015d2cc4d20a8fda502506e0d590ee9ea5a6df9385a694c6090a0b4284d96b71ce22aa5093af9e36b52c9d21c17e5595963bb127e492fd8c60645930ffb446b05457555fa340a96745c6d126e3e8f00a05a1b9fba9912c711cbd7d8e28ac1de7c3c1d7b2a78307bfd31dfb129cd117233af1f84114c0d60f1627f83109f4ce495033f47ed49cc424405a9a906628d85a2c4c85f5e2d95b8ee53dcf6259ba5654ce6e6afdeb96f540e200c3a82529a2bec11fdd220fdce55ffd591cc9dcd97b6ee99ebbafa7b7453af3f682ef03304ebc94ab78f215cd9aa26d90b4eaf9131204b196011370bdbe7f8b9d3ec3886c3eaa51e59626c044b6ce64d5fb4a404b859996f054537d00df72303b32ef6e1f526c7fe56686ec0e8ee0bd6587fbc6d90cdb974a1d9ab2664548937d3d7e7b6e789160b7a7f072dea19a3ee07dd025ee31cc98572a662e5cb85c7450d384cc5692d9d423d513e41810eb486152f83331e3cbe3def1e805e1079dc392ddbdff3493ef63295d59ac55e81612c9c4f4c4523e995447a6a952b05b163dae2320acb3ad8c40bf318c1af61f7d709d83d55f14fa799ebb778c0ad9bfc4207a47dc1f47009cdba1972b5224ab35058e5429fa85a0dc046ce0ff3d504be0e9c66914b99d2fa2ffefa0d21d29f0b1468237e2bd622e9c739b472723917664f67a8377d6ad58dee71080baf16e447714b7d3a6f9d9a2ff95ebf50a3adf91ea14fe34b296e992d900c567ddb40b36ee9f76895d516e151e4bb45e5e94cb6676e5655002f89b4d826d2339c42c7cd987ad975682f33c7c556ce608dd6f37836dc8a2767856a8a3da428ec81e13e17ac35244cdb194ee7adf54498d9765b8bf2cec60600b0ebc759fd2baaffab0d6e62afd56251ba5e902b0a78fe68dedb2118e5b17a5cae96a2b5cd32f623758f73d250482a3edd5b7fdff9983be9c36e33269ae19667a58f2778b6ae566662145bb05c9b0cc342a6dcd57eda0eefc6e588555c86fb86a125f795efcfe3c0c2d69b696918615d51586771564addd15d6cb966e810e5757156d462f7ed1c804d14d6f61444236e4fd7ea73d147487420cc6779ecea758d51560b5fe47c1e61e157e02907e19a97b06cdc7b04dfe952249fab6edf74a184e361ed7a94402ecb09cb9d0f4e15aa36b93012b3b5159dbd8b322eb5050228b6e59197ec1c7cfef4b28e3b01f1506176d72fd4fe3872f5dfe0591f5f497a0cd5b36f2ffd8cebc9aa29862187ea5f0f76fce12ad1d2a79e355d88ca9b491b29d914cd08f0dd7536f6ce7eee50792d6b3e73d39ac973c02eaa7be0602c62166912b5651cbeecf121eb77b1395bc5d8a1a862877653c5a193c333b0885bfc59662f8eeba0e9e92cad3b81509f7dfa142131f53f81c1f704f8408cbc84b597adb89413e4a5dd37b3fd60c385448ed65a0a0bf9ade9dd9eb65fb084e2db054e9f49813e521de18c9a7da9a1064dbc530fe082539f4f473b71e1a252a7f71e738f7c1dd35d25a6fdbd78e86b2f351cb8d267d4487eabc83613b94e5d02b18d0fe03cdff737b429d553dc77fc65d6772c8d5912b296381749c35dec8ab8f6863dbd24a43af517df7f6cc2245f0ebb7787db51d2cb931554535fe093b88befbb16386cc19550ae50766b127a7a369db1bc5462f02ff89dd8e2ba648420eb21eff735a7ba25f23018d9e7bb2e62bf64a8857535769515118df01ee3f1e0921187ff34c1d3d15f8548418ebdbf496ca6eaea9058e9b434fad3d8d4960e3b295b018dbb973edaa20221fa6ca9b0ff280d4873a7ff5bac9f2a0cc90c9b881aef0a86398e3474f3f2287fc0729880b7ad0f02df0d922066635e6855c982e7d5b0f303ee6a3fe8ec8abb23a7e2c62fbe91a90828900f108aca7cd95398ac89a5e2c66e3aad516b570753b80b5fd21e613219b5fe5d1e6071b63b8f1822e77d5e37d04668c0d8e54e88a42deb79d61785bfad5847708e57a0d8e75acb66aa1c6daf6c701e66f8f83afb8e1b2622f9777b35d40c2d3d289480bfe8bd561392c400b6aaec27172c8c74a39c3639f56dca2f5505748e275f49a94e821af87b5bb09eebfcb56c25e6c1fcdda3dbd9299bba200f3895a7544f8dc4c1f6ecc0a7afe29d7093766284dd3995fedeb5e1879b4b9f972ace59fea0454ceaf63fdb24118d1ccd6076dac3d7a80c93fda8c280a47253cfec6d4d8b684d7332b9f1441c98bba153ecfd401b8dcf8d064e78311a1a3b605173395c889cbf8bf5410f2f793328f3b7210cd4d43589cb299052e8da38fc6d49557e29a863429b0b9d0537b707b19f093e78c991bb78277209979a1d8d12645b3cf0cb163671e58f78544c9ccc4aa1b92b4f27d8e81b07e26313b3b12760a9a5a5e8b236f2e8c93936e5eb8523e1d5913f0be52b22e91f81405929e4980a39a7e110bace9cd49b224c78d3353ce78e6c9125ea29dff6222d5dd361c7448366c6062beefa746585e9a59d8a841a78d6fdcb24edef26740e3581606c3ca3781c5e13db49e87facec4086f2c76c7c4a6b0dd272863a725d82854ff3adad4131d1ba18e76fb9602c6c622e0ed76c016c9eed06cb588890a6935cc3ac46aea1042f2e51028a49b673cecc1f80ecc3f47fc3d2b66088ee1c692d8097243ea6c5e5f17c0007365b2fee8dd504c86edf777730e8a977d2871273b15c702aeb6e37f708b37a33cb8e497c2185b315c7b69f99265ef80822550dd6bf47cc8f2ce758d6002a3ddf32381e145ce6d62cb0d1c221e89e6d5d5d9f195a961c603ff048370dfc8035292d0bafa687f9f1d936f74c5b8fda77ad7b83259c07f517c5f9126fd375c5ec74b870fcd292c5efb549fd5f5ec038710689676872c599491c48daa94bf0b804487d05f1160fc4e9ffba4effd6fd7b235a8543e942d20759806fcf8497827b0d67412ce0b781eeb211046ccfab06fcf90fe8bbc9a79cffb0e551f15c0f02801c87c7b5b34d65942d0db8b794d30effc4570c8a46af7a0f350d4f50b535f63c45436a2fcf9eeb925d140ab5f794a064fd1a3f3828473ba19531a45e22fcfc537ad29e7ee458d5a77d314e7a1787b5d7923d2bf95fd21616d60249fe5434221580e50c96a6c7a7ae9ab139f468fddebdb047cabbc54c49863144ad8098eeb928a4cec22f114673538ebdf0b5edcf62987005511ed0a5ed56a6353b3266c696b176e46e05755820276e8f463b24ba7f6adb1a78536562e854feff7344dac55014cac69861b727e0ef6f47943a4c999823d4cce5b47a263db9a4650f0d643ad63da21c2b49fe2bddc545c742d09eb855f04b0c0b7ce021cabacf290d1b3c359d80c00c3a78e54b07aa9777e39c4a7dfb84e0a33cfbf6e28460ff89be6b6bcd1c79b230d5b3aab29fb8cac053daf93b528df32e5bacdcd25bacdb512bf72de34908a0c51ede35d38b5debe646686e019f9cbea65dbe8a7ae41be21b725be042946eb0d02663426aae5438e71ec22caebf10a0f972a011456ce033b6b29776c7f61268c03cfe17bd91a412b0ac59975ce4eae779b0240b3651248bd29c8707d99ea3eaf5898f8f25a8c6bd534737dcc5cc3283e63690578a75ea87cd8681eb93cf2bdf53b2db2642570b454197040e0ab3e29f86fb6a569fda16b5399bfa93d8cbe18909bc6d756465dfe8d4575d9b3df0530957252ac824b06af12ff5e738f7a76fe513dda8a2c548fa944d185f6b1dd766c4002018ccddd4bb48aee73d5d6bccffe889e1222543e9c15c69f8416b1aef6b0adfdaad626b0a5aa281f7d027f2bf18ca6d1a75c4e34a323b85a1f13fa285273c9c61cc4b49dada273c5a93c9d2061ef98051fb4f0e077b463231471a05c910aac8155c0b61f25e3f4675655a568c138fa6fe6c55e5b6325e7fe6797a01adf2846337507714cf0543216f6697b57c55fa23bc5b981bc580d7f65c515e2ce0e81794954ec80c01934d3435c31b51dcaaec72c86c1a17be4bf300ff587d9ba14082042b1047ac235f314c8e7d65758bc79a1930087a1ad0bf1e1e5dc692109b9dcb556cacb8b3a64c541cdaefc83fde76f8161905c30961334717968a2883cb46eadc8315b2f8040705ae715d0403cabb9f5576c22a72d7ea6725a75a43b50dfe4dcbc7e95dc6ecd05961f91d538c742657f130e7b5b28db8a0863265525537f9cb0b8918cc0902ec710e4655f2fad97b6ce1a71174b9a31abb3f40502f515e2e583e8b58793455096ee31fbb2f1e5b9d7626421dd2187809bc2b35222873cc3ed3424e2d7bf6e6c9d909f6635031dab8ce71bf5210a52fb4642b40a9adf9e31236e806423f666e8be1576657d24684565f10db892a8bba6dff9f2e7f7163fd1ca02ddf7cbb26e289e0503f034533dc8df899b9a99eaeedd10ed995ad2c7f8ef9f8f3749037a4479360e139c452903af7f8331d9dd1bda923ae30efddc6d94f96ab5838f46f8e1e6296162e39f257c675c3d452508269b951ec18c62609452fea86b38b0ef4e2d27a48c205b5a1c6ad5319e288b513511c454bf873e502aa6b6749776ec58d1a42816e010cf63b44b5015e30d926488432afcb80cca14e08295325542411c19564422aa86ae28c1943bd603d0f7dc58672e6502388153dfbb8d6e0d5fcbdd224a1724abae3bb3d53dc9f7c6ac3d89faf47985e855e292a38f3591e6c8290feabe5ec67e71729c8b18e0370affde4d81c9cda2808fc89f7726f549e9a6a701523a0b58bdab6aeb554904028d6391e8800d66a505f6ffbd545a9909533ec8a3f90398cff2c1bfd9d92c3b67d61475b8f51e9e5b5145bb49306c262a4088e7935de52c444203981c42e79ebefea414e95d58a7b7e08053bcacf81af8b712cd772b0c6bf97a59b55d4de0af10e06ba411f51981351bcd1ec500f815f56d1e62a763a5e53fc6ec1802f28000320d025ff43f1c28f7476e6ceb68dc7c208b85d0896cca33248e6ec906eb28d02bfe6c4d496b558814fb89eb3ab5f1e98d367e17d73ff9861c0d1220f4630ce5fa8a78930ed885520cd5f83132c8ba80e9f850089339e79c12ef21c83c5ca419f2489ba172a82c2fe1b2b9d0d706c4e126a2ef38367766f0a6a8ac4e7b616a6ca6033b0f8f6039833354837f4616c04373364a872539d2aa4ad12ab0227543420f07e6c776fd9a881622dc23353434ee4e1906288473e9ea43c35de8a4be4b7d648817aa6f9f0bec69d4ca74fcb7d74e0f2e9e80197e1c1e174cf41e2cd0b9ed4666c8b234c13d8563a50409a63e5307fd1824bda0a79721c49d3edd51f317b5200c12acabd2bad7e289cc8576643ca375df6f8f67c74d38cea180e1b309a17d11f360ca05a2bdadd2036314f462b5300b5170f07d51efcb0107303112c3c71dde8f65843f8928b3469bac150019ab0a3dbbb600862e9eb207dda069e75159849e0beda096295058b0c6e9457c869f744a421a1db9d258fd4607343cb07d567e138e21cc03a770669bb31bcc10801f66902f9807a8eaf2a238863c8367bf4c18cf7dbdf390a959d94b3a3a2bcb26594c886d8a714f2dc94411385cf02a7512ead965329018690a76d88696904a8110fb8c1bcd3969efce574505d3a4f3b69ee92f63ab366c59194b5a020d4ca00a469da3dd66f06a8d64ea4d3ac76fd0068b463803c19f0ef930d9935ceb19d801317db5b4dec54ab75ecd95b9e41afbbcd9924fffcfd9897d03c3b49eb37a57dffbcbc6745792b66a8b0873c3b4da7e8c42e565997c11b0e49e1bdb6df6a369d109fe25b96dbe21d51cd067ff9d69402703776fc395ef411de1d387eb16fef4a00719a7bf97df7325d632cbf33403c0e9ad239f4cf02819401deb3cbc643a42e69ee4c023de2b83b2fe907ca95d7ceca4e652fe5b4e9df816b45f09ff971fda9cfec6265017871b242e7c6ce19d80a962048f48c4b8fbfaf7e391fd1e6dfd6b4cc431fb40a818300a1439d34a0fd22ad6bd9336969bf464ac1a9673849d76121780e766e68eeb7f20102d745bd3301b326f4330af5218e2d191cf5d9e8c58e53caf512bc3da825b4c88324e68f9171c9f4d5fd368e6c2bd6abe2de66a6dc4b1a278a096f18f7f433f06350aef641d23cd85d18768a555827c1427728189b898cfba347f5861d5f955cfcf1c6e31c73a3ce849e6d922b74fe5b0d398253c89a207bfafa7e92e659ea6b21588b9561eb7d1457f747ff8212a8eb9e0740eab1bd34aa57d2a70e64ac74ed507a520b498e95c37f48f37a4fc7c47d5f8f38d5afa45ffc09ba8e717d2f4f16d179bfff538ca7288943c33f4dec9cf94243567192b00f82f1c09bb552043eb1af0f6bd0877a0a0cb26e9ac3a060a82c952d908be3e1778b4f8a7aa06a41f09e2353d350806027f44d82d543c95d1c6596109c931fd7958aee486589175c15fbc9211f783e103e12b459329a610516002a18baa10ae3b719beb8da994f4c7d1831861963ee478dca6f4501d047ee5317e7092ceec142500ee3ef6038a1dc02815762f1a2c36ff0db3990cefc9e8af5ecb880ffc8f72c907ea390198df5c29913cc3ca3fdecef6c8adf6da9a71370220d67bf2176a5db735bcd620db9c7f6b7f60541d78f02f0b43383355d0f4e9054fd046bf1bfefe4f5795eb38a49a8878b2b7793b488dce14ffbe5e7e2f3b7f01477f6a9eb2ec221b79ed1ef09a8ff1914a1d64fda0a0543841f4af7a4fce1fbd386511b122e2c0c869df97d46d24af0c666d010021f8c4b98b18f85fb10ed53d3bdf38bfff2d0f0bd8f608d4379b9f270584edf259d4e3a114e9fd6b425629c4445b3f7d3f29524c755125396ff2a5c541c4617c1f285fd1ea5df9d41ef94e589f839e2bc7008247c6c6650618502db12e831e36ec780e88c48ab06c8a19c31c1febe78fef6e44f4bbcb63b1a33da932418cc806d302f7b40a77ba8e1e34d1e6f73654a127153675ecfa64ff1092dead30e1938acd8056cf96d794cf03bae4cb70f29553b68fe98a12d0da01506c20badc8153776fc32b6aaa09ee43e2ea42a2849ebec87029cbe66f0d7fbcc20396e29f7d0164ef747aaa528c8cabe9f1d863ce607ec0adb81f4a45d0fabd80dafd690f206c8c786cb7589b2ee2d1676f1d0936ebf117c7381d323230cb1f2ada1155251889b75624f2b3df53c2df8dafacc5b0c3b0d375d77def4ef48fb8f4f1776831acd10c447d429f1379236a8ec109388b74b651c8b4a8c7c9416c8868f6b85dd6fa9d42cf5dfafeb76d83de318c4f82b7277f6665592127d56f01d04afc0b11e5af0c84c6b829db6e53d1100d4440935c965a13aaa111e2f056315e4ad8e3943304d3cf788066a2e042caa05772b144e60574cb85dab7836b6123c8a220ce9b7323076374e262b3e51c257424524698adb79a5c21e0c4315a265895bcd7a708476b4bf8e5c04602fc4b44053ed78d851f7a1655c1e0ea862e0d526fff50660b967cc2377893924282723ca7670013cd4359338396238c3b59a282fa7c76ba5f832c3770171740569b49581eb9658853d71e0f547d09395fe8a35c8e27d02dd37bb00bee4003ff7cad9b632af8bbf679b268e62b70c3bef2785a7a2392dc5b61b0e2eb493fbb103edd68623a39065b8e8d0f440c213eb0f3600f8affce3f4472433a909f76e17f753777aad4da584d10e40cd2a172c22d6078817f6fc7a882ef53da87bffb0cc66b26a075a05d87c7da0a92c5ddf05366cc88f12da92ba2af1a058e9347340a1a4e6c454b1664b089972ee6b5c9eb803ef0061d1c3aef2e262a1a59b5a98bfe0dd1b14259efa626796e81da169a8a1249372489a16fdd009894ec09426b39e76ea5083eb585e09439b1f9c18259c4a160ea3950e6128d624181464800d918cbd991eb37a86c67980d233c8991dd2a1b679377e2b6be4f7a60694bc62edb838a4b81e43d44814994bc3363f38da12048f21cfc68adbd1adeac8ebe49ec426c07f5824c9bb6d17244be99dce90971d705ea4be2f2d218d25c548d6acf41dbf6db641f1dad54db7d90e5f4dd4d00dec9946c15f001ee6b16b5ac3c181f725bfd49e19c371a28ce2d93379af4da341e5427ea4ce1e6ce42705ac3cc09e201b07ddb34a937f42423a0766e23804ed79b295d7208829dcfb1e661e7dc03b5658c361cce0108175d307eb1b4634d3bbb4835556c248cdde02449bac4fa7fd976eacd4f00adc1c7c4bed4e2ffe5daa3d00e2bc8dbfbd80bc281a4b841fba11ef5cc461786f65b44890753b9c13c1331f97e4b2b3aa9bace2ffa3fdda786d385050b0280aa4a7996259184d14eb59dc80e41b77f66313a4e6be05821baf16515a3f035a1b0e407f960e7aecea9dd54062f4e36505ace4540f99f05a4e35aa2b1d79b180fe102106f572750d4d97b2a85a3bde8773cf16433b93c112c38a7e906d20e8a748bf321f44f9460f29b20b53c2f344f5254f3f39f92bb2d0329ab30870eeced1fa427548392cd70e524c7045ab01b43109ced702bfafcf97d41ca9c9f12018b8c1c3d6e3f06e00495c2effee7fac1ceee8dcdd21d7c0c3e0c2522abeb0b65947e05313354bd512d1ef521d980f8f35cfd84b6c29d3f4fa0cdade1292f4b336db6c174a1280e6466f7655bfefa05fa7bdec74d3cba09c1b9a3492b7f14b74bb9f67ac06fad37d35e380276edd470be834e6d38b4716d248e47da17093f5aac3b7d64b2362f0f5ce1d96e1cbf15535ebdb8ad45ee53833e9fe45b780992831ea8a8e07b61f7ac3efb8472b091e1e97740f9771ef1fe3b581f02c2479b341fd33e0079267154561536411d95880e656ba7144f581b3fea5657e8d00d8899cfaacd635651082006cc7911b63dda529f866da6ae026b6af1d7a5b7a9097dc54269c6eab9b49248d10f1337687d62a77d2dac58bdb0c4b3b710d10503c7f711241bd722b578c9c04c4b02fc2877a6eaf7ddebd72a98182c9db86d565f0a229db36e017d2f180322028619dd252cd5338bf8b0496698a81cad7db630a58a412b2e79c9afaedc795d86dd63c75543e567ed331b7af51886aa078b72361c457ad6e4b5b5c65aafb47b9f6779d5b4c25e300fd5e280ec184815326a172356ee3399ea094650bab161c444a41c115fd2e3af4af15bc4e622735581ede47844f1f5987d4489d322fe53c01aef00bfd72af0c1cd83adb3b0f50b2d54468cf7723c67233619acdc1241fc66343a37dd08d48c33ef307a201b4c75fb06808589790767e0193d00971b0a69a1cfb2198538ff8f1e1add76f3066de173538c1266f0c83f14c4e360658e9c499d65c76c7da5c9687afcf05703177f12e931df60c514be51c7a2228d3a9826892e32a74c12db484a561d08eae75aa23ee65772391fe428b1c029b40be19f44050d58a773ed7d8291c30d468791d1d15b33f95ef09df68f47fa0a2a3882fbeb0f76b827471a67d61991890fd8d84bfc3a2b375ff5aa5608276166fc4275c1ec57aaf8376971d7ec7b6faf33f6790199cd9045952af8eb2d56d3ea0308f651dda04930c7e597c3d172291e7eddfab7086be18c86a72852f5ce97661d46e57c5aed7acc6108245934631b2842bd39815b8f7cee57b3a49158004f5c9556f3518ad4e9182beb6091448deda45fb831538bf3b75da2ba690f1dce23ec4532f7e1893345fe919d132ee52ef1e0ae5e7cceb5f579c4172044464fa6b264552cf29be16bc939f0ef3e82bf129aa2d549d0d61a43c954f77a4788d95767c7e3fba9bf4491ea8e8c1b9b2d6290eed15642af5f40a12ba3f6e7a10397ed48ae22340858d6938293f681d01494b4177dc91857b08a05e4934d9c5d601b8039c08afab19c0eeb89a6fabfa65701606f4dfaf1c647c98d6e8a80a96737140d4f47c1085b229c13944550191842fba8d6d2d2b64254417bbe04461a0bc2d950a29071503b76fb4a92701339ce40c59c331d57d7bd2e3729f6cf59d70a591b2dc008fd8ec07f1e93217d1b59479a6bdd4bb5af905fe04e4dd4115ea986fb597a7912086c433e6d03fdca612fa0449082649bb9d5a12bc0dba434343222b456a58a049ff76d5d1471417307ec3c637b6b0014a49b2f62d37831d5fa291aeb91a56fbf105b9b3f1296d6e4d7b47baeecaeedc6c61a5c7b48e294ddaa81dd41cbe860c546d6554864062bd68cd7fe8c4a44879b51799fd8a6a24223638d9b3c5fface7e643e8273c52a405bbb98d0ee98fe3d20725040dfbd55d4a6508bc40bbf6b58a04c81090ddfd7e8f3dbdd0dd88d542d9e353eccfc4dda7afced77b1f93046f4773eb1d319b987566dd8d6e458799e4a3d4815ad489d259218e0cca098b63d13a6f05990e8137c1266bf3b62797c0bedc8d4b8cb3a93082f1a8d6a0bf7f93f47e33f57248048e1e1bcf4cb007f0539b06eac27c1b2fced8fab4bb7072b4708c09b8ab4812120021627a41ed67f1844bbbbfdc899ca2bddb1c4d140b91a5205e8559896aae04a109d9521149be3ba759e3a2cac43a85cedc8f144a3d727ce2dc7c8896cf8bbb5f35355f3de2e83117d0b941686ebdc1c9b398e802c6c31f7b605b7113c90bd886b19245b5cc4a021a32a6929d8e1c9be42214ee3bf0be70c376d048519484fc21d3daf393e747d1006237951646deacc393e739ea7dc1481662f732a1691e523cda4cf5e230caf1a16a5d0c257a6a221294eeb119383d36d41181d80a5fc5610ede31e8f7fac67bc7f745c88a38df77f25ac902a631ce9a39f140c9b97442c14d16be736ffb1cf15ab8544ed261f3feabf20ed6b8dadbe8e22c7b039fb0374f3c4070804167bbc1abcb1e0bbb82cc5711fa41ec6bb3d28df4cee2d2e4daf0447bc57700f1605caa200e2e2ae894746a2ff7478912dc8c336baf101ad8fe42306632e16ba617b74e4f86d78391b3889da89507eca7ea49d5d8a55bfc6449f12ec03b4d3f1419e25af5d58b0cfed447b4eac3a2b5ae2cb53588f2a6f8d1969b5c967c734707c2a100f473c6fef0853e84678892726bb9bb8115992e9486f58fb696c5bfea80b963af28510d94754c2be0dae2430a0df39ed4efabc6d71b565c7c1257aa2793c9e419af330860eafb727d5a7319598a28e1c7f857e6cd1012091612e8debbdf234031303a5d61f83a6f29a319af47921ecd2dbae7ffebeeadab75e9420a5629f32a6072e952c5998dee4a3ef7675eb52f331af8677a6420a384d70fd35995b8f4915d6cfdc43ec136fc9a379f91745d3c70db2e5f822c9b9c6216755c0d1fd891a2d6d94f4736ed709007e11a3db428313bf6b07aa10c7276795c9c40ef13dd2494cb0fc4169799884ecbaaaba04294909b903fe95fa535591da079e26165a6d685fa912b4183f131e771c57589ad371bfc7309f37b53f68f1e12ef9a8ee1519a931975fc01aece74799e6263edda68e624abbff35e40b3251b84764d8514713f19000f9c972d425a4dba1870ec383d292b39d73a920cd8d111f27a14c33cd81483b8a69bcced35ddd7aa113c5d2c4ddefd984e7c32235350d549e829dccb799ab53e330ac0ba299a349e5a897d0edb33cbe055ab33354d1f2044979f2539a7c5d0e9b4a3a344d7c9cf1a301646caf4df2c7cd76003b6052108f9cdb1013ebc04a6ca8a84602b4b4834bbd211373d38e3671d8b5a6a94c72c5a1fae1872d4cc0c7056791acc29c0b278ce524aac58b4232f4f3dcf7c9308988bd8f9a9fdfe0062439a3eda6418ce6d4ab70b5a3cad5fdb60b59f2b487dab362b8ea2c60c54931250a7226ecaef0e345437d9b5dd822bbdc09e6bce3a5d5ee65f859be12672abf4735bbd73d23e0b5e51f7cf2b020b637697f513719ad45e09ba7f48d39a02dc85b8362e0ce8e6c9e9a17795428521536e486fd8ecd3c72e1a33d39da6f63f68ad05ec7527646713da2a5ffce81de318c5d2e3b4e1f7ded38b45d5e4443815324c954e9992dec9a47c6dd577240614ce4d79ae537e9ffe388cfaf166b7ce9a06837b8be6ae933a911fcc6d64c2f3136f947a4dc274f31ace8cc272e8ac71366cdc52cbb0871d19b6e0e58fdeb8cee009d64b4cc43e3678f2b2d45a3731a3643d19fecd52ebd5ad43f854db6010eceb9059c6cbfa4df690053ca08d10b50de64d825454f40995269266b43370db7c4e0aed3d4d687253858fc6a995ee12cfd54bca62edbd35114d1efa22a3b932208e22979fc56dffde48074cfa744875cb615b746735c8865d0090b08ba0c6251ec7615533697bf293f525f13c85393203c837fb3f7c02ce80fa9dca99caa02ee5134612adda6ecd8e244a200653f763c7baa92b31446ac9da20b1493a315b1cac07e581e7e121a66e02280746500ea21740d5ffa40636c0e2ed29fb79958062e642b8e1f9787dcd96740388e29457c958c44f4e4f3645845539326e78d993eddb30e2871c5397edeb5c047baa03e6623e4f085a2b6b8c29806fd2c703083b3b4bfe4484fbbc4702ca49ebcac7950d25a181e90457bf9b829c4694a7cc13b6145a1d878474282f22a81907c99e99eb768c82bdd5452607df112ef196ebfc6adfef8d598fb9728d7e7386603929809e982310950ca7a617866fbe32ea9cdac0796983d94778e28d178e79861032a7231e9716c43876c2afccf9a0eb1b8b0103b7d9b05822962410e0e93f5bfe7d7efdfcb039e1c2be50b38bd54c0d4f9e74fd9a3fe1aa14e56353859503ae9c59b0fe741538f744f9c5d5e048bdf89850e8eac1577962aba0f5430f7f61a70640dba1308caf3e517bd1069238983fb7d00515e8dfbc3a9540578897a9e18ed6c427a4871403f693ec8293fd4e76193f097c4639b4c3d809966d11f7ce173cf6d75cb90067ff90f51dab0eb6ed20c0c335e45170829335e17244b57e4f0a7c5fbdcf146017218c87746241029ddc628e6c138909b02cdeefd7f5271e7a755d6775a35c018617b12240a84e5a6416d8b2c8d33c3bbb621a4e857747ca944c9672f2a190d477bcc943ec78a3559be9dcbce5f27544e1ed4ba78669f3fd922854b2cd0014fe3759d72197ca94ecd81ed8c0aa543e1b95af3a0f844480a232ba43d51cf6ecb5708f36b989a49b5fa5c6101e84205f3ee206127215756e3c016abc042c06e0fbf00e64179941f84175191fc8204ab27a18e5cd298543d36f9105d658e8e1a72d96abc90fc040acee8fa6c9091d6e4502270544cb53035acf35ceeeda99ab63a64c7102f773176d7130dc9687eb211c12fe378f4d1148622d5aebc9adcc70576b0ccf4f265498816d8820e7b8964d773c10f487da8d2a3719ce16253cd0801ddc0683d3d28bfaf135c4b9a2767ef896876b4110805e0f3609a792910ef6374daf740181c47d3ef8070a4dd36b67dd635d5f5b8a6eeb4df9075fc5ac23d657e516da41eeef61cee92304f49cc8b3fd509f78b567b9d62e15823bdfafb1268a553ba20ba15d9a91a2da9d18cdbaffa5a12776834c473752b5bdc0563e9d7c7e8976aa0a66591898666d7908918938b84a76943f49d0e153f8f3ace1cadac072769d979f9342d401d7169ecd78f3929ba08c062f7aa95ae86fdcbd19dccc0d5a1016eed056e84bf9f85d641a65c768aee5597ae0703bc0411546ea41d5d50c959cb7c737a70d2db9285a328f718be9a9530f5f8c9dc1e4d4d3a3e4e91f87a5f30f858bf3c62fdc75d00491e718b19c61a072d4065423763c4aa777689032ad287438d27fdf7a98b7fb10b2a87fe734a17d172ebb194bdc15f4f7cf7edfa0cc83b33d541bfdcc2be0d33d6eef6175820a21af6df2f8db4c1f2f0ae8b95439fd400ff9d3d828047377f7b8f3387b9cb28708cffbb2df88b3720c59370cec343451b0df1301648283a39d77ea3270b2f5d4cf6d0c45cd6d8987745b3ad12753cfedcb0831636bafaa488070e49f9044dbde7dcebc8931445f81351829b0a8151e6f5fd6f31ecf8bb8a46784be8817b00e48f440311d3618fb8d432e6d28446e53f21b8afe49a389b3ce31cbcc2e5ce3bee3a71c694e07f9147fdc3a289530787552f93ddae04798b67b988e3b32f53f9f1f5dbde447332c3e8877756c037889d383bfdd61c11cbf40bba762e16b482d8de4850e7455ebd00136816ae3773e7585b6d0e9787f0cb3ec300c234d15e3053c5b4da91d2658786c08eafc83557b8ce94e080b26564dbedd30dc25f2c638cafa71eff40969eda4bc3c955548d5d2d93fac6db85d9cd204571d71766403142b5a004b9cfab8cfa31e342a38fdceda9d5a7884118e913cd0761c75a9c1aefda5bc5b7958d2688856c8fc3d9dfa9c64bb2074ef77565a6c0cdc0e12802365a03e6ced7a908390c62b104e17934f2112da3a1fcdc80afa8d70d7e24bab23da91b61a0b14053f8291af62c15dbb78aea200b81bf9cfe803fd9a465395b3cc1f048d60957f1a3ffc9bc969b7d5883d8f1b05fda3079bcc0afd3d51335ccccdba808d28ad67994fd9633332fdbd899bce8de4fde7a869c0a59b56ea9fe6d98831c232681a1a232deed336898929581b3526a58f64b8dba4fd357a206d6eb1500fbae777533da1ae516c64553e4bfe28ede13d77544027625ddcb42e59370da821f6034f76a1b7b1715a184279370d973d3b9f24a9954850f3ab5689f133581f50b20683a026dd86d0d140972063a2ab80bd8ef55a4d6f56f9e002d775b0ec1c74dc056602ae736ee1d2fe35cd6a51357e1abd5c5f8d7b4b2c3a8e8bb04802b1ff826530470c0782f58119662a05d60897ad29f6f6304645e141186b0029ea163f2e36c8a9125b224fa13e76722ad8f92e8f1637bdbaeed8b26ff04fed1c7199ae61d1a595498a853ed05f6f0d6bb84001f51f493c8b3b9a24d2d137c37e7f0a44e7db2869b69f5f77d812c9e279839441258af1540efec33c34287742fd4d0b19c9dc69003eb9070050bcdb87eec612616a2eb757080380d7f7516eb96038089507c96162c3a80450b345b81deb1aba70c64be3db10fa3c1f1475479f3429fb204a897f955eedf3fb00a48e14526a47c12967bc2ac6ed018a376bce941a38fc3144e8c95cea6b180bd226e0f018f4f76eb765b3a7af962373462d0a7a9d2d8d5d0eac457eb7f8426c35320c21bdeef3cf57500aa02720530cef85c86b5c2776e12d452878c84bd75eecb87d4d248f007c8955df01ade4ae7801a7f5a29a5072e18113c101b83a81be708afdc512016b4ed1fc4010b6579e76be9ffbf6a9e930312c6f5c28e11f9d3adc1eedd15b20f39b7a07459471f4ca331cc2f8cd68b3d32e17b8c59be94a9d10cf2e5af4f4305a926169bc2de0a1eef59c4bf88653e262ac6c9555208b4f6766a289f39d0f0fc5570f90f6ffa5d42421b38caa97550c05141ddc7d4e56a018b7eddb1bb203ed5bc4a03f7090b3b00606724410394af70047bfadaa8f53c48a67199fb4db8a36e546450bb71186a3f3af71669e2a524cc95ded86e10556fea8baa26eeb3a3f0492aebbb1263de1f0eef9ee727bbc44140f1f3736f7306f463668449d8a571593e9a606f17f00c8afa0e8302b47e137c360b4087152cb114f623fda2a709067f0d28370c21be6df995e040d229f65e5a06c7cf916d05813f66fb33e80a7ab650169141b1876ff320b12d0947d72ed80220b767a3148ab8a398ad2b3387dd8ac34d33115efc4b215d08e0e714a706dab5bdc53491f42d181bb7cfc6527eb160191a96d3417200d3f27f136092cbeae5928900dc4cf58b91119c5163890a41a8f54e43258d8a698953fee293c33c402d6f61f69768ce97c4d57022faeb022c8a67879da4039907be7c3eed0e91c078c234f4c502bc6dc3bdf11eab50c5d1519510a52d1a4cabbb29788141178d3c118013e374b04079049a570150a5e4f2b068c56449039d29aac518bd0d503442eb5a87c1e50174c4e8ccc5e88df92863a0b5326ac6b922547a231fa01f7dfbf373109065b3e750157d4a2f088461e8ec0e0e51256728136145ae6ad2511faeff80187081d5f7f66240b6dd58594313ad70c2b246b13bfce221abef0541fe33875b1eb8f2db50b5a07073656c8e1bdb689b8c80b28e4dea361951968f04a9abd6843e1ac427de9319ffd17b54ccba89575d288de560c4d69f0c6b796f5a20555a14d52ee955224ebc971b10062b58234241280becd566f8f5cce2c6664f24ffdbdac0bb3f8dc789034d3a82322284fb85757d8b6f8b6d8a866d5956d39277c9d42967e34157cb353b0e1159ba2cb883a2f1e539970d9be45ea6d29f81b3f57f0691fbfdd2f085978da47549c8e0f1f44282c355a7d33794fd69616659b3a5a63e482a6a0408bd472fc4bccb3aa14821a4fca2fc4768f827b164584f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
