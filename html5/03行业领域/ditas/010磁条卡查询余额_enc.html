<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fe8f882cd84780f9ea1577704b84127330abccf399773a789da1c7152cdcd87401c26b4c846c51e571ccce093583c20ddad21d418f58d12027221bab70774cdce426a6093f8cc5bea09ca68c46ee0414a00770ffbe48232680290ae44debee2aadffbaca5c6ba92388478033f73072809b5846dd257438859b8b5bd5fd88a4caf77429c335bd7a98578a9841630ee922f3f23f459c16943f162903dd2dabcb55817a05230e3083cf8e20d5e4a85735c9c0e8ff71d1e26d537fc5aea65bd019269cc597919912c2d8a8a4760fd932b1db35215149e503287b6d5e35b53fd42445dce3c194709549dbc75ca11919326aedb331cc90e93b916a7f02c84e5f013235d868c736c3845d60d641fd98b7cfb693ed95fa9258ce0e542dda2550ec31e14517f116d9278b7bd8fc329e30939bfcce7133271ce98f9eb9b54d7ea0ea77f19fb1ebfdc3de300ea275043a0e8712ce0be6870e4382543b26c29625d24307232efda2f66568abbe22c2b7aa2b73c30bc758d25063c613d83cd745526a5996e370b4447630d7dda4e01f7bda57f5fa3bf8cfe34447d012973d69834eaef39cf874ad98a170e92c7fbf907e8d364d9e186d854e8a242818aba94e40e134bab62b923064b5bebb2eae1f623cc76ab1445444ac11f11a17943873638707960daa8750a802a43aeb99b8cc7e8efe0177bd76cd7d48a78799b36d496f8bf1dc2e1036f57250f13d3fa12b54951fdc4c9519e97a9ce85fb8c09c2141f010d77e4d561619c9dc4d4b17e34e78e9ca059515437becabbffbabe6b0c8af6480bbe8c00d74451fc80d73d3d57b23d1d58b8d21c1849a880ed0daef9fc70d009ef129bf472992ff4f8e5989e5d62bdb548c13b61cc4da9c823e9b56704aae0ae5118c41d5d4d18a7ad3370d2295a463150b4158164a66b9993508b621005160eefa8a50c01319efa030c00dba746ec715c7f60dc70509acf383b821356ec84726b6be32346e3ef34bba02533680a7ae2d908eb9ddf0c92932aa99900060078b5e1cc5dbd26a3b39c93852e419cc296162debe8aca8829bab5e6083cfac2426431034a5e8d659428b820f229ed66609eba7f372c5c3e5d60dd9d14493aebe3b74955453de8bbed0934704e4a891c3b5f1413c7549433b1669cede11789dc44b26ebb6b11de1f94f12bd2c62b48831c73fd6044026cc2ae758037bf6a56e16354067b34c0c07080f08d42957935a21f5f93c0adf5d7834acdaddf22131382624c064c78c88b549f909494b057f0593dd1fac64352b6d0ca3fed620479b9cdd0938f2387f0863337deda80a851327d6b40247ade14fbac01ddc30c6bfb856829e6858e2be8545e5470c7b0148a802f800d67566f3c62474b023efebd9c921b3284e7f446a25d54bd1a978d615a09fb08f568f97734db5f4fa3582f0c41f4dec3de98b5f025bdeb10b33ceb79723832c5c4866295fa1599dc52366813088db6d12308ee9aebf134a15912f82bda309c75ef53c7d9b028d4b47c57ac7ff6a94f69bafb2926d2d9784bb80740035c602ff7d70f23d85e4bab3db9f9e681fde6aca485421daa61acc73a15bc0fdc44c7f7c18b15c8d924bf6f46486a29ecd314665ea655c03f8d4e53d37e4face99b8f4f1127698e2ee872022f776b8c3db7674aac84ab0018835bdf46c6f977ce6ac6873e57500d340e2aab10f93af1e48adf54f61066ef787fb61d7d6bdace9ade6c34e77e2baf75cf703c290fa545187e332f878bf5e2a4dde47910bf186e9f2b3d0d21b9c8450a08d06667d668f1d21f31470ded93b116c3345f450684d7913add85c14f5fcf13bb19745a751441a00688e7842d4a243e3af08adc392915c8e2b48088d2671892c74e3f49928a8407ea49dd866744c8abac201982630df868a7dd1a87a1ba8ff3fc6f8c14e1147702d76b73cdd031dd70c4f27d66ceb6401d4ce1de094a3c3e96d72f32c8d9257748d04014217dae19b11d001fa4b40b5ecefbe84edf687d1e226520a21aecd0fde3c36bff3d4500a4b6230713205f72ec4559e3e6d41d038e2c1ff5cb4ab2c3d9bb0828b7669e388df1e1d7e8eea34a0418d5cf52ef21223d4d311d96bd006ce73321c730b2b12ac64bd489af83304880a0a3f6771b404c33ab0542927f3ff4fbef1cf4a2bcc935e3dfc9a2358cae71b9350a7f4fb171c29de8dab79565ddbfe1a949c88f8d78717dcac33ce4ddbefa669d61a7939f29250f37a4d76914ecc61d64d116f8b6f18a0b3cfe244d23973af258a82fd7b7bc4d6507b1e0669732ca8f9373114b656e26b2d76db34941028a24a41585c72b1173252aa97f9984173fab737066c47314b1d89e88b44f5aa90319d3a945d0f0cb6c7bd0b1fa77503a9bc0cce45db39b4f0ce0aef746d86cf5e3348556b9d09cfbe1f53fd3619d564ba6c3b692ed3ed9ceb05a1eb63070aa667a8e947a68ef5560d715eb6c440cf87fafeaf473a3dd78b6bd689e030fe8f7b40ad3eabd247331b71df22844c9765a0bb0223c48dfe837a0a7ba7de5dfe1fb62869f5c13963c93af91d1e5d0af547a1ab48f8e175bc512a170a09158d9fb229e4e6197fd293d45ad05b1d95849823677356f494eca8d01efe2f11f8607e5f851e8c298c839ebf79ddcbb9eabe46662dacad74a16236752e708a5b3015a333dc842b8eeea636f864908eb1e705de891220bad88cd92f33868bc6428ed89ca517bef390996df03a3f38934bd37dfdd7e9e6fa0b3cee5d61bd50dc4d322e193badd9593968524e7d8e53050a58439d8a906195ddd215f31529510ddae4c2d2dbdd04191f95440619d52479bacc036d184683c6d19c330f4a584f383a3e70a90fcd96d46cd90675a1909a4fd1ebbec2b713cdb1b449d5d1f975ecc19a5717c9e870c21c0ea946935d85b5d6e31ddc6146a1d5fbb9cb28aedff7f68a3b397038a1b55fdde2dd5753ee7736fd52090e05c02bfd984488c9cb5e82bf1927e7b1124272a5a71522af42ca80189053d2544e6d1601407a27522ebb3352509e3f7a534c691ca7163768817d3b5caaa18c66023ef04629f286bf84a9cd82edd8606a2b35ed8a5b8af29a843328fe8bcb639532482f36725e39c2096cb8681b4decd5c5d5e162d55b61b34c49ec716397571bc5d16ac03732042ab0eab1a96fabe920b0f2edc64739b85a0e778d4242a14132dc2f1d7783938e6751514ac8d643d605222ea6330473fe257e1fea126b57c351b54e480de07d5ceb62d433e50f2c5dc40284b605fb7e0a2da81cef3b14ee87d1c17c5a2411db6fd3dabb0dcad7b808bd0b84a7baed986438c2da2ddb4df1d748bb44e6f06e8a38b4819e01c6c74a2999ac6e6cc1c7ff3d660be0b99db005ba6e85d2f8d066e8c8971d102ee7314d4efc4e23edb6d6ed646d02de7dd6aca4a81125ce3221d9bd1d146cf8458b55bd5b284a8142990b38a3c91c29b9948285dbd2412f3f4dd6d15c8fe66a791ab872c9da838e1773b93bc1c6e7a1fa2e96379d1a958b5ecb03b4c41da06a629b3b70f47389952be440544eada653bf4b42f2373c495923b2c5bdbedb599870cad19c329267dca670651643eb3abad75d8bac3fb54bc20f14e6c0ca7479e49c16d86e723eb070a5dc61fc2a2fa398b0005d1f7bae02f86f0b4f0f26cd92732c6bcd43cdd95530342f3cb3fdf97873c4bab3a77be29d98bcee5d19c85184f74b0a0869abfa28822f8a9246db78369a97316328603e1cc5e2684111037b5e286dd74342923fc13ef595b88d8a5c78a6a4d1f92fbcdc35a688b1b197d8ab3b293c75a7826daab5c7d103b8a29cbbbe9fe61d8ce6cf2451daaed086d8bad9aabc753628d8a49183b2627d7b1bbc14973cea48860f1e732d94d77e591873b141f2d46db77d5070e3510801f6788f4517e70ef259f3c5b7c72969ed5adf1601e587d59012f938d26470a4658330040ceb924310014302331dc8924a437b63ddd160d8b1f41b0599b37e998d429a7d290efaa2dfdce59aafd9cc0fd6ee8746adc6a1ec76fef0256fa896dcd0ddbfcaf62addb019d1febfdc46f453d155739be6b964b6509e93fdac201e865b28097cf493b2c7c1f623299b4d2a09d477fa7b40ab956df745cdf9a5d92b6934106db1a7c34b72418801621b66aff95b7bf8d6e8cf49bcbfd7ed7f94bb5171e07f5d805c2405cd53b3c4794126802681ba370642163473fc3b06e279b992feffc6ed1fb7d4bff4e3426780630229685785641c426be64ab5d0b4e42cd76b962830a088f37b1bcfb5ee30e5abb2110d7b6e38630b6ac71fb81974509a9142f79777ef0a8c34ccb2fab0defb06b633f0157c4953b664f6ed3a8f5cbc90c21e39b3ca9206171e461695e1b65753f903ff103e411758a110d8e11fe82576cb204be5bcb9515ea12ad9d4ca1e198d1afc1e507e4b75b929e6e206a97ea01a07ccb0cab196c9a9b9587a7e960f1db058250a0a0bc7c7598117378706cc4013b1b69f4cb1a312446ddd9107c88cebdcebf51a20d552b9eb34367ef6fb9dd98c093498a5ca775731ffa85f49f9eb04d643fa0cbeb352b03d138e2d7565dcec40c5c4aac3e162b52591080bcda5d9d6b0452b06de1396f312211eade2f519210da68af3aa456cbdb84880112d47de58110c245565141e2376ecb87275aecf4d823ae5d771f2a3debc87757f884923706cafbb363570de5452fb8e5b665d51b32c39227321397fb858e1f2c6655f8bbee0cc57d906478b3a2c4d6f3fac06326e3936d5d6efe3b925996f3b0add5f305b1ec38d627ce178a36be4dd48befa4812c6b9f2ed6a017b9715b3dd361fca9007aaeea103fc3fe7a18489c3f54afe0086a852cef73e0b1b0c28d462387c3cc8870c1912582df94fda926ebea21c8edc2ba5267e3ae7e276244610031d772df57dc2ba73f8f2ef8fe00c9d5ddc12477f78eb45e47dc776e2a70cc8eb786cd0c7a424bcd3347f6323333fdb1bb67207c595a265e08da3a12875af7e046df2447dc9b952e7d346018921d5c98681aa84fa12b38ede5f66c0b8927fb073282230204b10655fee13182200a7ed44d7d8d1c7d39e0ddb820c8f4f5855e398a0ea347db3f5b3827b8cb2fb5b7acc3d85c3f811299bfb40d5e164938d86c08d3042cd4f8e205003e2764130b7a741e58c8cc6b099b2d0e68333d358ffc31bbc63356342ffa1d58d8029faef64a7793ce909cd4c13839e9123cc826028205b0e7e4ea7e4cb6b9123c49e6fb0eea08cfee82959c2113c225d95c8f579825bb84a73c6f512a092e54e69018018e19a35c9224d6d2d71865f28e174e5d31d5a01fc1fdd99e8649ffa339cc3408880e863e7b5559a6d6e750f627f0c49c86a0efd85f3229f34e3ac301320b67ba2ce5a3e9697bcb667311b5f7d07e5f6c14819b6f50945d3a44199c6ccdebc683fde213cd148193dd109b8c0fa0a208e3599261cd76f16aef774191e5c17ed94646e40e219d5417196d2ab5b4c48ebc1eec7f00d95feb39e74b0c8f5f62b21bbbc2d501d62ea87dfd3ee3c747a3393a29b9b36c84fc7d20dd7f5fd308773a4d8870d265481c9ae05a609e31cc4b92fde3df6ceb6a5180f675eb329fc341109f3a3c0c7ee5f419d2e0aa7e4a3b65146505c0d2d99ca4052ba1762f77839a1529cd70f3be2fd5a0e26d659dbd8659f3fd908334a2031e1c391955701dbe247c39d4582828015d1b51a665feff87b01c731d5231004315458c783563e02b186a2d41ca2de73db138ff51b78118c54bd4835a7e301bbafa36fb6c06b848eac9203ebf53a74f13ef861d905563c8009c863dbfe909c216cfabb9bc03b644d377cd84d768398bee3846ab5b370a5596fb29a3544a06c3628c81e4c82b8e2deeb3dd64167ba5878dbb312168cdcb97255cc56a23d0a1d33a4c392d1283ca8d035fda6252a39dffcb60059321e665f29aa5208ad849079085279a33183fcef1cd733e6b5d8247337f057c26796a43852af49a8d8e09eeb5ab5fa77657705e2a9006c1876bdef5c0208854da77dfd1f32cff371a889a2655cd48b53843b7229cf21235d61d42d77eabf6bde338d347acc904b18f6df7c6b88df79a51b88fe18fdd5fcac4bee1ba723cce3a2154d76a54d7804d444f464e5d1cd72c1944b125e018eb3ddd35a6ebec492e70b159484235e7596bd2b47fb430b686950ed4792a9a2fae52bea8822d60aa1f0cdf25dc62db9991fb4a56f161c65967a724830480a01dafca14f0c19a18c74764b4df9e6941d1cc2277660db89cb6181e03f7e1d854da40a1027aee4128eb1bc52c8b43da32fc01942a9628a210f3208b236873900fcbf32ba2b323b6eb33829e749c8cb37396d671579e5b401895bfdfa1143f620579fcc1ed3ebda2d8488e5e0a8cf429528e14d81582abb1eaf55a88986d29513624c351ca8f2d753a04442abcfd9459711163e2c558d6b250211cea65fdf23debcbebbb2fcf2276c432b086fea932829642531f7535d8e268ae2e3b16c9e822ac0920d101eef367667b8e897ba3386a5d6c24e7824d65ea0837e0306badc24d7f28b68e92114426a85e03214a74531a17833f63c413f41cf8e74ec0922a8f17fae5dbb12bd937b4075827b22894e7db5f6a525fbea189389c4d3e6fc1b27732fab56ca443ddb5f286d507d1cb1fceeda119cde3d00155560376edb2ba2672613e5aa63b9d7dc1441ba92b43227c72e775552300aa5818ee7c1b5da8d6a7cbaa2af1a19aee4dfec5c7a65d91c8166d88d61a15b8407e615ae5bb47ae2b69d9205d6832565d76a50b052dae448e523b7b54019c390850e0561eff90a82aebd4b11bab3cebcb38538de50efd276baeff921e1524c44f5487854dbeff54a1f41a468e3c410fecc88206d9e6fe8bb5a87d74508e8981f9c5d7b4b77ffb992066192b454985420d6acc7c2ae2e2d32865b988c295051793100efffa1ad7e0f40a3657b972362f64a6b97a7f470528cce566f8236f82ec6ee34132149349b2983df5997e33c04e7137a155c709e279f7a6ca5f01a2ac0f5f8628c985730572eb3ba9aa092a468cc9294c92b84372a663583ae4081b89f68d6f7d69319fa368d621d7392fa7d0a031cace91779565a8abc38e884f3be8486caf8ca8dfae7d161039b86e4e29afe61232d41ef7fd703cb70ebfbd1ba3a60c2d788ed9628e3728058f0282ea2016df9183ab6ea838dbf5fbcc07fa828b15be5985ca80bd77f6a69be486cbe13f8fe47a939de8a49da9d6cb65c95f603f89647a2aa2055cc057a6ff23e0a8f1100cdf696cc992e829185a1cc41ebf5a5d45b736f5db4adf24c8eddf8b2b1dda5a3c59a0aa39306fcb0f6d44d81e4d9948336a1968666ea0a097c913ef55d07a35281bf950b31ef9e2e6f8fa54ce511421a8b021e6fa97de3e278bbacc93dd9a057b15ca2504d97b60821327b7fed699abf8d2c40f817e8040c5b9029497b4d4dd233631ff125faea7d321a8cb89b177f64c0f1386532aecb47aa0ff2b86aad1343ac2f8742d6c17723129d9de0df6983cb010790dfb298b01290acf1de0820f97cded9a1d4130444d3cd17c5e1471e9546c62abb177b88e240438f7e3ffe225f85d072f334ac6ec98dcaa2cdfad1678bc143f2d9d9b13c75103522cd85fab6b585fd9bbce8a22bdc6c8707770a76cb21cb2cda896f076c50cca55479f45a9f7d929d46c2409ce278c7062f9724d5582c8ea3a29f93cf4829e0b45bcef6ece873a0af119dfefe23669f0f85acb19dd2313570c5ccc12fa81d30ae1b39cf16f5bb47512ac91736409cb70bed20b416fbc35a90cdcf4c98917bd49828a81071d56693197932553d0af3f226361d8937c6609de2df248433dd3f821a4fdf14c57092196da1378ffddd8fc0c1ae17fa498c7115854155f16a2024686c237dcfb86ab642880f2f9c5e6bdffef829d5b84afa65e3dbcf1d9f628dba907a725732b67e54ad66e0761bbdc2b6a20d4814163d64f1a1117f8ed85f6e5ed828760174dfe170d93040d2e218fed2b82c4ccd08455b577bea70c98b58059603bf98e33d5da99017c51b7edb190e90cf12ff2d1d6ddcb5d4f371ca15e4d20df8883c47953b9a8eead71a5ff1931a4e23522a938fd22c81d27259ec1724cbe81fa306c87015e2ae00e2b7b0ecfaa327fa61d834e2a9553dc94c6019cca08989fc5505506bfca515804a0d484393c4f06526d2fa6003219b322e205fff34b129d206901044e12cd5a9ed2e43cf1202fbc974037432af9c943c0a423fa3e05351f8e9fa3a68546302e2e5b7a565bf0b27d0aa7e8c4056e27da5fe977d6d7f63bc957965b18adad6924b40d0924d431cf7eedfa28a17969347b6d6e11486717912e596ea7e27df790cb14f8fc0b5852c4c9be5a3cc78371f2dc0a74979f40cca3fc7cfa5a8a7b96f4e2eb4e068301d2a9e40cbe3f1946b76d5a3d6509567111196a793fd9a2ceb7729403545a1e3a11679a792170610625ccdf2e92b50249f075ac96f7ba861758efa5ae1989ef636047326ab87112e4faac024a166b89a90d82f43931e0543dbeb1c2e8190247636375abdcaea435d54e033f8fc85b71c7c20d2dbe4ad4b459f8dc26f5a7a01eefc2fcb3c1c0d81649b151a0fb627409dce13041c313c1777ca41407de2fb2072f622ea1ea60669f132073f332a6d535ee45d618a397bb15c6d6f703db395c8eac689e568ac14d3a2a71d486c7e97eedc6e5ccc8189175f9defab54381cebb44cce46fc4ce10d50e60fea0528cc58d991c47b32c46e4fc8434c0c0374b8742f28ecf9aeeb97206e56a8fb37163b0b52f2089cb66844f41525c3d82fcd20cd10e9fd754a7a83cf0257848d9f5dac4a036104b5a3fe7774e01a9d4337d7426f82e19c08cd50fd07d70ed7b9acd886d6894eb822a2c9e0c16ef51e97c56b9f00cefeb87fc66c2c64d45ffcec9228a914bdec55f1e780d0e8ce94f3810dabbf0ff44ca1b589a8e12f8e13b91a5bff949bf2c630d4f65e74d93368646e853a424f14845ba5abb2350ae815f7d64f086bb5fd60dc24bac39866a90deb2e6853cdbc384abaf61f5f59652ef9f882b56fd6fa176a22618fa6a8be2a6af594686157b160797913530caa7d7f8178a392fbcc1b398533955c3bf66087affc54a9688f2c39b063e4b629bc74ff3255ba25720cb9d4cd58b8398157c9d8a5bdececdf6d182549fe32b9df43a73569eead6ce845761301377481f63671ccae16a2ff27251e3eedc0df76ef998176e3072cb8ccab26d05415bdaf8dce97aa3a406bbcef064f19a16e2aac9ddaaf900abe554bb3c3c2552108fc6d790405bc87d89319e041feb89d5c82094b08a8d7ad65cf25854e399d9bdfe40156add25de9abd04bbb5cb10079f0123303fbff5d7fb79adef96f39fb15d98a8e5d13604978eb94ffccb4f03d5bb57ba37b817b54d2d3cb9cb68c4789e159de0f781fb9e90ef5a3f4cd23d91ce65f680cf55689e181b69bd35bc8cb338dfe6f2f9f360ebd6c4c3d7b377f957f620588968635a0edc91cbe109a1f14b57ad7bd76d1d37bd4a801a3fd69627358eabb7c7a52ed7d8d60e367267a2da02301b7807b767fd6b26b8745199eee8f828bdafdb7c9845a3a673e026913ca34102f90bb960716fa3a3c174ecc0a08c40b6af86fefec2157ed0fe2120621ef003bfadc850b51cd8e952a78e89260f28052622cdb985aa6b42b226874d9da4ed496d4cbcd6662eb8b82a51575bead7c67c4ec4e39907b298de906153ba06f97e448044277f6c44bef06de1947ddc4c8005787343eae3e394f22256c8854c3b23d4cc0b2bea87fb63fa1e66789574003c212d040e331682a1d9af593cfcf27095f73fe41a913c77a0a676750e08087a54c1f1a59247f96ec10fe56c61879bb266ae80bfb9d0884776db56e4f888e0606310dbff18c31a3da50409cde8b48f7a0f23f56f345f03f726dbfe7ca697e8d60c4b709944cebf19b34bae4d731e76e2b96dfc9d86db48423e080a65021fd8cd2c00c32b917a72132ab890cd3266377c01f4b2e07665babf70712a51db51dba084229093987058bde9677111101f4a064de2e862b75af8088ac4667136c3fcc79c2d610994b9bbd8574ec980fc6421bc5856ff04878b6a2bdc20f5009038a868381871a9102d645ab26cfe1fc806cbdd6d739b01de0fdbcc67ec839167e54130bdf4ba6630522b24cd5e9271f2fbc7b574f8b3c9b0f986fc653d1cbcde950ad24ffe825f3b827e0b8a3dc9e9496ee4d2f3aa497760d62d4b3c029fb9cda32495ae3f7cc624fc1d8a3e5667f023a114bc5a4b06cf8319e84891a3d2f6d84b29eed4f0d646078fb64aabe58afe64c2085f3205439913d91cf415bd0503fd07431ffc1214dfebcaf57ff1bffddaec811c77751cca10d1888f7d56d84bd834c9242ffcbd9814d414ea6b2d057e1f1746f445438d04ce6ce45dbacd4e202b067781606ae2105adea5bf4c9955d482b3e22500635d41b22e757a22958d765ac5c6bb37a28b8a041e9e4e6ccf85f99b6f1f0ce1dbceac6a4f2c88fa6ca43f8dbfdfea469a3854612aa4d5cfd6937adc28a7d304529e667b6bf13fffeb9ea0697424991","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
