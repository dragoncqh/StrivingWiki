<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ba0fa9fbf765f8f72985db7c7fe611a6e63eaddcc173c3ed043234ecf335263ebbdaef9746fdc3992c9b6ac501106f44302c52aac2181b05d519aac3b202b06625c915d9067a1892c7277f842fc06fa4ee82c986a478b9737434b6c8c774fc648026b7c5974159ca9066ccfef83adb83c389f699536c29c0e4ef25f1a54d429f707ec976b1813a5528cc9dd9070c010a631b73bc4494afd72ffb5f4e53a688c0dee2502e4a3d35c7849f3a9acbd06d85fc406f129250487bfadfab919618d34371d47e93733434268d6644c8c892772925d16066404a75267a7a760f89586ff6c5bc479797a5d455378dc5cda1a2e4abe0a5e9ea7e971ecdef965bf74907988d500ec3552b1a4390f5e889826b212762ad893c48275bc784b14220ce518186aad4d126f8de5ad59346240f09f0e02fa0b33db83eb5e60d31d00b198d53b80a3655cc46dfb744bb6bcbb36f7e9522095b6123f3530946cabe91acc8161fb56770d1b4ccbf8f6984cc813a26b7aea5e91e8bc14cfd5f78c730d8c2c052554babf354c3ea51cd49783aca2b64118226cc0e552ad28ee2c256219614742b22e262a618b1418b894e34990beb3f708dcde827d70a3fc670b02b8976f9ab372e1e6bc2795f1994f9801f9c944ddac251e1ee6d6d8628edffe056567672d35f7790d4282c85476e45013548669acf8797aec09f3d9c517617dd8ca4b6845dbad95802388b441d659f3f98fc458c10bfe5abc3994f4a2a32f0ef376a0f0e3321269059e94ce762829aeeeaadce10a7a5b8111a3a0a5156c381892826c7cce1d226158a4152002c91d70d96eb51c8a303e7ef261fc834e245136cee3a8a4d02b747ecfa38a38f79f5e537060162bede155295bd0373daba4746e027154d106c456cd57c221913b5a9e6ffced09f499345311fd7eaa4e8e95b5f756d4eb42b289729451a5ca3f159e41e60f021f4f78f99a509d43d45cd0b430928db1884e9052b536b899ecfdadf098f0732cce656b96b7c85707fe9e54caf78dbf7650f6e63671995e99bd8aa097945fe354e15498dd9e91ceae893e1497627a3a4d8d37ff08a254afe1cb6ce233a9fd5fbf7a5d1e1a8a52b67c69c80798906dbe6701a5eba29612596754a83385fd913506e5a58c13595c0d94096cf1c6a0c2168bd5f0ffd1f1a25ee47b0370369d3e78a64f08e099469b72a55391c09d4924a8f4be54afd1d10990de88dccfc13ae740deafff61832d45255275f2f12fb010823dfc0eba7ca55cc940e5e79ddc29236bd2b8e393623561066e2eac4c3ffb2564dbce82f577bcbaabab03fafd87adb94f3eb0bf9440285b44fa9f336f727af56b3c5440b4171f06c1dcb1ab99c7309bcc1f6ec41f048bf093abb5d1c542a1a394cc850a49dc82d3501c79f16611cd71a56dc08219aeb9b01c985fde7f8a70c4c3003e6f11d407847ca3c94a83b6f285a2dbd8298e3d5bfd97f0998c49be09d31d44c8af8500f7342eeff9d50d6794be32005abd29c7055215b80d43056ed27d87ee861830ab988e2bddce341bd23770fcdd44742ed08ffcd5859c0b3e47e7ff32fbfadff373e94b4334a87e46b4fb8ade65e7533f25a314f96b03052a400d3a136983f7610cbd6e3f6588ce070430686109602d53e02b9770ac65fcc556deec484d1ff4be94604743e17ac0b9971171a120eef03a38c2f472009debd5bd04176be4acac739d74af860429509387317244193eaa0d6900598b155c2528df9cbbf000eaec9a619530020d61310e8b4c8026c30921b0ceab7ac81d381c8737a336709df34851d61c6ae5b0bbc0576b4a375e50582b7f6a62993f96bf8866f14abee5cb1d19c2c2a1a534fa23460f24471c58c6da4c6c2d783b04447eb390db88d02ba13325dbf23704721f4f20d48bfb73afdbcad49bd9cd01ec658458fb8d3541bfe993a173dde5fa18a03b8350343ae7b49143c3b9d25748caf98596161368a18fc5240983442bb7c447c1e69da56165e157577e943f06f9013cabd8f9e415121fab7ee376643ec03ee208da5b68faed31ec168e09552f708709dfc50555bfb569009406422f47421f7b92b1093366bf17b781352e9a33adebc1f21f12863fad59f63ca2a0c3a247ffce3e07ea8abf08640f65bf0dfbb534e7264b9c8ff25e78f95e7814e7e7c3058495730701ccf2b45678ae4ef4a4ab8fb3344e91abbadb00bfa9b0020fcec37a0990dca52bcb1755b730c8ccaaa4f93e2b0f7a8def6ead21d05daccfc288d2c75fd2037d178ca6e4c92f7cddaa8d19842b0aaba0bee5a17f7e4903780ede716ac8b7cf38b7c8c3f47643a9475d0ea80f9b26b726f2234c89e134b8cc2e31fa18fba3e2a693cddf28a2c2af166c4426d85cf2562221e5a6ca8d1322bcc9cad9d01db5936d6b58a3d682f65fc346ef94d53c09e8021d7fcba54fed22cb92a9763cb585ad9ceebac43320ce73d1653afafa0c098408e759feeaa27bc26fd0f296c4a1437c5585ac0b37a56799255a15b8ae3054983c3418d4dac2c048c88a742fc5de38e04ea5051d1bb1e3aa8d9aff18bd71de2f34cefd60c5959a0b7d3e595774d153f98ee18636cb176bee3b640ec675dd93250e29ab14c1086a0560ce9f2195cd151bf431b0cdcbec97d168d7b26e051a78e3b8f162634a9ebb85fd7204e7d0949e39fc8edb32bccbc9d64b0175655b96caedf12c7c925711758d31d21bf10f924b07b869daa7080f1ddc17a458e997e98f576285d6d2faa2fcbd07eaa904689669ebecb98e04338d0c58fb4f51dd9ed6e70166b5167c69a6d312c753b879831cda3a0fcf8abb92e052d4786f7ab9e489c14983d9e07b24ab31e219115c58321f503acd0f8c8f2e399192ac5b32e85d7c415811011930d42e58d036ccdeb85c1accb95224827baeb760f8933a3c87c3ad1aa6782662fb4580c024eabd30a859f675e6ada03656b9361f53e7b84ec2b2d54f7cdf9912466627cc70b8ba95b23d04b29d35cc36f9b7ef97c8aff85056e638153d4ad60f2b159b07d7dfe4e4be7dca2206c58c35909c2c98ce111829c5474db6899e7b6cc23ce469008e0bb3fb5486d0ab50e3eb1c6285e1e2c62dd75f80f0c29d6a7453acdc388bfb5e26285daa23e10276c225cad03c1fd4cc4100efab0e8c531f0913e8e9448ce0c9581e8f66602992dfd49bca47625dc4d0b02c310fa442a3d994ec457d3fd550fdc1250be9a144b5700aeabdee85042ea9511d26654f32719977b79feb013f29e1654d3f682d218a385a32f14a03e24c2c42dadc35feaf92ec47a7d929368a0f3c4977e83173d376c9e694e50f87e6a994d99d1e7327191ce7a1b2cb1e5290cf29ec16baa412087ea608a50e6be64191065d82d9d5e61c063660a6717cad113219de27a6a3e88c1d4166dfaf04b0056f191ea27eb83276ae2a6c8e953577aa9c2cb264539d0f23a6fd91c0805097152c8df20116dc6d992d431b2b690da371e94bf6feb7d9212f689a73f6307e3229b50bf469614878a6f98626a78ed12d1043ec901eb4dd9d0550d76e31efde3cbd98a609302b72d8cc6ba41d49ea636c0bb119cc463f56d1b6ebed1efb26d59c8a5049a399ec6c95622990afee5ca5667d3c091c5802d4706bc04c455eddfea170d28d1dcb63f153864960b475b964810b8ddb74ff87c8f0a9a063331910e19d383d37df73d76d4b1741e39d09827c99acbc37b1d191d18d58455f31d95721d6a665a517b36c146fe0c6cd306dfa05febe659aaf6242d54a5a73ff77c756b1a105c870b9b142380b71caeead4c6270978f69ac86a7a725587cfaeac0eba4ab72767594826008968e6b22c4d0a3a2795936ed7f21e9d007b523dda77c3a607ac96b513e75438dcc2bad4f6b0c2ee9fa5f4de9f148085ed2a7b53e4c82ddfe7fcbbd2ab53a0176494106172e6832651b8a7d69c072dd6211ecacf7cc680cbcc95564b3d9db007775f2b5646eeac27814f78c0c8114dc01db4588c17e0430de09a1f80894189a39d95e8a9a9e7a0356e07d0b604ac271c67845ee6a5c90d55aa75b9c58b369777e142e242fda50687cb863ba3bc73c130eca2872d98c5f4d1b42af3580fa09ba765861cf2168b0aa5f9d9650262e379b52fb38a0378eaa8fe3f0eaee8ae7c1d732c6416861b88de8a7aed8e18020bd5a91946ea5e9b3d7ce705679464fcecf0826c4d0fece6a1c979b8ec7e51486d4a8f877c27f649ad174244a6de1b73b69ef3dfdbc780da0a5f667795f9f594e9b54f740f0ad120bfc76cb84b23c7385fa68e7d410a0ede77365b75722e6fc091b8d5358197ed9394a0febadca9870e9951a3cf01e4a60d16b7b98c5635b334cf601886e304eeb7eec373ad40e0e20eec95e240e13c100e9ecbb8e3eae2f25cad301ae17a0ea6d80e5cb8889ccdaef94fd387491f9d125f322b012898eeecad71c82d18746a34a15e8afb9e6262dd7a718000141a92d1352cc5e8eadf4685fb618aab9d825dfeab069d31ec54ceed69b150d4ca3fef138e8c0dff122428d31efb73954ea70bdc460f4bef77b8e1fed0a6f1cbe3c96ad15d1670eb054bb864f3839cce171d20dc397eb0392beb2c68e3c6fec967521b64d9e2c56823dce5579ef2b1f6a7b0aba0742ed114f64cdd37005cad289edaf60dfccb5f7c42b3fd04f9824a41a43957d78fdaf951406e358c7b8c779af777d1aacbc28949c9e89a00413b6828355cc5f89ef6dcceeeb4c5709d39a9d9b3340c44fd112d311896c0fa926de0ad8df132318b5c811f85adc9b7ab3edfb7f80073041a0acf5e7f4c52d026f2fd1f302d382868a9a7c02bca60ee8833c118c2faf28247d161c44334bfeb71da7642c02a96e312e3bbcf2b9a6890c003ffd6a4e7f2e2cd100099512bd723c57a911988b43801005751da4b2d75ff085aa84c4b9c29010dfa1904ba27ade81fa067c9e4e77572ad23d95d11de12624c3a817e5319eaf772e33e078299b68856fe652162cbcb02f82e24e932a45d02240e74dcd4568281f1eb91c15465b435c7cbd3c813a0de548e8f01d03981870b83faebadc34300ec0a6cbadb9e49dcd8781dfa58a18e8f4d2c1a438e7c2bddf35bf7ae10c8d1e2ecb19e2696de255f78f9651bf0b728226c125836029a515e6d0ac602885034bc078705dd15ff411eef2c01373f0786932a5a5fbaf2e4a54b98d2f2f4222dc592dd6bb4187d8e47e477d809ede9ce8b8f09cbae37f520f7cdcdd48fbb9829bf5eca92f433a2d5cec4bd046588aab04655523c9d464aaeeff7d35a80560745ccb468f1186e0e1bf81efb54070abbcabf6047e900776644514a730b4ecca55419fd4c45bec8d7189ea40ee42916c122a2f7ec356969aabf4ef6a2ff25aec9785788d76d8668d6485561ecc8892ac9b76bcf0e425399fc9a933b9800dedfab40b930207aa09e89f46a14b73569d20fd700c8aaae2ac7a1a2ad9866e14e8b03bb490697eb0826f30280ffeacf559638e38bddc443f825661b53e07001b1e787a9969fdabba4619ad2f0c961fdf3e6f83eeae835a410104a02a0d48ddfe69c4b5c13fef351986622d041752a5bdd3ecc4338ae6e999354612c9968e0dbae949d96d9ef5150710a77d131ead7805c1b94846caf70ac9964c933faf8c2c2069d6597f2119dfd6606747b6012740ea0789c20b420d65a39d6f4e5dfcb77ebe756c8e02ef0beeb5e6a7ea764690e886418f50f4563c4baa9164e0d3b921ed9790562bd38db22b9cc3c442a469de353b4df7ea7f658b350e2dc3e3448a27ad246b0ab825191d172b5d69872a87260d001abffbe1241e5b0218e7d7dcc648c28718d9184a2dbb229b7e6fe5be99a2e86880a95d11d735ed8f75096f29efc3c79ab3d67aca11b935e0c56200a6bc468829c121dbe80462dcb35e5a0b512995b7bbd24231452c3079febf90fe5f4d974a1989629de48818dea2f5bf792abe4556edd02335ded7c426578a2cfa8653a24179f98781d213df69fc2c36a53743819369a8aefd40e79b5235cf1e75496403c2b7923d555be3930d298810fcfc13752fffda3672e4685218ef006f4d76557e05a368592752544d1fbb34ee09d6dea4c875e4809c229dae8598bc0a1a022f6ce896cfa92c9f847da24815ec94888fb044e2409f232457a7eb85c89913db7f71bc92fe5176e9284fda7b0a131dd8336fe207f82f74ecccb9b8b77e0790c5130f585d55d4bdd8f671c11a338706fe36ff949f39b4d1a1e0b4d752675aa68455d32dce10cd803e5aa51463d3c59ecad026ff9ce2d8eca5fe6001c63c0e85e91fbc85ce182a1b099938b61399aef1e0407f7e5aea9ebf8aa410f99d9f1c3ffab47c5ea486bd07ad1a898d60990b524a9850fa2c0d9d79d6ecd50a4cb701f716d50754583f538224b8e00a92fb090fca3d2a0ffaa224430c2e6439486c0465859cad8052284086f19f7590f062a5eb7bd0d736f892a0cf71ab186fda59bb3b8102982b69edc9d38fb293d5f5d973d512fc8edd92d2ffd978d2aa41c0fda8c7c35f7860e2e01f061cf1af16905facf985583fa2722f41c251d4fabcc98bd5dc92ad2797d43b12d86ea8a6025d69198dfdec4b0be1dee3ea6dd5d989a01979be06a5e2a2f6c1667db2683ae10a1a38e8b52e273996ded2d856fa491c0590ac1380eaa0a2e2abd968aeb295430ba341ef2d955dcf86ce1c9818505475742d0066870c9c637703f4adaac089ce97d04959289f110c2bf174d4161f2fb7a5b95e0af298a9de3d4741b87a557fabb00dbdf833d8e83b4711275c596a441ce3f0800044a9f24ec3589b85d4d25c93673dbad5123d02d806406e206fdf1b98ab68359554d80976e4b82cdd6d5858f9dd18cbab97d85b5d9706aaf65bd162cb28fbb624d626d9e5df2ccf45a30557f89c0d021b2e0bf770f252d7bc72d9f4fadb52a422ffb1dec4e495dd8679248671d9501fe1f5a2166031790a75a7cef37532fbda40e34f33d50714aba12b824d87ae75e491086be18253401003e1fcc06485cae11fbc7bea080c1443b4438805372752028c30e2e218daa56aabccebee4d05a31d708ecd7560634b010191c66c3957a1b7e2e17c24c2d25766a097b476b438152e20608c072f95f97cb07c0999032320bdb26a9b1b47d375455a307311d47e9c0d3fbd2a0ae751262d6c60df3b1e8a1484acf2c5e3503daaa473b73f20ac71c976568b2cd8dc60b6d838444b3ef63938f75cbcdf4c0ebbea6e10150db68aeb7fb350f785b254ce61a320f8248ef69b287ade1f395e713c6ab619968262d967b85b807de98d2294c5692f8c32661d2e2dd2430a3d8f8d87f022d981b32a443831cfba1833467df0671004a40f2e67fee9514bc9f94871f8386dc48bf291b449aa92f32e544b0fb7d24fd8abe09a31d28262d2eeff953282d3801c1ebbba5e81c79e63cc5c5bc2c7e2fed9068e279d3597b48074289855bced16a78e9e248d9981967316b24fa6e3eabfe1180637fb091032790078bab8280dbdf4a9ef6f1f683a7392eda1f74297fe7f0d9bdcaa0d5040a0639cbba2dd555cdaa781361e290357ce81d30310e8128efbefdae7af0cf63df224123886e984a4bcb85b95e705d01f5c8f7dee455588238e82853f64d7da04481be3de57670487c00fe5c42c645bf32bce23f82e59cfa1ed6a9eb965b0606373eeefec2387f5c883de9129f39f0edc082ea3903bf15bcf8f65869a3d833d3a219481cf4fa6d99d0e83a594a611ddd0f347c3333831f809667f22c428579695c4c01471af648108a28f0b36c74b2e44439e8aaab93e3e916d3d9567c515b1feb57870c9aaf449a59a40e3bb2f0f33101934c548f27842efff38ed8ff3760997ed1e0237d14ac69cd3d5b7c52496641a8fb2ec1171847d8d1a2cba38df8a24ecd51a93a1078188a59fe1841093348a2e67616687cadd35aa9229ed5043aaf27faae80f022daa57f81ca56edf11efaeb978c0771b1194844dc3aec29376581e2023544524182c0479a90bf01e49436c383d8e6cc50ed1e05d7d7171ebdae681d78de5820105aa374e28bb80c1a0f1e9d597f9f49d655491f0898fe3f6172e5df3d0f44d08c1b7b53719d3cf5fc7a19454a6e306515071eaec33d8c220d6808153b0a442470e3fd57d98cd5f3f3adb551dfcdd7bd7baa4365ed46e8a8b532e618f0518096d6cff6283436addfe2f394652478fa7fd6e1474ac010dc1abc3d9bac776ca844316ddb25605b0d339928ad5e2bbbb150abbe3d837746d6b4b106dd001b4a73a592602aebd8eb01d51a55665d0dc5bbcc8684c96bfdff5605802d85560c860e79787ede730b1ee1714a1511eeee29b6f4e17a3676adb8243b42dd0b2975012c51cbd8b6d4cf26802ba0e24c99f05459ac08db11f8797871ba81dd06b3cf6bd05c7b8dff87ed3d743ee0d6cc83eab5009d038df0ff9b8f123a694968064f523c27abfcd820d6d117c95cff65e2c7fb4b9e7bab75ae4547d35400e4b6718298474cecb235718761777728ecc48966fc17e193653166b661f5575e69bd3789dc345a25eff2519d78fb34ff04a8bcacf3c9a6ac13f6f872731ea04eb3b9d1d9a33e00d8e061c6470a5789635c0f04a075cdd51779275a146d321a03a5e36d075959bfe237fef997c42e2e5cd914d26421eeb337e1c8103714408fd0cd2eb5fbab572a384c127050e6f8853b62359023c822af712359582e5ab37b6f00ab32ac68d5f472a97e321bc16662feab1210162984fc4415fd123aca3b9e13ac40027baed9dac96664389fff11302604b01b55b774d928bf80705a377e275544b9d573093160fc02016d8609cb6808ad857a02cb6b39809a2c0f5e789b81e75033e057dd37caed54fef5167c49b6e663c75f0fa11d350bb8f8aeded237d8569a271bf1f9b735ca443a88a9cecc3a0e9aa6e0e25350c6b2c95650aa830944c92138face4fad72dceac158baf2a79eb8410ae95cfe730ae14f234eb1d5d635d240e2516bbc4857a28c3c02c61821fd014e4a3dad0195bdded8b5c4563a26c13c7145a476d9f4c27403c07a8e52dfa21e15abc028ef243190c4b2c7aa596d09fcc4f656694a9e874fcd9094394cca2566147d01fef79c9be7ccfa855ac1899d13313fcaa97508dbfd2145f06efd0119f47ac6e70683d2cc80bc9490ad7d2a1c3884450be17bb1bb25f0fa817854366168064718f35651cb677a61c296306586b573b272e2e5ca8ef20c162e7ea375824d2047967ded2c38882a9abcb53380d9e95cbe7212e6f0d70e5370231e14a0d2f8492fd20553e7572943abfcc2b6c9fa788a5d56a5c54b7916d30008531b25c3ba29b2b1fd449a96082d347e47ff02ba75b8fbb14a6d2332a6c25410c8dc707f6f0cf9e49d4d741fb1f209bbe8271149a8390bc612276b6e50853c905ff98df3ae5b8956e13ccf7007d400b2144d2f81af64d726dc0d9ec4314d7ac6c07a4ce959c4fc52c9680f45b683135e4adde996b1080d3d3137fd2024db9b41908b614fe78dfd0530af459fcde4e2acafe2882f8f061e30733cc4e71102cf6b3d2bd19490e8d7496032970e89772866506d6fe36cb4280b0321c97037339c4daa33b85071e8bbd5f5bc5a186bea354a532bc242abcd7799c8e287c48304e9b3407f879a34031702125da930f8f8bd6c0830f7b451e4155563fa16cf1b31944e030d0008f937516e8f4b03c20bde9c3be7b7a49c6dbb6d9ab8356351aa98f0e0ff73ac3306d81edde868f74d5a5a0dbc9b602576ac4b49d1b80048af06b61e4a59595abd2ff19e5d2fb1ac216290d4171241500a411d98495028fe3abcd67681e94983b752c9df89dbd9e71e7fa4071ca2220c93ef8bd65a87e2d0510de756856397c1f5ac826cc5ccc55b47db3877c8291986616ec2f4ba7a8f81d90e6855b0f5ff821c57f4d25a0d91be3c14a468615aa0d05696a546a53e3898969325903eb57851c71346a64ff07a5f5857a8b12bba5241ec7b216e2f47ba4c914fc02761ddeef84bc76c83a4df8bf4e9599b3c91f3d6fdb28c3c05cd14dc0f5f0a3414500bbd22b26e38946d1e20f5a1c5d22703524b6cc606aa2b42ebf602986826405368afef1da6357117f280b91412bac1cce4517e91ca71288c8468b8d4a9014e6181a9faf820cbf5c30c3e7577f9d7afdf735d481ad78513a7a21e8ec645f5836d4e928ae0b9417aecb128e3204297ca5a095b66f402bac64e0e7c454338e08cc00fbf758ffe47513805383c227b2b031950c29d275e3f11fda832346122c8dbbab900a08be232e3f5f7f6e61c5013ff6071925ddbd37b5eb2bcd5bdf1dce53b36b2fd4c58118cfb619377b3c121c067d4767e10c18885668d5c84365c4695bde284ad32a8903bf936cd8771cd63c2eca790754ce676ae8302f6a1989fd637a5514762e17895528dd6bec15d9614f37238aba58d9d145739303f3c34a77d2f1110490ba5956bcd43fe558fbbcb7ffc9d4c37fadaf14f10a5ee8103dec1f5aab1ad3ca725f1fcb4cbdfccd6d0b118d0e3912eb42a2ea1bd515352d4b0aea53483028c7defe3fb2e9da7cabc7e48de66461ef94a4485dd137e2fb84c4177dea67a0c782e639c1cbcaf1ff236c867d0e3b4e260577d06a09ce1e8c7f71c9291ae2184394069f3b59f96aee25d90ce99680c549f34bbf2b35351106c8d33d260653419f907a5586453935a96706cebf5a36fbcc01810355fe4f8708baffd01b815f7de84b4c034c53c983bb648cb6a87f4607b6b3325d5f83fbba2e0352010a3339c56e81f1ac5ff1937ce30b50619fb5f68443aa52e2ca7197445999e3bf8fbda76b56ed55ad36aa129e423ae99fb9ad8599614688ccbcb68dc29ffbad55e4ea0719ca0c3f9a7e5d3271e0427bd392a307001c1d2be9d5cd35b8a376d5de7fd8100e3ec7cd273c0c353f45ad3f8065b2cfa74516e19825115435ba36a3d657d9749e3cd71ffe713c8f08a7835bbf8c55c748062eefd4b5bf1f1d4f615f62071ac8ff032aead4a6d72ddf6139b0147c135ee45a3e0c13d442366032634df7fb81c0a9ff7082925a66c2cbff8185f6aee08d13bf25bf7931cc095013fd3fe75f0fa44d3565112cd79f45674230bcfa836c73e07cb4c17c49d34323086a0fea915cf6982c4e8621df097e31d1388f36857cbc1e5d39f7f86b9d3a72b59002f30f4d38f02f496d9894151c15adb4fe25e9849a15a5919330debb6db041708b80f69dfc5d4bff194757a4db8d0c487daa1d769e79787c3d141579ba3d41fc8b544bdd4b64a3ed7f5665ba49bd6ab25a6d1fe6184945e738c50c757683de25ec0f6fb187f01352a670063138fd87b363a8f2c774764f80bf8f78822073b18fb3da5212b6f119e08b25dd44d220acbb3ca61d7316d78397ba775e2b80ef4b4e19ffc7345aa723d994ccc06a31827755a5e4fd4381f7f0f264fef9edb5907491a2a760f75629d4e5f781e1c4bbd179e0ad89cc2378a9ea96a88b23848e2b3daffabec4412a5fa7617ab997055b7eea7e7784f39aa7247e97dced8d482c786b1c2829ae4941b67912fd28845b5c9b889754d3043df222b90e34606f2190b316a373f506a341a8a07894b90e4bde222f743c9abbbcfc2559e953d31c6d918802921c03ff38b177334631c810b9227fa4c87366b80eb3722f9ec436fff57bf554b7bce87431f47b53b4218220a184a21e4ee67fbd208bc61cf64d8358a124a8564e30cf4b0c1723bb1185b6b4473d151900af6f584ba92704dff09c7939b1873942ca6d6ee4aa21153545f90a168dc80ec2ac9c87bee7dca098d691160338f27a4bf72a456452b5027c85ef17f61a8786699eb05f13bc19feefda9345043ff1eeb6cf20730d047b071183c9a9709d93e9734b196f7ba33f2ded10353579ae260e30769a8ce2a4d851e000fa6a38cd19dfb758476693fe334e31ba3d7f8f13a6fe0bac9eab0019fdd4e3a55cf0ef1030bed0c76888131b43740adf750f01ca514eef1ac69cc96bdafb34cf8d7999ca29cd2eaeb1d2688db509399649a376ba170250689fd9973c362d08967a9ebced71d7588bb379541ce570834a48a3d872f6d8db09ccc037adf262f00b7ae4d3c10814122dbffc1082f6345df7ec74c9bd0f24c43c5009cfeb6dde1500914be83fb1bcae28bfe014498e97b4c62ae0564fbd610d5d3b982d46576cbc0f90aca532c6ab1855f633f4d53ebc89383fd240288baf29da1aac377f1f10d9f911941165ab4282cf3ff0e873779451198682738cead5c19c988d47d84ec96a609910e8295b180090548b93bc36b3cdc5532b808efc05bdd78fc58ca45f2f152516e2fd30de3f3fa270f166864e9e3cd521131bd36bc288781d57ad6f475de565768470d500caab3c8e64db909731d2af50110a775d93e59d163507757ea5c5b698d96bd07a42e66f0245baf0dd9bbd07b71eb34ebf64cdb5ecebd12e095eb2279353455d09a5fe6ad8ee024b422252c5816caf890fb7c8a55ded83ed22cfaa39a1c0685576e981072c4e3699d2d7c9dc71da29f9bcc7e058a91e18b7317502109b47800a4ffcc2a1eed95f2e3a90536ec6f47af5b239b287ae70ee9739c30dcc57fb7e0c09819369be208c6534da108a14e2bf92a7715b3d36fba793ef1d313295396e0818e1dfa7b13600fd3d9df7928dcc7fc2e956748b7e134e5e63b73489932a574de429d30c856f4dc9559b3c47a08af36cde96de3c7a60e5601befef3dea6a7da8c45b0c4d8a303556bb8193d958a98a746c96044527ee4ede42abca8c41315cfcae0be5dcdd3c77a5de62ea17a4147a7839945ea5f51c8b4392cc1b001556ee44151a16aae67bbb2cf5270e841b6219c0662aa0371adfa51036fe704d365663a4f0badf8bde1eb02480636a2678461c6c8f3446585484e221b4ce1cd17d0fd6662c349f94388bc459cfe273b20d0df2974747729b3136c2b2858c98c18829459a24819e58c12ebc2b5a23d21f8d456016307f6a231ffde5375449d57fa76ecffe8efb65a602a65ac5401d2bc5576ba75a0375f9f792010cc9449d8a676bc69168de59c8f414b245e57fa3569731030bd3d251d64f3f371075a2fd475da8872d11a97ad8164ac6a9267c5c2f671548bc864e95dd20b12a06a1970c1b5408d4b0dec6981356aba37c035061fbfa91b3d98d4e5685cebba95bc4bb0c095bc9e1ef209c3d0f04a8378db4528abf299fd3ba807006b614e7f5132e2f2d4cdc995605153aa07f3f2b26a71f1b4ebc91d9478714aa156a26d32ac9e83772d15d838be79491862b9a3b88722c83ee609a4683068d0b6f1f14732765537269836e1558b3d7ddc73b7cdcdb53ac7788cee8fcaaca06de01ae9ab346ab9a7d0921577707dccc9e2b15330eeb8bffbd06150b3e908f0e58639a83c6fd570f388e6b8d2254944c77d51de08174fff6bea7937d1028f9c5296d30748efb07e5888568820a6000d125bbff5b79bee0a1bfd7c0106891a03f16c6a4df104d46ff63cec95e72c768912df783f0e85344278345d392558c4fd75b1147c3fb1338a5e2f3548a3f34d1df40d352ccea7983018302a505a80d99f4d91fb296bc8c3c055250443b5fb917d376854c0f610f6c07b8324b064f949b2274bcbb2d04bea1cc052dc7418be03734e5385b26df7e85ac588dbe4efb4701452c878004851d6bc791112e834b24ff6dc09a1a6a2f3abbf9348996105f7df3ac0e3cef20398f2aeaa38c5d94028336d2065ba9dbb5177ea52a939adcdda870bfe7f887f90069ac7107891505ef53be17effbdcc928f89e62851536bc245354e0a5a33213bae0a2457a19865c096d37975b89c2cf237335635e630ca7e35cf7f5481e5279d340882332d7d36959ab8bb7afb08fa8b3d0e0768af5338169b9962dbd9ad3e9895a9c6ff718488b79124a5d1188785d3cca08d5699845322d7e6b4eca02b9cfd83661f526e59e61d5370a7bc42cc0a58867a75ad2973705eaa202d52e09929db348073bff1937fb97c9bf2e994a3dc8a79d86122b967d2b18053137df8ad6af82b7eeb048e9922e0d487817fc92368678cc745934dc7d8ac2f6656e1afde550935e6c65ca2c40ee23944309bc5221bb6a0ab37237cce089bfee280dd932ad9e1882c71fafca5ab87caa0b86f8bdbec4273c0c1a22cfc7cc86ff289442b331af317be45f0e7c5703bdc5c25ec8eed1e7a4ca90278c048dcbf2ad6d6f249967f1e2122f623760ee16086980c2b0a45f97f04434c5795f3704a5f3703fa6b4799c2055eb80bf70eea9276dbe57b54bc3a3cb81c9ead84676f616f98a2ab7a39e930db0b1778366f2731157350a683c92206821c777114c95338223e5a29cb1d644919bf5209add7dc5b37aad93f3b004f895cfb7f27b4de44beb6e271925706e353840c8becd0d703944ab89e809818e5bd44fd5cea5a450da9799a5e28d3b0ff7cfa145906d3c96c33efe8cdd41dac2769ef8c7a478434adc231ac122bf081efb36d05247941e93be119521d0b50360c18473db79a495b3fd06f24955be09b18be39a1411539dd8e92290f13ed23309c5aa3e033b36c3c62f8d9c3d04e8418823a353d3b4455c8d897c763b479b447c6f19d46339e549c961c931bb07c9914208db4e5ee4262582bada88b330c29f1e79918cc5a536ed1ca6734dcbf193becfe09f0645524df9bb09ffce4c958731365851d2395800e3c1ead39a54fd6b14759ee47307b536da06e895037a49c2ad9085347cca3489908294c0895ead3c90f8f520b35794b6319188aa630420444fde4b3170e6a6694f8157880a1585a73ee8bd4b787ff9f702ed00dc7a873a0676510ef26ea5b028c3a169db9972c0a60ccdf21b623ff57e34e912d9f1852ebbabdec57596a5260033be09a922c160b2cbab1b25601681618bb611f30ee3e3053308d13e7448871bb6883b2d6bb1dd4eaccb0eb2b214fdf1cc83595629fcbda58d282763278450164f460897d5d16ae60ed3914ed00ddaeff7a87fda6e54f6bf4c76e5ba72e4fe3c4dbc56a008e32ebed3f9a282567eeb9a961747c39a1f9e3a536cb5d251e7dc584b0dc954617e23841c778c9b346e561297abcb346c88140b7c1f231fd472a134b8cef89d2da28e1487c38186ed3ae8667b5a8a886adb80c5eadde1126b3eefb0f1c5caee8f6b0eb4e7a90fc5059ccd2c25dbc26dd7a26af3f692699964cedc13c6e4757db5116073332cba73ffe015c814788c35d7a6fd7a82a4cf178475b829eafc21f9b327903cc77b3ac9b44b9e573d90c1ba1621de5b58aa4f20b957240163a2794ffa60a2c5698cd5693ff930eff214fa5fa881b4fd2ee50603c8986242cc7bb12a3547cb803024c2877326595ed4b8bde3f88bd26815bfff35afc6ade293363fb899091bea5ae45978f860998325c162d858d96fb251ec4b3e867f0c7609a4e5b20dbf37e853843841b033b0f20bc2217ea791f086969b4ccbf89ee6776e5bc8373123ea87ae4d6f9787717087a58443b2bf9694399d991e90a7441dcc454318b3d86561c9cbc106435779b50a4489d81bf38e942963c59a89907be5a8a25d446ac012a823817da1b7bea33681570007de472c1527c2e8ded98cc7d9dc24180cf2300b0604057baee7c84f6e4f717cf625ea6cb8576065858dc8dfd9399cfdc760fad18ab3cd76e63e1ed9f941086a796feb48db24fa385c94b1f1b69d4631f9317092b4a42ecfb0546c8a592e63f63822f02eca8748a5ae43814ff02d0e050e109afa69e4924c3956930ee76495998cc7ca8c114652366514cd6271e662d5f57e2f52bb1f7395d910515851f5fd276ea81c8ecd0ae1599b1f7fde09dc457a970e23782684bd62b29f8cb837ffefb58ed336d77bdaf8b5c39c88dfad24eef7432c996af1bdc798b6b4fb62af66083252aff51fd1718be49b0ab6fbaafdacc1b05caef0cf9d626a4bd26127e4b7a9f6807237afacd0ea586775644936508292dccfd2854e3e791d6e653ed28f30b0b2f6efdb2692b223c10b4526f8e9b20dfc7c3b832a0ee92ac8e0e988f75b784e557afa030b842cb5f2adc2f41e3a19e825a6a182635c7de0366f89a8b026bfa5cfad3e8c5bf2e5174e390e34c91f111fe80d64dceab8353b5ba377e068ed4dae1bd575266c9c505105e865799aff754ad81909dc47fde623ebf4dcb63f804bff7fba84c9d74b38168066c065316a33143cd013186e7ebefd2ae9dea4778dff583ded711f3b9f2f54c9333de1ddf8cb960f81d244d58b5f342f0d21fd7619d129f067240e105fd2e89f7e4d4b18fa5bc575e44f849d99a50a917ccc57eaed56547f6fd4c78ceec4a44bdef1943320e3058e3df02148259c3f36b21cf686ded810f8bd187d0b5d493dd0201238b16e5f133cab5eeccee76dcff8f2efc6a8f9104ead713f9ef884417ea9536a5a88d68706c906c25da6ee58af6d48e3899a90be00c159c3b34441288f0478911b5cfbb81e2eca8424bc7dcdcd88f353b8affc3fff6a1827c3646cfda40d687aab754fd0cb64b3e7f67527d5dcbc22765cd9111a8a7adf0bb1f87cc62bda0d62466ee53a274664c99c300d26e068e601ed9541515c64f11a4cfad41947ec17b5c9c65d38ba4b702784c68641e1784b61176ab6aef0b949e9009e76673d571b72e56a7fce69826a028f61e4c081b2ce9c72735622e911c417bef67d460bf2d3dd0e21fdf48c68da75146e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
