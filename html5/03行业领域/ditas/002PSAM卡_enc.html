<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abc51d0414ea1508c6da28e48a073d0c2702ac0b28238bbc825e64064b5d106145091734a257217d9b581dcd4fe9f80d9c249649a18ff443bf8b88ce5e3642f2742f9349ae9c43037a53ffe88f52666da8432c0fe2f300149f3532983d29e4c0c341a457ac8fa5b5380ee5c9a516b4d7864d37f5260f69fb2e9ed40aedd1eda9155dd9f315e2532aa893eeb5f03b8bda903a56c529a200eb1621a9f3bd01281721234db54523d1504fbbab70df90646d0a219bf5e2aaad009992efcd5ad7193da52b6f8b9ff5bce1faffa5994c024e209834d19af001a93ef9630f148b3d3cffbdf299ff365184a6c10b8a0c632a0ccd7946ecc82bc6668ebb55fa2213d8165f25dba6b01f2e352aaa9afae5e1a23dd07e5a2b37f52a7d2326547cfbe30bab70dc622ce5b4425f94fdd0dbf6086858015f18c0f71ab1f594e9a97812f2f73513996ee5be47cee064e5f49264a4f97c6fdb0e799bcb02f3e76bd7e7106d4c46ce8202f841139aa97bfa0856509e9abe8ea6fde6f80e721a34a21165348935a40bd4b32533023c3cb92d7403d653db08625e732198482fc34d2c079b4ff8832c7bf81374915d485883813cc20c71146a9aa93f70c53b92a331d885d89900686949b9d934e6459914aca7cd511c1c1a0d673f1ebff7908740b5ccb4090afd15663bcea728bdcbd653ea358346629980b03002df07fec3e9f1cbd1eddf839903991ff5fafd369900618453a9dd78dbb5498bafcf5ed299133fc1769ba047f7a4a40906bc793a8920277b6b7d1377cd1a5249aebf47e6b739951bfb14527d519ae633f7e2c76a47bceff8cfbaeb052b1eb25ace4bc5b9c6c579e73e1b4f4abf02ef52b1bb005f715e83cff5a8713d228426eade28290cd87de7ee345b692ba668dd07b0d32df1ed6146d0c23412984b7dc69e2273ee1d2422d0264d9b3ce5788a63ac518765851f5c6edfe23dcb2c4a2a8d78ed7ef79d1fe7b816d4ad6b7c45d51bbb0133d5dcc751577a14a5c572c4086d17f18599a8a21b7ebfc223cc481cce6f8b5225b061b971106fb5dfd16858ee3eadf58d649d9e268c6bd2ca598a768aeaa3055da629ebd83d84aa5272e68e9a22023e65b348e3629346095558e52dd14369a216d0e6787b8851728ff0297986f2e6d732b1ad83273b47a2ae4c70d043e2d599ba89059ed584a9ff568a88169b79115a32106a7f49ced12465a862c6e7acd4c6d94d5b4165608ccbf596b49ac6945fa5cc38e61395506a4113f1d720b1b211248978f7a4c294724ded16b217123630ee21b23d42141957dcfae20d85c7e38a1490325e60417d65d0ce5ab0375ff3eddb7970cb87180c14ed96b9fbc93a0ecd519ccd0c6c9eb26d97b319a3a2941e8cab5a4e1af21e871b9a99d6d32b00f031d4d60ca1b900d8188c042bd70e30988427cb15e123e904101961b1a98ec92fc9fafab3a6edae141520e4eccf4dcf5ec16958ff3043d1b2e848d23ca3cc6a62dff3aa7b552264e62896a7db8a8f55d3593116da4150fb9f3c15d8f58b1a785dc970e38e4eeacd5e2b461c9b49f58099fe3fa049cdf49b650e345b91d4e51dfb0c5580288e937f3ec0b2659807c420fd20d09818b69f37e8ecb563bd303dd0cfa4f036b15a5010d0753d8ea996be1b3827310a22a86078beabfb430b61fa55962e573a5902c2c36df129f66768c043d3a9e6c90cce90846b8dc9a2db2006e0e233f7d6acb26340b63aa4e24cbf2c8d440493d0221623f66717f76e1f9a003b6d24d61f97cbe525bed8b84b085a11e6ac7bb539b63b727abf5d2d1401a85baf0cd0518714c7e31e184fe5ab6a7f994a52c531da42ee57a74ab60e925c8673dbe46bc8759e7df09c97c52ca0f6e510a570451f29da77252291dda1a8cca03f20227516dcbbbd2d6347f1193b0180cd32a2813d052309dbbfa2aad24fddc55fbfa28b9771ae38f40f0d0a04a8a0bfe6449ecda2b06b9a03d17e7236672985b67a7d13438ed976e2bce3c96aa8922b58e75cd2f10f7932aa0ca6f3e0d9bf4654b7ec778c27483968f00103323fb8346ab4ced2d4568cc633146122721253a1b312eef4704885ab6ff2481860d07fcfb7d7da527609809192749e5be7422c91627244c4f7f98b751e0a357b51d810e5fab3b031f93021c3d851173ff8dd9af868d61bb97fb3ef56d6182b7250e11d1e6b39579c828b67ba6209e55b27d052e6bbd13429c7706138a07edc0c57bf32e94783dcd4d28182f9c552f33c5e8fa7ab577bfe36f23fcd716e89f6365a683bb85d7e023e269c729578ee91f3a4064edee092df4ff29640a6c34efee155b1e254a417f2c2dfd4e52888bbf1a76019dfc02f5f3f39a9816bf981a03c656dbf01820244eeb5e4099a451b36b07a5a229213e57d705ffea9cdaa3691520826634f04b336add9c137910e8c7926c12adf32c87b1bb3322b015e9fc9709ad8c704d58df5bef4cf98a36714f47658949607d256789a5035baea91aece1ead283d5b7e121d21147bf6279f4964f60e51e53cca9346ba363c63698d6a7f75e191d99ce668af0c99ab5afa418a57134574f988052a8074c7ace32fa74e31da79ed3009065e72658b9bd21fc71feb21126b27a54ffa980b8266d3da563c0edf86eac69345c41205e06f4e9fb11dc6231761c3aa7f5388c1f15e2d5bc792426bc9aec76e58e0dcd6750b58e950feec5e62ff24b5ab31dc342950fcc2a0c4709924e932073301d665161c5ad54ea598467b32b05b102ac6f9be5dc86782dd282c31ff97fef53963078f4cf2aa5f268821f1f0bf2296fe934c9fbbe81bdd228c5c1ade534a357ca43cb609d3c73534c7308d85f6b65cc57d7d98b1a86d1faa9a10eea38f49e5db121ce15c5ddf3f7f0785da6172e341f25f75c08e8127454a48a53a36bcda0e8209c0c8b3e0e1ee4bf9d9b753687448269a78563e27edf2a9a1063340b697c74e7c14b53738247fc8157db7b4944afe3e22743a703901de2e8e46ed199a38e28dc98ac7298f9af2aabd9d3829e0cf46534f115a3f4dd95d59b182c1100735f08ba8921a35044a788a4d91a9b352779dddc1e433728d98b44c90afa591748ff1dbba6c9b484a56ae435c2b3da71c22b7b08895e7b15554ec5c7e4fdc9833ad5c52e068dde9737d45352ddba0e6d263386815287a7ac4b20d345efbebc112b40469103c7e48610de06fa2a18be6d6c99f8aaa104f6820e64770c77b4c662a43e1f1d47f62caad731a8a2f25aa6458fa42b1474f7cbfde5654f0df2169847b36d428cb4bb6415f09c4e4534c835e17a5bb15663e4d65e2be54b21f6e138b9d8597cd3ec0248f216fae264bc02f6b6cc0d30b19360768933cf88ce5c5500aafc2d93829e8ac8466cc7e94be768bbd3806db919dd3a35c2326548b0c3db0d46b218e0420f537b6cc4674b0bfb5517e20c32462322b04708b06546165099a68bafc780ab9654fdfb149db4bf7baa379598d1587bf22b53babce249b7bf27b67db9282f8aa4dc822f462a3249e8fbd873200bbd23b4160f2ad235d54421c2a246d2f40856d98ec6da6107e1d01650dc01879c6ee696be4ebe4e509e3a76434b9a576d44361aaf16c86f8d8780f96dfe8425ccff320d33da3a74a4c7bde6ad1bac7ab6cd9f5cfe04ed44a9646298264999d5fb011336d922e5cbf75216b335ffee8bc59bc5d524af21794f3c5961f4039cf2f7ddb962eede71799589c779f3b07fd51427524a464f4f93488d03f921a9fddba103dc5b4fa44ad8d24586921d2fee9d018d967d146b10ef662807481a21afa2ee713c7b480983b7289f9a76ff981a5ed93beea26bcdfabb554719356e26bcf510ce7625208dcab5fb4cf014c0341a7d51102662826a8d6db910b719d0c2af946bd5e8f28ea30ffc826f637abe1745411dfeca4de2c61b0c44c305c0a139cb40b2e2fdab92fd9366fcbac9eb04eeca5f2e86073720e29c92be8c98c3558db16c4fb3a52687052ebcb3d003a092426b911b7d46ac5cc44f928a80e9f728bc59858d4e7a088f1113338756a2488e2a38bd7b656878e2c096d46888c409878f29fefc19ebaf3088c39ee4fe0562b4fe2d788b099cc0650db87b949689c4de80e567398c5f93ec3aee807fa3ab1a59beb1c29b49cdfc584876a63c34b4e661508b948648d85b406f34d9c8df585dc5d603a396947a1c736e2a7bb617477f4a20c1e353e53ef6ea8abc53987294f84c2b48c8132214990247250c2abc183bf0794dff16cad8195767e3bc36de787af6e972617ee946cc279fa1bdeba3aedb7327791e5a6991ef674813748711489e425383e33fc293686a88a6df2c2a521b5fb1a44d25f65ec6c1fee61f910279ffbdb9c869673c539b9002dbba09b17e0b2e195e249118c5673ed3f33bd54f1f75a45efe1840bb4825e65cbbad3092a15f4fbed01d1f9ad508268e3e34a010930241de8b506a0c9377c297b85c3f3acfa458e03cedfad60c8b55f95b773c3cde1918f9dd64f60948c9bca23142349afcfcddb8a1e6c93a589777a3e67882d651935bcf140ff8c1b84dadc6e55e4fe1ebf0491778a29ba06d0a595bf58b3f25911e2c14c42dfca712aaaac8acae81d21a3f1e4e6f6b5746b4e6bdf7ab698376820f7f610616f44ef741c46e477bf00af8c4105a205eaff4adecfb2fe8383e2284975df4de5f65a68789de6ad5a2a122c87810f02bfd9521be9a7b984ded5728070a138e397f1c359d1cb609736c8da6cd7be79efac051d544b7dc74f1b990d0c5a4460c04a6d7a6812ab0ead11a2de1c84750a996f4b4b687d5339cc627390cd42395bd703e37c0dc8b62fd6c6a6a443c1bb9ba1e15b7a0ba7778234f4b0a30888cc1a39a701cc058edfc46e045c5fb361934060a7a0e08044e76b615f5911ea03d7b60dc12db0a06e665708f9d4557ae82ea221449ea7017fde53af82f5810a707d68c13d6431dd783682a33af7062bed1e5b1e9ffe8a570ac6d478fc635013dc7100c0464a446ad4fd8b980a2d5d1b94fb76bfc30aa7829ce7403b83340442f36f13df813eca27071d12c80fac5a2354642c510df494b5c4f0691e51ee86444e1995d141a2347d4b6fbfb79eda48bd052c8adede56fe433b48e195bcd428723c70a0fa76f409b7f4e607e769ea09bb9f0c19e41bb01324ad700caee6567ffbe503283b8d5bf1ceb6322a980a76a88f4c7a5d3225db4db911a952b53075f96584eb1b1dfb96676ca0e9048f744ac4c87b0c43d602ae2b9dddbdbbf39902c3b68f9143d13fe4b1156fc37dea29c811ccfb5792cb72667021d443b4bd812be60566ccd1186604439b03857e492298db3f6f3387ba8aa8d2d5125e616e8ce3a718ed4de532e101573792473cb0d7f4175728a6eb827f4f887dda5946c36a96f3d2e577d7d4b84fe72dd0bfc54ba101a0b6b386ce835f07ed93c1668491b4c6e921d09bc1ffdc26150e7df4a78f4060030dcfb46baeb3a49ea8ae20fe4aafb39c1f826f5f0c5f4fa1528c173c6f157b143ee62548899de4dd2f29c0cc61ea3373acd987d5c7f73a260b9413ef4026d248739cbfccb1b48a8d78adae70c102ed75e4fe46ca93bad872ae8c7bac828c4acf2c0f50227a57d1ed3c2e041fae1f2320f6574047c125f48c56b4e31d95ed6d929016a7d9d9fa496ea3f05625732b72a846dad762578728b8f624faa7659dc3589b4a8b7fbde429ad5fb1ac9be1d1f0b232807c61333adc01bb1d330ca737941c6f2cfae788066d76d470d7594fc15259aa0a7e05bf06c9108a59b0799ab2c10d9ba5601ab6443d9f8b13d6078093203e4b20791b4e77e412759c2c2948ec4365af0d268447a10e67582a73faabf391cbeff4da2cce06e20196ea159cd6830585c8988666ef3eaacfacb372b7af6d3b6c59f327189def2642035931719c9a060370d99bc9afe75620c01c120975d0890964d7c7df0c78429a405fa2a78dab33b7e1b673fe8d9ff9cc1eb0bcb11c671bd226ba4701799c7980dd66429179ec4a8e4f62fd4a3965d3bc785b4c6be5a1bd4eda0db3969399e28a91a0768442db60940243dc07a3625d00be46a1fb4da91731c6c4a126b6958bc0d90d1ffd08bb5ac2b2833721fb47245527255bedcb94c128e7f8f332e4b41288a6642fdf8bb6d20501a79780138113bdaa4bd05013b32a439b1b8d61d9116800834cac2bcc1a36307e66869a059640338209105c908b6aa5a81adbe5c61c218457df09cddcc29bae5b736faa538b8ba008481b399c343bd211c58436e921b385de100b598f609c15bb0f220a5db4ad3b41f55d47d805e289b2671672adfb3dbf03d791de8e72b3af047668f7c09d1d4a180b20a5f78b458a25e9066fa7b4fb5e873bbfe88e205601cc76d8d7c5766cc9a3128c5c16d9454a0d97a7a25ed8dfcf9944073c488b6e01572317454b95c3fb9a4ac1af4c05e3add7755fe2896eec93dbb0293e9cdd803042e9d37b2653654c0e6d827fa022251b9a77dfc977ad12a8f61df1595cfbd7551f3d7edb6d3c4341c710ae32770d3bae2d3904b99d45d123cb6e35085a37666155ef2fc8a96d98373eda608d300156c07ead71600607ab6668b0aa13dddca3e3f2eabe1345c6ade7516babe7698a6ffa196da3a36a8be475dca83c5ac26669bb8433b00eb01bebdbf0c8d0c4d2a48ebd6a05a6acbe8aa23476817045b582b5acc4fa34b64221b3e618069cdbb391eafddc2b8780e89823e99de11300e11901ff157eb4092116aa9e69d1cdb68a8a77e2394a70283c4fa7382e8547f9ea45aa0600c3b45ec9f98ce0cd7b832ae26e2e8d5422446e0f8b9c7fe41958f13b317b571b2ddfef3bd32636955eb5fc86136edbff25b0fe40683d1c3eceea22f364fb0c0532e4ccf1ed9f57517b9ced3dab404260e773ebd70acb5e7d9a93ddc07044d162f6279689f80ee5483be5b41662cb2ea930c75ad74f4c7b6e947d56724bf1c316644cd2bceca1a06582da95bc0e1ecff1b484ef0933ce1be23d0171a9fecc93bea9c3298b0ef951ec7fd7ce50192362546c626c422ed1830de0f9be24778bcc82ce83db68327f6866aed79e23f9bca68b71b2ffc07b463f41f598d08e858c5e576d113bf1b47ab9b810eee5a521a2a4fa09a609727c67c3fb3e149eae0f9cc41acd607e12155cedde3602dc6d28af51391c4f9fbeba232ab1a92800d372a9ca8d46464897b5225e121770e52de2498155d80e4e30b615c4357f871e32664fa2aff3a3d7f5d033332bf73f1cea41583a2223c08e3daab15dbb2f680aea9ef96fa8ba80d6f088e2a7cc7d64925a13980de5b47c462ca4994706019d65f528387f05501240d301df247cc6fdd019ee7714b7f9e4a7ad5555d3d971b1970ee6c89c4955cff2a239441bba645c2d53e64b6bf2ab33abf8d75a9aa4d07dfab85483411fe4b01672685c11d630a18b84e95b7f67fe006c1bef48bd90a9cc576ca5e99fb13a9d902a8ab6dae03b25bc2cf1e54efea800f144081b2c76e053f143c578d8179765454b2173a596be5a1eda0f6f8031368027fc19d9461432f01b3c35f1a22814c9e55a57c93860fa1893153a983807ed150b946210e2b781f823e45faf1a121095edbdc6cdef2230b1f509327c00b063a0a7de32e5aa8b234d4fa5076e63d7da98a382982377038b418756788b94923686968d02649060697280bd65896db98f9d02492d6eb2ffad1cd48dc2a4cdbccbfa031292ed6c3f4a66da8295792e764778a8cd182c7372452676b94ac879b27ef798f4ac1ba2478e35d1b24382f38c0aea3c3d78e1fe3fd1ce5e730e1caaa3b0279c76beb8837cf37ec8cf6e0711b56fe0351657ab47a165d07c8ec91b9a5c94f930e869ca408e8cf18de707affa149a0f209b6f29249fdee6c45a8be690f56935ef21ff8f1a6088d4765010401d8429a58f8fa3485f1b3026c063abe5b7d8dfa1b023a7fe060610c4bbd776480cbe7815d795ef3585b69de4479e2b74c5aadcc722f45d24f18b33bc174545d5995663b2f1666c4e6c7180c0e9ae21e8c2ca960123a240ac4c7a7f7444a8bccda3fea075fe40a9dabc5182959146749625db58fe1509b2e6ed922cdc484c891ad51531bf2bc286293e60cfcc937fa353bc96cc95f7fae706fc7543df2f0ed14592176213c1f5f503494e17091accceb60f82c6f97d97e9cd8e3f4b77122bbf81e89759e925a50d113f2423630da8440ff1694fbff055eca87e106552ce5fb8d59307494b1a18095c216327ba97bd58143899a6b4f4590152830f0f6b3d05d080bd5c3c5033699ad6ed759afd8c6deefabed71adb8e2f7744828302d8dc820c4b57dbd3a652f2fe97440d1d32add56247866fb2f48a3e80d9bd7a8e7ea522fcc6b864c7b62078bf1cdc4520aa87ea8c9b98484ab2b0e5c349afe60aa876e006c382fd84557b643e505f73ccd6715549058daa68a4b508d7e428385f8d63db85bcf508298fc41dbb3339afcdbb178a28ce1ff43450a9b4c915f7dec9eef684ee46b0f515efc4c5a2e8e0b917f4b653b8ad0327ea903076da2a59c621f71e8176d32345318f21daba1d0a72cd7b2ac19b83c5b45bc0e25739459488cb6659c831786d269026b378218bac8e36a3cc24090b08f4bbcb63db714b7c0ac7941f9d1700dba8ac9b1490f7bd6b638f76a3d5627ced128c441fb26b1ba1c02c7ed1384e48d3628f8e39dd8b3c4b4548e6e1639c4f7f621a0defef1c3389494804bdace6dc27707ca6faa0c99a27230db04aedceb3d92b4df4afd7507beb569029766a719d47b91529a35dbff8cd051f8efdce6985049345a254b6215d06c1ec61cd4c98bc20f2346fbd56c4344edf994c94fc7a37e65595bbacc0b6e5854c6e55ac6d13b4fd7518e93d808e85c7a4be12813b6ae20af560cec23c8d9b94a493556fe10e045e45114f6090884fbc835536cfc862f751f0519ed74fb371c51555f596b198e215bd007988ea74c75a1f3d865e6825a41af6e7fb7d538450fc0006e29dfa96737e2d5c1046c7f088bb94dab9c28a07699749c9d181a4908db632e145672bbf620c617e3864d909a750ef192cb7bad0580e4dc30a72776f72c7a0d8a951e20b97f1b13ad67e6ae7edb86abe6c27e02b2d5979237e0c81e162249ec38b1b253f09445d0d4687132a9799a3ea8b8e01084b505350a769edce18eff1df3e0ca54b1aa840ad518a1c431e1f3781f3ad3c2a91c0bc1c1f8597485208b274ee3d79b17e96051dfe105f0641812d1100e104","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
