<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f886599423d501f1a226bdb42d7ecd8bc9ed959f6f59d3d922a2f389b8ebf4f85ebf5a99a4ea7b3074d9985bf660a75a62efbca4eba73a8f8bd2b15e7578842c029e3f9c95848bbd603eac2111bba3e9111a3b1f524811225c2751449e40226017c2482ef9b8842c37e764b52fc893dae596f68610f8d082f20aa64caf3d7fd58b19bf58f2839a149a20b42943d63dbc07b216c3110d2a815d4791205e3451fcaeebe852fb092b9b0d6e23efc07754352bf521b8082021b8415817869db1ef32c57b749bd3362d3a9e50621caa1bde18a748f56c3a5f43f44009e56582a774c35bacda30807985190bcd651610b8aa84a8cdd53cf941314d05473d88808baab27112c5b13b49087d583c9ee93ba7b7acad9f7fbaab55a595ab5d3818167fe4d866a751cabd6e219fc1f4c5e296fa5afbe1623c3ad936de6b32963707396bc5bba8fad5b2d40f52b6d06c9a327975326a5ec8973be446f55be160f4fe2e070c47bb7af9cfcc56b284095264ded82b20a0b58d9a92885a59e84bbdae350ba099b5295cbf2c6cd46ccbde1e21c911211aeb9a2cda16caad657492cdd4af4bd7b14b337ce094f9be044165808ee3545f116c5cbe7a21c1f247c7112db6728872d72454d92bc1a6bd9f87b284d712fb80d85821bfe95eff5ee999bf92ca11a19ff9e4fb56ad8fef7f2353c1371d4c23736f8419eb29f6a783fde2781dfdb6e73af789d7e06b01ac0ba070cf0f1e3bd02a991aa4f1642a7e6b87b7744d8ec0be6f83485dea0558942379ef7f1145d2cfedce1522c1b06d9a7cdd66d38680e89baa8806546d1dc3154b03232bcb731d8d27e61a35e3ed64da43d6f3788c47c1ae494d0866e3760058b80c34c1f39f0ffb764528a72a59b439756c444cc65b63d6a6bae72809c9f8333f106f9eac51913a8126939c095cf1990043a8d63120804464542394467aaf13718fe177e410225c0401fdaa2f3e850d6daeac3550df942ced8820a92a8e927a36f1478ed7bd636f4537b6dad10ca4f3e592a4d181dad5276477f6b61397200ea1c1b873a4342f71bcd6955bec44da6e271d51caca3a2c9819a7086db3dfa361f6ef9f4556b35d0f68a0ba628ca1d1dddebfea7f05d5f4edc916efd08522b2d3f68bba7f9c6036feb04ae0e6c2d680cde789529238177f44a3be4443edba2d161f005a554785694a3d6e2784576bd3a138eb3e6547b8afa5a4b50cfa4038625cb1390a80937e608b47fc6abbc7fb682234e1edd6221e0ac4418bcd0f6cfa174a22d0ba74f005d7d6a59f4bc63dc305129999ff718009ef00f85724e816c087c6a0768ee0392a3cd34179320b0d4a865f51611d1afed0583a23c26f67a731434752722b5ef1cb852f779cd2bf753017d5cf669e43eb824a514b81b5f26d5062cc736045a4cddbac13b373591b0f3dffcfadfb1bf2b20ea15cb0f042e1ebf8b26b6673df6bff0803811d033bf2beba9dcec295a162a9d6014c7a3a6c33597b52272354d87c8ef7855e303710d4e709faf4ba5ed8a49d1e92568f5e2134b980a4ae837bc0149705f25a3ad35d72871a3c7b0ae305fba6e6c047c989d828c809027adaf2160259dd1d0bbddfeb7f978198253bec9d7212b8e0f8809258f0429ad8b8410099b1068da25d1f4d6c5d22141c0822b5396aedfcccd932ee16278e3859ace7b19436298b29bc45fe8891ac7b2e1f78caa155740e4913b8548c41b305c8a7275ee953498e0e88a32008791ce3dada846f7fb6c27a061556360914dca0cb543007af25132eed0a4c6f928617427701ebf28db26d577292d7d8bf53b215cbcf90a7ce471c44a372543b1936f04cf1cc70b2e80c2de5e454cc97fc50ff5b008fd6e4f2764fb3b5c6f615b6cbff638881c9d7a6d03de398a6ecf7389ebe8aeb1d7d5818bfadb5734e0ad02c0f6ae677a46a999c33722667cde03652af5d9e066bed5c1be68107566a4dd06e54ec609bf77f586e4a3dce65d64f1cccf1af0982d81c6d750be326fd625e611a2f7b04f6cdc8f9547981801ddb2b3dcdc0ba4a8ad35df0c4e766fd6c48c3a207f375399b0a9081fec6cdf3fb8638c377358dd0aaa8e039a101bb21b3e6015cddde42d7b9e419c52f63ba6c5164dfc457883658cd1b564ae36e0395fd28c7191dcdfac626086cf44b67ee5bfca4304c23c7ab4767ec9db92c547f0fd18d175a6ea36e7da1a83fa8b6b5f886245f27f742c71638444a371bb0c57232ffe56dc909648b18bb5b7c737be7ce29bb1a19adb00df1db52ec8d8cf261d6344281e253ebe29887ef1a37a05dca8232d91dfc31aff27ce2ec7d5bfb9f6c515f7ddcecdcac92325d292bc7f79a4eb5a26d97d636f4fa075676afbdc0c27b79b5b692324a8d805ec10c5bed4dfc00536cab0e067904e073961c3fbcc35fd3161f7c8da4aaa5c49acbc54bffd9d777b5b1b558d777d695ca120691661c53f2e953581170946ccc98d692ae2e679cf7c2d6f1a53e565b51290a1f3e40b050f63e03df27bca2f566d5f72f2eb3d52dc970cfb223c50c58d58cf54ae3a65e41ccfc632a91ba64e366c67c88cd303e527e143c8966a1a9212ed06e98d1d839186dd6e094b6458705b2538c79016f8a4ceea0164832a16d8a98a8b382a3a126f6e5d07f4bd088fdefb7f95ed5eeec4ebd86e84e055e65baaeac2dd483d4667142e197823554a4e729f2592b3d921b57af8eabaca446d7c2aa82b061a110c35bf2ef46ff2ef5530e7cdc8efca27ff175fbd8428d08d921c635fb7081e98d22d3d6426c4f7cd75424c88cf144c985b8e65187367335285d641753685cbda5aedb02ed17e183cbdee2ff4d94103c9b991afb19fba32ac54af13a1168010bbf70137ae8c55acac74be82a07deefdcefee9d9b6075cb670fbe6a21552561774887c5f44fb7e850ee834a8d81ba62026705e62f98918e9bcb5d0474ebc0d9d2f25c42a45aa73053e5d5e50cf609d4663c1116a52ad2fff83b72b841cce8587aa06d4dbc07fea77f2cc02f1c066e73233c5d2ddababc97daaae69058ded9bba6a26a17901f25f479715d738588d25b5712983f02b36604c91567b28cfcc982c8c07f7fa3902212dd641b58641e99cc7a386e7598094c6db439fa1d5b0e7ed6c8329c44c234160045c57510f641870d9ac52c197cf9f1d26cc9e7b5d0159dfde1946ca47fb80f4b11700148cb0f1f348bbd3a20a6c4f30ccb8d91129be3a00b4e4d039548b3f12ed761fd09c8dff7911f697e11b32acf593156bc09a627af6c347a6ad6bce59575154642c03b01f6a476d4a4e686082191be3c46f9bb819df5d5b9d7f71c97166349d2691953644ab3a0ebca4e38827228543cafcc3694e5fca63ce942120e290e3afa7867d14fa2d61b3af41488569eb15917612c5182d287871552900ca88ad02b279c0060a5d5dcddbadbbd1384b9ccdd95663c4327f132ce5c2a66bdeae3dfe7c4faa0b0d0d374e419db00a3c387ca680a2c001fd4fcd5b4a688f18398558313b5de50ba292a17518fbd362d03b4417316c67276b15e3a5c37cbf8672afaeb29407f34075b705711b938146a01dd9a6be2531d3ef69bc3a0881ed901737ab6b38e320c9ead12ff88aed01206e5cc0fad353ddec17ef6d2cb0dd10348fcd7c6183ffe21ec3daefb19b1b0e2b7d01ae22c155ffa574387f02af1381d1b47d7cb56d5b729de27f5d761bc5c1af8c6c5f73f8cb7e0867cbaf2a8ea45ae5e0e1ec3670b3d5e226fe89f6c880c49eb42803ca41eb0c1dde811bbe16480bb6a4d01cdaa0da3d519d99c84210a26efc9b767f5f4edd311a82b8ef97d9cd08d83001bbc707a08bd9ff703dab4638a6d19e5d2f4fbbfa6eb0c018dc35c3c3f07c7ad256f7bda08efbbc1d7ea8d6c73f6b2d13328e092dc17a0dc0f2261d32ba52024ed5a19b7f3c5aa11b29f12dbe5dcad2ed5101eb7f7b79a039a8f0fe86ae8563320d60f529b1ec5125d963ae253b4493134b79e7119d9ae4da0a67a5d34688fa9033e2ab6eb6558093a8ff557a2f2ba0e2b8927b23b29ac5fb1a1b648274a965b46be02ef4be88f0cdc0a1517780c0a508d071b7eda4f37a815118b81756e5c9c081dfc2c71aca5d3daad32418a2a2d24d18460061087682c92d145e7b0cf6a407ccc22678fe4c414f485930488b0805c605d7389cdc394a48f47af648141987f1c2690cc149611085c6d7ca89b8d22a2e27759bb1375e1a11da2876ebd32ecf8fb13d6dc9be03ef32d536756adada1fa588811b41fd92e02a531b78ce2884585baf32550b5f281b88be5d8151495cf1cb1d720cb0bd68ce7d26a7635419d727c3393e22d9cf9875f01723ca87fe7c120b78594538bbcd7935d3de177cf96316db613904a34cf4e55812341f34f84c64fbfa31c0b4f77d34ece73b7511e9b0e3586bdc783430aa20635c56cd58c0ae16c1328cba6abe51745ea4486fa9745fc888c55c6fc2d58228ceda9635caea1e21f6f5df40a438b78042e00a7cab5088faa7964d4eed1a1e401c3efd247604d23e0c13b61bbb8f93adb539e41958a025d385cd3ac08fb07eb8161f7dfb849ca0408f724754b482a17c280141f7b6e1e59fd319275dd98dcea82246175148827a0d8d623f59ea29de8f553169c3450ce58669d9d7c101ef6335afa0340ca42f523b0915949ef64890cb8f61d92645adff54a9e37e24c210347d2af4c2734bf2f442aa1088daab7b82ebae1ff1f5ea788b3964e0f6e207077183db2f6fa1993a8bd08e1c6818c840bd056260b3f652f3a87a9b2a9afe44c2a1e2262dc2a71e2caedd4c124e86e274469ecf65954ebb3ecebd0b9e4107cee6677717d2c733c01c08b8dafb2d4cadce242b43287a0a71d87b97a0196ce65bd36eb91e1c46097b3df6f38c2f8a7da64bbb208707ead3e711b13e2b904701899abe4a304e445428cc2e36502ef5f05081bfba7fd5ec47d74e7a8abdd13ca2511b1535f0a16c85fcce27a1208d43a8796ad24c8ed94052b871dac0d9e53b51d4acfe7e97cf9c411caaee0d862c341209dc9ccfaeb7c3a1b6a8a2fed36d258062eb4c9add7828d9f6547556136f0cc10a6d3e9f8110551eb5e15033501438f601e99ea7916856dda37a86e20a3518e81a07d00659c6949ae995baf724fc086cbe4f58b427496340d8330397c0e491b65b12e8668789ace1a8d8d903212ba432e06951f7d758a078c12de5565fac7d32e9758d948f39364f623c77a268f37bf50dc2b02718a89bbf860a3fd684e1c3cdbcd27e255f765ed9334640c2517a54ad48fcd3c6f7cf3f4762d134aca9fb2e4b0bb78e6b576bd97e9b52a2ecd074139f90173a655c1416483bc1a3e8965283ad42fb223c78bad443b269641fa5a989439749629fc4ac77879eed74ef5fcfeffb579e2e5084b9a90f9af5d047044a2929ade125aac33e79da96876a9e5e63bf9eb02a0ef0cc342e82385ba50ae79dba3b1f1a1e6906f8d4acd98ab53b050daead352df7c25aecdca836a8cd489f3bee77fa15cd07dcb0e66c8836ab8118cc04d3dea7135c5425a4296f0dc96606446c4c63e432bea829b2810f525a842c17a69eb731e5172745f51e7e38c98ba6d0a92a85dff1df69369d8abe0a6cb5f4f4ff1877956e089fd80b33d9576c30c6f6e8d8ca2b05813a6abfeb6c029f99d1ac1a236bfb68b2b100a0edfd14cf9b9ce69dbf0995c1ac0d30cad9174ef854f23983edf9761243706b6178146cfe6259b96851a3a2bb26bf45bc7fa95f7b24e1e274348539ee10f60df13c4c94bcf1049ae8c55128a6d1d306ff4dc095ed010e9b1fc27b4400dba0e6561253bd3166595414ec3ed9891a1a8985bd121b27c8129fb99e20f5080e819711a385f9efbd6685aa7618987eead25c7152a0c5d7e2d1a17a471b640e57458b6755fdabf2bbb6afbcd20794de0915f60ae31aef98cab386dbf3cbe0fec3cbcd6b1dd079c50a59d8bcc150db81b7a0e2edde3f94dda4bfd7fb6161884410768be4a46d142658169906fe0bee2ebbc5adf0131d3c9d2e42fae9fcd0f6cb05babe7dde145641e3713c56890c4affc55b01a29778250380d90318309ad2e202719bf926839f24d059bf08b066625079a77281aca4efff2c0c3ab0097b364cf3b9a11d94989110ecdf773180f09bcb604ac236ca3521f5f8a2ed1e77a91a9d236f8f83c9dfcf1b2e2c203c73edb511bfdc091a165c021013c273bce806b7fb02bbb820af052213cba6d31fd59b524ec29f973e61464642742fad9c5f802a3bec996b92fe7793e16d8b34709e618ddd52d889304ecd12d4f38d1e96b7c0b9bd17be54ccbf78076c2c1aeb50b2c115b69f453b22fe9257a412e947bfbce873506cfe9c6a5548cba33b99265581e6015522f275aff5a0bed3d1f2e2c21e85b5145d3044f244bae09988cc7a10dcdd2e59bb3a1b5b580a2065d5d341e831df199473eebb96cf822d20453ff9777b4feb6d3e45e1ea039353281f512c85c0e29c292bb4cd5ff48da321284567040bf9cef55185d3aebaea5208d4b650adf52558ac626e282d18f7b14b2775063fe4fed80bd0673cab8a229386e43c269e8d1432936e11db8fc57010a1a1189e2ff2a3887565cf7740fbe69ad1170a92732a4ee0ba342570883030b2ad6c122832cbf40eaf6a37917bde1c6205bf95f8d9b2ba781da417a3e32c75e995299ca8fdd7fae0c293f62137b103f2ab44d0b7cacd076e2d01ffb24d1e61a1895452fe1e417e53c5ac23767f08864283f80617c996fb3089f347af4f22a13c8f0d522ad3cef8199521c5d1d0de2e1638e6a0af320b4373d5ccbaed7ab61b4e899ab8257fab185d1857d271e2b2b0634674d2ff7e62bb970a43062a13925b2783229c8da7f6bdb925db2663652f38abd3b0fbacf5574217a8ed0cb80f98cf46fcb9f7fcf5a0c0b5398ab48a87c14e776a0befdeccc39c70b44de8633704f986c8189ba3a2c6ac0ded5808c6eda9ed815cf3c79517c1d84e038530bc42e5335a9549cc65c55b14eef6dbbb784ad07347bda7f4a8bcfb9eca44bf0247a357f251f13d0c4731bc3ce1c9ef5bdafdfcfe21a5ff495ef4af7a052b39b4a347851fbc50cd79c6527edeffe0a8aacd14083cbb6bdcac9b811840e202df38c4867920ffde7532607b1947f1e83ec164783cf1b2bc04971fbe061754b7c990746daecdb55bb87667e92fd4ef6daf946c7720c0606a258863b3a050e122056df07815fdb8b611ee7ad4ca2e837c4a6e70248ae990dc80a55968e2671fe40e68fb1a172056eca03f441c16e2ec0dff5f3c66b24afe33024f130003b8ff24216429917ff0e84932c3bda006ea46ed11023820e786bbb730dec55e5ce89002d3ab29431cd322b97b91660ed3de2df95391c010ca6fd4c70fcc8d5dd8f5c2154986d6e5810042c166562f240080842316fc7b26471dafe6288ef8b4afa006abb98628971305fe50de9310c16e6f0789b17dd091837b3b9c8913b6d6886bf20868d6316b841272a11b6978d5ad4f2a3c0d9d355d5c504b898706961a70b14f9492121db4c40043c108b8358172cab02b86a464f40f0339a719dcdc89e67ac7434356e4748f3298867872537c33b946ae2e76ad08360fd603bc70a4c6f4ffd33bc9d114bf52e524af976d1bff5ae2fc07158c6e74948928ea2bb6e537ea352a75fb18607fb0d880e1a1314e7372d76cb395c323290550baff08fe1e4043bbda9d3f61468860b0e26183f89bb645e792a2df36381e24405a392fdaed0b8114a7098","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
