<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c23525fb5e36044fa9e440ab78c79550ee732662931069b2437f88e26681b6b5267b22a6f0e78a0e8959e3127f74a14bd652333ed4ca691a1a3f38a4cad6e52243462d9d26ed7893dd17160e70b4ae4b1a16b2c5e242a20b3be489e2dc0c24fffdf0192a9fdeaa856faf1d4e12d1fa7c233ad9decbc1d4cac0298590ae570b41ec8b4d063e8770d5faa2778db75e52eae1aaa849954bf5eb7829e7085fdb10778c4477c9cd5d3dda78d317a6ff44d45bc68ee746a137c5f352c0a4049ebb1ac59602321e55927a7b566cd6265c1dc9d21a94f9c76ba5529f8fbacd343331a920905f511f86b681b14da5e2fe16f836ec8071510cdd3ee68caf19d0371207a7240071a731b0688e11fc1e5738e1380da2254af6e8befd236d8e5cceb198e748ef76515f1471f651ba0386b82d18cab144baffcaebcde5ebf0336efa5e1529d765a38d978934d296d2a4ffa64225ecd4f239fcfe838e848f1a3a9f540c2343c5beccc39fde45cc10ed23f1e9a622d99cbdefb673a5b467e210e8b96f0dc66638feee6bad57084f7aedd83b9f8236758c17bfce3e592a36db8a883a8b358e3ae3099f0ce0178b219af8d163cc70f9642830c220b389ad767ca8bb1e1b2bca4896c536c7fa7e4fe07ed5d02db702b922a0fb393ffb25b43382b6d755d850f9c4f8f55a62c9fb1a162878b3755535635343f1c732fcebfca0ad6a9736532e0d300f5eb5348c16120fc2be4d75fc1e8134208070bed1e8cb8bf88b51ed95082f8b0329ada25936b0ea580233e3925b406a441cea06b4f47bb0879e8d0b1dd891adc9ceb87671b8cef317930c0105db8afb376e95180df909d73dfe52deb50c2084f5cd8a3612e74985d6285e8fc21214de8e8f7d2fb44c2ebbcb225d80592fd6fa580e16ffa95e6d277f44e245be093ad10f2fdfb514fe6daf4f1de32e0e3b9b52b676e857920035e65f175e60a1eb642115e36cc3aee0394085b37e421c2bc25b0d23acff377492545bd94cccd2e936e24d3083390692c0aa26fdf5723f44856e2411f7e7c57b26ea3ff9ed8793ab1ad3ac436ee41e573fe8ea8f963db43329b40d55d5c558ef8ca9d5e06bb3e154d34e361a07a02a796a4d08389bc62de3d803bf643fde1e3d80a73dfa14118f2cafe1cdddc063ff681bf5785d3f6c21394c82610949af4d5f00f59c0bbcbde2bc5b9d4bfd578f2ca046f018944c51e83f62450622d59f9fb7deea93184bcb7c62a9102c794c24a87851e40d924b6bc65e2aa496400a034904af8803f6fe71d6cb2316377bf7941ce6cfdc4484b13ad1a362569bf153e4b2f0cdccbc5ee6d300dfef618bb8c873050c4b809014c9373cca5d2bc24821cf9234f71501efe79654ca9eaa8c58ee01bd48e24cea05140cbd0c25c64714d114536d026d4a54601824a35f745ee1f3ce2bbd7de88f5f7de76f1e52429964efc9fa50c015d8900ce10ad2f3e7df61c7585160c51990c77f5b1ff8a7fd1c93a87dc63a498ca585d7bdd9da205c2882e91818bc58b2eee91ca576c1933db4f4594f4cf87ed84cbfeb0a4c41f362f13f376d6d8f64dfef4c186267bc87de74b868c1763ba786ce5136d384368d1fe6284de0f8a3ed64e6ac49799fe34b6f45d34161847d5645f538c2bbc64a90f89e506955ee9ea9f02d58d17581642f1562c9097af98487599e3d6c23ee17fb5b8e6630d88c110d4bfd1904134be7321a1c5fb6d7186e0b3a3de5af5b698f656b708700d78775f1945d843c66a9209e0bbd9006528ef3b2638d9539c0eb7dcf364b4034097d9ccd2351a56e68d05b4e57b935eedfbbd1c8524d14f138aa5bf829495485d47250ba04cdcc545dee4f8489e5df0898540bdee3579ce06555cdbc073f2feb531d93b96de2c0dd35e9af65c49686fec6e6d37e2105184c8fe07ad6b338db76e2cd13dce2bc303cce1126065fa310026855d6306d177ffb8ab42644573b7142a45f70f3d888624716dc1946c417d39807686ab3c49eeec675678ee7dcaf5dfcd978f9aa066dd95c54f4bfa1901816b45f3d797f625fbf3f5152c85e4130222fcbbc3bfe7c7b6d32417cde58e690e96d3c370587aedfff810ec9805d1f97203d511bcdc096e0e6170613dea508fc970c4f9c3071ddb292c7ae682b6e4ba67a79aff4addbd1cf56e0fb2f4a17c7642ed836596b14283be2540953ddb274e5df1f85947a69713cb666f0af5d99f3fd5844f5a98d0fdb32b12e9b6247719159d0168465a34fc61a28beb794863173339af850cc8c1e655d5b8bf90a736fcbe4b8b70918aa20274a2522cfeea218fbdb93112758c1190ab3a349e1caf61bb0f7c2527dd6bf2a555785f65fdb4374c756e290d538b4591652bcc31afdd47c2ceb877c0c7dd06b8786efff9dac76d6e64c076a63296ff7724b7d34d702a0bf2cee7a3362de552f88931d16ba0741f68eb15cb6300c78160e019f13420148b895a9e971687d9dd3c0b6d3f099bee337540afecc8a26401c28212742520f20a0bb1f090a3a8b45ccf8363982d811bfd4be36e3e6cbd52f61a3cfe465d649893917d71a6473ccb4e4bc5f7998ec855eadb4ada63ff4897af712d7ccf522e73fe6dd4ca936a0129faab20fe3d486a1427c6593f8dfc53b794dd7e62d0252b5afa0ad60865a450bb26a69b95432054e594ac7324376bb36a2bb8a742a6c2c047d59225134c95c99a23db0c556bf387aaddc2942fd1c70a2a24942d70ba43c162746cb6bda3ac2baa2ff859e5a101e34fd7786cc11912c14d8c8a68382f11aa5226c2f1c8508e240748ef482f8156b0e5d1ab246912bdbce6c2d3c70e5e889ff355e634dc6e18943b91ba194e5f96f3a19fffae59a35b9dd29e835cc22155124d52be115e9604f8625c0c2865ab912481133f5eb548046e65c54ffce9569b6f1e39b33662a70cfe2928b945918be4e3387ca758f9aa98047d91d6747916f7625cd0a6cf66e32bb99c42c7bcc5ded16f8647ba741c97cbe0399c27cb3c682147da8ba3a32b1bbc382cd91a3aa0b4f6da63aa2564885cf942263e99277af589959ca6bb5628e51e4e134cb80e140b25dc337d7dac46a7df048eb583a8673d8406871da17cc386dd3745aec9156b9ce23163ade8029a8d78df3d6d6dcf0135f25362892b9f9b8f0f30093e50bd16f491d8da90c397902f42eca7c56a2b4df2ee844d048ffd349736df50274064f29e1d1c0209a7a8d629edc3d11a71e2ec25b71ca59059b597d40994f803f4727df3f78a1d55c0bc227fc8dadb1d099800fce049f7d9a683150686ff6cd8a3f41ec8222ee58709e9c720226b104558e1c39a9318ee562a05c6fa8eb47db288e5a4c07a565796026f312404a6fb4a0c645dbe12a709536f31d0e573e846340d7123aeb2be54ace28b89f03b00950f4c4d93f60c4a6e99ad60088e7f38e740ae40d42979cce6edd9aca0a1dc132e0f0aad0b68c746fbb8146b03b24f4771902a52da0a1c8a68c82117c0a653b03d49ffe7c9c591cd5e811b815320d8356369e0e69fcbbfced37e9dfbd36343df9893af441d46d08978ee5ea634cddc21853b6179785edff4e450c435434b919a79de2b1a81e32a2ddfc74384efc3ec91b607133772a07772689d0005a627ef2b7881b08a38213aad1a3cecd435dc9af787ceda70f10064e96a34376f589fc240738018194861e090c5a9c05312081f59990da86c849eb1ccd8bc6f125dddad76144e2ea8ecffcc3dc9bc038dc4d5d555f9505e033c3db4f8f3e1d42fb3e074fb3c2211e02d840d1f9e59f774f4517a978ce8e316f45a0aad7ec39acffc8b76c889dfc246b8c427e70c174bc137c92fe892f840cf8fe57bf854d7443e6dfff9e756fab00a24718d1814f0fcef01ae93123a9711558662fe4d9830513ca4d4d9bb1c5e8b4bcf8080a840f5d64b28ab421d70929398e18d8bcb1cf29921d72ddf5d3bb765bc19065836969dd0fafd66402607d8b7f17a643ec0be7817050d97ba7d95aff1bfd29a1ab47414b32a750eb86fc42e2c37de00b3b2efd44d73a2a537072c3a8752a40a2d0b0ebc381dc2fd6f41b385bbc7b902479ba12dfa0d6e83badb7cb00df3edd86775aaf3d7cda761c1726709ce8c26399465d70abcf05d1ea5937c91b05262c74cc8d0e76fb376025e55a06d6a77a0686fec211699f96768cc7c4159b231109bcd5af0ffee6d190d614d0a42c5d189d643ef6d93d9fdc163ecd0f3292a14c644218e3fc53d9202d5535b8c78502e6be19f3777e7e8e674b7dc20452f8e979793b69c98aaed0d2a60d4b569ad06cf7f3ba7b44c80752c07836087d150ccc9bbe65fd569cb21421eeeb963212e75beb3e189e2dfef46789d3ea7191d905816ac8faa7c82a74355216cc67e7677784ffeb0d0700d922c5a7116a46b2844e7278640871e908a4fd71fc5749e4a11f161f8bbb986d3116207ea0a67e305c39be267e18d7bc4b76f30c6e26c906e951ad06bddc1e5dba51386b8597e46afd83f3fa24d8bc8532c8d0604f63ba1a1a3fb37ce60beaa73360d505d2afbfff408a3622988d5cbcd23ad800940d8f1247abae71068679311b6765ec3698f0bb4d8da8c5f54e9b07b194e6a57a173127e9b41b07c6806b5b515e36bd546a184a4673de031501e6315171a45286bc00f61f745b68c85f151cdcfa8708f6fee24709340c10945c7195f672818ecd096e4e1041c209bacf860ee4065ca615f7db014683c4868444d463e21d3889a736284fc01230819f6c40617f0eecf7498a411456cc38546551f415bf3186536a75ed5a17980a8085e620fd33c6e75285bba77516ca2c77c68326024fb36ca209dc06370a9ff4080330f1d2267a866ded8e752bb1a471bb7b2bd85331dbeaeaa4883d7d64655a2e0d94a3d5d3105935c27a7cab61c5c7a81c054fa15ac1e2f99fa07f8297a0530ba190c1b7c540cf3742b9ffac4ed913057f7661b1f836d8ce7b4e0113e0b5bee370f66fd6ca6d067263bc5e1dfa99c2c114ee6b3006d11c36ca89ff4c2932997cb4b6dc00086493606af7b1341682b5428572f9ca038a66f592b89c17f81d718e101ac7c4aed82dd71794e4f76a0d7d1026f4c7b228a671915817da52ab13f4d920465a894c4afce5cb0d75f469a2f88cca64aec64c3ce84f2f7770499738cfcc9d3f59705a9b805c7487d752b7812876862efc59895cf87c9b731e53184619ada6351cfc6a3e48d2e7624ff0623074c61bd94c38b974ca20bc3e1be2d2347fa63661d130a589463f532580636509af93995bf5af8f649f430164191fb3f97105d0f83ecb8c37a1dd80d15b6a79844d51d0656282c88c6522be6a5794652a7cd071378aba0db12c585c788181ededa43cacdc3cc170ef9d1ddc9c3bac2671e84af7e0d9232b860aa1a2e0aa8b2020894d6a254c255864e5db9f4b0d1cc69062aa3d0ffd3f9921997f8af1fc9357672ddcb449c033467f5bc5053966757756499897efb0f88824349c94902226b3fb305b9f689dbfaded0e3875b8ac09cba5d477336191a08caeeb08d00da0c9365ad22cc9630eb743adbfacbebd70b1a8b815690bfc790d702ddd1fb0baba07628546596ed593a838615fa5361e10388da32d85978b94b7394f2151333cdc52e858e853518489ae32b948a08ac6e954fd2d8a20f79b66e0dd48cce83554332d898810b34d043cd4bb2fe32e55b230d8cadce1ecc3b40bf5af7e756d05608544918ddf413459c0df284fd50c098bbe7955b98b42f718589cbd34b35252ab3c2ba9c5cd29e5ed03e3cd734441129eced82bc2fa35efd74e7758e207496de44b1d079c63e693c06bd3fe04274778cd338a589674991c5280d625025747e81874e98879b0b623c0fc7959639ec4fd1093f5817bf4fd31dee73bbca35cf9d236580fdb9df5f41e0a32e08d69283d268ac6c84063884d07f20c2a0ea1d8809dffd5ca8c70a8fd1b537628af52b26312bb209f50d1299dbe644dc306c715031507e54d384f74acef51046450b03d5d5d229bccf5a06290a608a376ea0828e0ecd57969b8599c0151563700b794c938ab97988c1f07ea6a812e12bbdc0366967be0393e567e8877b738683a238a20963fa159c7a8345fa2f1c1696542fd5fd6ce94dde371f62e3866d196f3619eb6561079b4da79524e3d81f05c0fb9fca578a1cdc0546b36136263961f0a84e24a539e1a4973210631a7a46ea9466ead04332a9e07d5c6a5b7a054a66c9e9e3454536eb09c18ecd8b06fa64a430ffc748c0e666a60794bba2cdf085e3be7a7c614ccfcc029977b41a92f988d43c7f90e24e894fc973d5ddfeadebc780659dce750c3f8627848e34dcc483c1a3561e52b099669e48a45a4b37a13606b5b67ddbaba5265159425aeeb339f5e3ea83341b2d90a0163cebe078e101ec047c381bda41261fcb9a935ec5d342021f2c6f2afa34aacd0a58fed8ae2d8ddc39c450141a600c25747b88c8b5ac89cc074c63c6e4430b6264e3b490f5e82e58911b666581e4b443e01c71e703db26dac5fb665a050606f41a35914f750f85e7d9c02abf4aea07414b64601009cae822910b9da1a5c16a2eca104995e35b47f842b85c9c943a0400518e5752c0aca623b3293dd721f2c726cf769e44d246e80db556875c82da2ea921c560fc21809bed3caee8ac99b1aecd2224758390924904e37da4e46ba69ee1fbccb87dc5b30c0e837a4af84186d2b0976d44b531ab65d24eb9d3f520dfd7e64a7d4c49f8e164143200acccb62217bb34c7638309fdf9bc46566d35be7047c9db87bbc616b3f9dec984816f3326d1ab962f268e12e3cb7c1f57e84b8c71b381bc229790a4581ad5aaf09b215f02fa06008f47780a613c31bc771050f87198d68e7b2dc86b10f0edd4dc4a39f734694b9df66ab8f08b708f498080239615eca1b965a411f79cb0efabd6afd8de70dc00f14c94f2164f494e79858bb4b65b1c163dc0c5cc975fde85225cff89a01ee28b974d5f4922e3aae442249c1b3057626410e2cb984d1a2599e4f000dfd5442bdda1be69997679e78e175b8303aacc214ccc2483ec510784dd3773e6eac102e0b43a924c49f63492cd8637b4a8d2ff08e51e16cfb63cbe56f767eee939fda134404eb7dcd064411e3be2473b6d1b94303a813940d21993500df5f84323f0e2c09e31fbff4bb7e79a46d027db2022a295de55e59f35ec1d823cb26838d67f480dca5d0cfa3f2be0e633a82306ccdaf502b66f503d2d677dd26b16c6bd88d1d9c688a1e9d36f3d33e9cca001220bf228dcc24996b1883299ae3dd408ba1e2503e167440a53e5d49e37c98b538679007a1e6dba77711864be8f0d860ad053a3ca2710ce63cbe68b3f4566ffadfc17284ed6a466892658a532b180809f614f9e294746f10b28364c969ee908fad594a1b46b652519681953ed4d6a39b78069c86c74a9efb5ec86364a4a43d8ee980ac5e3968e175fa4224281f983bd581451faef896fee2be3aed13fa9b23ef7b24ca853af65770a5110735c59c30b013a00d56ca5db57133819895b934d52a0610f6371998026e1be8ef75413666a455a39707c2a9b6c04e74d54e8a086935f79dbbd555de348d2c45922f75068162fa17289891f491a970e3fb9907c9ec565e0eaa248ef4ebf2ca627fb68dfc186b91a9647c1a2fa3a5ecb0a83b9342c85ccd478d70b971f766b197f2c4d509287daf3c7df5a8be1ca18bc55f6d85b747b9a189b1547c7e1b1edf28dc077b04aa4dd29e07d2c20bbd51a1e74ef9e7e1c595826a14752d00dc2de04be324bfb3a72679eeecae01f0b6071b56d17ac0a3e03fde6daea8986fc879588ec988382dc40abaaa6eb98a27c63adf84bddfd28a9127533fb57f8461ad5eeb4d187f3289fac4236ab6d37d71a1858db571d497ad880afc7def8783475e9e377afdc52463ef605f2f4cd7306016b65c587586e960d9970fe8bd935ee13b737f4054a17fa921f7616068d8ba7be9d8099c8d7c31553a37248a371746b89bd09c30b1e7c9fa86bb2e32ab75358c830cc1a3595c84f7c6f253679fae2ed83ea1ad0b472b11e65596665623342cb0a387e6744a2abf4d40af05e07fbd3f3cacff7cbc4bb2aef310fa4b14f6b2f5d73f60affa133fca1ef6423f75841a11b608cadf5a7d76a6f5f4a7ca28b3c0f6562db3debe09a157d661a324dfeca8f6d8e482cdf97a744df4840cc3e6982ce63276c3156f9c6b159505f7edf1ec686e0350d76b44a181592f717fe1cbee82b3d92cee687492e7f43395c5e51969fe846558951905d9fc42c09f485a62b3e3bdd8a62aef77f77a30cb8198a3b528f449619705b9941e84876b7ac21099457a976f6dbed75706288a23588484bf68b18055de9dd17162cfacc66b5486b1d319d1ecf90ddf98b0a78e62f3b8829e01811529078fd643c60e3167dd4a6d8b51df771a8b98d81765d6262ed2bf4c4bf6271486f2066046f2c3a2f2ed5cf4bc4cee31e9a47c98c3e6f03e22c165e39bd97ea7156530658856f693e1485ee7a7bfdf40682d81dff5153953a61f52b07c535c40dc8f61e8898e23048a71055714dd3b60403b8dadc18e1095a0d8787aa2c068363216c4d261448650c80a7c4c4935eb670295fc85c5f4eaee3ff3528055a1770b52552fc9a8f5d37006299ddf77dfef931a9c14cca2080d5612f1c74069ed99e3afdf33068a3ae501e14b5b7113746d7c69b6ef31abebff6e81168fbe3c2d156699f61ec05aeb7b2066a82a4310016bbcff78903b26f13c00e9dbeb3e87a74931c6f57b1c43e088e9d95e430fd4cdc5ce238ada7af1cc193d9c3c785ef8842ed36403d9c3c40dadad010e62a6b2f57ecf62fd070889e073a4af2d832651fe09bf812cfb1ed16493530ea65d1ae83fbccaa68ceda824bae1e4f7d753d046e4d79ba79453ac3286f475256a7f704fef69234d28e19a13e7416baba8df627627a2df9588a1f119bc47824df56af540ce693a193b5a96de7de4c60fe440c53416fa30c483298292e751e0fe9db58ec34f5266380be3dd4271809c643b7a067e1e46a405debfb26a70decd73741fb098f5ae4173b6bdf9a889f36b29f0c67117c7a6fed644b5f56021809ecf875f14fce11a30098917c468f08ce81998fa3c3a1e9c92bb41a30af3255ea4669ff0e8d31dae90e5d11e0a4e4b7adf37ab748e193f7b48e2383d4d7c6130e2ffc65fe290397cf56f9a2c8aaf5a92728a6c0de13a1794aced61da83164873559b8f380f549f699eacfdd7a7af7ac9382b7595a8f29a71053597bc2bccf27b0476370c0ca04d3e7cdb5bfda69bbfecc96d9acfa90c50e6adfcaad7fd9a95947d8a4a442e94713d56b7e3fe1636689fa1ff9a42a7fa5117fae28493fc68454f380d5e61bc8b22df798cd1a7a746fde9c9cc5aced094aee8753ba363c5d67a60b0fc3b6525999a1d37ca752b2368d37b27a6145b7cc6b3625494485075404e05c488c574dbe1caa1377c9802f9b9d07cb4e652cdb03ffd404c126faf2839c14c10a17884f60183d1b4a47a87e2b7978e92b38d3b9bc8d931c388bc7a64b1bdb6b8ecd4093c2c590f0ea95d89551244155aaa4909e13a18b054c4278b8ce638dffaaa7b78f693f3f8128fd916e0bac4aa8260d7905639f8e40b705f7884d6b85d9732d160fa53a0d59f5c0939733dd3982a20fe6b72b36626062bb536817b7cd7c400859c871b5d04f587458aba6b73aa182b32c06fdf487d0878c9562c0e50d247e82615500677a7326f59126d7b9ad928e60cfc4dd3e417c67cd02cd6dd008055aeb5c66c47aab4dfd5098951984e86d610c9ba3155d4e15e424b086b9919df7322608cdb464e3f1192a25554c31c149706c28d646061b89096cfdbafb27f3e444fcbe99c23c360355d4f5ea03e292c59deeccaa5c73f4e97a25a71c9bc63daeee9dc465b7c5988cf902faf440e3ef76a4387de51eb65043d59183ffe8d417fb763da22acaae118f82a3746603646d80bd9c4981e23b92c51ad4ad59fe651eb994e1d1192437cb717f945b57c544b04deef1bcf26d34f95a7dfc3a514ec518418072a1e92bb0073171511","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
