<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f472db954ee40b10d2cf97c935731494fccd40dc7a6702fec6280f6078f26c440e540d784a0e6872937c96f31fbde68e55a7ef398ca778bf1cb394dcc58974a6d0746b03cd43f5a1d97661fb3e16052f9321b70a43f108ed668119a62544f1f8831a37c28f9c5aa168acd0c562906c89447dd95ad7a1215739c1731a6e5eba3423fb9d8a8b3bbab2df153c4a3fda33824a38ba4f6ed00ce3c6808f22d9752a801f5d461dfb2a05088159baf06ca092a2cad7d6d663f4f96572c689e452d51ce97d7388b3d5dfff95ae8896688138d495268c976ee7263c2998b8d63bd1f1ab1d7864a44c913719a5a09425cdd21668c2f420a3ae67a68ae73d0de82a836dedd51670d9f5cc243bafff16986755ab1939f61263873cd2497d45192181acb294c98fbe1a4c2add04259e72fe35ed46fc6c1be174a66a220b1fdc8e487c0cc24bdb189849fd9be3386e3f895cd8bd7e4426c54bd449e130b5e031b7186dc081c81f7a54c94904def33d87dbf2a909eca9bbc446da047e4c1d1202311a630c7ae61dd96a7d94a8c0c57bb67dace0c7b735c311b1605a9223ce2d2c03dc6144ac3b75f38548cb056bff5e320aaca327b0ab02ffcd72846af3c26dead13446471cc336f0a6feb7eebc2676a33851f703ada83e12dc94ba94ce35c6121230db86c23792d0b20188e2404fa3d31bc327397eacde53adf33dc24cd2072dc06da2da3c7fff4124b7cedf11069578a05f13b4883f5fb32650bd8bf946c4abbdfe72074e9b7be2bd5a16504801c752bb6b32ac3ac71d62060fe36b0cb69d4b271092ccc908775835003a971a46b6f3ac5de0d13f94de4de63cb0542509dd8d680cdc137b8b96ab713742176f718725de2766d74ae88f0bda424a097444c67bad559c460497c7aebb090859cc7ed917e7421d0afca31b036e59fee08659d455c00377470db0708c6ae81ad1afad253b5f73bfd93a5bb5eedfbaad6dd1082d3436e327b26dcb10c0e7205e0d9395353a117c8e94914579c94cc52dddd420fa61d3f688574f1f97c112ba92f6cd8cef31f0a882a36fdc6aaf64539927a40ebe52983d67eb45fa407b91d88b5533daab113b683bc413e45bb49340dc9b4bda413a0ea0a04c775f079c8399cb50d0e183d3c0da269262d0bf5f919e24365c38f9c236c1abc04c47d1e02aa4c9908e6950272c4d6b062da38982cc98d12459dda411bf54979aeeda9455b7593f76480b7a8800f440773243a2062e271222df0a4473841b5df3bb40fc9d7c36f4f5baf1b91c972beda20b45d32d094204e6837fd12c1c379fb5665540ee27ec064bd3b29599ed46577a364910d9b4e047f167dbf82b3e9e56700b304f841b06fa77276447a963e39de4e42162e966da6721f50f10b769bde8e71f519578efa2bc2f6f1d4fff12963a09382942640c0631604e3c8b6162b44b020d20e6284c12d3782d017840b3f667e5e060c0167934a9125579a09cc916a6c6ba2732584ca94a1909d2195c3c12a51a161db398a9b46fc915112e5989e5f67011f2b647afd59c06eb103de5b4a1d60ca1bd592b012c04db13cc7874e8885f8c8b5068e0f3e10a32878419166eed5dcbcd02422e9cfbee2e02579c23bbe74bc874da39d37d00a80c50b8fac022b3d7ccafb00b9841336bc4e6bed788435805f84573c9f0d413f607309329e73a047446f62c2c9d3d472ee84de32cc9795e4d9b6f0a15e53348465832cbfde2f755ad6fef064b4aa3527d316c24f9511a075688d844f7d43d0b044c709c37e8a176facfe4a5fa2576ee2c674f55a5a22b1e42556ea9c98c4c287b4707b123975885acfbf4b83c396495d450988110066455f2e833485e47723cab6362d07923d20c3a05d4d03b20d30b57e72c4a3f87d0a89a0e6828f0e95390c080e80d1240e6ad67f1857a43b060a6f6d435c7c1f3ebdd42672a53c18c4c13d7f15e02014174db47e5f40679c62c39c17a92eba42e8dea48c3f52e5322d4b8d829464a59fffdf65d03123125b1d22f38328244aab7d37c5e60a01dcb45e55032c21fe505edea55a14c4977143e05ec715a21f3067589ad6a713ac9e7e5fe221e046bd1845c1a3c91aad970607cd5c28e5db76acd63cbc2a0457a6595f3082ec7802331de1b443fae43943cd471cfc7210160fae9d4092d9a73d2385716677a60670ad861832dc13535f1353293cd2fb4bdb08052cb4659e1a74e29902622a8fd9cfe308cb8a1b207528da712d4f36fb86d88ab9d4324f0042b2ae9909b4797e13c0222f8e7b17055afc45429a97a787444c59d8b40883cfc57672fbc033ab8c5b2d0a31ad125b90185b7c92bd4fb893e08b07c9996f33d9c312876dd6c495960a2aa501543286727d0c08a67b409734903351433701cc7ec59cee70611752ee4ce9cbe682022e0ea75fa50ff3110294f88181f718a4ccabc3a94795a660a2021c5233a1c922f15a7f9ae74bf867724a355ac841fed2b1159cb1f8d005f5b69f0bfd5c40311b4b808a0af40307319907e56869a0d29ae492e79c3089fa5a22dc058c7b83ed242dbe6aeeae7db2e2d4351786986782a7fc698ea0efdb3b45b05085fdaff0e9a3382090c16d8f14416933dc7aa2362c423970889ad7cabc23ee797b36a3323600761d30ddeac5f21d0f4635ee7628b8903d27b82758472ecac6e31b31351a7d55a1c56e9a2e59b8c25425f046e01518760446f9b2ac29bc19570e01b560bb668e40f6cf0085220a7b845fc9b368407ba1891793c1e87bfc5efd71261d2864804b80f198299fef4b461feace9e085f783ed5ece5e3d83b58c7941fde2bc18d5f6e3482e4c2cd504c533448519feb73a99f83a62345e5b8d251b762cad4e4a3f27d5f06d52d5bef50f61db1addf85d187151cfede9d6b83067fc89ae598b08ff7875ee0531f18ec787c2206db0349f8dccf320675f7ce9a7619ee7fbf68e1af6586983794b8a89272e70532a7da2d62e2044e053a447c5cffc6d601439f17fb659b4509d22fddbcee59e636ef0047c0ee05a644f349a7fc396eb8c121e01248cbebf62ceae86e400648c34173e53e20c4cf694b0d618cdde567fa69a499e46ee2d78210a093252dc59efe4fcb8b91993c165147590cf013843ae0ff2c9296cbd312bf6cce12445d40aa359fb06d5032865f4d92a854693e6f1644fcf895aed47fa81cc61728df4b745bc99f6f508beb89e98b7357b8b691d7470ec9ddc5b53dd5bdae031d4f410d877f50531bf0273e492687f3a4ca7abf12b6f3830d53c6f1cd9a7e300d8d134f53c2578a53f7976abed5d77c40561457d820495653c4a42838ad204143cad1107bd365ecf0911f83621c00c0ae6ffef4fa6e7f541e78943cbce8175639724edf70e4ad5d1547faac36e0f905db30bc53c7a05a64381f3646fc1d5a317bf7097c47305e9f3c848ffd5ba937e12fbb4e27b6653db97a45b0c68606258f7ed19d9622ace1406025530da53e7719f5583e5ed5182dce7d8b482e45e601f536b7e8ff05ad993c33ce822be8e84b095bfc76445781b1f3fa5ce7b2c7d3fd2d7c110b29e60d9cf82cd198860ffca62b7a0a1f3bd495aa1e3b1173b0a77637c96113e9f2f6ca4143174b692e073431def5d4a5b980da16021154d5ac7f34cc48996c27c7cf5345846cbd3c79423b0a516e8fbf5c0c4b3a84e9bd1beb2def066ba0bb3410df5bd54a63531ced73ffb8981ef12d51e891751c4c5ad537ace9f6050fa0fa3032658a92ed7053eec28872a60b39dcca6ab0612a7006f0bbae9637a6d63e830fc4f34b27967835f89bd56d0b3dd9469d2ed8982856f3a86ff57c81dd8a2defbe4c0b341d892816f7bbf6a11977646ca2d959e028371aee1f62f18a019e8ca7fd2b7484f01f81572d538d38a49784ae6ce45f153d8e2d3dacae3a1799472029e8c675a0287b51d2f8fbb54256716a617c0f581b3723ebb6dc05196c8e1c7641eda48cb39e8b6c38d18fcc3205c2b0ec3bfd1c801e5494169ea40bec4fed27b0ef2120070373e12c9f0ba918802902b9ae258778f223bec727084bcae9f761aa97ffa493589f61d1d5915b6db13eb0e1900d9f6a3b78f3581db8490023fe02f3a2a4dfeb76d57e086d692db1c440857f5d88b4b1f49099b15c88073cc5aa026897722d6dbb02d06afdcb0b533a085a6def77f8c05db79e5745803ef9fdc752440f3bd65389b3088763d5d3a188569044041fb0b35c77865f8927eda21a0a4721d9561731483235be95c50dab3add4d242efe85d443e19ed54b9bfdd2df251d0c84d337f4e6b9ca5d44050092432db984720bd9bb3cc8ece7cbb30425cbbece010ea51391efca36cae895a5e7b7ceff4a59ab5cc06c61cb46336e5fcfcaa2a098b5cc03ca6982897f6c8bd436fb717c1b432b28fde3a8497583bb69d226986607ae2545433a9ee0c1044cfa5feb92436e430d9cca06269f0bee53be9e7d97715775d04c46a252ec05ba5c1edb31f634a7b40ada0c3e9f70f76a245a10ac7a96f45386f750299e135edf69b1b88fa209a05a251756ae088e2a9df61edfd2b5d0b47921261a7c2481e19b0ce043a00388017c33cb1c3920f208f8962c744bdbbb708ecef1d3c152a6c5c15c81811a12de7739f759b219ddbd05ab93bde8588204288c80e0cf79d27a2f51a69a429023df290cd11ca9dd0f96d3aebc89631438c605bbc48acae4713032ddb2e0354f16ca7a6777dc71aabd8967833d846150249820aa98745a9587676926b99894108e57ff4fc7f3c86c6fa1ad9521f3d2d2ab0b7a65a10fc597797f0a9bcb722151307d613649836c83846555d83b2c6dd4a1d04562d598e433c3b35b388b9c96e51a22d47f1e3996f1a24757b352cde562843aa375a9d32a759362b01b195c5ab5da3625852a69a3246cc0457d1d284e9a8b4089fa59ed07055191d9e494c329f9b23b7bc3fafe1d5b20b2cde2494e2e7bc21906cc534d3f7928e57d84adf3ac764dba1c288fe81f0bd80c02140596676d90c3d0d2126edea28e343deee115aa2dbd86a84bbefc4073cd9bb72a13446ec5e52cc24ac7e9c4ab5562e853f8b535b44ef2b107857ce6bb8868d028166df0a03a97bbd7bf1ba81ae53b739a8ed5e5c20d95e723a4b6b22a39c7f988c79975b45c95b39a88741a810acac21f505beb7c6ee95a04b5091b43adc3b795d0cf3e371214f5651c19c8928423fd613f48409e36f19d397f3106dac04f092cc04386b717179d9a03df8c6f6c42774861d0e81b1745931c8908ef130b30e43f78f4d17d4e1540bb55cabaac3274763b7c7a80e9de133b003f8604569d2d941a19d1d340580924d796494b6d37f9f1a624258c5a776439b5e628f5b0348bbdf1b6634f911176e12f35ccd536f3e4a62138d1c0badd0dbfd849c34323de0d9d48a5fbe3c5916f851b65a868c6e2f2662c5243e44b26a93ae3e849b451b8848fe17082901626abcfb52e75b2e6fb2dcf145e0fe7b905f6a9d293b10ea43ad1ac5c14d57e55338677159690d118be22ddb519aa7bc9a3920f14a12615200719a9706b0eea91710de511b752c6ef7a7102cb09a748ad54bca8538ea4291c9407915b95bc96bf2d4c55bd631f9235426048642e4097d61de0417bf4897cbea7df830420d03f987366b8f16194a356a8be7c5d868b02d521c4a9530ec24292585a8b89e43a6820c22222da75e8be7777bed081693877d80276266ce8fc932a466961bc2c526a03de7d5a1ae061d291e494a697c1ba66946ee5b200c6a8b3d693012c4865eea1474de616dc41749753a112af04f07a6fa05bff7755e85e48ef1edc0667aa0ac18653b4a2d405f046b5fc9242b1040fb750aba49550bb4f1d5553b70117a9b085e831e63cfe1dee2212ef0ea1009fd8e2d6784ade2bd1d65c226343fb598426156aba3b1e89053badbef4bc1c2bf01a017219ded11d9d657e89e7d3762175efb76af87a01db64c1c5d9882543ca04b8d366761148ae98b3e43f3686db769d07a2f4d107b48152c51d6de9dafc313bf75479008aad618258f629d833d3b92f459a256dbb6c4b745431a5d12b8a06794fcf953d9833d739f4e3b9aa6eedd4d7e08fa811ccc2408de4223c7db2fa85e38ab0be8c2e9d754ead712a8d7b22129100cb13fc1b9b869c81444c2c41cf9f38b789c11579c261e0c740b6870e5c438cbf4637692969ba3ee44f19e68985e6780405c3ab3f9ff29fd96b82020f810a63ed12e160bb6926d7b636d85c96cab42d7a02de1bceb39b88fd5397c015c0037d9039686f909d0bd88441df5ac4a2f180ea718b6a884b7a01993630521d205bc564aaae4094db3b2e66ce068bf8ad1efeaf6c9ff7c62f949bede14aebb84e2f45b25d2a6274716d4e584e3fdb2af8dee3dc144563bdc082d493902e1711dfcbb49e1f6f895007cf343a0fd09dcf83b3602b6c2c79ecb64661cf6a04c8f79fa9c52b29add397e3d166ea1912b9d011e06f978341fd3f22410185f147aa349822c61bba4c2ecfe7eca589be9e2b59a6b03e7a186aaa2a07c9e43c707f3c968f6d555f4b8bbfc6444f9273394299b54ea19f4f60a8c16206f5956e9398fc839164075a9a8276ae7c8c11e70d2fb28ac862b4a409e631e501d056723515e8b7f11418f2fd563b797ddbbb35846f21184c6a6fc4e2bf31e543dfef32f997f9c53150ce7a1b57d36d7a03b7a686630a38576956567859853233637e15783ab4fd12acbcfe6b4190d371b71a7d1b14d8718eb650a40bda50b6a674d007e1b5695a48a89a9d6d48968016cdc92a4188417c341ed7967f3b98f0d16b830e2de87aa737301a9c136a2cd6ede1825bbc6c2341ce041b0acec78b3052e5ccc18033c1f835c2d0c9421c63ccf48a953980ba9a4ef0fa6e6d2d08a7d151de06c7759611ad801899fcc72990e4e13bde8e0a56f6aa0f9386e62edd5722c9d2c76da8e3a87d0bbae10521a94010fb63e38825823ef5ddf766f80c3bb9400d22ac1c5c067aaff8e72d93b204f4f9381fe26f7cbe18fc14f07070e6cb68246882f8d19a6923f115ce21a46c31ae6d87f8fa93cc8b485ae6981b29303bf179628f7af9a5f447c902fd1d00896e43d0cb2fd56930ea73bd32110c4b838ddb0954473600036faf8a16efd561c0c1dd736267ed7240cf377d0dc72ae99d986b72b443dbf1bdcd0a4d01604e41371a68f8562ccd19ba53e63d13eaabb2b7c535c29e492e3677c421903562ff2d82e740d323528c1d8a27029713bb301f4e2a452bb0d634c7d2eddf141fcd83c4de5bcdf54d8777b581354d8b25013a8509a48a48026c881eef184a99ba400e318995dae2a56c0e6d1bfda0e4184fb67fce439f8857e8d8d9da653a5a6c01331e273ccf82286651360815a7d2ae0f0906b595ef41232ee2b73f1ea8406203bbab4c8b19e74d2308c75229e7ef393a17550b205427ff9147b5e9fae478e388c78ae6a5d28df13ddca07f92a814302bae1ae4661b4593e545ea238a2ad8ed317043fddbae0b85c6b0df05d5488190d4a417f4b2b8180577f2d3a5f6ca171b212e507facb0e3f4b670fb7270a870a7d964318adf1ad06e6b20ac5954bcc8da2fa151e5e4bd2677623d90e563118ecc73c0184c03a9227e1de25655f0c1ee1d244aa0c026be5d972bb538f6d5a02507ab199d1f61616cbe71cc9aa3c80f7890f99b814d11d1d18fa387adc5d9632e9a80631fda781b1b93501a4019fcae3ceb95f01df0eb016977f4c69dd1d6a505f51c1f8abc35183a3a3d36d3d59e45c122df040bdfc884cbff67a083b5f5aff2da2dee6500783d7b05f2cea0e8e200615048761ad61600f354ac39fdbd64e6eac03149445d41a8ef9f1170dd6aa5931a482c5fcaa73b8341f16d856dd4dc363e7f9cbddc3d8e74df6f267d12a5ab0f729fe965bd3715fb1f4b34e09ddc913a1d61805809f8826725e64c189c960c9b415632c511cf0a3d9663f5513bf32b52e741c0da5eff501c0c20e1e4275b57cb8f02fe7b76c32661760f3fb3840c96f07351c3887b56f1d0818ab7f35761572d05c8bcf0baed59b10189292a8d71e5bdd2babb1f4c92bdaa32c5404524d729ac3f59191da8845cd2f632b8928f510e49b0906007d1eb9eb681e18f3ff56ce60d885c3e21adb3c407f76aab3cc983506510799c3a69514174c00335f024c57f1be8f11392b6000f22c303569e67a83bc2cbbdbd392138a1b4e724bf3d255d8e5c859a2e023edc054b5efd0840c440759140ff9107eb13fe69c1137cede25de4ee4145c38e2159b2bd2064adebfd35293ef207f7a48a7b5e5ec2f5687e6bb1d37b5243f884f6362cf087c88d957f48aee21aba36dfdfd2964acdff1bd7724f04e0310fe888c77242057dd1adbe5676f64a5cda22831d3bf56f138cb1a0444842621133d88ef5b8422c7177ec60599c1057c26f465dc3a4f3c6a436e2e465b724c69223b5918ca3af6adbc1af475c0449f02e62f38567bc423e9299efefcd14aef58ba66976dc8f3f5308b7e7cd1c515d6b066fb4ddf1f7cf3a21d1e12529b679594011d246fd72a28597803cb5280a6ab2a9569ba3e4b4fb7132ad71aa3d34a5a3fe32f9d7f2dd7fc2f4bf2eab80d9fd8ca91979eeba4a87648c956d6eb7d3a29fc1d14c91e4c584e61ee7f6bf4bf301ee2592b203fde3aa4f9acc22429eefc9238d17046fa126ae873da8759f22d5a97a902cddd489753ae940efe53a95ba10736ed329cafccb07446705b867074fcde493f426211973d54a69a7e720403652c045fb961db02b5ac2ccfab0a43ee7f5109654c540ff544de5cddc8dec9f61866b26871bf8114ac2cedd431d804e407d0497067e356e52f8ed45e45f3a3b9bd0db8721a00d08e833ec79cca70e76739bc91b7d7bf793ac15b82cfc9588f293297b3f82d9303cfa2c25bab9bdbf650d8326ed057f3d06f8242f3a1dad528bf377a88c241944fa3b81bedd901b31746dc58b029e966e7a827800642532f05faf00e51e15a6bd72c3310fbb6194a972a125c69b6e07b2e0556d4b5016497b8278a719cdf656eac313d9b1bf32e315b714b9334c5398359edb164ddcc1c074544898c5f67564cf6c840e6cb828ca8225c009efac3a386b446d59a79fa0e2e99d1cfff0fef305db722498840af1fc9b9fe057f75c94b51a9a562587a3f30523e4d851e9cfc1662702caa9f2c6471adf05b41ad6235587fcc7bc412bb61bdd5e818ddb14a1d71ddb5d897ba0e2ef31cb0481eea729000b5b8e4e06256e7e1e5f18bb83df30376cdbd637012efcad63c996b06032c0f4e57a49918de603e478c55fb1cd36d4f16eba50fdcb2ab06c2b1d5e4312fa3fbc0c77d47186d0aa60d067d965f43a76ba9743d23539a4f3712eff39f399b32ddd50bb9ff3aba3806e03a5e0b9353ea08c2fee39dbcdff90096fb9d27cb0947b21edf4efba9982a812dfad4a4fab99550defcf58bb876651d009d1475db9be11e641d2fc0849b975fbce710d25ded9e39dfbe20dfad77069d79d82839ca9007900dbf5208eac5f69b272f5987b98b04abd5569fcb07ac9c226a82ffe311a3f212f7431403fc6a2c3153216288cd2bcc2a2378a76e341a16a1134a388ad0440c665e4b4f4862e98453ce75e4c867462f3618b7f678b08d746bf13a88b6302dd0bf52e8f9b37a18f8c44f297c628bf2ba4a2881ff2544c8c44b8a73b98690b04037b894cb13219ffc4aefd3ab3571d443732d2516cb522b187c37ef1a7c0745b047e3ed0d19d7e9270d005997fbd5a084662b290ff7dba06b9d9902c53ea16cf1c86f15682ced2286a7e94f60add06d74f279f011a60738c3dd7b31f4470635ac9c4b6ff4c50aaf9d0d5349b7f9341f151b7dd3405a45be20698fc59ec9ec799c1261d0f4c75d09cb66dae4481b2fc22bd63a1e2b6cf37cc17f4f3f35058caf4ab1d09e5903c06b309067efa03b51fb6bd49b6a092916781b1b46fd808bec2ad5d80e28acac9efb00f52d9749f1f879f87d8b347156fd86626e73e3759599f6bd94ab3c292f591db94f265bb659095a3de637f7327f9532414d2f3268ff9f6a7dab73de582ec7be21eee17078c7c622519a300c35562fc89393b16fd83eef95ef04e65a3843c8ea4c252181a17ff470cee3309c82ee5fb725ef4407e47a863b7b4c40ccaa6a1110e942418294910ac4a0287ccdf0a7d26730a2a7966452f8ec5689ed512dea49fed4226657d6eeb39ff7e400181fe66bd1493d60c035814a379851c8a3e9d3288c115664cad5d872ba838afcf0b91ea4712f05f7aa790fa87fa0887596592971c08b086f9f6a2a2f9bea7ca9ef7bf6a11832050f8dc1d2cf4db67de6fb96092fb8b1fcc4a2ffce2327415fd56e34143c0d58aba971ca82280623ae54c33e9053665d882fa056652a84198e9261216e03432b65067dc6ace0f7a6fe9e7fca683cc7b3f780f98ef24ca076af0932e27428236f598241328a5b0d29f619f47952e7bfc09c7cc2f14b8568b1b2a0fba8bad085c76b10c647a71fe53a163f86b16851f498fed7001a4f423fe4459770ff8eff508004c2eddcd60d4e6bb4e6bb36cd242ac5859af29b58ad5738fe38932394a4b28d5eb00183b2d0066ccfc0004fa1ed07f0ba1b25b066dafe578a2859e9c1baee8a264437ef88c4003f83c9412962f3a708735da37b1464ca3d39a471ff7a288eeaed102a751c8fcdda61a5ebbb3d3e45541ed838517426e4431cde79043fc1a4e13e5d1a33c599a8c8428068e3b48fd4f178186aeee57fe56b2c47df77cd11d303ffbf3240fe2955335545a82ff13b125c35eeca091af1341ccd5f98d4052debf2c421fde6e73b85fc7f63384a0ab7fafebd19e436b1c1f70385fef63c0f0f0fccfe40cc97ff001982db818298016e24811cfc76278a85dd65ff4120974834375ca5105477d2a3e3e6cf33963d261b395820c489bbe6f9eb99b614fc3b7f8db7394022e2681fe1205922e1f66f0b995233790e1aa2b6b0f6b5c9ec5a4bdd791ed22aa230fdd1efc9062673d7938654242a6dc11c83bd8667c60411fe632fcb1cfb2188650d59615ee722accbe2707161282bfab875dfa0d07ebe590df61a949e437fe80d01595a96a7fdc5423b8293420a4a527ee84c46d7daa889691cb8bb44c4aa9fcb29019b79dd8b712e9a5aa94ed6590f6712a97ffa5fea8e6102c4fea0a4e8e402a193a708c3469e007092b6b2444d73ee23676b1b3bf9f2a04d07bac5104fbcf4b4e51f800f8ad26b9c38efcc327cdc2bc131af16a4aaa0fa1cf6e5d485c0ab9627d5eeb2e46ef7f7a067f6e249edd23e96eeffe36cb9c5ecfcbf3d2e176553e4195fd84dd40d1be0f751b6cdc30d5f3aa8a057ffad87036979bf3ef0e08d155ab33be9a680ba96bbacc6e1f2385d2cf396242c03e168093f88d56ab46156a3563aeb686063a7969c23bf72b6dc5e752bc9ea23e4e768b0a1aac026820096d82c2a972d85272e0e33cfaf4e547f155dbcee49cbd5fe8074fa57bf9d25619177b245b1d3172f5f3a6d4244c4ff91fa47be661a0e34729b1445df5476099f909b300bb15451d8606cf4cb136435b79e9dde5dee677373dd207201c1961231611cb65916b4626a382dd70cd9adaa05aaf81b7a8ca49ad83424f24fffdc0d9aeb88180bcb5684a8bc49e42a23f91d84b7344a587649119a726bbf41d39e54c02ac4ab7902734b7656a81c8c278d1aab8221cf0f81f70cb2c6d1928a23e62ce2cda5881884b12128c390356bbdf8174365a4ec1f219cd7b81f526526534bac0eee2b1d6eb517fb9a78b13cab1db26cb85b2067684b3f68286f711058d3ad481d96ab9fadcf94c4f61dfce96a1c3789efdbd64bac7c0cc9eeaf7aa8e2e478fe1cd168b4b040b8d82f8babe33f99bacce8636ebc03031540bd63abfddcd19f422035fba693044be1c639671d385b28bc3ba921ea88f99a4fb313ec3a0d4b7c5d6500595b21066f3bfbd583dd2e7940b18c9229b6b861a5d2f11b91544b3bd3ecd946afecb9906f0c3b13cc052d54af51c3082d217d62029655c00498420bd6c708db254ba2340fb3ba652c8aa9c2baa799756cfb45fe4e669b7a9f7af823b6f82b9bc76cdf554ef159131db0ceb90332f81297bb5932fe74f16147f11342cebc509d71ac7e135d3826c8295de660b648dd50f313bd0e2597d17c2372ddc4dcb858ae5e9a527a327cdaa534811b7c795bd50452aa6c366b6ce0b95f9b8fb410ed26a7f8f199975d91104d03cebd6ff2d01d74ec2b88c364111c7f58ab41ae404ef9be5096c4c76e0f384d25549746e2496e24cd37eaa01030ba6bbb0b0ba6ca9cea2652fbf43033afa301098a5eecb3387b25973e64a5b459ec5ee5e0244decf3ac3426dcee7531b4ddad2967a610ffed712d5939b8d912af8e801d184f37002a4d0b5716aface46625292bbcc5fef74a711fee13c124e64a3263953358b2230ed0d1762c9ea6f61bd669da889418a65351613d3f554f20aa65b25fafb6fd3cf49d26a5e793bf19dd23820520f4417437e82a19448f89dc639e8d89e8ccf011e2c094f2208f22a68f56d699080c977653197bfdb049899fc094dfa8678dcdc5505ab787872e57f8ad94b9fa82dffa7ad20c97cded6a1f67e3cd66615bc61e11e908d80928cd8ad1230504437ad9c834abae5e84e2b5cfd06bca794954ad0d182aa8057dffa467e26fffb5c0e2e89db70be40f8f04e05862037d7fc7b7480a56aafbc5b194298f151c48003c1a53a37a789f7412f08d19146e4180263447a2fed1a9e51364058cd60366f085c12a370c5bbdb9c9e74e1cd71e6da7814c67becd24a5285669b015436e3533d86150a9c8785d9534b6104a96183be87fe851f3d0094f0a372d23a87c119e50541324e248e31eb1565f3320d6df22ad50b8f8ca44791ee15283ff6d9bd193a8a2a6c4d0b34cd2d32206bdf142217a0aab8fecb6fb88ac8aea920a94654d226ee7b43d8c38c7ec5702174320d9326b29859b1d65cd39fe5b236fd3c081c6cc85f70667dca60e7c344c15e94f4832436d9ff4490c7e83c1c4565832dfa0e3fa245fada0b802fb3227f2fe2d509e2c66203d2c451fca569eecf1ead30dc43bd907a6df6b8a252702a5a1fb5c7dde610dbb8e8ea5f82b17077811f715e5b7c1ee56bab5be9822699fea920dfe7e8a2e748bb45cc77a2daff7955d5417f7f935ee93311f34b507d83ef1d79d2d96d42cf7f909faebab8d0a83d47f9ed029903e2a5bd9579fb317b4088d87a56525b1a12460af4448bee32d382bb81290c25878bc419b15a086929024aa996c98e4ff7403d477c044721cd23682d18df3aa6b2393d126e4f846b0f2428a225af0c5d66697c7d443bb982c303dcbb92aabe4f1badb114a5bf72974d898f8e95a7f120d93f0cd3198a60c3f3ab8dfb9daf5fc36af5e080934fa1c7a4fbaeaede99362e503d8c66a9eb364446d15b32d240e9b62a38c1da48c64c64b5c13ca224926759044ee2a5162fd3ebfb59b00fce68364d6cde9fb9fec0fe83371050771ea95e0bcda5a51d7d12ef057b38a0baeacfb097d494c9e030336d0c67ab319e0bcb7e4300330fbe71e0af668bf8149fb35b45c67e4a5d8f9aa2a1b639dbea3fa56ddbaa5f1dcb55f6874fd4c6dd105d370b99be15c9c1898b41a8fc4d2bcf11f6734b19231b065af79b7c4c0b9b1f0fa1d4845781cb84d801a3230fe195fdafeb0e92d08a19771f88a7b8bbc593dd8b5561e4a53dae182bd5c7ed7e0c83fef26b750232a5ecfb9f2eb801212ea7f034cbd62c59f2e3e6f77abfc8d7e9a3323291e9c54c972627de6284b90e0921211b71c6779f1645039471180d6c9ee093c7ece003f8656e2bc522945067317ee0d46cdccaa5fdbaa5508d71b5a3d0a73fe7549b639d1927ef42bbac8dfae990b322e9ceb70695192dc48467b6a8c2e24fe00fe50881be0950e9d66f55fcf0d3b35ea474ed32ac2bd81b27cb4542dce803ea39a877278b104bdff5c05a5256a9e9945192404e7eb9897987c0e0258d16a7afb3ddf1cf4a1734307ee67d9a15f353873f3236a235c690d0c0c10381f1c9c5af74c76e60e5c44a54ef2319dc10538726c3162383fb0bf9775df6105f53cf52cbe7cb0d30e8e79305f039ca09c06d9ab46fb2216c01ec7968734c0af15f18d0814daf44b7224d849eaac660ac3d4049eb8fccf8fb104c6b760ebdd43a4cfdace187575ba0a699d281260aff5ceebaba8e1f3b41779097cd8f0ec683bd479bdcd33043dc9e7af573ded2804c566c951bbbdfcb67e766d492ea284d546c3c983e79d2723f2b19ef7d623ba797bb432a8843fa104e27d2afdd4c1764449a95e7241323ba32b119bff1bbb5896edacbf9c3ede0246718f00ae79bf69ea71ac86d4678930a27b6bd4161c9f427a5d0f9b859a3aa370a83cd2594a5471e29b2a98bd9cacb88d17db3c05225b4dc6a0613df95cf5593ec0fcd5125b5d5f49358f44aae5f12e3b56d329f4edab0412e76160bd93c0fc42e3dfc908121bef797fbe3ebb1144ba24c209419fc03330f528266f77f4fee60673afd738b2e3b1b25419b54eaab5602b37dc502992f6d8c4dbadb533843743d23868d97b6ef6206db4e152cfe256465bee0af017ca169e869d1656441120e938a700b8af3f0e6681feeb85d6d1bb3876bdcca237a8027a133488f0b41949e2f5738d4b794f5f709c61f9059022b26544798e7d65bf6d51d7f98deec015eec04f947c56a4d850acbea073ede9a046d371765f464e22e5775c981645f342e0a0bbd3b0eb6a9c6d275b415afd91c6b409bc94235f413975019e49826283e585d03d19255657fc7e1c8effd79d090dc53d4175f85a3f3ff91b9c20ed2f250cb2c4b44e13a8b92ebb9d40e1af38f6d4f09a3bf62e3bcc978fc14fd908ed04250f6ea84f525784fe2930b52c1305dab9572d05bf3916cb0391ce39d83f7ec4a5007987081457dec9c5172e78dbb33f4ff3452371778d531f9e29b44940f0bb8f42b8d98427c814fa598bf125d57f2114c1dac65c30d15018ebfc8544253f8459fd5015ebaee2b81b4e8edbda1fdb01fcc89ca74a9c882da1db770b3b2881d4c69d3fb5f65da03b2fd042dc78275574fd66cd381bc1730deec4ef293cc2b52f4d7b7d141cde655f255fdf4f3ebf8d5348357da835d684dabc6f9aa34d5f9da63076a948ff2daec1727b87f82b8ed44cb2e633bc14d69b2bb37f9ce6a4b359aa9829e621e68f0c575862bce5766a38639c0291598a7bee9a63c6a55aac64a99294231a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
