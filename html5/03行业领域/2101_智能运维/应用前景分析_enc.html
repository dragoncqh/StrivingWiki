<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa8e7634e1c32bc1e1df72df3da02ddf17620812f8b9613be6888d5a2cba9d6ee237622c4eaa877c61a37786b8d34e138ef30a53a342eba392d8e2eecc4997ad4bf35407a39366bd81f7e509a8a17fd511dd7438495445493b555bd1d2932e55e8b0521f91b876fe2d4823d7c286a35c6615aad2470194d58a01acf6556676c9f0cf109ec8f6a01a0527ea751f3c3a0720907dd5d5769fbe33143ba401236ce4b3946818942fbede68f3a04735f89c15a8f271d625674e49eeba80c5976d5a7ec5c3230782179a5e20602fd212cd5cecaba6dba495d0ce4896d14ad97caacd5297f9985fb7ad08b768f2cb1cfe163f9697ec01a163ffc8cafd000ba84788c203a808de987b3a943e9c7fbb63aed068fcb4d3b46f36a6dfe0ed0f09a57cb8da2739e32d5e13eb6b2eff34dd050929620ba129f5f53f85af016a04b00029cb3b972317308eb0b9470a8f216afc688c019af89a7e36d90a0a3b7e0297712ede34c9984a49286da65701edb364826ca0c1b284c632301e647f3210ee80576f8c03761255128e4fedd2995b0d64e17aa5b3e03be7018bbaeda10d7095a60bf3f5464fab3aceab766d080b852cc2b8925cfc1a77c9ff02e4a89936ec82586f63ab59ca40306c5bff7dcf79db6675cb342e0b13bf69578b03a64638fabe8d5c83affdcbd87a7d1e60064b7fc11077b7f8a1d1df0a839528a4f23b2f3c6b7b86da5bc2e3b2688e94b5781ddc39177e8d33f5b71956949cd6acabbe32f4aaa7ccb71fa9de006e2eb0340cdf9de7a2ee37db54caee6a71c0d90cf4bfa7dc1bc7548479eed8108bcf7569a7c91922968f3e0f645ae05bcedd2555b0ce333964004f4e97a05eb558f6f12d6eafa5a774959a6caf40988b5467bbc3474e4cf37b6fa3783d7c9209701b8ffd06b902d954d823b7261f9804ff9f8dff21377718ad930b06dbbb39e66eb5a919a0baadf0e30adeffc75954f3891adaf1763cd9c15aedb854e1ce4e7580d07c23ac10c6c9811e5983279d7e3aaaaeb1dddb05fb504d406602b0ce856c8103479199dd1392a1362e2094c169f11231124c4bd38e2521e4f6024281f20dc92765327ebecd0f58bd2f33ed3e47b29988d929e309bb33e625516cf36bdc321263653d771bf79e4d5b862e6a42139ea7a179225c688df5bd7d06b9e013bab21864322a2efda07ab3a719e066f55ed1daea1ba4e764d1a4a7e74c48ab5fd40d9538e35087c31252ec77ecb3da43b719671b225c788448f8eaa21b239099277ef363b18f2dae7f3579679ce6225bd6876bc900047dfd188c88d98c5c3fcff9aa87ae467dabc460b63fd216a8fa9c49b2653c38c9de1eadc72aba82d8b673f2c72b5ce6154c1f7a9fc63172e230ad4ca6c78c293e79d7a019eb215b44f08932c61b6c45a8f0fe14c3ef8dda0c041497bc6cc6da9933575d6c9b49dd17ae1a16ba621492be38309d2ca06516b7326151809ca9a4aa2d8095c0cf282e019974e2c961534b5e860a7f0ae8dcc2b29cadda7fa3da19eb9a28240ed7158f0eb1335a43bcd9af90a4c9d2ae12ec6f43b708d192ede15dfaacd7f14bd17fa083948d61c2f66f627b5d2e96dfd4a157d5a12ad21b44fef4b89cb8c10eb62a23ae7df9dc23a4a1ec78eec8d97f0d2597a0a56af305d67260595edbf67ea3ad4c976514f2aefd69f68093d75ca9cfeb6b98d70d4206eee77b2c84525e8ab1847bb536711e3117dd93558b68a6a2882ea05bd1693381bbec93ff350ab28caad6b07376102cfae6ce8ab65abfd0acf702ca6000bf45afa2c3de32c65cdfba965f0599460312ad5834ef39ac0643c8708c466137a9e26657dfeee49d41a15cb23c73aa5b1e4778a184adfce1c52eff25f2b85ceb5afe32bf1e546966416e4c295f18ae1ccf52780d50e8e68e8c2173325eba5e54832bcd956f1223f9db0a086bb9bcd029aed735c5d414d9d2cc1a4a57252ad6cdb8e8a141fdc4be4c0a0bef94829d438a45d3e0f2693a6fe29396541ed7a2a2a139d2b98a2e76c7a4f05ceea00085f01eaa7b2e12cb896aa042858bc23e44f77fa0fa923a5f9a2748bfe6b5ea6253e1bfc2f759dcf6fd8273ee3772096e389025ee8c66c2c94e4670aadf7a30c09fb77479ca84c5b37868eee2cbb6ecb14557a541813b9bfe58d1f2db429b68feb7557f850f67647b78fb29417ffb0bd6d5d3c0527c596ff8d8b1a94f8c3917c04a154a9784209ef90c6c32c08cf699437d5df695e097ceb1e849bc5a762812068bc5820de8e3b27de72530be7d74f5cb20325c183575ec9799ae9125f4c3bdf143f63aa87d5d485c3ba20071c455a8a265d6293a098f60f8c4ef82ddc3618d9a0aa11ff665f828691a776cf32654fd81e2bbf2e16532f13b234d6b636d5500f297b3a93b51434a7d20dd39485a63d6c97a58ea3511b29e9141189fd321dd0a6ed683217d9e069033446968e62358e80669349cdb5d2a93f2baefb2f881d0e1380e448b2a457929160232393d82904d99ad06e900f1ef5ee023bc9a40001a12134c105b55757a6af0f18f82262a30e7184e23c66a84660737e8a1d4bcc9d0f9c6d19db699d3bc4d3abb5abd892bc23304dbc646c865d2b9c7f3de7ea5e6b11cf396744baa8bbc6c6d3559224fa8bf10950a06b3a873289cda5a3ae60c633dc0f149e107e8cf56a060eeeb14d419f61100294b61be3444f35c2d4ae9c5e612ab03f649742afd50d9376029490b007a2a6c0f27c3932506f21626bd812f6c0eba76ab637e63f0fa20eb29782c5a828504696a208b6322b8a6e4f7b4dcc19e83ba9546dbcd0a5a196160bfd38dccdfa506836b28d6cab8d54be3bb04e98def19947d4542815f47384cfa59a81653105ba847e776e72519f116fb182cc8102aefe40bc08125eb56bd594012b2cd4b039a8f3b00c750fb7e6d4905500e5fc4fc30c23bfa76814ebc6b3abff4e6f2e851d80e63f36e574394e4c3840233bd27b7a6e186bd197d8e645f8d47f5c638aa551dcb5a4cf27d73c308977b2ef25a023a5e8f12dfca18371e9410bdc9f97114320f41450f69c7ccc6009a96120d959793cdd9d882630a12a04a3598e28bd2e3e8c9a48c9d7e06f64faeff2abbb418b70173dbede0fa73aa5b933af66d8357ff002a696ec51dd2fa911d09d925210f944d49ac7c7df367de06fd1f2b37799eb89f2fcf9428ed7491c44d43906b54102e0368ee5118078c8d2f50de1a45e347e00564e5b92033cff6cd17258f3da6be79f40da6f4ce37669b3dafadacc68711e664690cbca61f227f4545153fd91e01fcd4a5f09aa44a7161d184c6ab2fa62000174000916f25c3a50ee0d5a8f9461f855367d50725c348793d49e2b41a8ad9341517ba4a126f562d7fdb49a080812082ae1d1b8edf76e866f7cae19b0024f81b64d230629c45815d1efc78f70e82b8084a6ea8e40b4eddeba11bdaad0fe2e5def3d321c85ca2139658bba3ba85c45afd4fa99250205f49aad272d20c2a5800149108b7145a8c729b61e60ba32b7b376d0a3c5ae1902f96601e5cc575e9e330e732e82537d5b89c2018f7ac01fe5c41a4845ad6343a6e10683e884a590dafa85ceca42b0ae4153fc9264c06ec376cfd05a9122ebd22c43bac0f4e6a17318d9643e330983e306f8d93a7d9441cd0c5d81e763b96238b3ae190f341e06343fd7483d4c02423094603544658dcc90fbd294dce11d4940495f248a4d1ad1ffa92cc50f65578fd5579ad944fd50ad4264f9103ef194a8c2a324602579feed886c4576e50dc25b45cbba00764eef70bfd912173bfab64b589e60238df94c62ff41830ddbb5bd03038b64d4b80df76d3776629b5aa4ccb106cecb4836a6d0eb668a397e74c18dd9b9eee3a980756e7869c87a589e26b178e512f1ba3012cede76b0dc9c34bf6b0dcde455d9a0e1ac7e6cdd6a1434e0e6415e8325cc5b6c77e960076ad2d130010d8a12ef7e902fdacb7e47b9fbcd5661ab7ae4fae093082a9fe004e774ff7afb46c71070aafb9c97d2faf29cd2ccd7d06703adb83b6fa090d9c067ff894748bdd2e4560c8b9687b832bcbfc29ce8a82df36f6fc0eeff16286f9987e9986f651f725d747995c51c13e007b2290e840010cfad760c8a9c3c567b8acefe2affd628ab23de831b25bd147cb1a9c735858e201ac8f2bfed41d98e500ad52f378dd9719b08d2c4fd2474d39c23e19aa020046928131f4c20ea4c6e45e0600f3ddda0da2668dd6f1b4203874837038cd6160cc9ce929646cbcca484a36842ab5117a067bc8321de65feaae4562b6ad0dcf22d7ff7ad5e701cd783fd6f4df8eebaac9ce1fa440b5b4ab6f481d95df4131e4667cb51ec97cfd934f31e04717e6b66039a096a998fa280e7a0dc18209e6c0d901c6cc7b285b0c2e16aacf5c99ecdeb9c27c3a4a0d7e2eb75bb1440f2a593d472b4a61fce907189e3a2e4cbeb7b1556dc776a9e1e66125451ba2307abf6355dc60b4766295006e2f5fc214844616d0195cdbd63320832c55377d6a167542318b3c831a8026d2049566d6b273e56ba7c3933a6b477aed4f69cacd9aff9230ce5d8f16a4ec4536fc13542369a7be8f4439489d46762fbd95e89ede2f0d106e1f197312c762d5d42c797bffbbf54b289f3cdf88c17a6cb4be8885de495e379b0193a99b867d63d9f707f49c41889a972132067fe3c37122068d2fc88b221f058fcc524668fd4588eb0eabff0bf284f97ff18a8b95abbed3b507c6ae6d821a37d5eae4b51af0ed51c75f3d119f958acfee6ff1e049dc5b62edafd4be2566219a2c857b58b8caf5ef4e163966cbc2ccbd8d10039339852281e62683e4c2daf46d8a0f6157a05c034ee31729cac90d1af9477b58221815e4710e2168fe4e9b3a459dc46985b048054369ace259cf0428e76e9f329431b12f3a5e7e74520b1ea2a84d94f236d3da5e2e50fcc9ce960c09a23c3ede5c7e7b7eb22f50b2f57bd047da3a8a853323a4116b4a1b7c2051ae58ea248803f1d8ccf619ab77531bf640fb1ca3a6e52c93be229bf9ddac32291e7386d9a31e35016682b7a73c9a10e25d88597ede070eab16c0d207a5f09293274afc35830a25b1e8d13479d233f3395cbfdaa077fe46bd597977cfaf3b0da5834585ae527ef26f9231bb6c7600d9c34fff0e80e0dda60e2c4207d511eda43b35471d71789ec70ffd11e4353cf045cf771ddebee769f078ecf06c4fe1bdcca0cbb49dbc63942804e1e4ba67f6c9922f9ed44f3acdcddeeb1fd546717a1a373113a969ce2212c01f206e3b0885edd28e703c5baf9f27f395d65968fd3809938c51267f9b82453b5108cfba6f3623b2474776b11c0856f31f69a45172ac7e1b66e8c37dbe5a5f68fe4a3f7c74dfc6497553d704e155c7abb521bf4a43d5fb8daa429025326679d4059d76f77968dc77843858f7df8e9aaf72fb3a52c49c30178eab6e1094447e19d2c687145dbbb86a5ebe6ab8247f8d1f614870a3be7c5fce726c58932ae5193e0cbd688f0ad03fa9b0c5c76b3c18971125c466d7dd8017043323c881bd85a5779553d08a9706d814fa5554e7a7e26c8a90a39cbcfaa9c937a95e6b23e182283cb6b0d06003eafb39adad77c35fdf4a1023630ae33250c642dc02661138f3304e0a15de685adbed32cda909236d797821bfbac339bc3fd07ced75c77c57722086da721d520693fe88d6de091888634da47749c159937505d6541cbbe95e53bc5f98a340d7f356e5c348c09d88f3d4aa50729e78f279896bfaadf897ccb092355836306b5d1d9b55781907e6f7304565ccbf9a7a3e4a64e5f2c74249236b7793dd5322a1bfe25d6e3496827e575aad70d8440e0cab808d0f817fdd43982cb7802fb88f7b900e976d12b5a796042f73ac44652262b28229bd5e5130d1565cc4c90ec092541ac8cfde8f37672e2249076c226a0ed426041dbf35344ed40cd5bcc260f1fdd9a90d362d9fc4b9797b96232ff41c764594a55614bd984df80485b1897f61d9a4fd19a0b7ee7988435ec1eb89e95fba0c4605531d1330924b3fae61734a4b77039d8b2d50c1a39fc0756dd259017c2f8e0116b4eed424643b0d8860d23779479873cefa8292032a178574d37b950ba5c4364cad1d88fa540b1633354372c966a8a43949bf3ce2c4e4740bbbbff12c2e841351ec87b11795fdc88f86457e3117196dc7b746dddda3684218e2a57aa008186364ec2067bddc67cdbab6f03e77f779bfbe090801156313bf1e555e3d62f2509c54cf3dcd1b248fdf63263b2b9602738c1e896b312c0cb6dcccd08c2ad39c73df266261fa7b42ca9880decc0e1e9923f9687b15b0a78c709df877bfc503e6aa4660108e8add9d87b6243c7b37dbac611d013f8bac4302a1b10f9909aaa7902ffe91c89a12a75b84da17ef874d50e1069313d966f9bcaacd6535a2be4af84f7e20a76ae9efec2ec530cddb2203ac3c3410de2e2023557b06fedf008486722b8b3ee3ffd1d9790d1ba1776c025be63d939527fae2bb3859a0525aed517f6efa59712b44feffcd738acb3afaf5ec7799e3cbee72346f2a2c6bdedb5a3a9e19f7f3bca7dbd74296d151d2d4cb40cdbce4884abbfe852d44549a28fc46dbd24873da9bca33560a2a9bdeff9557325a714404a14579bc68009434744d441dc1c2ba190b05bdeee5eedaa45892dc622fca2e99b42c3bcb84da57f534273ada9948b55745c524f152e0954b9ea98107265a151bc653343998f4ab6f483a8c8d08e8500d37d73ae60d05f0135744aab260942cabe907f70a8fe810f3ff08e762e939334a1e70e38f4cf2557320b097ecce450c021cc37fd74ef7ff4c21a763196e17c0af1419ca2a20b3edd686520a1deeef08594920ac5b3a6cfccc7a02dcd839355da29b42d375d68139a52c5dc4e59db40d75b515fdd19c99a8d9da5b02071d8739094f62bc55087344571618acacc1b529af8cdb7a2b130031e03588ff1dcbe87c6adb74f343aa05149ff3f2950ff7d1fce00b42b332be86cee00d10f12d8642c62774c9a3df3ed79e71dd67c581d989a48e81996529de9881e066352ba5c5fed8987c448b2f246e70d01cb9d2df280fd689db5b92ebaeeebc97c8419e6494d492541d4fdd0e24b3a29a33b134efa08f7572c3a5402d565d31ea9246ca3d6566ed9e8672ad3da62882bf78663759a58e2aae366666a7c9aaf5a2f39347d4afb4f8bd23f5a3577a852588a1668a180267d29402ebce93bd56d524552b05a3f63cb7bcb4afd83a44a932d6b3ff54f026a376829eb09a66bc26e324d8d5520b6bc1b076d5be1397e0d877aade4bcfff4b91766f0b76fd278f3b6b2dad273f3559cbbc0f255da00402910e941f7aa0619f71d7d391e8c62c129ddce2b5e8e6fe645133b063b0a7af81a7cdd33d647227358e373dfd100ad25c423c5197085f252777226f6ba76721670ed77c0cea315230342d7d9823b51d68b3fa399b6d19c663a6a0ac2134a6a66ac14c876a33473079b11998cae1cd5080dd24e66cbabfee02d9a1cb0dede4ea182fc485d4b1077f7e0933458d05dcb34980cc352268414426a2b0e9454c5aace6c7dd4b6bb94ada3ae893a0457a19292f27671c5fae46dbc4c5fdf7bafa4eb0e54ab08f4b9a77571bbd6bdea93eac0355c21354256ff2a58504a375139c5cedab553d7006f20b68d602f6017cbae3b731be7a851bfa2de4d99cb5c99fd4eb521b703754143b9018955a48d0a6a78539d98e4cb373dd1343c836bcbea24147ac388d1650c07eedce8d1cb94fcd497c52e935c1ee0dc489811418457443ac3b2a0b75df7c8f6544138bf9527b46b464bbdc30cced69d4e4da52f782ec710ef4dff99e2449e39e6c7fb677fe00315309ce327b810bd70708c3a399e60d608ac8aa1bf9d08c8518bc10130d93fe66fefe15d628e18fc57dfd5c9eb8ccb72fb301182c423ec27f6df85030d52daa84a407d0af81acf1d5006054f3025eabd800db45448144eadd70116a1d965f956640adc0ef7d686879aacd660cbea558786832578ea48873acf817519e471c7730324056583c592fa44aea43796478aaf542c6c7c191d94df4ec62138fe7c712ab577900aecccd86feb3f4d609a1fe51e5115859863cd8d95112c97bbbbdabf2a6bbc6ed7aaeeecc9075eaf577266ee4b94d9d29708a156a35116e93fe40bd026d48bca7b177f6ff46f0df7bfb40862dcbe3d0c82acdfe029eb7b631ad22c367acd57405730ef68d05050cdb905eb3f3164aea834dd1f7b52315aa1127d4a405c280c2d4fec80940c0ed1fe77ce9b877459ab3a6672dca45ddf46079f7d91ad1942e538d8e860d55c28988376269b51aa3c72652fae4257ed44bf7649869e2883591cb7fc79e2c4b5b35b0ddc1596400fd112f07774616dc4afdaa6c90b50250fabbffddb3a6739e9cf2e929e564742f6b8a35a45d6a45e8fb322d08b58b46cfcf1d1ae8f30356d821ccb5aa564e01bc6e4751f80c3d0d53edae08ee3812996f1d3c2950543357655ac53cfe8e62ce3a5937505d83f6219b3e232467b6b14c141cf765b4151867b6ea923c9eedf917c5e548936c3a36b0424e555758d5bf5a6c978b1f42a4f3d39ca006a1a848d753ec20f515d7897b95fe9422a37c3b2a79ab72c1c85b0d5284db894d577d8b3c9006c1e77f246c3b63d351edf7e0a39da3386dc945e15e37a5db6bac8213c560ba28004af6c93766a49f9c064cebeb647ca8efb7266739c0a97fc8ccbc0d469f0db69cd72f6cac234126a874d513f701296ad2f2a9efc4fa30cb41c6776a581024abcc0a1cd64a5d60caee0bf2ca62883765c9fc3825339ae7a48a76685ecfc1c004c6f8e828a54ceb283726f3427bba36dfc1fdf3706d67ae371bc6951cd46a2123620f40cdbe3dfc52b2b6e54329f826257c4400130b2555add6a60301e3a070cadb9d64f22616a319bba811dd2b0c0ffde9d15d9d9d8f39893c81a0ba7ea8c4d9a045c4e969cb859b0ee2461783b39b9adbfec04d275a030c42219f61f7f4241de2ebd59f450f47b819cdd476ce1fe99f5088d2d84655b526f7b19195a38c482f7e0b333a6d46ee67eea5e4d0b35e9877a003030a5fcec83cbe1b96af60550f24b3f7127bcd3af14e6d559708482034aea65b068908ec6929cb098f874b44f024eb4242050b36b503ab2c65e72ae18f85c741df5bb9095beb645bcdeda45ae8d933f95b57aa5592f71f1ed5d424fbb1cbb78366d6e031bbe748ac6faf39c3c80e2e47eb4dd7a9ccf9616937a95fd93b5fdd9a314a6fad429f2f44ca48cd8d51ef16f503fee1ce75270c46a4c0f7b7458867780a046bdb6c9d5acbba7a556904f6dd08aea3e2e102cd0f7125f50b35e25a9134ed2400cc26463bc852e1f66de29b103576335f69448e0730ef7382ec32b9b00219b961360b5d31ec25a39c9e3f0019b0cca40c39ccd05dd9954715ee3c308c78414fef888d2245ab3df81a388f161d854cd7582d23cbaf5fbeb03011843224d42b4dd998cbdf1ec068799402b34d9db4a713d00415d5d6799eee3c85468e796cc97518ce6a07896779cc6e292ac3856240881d92ef9e27bca3a6c85ffad6ad8f1b6c5c14badc6bb6da5fe3dc5483032626b9e3e2a209cf383dc2185b86a81bc192e10a57db2a7138b40736b838ded2c6a13504e71f73579e0186241bede6ec013e6b6287d277508834217bd6cf92c44a1d166fa0b87b5e843d8c5dbcd5ab6f094781c909e4e03f6ff23f1b8eb038fa15dbc2e88acc42fcdbbaa18df19735d103694882b4450770ec177c7ecaa1717f1f3ed31661cc9cd41019197feddf3546c2af7487192bf1f8befe659dc8d5b2ebd738dc9d93f460b427bfc541ca8484a9f1f43a8a084658e0aeef98303c1c3a1bd47d21ed78e0c0e47af01a48a5237b43e2fb679898ed36f0a1ab7c1f927725c3ba5749b6a3a445b5c44bb94387825b6d80214c47134d311ce11e49e85380f62c55e6aa78a55b32ba67d017ee52e750902d46ac59bfdc6ffad79f96c9d77a2d5d2669f79a43b6bf17994398cf4ce8a3a67f173e04dbb777cff000d2fd1a76c169d85d73827e583e658c7ba7a465a5981064c05a66e5f22bf736864b8be59701f424cfa864a1b9a73c2fb28ba8e2ad14a8c23ec4ae238900c6939468e79a74aef7a99dba96d109be8abc6249c1bd427a556548792255d386d7decb431def5b384953878b6a84cf7bb2a05b72d7d75687fe63b9a3c140da2ac6b5a42ab2ad3dcb25879d7dccbcb4a4680a2d7425ed1266d980bb0f636fc7a7c516f5e6d3f5d60c5394314e29ad5b48904edb928bb992e8b6677a4c6d9c0e78423b775ef6917daf32d7a8189dcbc51c90cb54bfbceb51abdb432f4af4d6793d00afef7fe5888df0bf46c66f1606cd51afc3a99d7b604ef3fe6638a526a0f28395b51af2c9cf552dabdfbe19d4f766ee208d9e9ea304ee5aa3e928acc42492367a36ef989326ff2a5b866325c50ce7a43caafd092d281fc17118cc4e9b5fa241d1ce9933fdbf124dcfd45523","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
