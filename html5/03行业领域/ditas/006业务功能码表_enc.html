<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b34d030cab473536f26b9cb1524c747ae334722592afd6db9a0f540056db2889528174e77accde610b8ef24cd1feaff948bca3e4fb388727b8211eea82c4610661a4f75caba31233d2be83c0f8e7e7c171fd3f2d92737259ce0d6f3f6c05efcd302b963af1a36c0ec121b0f9ef05e21b33f35b559128c70e85a81b5e2b59d578a1588431bdb51adf70fdeb591c68ad3f39470b313d89aef394e965d429bf44a518a157eb047883e9824147b15587521e1c7603cf916fac33d3e17b86417226be12b2cfbada346e3a5845b6cce5122bce72fd8714644ee9d9e7e10132b50e97eae6a3056f63abeea9e832e6ca1d883a20ed4516f24ef9d4b70601f03c5a290c272cbde9d52696f46cf98aef5b999a776e942ada82ae801ddf8674c0748b53ce9ad45629556b5cf69c85dbe99c49108582af92f5fbac40e9881fd7f682abfa5fc40d0f41f4c5502fa364674115790abbdc413cb7b5baaa4c0e00fde41b8cce3cd48900308ff01c1c84cac364cbcf579dfc1017e0f2caabcb8394c3ae3fa3a8a4bc824229a5bd47b60bc221830176fd680601fc22b88f30675919c1d0ce41705aa25ddadc651321678ccbdb715d5788cae55e1448f72ca5c3a532057e85ea1473accefe8de3c6d2a5c742bdee988784817e4d17c161c552f84e776e3a5fde3831cc0d675fa556816e1c4dc76efe2cf197622334fa7f15abb3d76d49d246efbbb39b0b92be3c42c9603edee58fd019b970b85d411b135fa77dc8e09b4888a4e5d0a314bc110799cdf893e3e3d8d2238781529072f18e3374ecb6c340c31ca17b2e04e67396a55a4adf12bc7ca915069c8a5c0df3498db5892c83c5f709de7cde00f809d14c350855ecc0f9a434e1575f248de029fa6d111c17d3f5fc6ddc719565efcf482efd6622fa8f30fcceefe445694ed588746b5cb8ae7a2b3ec9b2c781eb95a351f96ffc86347ec0d4267feb6974b8bbe63d83bd86bed8906652ff09a175944c1381fed23bfab1b8a16bc01263775b6154db6690d3e9edd6953622fb362f615bf982d7a3cfc39c6a45f8977a57c95cc9b904ebe772c5d91e6aa7baaa2aa268b0db6884ee18770faed51ad098c2f54181c80f3b0c9ce691bcdbb59af6fe85a51a97314e163d010f810213d8af080df4a5d8e93310381cb71e1aebe739461f7300097b6cf4d038fb1a634b66fee0b890efdb87724b3423e95bd70da22fc9f77cd087aa03c12e0a2bfc243d2bd731a140442f226dbfe1180adee668cafc56329439d6118e16245c5190d1d02e8f1226360360a1e3d4cca1b284cf455303534cc64471db0378476f2d9b82dcd1a8b606c32151e5aaa0743b76411f585bb4bc56254d7777932d2568b6ed8e6b7f643648a81cd2b80b132273ad461dc83f3eadc01f7f103418385ab7260eb5d697d13aa64452e39afe73fd8e27e5b554fd6d1619abcd999ef891d562ae7d5069ca957e1932ab0bfedc99ca686d1b165b6d88f5273b0d1fa8a1bdb6d2c65cbb7aecffb54fd97c18b07a95016f181aaadca22396fa775c68435ef6d940d8ee8527ae23503cd983fa242aab8268d3ba676f91f266154cc03c137d52122626d9737d41a6d76a7fd77e6611287dc54348b3ddfe5a9c89f55795b93afb7438cec364c5213806c8057e5b55f5d90b74506accecaa381d8283a92588d70d80f64b3c314cf19578858403eae34d4204e0f46cbb65a088f98ca5002c6417be54544e0ac15086d3cf1c254ac33272aad52fc0bb0914fa51ca88c897e4e7624cbfed18b04a1d701c597038569041307aa6de541e020f93fffd3537d28a4d03e586aa43f4f716723b3cdd0c86ea13cd03f9b21615dfd162d71ef1426f8a3373fdff9c172a2665bf2b304e5e5e4b92087cc2ba795e45ff4a35924c7d5f10b402cac76a46a4e26befc90dd171413b95fe85427665ea171cf9c8fd27a2dfe4ab69d519d4cf4a4b503e4a35b6af39bf083c0a73f54868c0a5bae1086c223eb7c8893ac267b943320459b3714d4bde37fa3f623fd765ad25f8e7f2aab25fedf2bc8834c83d3b4d8a3478010aef6806c3381989ce8c8e3284ad79be23625fdd9c2479f03f16bdfddfc2eb120dbe9ef42b267c2c3ea5befaf2957495e597112ea9aa8aa25cb1197136e659cce291f1baf916b0425c7bde5573b31656458d2703993099399d4a6798914741664e2837ed4b2b08a7793a33255263de793b02e8e58dfde24b4f11b869de25870f1ac9ba3ba1d4fbb5ac0821a40377419b149e2a09e1c939fe0360e569945e8813a5bad53a23e43e7a458ea6db214a404f20eabe9457060e2853214686fac8f1c6bdc2884fb26f042d116394a0f1933b3b40098197b7ce0b77adf703776adca4a554d293b8c7fffaa147b70bc95e039917501c5516f1810277689cdbcf08172f25d173fa80fdd3ae576ca39f5aa7c9be7858fab16600245419ed2f13eecfd5d2987b884e515f9ea12b990dab808bba1e3ea12c438f0da7ff20a679298f77f7bda81c4beae83630ce73df821a48c1d7b25c8f6fc028051e48645c712970014048859cbe99a90a7f323a3b8eaeba3e55e7029c861faae5996ceb18bd742d216502e5909c6eb27ebab9cde387eae25218e72d4c0c8e76fc56c8f80b46e6653d551dcb8186f682a1013f7b06c4503aa359fce9151594343f12edf8241fa6165cba221c4e2d56d9738d3e46b478d24c66e3f4673176ec8997afeb1887bdeed795858bb4555eb74ec189ec9209ba9fcb6f549040d1efeafcbf778209c249c97266b13ef41806cc79821e3b5644b55ca30267374d88b5d0917941833bbb473c5a90611a0ce480ec70f1eb2a522dcf4298e1a934ef4a94fb0ba7acc9c7aa03b3967ff0f0c8b0b67e1f739fed63879981216a6c605b97b46c44878881cd82f269be1c7318b414ee113f53e816ef66b28172a4369c52a67020eb455350f1f336392b4a8916b0a08a7ff481645a7296e3d4d1767fafb540b1ac5789139444b83eac1abb936dc671af0869c00142e39a9d6f1180d57061e703bdc22462f94351ad7ac33779f05499b9bbe875af9548cfdf599d6d4fe1af088dd65533f093e9ba282fc9911bad532e9882f632da21be4e9c0ce3b149074db2e4f5dc507019dd5040bfc59f119b0b0b79a8b88c21897d02a0164a03b14c00f662e2d9aa3d308d1a7ca7932c23b0a3c7db78be9aad96d50a9ebbb1ffbacfd47cdbd74777457972ed79c63d4ad93ab637b55d0a3ad26c4bf75afb36e36c6ad86bc980219c76a4b35cc7fa7e9efc844c3bb50cb52a5072c97a7b884e3b521f8ab6a7358d13400667ee79e96a46c8384d12c5fff3a7a696d640e823809dbd7ce14fe2719432ad8ac901350fffa9e36c2c09fe79347acf6f1d313b50bb1aadb8f34395e3be49a9283e8ec6cd491d635b45ec4a2c04e2ad85554a8fc3230de9de02be8ae89c86e20a3d0552e09ebe0b7c67125849497368a215d1c0e3a6df3c73ed200eec8a51574ac4a5d15a7781d9a34a410289325715cd293c7b73bcc23c69cc33ce0275c70a5025ccbc5341dfd0d34de30aadde4776b554071518d7125d3d092ad0d7f4757e60f5ed3e2a260e5824406fd561495dfa512cd86676e68574a95f10a02cd104913613e78b1da194543380e6ef1ce5fd9d61c9c88961102843d4c6d2c0a806a17bb0ddd40033cfef4b41b61ea610060dc014c1465354bec03e86a1080fcea90222ad2d1716ee6db3afe57daa70a1ebc72df438a3b7ba33b8968f4ded4969abf9fe937a38575a87b7c75051e2d9843c7f04be7b3b5c2a6a336aa4d8673d4570b9b5c34ac6583e941d43d531b5ac274241bf0335d54195a09647d8160f97642c3a8eb63690fbff1d1a97c07b3b001ab8ba93fdd9295a6e0bc718863364c5d516a073dc9217223c5d1b766040666916aaf1d2c64fe375d3ed60046a52cfee01723b8775d960ce86c4a9f1336f8d084aa2eade8001266894861f4913138e9c01e117c79c716812757a1d37c91cf362582c721ce758917e30041ac5481b7d4a906fa480e66daa86f9befabc6731e7e0e1616ead40379a458259af486d20eba829bc105c09f6ad5bf43b8893ab34dd4c2dd403b957750236f4ab53b79f1454b98fcf536782600e07fe73ae458520b290e5cb77f0cbed42434bc9130ebd3e6d0f0c199c4d4a66b5bdf24da44178e240c9bc854d63ba370c5298569b9a486608f76267f214edcd93109c4e5c5978dca7f43076d2417bd32df02ae42621e8e2bdf2f430a13586d944d4d12e00c10ab39571c8a9df2516473df97a533b95a89301f3080ae5d96f1f50d5e7239cc1fd015f3b627a4c57b921db5551a406ce6a0eec1fe4b8d60930507af8ead1c0b53af1caf32693bcc6eb4607f02fcf7613eda17d67da4390e0a038bc5c293bb052b11dc750fdf1b655681ae3730f572235ad54485bbffb0bad2b4313f279af4c5152ce75d8136bed50ac7c18cc58b090b046248149d694385e1158e8827501e3cad330943824da5de2df2b9f6584cf0af736a7d6470a35f1b2b4f8f36545f327c45850e228842ac83a60cb7acfab4eb232c3d00e9683832faed0e7d999b16993fb21cd412472bd871b2d8944bd74071c3222773ca43df00e51fc20956a8cfaee5f369bd5e93dbfaed391b78c3077d896404f87364233dcb053e88a355b3b7621bcff363a6daba967192a6288955a5978315334576fae9036782ea7f69ba76466d12496489a549e3d50d63569b776975b9a335143a6784e465f57d8a44dff5241f884e083888f44c40f44b3e3a5ab32534ab7f92433d742bf6539785d82fbf70118cf58d70091aec7f0c8841ad097a8cb04bac4529c831880fc5dc5af2922ed43ef34429e8d871fc986df3bb948790ce586ae2cbcc714f49d8af10e9caa1017c962c8c01ad327e6963a36100b4d553682ac0262acc3a22d78dd718a3d552f696c4d255f6ffdf5dcf98f8fee80c7455ec84e59f28f4e0c585d84fdb9ed02a0e2543cfa007489fc2c76e75eb7941fab61317afb11213698cd92ff1bcb66d983eabfb9737dbb7905b5e851c767c9f92ffeede3e9704c51d24450863363c92451c6a8e5fe1418c12f304d1d64a1999e6557cbdb6d3f9a8986d820f4856888fe6056cd2101caa5017bea27512684ad4191263318c13ffcc2faef1722aeb853ddb9e2897a512f08c1818d7549ede9e4fb1a9c44ac5c98e6ababd41ba3e493353105274817c1d2f7c382aaf17481bfddfb519869c1525aa1ad13becf3d11b5962950a954ff731ea03b7e3a409923d361a7d41a5a432ef13961a68eeb7cd8a3bc2d85a02563d99196f945ab0c78382648cc561da5aa57da15906642ef941185dc3b41e8790fc9ef469376d5fb35940f946118a249a32e51a947be17eb8fe449ce221b4d212bb930fa1e13737be5b4e275b30b7f0f08a6395657cefe2ca191ce2ebd5172d4e217a20cbcf53210dd9c5b4a211011c90dd02d87dc214c773e2bba8c45f610cdcf629b5a7e556e44d7028a2292fc0308c5ba886c08c23e522b68c2ce0f67d807e0314f27d805de4a00e786553b83571be88953a017a8948fb12eb653d17fc90fd4049bf58e20b7b25b0c8807bdbb16b35471033464dc6ee11706f83ce93914b60aed68ecf710f7b5f1b562d144a4644155ba764caf08eaadfd21176a91f626f7c786177f790878aa0c1a5cae6e2f5e33df3fd376eb3aafeac069f432d802dbcd4ef6c6eb471c8f6e3f0f7107cade13918e0a6d7cfcf974a24b3787f4c4db6e7245466febe71a14981d1d4931453b00b1909133882d51adc55099a9c6c2b70778a2370b1c430694e31d5bef5f301bff51fe1ea38060a6a77a087a91b964a02f7731f89b0ddd385fdd4cd7a74e0f8de060e1719d03978a0802c9dfc78fedb1fbe20cf33928b5881df6cd5d8045e23725a402b4533f6050e84d5a85cf80506c17b1966f18b524ac7b465a0107c867e35f38d70493090ab6fe80eb92f06015b5a19cb7f63b75a948814001c12ccfd92488974bd18ac591c9e9565a9264f56f90185c64b29ae9eb987613ec9cf395c64f57cceef74afe21a1f0b1ae3589fbb32724111fd4f1cda19f22b133f4540140121d463b433b8f241abff81ed9ac6f7901fa01ef7f8e1a0a2305d367bac91b28563658da518bd748da55df833c1988409f51b623cad2848a217b1c1168dc1ddce4d3bc47f56ecf364b273199c0e2fdcbc54183ba6fedcea2e4299e0bbb74b62c69264329614be525637b30a9057ccb19a5dad4deb9999da25107c08ed3486707b0411d3516c466c951affeee6852ddfa33765f2a1ba0cf9df028b2eadce3bf095305ea14b276d27c680f45e72607659181f1034f05ce824cd45b50232ec044f7dfb9d557ab85eb8f6913b755d0334d8a9eab9f2ecd3485d5e86c39b648a3f75cb2d821e57fe5af1aee4f2b34a2aaba92bb0ea3af002c0fb2dc0b506cf175a4440d61bd8ffbdecf3cfb5c711ed5084e03fe5cc2ebcacf7d572db652d32961add4f6b3e0432af72bc513dac64952ec29a064de124a77dd34196003b52b3b22586a9c4eecc79ab3c8f271c6670471562e8efcbb5cef91d128af48a16fe6800e9935222a626b736c20b2f8993f408604624066f622f319553e4038c24586120f8d99ce0dc31513372e0c236edc1ce32b80f76479dd8768dfa10310d1fd2b4f195b5b7b61e3d4a165f0f9a745e200890dc6284caa9d9c25900c6a06905ea87b95c17480c68ebf18518f4e78d3acf29e11ecc9d36a70c7a789baf32ff8392c908b5a94173fa9ded8d69a582c0e07835fcee5e3855a4da71d8adb7067e850c7b2cc118b16d3683db8f4bf8f44e9d346f50d0359840159d27ef940507350015cc63a7f6e20147184fb49578ac5b930a59356c239b9024a31fdf08bbb5a4ce2aee661e67097c9ca8e9f916692a4274bfedaf92bb46fd9f1c1e0e46110e2dd010d8ab35c3038022ea79a85ec495917816f10c11f9c2155bb595fd602314c23ae2fdf2309420fb47c469ba963071579d743968fa9f472b73af5c79da3f21e96bbbfca3e83d489824fc187f53c368609a86804035efbc14b4b054f21c45cdd0e16cbade4c9eee1dea35a99b854cf441363a4eed3d6942043e311870d2f89c68607fd4069e677a9e593096e925870e380c25275a17061c200e80b3634ce42b9b0a15dbca2f2fbc77244f16b36697bd5c272a1d7a312b899ff05e9db7d073ffc62f510a849849b00d2d65e7a499cc996fa200c8e65deddbae2599c7ecfbb42cc2912d7811ef0fcaf0b642655d9f532692fdecbea3f6fbfff4ed3183737f68a735a838bc66ce9110915a897edb9af3503f7f9c8c2d26a135e3e12709c78826abdfa6fd12881a2ace2448aeafa444aa70195fe13f8742a8817f86986a786e061f4aa089c86f6f0ae2bffd0e3317fc42ef430d2f6f963bcbc3912461e6892e9e07418562e351a593d54f239d8a17489521637709d36da3120dac92608ed40cf2ebfa3af4cd4b974a0336817f1bd4f6d39fe48435d466a4cbe112a5db3a129ae492cecc7b0283dd7abb6937687a580d7b837e37abf580cd9ce8efa29711a96cc001684306071ef155402372347b221254dcb51e63f086a72567ab47e0af70a6efb7d0c8010da1a0ca885c0de20c8d15306054ce2664f4c8ac6d2a1ab07dcdfa392180e2bd2e530ef53690356edefe88ec401272341bb9d4cc14e0e7080189dda1cfcb93ed22c404e80a7c09c00849b03a60984f431c3fc9d930b157eb025dcd00c219ee01a98dfda182668eba1b8ccead59fca7fd2a0f567900a0f07f1ae95243ebc703881d2b1c24965ee2805277ebb69acd7b5ef5909b4e8f54bb133c0ee8ad64265140a44741b9567c0b2bc9494deb63e06b23641c760875e37c3b2c24071cd2c0fb90d0e451cf72e89ee6ddffdd1ac9bb4e98da50c5af3e8d2637c48d9e40173cccb1ec04c66ecdbce3649740eeeb48bdc78114a19da76f97e7c535327d6b5b64f5c04e3239187eb348e6fb561b4214fdf0238841c6c515c1d1f2d49527b10cb4a0248b94ea59337c817289934b20a49777aacdae5e35ed285968ced8b9371771cbb6ca4b1dfffcd473fcf73f4fbf7d58071d53bc3d90076b43b159778307ad4cc18fdc5d2dd8ffc2633b091e582979c2ad1002939cebd4eb16168535fccb42688125b5814a08000997014ff0699ff444f9fd5a05d12903013275d3e4a841e20dc3ac35d149385db66850ded20f94c35235afe209302ae68a4b501ab7ff5bb8dd91dd2fd1f0f69aee921ebff5564cda183935e8112a8b424c2544538ba0fa52d098f0213f7e593ffa1f31b7f5c944fa0b3f699d1dfb29ce2cdb2c2f0fbf9aea70dd42c14149fec166184a815120972d3e7a63e986ff39167f8b896e5ba560f34482fc140d3d49c2447800bfceb73e155c1641f85d7d323856bc6dc1672dea2f6ec3a4b3d1a74b461cb5c1e46f837082210313ceba2a4b1b2dba5934ec8cd53dca07aeac76e86abec39125ccd3c33355b18e15eb1db646e6bac4c28ac856cf255ba3b555869f45734ca3a58d2de5be8f249e3074c4c571915f1b921de4e1c62c2d81e1a97e9e43973a2c1d185ba472aeb047861634b525be5c418e5767b4af18418603ed56ad01dab3c6c3bbe16e5f4754aab2ca77eea429bc1ec5596b6869b1508cf959d732e3f25efaf7b7ff9ae098deb98095264a0efa979b9583130151d4a90d8964fa431fdf7b049d48f7ba490e65369e956460dffa13a5018175e82c5d43befb350118c5d64b089b2d799ab2add441f8e57ef37f5469f67be6cb0c1dfe40fecce276c9e69e6651af105d60ba8ff0cb573aa1eed4676e6e45d12aee3c6636fc3ffc3704657eaf65cd41a74760dc64d1a7da19062bc57a814fb4baf156f4f8bac231c71abddb6b9ea5bc5c488251d2c29140182915cc10de881e4f3e7f02d94f5246c43c107103e255453c050ff3b358c8c3b46f1f75e8a46d23f8446356437532205935154f36c286f98aa8d104cc25567c1dda56191a3dad77dcb0ff7d0f0ef254ce7b1566f4a6ab03b440dc308324fa257b0cef478a198e5a834a08fd6170c9e3c71d1148c5bc004a5edda8666e96bc684860e7a896737b1ba81ed3ebf382e260775ed4812bfb0fef32031530fcc09eec3193fc7fbfbfd1b73c8901e6c2a8e76a2afcec1e6c48c98c630e34cf1a24721b59c437af0dd32b96a840d010cd795c8a4eb46b4a6e9b18e40a95457bfe1f412d1d424bf10495c2f8f0fbdb270581966e4bf0ef8f522c64e49207da1e5a8d9bab92ecbf2c36bac7714d4864be759ccdb6bc816effbff962e6de8994e0925a8020e37a09702592fcba2b084f665688d1f0d31a0b4fb2219a160d4d91379875948fa5aa355780b2ac7408d8661e77718b9ce3c7b28fd02b010c5425ab948ccffe3daafdb9a1d31301b765345c869e63a00d9cafd5d3a2be360714e24a58c88c33e010a993674e451ba552cbf5dbc38a72e001ef7fc6d38684a44c56624ba21becce0eb79501a10bbe779353144d87042409cc3cc7ed3ebb93ed56692c58c4f41ea5373e8329719a198200b8686485b5d5db7edd80c3953cdf443f62b203fe54a786d8539ce6fb2599bed44a7a82237c413d5ff80a2adfa8dc8433e72c92b776f34e1c31a5b4517ee4ae24ba7f492b502c4b7a03996844b90c44c77a7e875eb2d61d86b87a9048157ac9fc78e8947b58ab62ac4052d821539d57ad6850382a4d701acf8e1fc3ba0b006f8d0096794fa77af74df7d1bdddb76ea4019129ae683a0e4853e1251ff9f9f90d5b318023480835539efaa3a5569640c7525bd4754a6d2ea692c989a2f55ca7cb19258224a0018b5fbfb62895e20a0686d1709b2055c1bec7279cfdf93f07bf0025ba10c853b62d60638338870b1d090fd79a8f7d55d2ffcd5d79f3c376b5286acfe605dffd0a03dd6a3acf6c16f46a86ad44023a05d6966614b688c88e431f83479cdbc1b582c248d35794d3178ca4a34c2eeb947b6ea8591b19f129a0f1124734cdef68d6e1da5f1355ab7a6680f3328fdb0f0006ab95dcc00ad3ea7497ee522fdbb6fd09ae64a86c1f41ab0fc136847e8cc316cc91205c2725d767944a9a50820b0bf19509daf149111c0fcf1c404810544b5f5a7e1fd15df91db7e6da2abb7f40ca2c532dadcd9b2b86b574a942e8b0e05c35d78da69001ed66922a971418dffda33aa8969bce48322f4430c6010ded7b6fa6049451266a47d3716269a56c2e508c62528c438535c2c3b5c7ab53f60ca5ba4185f61321607d77275e255ead983f648936734a8bb9fa5f6152526874c5595ac5611f4f958f85974a5db07726959c4b11cb85975663fc7909f9ef4d6a5d8abb72146244947c000ac87f0d806fb3c4aafe66c1f51ca7bc0fbdb574e5d684e3f1915dc74abd6e1ac959a9342d9c9de61f1e5d80f4dc2b9f424e6d9c52a425e3d6695","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
