<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbb30d9dc4b93bb88e53b529dde8e35e774b628edbb557c455c7a733f4f42986217ded39e4b6e11ddf9f414c5e4ac423e10f66f3cbc7b79d48d821c0bb16cf80cef75405d40680bb50847005e15df7af4a8db5a7610e82f46c41681dac39b2938044e43ac8b0745d596510bbccd640a626a6f658f56a88d334e28d49183affba3f8c20f38453df4c0e33fa3be5c5ce222d1cb66ede062c648a5d06bc78dfa2cee01cc57e4b061ff44b02167b70f22fc40b1a8de4844de23db9246b2e04f4b1e588febebe568f47672bb62ea1fe52999228a0e4908faf35cb498cb67e3de77a7ef52dab63f4ff57ea859255821409000afa13ff8d3036523b610ea9042ffb270eef0e743cfbc664f717ca91a49ecdfe7f949fa57b3d4bd2a9c83464e36445e2beade7530dc84a010056cc282afd220daa32a65d26c95419c291aaf3aa838aca00a467ee3e066438c5321e32d9546c43c6de8b0307317cd4ea76702981faf6b016f66cb0bf053c378b0eb1c177437dd5c502fd00f519aa267d4c4990b86e9b40fe3c574332f39455fe5c5ce1dc15700e024fec4c2828f5174035c2785a1dddd0cbaf35b280d57fa86019d3b5b156f28e667afe1d84da5392242edc07755cff4804cca28ea49daf75c42dff50ac9bf9c40929f29eb2bd183034c306900064c299104be12151d5ddc1f1766fd5773bbca9759e547ca53cae2d395dc1bf5698ba36cf9d590498c8350140deaa1ad3a73a4e6b44f00cdfb87d8f76d710add01f6fe1abec513d7a0672e71e89c0e12c9ba2c8197cab4bb0e5c7ba8b4266a7e673bc0aeb124a98e2ad7dc918b6353799504f19599012765ec5235b61b8a67b53574743158827208a1f61781f93888f3450160263464408ff95937dfa9138190062a7177afdd900b6b3c7bf0187760178824871e6cedc276fbad169416fd18bf75a3c417ee631d210815fe3126000278f63faa077fe51c2152b4e5217166380ff3bdad33c7bae5bd3ae47a3eafbb995647ee0278152c2d0b82d0caf444599506dfaa16448b681c5f8d58a3238615fe7bba2d31b861bea4ac5ae9cc86bc33517b3ef21cbb014496efa86112480cb06c1dc6416261a3e675ad42b76b665b3b8407bed90c207299bf4a4f88bb8d10f397ccf2f1d5257442a6493a5095349314350e7948907f96e545dbba6e9034489ff553535fe4f6fc1f440f1d558b99c1696e8b495fd896265d329039b94cdedf7cef20c78d2907ff0b200388825e23d7af3f082b43613702b7fad570dccf19b4bd5e6fca2419f13ec36c426a0b027881de9028aceab8fb11d806db3127b2a6cf03f070cdbc82850a564d3bfa88376818ca747bfcea07fcaf332c94144ef6baf37506a7f53f1db2a8739c871792676c65f32080ddb5796417fe06fbd47ecf9f95e785365a3135c8ca4cf9c0b253bed6fbea535cf2fec700c05139f6987b35e1e2857f3a919d77fb5c8265014fd46e8792ab314975d0e8830b12a0725ee6f8018bc4a9811d2660acd9dd2e6e07ff9bb1945dd96b514be598e2fa81b22391918cc07be8634af20251a86c76aa64e89e44392b759f7761714f0396f22fbb733d5f35b9278b9a91881df25302a9b54259bb206e199ea7843d9461fe5834ed84cb172a86c9d15db8cc236f902a8a5b3adf545fa1b2b4ba4437a8ac460c83070ff794b1c96f01e185044c459fa45d66b1ffbf5c926d6a8fd3f17b63276c892ca642eabc3e91692b2515db6e90fa3a4b2ea55b2614021b766a695cd01d763a46e50b215231a3b8b129b71f89e6262a0cd786183ac6fd197a0e35712a3511817881a4e09793b105a8f9443887c42519c112cbd31246e894bd7b6007804a1ee2e6a71244e58717cb1225e5aaa65d826acb5d08b8f8ea0864480f2ee651e41f2b030a9dd318c15a0e48b93b280b477c6597c87679d8d3beee9945ace4752e473dd58c001e4aa7c699624cc721a02ac87aede16baf0a609f2d6005bdb9be43be68eb725f4f7b8222fc27a733253fb667a9515f5c346c185e2f9db57b1011b3a04c18526573ef992065ddbf193e51277211c5a56d2a1b26305573101d5ab3afc7f46b083ab0f4d38237836d0c5c3675217267255a91cff384a7e9e89d3ef836d632241a2700caefbda089a71ddca83a546bcc9385f45b185580cda4a3707dac9aacf40e029f9f210470f440e5294cc1b8548484fe0b5fb3a2ef11d16d9893afbf2ff7524deb96a68f0e8e6dc17fad421f800229ea2d637a344f1d0c60bc8d0f4597b9fcef501f587ce1fa740a779f345e39085d29ea711ac34b1e14006d92c664916165558ecb3e945eaedb9c9d58b1167864db4c8457df4e1d01ed26190c68ca66a02430a1f64f9475abfd0f1cd74c15535c1da8b9eaf436d48917adf7c96d41dc21ad6cdfb481916ac27da75623e4f1f539c3f7b35d2a980d99aab08ba74fc0ea2e3a317d1b5e098050958c7465ea680a57162962759f25f66eee5dbad9da51d84e1847329a3b553be398c0b3c9f65489e5b30ee2c8a8e38c56cee9a4b60c187009c0545bf069b81faa18802697a046a87c9b75a719a773785c5cf6c5e62e96e009c32e0dad8cdb4cbac0ee146e17b2495c0fd7a2a363ed5e78c1891614c416a5d35e54f221be89f16a16ab4cd750a58954d9d43bfed3047ee5eb93e5ba689de0e16172d2aaec6c69b13ec5bde3216c6b05cd483820c3ce0700fb3077895ee90256eb635dec925a92250507b82fc56401aa567288996ba4f37f2c9d34ea7c26dc4b9095fe28ea4f4f69758cbf649214ddfe79767d6aa951b42cee96a377b7cd7ef407e7bebd537f364580491624b7e4b5064fdbe158b72eb345a27c619047942c1a3400015331c7805fe600f4a42e32dca368dd95a34649453ef2a2504be993bd763ae4d8ed866e74991327bf617994f9a373790f2f36e004c0f358516e2640ebf3f92341293b3dca2370566aa90f1abb8894321f04715179564b63e4305ebd5d09e796889784df116c70fb7b46a05410c8bf7fefb54179a515c05a19c0a3879ee3687c935d7056820ca8e4e403691a267475d1e60e5a9743e57e6c09adff4284ed3fe95503f7fb381c4b4762ca554b4fdbc63c9add99e1ad12485c059d8c435efc9ee86eff6a8fb196169fd63839db47672388dfd6245b3a533cb5f2b413312346e8b66ae4919b62626c4d4279433d0ac1780932e1a69d42bc1a1acd5535504ddf4441179ca06055b9d066231067bd2f5d80e163c3f0f5e9f1fb1d2bd046c7e8d5540655c9dc20acb8ebf9dae33fd3e4fc8d26ce17b218ee402f5058098100ff018008a28aec51811254535d8195782736c49972dd0e1d69e764376e32a2198f1ab73bad6dbcb37b263068b3a2a55a31c35b28242036ce3780b790b8a6e17271acdf1f865fc221c6aa0551e5134e9ba4d3540b9a7b358a6549fc0699fee5dbc8242ba226a92a07f0b77dfba257419fc9715356dc271b3d0919387c53e63eee9c7a2adaf6f3ea0e0ef08627f3adaccac575bd7cbbfefd707b72d997a2cafe576728a92ed0cb3d12c8e100b312cabca8a2df4636a4c3e927af47dfc4741bde6c5d466212177a288b68b926afdfdf9fa22bd64662eac2c9ef4a3e5cbcaa8f6e14cd5a7e93a1ffbc84dfcc4e83e297d2c7cd0f9fe379ae4046d883077074a61de9329c14bf84c6ad843be8d156110244e414db7e8643b91314bac201937bc4b7d37a711d4bf98feb18f03ec665baa51bd33b122aa9c2ec86e38b5353b44af85d23d93f465ea879cd35fc9730ab7abfde391d6e6c06c349c3ab56da4c15009807d1274b3f25b24ad5ddefa12b5974f7d788605ea8f17e426b771315e3f89df2e72aba3408a6209d5056fd5fc5d16efddea00590fb90d41e099fc2cf9f472b386459cde2224529048ec07245d9fa4f614c0f403b6529571fd00ae99e0e96bc0235cca3572676eb3a298b912cb7c3b80b526a27e838f801394a23a90ec7c40dcfb0899dff82e5e10eed49fcfbd2e8b4722f756299b36f422df8b80f32128f1cac10ab4c3bd675df40b9aa4a75f4cebcce524099c02d528dfc46b26d2ee6fe38f7fae1958561be174c412a5175e0afc34d514639043213af70385492985603ed1235a19e0786b1e53f8bda31219e570df0206e068eba97c74573e1a4da6ad9f364107208929469150a3632c9016832d72e919203ab02ce4e26c612321741fc7f4571b75b25d82e7afd2ddb6f4baaf1e5a241187514c40eeda3e0c3faf383fe796a6edb7632ce7a690bf65bbb0094c37ca90a2420381b3a534a897ac278c967bd7b4189adb0dc755ec141e1e6dcb1edb2d2cc29b0377ef2eb05b285b9d5addeaf032852030c84dc4601e1bbcc925577dfa9cea01586e060b1670f863275da270b0950071c53008ded8b3b94e5ee0781ff295c5037575c0fb855e6323cedc8c897fd31d8e5d64b862d3c3f3c4c7649cd7e17e2e3aa3bd119e13aac533bec46d93d76c8f5745c61deb7e30c3a37b4eaecf2d6d0eb575eb2dba585aa40205751ed0a82071ad7984174ac2066c677ad070e851a73009e2037d4310c9dab272f84b9cbcba6586c9cf6882c346e938f3b394eff126b3a0f3c03d6c0a960f68ad789b5b7d5ac471d16f9de7b4e8ba05ceba967823ac972fde13a54e49197133375049902112ab71f09bdfed526cafab5b561545568d9c5fe3d09efc3b291fe72d4ef42ae6b8e17b9415d9af539a49c9d5f6b35bab94e967e5055d111f2e49ba28e14a6b9cef7a0b749f3f4008c888400ea395c8e661ccf4a004f42288c07cb7bfeadd5f4020eabc1b2b59545ae81b6eb2aa1cfe8573f85f52665a389102c32aa3aba8c68e796bf868f50a8cb46c770dc3b85ebfd8da6a6a9867daccdb482148827d206602a6c79ead3ef2d5ece5f3bc4573d9e90de95b55846b037070cfcdd3cac0313a0ec02bd36273a4d0c53ac33c2d182a8b3b63ff273d5bb96d6b2bd21786a957291fc397cc4cc05bbe81f775417bf050a27d968b457dd1e4e3869748b93ff9dca4e2c2862dadb659504b7c531439f1010e3b2a8b467e5e8e8484f898ce482495bedd9394932c6b4aa16495fc82b2dbbdc88913cf787951609b67eda2663e3dc8aa0a3d449f550060cd5a2f1478021437723ee85728674e847fe395ed0009bd847fe4392e986b883e010f0af9eb92386519ebc957abeb17e8b675960230e8f6b5c92a8c08ce7da6790932c1f4594fa29bee6ffb38c4aadc001782be7a404ea235d767c319580704b2b6e601250bde344fead7b51e25680a367a3808659cd85f9dada7df0bcc4722b1ee4d3292b5153cc35e40b11cdd67051a32f53a7e52e462978d515d6e7c94aea334cf31533565310f4dbef531f7d0b7a6d7ec4aae534f808c9c6a5352aaac55b9cf5617eee31c72d14507f2b70c9efbc72febe08c135eaf23732e8409519ec0f097db7c98fa735a142fb76235bf85a6652fe905ab0a3024e396d288d819ce1ac614c878193473f924c2cf814e23e3fa8d9de41fc55c33dfd33bf62400cbf9b6037c451f4fa00f32538700badad2ac0a1836d1d19fa3399a1eda38e1372d1889a0c3ac7243864174558bd5ad4a7d590705bf5fb9854afa1d8737b9cd9b4a1d9979e5da08f4cbe274ad3b55044cb92134f1296b5c0d9ef3a8a020798e24fdebe34d3800329f60b44e00adc104c31a6b84f657d0de4491c19c34b7f532038ad852e32f16987fbdd63cb7f7302b65a0f14e9a7a37857c685ea55bbaeb00423542d1eaa99a4ed743105ae76a446e73a1e8a722babab23f125cf562f6b44a8e630c171fbfec168766734b0505bbea98db56711e627c53a9d24862ff5776304f31ef6467ff4ce66ad32ff4b3a7d2ee5baf98323f82d57cd9207e0665eef71f60913e05e2918e3dfb9fb5737aaf35ab3d2d3317c734a9960117a09473b7528628233e439cb86a68455604c741c5a816e0a90c6ee1538ca90f6fb5d62f8f677d6c03e0446ca01c2e94952ae5eab293a63625df214bd24f58f7425600c85ad9e04ab442cd68446496c2c400eda3864c5847b048358df043144a2815f938426000a1c16b12a5082d8cb4cd49403648d92f10dab9ea2b51e834e232c9562b8963c6e0bdba9539dfac7ee6a8cddbaad44a0cb83a27ac3e116db1a48e994a43f67b826383b89478eddb42c9cffec7bd7c216de72d40553bf0ce93ddb2fd271bd17a3d52e96481b24fc57e5477fede5b1bf9b316372c856e71d60fedab7e8eee85300f06343e3baf45cad3c7a3d74cfb127b27220640162943ef8e34811a1934fb21782e6a8a2aaa2b03625f27ee250840d0ef35f45259798b7856d5d3c451781669d478d226bc0b49e524801b76087de0aaacab7d26736488a853b6f5dc017f11049cd9040eb3ad564108ee12ab7c053691842c4ca56f964c0aa8ab0edd9f01438dd63aa82633e815b262c52d587f2d1e05acf4810656a965caf6fe0082527dfae71349f4120b35c9ee609623236bef04378b7f5a2d5f07a337e2a6c1ddc384239e06beb43f63657d1f5bc86b6e3e8f29d691c3a7b42790e6d6c90b918afc4378bd330b5ffa2de5b4edf6b13cd057b4de6785e1211a8e3be01f9d2cd9bb12ad14d4696191206698ebd0a7f8e9110404f93f39735501f3fbcdb9bd84f85c538be5773414b74d223435f455a450be02a0ca35481f097f09a82e8fab6e53f0a66bb6062e11af5dc0a1993199c13fa093e3b1d0eb709c483a7e228727a892a42cc726bc5531a99e633d9afc0b47bf71906eef0e4eda97783be0fe5148acf2adb69fa6ca1dca896e581f7a8054bc4edd666a9327a92f95485be4127723254df86a930bc6e7aaea108e22657aaa1ad3a26782cdce646fcd237dc224f8f5dce048570d94da73a538f1212c6da3651d68ca5dd71ef9269a7bd754f8946ca1563253b09303f70f62c25b89f9af417ff072b7d79fd32744c3ca8ee8079b348fa0cfadc45aa47d25838b6f3b31b51390b6801b51f85d86bca8f93b648df36a19fca2f60d61087985f03bb8f838d5f4c550fbb59ec256f0d0f02d7483b253add263be29a59a2536e8fcfd460fbf45ba39f1eb12622aed9adac395e603b8e46fc536bdee1ba98068afe1f4a79bfb90e90fd0f70dd3526b8cae1b86344b24d81f61f7d5720d0663e70e8268601fb8cedd43a1908dfdf747e2d4acd366d529063ed99b6437e295c2c58497bcdabe348f2a1a1829b3b209a66cd6ea7a1ae4b30097399b28ecc24260bf5374c2860a1fb8a5a8f8445cdaa72d085a17c113cd3f895fc0ee6583313eac695b59b876c7dac634932b11bea050744cc851aaf3fc17b234181fcb51626601f5e0c5115332a176705588a0edf96d8102f1e475825c9a4e19ea35f13a9e36f26d2aaf03989ee9e0d934cbb088211649069d6c0276bdc3ee00a3f0a3a8c150f29fe277486897edf245829570a40e514df907559cf63b44c4359a1140d9df09ae9f9114048ebdea060bcef18c7f62bf899df9380a16b68b9c7ee6cee29ac9041468168177a792e582884b256326637c891796b12a449d9c7a495b8fa76fbbe29b008852b2568360eeb34a1493d125f8b207c05cc4f52a58b27827dcfd478ba34b32bd93614a257952c04601a1e86af4f6d61fea368b09b9a93796497315e1e5e9a9484608433f53155f64db9b33dcbcf766911091255cfbadc6ab1cde79143e69da614dede5a388d9a77cd45c36c7646ce251db7126ad100fb8da9078c839679e1a71015dc7252aace7425dbbfa3b8f4da5690734470522fce446159eef81af4b2eeb0a5eafa9155f648434d8dc92265c7458ac40e19d3ab9fad4c4e83c4f196d4b50614c221e436f310936487bb6c39083df4ff58362b76e2e044be2cae2f2598d2dc8d94a6d81f0d8a72fd3dfa46c662cb006eecddb3270d4d323975bf5798324399c5936a60a6e8ca4a05eede76027f83538b1b1997608d9f2cbecd478f5d27675eacc6cb2a87d8bce339673751fdadf37971c903bf6cb195b9b3eea19191e4c1ad567170841509b40e180fd0d53f0778c474d90bb516044792c74ec599a8d90d89315ac334d434d114b65578c3f7e2321d2a7071489af720bdd02ea042d9132ed104fa8e6944e5d51008d619340204d474480e29e8430d52a8b693558a9383ea1d932508636592b6adea35539d233fae941508fd644fcbeae56c6e40828ab488e5cd6f02bfd6a96b33f9c4af072b7e443ef6ffd3b83567ff6d828cbf6c29aba7b8db2a5aa23935031cc0242afbb41ccf9eb8cbe2508ec9e770464a7f506756e801bf0dd170e5a4c8b3a66c0b30bc2f3f12e5634f8864f1d36fd6ade38b0504fe3eb41e66102653a0fcc1887be1b0b5dc9c47e9f97f6662324994c870b827aad698c640b2a111f356ca8de4e49e567107b16556f4e29a20c9869217052905980e7f08a2d9e9ba018ba8298e1b32880d6366fe55f15b5b4137f3dcd0ec35aeadd91cfcd466d7bed4110ef04a94f108c166fdab9e324e9b5ab52df74143f0837773197095bad0979140bcb7625660845f014fbe2d39ca49975afbfcc964c103e6fc15b33ee9fe92ab21a9e1f24afdf6e5caeac290a99718578a5b6250f8390595101ec642f0ee0154f5b275d3b82121d8a9bcc2191646984d53a5b47435e7de59c4dac02520153c1974c768d580d0b62b51d905d74f7b5c333f2e41cf80cb483924082589c1a14228ddc04ced15fa08b0e7abfd74fa0104099e41e3893ea4fbfa886b3323434b0a0af032c5e3fc34094fc27514b2303edcbc5eb02a7ea1d33ce353da3ce87fa73cb53dfd8e89f5aded78bef2a11efa86d41ecd4d964cf7971e96020c3087a468f7e389c13beda14729d4bf9c95d6d52caf725a9cacb0f021d5ac855d196beaa7db5acd5947bb7885705748bfe032b8e27a73bf63854c0cff4ee93a6a7263582da6f835de1bd14d1d987b81d9579ae9a7fbe38da974ef0cd0701245545f60f83ae578bf06531921d487d41485e6556af534ec8351570b9518817d19050eaf3106b2d25f1ec2b623a4714621272a373fd7ca024ac329a08211c946fce5e3ff9b0224d9e994b158e45439d3b189f190c68b443e547752f9ec20e713c25146ec9cb4789aac25379dfabe489fb199783ecceb6bacaf81900eaaf6a303aaea41f45fbbae1eb1f981e46a37ebd9cfa3d60762f2ce07db26f7db8b0f6a3e3f664103fb6fbb45a6a932588652c329b7f973ff9689f4cdcae4a50970f0d76053f0fb65de5650fc4fcc9905f0178664457b23dd5f956e58641c990be2325afd25a5c2665c7abf5fa9c0e7e205e872f8295fd3cbecc0af7de7b3833907c5af07cc995f573464419f37ec7b15cfa6d0fb05fa7c936a12e2885cde3e553c7be39ba2721672503d9db7191b7f4f3718f503514ef4ce8bbbb673b20a13fd3d51831bf7fbc413bc2a34d0f5be9b29446786091c92ad4ce28fdc9afee0073607c61939bf4abcae33b0f9733ee2afaa02939745c60750f5378467ddcc1db5849a25506ed669772c52dcee48d49f0d1c8dbacf397b8e10d1fcc40acf7e9391d53d74fd84c5ec76be17bce7d45c29489b392bb260cb4a30711f78d76e0b37ece3aec64498eb20fbe22ca40afb9f8fe78d28a9eda294b5c8fac490835608b5bddce17bde4ffe51c5c23bb0bf6828c26975d832046d1a693253bec6a24a29b954805c95aa696b5e1d5ee70f992935a01d070e68bcbee078b2cb9888ae78e4a4c6752df7c0760b43981a3fdbe6247ce39b6b2ac12977d81bebaa393987d21b3ce005026be63ca6e94eea12790658053ffc69bcec7402f3c9b9d17bbeaf8b55bd26926ceca9f60ae73747a6dc065b167eee6eae18d5db98f9021243769931050fedbd0b3c4c6a32a2ff948e9cfa722a26cc61e20ebbae60a0a8f0f4087cf7ebb4c06758d1a934cc2a68f07588aca3cf79bb967e3f666f9fe6f9dc55ade181bbe8e73d4f2bbaa7f98b718a33db3cd7e7cac3766c8f12d606b4b5fb19c1e405b37a6384e7be12f4ae3805a93937b1e4c1995698cccd46f69f6658f2e91a942a0361cc2e42adb77218882ae469bcfcd70e5ca7c726ecc8491bae790e8b50c3776eb0a13eaceb3e071868b93bce12f0e5ced99c73a9c9dabf5421c8bd66789aec9ff4197f2ea1ced3a3bc1d8abbc7815e852f3d4ac54c014f77aa03075dd1e34b9c98dc5a730e64e4adb34a64c113baad8923b57d0c0323d39ab38f3d0b8c58b9693609eb261ec5bb0c1f85184feda48723ab11ed56e41cf34e5ef9fd1664b357e586d57c019c75e1605583c68cf4428c2570fb7706d868785f9f24f2c286141d0ad5ccea641349f3532b5d0ea47a04e4757c8d21d1b6055bc46f6d62709104bc2a01fa62e49c32daedd8855c72bc1b7357a533a058ce3d9d3dae87a4d087f95c364f8beb1317c7612a503aac697b691d997ca50f7c03c71c680107889635b671fa93d4a7752f78869c8bfb6fcd59fd376eb4433016ee7f9d748ee230264ca5e69ce07f7100aca50fef867962c665dbda26ea52a8851058b7d16b029ff4b43d4f1e13f28920f81a853e1dd70a5783c783264173f3b17567e6227fdf94d30b5174dfc57742c2db6c8de71b3c4d86d216dfa3fbb1370473427b95b8024abf00b945572066c41012539a0256138b0a6a854b678a2babd44d012af5cac69cde680c34ac7be841fdf309f1f9d9e6440c57f6df29e30754a14750a27420c413c59e5b3f8ddea0804799dabad6a415c78079a32fd3a82f78c75c002acf0d9ea101e8502a210024dee454d628c308fdf373ddca48bae953ff91cb204a7729553949d666df9184e076281000c0db38e97055e29ec9bc3a4f957ba651e57372178b36c78fc8bfc6bdc5bba01cbc69321f0fbd07cf75f8f11e4776b613d7ce998acd995a2f4aa9d280bfb1588b01d3d66a01ef24c4c097de6f4dc3bd7aad6ae6daa3dccf1fa0c9caeab4f6e800ba7ee2935360f32753ac10a37994656dfa8dcd8690e97dd1d837f19fe25892d99787c13e15f87b4e8df791a3eea9ef3c0887f6ee24434b94ccb204ed2c1cbf00537b76abffe3face4aa5076d0bf198ae3e39aa66fcada9e321cfa078c9053fbb47015a2e733e50e4f9e03517afee43ecdc4210c1e5f5b32e2816d4da3a967ca87a130b1372a234c2b5cee08623260afa4b5162439a6bdf94e53a612049b7dd25da4672f5c8c991e87fb37baef51f11834a85e676f5d5b332106f0b4688179a182a81a37641cfe86ed44e52737b5184f52603a0a9188e1ab5571b13e4d611b47936c473a62ae813f43d2da70614863f0560dbfd05d873f26eeb71297c66a02b9c34544eb3bd947e1b9ce1c325d2c708126f9f4a0c24de306226930259b6467a7e1489743035b91c3d9d2d94b61e933645400f0bd12839b2b53ecc430199d9fbcf035c73ed5a3fbebe7a7626fda6f3a95c39bed9813f6d57af7c98fd8e7aae57d9b9943ab60f5aa713d2057bdb69b95f13168ebc0b8a11f2cfa88d05d152220f95f099b6f6e573e23fec58dd9d5050a530fe54a8e201828beeb667faa1577b9d6ce68d8a64dc11a6a9cf906f37be6b859eff7699d936c3e563904bf99d0c928fef691629082f141588a7deffbf88356b7db2d5f27313a14b7c255aa1bfa80bde9ff520bbebf7a1c13d1a17107ed92d83d75621c1358e91ed9679098a0e7364e2a0693be9579ec4ca23ef2add895bdccf9cf01b0fb3c79f15caa8512afc3adf22c90e16d85023d84469718688cd7cafb55040017e231e0f4e62a9fe3c7d2c970a9c98a717530d3924e85a593a179be0d9a489ea21f2d30c5b14d98468b5cd4c20fbd3dac5c196d595aeca04ca24e0df2af60264061e0e34bebf95b7c1b9f00597bc644290057120528ae90288f24d6975f90d08f305a495bcf7961c96d86555285edd775633a5b96f9d60c4985b92d4dd31a371ad817b5869305b2a7b4ea29a3dbad1afaf633f5636f053e025aa2fb472d8fa846ffe81efdc8f5b3ee695a77d64b8b10d322289839beb8bd16c6869d436d593f66cbbfe8b3f173b147af358638bdd44ebe6420f446b5a1aa4a7bd069920cef8a912544043b7ee3935ff34a2a2abfb10d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
