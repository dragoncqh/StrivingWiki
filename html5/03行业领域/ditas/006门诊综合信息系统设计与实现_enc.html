<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b68c923c4af4ec87b8ede1f8fa8a95a6e7e7d9d50d65f2d4089cbd73fe0cce1cf978d8ce2ed6fe46eb4bac98f753dc5db272933a3ec222c4d9929a23c704c4441ae677312a9144213db8c9d8e5af8aa2d266def73b850862d037fa3f0058385780f8a69a8cb1523e881ab6c3723b1ed1231868a6068fe0c3e517db92d68241d327770bbb343c787a4e77c504185d3e4861b6f7e8e56ff7997a85d70b57e97976b6aec480dddecaa17817b854d373ce24bc63d9697e05d5c3a33245d1fba55d04a25e1c34c244cab2daaae7245b3863d1351cc15b0a75cda268fa5ecede1f8ef3a94262617f7267e8ea76a839f1f49676b3abc5a450b5b18eec8c51d6df12f4d6f0852ff7fe628ef1938e940b50787ebba8e8996edb3ebe3bc250b47fd0c1527cba33e56e610179f9a7a280bbd42f9809bd0ac27aadd51f1589abaf6c917c9ab3e0d9ea8b83746bca6149faafeb3a27dc889e36658b7c75453f3dec80ba86fb33a9b802b7683ddee4edb3f12f9d7463236503d75d0a9895c6ce5d32d4f4f039eef3a7ba93822165e0d963d71545f4650851ae5a7406bc24984ee74f83bc6bc0524e3de54674d1b1ec74e82af117eafac9b28fabf7083dc1ce17b22c0049571a9f3a994e392b74b87285456d29956a1fa1763676fcf1fecd49587a2b623f27f2de881870acd84076199c85c716861e996dd27b869a3a6c25f0a00f4d2d8ff7d5be9227d4c6bfa68a76b1746693c84ee77526d8ea1d8d75e7d2c00544e35197ddd8e8514556e5c38b6afeb802b2194a34481bc9c072d2098a0697dc50394d7f006c500e519a51b949d48d8ea1ed9e22344ae8fafe2a9fc9dde5f701a443f1fe38127120f30cc0453f4fbcf3a75a7a5b2e62baca9d3477ea9831fb649f073e1270430e3c0792c287791e3a2c2b600934830884f93309fd8ca40d88dcbb912f261f8244b0815b37a04e320af4d69032e25e485b9a652d01394e5d4c0977c68b9aedf6cd7244d3163ee6b63cd49f4ecea19e558832801c6122c582db3c8b3fa7e6693441b7977ed5574f412290a5f4bff71fa291bd380744451150577a9ab465a9293a3d1b92b7f15f01116ebe4b6b5b282e88b926463a8cfd53908921027be14c384fd7e07594a575554b0afabf98c75d40f83ce330c41564bbe88326eaf0e9d3fcc54d93f1fdfe25fb0cf289aca351d57489a102b4b874e4aa0142b54892b19d52e0ddd80c81dda74ba869e0bfe47ff3dd6b0e681ce952218d91da064269c7e2a05b5b50fd1b6ca6748bc09171bf8727a691dcf0c9a40d13a9cbc3341a64def8a3b7fc691aef94d03582d273027138a756e875d5f9ece578aab0f097beeeb3daa18f30258e91bd0ee57c1b4e34ab24d2a419a2d20b25f998c71040ab24b0ff222540fc0416261b91d2d65c374384eb72a590930bd72cc678964de3436dee07e78072100c3587eaa9bcee51f246d3effe1610e9d269d3de130504c550e650a28f791fa44c3570312259a0dce350180aba6ecfb3e5846662537e529325671ecfce0abdce5a3041be8393af3978c3bd46cbc565239b87449fb1fbaf9fb55cd6b8dcb776de58dbe9a2a35bf6827bdd0564bfcf557620850498ff365929b16e2191de7624463a277d5c54d38c57a7028f94a736d9878f6a26d6cfcbd4961e94c5d63860a065db0f778e24e0ae6f27546e900cce2f700c94e4e871886c362f5febb8b6ee4aa86bc129a9434ab493610b5d00b36c9545cfa6c8958cecb7b25f9cc65d66113801efd076624eb9a4e0bea3e963f55776310e162c563448f26be2c0dd6ead74f939d08b124d21a16e16437f28c12e8394fda5ed68a2f4b8576432fa7c4e60e3b480f5a1856dad67c2af6a42a29ab158a3b5aa0c473eaa7e879a9a75fea3df87fa06f114b2ab4c0d4fa9ca5e92d23d3c85807026b37b77236e9a2a80877ff37ebbe2fbdf02ae1b1c959bfd7d1ed821037127434158fc4125c2bafbfad61065eb1aae4ca3ad9b8dc0145edd9c0345f7d75c7eca43e2372ffeb9f290fc791f45b36d1db19a7196f9075d3dd5d3a779de5a86f852e555b208bc95630b6891bc5eddc68d19d8b0cc996cff9cb0196c9bb15ce56577647beb140176eaf121b6fa0b5aff53375de0100097f1a927d9a99ffd1f051b1f5420f3156fc75392f2126198b1a6188de9dd4701688d353fc5feede8b256bdab526f2918f857b2469c37619afb605e3a05d761a638379210dfd671ee0da0e64e8c8bde8ca44adf1789b8f2e900f2bac6a9d4731e605b9848f0450680d26f225b403cf8b9b4ddb2dcf871db54b274b78b2573351e38a53c6aca4b36cdbb14952197b565aae6542180bc58ea83d9170dcff2e789827e50a5bb22b91c8ea9e898769ff621ba554514a8633da77c4273bcae1fa9b837b815e38a9fab4f5980c98884f0b469c3d5e569783744a58b59ac8ccf2756bdae45cbda97235790b4cbc331fcf0394ed67cf950cfab2096923588d37fe6e078b14a23ca866b947b222c04a1160001db9ca572895e5398cf823f3a663b10c7f339e52e9145fbd11d45a85d9ac9db787265d1c5c2d520381a42c1f201fd27b9c594c3f0ad64d2f5bd6ff7c01ce1d14ff70961cd11efa168465fd67a97965f1d3a06d89fb6eddf2accad3dc7075e1992d98ba2fd478c34506126e4f1f1d0124ab6dd17f80694ef4443354eaff8edb674265b2e875c7ac85ef83e91e8a640d53f9762b12fa9f9808bfde913ca510c69d34df567ceb5672e6008528353bc0281fa408b08235ec13a7ba5f5c143ce297d3d0d7f4bbb16a0ddb0796c40159651941b54a9f750e6932079c99b48918ae0d454bf647122b3ac016096bb794ce24abe28215899904f353238db02860fa6dd24e78c4e7f2ec864e745126002eee4f8793ff482cde2f65e6cd91db9924b1958ce3059aa404483d454598d393b6a61c158511b0f09739714a71f37f8f6502c149e5b74accdbc1b0c688f0d9ba652d179db0b9b08bf2d890fdc7dcc96e796e99d6fe2912cc1622d9cc7bb628337bf1202199d9a5b24f4d4c028998995e573a977c94b3477524f04991c4bef54390245c64c8264bb8f2463fc185a385ab39678119dbf2cc26e74ca742bedae56889daa8375aae8d1caa3bb8cc2af2095df4e6fc3af79b3e099d10d66a87c30e0658b6003b37d96d65aee79278e69f9f963ebf3aba772a8ded8f797bce90b7d4875f6df80d19294c0842c22adb9e92abe4b2d37141288a52c7f5163668cb736f261910d43430190bef879d072e78c2177afdd184c0e7e30debc83fba13a1f689f3c62480e1399a5d5d5bf0c3c04af8461386c2d49e93c272f904f1008dfa4763b9cf9e3240953c9bbf96484b41ef43540698cafda7be566d72678e1f35717b49a6357a6275abcc193bc00a72f5e49cdb9f9c3c769f2ec09e3000106adf4f8d25430bbd385a0632ef732ef7374e95b0b72e1c38bcebcb67e69fbe7e90013c6a4190074a682eda74259aff5b54aaefdb48079c077227fb8e5a3e994010d6565010734680c9aa294c7b96df1e05f65303249e6d491ff8c7d3b5d4e89481a4ceb533e6964821bddca92d7b056db6207d260e6831374b8dbc6d7a903f6f6c407a1a5c33d08913e09399033e31f4ec164af6664974e90afbba440e51c4140e3ae6b9aca32bf59203bfe3e222a1263e78e291ea87a5dd7bd339b483a6b87b825ffead3af2d66791738d709d727175b5a340f3124c5184c0ff9f40ab9e9599f2ad1da0382dedf49ee3bc2cf5df8600e917c60b451d7941efeb95ae1baf5848462792b7271e76925dfd01f304bc1d036a00b5b3c3a3baad6e01be70a75786d39f91975f52d36a1e50f5a59e67e4d1a6b3da5962157fc057c3afd296ca290994bf681e12a2a66eca8b2aba695dcf3422e8dec6773626cda2289955dd96a16e25d0755133cc07657680a0cf57edfdb519157e59d0452dc6253a3132b3b5fdbd2d60a6592e96d3ca9008545ec61dadea9fb870770c19ff332a43786140529299ec7bbc6bb4a2a1a01b32fac21889201a618cbce163ece639dd330b4220f06f1864d42f21a61d0e61eea5fbf5550c15289d78b90474667c4dc8c8bc170ca462ec1d7fd4aab1824c2036b248545016c2049e550ac468ac02415ecc8bbcb0b84990bcd74d0b6ab0705ea953fdffb2e462b760a7ba3740a0716dda77aa59e6aa978f14eddcd24d2c12f61fe52f186db50962e7e0da8d57157679ab4c1e019a34fd221a2bab8f1a55e4607f227e06de21a01516dae9b424d74952278b600902a5c5901a118d941c76191442d120c5bcd2b20ef86bd33f9093d6b60ef0192c144e08851e98a17bea3aa743db36ecb84ad35962c15f7b0db55b2ca90b7175679125e3102888315b9e9da61c8822cc3a361dd5fb7fab6edf35dc25246234d895011fed2a4da4ce595e35effff0940bf2644a393b5b180ded22d2b368c13a46a15ffe7d52fe317438df9f28a62bb0b2517f56298259cdd28022635606f540487e00f1e0fc1901b09cc29116120cd3905395b7484e7ef25d7169258ebe18185c4b53fa01dc563b88e7e2878b04779d317f53bae20100d270b0b27895244e08a32e7950998b5dbc6466d4d71ffcacdb54c4154cec9f63e22fe4c95e4ceb49dbd1bc3734d192c40a8f0553810a3c49d6aa48e26bb25e759e68652a66cb5796655bd504b7e2ff070766608340ff70bfca4c7e1994da59b9f4fb495ce00c2439b0c66e93916c84bd296b8a5ac38f9b6ed555c1e407312e6ded2d9ae51bcc03e2eff9bc9c4b4470e52f912d0afa61fa1ba2728fe4cb23e7b700445c5d829719e61d40414c488a0e289b5de70ccada6ac5584fb8f93919a8cacab51c2cc93436ea1692068f205028c75597f78cbfc8c126d32eae45d36d975f702d98ab52be058c348008c47350b28bf28148412fe718e9e3d36d4c8148e367bd1c64344a44df3c9d7c9d4e700091ed8020e7e7cf5f95d16fc88d0116d7d12735af3c4dad18f71f4c5d7dd3cd38bc8dcae124579499388270e10b703772271a236dbc720b4ffbfb4f8b43e81eace8166d587022314e31d30e1ec8a8f541212ea165064822bdee087143e77246f2728c7d48293bba08b0c14efade06aaf0f137bcce44da9a094a3c2c3272d343779957199880d5d909c9de1ff3e6689d6f39b57411cfee2b42f77e8605b56cdc400f2fce8fdfd2071652193e93e6a2e0fb793f5971d2b8913ea1b5b14a281c42cc5fdd4afdd35a7064f838c17de2edbdc6e3d869c30b83609d7cb6aa01289b4c5fd8f621d7671e6e449254edda8213ef8a64bca86e9925399ce3aa0e42c088c681f6852f5da3b4be68e0e45827994777eee9455cb0d70025b7494f6550ea119ca5d62e67d9ac02e0a32f4678f219a3354d5e762c424792f53c8c0de1f723b1a92ba138742c67dff452a3e2e211dbf70af632aea6b2357a841a02b934925d8c7051761fd426e1273225188b2881aed98e0aef2415cbb1df27e57eeaa62305c8a914e499c711f874f6cafef8a9edc7ca84c33c238cb75bb6d168dfe5614ce922708c656231cfb07b1b3374848c860c57f589bfad64028a83fc4943a6e4af5578187f51e63606e6415549ca8d03d2cbd71ced278fbdc6c35319bebb91628988afef9de1ac1e9876efbcb36c9de6dbaca7d829068d0071a23f9d6b9d69c1ae567dd9514fe4fdaf164be4412daaa37a6df077dc9ca5bf040109f591f433dd3e2813d499ea20315e9077f6525b4d64af7430d101f3e1e4d9428a2809b9320ece31b6ee60b193efbc59a6341f1370aaef00e2d50b60e9e6411b82487eaf9da8d840996475fb537f31f589c3f51a8343d4db71dad4bff01c64c1fdde94533a36aa064a01532a662e04e94b74e9b9265c5fe5e0109916c5f84bead4d2e30a1505da2b15fcde66fae3ed5bffc106a4c930b30d3c2c7dc0cd87c2bd0d6a4a58f2976351fd2d7ca50775e5ef6e1da6e41a1fbfe4bb34f6ded894366ff3eed1890e8400f2c46dd0264abdb382bba9e48c417db5f237de0fa68e89a886da516152b0cf8be21be9fdeb03783cd6f9c2da9b36509161b7091307d47d2f8b148bb4ca5e5060d1e968cb385012e28635e41100eb11c8274d6b9b5eecf7ca4747923b643f1f067ef7965eca67789bb5a679c10d3d0f8dc60d0dcd64506508d13102d9982bae76c20e3298492b5b7f095400af3572af3f1359c087376c2fabefbf95a4f19cdf6df202d5c906c5d5dca65241b2a216f398e80b89cfaf8a8edcfaec095c08a082074a626e2ff3884a7f70b7eb7c9b396d391f05f4a1a545777a469072a70b6aeedf1bbd62d63b4b8a6fdf4499962ed27a15ad4d266635950b24450a5c179dfc5d6d15b59e53a3c9c60cbc8ac8d7d16cd82dce8dd4152ae1bef2ea226f520b2950888fbada04f6707e2d04fe7ef8c31236fd9c46a8f52f74f7b56b97de4a43fd52115b6c69fac079160765e518c668ab389f49ae62efc540ce0f453293326ef0f0f8bec4c819c305a9bead9853c0e0a9721ec5d1da4d2ae5313f01dd3370a6a74159067fd06c5ee24aa88dae56ab0648002dd38eaece70aa32cb94ec2cb48ca552ab26c98471fa26b55a06553dd5cf4369dc570a7aad7b5a31511262f86761585e92ff40d7d6d68f804c7b88c37739c568286ef6e2cf67771dae45223a1f7a40e60b349076166ee308d9bd81e80b90c740be8ec52c1bd8b3cdc3ecb3bb1acc985e1a3042be38a5bc550b95770d1e0e545626b08d24c55aaeabc3c5549e358b119f06875516acef7616ec0a4b0be1cc00c682eebb7b71b63b146b1e7318c4f0a4daf3efe5b343f2a420f6276f4dd753f751978871bcc2063d333418199aa45a5ad55d2ff992f7126f11f57d54e9d431a086bde6f9760a8d190946453e17c193ad1870332f9ea2f0a023cbb7458a93698f76a48839f0563f55894d0fc6c6721117e55158bb21323a0bea3d59224cc1cdef4a4385fb6dc3d6759a41be86ed4dcab4e60788114ce502c566d06947441b17bc4ea90979b0e6ec06e08a9d33087d9cfda8aa88b89d674c8a394b9242e67cd9699de4c1d1a0424370e8b8363f2428f7cd051503b64f6f5b98b657b0d47bfa4ede7376c9fb65163ca3dd444fd81884f3d3c3ed5e700b05a6158839a206e9c770a806858ccf30546682f22c4722fa02aa61ec77eefada668cda210558e296b6c4295677239247653df912e6adc36ff68b663a69093df63e9d92783230c943c3f6ff3e434d5e3b0a401cdb0b60437f6cb0a402cbdf61156a050b1b92461fed47ffa80ca75fbc92f713f089715c8a9b5ec08574a6b4917913b7974bda6f96946246ff26027c3ea5ba4a689f6b8362651ada4b17aaa1f205c2510f22024d807ea813c2e6bee8f6f7b9695b3799244e826f52a8c2ca1a02493eb605eb6a673338e05813432d4d1eb2dcd890a3ecb3e09a666601339957f4b94cc777f6b7e202d99832cd072556adc7de50a8cf9eb26134d2ee40bdef6e19b19174cf8ccd33536ca7b8ca1e0b20596bca3f909cbd3004e9c23034ead817feef892bcc00cb2a04900bd3648ca52eb0bebb691c5112d34e0d823be4b1ee0ab65f29e3579c654ac4dfd84d292e4e2145b5ecae57b9e7f1e5c14075b5445771ccd2455976cf7cbe4448ab1683b1436c20ee999fc8872bd62c9ea7220d11d1ef8bb960047098e2253a78efb8d5f40069f165b5b0d396cb7985b64e658f03b260fe9cee20b23bd63908e621328a3a6b614490630b43d1645d6754c258a781f38ed45dad680380adba23567818b9541265749213f45a38feb054a8db175fbd1e9c65d80f6bae69b471d87576cd1e79dda558925eb2f5ef008f27b19d4a768506fd5661cf0586623d8e8e83c038ba4e9964f257ac5d68342d32af7743cf549c40bf366eca96f867faf685d8ab3da0c738183d5944bceb9bdc7f0184d0db195b42ca546186f3251894f82b8123f72d22b29d82525565fc5578086c6e7d6abddd8a754632064db6bc9a2071808e9c445cbeac0dbcc50c25ced4b85f7b71f1200bb7b24f7e9617f6162a37bd2568d00e2f2fd8c5e97dd2ed12b03a4c5d2a68d6d163e24e2bf0289f1bacefbc5985c7c99e6a95650810ae65e7d6ee3bda03ba396605bb516385a2b2d6f0098d75bd4b9215f9c9409dc9ac877372737f5da2063b769ad783bc39fbf1107372094b76fdcd61e9fc841f16c2e853de8b2c5dfa74bd9c76515900d64f1bf7f7770f100ce1026c19086a00cac9ae83dd5f3a986cffabb356184862ca38c7ef7a10cd4ddbb75d73ee8ca56ca0b663154a900b272ae3d128591c02eb805deeb7fec9e06bc6e5cc8a9c65229617142080e9c3c82b88547f74db180616058073e138830f9bd71a6dd58e5f1b1cd4c1181faf6bd3882727c29eed4a53ec442bcec4f1406c9d8fce66964f661e32674851d5e986a3d4e2754062b28cc246a95f640e16f6a54b196e73975382e434a364211d788e3eb0476b032c53adf0d438a0c89681af779e6874ca129694632c2a984ebaa3cedf11025bf84101ea663b99d380e5fca7e383d3fcf4d6431fffc804585934a0e911a13cd7267f075a182fa150aa9c4efd9ec2123fae28fbab2da590ec098ffdda98fd82657cfeec7e402b21ea67bdb0917e38500e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
