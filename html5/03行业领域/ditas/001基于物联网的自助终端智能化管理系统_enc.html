<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d0b14dae3e9177d33f2c7f49e54bc459bb475e0ac270cb32acef74b9b45ba12d4cac9ce81d685d6e1b90c847d9be6a0b998331853fb7e3834862e31bb5be6b7c422bfb50ebc6cd138196f1a8dc890410889ef2707656727c76f6106e73e17cae98c741ac05b256cc4dc3f7557e570dcca1a321e749cb5105dba89f16c8fe2dbda2c656839832506e3529002ad29c94b2d9a498f8525618971b0252a3dded766753989853e2a4e09d9f0c738b5f55efc2779157cc127cee5c0d63873ce265d1360911d7fa19acb06e84093d7a535cb90bc87944dc80db11020338911f46a08375d7145793933d4cd183624706844ae01afd81e20db508e3ffbe2a33f37f171ed5035eba1ae1ae735d6970ce14d9bb064bdf0628068864f429836cd519dcaab6a9d87e7ee9ddc9091bacaef177c0d2add0f4f1ff109ccfecd9fd909430985fa473af8ed5140d6c27be740a0761b5b54d25cee5bf8acf61de655583a773f662654e4a025ff371167714a3a4745eb04a43ab796061cea7f6efb3517306102584abe9b14915b223ca56eeb0bdd51efc1d932255d99c936bd214c90e6581e89a30f4e9c23e63e27aa3567522be8f329f944f4d22edbd75083ba6c80c8b901b7ff5c10d105948e7ef2c8d4854195270e0e26a0d00c8c698296684b6917f5eda4232b478494fe2b702bd96c4d03eb261504e355a6bb4d660324287f0e5b9b81dcdefced17c10c0b1c218ee54928267d52ae55fd44a91260c22c866d97518ec8c64173a19e0ec9b205a53b716f27cd3794f0f73e0225e6fdbd3dfbfbf3f8b9a391b1710f1902f045cf7398f0dedeb36cdbcbfc01637a89f1f581fa8f599f8485e5db7b1474ae41827a675c6bf21984a3483cea5b595f8dd963633615a08e4edfbbd90816887c4e59b2c272146c2d5a338e5649014160eefc7efce4f835b224456cb46c87083046565fa65718c0e96374a94eac6c8337d6295982a73e75859e5af56ef7eedcb1576c1d2d1415743bf34595448c621616f1f224f50e94378ac6cf367c130484231389b0e539472281533ed30bb0fa08f6909600a6510631232f255cdd88b6705e16361cfa80a66beedfa20f36f7a523d1b2f5df888cb2aeb64f123ba3a5762e7fdbd2245efb7c9135cead6eb4388d12eaebc6e41743069a69be2a48d05a90cfbb57da8c1dfedca1428eedde5869e8a76fbda578e4e0233eea410d26594728e62d0e078f028f47a910636766bc7871a4ff63c267fb91d437a11e7adbb192a8a13752cff61a7f6e3f76da2d8fd475b7155ce4358309582532d882682c40dfff7ac609f2ae9cf49d88c4613b884908a417ccf0315442ceaa6300887ebf79987efa4ff4040f77e0f2ebe3393d80b787fe7a35eec753641563a8b0e2cd67b4394cf4716cbe7ca2b756164dfa71a6c47ff8d97aca9365b6f9296de96c3427267a247bbb57411ed3c45e70c543f7f870890bc502d883cd326b455bf4f23b41979becb446672fc12fc4a0eec406f0d94f374f1161ffb1f8b8dfa2936f80c67f90b3fe4868f4600359640c7d4e1c2ed0bff0f95f56e181e1f82a33ac2ec4dd959efc31898dceaba0a383b1b77c15de6da6b10b4c9c721959e6083732cec093d815a8bb10f909ca65f1853d3a13b0114ba0c468245621c0eee27db5bdc19927c8ddc50d367355ff2315eb1312952edec2a6d981f77e830465036b39d33cc31a97b5c1a4d49726c65ba398173671f1c04d107bf0d0db31609c2b586172458423c3d36ea65cef3a0abe9a4b0a90ec4cf7f65bf8493dc15a16c693528493589ce332235eb5bb5be9f347d4823338a245b821501e0a65d106e6a1f24f17291ba684c4fa9e7cbbf82b6d5ddc8dce6d7b139617c11914e46614f8de46830c57f54f2e9f00fd0bc733ab943e4e0ef815f54d8dab59c216886f27935f95adc6224e11785d3b21febd0ce8eec1dd057bdec3a3b319d5715143d06b42ea20df80634282015dfa71d5b3feb38eb1f019f9f86ee387e79036eab1c44002b7ec9831bd25b04e0ba38c9e89594f08f81e2333769ed9e28a5fa25885bcc26f9625aa7eb7bf44de8e710ef691daccc23d061ee4ebe2d9278a0feb99e3fa3e93f65d0ea3b93cce1a4f34be3700ce14025d64fe09e24b86403f6535af047715f9cb0bd06f0854e38233bcaa25cbac6ec1e87544d6e5a329c70edb77b7aebfefcba59c7f95c973d2dafcca2728b6997ac84f7f0e28299b498a7c1bd154dcb127922c64b705be030789c9323e35eb31df00b35b1f7dce8346b985dc13548a981796bae887266f166624f345533712e0c684ad8b254af5eb776e4c11611960b59bf225770f0984e4b08d9ee9c937010bebae1158e08ec3befc5579ea5a8874641388ea69f054f7a22d0502561f6c4c334f0d4f39db4613333e22d7ece6a0fc0300fd17bc01188ef3955d5cee84581541fbc8b1195fce75e8aca55f4df186d2f0307307f321535c64c607a6d14f62da0d3b17354c823eb3f456dca724e78ed67899bf0e7116f88c93c2f5358c0a67806abaa68cf7cb30ef9e7fdf475e63637d5d629e86e6e6498eca2fb266fd71176c020e06214080553dff07583929b8c6df8199ecf8eef5cdb496d12826ad20905713b149c5a105a37ae6b3e1b805567022bd3845c62e000100779d5f3b85aa0af0ec7032cddf4c6b37e5726a1cddcb5acab2c9cf48df60d0f17a4c6351106f35dd4b182cb50839c39924476aff1ac7ce19ed68d722a8ac27d0cad9f7ef0ea13d7a1c026130c1efa25c6cd1afc580350b2e974a2bedf866fa0b25bdc486dc29119054be22ec81af04937413b38e355d66061d987d7c6e8656b25b534cac1b997a5e2d7d4190c7aa3c6b65f73340f0d1c2e1c92daf5e661f9775f23a94a6ab351bef875d36056e982bab68886caa574061396974e22b993608942ab900aa994e7936e4444b57eb323f1b811ccf80379c9e01823224e6e6702a401ba6b1ad6658bc4356bbcffecba81dbf30f154c263fe804f333be8dd55f6cb4e7cb94b663b5d13175e64dda93bd080dc9f4efd8af6720541909c3036ba2f8886992eff910092c32eeb9e0f33ea0ad6a27a55772050a60c73c7da50889d87ded94ffbfebac361018e3779a1c36bce9503e4300d006aea2c6777ad7de61560ac3b94a14441ff83d72afdb0b0bf15bd57b94e4fa0d6e0a031630dfb06a689254d119a98d018bba434692502045bd764363e0270ac20f0f845f7e80233392d8bf5f16588fa841e2d54e6c3d3a18ab1a278585f05e77ba38cf72314d6a64aefa1138bf8dfe3f3b922352073349829ba6fe9ff7976e3b564bf323182a63ccdfc38ed612f193b8b27722543fae216ca74e3c3dab1423ebe6251239b90a2f939628bd10bf70454fa1615b4d3fabbdd156d1e2e30369b51b19478e43ee8ebb4c9c51439a5021fcf39daf0de40f28e31231fc8642aa53100a9ddf1ae6a2c86d910d064bfe91fb89ef71693990cb066297c3abe8b609f409c9f8790ed435f756903cff50d7defefc27098a29556973ecf0d6cac4033c7c6a144a96de98eb8225405ba75d2a6d48acd4ed69eeb2b812928e0ba7f24c5d6dc8ff5a95fe2cc0558fbf67ea413a1178e9732b6ae4f2bf37dab6ac5e9dc3426750403b449f038ba1311556d1a44a0274723079169451d011be11f49efa72e7b7a9b28e183dcafa3e5568089d1edd3a05cc63709e84262eebf1e976399cc0fc9b849648b74ffa81f1013443c6d5aa2e11e9637a03b5ef7896470def991ad4bddfee125c6864b20cef55a544b5c2fe917537fb706891f777c0e00d5e1773a7a21bf57be6599bdefe24b825540653df8f01e00fd1a6c616caf34458bd6c33bf33acff33f3aa33cb234f5b60e65f361272dc463589a3ec94f720fec91e331cafb0a39dc664d53b39422c051afa746cf09a244d56637a7dea29156561051a2c4d6049937d3e0e4096e004a8f25d55112613d3e702658e504d39b1a8c0c5478dd0ea3dccbf64cfd52e5a5ea8c7ec50f0a4c160dcabaa67522d141df3ced940ad198565874ac81c654062b8ffa1635efe8452437dfad0160edf6ac65e1873f914f1fc02fd33d78d9e0ad3da76ed83eb04a687701e829513183d68cd895738ac278ceb5f458fe8022d9a248aed9a2486f55ec6eb251b5dccf3dc2a0662909a734e70a84979df8813156f7abc136f17c69838759c293c8aaeaaf727e4b73dfc978ff4526d12de9f35f9dac075ceab54ec9e4e73c42ae4989f96727c2d138386d4e326115137c7fea5ae91db3c753d04c63963731de70331121b7bf9b14cce34ad0ca269b9d30c822b94be63dc8769f93b7d715b37d9d29f226bfcaf435a9709d791a5e5141a04c2647b4031344c9841422f67fb7394ed3a2252aea2ecd98d65836e4c8e400864afa43764a7a760334ad35515cecd1be1e82261d50ed9ca33df325275cb5cb42bade647b0292e55e4c65a589cfd598aeefe112a00fcacb9be4cd05779b96ed51ba86837bf893e1095cc57abf99b98c88a6fba5ef9e26b1c2ff536231b5fa7802e6c4df602d57a6f41c0919b852f8151657a5fa76f1f8c9570f9175549d8e5fb6b6ae8ec58df1edbb20aac9823189e3fe70a50c6c6ee842dae9ebe1397b5c6a9449675b49ed18b57b007540c16c101e312724b2b92d1592d6747c794ba4d639431e482ae2e33e5faf0eb93643ede8098b6ab156842a7c1ade7b3749f080cbc8870d6470f86fffd289f3ecd687395e54200a53b7975d0e1a3d9129e8aefc6748716601f7aa50f1d91d7c906ddd406c24af91ec825a3cc817a47acc410c09364f05956cd1654967638d4208aca1517edbda40e4c6b8ff497408c2dd19264e173d7203026770531e1ccaf4e3c7827bcf477930154ba87ceeeae6c160d2e6882c84d15bbc10ee100007ab612457cdad158aad806b7b4d96d86855b136b8ee276daefaeea335823f5f4bacb7a9c1ee8fa097c7b6d50cd7b8a6da7c4658e7ecc7dcf65f1cffc2dcce02de761468f009816d78ad40a7ecb91bb3b154a61102418c37c403c0ded1c42058e4a98c9e8815ba2d043712971f497730b5fcae4b9bd7d42183ac9685fea02226a9addc0a8756b6eba40832d447cb2e50317eb874f9f7ec8be7f42dd2207ed72a3cc258beb90f1d15f8abbc43ba7a6f437e04693defd6b31ef21f58d93ad5fd815e86724fdf1b60194b57753764744caba7abcf23870906cb79ba34c4410f0fb283c857922333a39bc736e5c689f623d38bc24c3ffee5ba7757b50646c45aa5b4b4e00bdcfb298d2959a25d07fc94f358a0ad394c512457f2b730af9d6b2b466467f0abb598639122074fdd3edfe82313048152fdf528075bb8cd73def60f3220134802f478d3ea959577a64553e04298e00d50330daa7aa9b0afba73578fb1667773cd1f76dc821b2596d6ad1be0dad61aaf27bf678097fc58ef2b5a94986c8cd9b199602ebbc54f199e6f15f35f0d3cb6bec6fab090ad0c524eb64049e03ad8d0e80eb4d6e8670c84a58135d7dde2dc19bf3d640e0dc5628b2795e7aae13fb132ca8b917830cb545a55411b94c39a9aace933c16c27b6cfffc3e73222618565511defd38de85c45142d6bf3fa587456c0d305ea4c3aa5862ba664fd0db2d77c417fe94bc68013c95c3068941b03b8b1ebd9dc72239e33deec2d2ff4bc9afae8a787c60e00ce5ae653bca4066330909396362a0b4e927ebddeaef2fa398868a4d66dab5647fd9416ca9ca1a41ad47eb2c8f91f5467e89922b831685d133f6a6ba3bcc1b5fa0bfc4cd2596b440b9cce4af8de12e669908c460d786f989960a7dbca799bddc6b48907091cdd392c8d1b51466634ab3f52f6a1ce58a08377b8c63313c46ed3751e92b31ec64c4adca83204c8d939c503269f9b8c08518aa25e91dba08a8eb4292e3098dbb9cb61b9221bb33f76887177fd9c739e5a6caaa9e25218f00abbddacf26dbcebaa4ae3eca6b04bb5d103156fab5d53061c0139e06472a382e41e257adf0353effe29900e1160ddcfe8a7e9d9f8ca06177db52fc98e0d6bae6440abc0bcfb8f8c86ab8d6fea32470373837a2a252548841fe40e072b9da829f76a45a8bd3ed3c7b4edd9d4b83bf2b82109ef8154b068d1ad89787ea896d0cd2da327bf81a7c5be479c226d414d0236002dd8327917552056fef4724684b9e9d05db6040b81e775aa1ae89cb81c7d1dd1dad280adfc7008119094a884308c309a5830475374efc66561c6d0be8404a1479ef974c3aa17fd1b242ac2ab5068fe1d5c836b4338ff344050d70ea0f9f374852167dd7eb03800df29c5b31e5e2f4451dbf1130c3e27704aea45839330b2f915411ff4198ee10feb9262b6df74f2e92a3d120c9b1aab67414a2b9367baed5f97f4234c79f209feb1a66516b35ed35c32b7c4403db89311a3a4bbd12e44d810e9e622f0f7d98b9a00965d1a63d81a02c47b3bc4ab058639b02e90c449f84edd8e2fd178dc5221ec8f92e911e043c05fce4fb2eec6d04aced66d3025320911eddfc859e14b3ea3aa6cd6493d43c925ac3fcc0464080c8e534ceaa0a9f4508d8b64d1eaedb0fef3dc44f283428f2ee9688cde4cb6c84efa205955d870868a187d5223fed26d5aab208172a0626afbbf54496a56483d9b71fde1c8984e12ae9bc75eb920a7718585e5679c41b23fc1b7616409137e459caebec255a9fb090800f9d24c3605498671799ac73d515f5b4e34e604701e00d9417943ab5dc4cbcdf34816e87271654580db79a65be55c01398cbdccb19dfaf3d76faa7ac51848ff74da4816c3c6e8db83cc86e9f63fb954042bc810f1695337a551a2f6a279f345720dc50d97a81c1d392b3ea50ce89ba1caeb84d70f0b0891cc1b07d2f8d1e9f41d633bf0b2df0424517d82f65eccf6654f6c899dd5f1b297b721938019290b896a08782ea6e02d201f481931e22d4974ca32cf8436f04ce34bcebd92702d8fa01e9795a8b367fc66fe2b85970baa64d7f1baa2db5f163af523b3cef1de8e5166e9c3fd0178d39f5358fe2aaa460bc5a0782cf35d66354ad7743a9fb9d1cf68592e385abec86d36400bed87b5480ae2b40d70de19ba33341c837f4671a25b8d0227bd81b8284b2243e22669d8abe69b647794509a43fb587be4950145ce377ac5895bda458f45e42033878603f6466f571fc62ffb1255b8564298cd2c89ea49665a996471e99505594adcd6c31e4125fa0de4da4008bfc25a73e37b8945fe54ca8257b5e17f49fbbadaa986fcd7a144f4ace092113593d4a0698fba691c9e19000e978cc1c82c86ad3c47e20b05fc430c29d906c31badd10a81120d95262eca50af2d05820cb2aba9920ca95d622462fa6f6dcef7288641c565598cfaf9d1c5de4a129b700510d4c7761f53742113a6345e8eb0a720521b2f3fb2095299a852f9bbfda513bc292e94eb3cd1f77a7ff1c6c74225575f28bdbe5d8791d0a1f8ab64f2b1129c9684e71522cd0879b670ce618a9cf4faa52956995d75bd14e8247b2dcd5f579bc012a7f86d20769b64140fb141bdd9928c6b74a29225018f5a672d171d6b52ccbda739b25d88852b90fee14e2e699e09a0bbcf482ae29c3d58f50513769576a7bbaeb50b912d7be070ca59896b9b14795cd171e4e2826b74b3974e8b1383e362453b9ffb6f118cad0e5ad694ce40a70a609f12637b3dbba38749ad615454a441e3a01b30330520405747f9563a282e5d307c29e849e500e4af3e5cda5962cdb5a3a2c61cbb298948f38869d0ba3dabdc6ec73b9563c42b0b9ec7e469718b6ef19a8f71304643ff2f3aeb25c4c2f5946b863aa7245502e9e30cd5b8870aa2e7ad11ddba0ec187b9e780b6552aad3f9047e652ee4d08d6497ac48c34617c1843f49e7528bbc92fbbf8ee659df0c12550e9a0983580028374549c4a3978e264c32b991f7921ada9ba98d3d455dd02408a6e98c922e96be0cd911b322c6ddd3cdbdf851c8bf5affbe02435a5d9fc4bac6bf75ef7fd6271b4e0899d0ac1f6b427fec9a937554a235f834139f5ccb59a9850e6d22d4965b878681a49d38eaa22663ff371d5d5393685cd2b31d8863fb6fb38d0597ad3fc10b11dee05961670e024bede4f5b5444d9586a716747d37f428787e4468f94dc9debb7cf6d564d6413fc316c21fdb0a78318ad2ff8c59f6cc650b826d166ea300d2bd21892219bbefd2fef94fa912c6b26ed85c95d09082878db74ef8e6f482e89b2db1289afed1c2dee750a6899c3197314bc27c513c7431bcddb936d5831cb5a0667718180fafd4a07d2e9e9dae881cf8ee94ea7a9709c72abadb557a555be1dc36e25fde3f9c1ae1a43f8799d67707ac28b39330a87aca5ebe8094b242d6eefcf6056d8433e450972e38394cff16d72827eab9929b501f0a0d5447d2d5ed96b4181b69e0ac203fda634723beb6eb63655f2efc69a36af5b1223547affe7518fa2be5b968ce8fad1366d7a28b30d0b0a42e05e3a445a580dafdb4b892d95e80503ade35e249d5e27fa59cb0c196f3dffe5e1ca01aa21a902a17e904bfde637242f12a756035904a50c4167385f3716f75572aa87bf1d946260325fac7529f2faa3bd6d3f6283a6363d8303a5c2642588f084397fb6def517fe92fa137d438c8be2b42067b5d624c17f94dfabaa2988b814179e40b842edb8865f72af5b7ebd98b8fc27e214e218b67b17765f4045eeb9ce4c7a3131572b673b534e1fea6cc87f12aa9679cda5cc35ec303d97467a1521b74c998fe5df145757004a8055774c71cf3ec05ea660eb5ce6721837e2a74edc4feab0deab14bc010c85943d0c27af7be9ba757d29827cfa139f8fa956dea57b9ba7259f28615689d400ee692ec6dd9b61ea392211035aec90e73613278c724e8bfa18baac7be9d81962f948858b069081ef047f58a76e01f1f5b5938fd5c3b9764e37e9b66dd19a6a41823966ba6ecb1447408267f8472783e5531b55521abc7a3ceefc0e04506f3da9e9671b5b09eeaced51951a68058374d9d3dc3b201794f1380427d3222d0cb28062f156cfae1559f7947eba96c6ea6370bce9591148e4a11bb0b0c86ea8c1986487cbaae22196e914b82b163196eb7cb6e023324aa8302cf6438409e3c390f68454fc39956ada047188cc855be6208f0bd460988cdd28c53ce1178111097492a273a125bcab4b9316526e05aa2b5e3fb72f7ef18ecdb4bcc74a2b1ed1a5d26d8dab392494be14d38a712cf976cdf47b402a7825def65c5f5d37113749696d76ddb0890706004f4ce1fee0fb6815166144489230770555aa107811b24a6367493aa57ebe36c396499015a13369eb66ecd70df95692252cba72b560e49c767dc0ad954533cb2e3871d0223955cff87c2094c2ba5da6cd6c9d061ab4ad4f277b2e58e06bb26832309ecfd8f69eb1b553ac02f538ae05825ff83fc66d6810","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
