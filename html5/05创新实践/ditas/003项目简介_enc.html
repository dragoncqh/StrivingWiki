<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ac98c3bd1018e5facfb67d5b7bcd4bcde9f5cfecd8d1c40967004119735faad05854e68c0b84bd1fdcffa9382d1d5d2fa03a7c309b38325ddb83ffe59825667e3a23eb9e2bdef0929620cd0189342efcc94501bc6ecc51ea3456d7227561e1423aa60cdfa0aaa87a5134f5b636dbd0e408108734ef3037f7d20d5e3aec7fa4ff60e2eb8711c0e935817e37e9cbc7385ebedf06283c4501a82023a78d6c32c6d2d0c913b5411477a6131a00f71083ecfa89ebf46a4827ea7d074effeabaa3e032d598539119ca0910a19239133f478ad6cc565e8e3ba61a1f6c43990625fad1e5ee438aee2c926c8cfa53b9196489978a21e7a589b4ebd22f891597781cfc985e345d84c639b15a7d0946b7a31de990cbbe714b786b31d2a65325dd5afaaf043749e70a606900a2e9624eff5f8985f1522adb75fe464d3e5c65def1a5108710266c843efa35cd1dd70add4fb3995eab31849e5ea1b9a1a5b3f3578c7020a8e9c2eceb8214fcd7beb78401075f17aa372635d96c0914e8d8f27b99d819c154f456859b5a049afea93bd32935b57f34c29de680ea765427464e1fd79e98a8d32a6848a1906b125ad2f3860477f9f12c9ad0f7d531576e1b5fc750ac828fec0ad3fe3f013702ba6f3573b5ebd9bea09c2408431d05e1f1abe2e2b8e6ae682bbcc6a0bd47296ad04cdd48de9dfa3f315932d3cd3069a035db872ba04f5389d606cc506003deb4201f7b6924c8bcab735940604b95af325d81476e885c195707658bccf46edba8f6b3a5e31767f9ee70b39fbb7d87dd6dd4659e53ff6887d566a6050e4736b728296918c9726dd638b277d05a193aeb3393d3ffb5ee485a211bf5e4514b4e499e116e1432622f38e434d10684e78c8295a74d838e7542b481f701a1e2b9a38a293c3f970cf4bcc8dd51711e7f4b3de584f06abba490722bfe97ff3429d8409f510d0aead0b0c9c30ca9cc6d0ec44c56f45d7f798e91783682568093a00c9d21044e51b65f09ee77671f457a66d93f6a5e902a82544f5a4cc8df660b4e1c79675384d03a538e4f1385db4d12f6976d8647cd1c21a89e6732f3e3c7ace8d32f24c3006bd0f8231355b5244ff27ef7b8a207ac17852dc73fb966d1599f4a8248770bf8edba8599a65f0b2680332961acf5ea312574a9ffad99673ed3419c5eb531b4ece79ced0b1b1365bff9be7bb580df17e7fe24f4ec6fb08cc9f79c354d8d0bcbc475e6811ef9f7da485b354c221d8b652d111fe61a70650b218a5227f7665063438a78d790e706f9883e81002a536a997b24d2c1bc09acf6f2aba44f28e1ccb56bc77e8076c277873279a5470248111387a141491006d20bbf0f6fa010ea231913f9de06abf65d7a7354c61363bfce8993d6295ad0a7c7e81efb44569cc5352666826597649237671759cf24fc65a94b03cd70fa49e37e9a4fed7f73906b5ba84a78bbccbefc9001c017e446a01eaf1520c14982246d0b644a3f333e52a0c6dae79f618ede2e47f5359e31fc36d59dad408cccf6de12e44125dae6d265979bfd6d5b23cb3d24ff8086e99e56fbe674214e63066c45f37265692546d3ea7e62d0b68f9629127ec862b59aac5beb8a1d398bdd25abd70915355a941f5f033859831668869a0003addf2f259b8a0dda615c990b7e9dfcfa69deb3906f79b400e75664c61b582c44eeb42ae626f7fdcc71f901dbc8c4fa80b245176d695643781fb58d5fa57fa1cbe77e5d29199fd5a544bdea2f6001a1e93502f509520212a333acb23cd471b8a9c66d22a174cd8344d5a5901f47d69f60d4ec738aaef009aae0642d1fbee94e1abc1bb970d59d9a665f60b5877313336746369240300e9798eb8391767a6cff0ff220dc83f0822707d1e4f4624db659f8b0d3da6a9c838835f42d16f83452dccda526a919513712e63fa5fe375950ee5975ecf0fef0764fc98921cd90999604fe6e173b7661b5fdf359a75743fafac3d30e3ca756da35b251bddb0244869f5af051ea8d39df2661904a1db4e0c13500a88abde6378efcecd78cba95cebd05298e8d12253c664ba226b06dff68ffd1c18da2433777678acc3a87f3b081d04373834dba591888da8e670e3805ae56c00475740a8ba480b7650a3e902d547c3b76de01d7f974298115db87407d19378ffc44bf26919f544a1f684e70780b2af0eba292b9da97be54f5198ae485b3f8a23797c24b542f66c66acbed85919f6c33fc3cd9748894e2e2b7a613000ed4c1247380ac064f91e691465b291ed104b18c35f232dee9d301f48b653a26159da476c3c33560d58ede375f8c4d8dd16699e2ca5f5ccfbcf48e553d6a4be8faba08e2d76b08fa34dccd777a20fe81aedb2303d9200b54e52cd52e537120c49bec38c67f89392b50f5152551bd7e3693a015b335adc19d4c40362087b2666623efa807978c75afcab8f4d04e38d84ab4bb1a1dd8b228db1abdaf8db367870063fc6668a37c211ed375bd87bcc095b20a627266ed7908ca22268fa702026612aeb3b6b5c7025aa098644ab84c64bea71e6e337eedef2d3b4828b660c74afb080e98dd2f69a6ef247eed76a56aea2a2064a83f1e1e2ef89a51d975355d0c734560d62f3098b5ec27ac6dea1f5cde4319c9bbb19994858f16f12e6ea55a0ae3c2e3c819f4ea79ac39a513522e84c95eb0b803b9619087f62540ec5b6dd378c5c8d6aee0691e782d2c7031980c4043e2873a13f343eec7d0fec229090859ddb8421c9a7f20403b8237635591011f71a9236c37c149131d0e6ab0d10819eee9699f5f03733f421d41c16c8af86887ca586fa50a8cd97569aaaf7504696f1e9726eaf96372b3f1e45e150b039df4ea0bc2fee059d9a77ac5779fd8d14a10d56f30d20582adc4643e12f6d7bf08bc5c33deb380c76b58d6537643b3be967c49485f5f0baee0a86f70e8dd792e5d22ee85fa6bdb1ecf8f8535c58383d9521f8fac85ae4051945c03fa0846369dd65aaf4c8048960db979904d770b61b8c635b964bf30764e0d95487f1db90e6fe45f95c0a5f365120695004abc1fd1f5af64edb0c36ac71e795e1af085c6db9a2b862e80f798cb8bca18d176b276e56531d74a964bcbec1c72b38c11bff466d31ed72e0a3aa08cb33bc94d861f5cc42364d824158828210c50062f05a85c9971e305db38867630a97e5c182970fe29e54ef95c0a1197814b5013fce03c8e5bba30afd82e7bf9fe9fe6f123c301996b0368f90927567beaf9b4924baee01ef201a88a03336739cf24847bf3753a9f3d0e72379fd106313c845d7d293c304e52975876a0b886af18108cfcd7a660f131e77ac0661b4edf3332479d7c3880c3d4a94ce845efb83e35a01eacdf18b342a89a8b56b7dcde4018d04f5dadfe2bb4b5b8ae8b79278a9d7cdbc0d1593671ef932ba3a6949130210869156a269f46ead1db2d0b31fbe59a1d8fbefb231ea812d2a78d4de53b95266f99df884e0343c517f890652732572cd06a6e041dd0ea41ff278b37033d7ffd680f8bbf8310c80fa39bab55e924034ad83dfb6ef2c5eaee5ad0403de7a1f8241d6b346d965d886285ffd416cd984225f1206ee48bc229880b439f5e19eec61db7802ac32f3ede2f8365e792bad9e537d19aee0dcc54bdc9451664c649f72cee792677a64068325f3a87523369d59188e91ad6b794bd42f38b1bac8e4b9011fd4c7a7cb88388f84f2565f0c993d8e9fabbe8229b4a2674c8ca69de7719b0572b5899d04635539aedc232854667a630fc56cf547f886c2a2aedbd78f9ee13b4667f06a65affaa1e2ec3338e207a4ec342f702cb3232f0faf1637cc5cde31f9ec36634775cd29a826b67b4b1ce9f4c9bd03ad61d081e808d39b7015df2c530068bf3431d78f76cc1b0fcb215e3e61e24fe33e28d100470fac13dadcc67c980ad12dbca1368105d45a8f1309171c7862b76071f09186eb632213ca188f48853a657b44042080d8b8a401eac715efd08a857677cf9cf1207806e63f1ed27b6e0eae80e7282b97edb25d3c346dc7dc47ac61bfc62713207a5425636e7cb7f23e7a1cca98a102fcbf052ba796200d459c725b052bed0600cc4df90971cd560b438efc51b8b50663bd8228266b7c436ef8e1780cd233eac348860b2dd497bb44d38725ba1ea5687deb334a017ffd9ed6e8b50d5da5712182a68d0226022515b0f6a5ff30e22d525e00906c78b1628354ee6532d51191e0f05ac3816df76f68fa11c6f137a0c30ac483a29dfcc249973aa75a01fe42c47badb7b094419403490139110a9dba88029597fcd2feb7ebb520af842c872cc98c733b68b64c6750edfbcaae9277ceecaef0a07387e30a87fbb1073f006851092f8be71e5ba60de38447ab400fc7a9d1c551de7ce9446341df8dff6762d073e86cb85f52cac7bcb1fcd18acfbd2cfe2fa5bdc3df8d6da76f891712f6830af67b07dafc19118b4514e2b8220f251c1c39b3b48ee02c5565380d8c1674a4c7168932f1ba9751ac7fe1e01d4bd9e33c9e2c1e3c7bf62e1a54af1e8a557aa43e8b340bbbecacb99dcee9a97864aa2af484d41809f3e66197a9208d74a639a92a87e6574497092a823a9688a7bae6b35bbdbfff7aad05c775913aa03c1a3e178b66b324b850401b7734f2434ec19ea1528a3b3d301ec0f9fa98abeb1120f3f586a263831a2c07aaba5db7831812172e54786ddf126e20c850c4f08a309e6c88815ed32168a348db5547608cb41b72aed956ee5743aee5939f9a2d887ea20ae5cee5a2fd9f9639f885f8657b77aa859c2708c8735f52f6bf7bab6e94e360caff32a28c37300c36d2c592474b81d545deae16f5f94717a34b6e1cd34a49cc40de1c94dbc7e4df25debc845a0a7ad56de2232fda5e6128a2b87202b47c75a8a7324b970d22a43164bfc47b0f602221d66017b66131ba521e199ddeff534fd038d4c59c95b4fb51479d6350d7baf839965aa2173b06d7c0047b20ef97f1fe3f9ab895b37c9ed1b795fb68a1e7f1839c961a5fb693d687de12b5b42f6e90eb3d53f22e53ca4a2b59e0065896cfed88f3156a0b63f67156c64d28d04b4ea0024003412586e05ccac3159cbc3c7174813fa873d346ca9e913c540c3519f591ef01fc96682dcfe1ffa182fc23609cf23642f7526da9782d89550265993e21e6c21f5e60a443c8ac93d8cf071eca6b819c46a76d3cff6f9b5d8b88a4c5f00018cc1777fab734fbaf231784f805dd8c48ae264a6556c864c4f7285b0808cd20b8207158eeac3d1b1bba47777fbcb7b2d0506dd9e74617c6c247729aeacb2bb1ba7612d9fb6011b75c176ac4c21b9e14e33833006369269dfe9f8576f5bd52f75e0c2189502a753828811d43abab97e05fdf394f4c02c877fedc9793b5bc40e1da9488904121702bc37dbf85d0cefc70e4eeba2ab70c6942d297e5d3a2ee1006c8d94887bab13a0e4e7a4e46af05deeab17e61139b137c3ac2da3ba191b1d7dc7f09c79d56e1e65b24af68a7d332e1599e8cfdabdd8221103d85c249cb351cc8601f75b16fee21cb51416f5458e74ebf20d3f1015ae3c2ab2124d62e448c07037af93cfc35a0476f21f13886d68761dcd32ca0f4a69039bc3d08b1d8d030643b2dca07b36fc5b544f9efc306ef5a9437bab88eb841100b43755ec03dbdb736a4a2cf2b287b3fe0b39f2cbcb431d110cae31d2263e2c2304bf4d1377c8b6cc9b6915786a050f19b405edeb6c5ca0da4b0f6ef68a93c61ff2b5f09b69e7f4f83b0623a1272945b8b458fa48719791418ba4c71c3eca905a80cbfe6089891522fe1e834481e8aa602719a48cdcfe27f9795625218a9b40fb71a4384e57ab078d48eac4d03adc84f98993a56cbbb476be62389baebc0d35ac0abcbb190810dd93f000056b47e0d73e23b551d15693733c3ab81d99f40674dd28932229ff2784e9760c66463ff635101ec48f58b7a27a73e16e6f6d84d46fe3305a263690d19e5bdd512a6f8b654249d30d35e9e00c157a9d26e3dd26317f218551c69a1eb69ab5906fa9dd1487e8b31d761ef39f4b1ba995dc3b0ad9755f4788319d00e3305197a1eb02387fdd81ef0031ab1f28ee3b3f8ad9219075487ebd42771e5bb3ab7737592cde9cf2c82df3efcd2306a58b4dd8e15d6394e216271973b8196987d0a0b5ac711acbc3ea1a20e85f6b08f284d32f55890c10e5c72647d75cee0841ffefd0e2bcd0f66d3e9b7a38edc15b3f40499881c3ae5cd73d79d960e3f6ad5a062204bec5ac8f450d23deb901be0c09eef227b0af5119246f6bcba7ba8c5e332c7d554112db0bb697d9ad2ee4373762a5e75a95107c3bf9fae36d08c7ef86b577a59bb08d725e7c465ec7534b41b4bd507194ad4f9e336776d1539f48bc0cf12c6ff6f34daa9eb981f418dd1c02aa0d3cd9154f2940d4cfc64839e98c2b554105985f1387fffc9cee6985df3494f9879daf82a3ce9e6632990d2dab23271cb138fc7b0a9a2ebe7b6981e6ced2a1bfa66aeb5de5bbd5aee9c76e5982307a4095697f1f070b41b01def690d1750ba417960bbcf46469cb5cfeec211c80e480218b6b09ae88379174385e6c343eebf458155e2562c635f8eaaf903a93ab102ac6288d5ba2c26876c7797252e8a08e324a4a54213bc543cf2927324b62c449661fb18867e4aa3dc1e8505e6ec6f4490ddab8bd716ced567660eaf9017494638f4c5897c360359cbe58fb6c6f1153b52aadc76ea150c3fa4fbc3c105e07bc45258eddc5df9ccb88c149f058e053d06863cccad3023c5c6a30d46031150ab70b096646b501951f25d55fdf15cd16b1657f04ca9d3a82f02b4f9ac86ad69eeb47f954bcd031c74f477e21a897aad0deb8864b1b8a699c375742cbbaca7214328ce62e2f312514c55e448a136d831f1cec095650bbbe7de17a9fa2e0c07a4796f6085ef985e8de3bbc1b8402a9a1162bde942a6b0bc1d4ac7711b837a3846d24f8f70d973e73e4f15a76788ec46fcdf992d68d01ec3fb7ed2a2a9009ee4fd161bd5fd106ef5b0c759c78740e3eb2b498cfd422bb20262b290df067e431370960bfd6551eca9b5239e492bbf09ddec29c61c31d2717c34d8c6113ed070869fde99a520e700c48bb10a274da1311d06fd70093e14581d619384de5af5cc45fa4e8cdf724cb470dcc384a27a9e151caa4009f504dae7b6762c429435e30a575ab929b5b63557f05f15aabbeff88f9610b6d1f8c6f6c3f28fcd12d168e1b0a462e5de705b8fdeea9dd58c2ea15f1145436129143d2f22472dc08adbda7e732e5a0166fe9cacc6a178fbd6500df91de80a76699f90457338b3969a88b75e3ba474848d6bcd1a20aa335c30cacb2d9d0c801608c397292ce25e8a6a9d3beea02e62f05284c6146665271ec5ed55628d0514d957522d90c3833c0e5ba36453fb9d3e764c2b5962b5369a73a803cfd1b994dca40ca9e580c73442e24a029c5c89e2788d7d3e5474171daec928802bd21b22ff4001d0a9a894bc379babb4fe62182cf317f984a42b00e35c796a6ef92a603a49fde83a1e664cec97ff5dbfd35fa14ab77a3585d0f5243248a12a01548a60f23ea1206d3d874d9a1059c4eefe0c00a1da61a0c335a99dbda29675b75075589bc2d27a927318b0fe909fb442884b91be054ed74c4b268a872b186a7119c28c4d67745a007f2b4a28ec65e5a93023eb8f610ca7a7ffc9e30e8576b94d9e06a588ab0bc79e4cf7cf32c761144a1954879f54b58b06b7a6805a5a08fe565f0c82709bd09287679ba564b3a33fc8a46e121f57bbdb8b327965ebc6c4e7f427e7217b59406950ba7636885836f6543ff8ae24413141eb1d7cd4a8bda5ffc7f8cb7e2f0dad5cb025a2c0233786e70ce3f497b922c7aa9b9d20a0aeae6283895bbde5f4eb57849b6d8bfe7a6f424600f9616ae8c2117ad66655d586993d5e137edffeebafd8ee2d999e9ab3f8086f2deacefa4d29ff9663021f6ba53e73656c9605b8d4da2900dae76d886fa14bfe95709248fcfcd5136fa087b1cf4b3df84cc91ab7b43391c8dd4f87ea13230d23434ac1c6838b328674f837d3e4592a8ef7a30999e6ab2cd650c8f4237a844c5e2699d23e6a97d2a5ee8c5e8412a8fa7605fd9c8122d14f4ad32c6a4745d1f4ad0497d7311762e8c188c995d297851daa04a43695dcbd72ff06de4210706241b0b28ff6d5ec8956d9dea4a549886e440e3097af37663ea9b813caa94a185167a6cd556ec17e6182937b8d190edb317145a93d21cd92dea2a1ecc9a59eedbdf6cabaee3701a0fba5b16f35e49065e69a3630b183a4088d257c556646f1044be50a14043fb2f6c9dd2a57cad8e46913d2db0f32c52813c3802ec09f7b05fc5f81a58496cdd7373cd9309b0e5be4f80cf89c93dff1dc3de4a6ba7fd0f997f5b6afc68a0f1eb317f0a957f9c1e17c2df562d98309ce3a6de629df27afb028bd50d5ef03d6efb656a6d382e2193c251889c7acc6666c8c848634134f4e764b6bf3929400bfba60d536aa2678ac0b7533ffb2344d90447e39caf94b042496b78a7d483d2e6e054ee3250b13ce62bd4983c513a53507e3a41789394a466d0555fd4b9d9f39aa6dfaa30b45ae35cd57f3e08789ab10e727fd6f6570b3dc5a2f88e465aca682345b8951413688de24330a6d880edca109e1fb7bd0ccf324b93105c1b3627f3f0a45a2b02843eb92288fa98c220d5dce36c7beff57d3d873a803f0c7fd1c2ead7ea32262cc57962e224dcf5dcfaf7aa7e9465144db1479ce4ba57a51e004f1cb907587a3e6fbaefa4a134a3979bc4925eebbeaeb7042a04d3088bafc3fd55a6f0f1a6c6f61c79c423a88fbfbec5e4ff715e97354438e20122db292366a5c903d95630b9fd1a203ea324f14bca72eb931b36a8c2a1875d194cf8e97377f2628206c29700c7deb339a627fbc9e32d44411d7eb308da46f55bc3f04a66f2a0636bbfa2ae4d143d11119d00a27ba98fc2ef8fcb67aa90cbfb3fe06da780265febaa0fdf07edfb9c3bc5141ce8e7deb78bac0abd2a7cd8cfec7958e385a830104fd992199ae170294ec81b5294712fe9e31385858b0880b6a26641bfa8b359e2b3214fc4c5c702ff346d428ee530f20452650836e9bb11b4decb80e2ab63196f4dbb2b9756038aeb877141fcd79c1a9e252a52a1c2c8f9f35bbb4fb01bd01fff7cd977d8ecd4553a4ed4504f33dbb4db45a2c52ac5e8275f3e096f2031a38f84180f933e2b4f72d2f9627f02697a60dad97f567d03db28fa8842ea3376652f686145f6bfc1a4418c19cc786d6d3b89d18410777d633b434eb74287289146d324892b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
