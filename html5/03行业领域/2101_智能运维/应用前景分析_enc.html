<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a816d2de1636780a67caf6946791ed4b8cf5732571a6f9ac979a8427cf1bbfad36454f9cb82f51caeb824f509b9790916b61be4a8ed28053c7557735fbc670fa7ad1d3e4db1aa8c9a9c0e4067dee630885354e4b63aff85604a39a6dff2d3860c5267f64a411c4bfa9dfaa721b12c6fb5dbfd963e081cc436774aa4ea7524a91984febcc9098969f86aa5331f6e08ca562f9b3d56aad60cfbe31e3c3336fab76113ed0ed026d2f0802b2c4776b13ea24d6f76f13a07d4afb68a7b0445175471cad7f118433710ac915eea6c3731f2fb088cc24dc7773473d33e0bf1bf038d917d5f82e62bb5f5dfd0ad3b8dad343062000042a0bdb39bc80de9ff1aa627eca32d5c9445982b969fbe0d10c62c804e22d61b71e519afc82102facf305d241d207c4ef8e1ce3adf91a0d7f340a3be7f15a37a46531a76f244d79487eed8f895c90e011f7c93a1ccdcd2866ca3ecf6504b96d71a0bdb3214dfa50ca5bdde48a13414c82e9e5b82945c51775ea1dd457d7ff8acedee5d372dae0c6376dd9575b083e80ac6d7fa854320a7fe3df4d0aa550e716af003b421ff539cfe097bbe980f4b33af443a64fab3fc60892b46573f025730ab77165ea8f5b62caf3c14c4543cb872dea4731a2a9a55cd490dc20f20a16de79e5d9f4a52a7b705afef54619899096954fd1a18e191f76f2a7f9969cddf6679ebaf7ac82f02102656645654415593a30ccd1e3632e9b7cc3713be69eb48ebf7b62504f701f07950ec2d2550e508204fb99049f391f1cbcaa0ec92465861e0b8c33c2ad8a9d6d8e32d44aeebf7626e389242f4dd32b2b5b1f694f50767fc0085199873d974b84088093d3c6dc02f438e2fa24fb45268b16136a2b32d3db14c94ea0f94986ed5443d2fa4249bd889d38ee74378997927481d4ebc79a76585b64c11db9bcaff9d2e989cd213b977d31fd0e6195cdda78a2614a88dfa3d590b173d097776148824be35096bef2d50bd56e2078fa2c2d5894bc5db6012783e8ac640fd668334b62f2ab0068c8fee52d41d05fa24db660a9aefdda6ea512e31d724cf3f97c6580f63bb51c36a5d9012f357f637a947714d5be50d5a2ea1e31b681853289c970fe28dc2ab1f03a7ff1edecc731e27a50dbd41d08644f959770f25b455cb2f370a36a50c9752b619892b82b385943d5cfe9153020ff7f98b8c35d1ce9a5575c712d5983af9bd9212e68806748482ea7619130d5915143962a9cda78d134d0d633540c18f455d7e1ea205da46350fefcbcec1525ff54d704b40f898b5ff75e093bd6f22c480b443ef0eb04551c533494ed45eb478c6f7ef40fdaaa78317296e2d12e566c144efa5f9529cfe959b0822549a7eb6b2bcc7db4202229638ce4cf7b84ccc69955382687d6da1b8656625650fb1a96471979a27ba7f3715825d75a54cd42c4c48111ea6ef498d87e09142e7267b45cd88a75cc0f91eb7d034d21d4798c7661fc3df1662037e201311c63495b997252fe33008514a3a675106b3698e922995ef187cf404d8648017d8c9b183492242609503a551d65066b263238993493e6f6cb2c2ac9cf868b781abba62ce6e501b2d288d51706b25fe174d84f19d3eac64337953d11726885eae03d805548933cfa2b672fedddcebad8359f3166f425d793ceaf18e5176c7e5335817d32faae7cfacc233c12d833b555639530ae8acd3e7d1832674a9d933918881d899d15b18cbd4ae585e22bcdf924b745133f9cbe2f9a79bf28b65cadd8c0601e3b3b09c390668f164ffd8a94894f958fecefc94f3c4acb395baf554e73194f9c38b9400298eb2b2ba21c0e0d73522d765671f9ef7ef4ff6fee4ef000019f21a5cf3101c5282904408fc0cb9a60ac82b77e3e17f8ca47d482542d2d8518a20822a56e5c3e640bd2ab87625bf5997fce2dce86fd2ad01c56ce0ec5140fd0cd7b1ad959c14bfa10a4ab2c5ec0e3c9ebd13ce594cedbb08fe3e524198b81f243fb24a21ffa557bc50339ab5c26d2ed253ccec5226cf5c08ff0584fd895a10628e4c72d87556a6d1d93496252f4a3792cffdee19e791940fd24ced86335e08f4933988abe65f1cd647b6efc26153107bed045f59b5395d0bc6bc35f1b7cce1764085e5d1476d101b2ccfedfff316800ab6e3d5620bbfd2bb9e2ffc50539669a36c75ef34482aa41f6e0f956fc14cd4b3160e5d083e4973d8596bed4b5187b62d801e5c80c8bd7594212caad34a66afbbd3d4b7f84f5e583bd459711a8a04ae3755872bb456f86957f7badf672fb43ec8b4ff7c5c10bda6f256c14f526972bc5716200f6ff34534c66b0dbdf9311f49654b4cbd87205bd9a66e6857b013068fb337ef5062157cff957eb483249f7216ccfc5275c22160fa0f6a99a8144df1cb83e40418dcd240a958f4ab24bfae003ab1705bdcb60f34e4dc0bf593cd22b6851f27dd27b33f1c0a32dc2964a47da1c39f7d46bc5a3c0faa647b23d7f6b2de59b1e31a316da6d1614075d67f7880d615ccab37d86a6a03092144c0e78a2d7d25ebe6a52412519aebcc3cc8ca8e4ab1e57bc0e1d65302232af4bb8b560897aa8bf580cee18fbbefd7c8a11a42f54194e2c42b3cfa6a6bc6a3068d7cbc80e8780d8e3042b8ca757e3612f468758bfa9d5b0668d1db34fc892254a2ea14a844fe19ae0be73559d06c9ce5e554b97fc28b3a62b26aaaecedef2fc9a53824e328686035af68603a1954be2202a4754a7b29e9af1b68491a2f4f32a7b9ca74c726a6572b130e994a53c5008009c101fb11b82c66801a4592762dc2e351870dc3383537809c2da07f3be0ab92539a109c06e6c44a9e8cc31c6c2dd12d6c57d46ff17624de7868a4a25ecfae74059055fb0a711eecee3b44325e8801d03023cc0ec22d24080fc3d4faea06524d84816f15bc9f966205f68e74a56ee50163facfa15c1e76018632438f70f68bfd9a93f04b21ddd84c7a000ea37905ccf954eed8a43219f66cafd8de1c068ab0426c6ace0f1872cdec5ec6d6bcf6dfc76d5a58c7b6e3e7572b58024f5f7faaa69b1bbd724ae7b0e9919865691edc4c84cb75ac52d48d28c84c70f60b0f0e44b1f5645c8939fd77e17d5502bd4808b1761525a6dc8c30db08667dba11de58d94b87b30c59572a06196d791e3053774a3da25ec5bd792bc20919c66da3d37c1546487b702d031f592d2a42b5c77083c2874ffc2546fca09aeded4b54ebe843e9a0705b020749df1d35bafa2c949c4cc22b3b5ee4c7bdfbc9ff77eb174f499b978f438ada923d64fd25c91fca1cafc9e532c1791ff5dec9d756b9805e7617694a589f6591acd4ad6096dc00ad77963ccd56a551a792cff62396dc91ea8925af9acd9763d19b05acaa3c3190b87cf6c05d44758839808da9a3c4c0a1a66613c51f68c0f0fb1791a5b030948edb12ddad126d8204f01f5524a24d0eb273fada298a4b1e95b94473a70846822b9bd7d0e155c4d4c0a3d2858be2030ff329872036da4d4c743811cb4102828efcf6273639ea7285519870a0074ce32706dd1115c48d464a471a3ebb1e9d3d9858651417b0bd1388b1ece7a023d6a9d15ac64dfbafd6a5563e137a3a08f4c65de86e79b7d61a0d81308b40b3378db5094f74cb71474af44a4d0005cf5ad04ef98747dce2db65702385c26d82c41e606867d474d59e231b0e6d2261372296e1326012a3108a58664985d8448d2737242b20b51749d14dc2edf1487010189065142bd1eac4fd24f91a46a7e560e0243494eb9964685e42f7b311531c21bb390bdcbc7e6e34a355e895ca2444cacb42f91ef15abac1eed6aea314d6981752d05ff94f91d423973139c802a3add7c25cb783dc7013aa95b33883b41223329e3b1c5a32ec38f086354de1606735750cb6ff6773e07e4bdcd1bcf450f4b28912b2d272c49f68d0369512928aceb1d0107a3b2d9e6080fb01a53412572bbc98dc0a9bb911ed754d6c1744cf883a52418b534b78392cf0edb85fa5d6e7b3b261456ad40f8741ef0be1b79f0c55b5ae4cffc7f2a1e4295d2a2e2337971b0c1a0abc6c61e6eb50775340ecb370833a915d069d0013e25eb32ee5ea294dabb96f474bf806bd3abda924c6f0c67e0f63ef9f05bb86d638f10defbdddbb467ca46212e48c5ec8455aa189e0598b43342edce3fb000576bc1d9c5aa1b528a23dd5e357eff3714fb57b28b784c91ed3c55491cdeb10376bad56b084d2194177c1ac33b88058fa9ccafc0b6d834cfe64e1af7b0c60af99c101ddfc77955b1fdaf91681d78aabeac07055ab9f75f9a48b41154439ebb01854e9c5f6a76318fb547e7a404c40da4a3851337fe5a6c27dfd10395086b2a9523b1f42060419ea8cc16e1069634187f023bd9744ae41f085238192ccddd0673bf9d70182928043b6ae46f2c02cce9279ff4b896bd4e11e5f22bcd0efb62db9ba70cdd3703e3e9172fd9554af3576c9d085c9587580202dced667b9210c6784638cb93b7d061a4decb6fdd33bf18020efb1a1f05a813e0e36c15e93ca81675d4f6b39b237f68b07b57f06f1ed51c466c3bb8c2a67a4839405c7bb65a2375a8ef5824a3230956eba61db33a1523960e1c6a89efa7bfe707155d7f37757150a58c053154d7debfdb2e9a075d578fc6bea62ed1629dfcf6b7b41c0060c1bd32a4f7a5221d8e2bc62cceea610bc25dcc5161434b1051b594e1c00c36822481bf97cf13f54f6915c1a20758bd345d953fa1e31470d5a69928c183dbe04019af8e37f1d96ad482d654aa5b8c50bd026e5904c26923cecc3d7dbefbf519c11586d2010553766a7f1c9679b6191fd8d22f28e3e8e7ffc4d4325ae586532c1e8e116ad958929c796a4b824efaf1809cff0de5e822de6b7d12f8af2496781978eb82ec918e58cfdd8c72ffbc338ae6e07d3478370019e819df567a04f56f67d2dee53c53cfd7d4b27feb3f5c0d93c736035785aa65fc85022792d1c2392b1a8c5acad9b3e83ba12391f0325c16245d8811d546d7e98f1cc481b7144e10f218e8efa126b8df168c03079be0d6abb582a16bd8311fd5f57bdd70f96eebaa62d9c4c9b660bc1e319a4e3086d62a7d05239d4b79d1a3946352d3213b0af3edc5337b54acf19b375fd2db23e93b6915b7c64f00410de9f265ac8e6ebd56616dbf66b522eef077bdea7bb850d7adb2512da86e5d6c527dbfae6e21bebd0503c6ac32470eacedb3cb9d057c66031c1a222e0b26d8b160e438dfdfcf0aee5d9d6c72f66a0ab0463abe32f9c7ccdf4cf903fd189952dcc8b44d872f28558b3123b1e544514867884891c6ba4749520ea5062dfe084bdb8e48a04f806947999cad358aad11275d9114f8e84e98f17140bfb096e00ec8084d225b3b895d461f1fbd5f1e9237c58493d4005fc22db469a650354ae311d33a81c54aac416381ff193cd9fa40a1c96d25df19159ca81d4aa7652b5063d834117d65319a3f135101bb59a4c3b9c604b91ebfc80313d2d314a7f051d8c24853a7d17c8050848d249fe81ce8848993db5ee74d59f522c6593b37862b10f3ce52a797ec4b0fb504f4daf21f65aa3347c89966d2a40aeb97dd01ffb96b6f8ff88447a98f31470c6708dc85bd9bd3b5a64d0d59690454f28918d7eda75857ef290bd8929371e1256909cb54b0ad3c1daf0a98f512a05d4b571cc8f826c34546fc183bbef8348e67859c1f8e4739c5a7c936459668271b6e345743465b5f6bf89465a6ec25173eba608f174b887c02cf15081c5bad014966d2fedad44cfb710575ca5527e359d5fc932a157b29088bf227ce65593450865bc9c307d64f273b8537b2986d074c132464cb7fc0260d8c9cd6af1214e7f404818e669dd85282133a19f976008d81f7e78f03fc5b20b24b8bbf4131a07569dca9e63add0b6ca4cef681daaa7e735d3c681543f47d60e2831a8108e842f494135fae2fd224bb7b0096b5719228170a3790d583c263aad7e5468e06e21950e0cf46028d2c07458df8d862f329acd6c622f0d9bb719c659ae9109775bc35db02a655bd324ae6d7d06e94eb2bde2e7a0776a1b78e7a7658070173983c995d722a7f757a2555ca337186ef98193d682118dd11c057c225171c4b586180fd57a2cb954bb1d9c6af1c786a1d71df2233a2109e69127abe0ef0013e8a6ff768966f9553214e134b040def129737d685e0469beee53b89047a38f4fd948ee132632e9250e63ca0628bdce2d09e265f034f39acebc9d7992af576e5cd004146e64ccaf055bcd4e1acd92669d8f270c9a8fdc1638c27b41a3f46ed0deb7ccea9cca8f501de02299cbb79ebd7101295b483730754b3b9d9fa262c3df94ed96f2f3aef61b2d950a2d934a6309afa74cab1bf74712c451abf070102fb8dfd8361f1a2f327f156ca08e2ffafb10a11dc7104d91f185285eaab47ed832b228ab28c9594950833c87e3df317a98b368b323d5e8b63b6beb6f177ea7bdc9728d24129fd515cff50d90b518441a5dcfac7ba7c7d17be9e4f5ec12dbfaa0a2a68a5ed361c0add634ae0c5859cbd7d98dc86fa36a01c7d9a14a2780b79c4c227d295f876e4084c45497f97c4183a5f2409152b36d746f91ab6dd7458f8404a68efd22c9d4046abe6edf467c7612e5a6fa53623dc43e45103b5ffe383f3c63c91f4cae963e0f2b3639136f53a710fa3610811773f31f35ba827d28776bfd528569a833e09782cd71e837778418542d34dbe8edc640ebd8ec20364743e5a17729028239edccd66231892ea9a04361175d5f60aaad874ef72cd5174437ad9a1636db36104c8962f7b5058aa600acb063fb1c25b97a8dd45e981481d76dff6dd5536b049a9e0fa2224beac3d0904a6e5281d2798b245a4353a204309d7fa3d338e712b58e3494a1e09318bc44ed8e565f21eb39205b591eaf60f5936c1a3185b0203e9c0ecf3630a12a8ff96327aa8b9757fceb71e8e093eb628d06c64b247e689560074467799f6f1f0ec6445431a8aa391d044dadfab898579fac23323c4124160ea51babe0a1aa096ec2f3bf5a83e1c1cbf91ee612e794087838d9f5309c2bd47e6c559af9860c5fda090e3f61b977d5417e8772291c6baa98bf311ae99bd3d293a1c69ecb6ad83eb776a7222d547bb25c3e0f589b3e702ef0b3f6d9bc8fb1cb2605995b576690e2720a0d73522e17b8567d8e4b026292c1fed5f4c8a1e182ed4bdded5c43b91619b6267a095a329e5e5331cce9a0f9c562352bad185870c0c219f5d283e9c058fb517a580503e534d0ccdfcd19e1760de75a46db9ffba38f399cac4c27f859382f3aabcb56f0023a31e52f17814401f000d1e240553199218ed26eaaf1d5981da20d43e225a20f0c3ba54426d8c9de7f54cda09b94c241ea3f807d74054abface390ce77d938c374ac8749907da1daccc51498d1c521def0a241ca22bbf8dfb1d7420925239566675979220c1f26db62195cb16cdd254f736f781cdadd7bd178abf7eff88d1444d5ccdc974efeadffb8d0184ebeb0b7f1a96a5a258bf5d3e2f830c6b239268456a1e14c4e236db08ddd3ddc39b1f7d6f364a2e3f2e50bd7cbec94ed0da0e1a89026695d1e1cd4da05345e1dcd2c45b4f3d9a099778100375e686d4952c182a5b2a97d603a857e1d1499a0a99434bf9cd17a3d5adb7a90fbeeb6bb01786b4acdc563a0a296ad41ab74df6d04a7f55c8b2610c72897678b311dd02d4831c4805829f198f7c9aa1896361e4c0592feb529959624e04f41f56e9cab6ede83e9beee77332a5ffe04ef04ef75000ed4b0ac323353a26feb0d283266978979fee6e3ffa109e9ae36f508feb9be0e7df58b3e3755a4abcebbfd9b9495c3fc1ff17b9742a157ea145e2aea3f55453a6643a2760ef6739377004162a806d9616a5a421fb93ea2d9a6e6287cdc08c5f3744525772f8b07cc2460e0ebccc778377367ab3d99a2ccec9fd9c68c32406d5c7a6c459af22c636ff2a1dc5dc3fa723cdf348e2c18f3bd96de7a901d153240735068836c4aa151ea21ec35d6f17ab008797393e4773003afb84821360f1d8bcd8ba1c9025b4624f8576ba0293763119ec36eb8a84c02bda35096ae8d72789c97b0ed0c2b1351444d9539c975d81ba4f46b9bb3983fce4bdfc05a59ae94446152a72b2f9c1917d1c33ece4ddf0321b9ae47fa2a203b102678a624e8a816587ad734508d659b4ffe650341574af4e803304267c500fea7bf772c2379e295795662e0b2fbc062fd0c2ae1970fae89406d74bb691021a469d64dfad3d5cdbc92b8dfeecf51cc9fb7d15b6e6171639577564b0549fe1395854514af4a008ec71339e5cea2b07717f1321403b07d216e3646c9dd573d54a28775a269fd26291b389e0817d2fa5162102d8ebff58799d3f41a412e6b1e67a97dd3d64e06df0901df641d0fd8eb43461f66e5f95735a47b7bb9f6121c7364a075cac1352c1b7d611eedaca00b2ef3b268c762619c87287213a36cbb973d40424db1c31c63184aa889addc0876a405f9998eec0a81b7622a42f9c134fcc93b55aebe80e0b4e27307b08ce6ad2cf73e8847aeaa93b78e977dcde621cee3cb9c50b40be0fb8f4f63ed451c844e25e2b6899916c7fcbb4ccc740da8b0108741aaecbc61cfa27d2d044fa3e6021b05eeb45b60451101ea7efb54c6304a941fdfd7f65fb9fddefeb189d0ef8c63940a8ec0989cd74ce96ba82eb4a9c3df2f82e6e4265420ea3163565031440eb75f5fe0726a9146e8cb74f27ace990d43a6b5c4d764aa20bfa9dec278c4b743395e07287481b587e7e9e6744b4580a9069d70f356908664371a1c6ba7e29a7aedc526ca3eb2de230d64c80e3a4409d83ea3823d811773d4e1eea78a843455bf61eadd6090299beec1ae3d7a3b9c3916395943b04b24c1d5b447b1e590251b55b14f60d124c968eb9f54734c438fedb0d3711c41553a24d96ffc0ecd702b8d8d200d85ceb600ac36b63b41f11063b053f3c11c6e5564a639fbeb8c8ee047a73b16129caa28748b07b2bf4b9279d696893caf2609be6f1c93ce12c2a8749ed343c9d21f6830f6087f04c0517a1d496f68e648ee779145b1c0e28149e558254935b363027ede43c74389562898bfea6558080e76e70c9da7bbc354e6aaab0778d7520163394ef6dff06864522c64fd00e7fa27cd9f9449cdea4d960c36a6b453ec5a2853c7a898433390501f27c5edd62bd976022c9e59776f524b879faf949c829380b9245ada36526eb9c925f9b705e0fdf9706f43d44aac01986d7eb0bf20c2185a374c570fd193f73c919662b675c46356a1f134708ca495bccbe8e1955d5130a7c88f8fc614e2273761c192c07fcb3f24dd9172b3d065911df5eef0b0b36b80b4033e2cfa4269cd55e14b95c3fc8110b6d4e041b076334e935d1bcb27c296e921ef7c344abcc4a534932ad5523c91b305a35ee2c5c3a05094b36df090ae659010e69165778a9a483aeda255a84bbf9bab4d5f3b34b15e43c6189c11461120315d198ac21b661ac5a2c6775abfde94e44356c405b12b3424872dc5d2405d3457c2cd09add3a9783eea09c08fd88e8386b4195989bae3d5409ce89b838a72e241489021a2c46e3e81c4c627692a75ef1fa0d99793c887b22d1bedd3ca9089d624e4623529f6e7f8e73703bece446a7432a1731c66a0156304174caf9f380bd5ca028372287cb5e155f38537366cb06c01a6de7480af5d7cd32cf88ec2b8c52bebf3ad7ed722ceb34f75a40a325c861d12109d5f5c7bffa02300a810b453c9ffb0b829ad67fc8ee3b3933adabdd45091d33f4d18e02760c3a59f155f1b1df086a002052cc011c951f1cdaccc4b6d93c87f7f63af9a0a677a242353bbb63e0ef4abdbb19d89dee0af10dc4fe3c8d7f1bc8f84b6031b42998de9fda58923fadc5075fe5fe8aff4b8b90b1355100b122ee3cb0144e5aa2f68749161e8ef6999af707037ff9ef99482fc10973ffc7841f7a74a616b40c41631462dfba66e338b493b77d051d1661a6797d420541780dcd9e9c1a09e6d35771f2fd79c7ed6dd49ffb089a103db7f0a9245e29ad747d8af407f2ba5db189d667113a4111c8e7d08a628e8d9807d3110701855fddd02b9df9f0ce700c89e1bc446e354dd7f30672523ed2014360e1a0a5e87bfbad1b0168d4ef574df2b39c49d750281fcdea704e0cde4e47954bd97de07640a1c952aa6f971d756fe0bce76fadd1e44d895c68043f308e31a4f3d8f1c5cdb0958fae6ba55c69e4ff3c2f904743b2129675eec8f9b835912ebbc881b4093594f2f079425a67ebeb38a5db06146910bc2e845215f0482c4f9af309cafc8bfa93f6ce61adfa1fc15b0d7c627dcd3379128fff1453fef2b2317c8ae7990e4c791fe9280dc1dce9e8ef34c929b9a2bbc1fbd25bf2efc43205d3ed533343320805f993171f994b5e71acafb6e5317ef4aed16a436ffaa87ec06e24cde21621786df316d21a4a56afd8008ee69ed9075040595df89748233887cec704418d361d8bf772013aae29f28c62f1e3a7196c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
