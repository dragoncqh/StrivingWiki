<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3f53cd35fe1549a7174aef48d6f3fc0e95422d09f7761cf3a0611f0b511445ab986f82108bf7eacfb1ad6d65d3e978b749fa077c3b86d70d5780b164db2965e7f96e0b896d28e10cbe892a515ab241943e56ca6ad5905f95d099426c1355cf04b88c6c4f0989140b60c861597abb154d88ae78199f38e9f01213e3d86de49893ac7da56383cdb2ec3b18c9d6488c79c90390c1fba58ae75b9d3b8762ec49044b68d47e4650f6e3d2cc7be57c9ef7e3282c4967d5562cf99ed8d7215b551eef755e3e86e3151cd1e72e450fab2c86c335bc50558306a37f2cee3c3c96b66026c5f769ea2878af9fdf84f7208b767abfe0fb1c0ebfae4aff8cad54209af59bd2a786e6f1abd3d613f34b7a6834dbeb4235bb84d993b9cfc6088729b4adda42629651f3076551a1f21a444a6da99801452115233e088c42c0c364ea21a59bd390734d2655d3090ad72836d7f6ac54ff4265d31bfc7a15ec4457657ec5912a36d7802287acefb6b483461cc5ee1f3e77f25d9899563addab75391368b8088d604ff054e36afa8c068afab5e1ab641c3fc787ff1fb673f14fca399c0175415ac026eba88f44c24e64bca2164db8ec0174ac80bcf8282b3ea4b04fe96ac56669248691423a0e98ee9cfd3d9d114be4108628553a76f2bf97259634ff74428df802fd063dc995dedddf29f327092d83e6bffeeb6ee02c7a6fe97a36e6a91bf02d254a1028959fca181511b69e7a9683a2fbbbc42300a965bc74860f723c5291e3fb6728be14029158bbc79598023bbaa119ad8765adae97988c8e41b1fa7998587e7c37aaea0a87af5eb71672e7f6a23d19c15878f248d448401560df0b2568a5271033fa0ecd55c879aaa002233b8c542d4e75acd747ff36f62dbd0f910cc1811c865b41cd9c0c2161d168a35516493ab4bab0128d227a97c9e998a4d821511ce90c6b124851730df6979e3d22db6450b81137e4cf406440cea886bd225d23accbc9c421235c0c6b1ce0e83a043c384a4a1bb2098f0604ce6e8ac1c1de79e5a448303031bd444d63122a9b3e916277bb725c3772179c70337de278794ceecaa33d6ed2ae6833afc4f2898f3d1f7f676113a16d1bd6b42f436a4cec641d807d5d98100e8d01387ad6474b5ea131efaefdfa99f21d888d29c6faa4e5734746f0999a97362f52b272c1e5699b1dd7acbc81724e4341f0f9137dc8fce4717b320839640676174e617e35aa3c4ba9fccd60b31b2abb3d571e05e84d7df7f97375d787fa57b8e4d15f02581e703912dd671d38edd36b743cba941146d95263fe7e08998e88760a777c50d0ae5fa38d1ba7ec65e6bf299e0031c9626c2790418fffacfc47eaa10a0eccd2723a7e3a1e92f0d6b186e0684a5501b6a06934201263c043bff27630b037f0043287ce2cb1731d07f22fedf1ed5a1324357a6a7a9e210e51452a08e8ac5adfa1e25db599769c70e9e7170026f8a3347cd510afa40cd2d7015ff1cb16f58dc1faba80d9909c5e02f6d02c99869db68f87b2610af04ad9507e011ea8bd77169ff3420d0b7263c143fad87f902874f7b05cd257077f2db8eb40bfa13eb092b249647d7e385d8c004330ef37fbbec2b59f704ea075a19782faa11afc6882124ff7395a17f519835ae0f6732f4fdbe6e07c3052cdb456c906017008f43d41db87de365d3c84e50ebd912a68e1105818c3ffb12ce4b7be1f145a5749b1c1d3778ead37102d8a347f544cbf079fea486a22c89c75ea5c00d4954ffe3ee54da53fb260470c9fd66859dbaaa68a1cdb186650b238685d734c1ddd3984432a66412d4b4e8c138e97bf594d693648642f25979852f37773198698db2b9042e8e53d4775c577ff436a4d0196a484ddef07f38a306ff0a716d9770bef892b43158e37f882b92c12fe2e6a9926fdd8fd6833d4e11c728b088ee4b873694bef5dd2d17685f856299e5d49cd26721866a17e63c634ff4d7e55bc026b0c952be0035fd10187d5041c2dd713fd066c28df41306f91abd2c8d47ccc83d37999da89fccaca039b7026b2aaca1cfe40294b2598cb66bd3b4f0648b95bd38fed596d8fa69890cbb984d5903abf454d15c8fbb198c15970b013c48baf55c79192f200a7fa845b293d56cc4df704f553dabb9b97c1f0d1d52473cd3e975cabf4fc2e808e3032ec6e09fcc6e2cba659c958d45cc6a99cc3282623b44178328b11d4fb4f90cb89819d2c571358b354daf0d280f5c478378bca005e224cd4046ded142b418071a4cf884f00bebc6abfd61e50d0991e185d07c070de809f80ee226cab176d3019784e8a057dc51cf8cc9624f640afa60473a0500470569b7fd9bf24c7e91cc898467bc4d3de4739c60e184898b75997c60afc6089d52f0b849f2aaf866dc73e7181fe9ccf766577adcae49a8edea328d0aeb5621be187a449ad98302ad837255a81cf1e8d43e49c6068a10f008457c04fee07f5f3583e828b7c6123470050c4142356114d3ed173d000d4403f8c4ffb30a41aa538339dea5081c372f0158a3a715a8878f8b7c720b5da06f7b034d2b3fd64dea94bdfaa5b01cd234f21a3e3d2302fce1a06e44b6e0daa5b876cdc22600ecef179af31e5ab07f4b7e503624719348c28d68f2ef67d4acd5ccd5e6002b91b53d7de016ea53fa2066d5a749484099154bee9a3bbe5c4be5fb65fc00051527eca3c0009e5636567a65d66ef9f93daa5fc063a7ee3b073cfe0dc76560c36584e41e9e3d171ca2e361f6ad7f526a6e09bd0cfa62d00ee75a14691df2a0cc7033be4d3ce142729af84cce2089e84820a6a5959a0c0e19884db5ae02080d3bb9d3f7ce98939822a0004aa961e9340b3334d377ca7d4a8afd5794569a8afeca3cbd57dfce27e3cc20b9cb3cf2ecd5149cfd55d68bb46457cea5c440d710ad5143921e0866011502beb572442e8cec86e0973f68eddf2daed6fb0d1bb876d8bbf362a0e71e08b508fed989c2e6c4589df67d0b7006cec87ff12afdc6052f4b09963d696336fa00acbb46f2bb7a733e2d80ef5ebd832ef875944cdcef454ac07aaa0646be12ad0a82f81171698d286395351864eccf420559cd1364a77f64599f1c1f3423c90c24c6ab76f5edb4615bd1ee49a0ad65b75ed9690b77c1bab800f6f8b7d71b71a72d78be2e4bd80249ac442773a213947393f775b22b97529fe599e670a23f2d3be3679ad53c81263922868b1ea7cc76fd2e27c7eda5ba62caedf9e1640303c5d6abf37144a87db75b0ee92dda38d40a7ddce4b2858609052dc3bea96edec9ccfc688efbcaa3f8afdeec7ea92957703e96e4b8d8baedf519607791a226f61ed837a571549b3c64e5deb2170272b43868cbc6c7bbae7ce14e352cb0e3b691d450f6da95bedb12dc37299e2cad4a3e49aaac58caf5868a434e83e0e142885bea6c0294282852a974543bf57a16236ca76b9a1d9cdc7626620e51cd414ca485284761bfe365577e204ae530034459ac99a751c173d3389fdd6e751aface06d9b9d49f158bdeb2523036e2a5bcfbbf514f992b57f49469199557f221d0b5844cf3aad0f7b3ba950d7d42aabbf082bae72059ef2dc8ae3425d2f93d3f436a87ac31b2b95943f6ed4dc09d0bbe70a8e8573d0b39601c4646dcb83a3d1a05ee347144c17b60a3c2b478a4e048ab281bb322f72843118b6128d594f97468da36962f85881fa83032698ec55441c8c5bd30892448a301d69b852f1acaf27155d7219d0dde40623b6f0cba95ec5777bf6d4bca954b4d1d1e8acf9dab1ad814feaddc488740105977de10e4fbe63e6df38dfd8cc779ce8bf70a4dae53a99e03d81786ebdb55e83b20627248c073cb6ed14e2811889c66b2c214db579fda28fc8a06e7cd34906364d64c2488179c2f691a65d3de4094d796f56b3470e42ea54d252bac1bd9c9bda91766de7b836525afb24bf2265f579c90398f52da619f3c9788153c97ef65e3e86e81d3eebee48e5cf8c75a553980c9dd5cc8449b5baaed8ad57893d770027e685c823e2aed293bad8684d05bea01de678a49d69b0ea1aa09b51a13573fc05e3198cdd202f6634c02c9ee1e05cea4ffc84c54acbbd7ddc1e9583c90e566312752b62a621cd11b07c05ee1df39037307cd9e8fa753d39fe2729d999053b9182b839ce2b47dd240d7c2f4cc03a5af1b3e1fa1bd82e9f37c0625cb0cffc78392a5e60fdaa46ad89dccd5de210c03c38e09788c52b2049f22145a2ed481f3a150ed6300d912aa12a333c9d9871ffff9d3e64cf0e4cbadd09396d1fcbcef0f544be6d71b57b838496cf3c87979ebfb3da2b5b08cab981f68edac3a4d4d003d4195fe8bf265f64f08eaff24170c362ccc87a8578d970a0349a7a5d267744956b64cf7b4a7fa8e92cb3a8e9953eb0df7a987c708501cb054c80a8bf98ab1650c3953484541703250092eb4577bc4c13947211b7917a1b7a4a8bf17e04034943763ccd0a7f86b8075e847239617a7e392df25d833590fb3bfc7748dbc645a99111c4b4a4ddbdb6b6889c8a4b2fa1900d0be69e7ed7e39611a530d14bb717d5581d3350dde86d2f180fde20bc488045bf44ecc600db85587eb27808a719654c2ec9577fe0b93242149fc1763ca6d2369250a9ebcee79721f2bf17df6458a9b5815e434e25726f6db7bb7d9c0554e9001e7976404d5be40057374a21f6f4e2e2e615930fd41af9f96995f37b930e152461fa00372c548364bdf5186c6b5f5e5ae8998090a1bfee2476c43f3b45ce2089cf595568a80b80b9799a09c5d77ad0baf8298f1a6e6326e504fee2e768b0ca49a9722719012def7f59c37b91a68c81b029a7378e3ddc862dc8c13320daf1f56521218cb07f41fc6982ca1ddbcdae7ea686e4e51f04838641d5e03839095ff03d3c97820d40952789ba9daa79d20a3166178dea0acbdef647373a2ebf441676f93db70356185a2be6a6196e85e2ec9a41240c769f8ff7b1fcbdef09e29c6f5a62b064a2d203b8a90a3a8baaf63b81e6050833419a57dbb6095429228bd2b83b8ae979216eec022e55b3090bea952dbe8089b641026687d11d60443f4140e8cd17357d8c7b36b0bb6c0b6a292487e6d0d71a0e7e8507d16cae71f3ff8a196da4b014a145b1ca0cb5adebd450147a27f3922d6d73a0f015d9866aa1c4791fe3da04fc1cc4af21e244e92df50e75f22a96b58d40f46de8c3f139c1af667c08a9c2af9bcb73172fe5b852a01678cb93fa9464a3d9a1de6f4d26ed8a6e72349a580d2729eaff69597cac0f3c1c03ec90870d5f542dd3a403e3cfbe1575c19035b2bff5946c24ef377effec1b244bee6c20b5bb8e292bc14b7215e7a2802820422ddc7fe26312fd906994a7b81ea7898cb86061f61b000f7792ee3bee6b356fc8fd9a236f1682c59f1b827d8ec53991a0b6d0e8170638bc4c051464070b1c8e3eef773fa7b626663aa9e5262f63bc795bebfcea5769a2347c48e93775c8093d1c074ba2804fa9e275c6a820504e126a4dae40b381deae5f8d8099d576a40ea940f73b4087181084af7c7fa1b6e4b15548245c86527861590ac8fbef04c355761a0985cf1fa1f94de1105565fc17e2a0a4519ebe340ccf1113f108367657e756b59f14416e4d5c43d923677bc89bc1b01a496cc3c878801a7c004e364e842e384e4a3de88716ed11132212b12ca456f3fa951ae2ebf243e71f6b2fd01124979070930c17cdd84e282ef1d9f1f5d12d7f99343ce007b48c1bc3d3650b721c7cb22861686c57c32ff5943081f0ee695c6835e5f514ba6c1fb1ea536b19abff3ea6ebe8beaf48a7404c4cacdc2d56ca8b3d856aed73eea55f0e93a62897d50f7c89f0342fb7fec2c613480201c8d5b32df7e3d1edd9980a361aee181c0af7ad17ebdc8570fb2068a8ec2c5a07e8ec2d603e29358733152034bcef5f2d1800acd1fa7f2fe3fdf236b1f8092d43f7ba47f855069d89713ad477c3116214f94cff6b0e5d8ca98307e0c235d4613a8d8d5b2dde584f867d46d2c4763bd46f331ea4268fa46a9ad8fa08568cb2657c54ab9c1ad046e643d775edaa0ade133b4a908d12cadeefc01c22eff69197b9154929173a147b08ffdf3185b65dea529ced27049b466aa0e19cbb5782e5874dce9343c2669d169e59c04c6bada622ff77a5572a468886557ed4e0a0ff8af07785b48bae58e68dfde1465534b2213c89efb80c010b0194dd357ab492a168d2da2d750cff1c2f466d2e3bf7a67364087184e8fc0cd4278237add12ce7793b5466c20ea8a8ea5f4248cd004bbe9acaf24ce9188e2c4c3344435c9d9143d95ff35ceb3a3d8c3003d59503b99c54da33223bc5b19f4aa3a8d967edc6ca6b0ae82f786073046654bff73ada69d1c5b0e5e62614bbff14c506aabee841d2c4a855eb42c64445ededd82fcec3dc64e172aaca322fa16731c3224462590e8f2a4de861437d966e221bb712aad2e050f7a0e7101cbcf0f30129ac5db94e42dce2b66a98e591b8e2d0578a1336165530f95cfe0007d14e102d65abefcdca0258c65e7cc851a9ab9698374b447ddd1ae3960b0b196b61516a82c229b2747cffd186ed7a18834ad78187ecb9fc8aafa16abc666424303deac4804a11eaed29d4d517bb2bd1e6d13c85f69321691d5dd77121c5958b629450b251d7996863a5963e25717d201d1e9c08d6a4b491e3ce12acbe1affd94bf98cbf359907aa6c68c49264177eda984ca9ec549e0c9c97c8b567060dbf7ec5268e28067aa895a75b9583370509fdae646e8d73c22edd7c7172910559d46aa1c7ae21fc17e7f940a335b9c36161cf12a0570d89266d62064cfa787f4a69bfa635e983e63b7249e8bcee5d24e3586011b05bbbf46813b4e5285f27efa691ab0e7e84d1dba80ef35a41baae6e7bc9293f2f267e87872e094cd76833b6dbc909dbbb0081cf07e56e9528268006d758a215e983890b921f30bab9bd138cd1348f9223ed9420a21ccb8470118b6c3e2c563fd9999f92cf93e9365000aa1d7212d385c57f2318860b618451575761e15f79a73940fc2800381665d8fc3adb3e2d8edd597c224a18ac117ccd2c0f846f809b7f73643183cd990bff20afc7124c6153c2b29e3fca5589dc858a31b66a388bc56501f0d6bd8ad0cf7085101102957c7acd1fc4801e7e08309fc415b6b17bffcc1a8a16953001ae83c68bbdd06ef4d4662df787bf2a5a572c6b3d2d0812ac1278c65512d9a6a99474eaf067033c1366c9c11a8dc85c40687779fdcc2f6f7162ab6559ace0cf8f212b167df8b528a9395b10e4e76e7ca9d2759ccb41f3744fe41adbae6a9b3383cc9cc6172293c489d484d869ca10fcf36616461ee1111f962d4cba8b73eaffab6301aee00d51ace4d9c3375acbc9327e328d5a21782220947c0f710ffe8acf4b9bccf31248c0cbfb856d443e2fc2f14c2aac351c9e1b1c091421051bbc541a8367b819526b93be15ccc79b470767b36aa58f8d570c2826b5bc868fd10e426be3de0dccf972234d7a58e3782ab9832268cf1100296607e92fb4d619485d56cf432735aa508e85d89cb9c34fdba41d53197d774090355d168d429bd1b15eb5b82e6aaccef77cd7310c546490e5029560352c7f8b4d6ac3cd0e88a4ab39cf96ecde76041bcbc34d9608d407179eb21a25c90a1cfae03c8f8fb0eaf55fbf9449e4b32850d51e961c0fc3d64a4e3789af0428b5bbce8a4c9bc1c3deb97d5e5dc7fd9b2ebe2fc8ad3f80c34d58a3a826cb2ada5713482eac8b01924210910b65db8a15458b59a88e53b3e580f7e55c5795f2363a42f465a6f2ee4513f87ece262571aec529a2bf08c23a1ab40f020cb3622d68d5ee7a830282c6abf4490bafbbd2429c7a16b4fa663ef2a1353099cae0f8a0bb335940b3ca381c70f9954257ade1648472352a6d554114a46359f0533442f6dfbc3d1816bfcc1762bea34b94838b4a77fe32d58422e61c56fc2e4de972e43fe4614ee800ccfdc58f17c6b1694c369129ece5d9aabf83106dbaf8ee7ce1a3f6e9f0fff371953f3765d790aea6cecc50782f1114854c820b850e22f905b9f51e90b15e9ac50b27fd408513bf87b26334802c7de4a4698d0c7ab0e94eecc6ecd26a706aed9cc2efcd14a2eb84659c55c42c03fc26644f36e42445c6f493fe4427171899ee241c9a9fe3ac2e7aa450e715f55ac10d472814e364a1bd81c49e2c98e093f7c34a278d89bee2c991ed97df35566afbe2de7eddf24dc65987f4d00d0749d5a945a3342f9f5bf770cd7be711ca7524bc6b58ef65f8c9264a1340e5dd914a51e556e45b0afaa431da19ed1b77013226ec0391dea9cbe4e88c175dba5a11a0fcf31f14c9429cdd6e668e9813746459ccf16e9217dd87c111478d25bb64a7c8b4325f303a2912df91c637723773b86769ec7a08e089bd503949dfa9b7c05f92c1322b5afbb3300ea74c2946c544ae4a6f78ecb918f2a7b18b5afe407e4e2c33a6fa8dd938b240bd4cf7a9c2c3e69b0ad7ce823462fc1b8384440faee4bada3077acff183ac86264c24e4f687d31097d81816dffda186025db89ca977f24aa030b75cb6f3252f690b85d000d850db3249b60b2cfd75b7a01d9aa9434c5c74a9c16be5f3fa96b57b659ca7c4084c1bef51b4e34f06cc8849b787de03f59b5194f3e9fb12fbd60a7b9d6ccbdc541696ac3575225bdf6652a3ee83ba59f2036b6dce35b61120781ec12fe0da0cd4c4354d41653119ca01a71665e75c61fa2b892fdd54586ef3ed86ffcd2d1a6fd65dc71200364daf38749bffd7842ef2776fd75fdef14d85cdd4b1bf33c13bdedc779309656b7a029fb15e7344b651016db61bc3910727618941d2c33ad84c969546cdf8b001492155cec7255343db8f614fc7b2090eeed2d1d9235a8c692151db4d6f1e4686b8515f6781a711a8f2d4fd67c651f026e8c77c1a104bbd3e7de17346a08910d3e35d4cda7ca47a901ecbbc42375621695966af1677cc60e88545d6f9f4bbeb7abc8c30b38d03502bdd854f46f036fb20bad224c623d9665d606c89220c1aaf33a1065d5e80904b4652a335cd1a558998d484fa1a1c907e51bdddca7b8494d53e81552cc59008742e49d9615ce2e7da0d848c0df034994f1f199caa54898577c805d990ed4bbffb36df39df176e8a8ed5d5cb3d5090ba9aa6a48ce15e078b13c6ced3fb962b5cc760852a1cf6b91eadb553d663d25c3f00229949a36ce2ed5d0d6507ec2991e7d98656461f1c5d3f584fef31f8f724fc8d75d15db810d7d7dc20233b5fff904703aefacb71e2024142cb5e093ede3837a2c4ccd8c6b5f9b0df951d3a715845dc441515902813bbf4d893fa3001d27c83629bb98a888088be5b81be6a289fcf3bb199742b35f7cc7b5720580117e4c39376cb836b2d457b55ade48721010ca427ec76fa9d491997bb4dcb986b313151aa76ee00a6be76389aef2554d71a3fbc0e8067fc52a611815871d7b49e62a1855c65958d0a8f75d3f1af3d96ffc6cf94cd1ceb99892da332a65c2042dbb5c44cba172dc516dd62bb31eddad94ba8b954e412888a813dda83726406b5ff76861142bfa0c3ffb8746c753dd7439e9519d1fb9ccada27b3bd8bcbdac02182ccf36cffcac1aac1041b02fe29dfc647df25f0162d832f48ede16eb294a40673d6b9607b3a3c0dee8d685635705037f8121a26ba45724b48cea54cec162ad0f160352514d070cac8c7bc5e70c7f68fb5f0d863c60e58b688c216fc9fb15b6d76aa826c98d8cd988af439b2db3a1791dec18ab418c5b286b4df583125acbb0de67d65f7cfc4a850794402dc1a692756f5cbb4246b5e6ba9d49bc153c382078616262f70ff925382d74981774c5a284a3811dd7fc172434f43f56e5e1fab517c116b7524517bdc084e74634e1d3ad0ec1ea1b7261b98b69e3914fae63e497c2fa0dda9f39cdb8bb27b4880c86f15f60789328450c6f0aff508a1819979e2c57546cf05e3f39d2b3f4f0675815f62bd03877701085e501c3446304cdcce2ee054a2e39b4ac258bba80fb44cb6e892cc7470a35c758102cc9844e19c69b159dae03bce3a8d0d1b2bebeccde0f2b28b14931556c2b93e24cf116317b403686d3bcc6258a3c1b9a55d3a0c98eb2eb5823ca36653226f1524de74b3b6d95bd4bcfa1a8eda8ca40b596827cea3489bb8f521fc70c74e4463da60640b9bdc955ed0adf698edc916b6b6b801998860e8d9dbf3a5431b7024265c636881651bd7eb3dece40833f0bc791cdb3717f0456141aa539b09d1345ac3f4b9e76f7fc43004057048ca503f327a95dc29e9c8cb2aadda2a275d6701b7796c245e5880c2fbfdbcc450761cd0f69fe24b5068298590509f6d4757387803e6986d49691af10dbc1de5a9bf60f7b775e6216c55b26f86f3c52a5163321f5774df20fc0505acd673d47b1af8296f4a1eada7a4119f07c17b7627e3dc6d230e0068649c42af413d8ab100c390a24dded1710d7795ca80984af59c09266723e9b36dc2a3d3a73fea8d6d07ab982a470db862c8bee4abfc28af58974014bf7a038501761a2994271d7b7cebbaf8126047f7fefdc6bc9db179ad0944ee3e96210435fdb1174aad424e7ff6c829f50b9953a7f32264bd46398cae0784c06d5fbb14073874b0b7d11d7e58303981c5204f39653315799b1faff8ef40d16466d9ba9ec4bf3ba4a1ab94db6814ea0825caeec889234eb0b5237cc1a1f3ea00f68584f2d918b4ced4202967967e21097abf35861ca364d2fac3abdf80681e842d535d364ebcb496bce3e0039809e9ce80f4ba6c7a664ff7f0d75cfd593bc0cd9ee6ed97487c299216ba21adb65fd18666564f0ff574378ecef38ca673b91bfe4be22493a750a60f89d0f1207987f293aff202c85c61accbd866044a33d4163dd004029fc074c1cb8e44fc7f6125dc47f61ccab7d5fd9afa0a12b56e1ddd27982aed2c68c283632e17793dd14ce798db79280d7682157f7de9679b5e38cc5c9f27ecfdb19a4e20a02700950e74974f9aee9c4db2e95ea18166eb0e107d058f93b13346e5c9e2c7c275f22314f0e4bd7c47cca18d4994bd864ed2f7e4b0de4fc83c74b759945652685db181882a10fcc598df21de6fa81442404eba8d971009cd3a57c10a7a227048261e59f92503dd9269d9f0b56b5c5b2e55dd63a6aeebdd0464462860d3ae8ee143889429a032b12fe29b7877bfd3f14626fa3b99cc5031449353b2b4186ed47e5afda56948beedefc0c9638d6f7705596868f1904f5031c79169ebbab249f0651286e5d8d13e5feac7da2097e20d590371fbd2d76b33d66dbcc280ade9453aadb95373536f5c49e39e9b99f956837486eb16b7b082ccd45187885b1f2b994d52ca40a8826497989ca6f3f50665dd16f4c63e0e96eeece2ccd03891e6bfca1dd9e7a81b95953a575efbb63636bc593a6380d17022b2c68e64d42ceea6c51177418294e0bba3331358682ddc773688e3e59587bd9b902f2ec4d5568fad7a3ae608269d7acbf86f44d793f6c693e6e42c5cb90345467f8819e9a0e4ac0b7eecd6a14850b14e27632214cb2b10ead3cfa9ba4b0b3b30bded84de9342920163c8b7a9ed8e27c4b0dd0dac3f2b55761fa7368a8789952ce1bb711e031897306eea706a498bee952c8e33eb322dc911605f7acda5ef90b89899b2d95c41b327c42fc1e40107ec197f750d57397a89de6e757e1d5839150e53f404e99cebf42abf37b26ed2d4738a5a2883a7560a67f54fff2e8364ef180a2924b6d4ffe1b3b77fa13b15c981d29f80511b11512fdf5a285ac75152145c72fafb16a6250efa896c1be2ea4e9d0c446fb8dcbecae32e9e2b7b3c5e07a3120301cfab1acce2b0e8ae33316576915761c29ffd7f027de424bbb5ee45f68bb7726094152d13d916b8302bcb7bfd3965658a4b3781b932ea070d7f7dfeafd534cb696bd92372803ce1a2e1fddce62da5b7a4ec16f95aff6be7eb135753fa3c3aab5b83de91b8a61393b7e383aeef165f514050c1df2669f8a21f213ba372b17835ded69e3ea703c179c5aa89fe8b374c75176fd20f1075989ad0973e6cc09639cca4a8f2da38c5c0ffbca239940e2d4fb4e826804375c92c7ae49bbe6d4ba775cbaa5d4167a15c97acdaf4c29fef2f60b125145feb0c4f2e6fa3806a4e6a300a3f09944b3aeded7924ce32fea1952a13c0cc1e8c2906dd08672d8af81b65af74751a3044026f9eb967f8910d6139b5c5431cadfd25888d2f95dcc11fe0fa4f3556433c904b927af4595db2ef8494cedcfca4e673c0aefb4a512e44b50ac374a7dae0762a33dc6327e8cafa1c4dbb10025b8404c3cfcf6f6c303f9a9f4fad92671c54de36be7e1cd5a40fefff18e562200673fb9cd4fb6ed18f5c2dc0aa042149fe3df8be2e612a7fce762590d6744a9cb0ef9d4a14a068b60227f7c6aef500a197eff23bddf8f86b3a6e2db71c665a2cb02ddd6e1ba2f33a4f75f6cfbbcc9aea0c4d3b626d73727ee01351ffdbc0fbeda58f3ea3d3232e87b913b6a44c87ab6cdd98a55bf4eb9ed1eae882a9ad5fd7dc127b8df223639a442fb3993dab7842b942c8b201fc97fa2c23eadbedbf873af5b6ca28613b8ebdec22f4df42d17ca2f77654d9867fbe4f1d32e5f8c2f7cdfb7e72d49cd7960a0cf6b52da8e69e05057ba8d0b56e66694457bc5384442fe4242d871f523db135de52e70608d016b805465a26e5d6f3a2f26614e75e59a0fe5facf50c8c1bafda9549d9cc1547f7920daeeed58e41f49a071cc398f62390096b1f1dcee1c8d605b9aa9438a615ab9dae39efa38201001aad251952548f05818637953cbb981653496be29cf1fd5d00dc747ad5ed2cc87decf639ea90e7450bc7d6db5bf8d0ea50d2feefb6d9813fa25300dd4f7ad5aef554c525d1da9e84fbdd826c5355ce471c368d611ad1a56da14ab0c7ca11f9cf189f857f632d0deea78b8dcd597227afd8f7ae41abf895cbbcb0cfe05187a11e926f89eec02a7363cfd38d338098e28e80a6d195eebed8ef75fea79269562f23498a433c7d2b70c44c86a95ccb48d6e104a28002db29f172c92a0b1f6dcd4d236462a8fab957df86dc2a26c8caf1b19301bd400ec66406b3339d82e98cf81b66ce301783486f658cb6d1a5afdb76b41acda51a84b82e803802245d537a7aa1f38ee070531a79a7eba480d270e171a81eaa3622a27bd8ecb4498810de2614176b90f6f55aa95b6dc9442504434393f92a576570d9b7d28ba47ead9d3fd42e9ee375f491bc9044837d049264f2e7cf2586388c81c4dfaa8bbf776594e451ea25e1d05b969e43ffe018a8bc5e1d62685db711b3dd5575bb58c1941b1bf60d86232f2a70beff941b1da25622af868a56af3829110896d7da1e98dba5415fb07502e84a0a1d0263ef2d75d6ceb2b343f4fc6f24967c602f337f582d1e7a91df25042e4e96898acacb295b101349a242653ad02356121226788479f98b57b12fcd1cff34d7edca252f5694c1545873553d4f410bb3427d5f96178374b509e15c6ec906f277552eedaa4a212f42a80c6572d7ec45d6c33e794c0736ca35d08288e84de74801b0a6b444533336078da61baa763571d5d0fb2ed10bbe084e120ad6141b53276781b8677038b7c434126c2ccf3663872fcb7eff7a9bbee5c975e5310d231dba6d0416c954b076c23712cb8bc4c927c997e1c94ed6bd55d2386781c030655bfb1a2b930091d2d943bc2b060506b658cf9c109ae5c144c02aed16342fb1d0c4af81af9a46902fc45aa533682c9490c60d641b1bd6519559c64a7db7252d76c5035b0d145d9472ab322aa9ce3acfd6abdda347b106496abf50b81a935e9fc7c3f5ebeb86978c1823f505ac6d2b828a98c692f5a266f77a1875d4a96c010acce4a4512911bab0e54a88b87b18273451460376d5459012b670a3aa4dee5d7ee81b30edddbd23a48d00c57771c4aacd52a23591e29fed2b6d91876bfa27e818507899255c0b30ec33dc950d2969e9b6a872b5c4e336ef62b2e5ee2dff33d6e4c51bd67ef700b049707a59508718ced658375e7dad622f249be76f8954dfa8d389d89859f4b9c3887e7c07daa73dfc34bb1fc37e029ef78b98d104572527ab8f7afd02d3e00f7b969f0a9ee4b9dae92191ae1f3e37a46b6436c794ddcbac463eea90d197f53c00aaaa842e010f54231e105f12824b1a38e2b8d42fa39fdc4c308093759d7c9626235d6554817eeeb1de7d7a863e360e794e54606d8cbc9db4d5b8d5705cebcc812bf722b8a9d51743adfb37c1a8e8f85091a544feb8a4476f1ef86fe34bd20dfef88760edc0878d88cecf6627e3098b23ff86f97fabc84d3e29b03f710bbadbf7c01ee8c7bedf22e2c08b4d65d66d4efe8ce472231905a4ec7c1aed1ef0959bdad2b71e68ab6cc051f5bb5ea4016218052624e1d2e619be411a965d3625b14d13c78464db185f4230beec4632f171b6833052e45e5a8298fc14e3a74a0096dda2c1d6629a11d95c7df5d87a86d609d31a0c3b60e700a4104e88c5e01839ede61364d948af5ede54578094c928ec213e687375276dbfbd1dc1e2a635366a1cfd3caf629a3742f48f5d85a8009de2fdfe76aa07d4888663a28bc8b6b629dc19fd563a54d65479e00ef81c0c77d0031540dffe76672316491ea2b1fa8452db9293b56c1d8cd5bf8f15bd94b3bf23020139cabc331886536b23220cb475cde7307091fa2a289d3c73c102458e9e77f24b3560554f22d9fade7cfae70b8c29463d168fe4bac149b1071cd590fc901395e5b28f5771d030593b3068c0c28021d2667a4254c018bcc8b52e6cdef88074fef685f0251f19d1b1a161c7405ec1fa5e4efab1a605a37c73c56171257828ee4a3df8e4c9e95beec873cc0e9a1d125237aa3fbf63c71125438616e1f57ae184a352e22c6253a2d1c271a5ce895c00e81044c81efa07fb2076dbb74031175b495f5af4cc678d97f737e6bc6d7ed51c4a23a9a5d2d1e5c428a5453b163791cc2f07355bd24d1d6b8cc95f214e671a08f1f78f46937280fecb8d20321ec8ba4669411e220157fa2ea00d9961423248b8c1e83a7e8e42850e9bdd78305f2722434e0d4835dd6066cc12f194c3fdbf947f97e384aa41d3bc3164f1c94212f4a4a34bdbf9c98c5be3dc55428021936334bd669eb1190b5f9f769cf75a467428e2617d9e733b86684727d60a75a23a156a46b909c6b2e83b7fdebf1de63790bd7646547462c762725695e2c6f9ccf860f2ecb82b551e9fdec8795b504b80f1c8fa57c587ca1e266fc5ab0793d40d75f1146de2e1c46aa2283a279874fd13b3f29dfc4a1a9dcfc20144bbcd758a69b2a5f74b5a7b80e7b1bf40dc960702bf118e4537c96ad4e43b62ae68fbc2ef02792af89b00606d47402f660b1dd76b269e764bea45d5e22515aa4c5ea04b949a8498d379f863ad4ed7a52a8735d64a1f103293ee5aa2a576fd6df61df405cf939fd306a94c130b9c71e775bcd66b716fdb797e8943f9c77b742038db765ac4562bcdacb1183105df2df44c41091195c181171e68de326497d1a2b9c02be2969a765322e3783b00e2c01812a81b4a7d6df4683a9636fb359c96c8e05b89395777683504a281713b4d05dfc25c713669d98cfb6a9f99dce8ab95f8a8da13b426fcaa6cc8599056863a92e3a18d6493e39cb277574f0729bdbe6de5758615179e2e1e042852ef1c3612280c88ee8d81b9926d76764adeca15358a2bc614144d44f983a59869f17af3dc5ae27de31ac750e1cc94fbf53a97d440b599ef279450b23a0e6b05caab5fcd2b5570bbcf2ac8970d0678d3c68790f59d91888f4b1b987e1b32edc97675894755bd11dc7de6ed37ee875fe7c79c755e5158f51be607896b0783b3fee5feeb92278d767c06c841c25d10c5bc53891b798fbd05cc55c61693147958983bdf96b5448dc753d381eaf7effd27eb3c1f86dd58bbe4a744c599060655ae5b4141d374eec9554eb7fdaf120a9e21663fbfa2e2b4e68d87d29fb3daf0b88beef01a4b843ba7d3910db7e62015c76736cff43bca9163d62bc69244ca278efaef4050e96bf4f000a9f98537cfd92ca5fb2940821e5ab653ecce3673a28f370df3146a8d953e3d9e9fb27dd1dedd181c13997de79f4addf06bfd914727da1e245d02d88b31f0ddbf9304bf90e09e416d15632568617fc5be98d29553ce60dc59eafa1c3d225090a24f026dbcbc4aa16e9b4807baa066ae8f41cd86f02d21cc78aa91f64c0c7bc38593c0b06172547e15eac0b83ffc3202fc595fa2617de35298f21b9f961fcbc9bd4e594a2f77f8aa115a84a43885eb9361","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
