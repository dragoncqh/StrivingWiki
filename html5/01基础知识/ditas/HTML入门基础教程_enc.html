<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf1261b977324f93adced3e17655f16b351d68bc032af40e9296de6aebeaaf386c058a63c5da85de9fcdb69733c5282ceb0af3146642069c1302d1267f012facb7e48db55525899c6eed983e7daa46563df91919a38cb7c1989759c5baf68945c6a6939db7a8044588e9cdd297aecc0acb57339545296ddb054172c2ee51414ab952a61adcce65219ad274278a5a85003f73ae83b23406d1b3afbd9fc8cf96dac278608675763d1e9bde4c8397c50ef3bf6ad63f72e446421157dca1d5e80bfe803e54f7fc47c3fed63c2f2fb83ea3543b2cf8c7985101e22cfb97836784ec6672879ea5f33cf9aef1b5ca3c3db52446d61a3df963b7cf3f9cde0afc6f6b9100cecee7d02208ad88c83306ab9db29df49886c9d557e746cf812b1cdd026b65dcfd1f08ef31f7990090283ecf623f79bb81403a2ffc8492a6d14818081e3ec94155ab979335ae5f97a6478d0108a4b201b0fad5f9276411bcc444147b4acb75c11ad20f2fc7d53ac7e6bf612c201c61130fdfcce29c60a9dbdcb346fc2b7a1a5c9e2f778a2d2951ba104176b133825987967c6782d5e946dc9f264536de1b4402850c8c7972ef31aca583a5ff581a09a31daafffcca9c74d80e53fcc19cf8a66c38a532ddf03e054c1b5f6841caa09944a3b6a4097f7a569c59c838debfca24c02a767eb73447c23aa751a46e0470efe06cdf59fb30e3ee219a6dc316393229baba0b9eb6cfc6e8a94669ff95799052de3f0b4b4ddafab5326e9d6b1041decaa402ab5d9237c6e2d5a962b67a665618bae894c2456ec50bf511bcc9ec4d40ef302a35930db6e5bc31f034d0ac491f1917c8232401bcc925d15ee59a6993dd2afdb08c9967a5951140afa87392e3fa90bd19805c449d01ecf680508839baa591d75bfc3924cdd92fb937ed53534d71c2f6beba9cb182497c6f970b92a5b075e9b038674e10146cf9879c9d17f0a00db1802d41b810e2823aa89e0c570ea10c648ca8e4ded9111a7cd93e7ce723d42b1625300d8ffb029304ae95230e3cb2a4c5110abb2cbe3f51ad2fcf8c8449971889d0b735f034d2f1211ae049e460f9da21bd6f20c3a74c15723d07ff06e5b22c82916c601aabc7d023fb5762909d263d72b9d5007f3915a25a86abb1b6915b1d789a321c70ca6735346959828f9ad0140329496fd54fc82f3d5f1ce4550e017068a5deefa8cbb74b4e53b1ecff9345d818aa804080089189a8e13fc818f68183d9868f82885741919293ecdf0188f2dc9df8abe197a53f68eeecab50723906440741e82ea4220e9a029a26bc16b2fb1fba872a0c7b3a65c090b2b3c0469e912a99076f6f5310a60cc857cc0786267b101da4d0a71761e084960e2abd27b9a4273645206961e52d25cc263e60bedf4e4c8177d2319ea3412216cb4755d4501a6c2d611e57d0316dfc7b96bab4fcc1144d7bdfd0fcd201ade19f7f9647846fa52ad11e07a0f4f86518883859699599905aaa91e5e4e6edf3b977f9066fdf62c96477a553973a751479db99d426fa701f31ccb3d2e4ddac289f287616d9d02c2f2e6cab73a3798d48aa5fe8e05f20ebba4675a0a217ea4f24b7b087b9eae863dabfdb20802aec2e0221225900e7e8a9e1d30f99fb8fe214eac2af9abb4dfc75d4994cc6f0c7c33403ac0b98bbd0c79c0e6c5bd40813e1d5f465726f2f66862ebb18d9da3f7eacfb602cda45e0d9997f7b405314e577e19f90ebc36156de1b78702b78db01847e509a9d4886149e07051d3bd4d46fcd2f8029db7aa1c9fe29297c2b29945452183f3abc313c2417c2d8f6ff7c284b619a120bb41680c492485619a5e47a0e3f1cdf23e8cbfbf9ac97a2f35554a6c1adc20267463abae51daba65d882e7cbd5e79011d7a383d881e53ef339014bab9000b2ea506624a945be67f5ce773e650c7fb96f60928b25c873b8520a9b976dc56bbd17c1824e079ae0bdd4fa74b53eb80226c0a4ddc625355bc19f3f44d1e88fa67377923f1dbd1d1b8a9922f0a32c2d6221734cea7f1b4c44a020bdc66a514764d9bee562de8404985afa3f597a502e27c91a4aad0d1df04b9528fe444f05f979fc7e3d3022d29354a673b3bf89af71064cfddd2ffb1b46489a535a1335e4e3150c13b888f10f7afa618573a2103a5f45658354fd9bbcb8af16e8cefd1ea5f0a1c2d8e77f91d2e99a2cf81e6213453f072c42ab6c41b125c8174241b8c79f7e518da95de87b92ff0f2c514d2c10719b65d768fa7aa327b0565d6c8b61ae3ddbc2d95e7dec0c426b3181dd0deaf06fb93181cd4b26fa0488084f940c5335ed5b7dd08460411107ee80ef4e3b76dddd96b650dac5b8c6e3fd65c4687091271a28925005a83875c2a523905090a3a9758e3439d5c7310b9428be1b73f61d868c696548fe9f70b5c8bb8f9caa69e0a08cbdbc801969b63dd2b8f749be56368fe01d97b80f0373a05a2f54987e3650f133a2f02607a3f336d8217da24e7c78d65ee861a42d64f3e97990d7cb6dda12a6596f0b78a333610777677c1fdb77066391e4f3f08bdbbc5b0aafbd137cf4d0f49e308d86844a63ca089cee56df25c78595312ce93924d8213c28823c59a6262835e7d21256209d0495d1df4a6719f2242873026427a32771d3046ea0aa6337177e2e371663240cdfc3a80a07293037a832dd985356c8c81e4175b1ff60306f1249f7d0c4d9ad54ad637a21f13c1685efff2340c21b72a162238df049056613b945de72db52ab173329092dca21b1e10cde640f6d51e69fd4be4e474754aa2a0b1318f390c58836d8832ab8df967334c3df733b326cc4699a13875ae120b921e419e73ad235e65c8e43402e1c88b72433f2c7f64e06c4a248dce58d9537cd8fe1dba53ebe1c9cdf3139529210b68dfed7aaf5568e5c6d0d6eefb2099a07f5f4b4322053437b03bf3af817dcb925f34f070437fc32d1835539fa0cc5c6ab7432be9d9efac96089389bc0a48e2e18bf89f3d854a40ac6d7cd66a39b37ccffc2c2a877074b4fb5f86a601da1adf279a17b3b4bf62c7e30e5656442b70300ec22684d6730bcf74bdb02d62ab00ec1b9b9189f570a8eaad4c808dafc214442dec570922e74427845997d5583c9768d354c5480e2d714343591b214d7b553177dd57a17e253b8b52fb6b7d69799ef188edb403e3fc025cd536b87f50129bdd6f5935e93b7435ed26965c72cc35e8d849fd75980609c53f34fd17dfd47176228fce38403131c04216ea71697557bcc54bdbd5c3c63140d989d3c4896888156dbd446ad31db16f6ada79a09761be8c9bcd4d7a75b48edd12d87fd3808d94c2efa1ee4d2f308a596d7752f2ac36e6488d57036f09fc1639e3d14b0653418be8fa23121ee6258cc248b07b89a93ddb0aa0243021b5ace07444190541f44e196982eb04cf5538f9abeba52b22177b5069f322568c28ba6b4c625dab819302f32995ad7c417bafecf8135afbf70805255b1d36139068c91076fd967e7bad566fea4f3a32958ae8d756c34625a57233a24a08c4c6ebc22ab76dd0f89b8fd2ab56ca4a2be65a0295447a0eb4481665ac9a6134e48896534be441484c6d11901e0cc922734a60cb07791a82d4dbb324abe73bcd8007628b58cd992d5b2f3d38dcb11dcd74eee721350a464f48acb0204f0646e97c3ca585d8f565a3f030a2f09b7124c1faed0fac422070b2cd2048fba874c47f3c309354777c25f84a565e8a5f9eb7ec380b18aad425ce9c96f6145a7780fa40649357cbb24eab92952724a3dc7897f2b642c25b8a8458a79325d0c5d235ed179f240f62bfcff77fdcb416dfcb0261e21fc4aa4ea667663b5cf3488181f8b9e86763598a9a28c93bd49cf2a73cb0bc2a1cf0617d0b6b3c43187d226bfe509da408bcc40d8baca1421c2c501e16e168e7ba33f704188193646c0e282215fa3069aa98b9a5d8e3c3c8d49ec1a5072ead775e6518725846cc43ec669e5ccf30fef346043123947d9e71eaa97622c8fbe4ec6930a6385e101c5408512b9d23e8d4de2a99604e05d70df4b925f0fae70549f3c4b11b283d3182fc88bde050788c58000d4e7350c00e0f4253a57a04627a8dcaff44f1e5f509b320c7881056264853607764b42f53ff3a24a698d0b1fefc9456f54f521c133ee97b15961cf7bc9e3a448c50442e58c0141744781e930f8cd9b084c197695c7b199509d885c961cda478dc05adbb906d2102b7c8dd3e211ad039fe607714d29ad234fb7cabe797574c480d7b7db9c8983ba0888afc94a3b163621a03b167f51122257c54f35cbed575cf312fd85aa0fd9fa5da8e0a5dd2ccaa85239483502941f73b60fe8eb7c9ad9d868f94c0fef5eb4f74ff0b5ffdd54ed9a59f4fa7ed2a87b3ccccfce89e5007aee9cc190273ff91d5841e1e3fbd2b42e3f7e39eeab958a068c467403dcc01690d29628f502ccb737142022af61fad98c951312826b590382acec7057d90cd0d76f8408e594c8f44da72b560be2263cfd1fa072df525a2f4e60a994fba06c6f688c34114b941addfdb15959e2cb20cbcb848654687b009a5eb818df169192a2ed45ac7bcddac3ecf5dbb3f78d313e5850517eb39990cf692a808d19a5cd2e5540107f40be49248aef6a7c39c316a1495cc148b21d63bb40fddbfde2b6c270db4e1ff64e53d01de259d0b34bcb365ac439028d5fea887723b4b047f53c15ac0b5a8f4a15749de5e80620b8368497469201f77dcd4aae89b8571e52905d698f0bf6333f65fe07f17359a2d24556582ac6a5dced76f01420af44c290a34041705e8b4a7fcc0850e5345392f13692c6372e5b57ae98ba3c1966c91c3495adce39a4f950781046762b078dd3e6f213f622508c50aeb90e1ed5adc13759fab279dfa1dc07fee1cc9fd214f00997cf1100018f205ce6780f8a0b6610a34fe7fef5f3a88a5e91b737be5c339b6ed9ac9db125440ea7756dfaf8888c948f12ecd141aa6a7357a97ea198d83c58ce95a6b6790c9dc35245a9e936828ad815ccc9f71955785fff572a43df37d85a7ed7c710108f43b919aecf954fd859f646ab6f9e821220f4eb1cc9617c2f3f6dbd52ca067560c81a93fed88d083911687bcfe8bbf18f895892e60355dabb142e43c0dbfc67ece5ba4eddbe9ee9297b2a9bb7a95d9285aa9dbce547145f0e0cd27cbf9a0fb05f86d45dd688b73b5a7cdf9ed60a76b3cb3fba8264ff388ec831ea8b211b6eca1a12e5ac69038cd0c41ffb62ce76d12a5e33c16476c9ab3866af4b5e9cc042969a6060e235b3e371dc891a6c4ed8eb06a6f9630e22c7ebc83c42e2fee5a442d8b125bfa4e3ca984fba1d6c7b9bcc20d10b3b7f869c857e5af9970e98569bf22e0af05956b972428969be955adc9c4b5202cd9d8fc72fde8143a7bcd20e3c6446dcfb37a01a72485beed9ce3b50647264bacf2f49347b18982432b57c304ecd49a65db25f058b14ed5bf2183c098e3707d7e0533301878da7573930b91aef866b6a5754850803415c40c39bd92167357a8d8d8415c39c6d204ce9d11952dda4e4b86f0dc84d91c0d5ca94c3dfd78f0df576ab702dd3560ef91a33f31ce2bfbaaaebd8f53bc17fb23f41fdb05df44782d29a7d4df9ec8e509fa68d15ae4d03d8ca2f07f8ee28085cb12cf1dfe3bfeddca5f0f1d1e152a97450dac0b3ec61fee53d32aa09ea295292bbcfd84efac48c38d85e789185b542da435090ccc26acc547aade80e43cae9906a5db3e75e0f7617c9dfda5937b5eaae3d03e1ffdd2a32790fef5aee2587f70b50231ae9ab99b72084db4fd95408980c7494c31232ff5bd0b0115e3d62fa5ec7849b9864b65947bd157d6fed7e3ed9b7d51a29a662d04a65c2ac9d9dfa4f671c9e85d7468610fea0bc6389e92f6039134723b6f668bd54f1d998ba2b29b677bf59b80603b7d263d38f738b10d879e1dbe80676611b2584132ee08ac31778c101153be1bbaf9173cb659ed190538dbff48a86e0aa4dd4562bb5eb9af5493a0d08df886d6e552dfcf25615db019cd834f375cf4dc19af0ffd1747b4e5f98bfeb653db49138685a5cfa5de3d83b0a96fbe325ac792c321b79c3114403c0eff8003fa218c37f6c7bebc7d8d84e76ba7b26303018ed9b0808d4a0396d4ab3562aaa918917be89d1d3da94c791333d93a16c6922015c8569c167d837c20cafcd9d13b00b328f2a731c769aefe08bf05da1b7c427a1ee3a57ebaa58a086a8bba7e600decab50de7c5370da92057586159ee0adaf008aedb450d9d5f6020728732a60b3a35f4714fd5fc02f6f982ec7dea0d9593bfb10c5455ca71be31afbbeabe8a0585c1284eb8466e4e2096856a2c01ce78dd6992e979e6ceecde4cdb1fb46d0a00c1633622adff29f24507b151bcec35f95247dd17c34ca5b97e08e1ee2805cffc83ea31c856c3b3df6964d58f0aeae776bfdc30217d3d7225b837de027126561c1183a0e1e39a55e802d32a1259882bb69449fd947beaa0ed31a39d681d0da114107ce527d81d72bc08f4ce2007353bc2ec628e9a444b64b0f5f408063ee3cb59d794574f0615ec093c29011251ec2dc995be7b60309174feddd957603fa219907ea1907134596beda9bf8772cc17a8514f66477c36b010785934eeb3f1888b2ec7e36e4d8a505ccc2f2bf8347ee5a98dcb0972749b86dc0af549bae3648efa2cb2fa41d9b7d049327dff9cd30b911368272417de46ce31c7613ad0d92fcb723f924ee7d758bfe48392fd9f46788af9d704c37b3743ec3a9bcbce8afb039b0e7bfce4eedd3138f223e40a6f6f045faea8276e554736657a5572ab5eb94b7658131aec8c533cf28413dbe2d7e37e744c6bab53185c003309eb923c8c918b5f8f1fe72b0a68efa262abd91a7bbf2b24d4fb55cb176c8d31f1744eae8510ed0e326a9f9f6183d0c32d801281c92f26459e58bc126f38c2b40b8591ca0a815bc2412e8667c9628d19c282f31f5308e2f54eb9ea5a1dbf83f19573d4eed26b3ee790e3443d8c1bf79d27f5ce351564f39a8a2db2bb116aadce40f36e924f25b5e3dface1b1f69b51b8931cc8dde23313c538f64e1f07c29e0ed02ce4275181913dededac673a96aafe7e5a43139dc806cfa3d128690e0acf1e85c256a3a84e20bb3903992efa3c948808f53fa8b69ce12efb8954e361a7890e38265f7df65cfc58ed9c4865d1e7c3460a326e0f0f202002616ea526ef2f76cdff8700d61812499cd1e1465f57537fbdce393813d3dee5c9e8a3c4c7bff7130b4e7935384c27f592538cf202c8052e78e7021142f0bcef413b51c2710d2944ce7bf45cf84da76ca13c1300cc5d03a9bf7ca6aa084a29092b3b3190658a5b4e2ac3af9cffc6ac0557fd364bb20f40b2f13926be2921ce6e7e3eed46ed780471a6a60957c236e06ffdeb3c35a7366339f2e6bab4cdd8d119cabf88f475f212c10bfd32ba1c5600573c54697830c3cb1dbdf44ea494e772c1268d6e713c0fa2be4e05a5cda701edf72ef3fc9c330f6816affefd2ad495a1e8513b13e6ae02f59e8b1b9d497c92f5a588251a2424544c93dfb225c059078acc516f3e9597fd54e8c35b9429709117bc2b10772b1c7547507fe7e9a60552b4b16e252805da8458a237e023b6bf71ff81ffa633892524d0f6d150bdbb72dc280ccc2601cc96dbf8b93467248a5c058297811b74a810139b7e070e922eba402cc3b07e0ecd8335f4ca2311103891bc1c1c653d5c09bd4dae301c3ada0bf35a79753dfa1fa8adbd4f6f37587319c5e729ba13d7ac2e6e0564c82ea43227f329a824aa89236169300fd1f61517ff7cb3c38bfeadb191ddeee7f43482739c4e6814225e4b79baaf6a1739d6e7dee683c12eafe8bfb6c324835b0851bbeb1f32f92f61cb7a7888e409745b82916f6e2b8272e2208d893c21a3c73cc3a6d1b8b6da15b30fd4f146a3c619e1e685cd33a58fa8ca6cedcdb6c29377e4e49b05744d91946effa5183fd6fa70e3c6d77fa32a771718cd1272207072a34b9a54653e06e788cd32af7d0746fa9d3b3243fc4e563210fdca7713462fff522ded30a6413891c565f8304d647a82aac9137733897d986ef4d9529bba6c7f97dc5b9f84e9633297e5cc0056cce6713f755341a8b6c85eac28820c3add86b21dd573cab9453a76393e8d663d570af411f3343db7ff9a29d40d2fb45966a3b0e066f7962474607a0cd2c78c4a8f05c0fab93cd512ffec1b29a077b609c19d51a35dff0c7b8fe6dde7eb9664e73116e78cd9a6cbcbeadb57d5a477dbf8144167162300d45516868d31fd76f247f1f29c0e503f4acdaed080c18f8b53d5939220dd890a9440b605c5bbed9d1fed10aab2da9636ef74f194af13374b686708c691eb50fd2f75d733784fba02a9cacec8168fdb0b9a752b8a7bb12414acc21341af0a0611e8d50731d958cb4a6cfda41dd49fcbed35609fc49557386ca5c413e42e67a5827a97c176a815ce69ae8b59242de97fa2ff9089e6e6bad62aeb6589accf964898a91d6acab638a8940d648d8613155bcfb9781fd26a25dd935104d4f24f04c895993103f9b4f7051491492da18589a70b3f16fc834df41ca7400c739f88cbd68412432843e5b75f02964d0020bae5833031dc10cce024ffff8a26dd6930248e07fe4553a78940db765ca2a84d9fff0b7d4b5fe5fc31dc6d13da94ba457833c18ac9f301c5cbfdd5e434e9a0f9593ed562b993777e02e20b98b378d1c1e5a7ef7bc1fd2717335a99cdb576a0f41a2269d5c136242c441d0538febd46af96443362b506a3815f8108f30680ed9a958239bbffe85b391ad0aa7e6f3c7f41313ed965494dccb8373fe5fc36753fa014c580852318d62172cd2a424d5b3b76875947390b353b585101987ce442f2b6a4973975371703eaa2c05a47e8da10cedf5d2b6f16aab14ff96b1b3db36e8e1737adc8faa7b8ee8895cc374f95063af330b4388ce534bc87a8f6980721bef338fd2cb937069e108a8301fbbe66790df8784027d3419ae796f09972a3c5c61e552da5b5bb67f3f0708e0449a02664b7fae0d87291871916dd93691bf41cfe9ad34913d3226287b1fabbcbc5b8897917cca73efc65535f96654df68472182e05733cda5fb5647d16787c124d630f31becee161d963723de1967a9fbc2da50b2b80a2b043a6515fb57e8110475b6daf66fc11880fb70c419e8bce871e91e943c311a99af1b7825e73b82c7064d1e1d808e65d71f1a56affc31a01721e5484e0e0eccc922d9df22e4bd25e73b287d6f7eea743c2eb5b85c53a83909788518dde3f8d71f5496bbd9c61a479e679fca127a002bb7fc60f95f13bf29075c419798137844c7b7b3b06cbd6f7f3e6e795f5f7a57b05400af6a2797f61fe5c0d4a612a158d5b1a2d6acc6c24dd1d295b5e85034ee3bfa010e28146ded1e2f08f32473579f8b6e12bd8905a7eff1f3902ec73fb51a4fe5180386ffc371f64e25f3948630c7ac158c45d4cee20b068390d8e8cdcae953eba3fdc824f75fe9cb6ceb4e9b6ca37a1ad4663b4805bcb542f0f971a3751a7806c8dbc0c7abf69a7e28af6d287c89bf22ce1bfb88ddb408ede008ef0ef78089ff9ed172e51810316d624cd3fc8ce978976ceeb64838a214bc58bc11fa64559ac59c5b3c85bb3bc788d3d350f795fc33b1e423172ef0f15dc8fd195f04a97b55846605c9d359074310ad7e8410248cb1e41aedae0565611d31e9b35a0bc80b13319839e2f481ef9eab64908515e27d3e111d374db9716ef951f2ce4eeb02159f0bc2ba61c54e5fbb716bdbdaf4290ff95b30d3c3df83e9a959f4552201527e5f68a19614be9b0fa922696038a19a74870812404ac4e2bee6a3fd124f6a04f2bc5b6bf43b8d6eee389003546fd4eefea159c3533084140c100a36aab638494f7e3aeecf4259dc32dbbd1fc11fe880d6c05a000fc59ca4e292c0bae7950717cb325bd677c30476968f68b313734ae79e600dd91d34d3405c21c20999397c3c3b3fde9583b2f9dcabd205626d5145c86fc1269151e7c862b43e83088e953030bd7aa277a9c0703daa8b5b84a076513c41d8edd51fd89aadf79ec66d5d27f0456f40cfe042bbb74f3febf5c9852c77c816a4a327b5bdd4fa4628a3e02f554648af73c7a90a7493188b3ab6edccb675d7d4649e81b6eee0acb6abb4e7300cd19c951e921b7fa8c9938368dc9b1e878c4a67e2fb73b7160f84590da0c6571d0013e4f9a724ec5f798ac6c837b5f9bf8c2110747fd99c23d9d0af1f5fcce4dd3735ab36c5181280280079ccf7c2eb57c440b3f9ee7c3d6fe936a764ecccf654d0cf4617195372cb4955a9a49734590eb5e1ef2ce1dade96084e17bd5412e08f71a9ff1098742905977e4dfd5fe87c3bf8a57ddb7a367320eca1c7fbe92e9d7a2f403661fe2d6208b8c9beb966671d357822fd679510c5a531ed8c00f4dd506d9d144334362f014324c39efe088c1d0e881283ec939113b52ae1aaa67a737d6bd6a435bbc83c840e275691584db98205586fce6d1f1bb67f6e7e4fa9ddd06817899ce1f3ccd069542bea2f5ccca42b94d376c62d2c6c1f42f304491d222793dcaaa4257babbf1fe8d1471b999fbc017f068c944d163da6ba7b0b26d916d8c717c6e5930d3d66ccd41e7abac33df4af42bfcd49bde7a8b5f2f976e5e4313fa280ccc84753e711e882c558cf70d9db9f0e403b1c5f95d56384911b8e46f8fdca5b22f77f0a352076aab58b9b4fac1ab6959968e3cc82debfb76c425cb3a9ded8c83fc6db7aaf3a9a668fc4ffdde34a6e4e523a2ea59d3bd82d6c4659d2b6227bcb4e806eeb1943f612452661512a7b5ba23d2f6093294de628537b7570b8457460f994306a4dd92ba9b5f97c56fd7a96f826f6e5b63c731310bdc4291608a656577f40afa75eb71f6f56c57afe8eefc1db5bdeaa1f851840d0806fde542c04d289c06838a1041d714b289e94d429588d4e7d9ceec8624e36b70c9243a346346f5d373afbda92f517e695970835469d1c557128098747bc3b463314f104a9ffaaf3631a80295eefa1edb362d4b327a149868b538b2adb5ee3dba37cf31d8117e4c7074df23bb710e7fdaea048d24ae6e7897c307d2a4d1334f06335a0042c82bbeb70852c19582a80b36b7008ed9d2cbfd450ba1f4d86938dd79593679e1d01a6084ce4c79a0537cebc735a1e472ee702a3c901725c8f39f72df52d00585871d54c5459b679cddeb98d7fa1005b321fabe957975eace171e4056e5e377968dbccf53b9c94c842a038d746655687c70a4ff9c18427a55d5b46d8bbec1ed439e84564e62fcf2bbc53e2992a3525e68e13ee2baa9f8351ee88c958341d801776dd4e9602bdda7e57210b84c867f53bfb15207e8f13685a09b3682c33b32e8456695bc4b381ad88c9028224cb2f87e73fc08364c1931baa27a47f151f0e978872aa9eb6d0c6e826e218c4edb34699318b30b4a33a5a3aee9b05ba3e6615d1c499e6ec4721fb85e1855281954967b598ffdf2705547e61748f16823e4f538ad1ebc74ed3f2e2f9d7b3892b72d71ac313be56a2558add96c1df5ec2543f7eb1be43d3ce83ec002e8877dffb186766130e7ef0c15f4b5862da45862614d61dc8b25ac4702172e821507c8705d25952d0ec161b4be0861cbd725c83d3d96276d969bbf33604c5c3a63eafa75c1710482921e5ccd030baa6978a1a9f664592c3b819c123e8a6f38981e3ebeaf8da665e8dca145e01ab3aa97d4e16a33882e7895a17788fd813ba182ab63d34b71783d0e8c61d28d4eba829eadb51bff0c4f9fc32ec892f837c9d605b9c23ce06086ece9f56f66c4b27b162594f46def5045849ea1528422fee1658cf7e7b528999656653655989b56ef7a0c7184dda92529ebaced2f9d1122074ba194408f54f61306f7ab0ac322bed315ef8a21c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
