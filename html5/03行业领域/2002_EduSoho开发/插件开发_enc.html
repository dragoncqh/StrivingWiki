<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0452abd6281bab72da763fb291625d666ba5480c9bed167629f9d929527fa06d58b63ad66722c2f704bbf5969c7f01a37a142f105e2265b0e7bf4da0c2855b1902d603e1ded96938d7786326114aa08eab5a0f7aca1c60e34ef9e049f2eb0bacb39544541b9a958504f33325da252aa5a5246cbed476d14bb842dfc891c13bea59caa7e0a14e660281c6a223b1651909120bcb61c99326deec9c5482e97adec2240012c80e3af357541a0efa2ad8dd36a84e39fb7ac1632d92a7398a1c39029b49f1e7ec6b2f5f6f46dadbbbd2bb314a303f4857a016c4724f72cd332774171ac68b327c21118629ad27e15a0cd7e0c1d1c715763b29fd3eb12a624e9518056564307dfc4055cf8c1b8a51c6eeedda235fcc007612e73c77b76e10fef06290f57ad87650bd13a42771faa2495aef5660100257a2dea18da01fc8a4559a7d571d97fe663f0cd1f07f7399446aa286290397b2bd3b3f26db011b67d80d66974beec44452c831671cfea9928d25399b7665d9fc8f8ed64ab6354aa197e768fee6d444fec05bd8413a61b9c0c236d1f2506fe0559f78cf86b413b57bfa421a01352d1148488d9469edf3bbad559798111ee7bc4a539e78eb8eaf8e4cfbfc7d5404de7364bb69a9d8d88dc98ebbbeba68824de7d22329c34ee44ebeb27eb0f2f101698bfa5402fc648044ee07d0cc6cae279dc131041fc045909e7fc9d3f619fd18e39a63afb86d2292b79b872e88cdaf13dd820a0b4e65091805ab8c8cdbb7e53f30022b24fcb68b84c4b343ce624ed05ee0d861520b3d11038720b3c54ec136a22247782016795a868d137ffcad5ef1a648d4a1fc1577cf5e9122e831e2ce69931fc100fe0e82283641e4cb85803d0b769491fdd7b611fad49db07f994f4bae8f6734beb3b760edde44dbe88c14373ce57a4265073b08314153d3a0b3d6b330fddb38db1c2c140171d9cafc9da0f53271c501aa23e9ca1679905ca379e6aabd1f99d6a14c80393cfe3f3e38856e99823040ab80cfd9e2aba4f246c5f2a195b111b223040f575e10618469db6085111ff690a13c84f13ee9096e95bf5ac023def3abe99239f3b0554e1751203f69895e7d1b49a3697ad5682c3972a76a93045600353b486d1deb8d1d500c892eebfa3575820e3bd48a60cc184bcae80bc9a0a1dc7906e6d84ceac92ae95d8298a716b9a78b68645cc577aef0a0c2071ec6f6ded3a3f31fcd886204f1d2e1586ec506f38fa9da79c73a2d4783634f73f8d8158e24c5c8f684c4e197163ddac85e092a875618b50419cef7181f5d9d2cf0299ec153fa5963e0211e7978f593b629bd1c919ec722c78c7be91389ec8b6c8af03aa65d7fadbb83c40b56023f88b53576ff1333e675cace8f47bc3f79583b07c732031b01b34432f5b95f9202fde67301e6a11a056703183be8e39e9e29ce73f430552d3891c264a08187e24e764149219e1c07677a147605f989b25af634182c8777176fa8641d9fe8bd1942f841bd73b204030d275557a4f2516b55f6851db31666b943740064ceef21f73acfb2c03132e9cfa48472d961eb29a7309880f71b0a17098e2dfd27a5e6ab797475325f546973d48bd441264844e81070f256af06e8d570d991956e6575715bcce3059181cceeacef8b9564574b022abbda2fcad427f8ffc2afe2ef39f779018ab8d8d8de5ebd0a153381712ae6918729847ecde34f121a3b6638be0b83bcd06d3403c9e077484a48361ac6646a67f573426d79aa52dd8f64a4539dc8b83cb3679631fca1ea77d64b5c4b158b37ca6313ab933035d12c4cfa2ed993db267b331ebbdccceb2e837ab28dca47554bd2cc74f673d087e3e519916f188caabea603609014cf39ccee9cc8aa65e6809b0353911acfdc924b24e6bde92a8ebd5c853e72f350f050bda3a8a2e5f8556443da9f81061379fa99faec3192785aa046c0a3fd4a727dfa0743dd9f6eedcba98f062d55e3b5b07220ba6c29c9207499d34f0f5e8407e320aa1445786c51550081e8d32461bbd8e3f021d39c76c615a820a32898fee4b7e7a221321054dac9bf2aee3a2b5fb216a71442a3985987809d2f3a6fc51413725165f6e2f488eedf6d70cd051ec5d238f3a4ca61bf6f6391258f48015321029af384d3b10c2bb72d2c809203c6281c1f6f94f83b2815fb8d1d018555d918c451a6e7c7756ef9686d470aa95fdeb01f9b89d93ed95e9d671b5c216f6b6ae732d83377ac1e5acb8d499b827b4fc2719e57d2522a07cf3fbc570f12b0f8f5650ce95d3163445fde18a7b154fd0877dd7ae3d7bba01a0980d80037b3a33b989a731b48d2ade4185e407515d982574e606c1b2f12b8a488eb04855d26d669a7e5a9bccf0e5f790c7c00bfc60b19204ecb1c15a83556ccb32d7a7b7bde52fae6c448ae2693193075603428998884c0e77105d2a2eed41e3960bcc3151e7bb7a91344cd73d6bf2860fff213ce99bf1935023a67b5d932fda6d75c9cfec14041a9d0fdb931a74aa644d8b6cb822baabbd8009ae2d67bbc989bedce13cfab27d4251984593a3ce6b07e7089cdb12b23bba986613c6f776a1ce87efff3e78d146cb4daa3771122a53e964e1c5ace3f24c47e34c358797ec8d1be5776df6d1ed6af1c2018cc1ff93363a6d2b9a0fea5dd094761669961b3b0e2d1aad823fa4383e4c1ff6d2f852b92e8df393d65d102bc49ef101861e2a9c036c7b3661a89fcf61195c85093450ec2c8fdf89f2401dc9a5ae7ce563192323757feda47f1b63cb3ae476095f9044ad79675bf5bbf9d48f19d6e1b1fe0afe4af65fc06ae20df74c523096381af5688664a57ec920378fd08b138636e89d7ab680a161e94dc213b70d9642efd64aea4009e9f2273582cdb602ff730bdecb4c067e16e010a5b13d1364fbc27d7e7516c49e4a729a22f03eb1ce6aec31cb11a3075be04bc3bd6ab1f22f2b9abdf9d808021d2ff8760480aa66e7267facbd00dbf186cc8103f6d10c0ba6c42d7642a294fe8ae8b65256ece266f2aef141fb9f14b85bde1f52e68dc7eea1eaf77c875c44c53e4d6b74eb7bb911bf90e39ec4b84b6303fa93d2c5b762d8a6cea7280901494aaca05e16a5f50654501dfbd59cf461e2952d7ae8cc1979ec86ea5f51d31527aa6cbffc94dc603ea8061b5cb0c58e04eb7fecaecb29604f043dd96faa3e2c03e4500464ec789d43bf5a6d92b777af15a64488c7227a7599dcae5cc7c85552d6f5638130cb051f7118500fe94fb43101306318fe23a26a89a600dc9284c791e277c4cee3f67e22bfec01b6bbb1bbc49647d775c986c4921659168b242bfabfc63232a02a2d1d6d59c517ec95b67d7f3a70ee03087cc433ed50e96f59f6292c5f444cfc0f63d56384fe34c1d14fdb80a08cc544965e581e1c4b814b36509e2781c4650afc7dfcbf31e65645a5ebcc5e297f6219c4ed599a27b5ee4b3f8ad5589b5ca52acdd7d4370fc0b9f473a06958d4c2755f0ae86fefd77542603a920e4cebeeb86307af0e26c7a622e7afcec53b487ebfd1323a4607f42fc133edcc489da86a61f92bd83ab1e8b9d40f3866a248792bfc4a9c131e8096ae9138a0ef8eed2f282d8e2d0f882d589be0f83a1c9a077f7074b2d67848cd0bc8862b3b2533910e82cb6dfbaf8a5a4cf9f7774596f370a20d0bd91c08d85805759da48b9667d81f83c4b4ae55db2d516f3b293d8b208a4784a7420166ec85d0914f7ac6658040019c10dd6017160d828151abfeac992c6e00fbde72fa938be4bb56e8118884ae3a38935222277aa56b86caafc57741b3808182e9c39230e60d274ff8f2d0332c8f0f775582d10b7d7f308d109b87f75c6ccb044965a96d80134957daa6f7285229b3329794747e1ba68c6f12d9865d0cd227fbac91e1677f2e996278ec7e8ba179d7b7dbb9a9f83484ffb503bc93d8220d7798c0061ba0bbcdb905218df4789d99a6b23126d5d88d1e3f120321d19973a4b19575ec5718717541b74efb76e1024be393857bb9519430c9df4c5bdb05744ae12cd31d0efd7922f84ed9ed68a12a06c16223c6cb2488526c95826db93dfe8adb2c12bbd98e455f7db3f2d84888472cdd1364022d2d242c8ba4992c401ca79ff0b49d2dd680c9e1e2da36d9a06a605a80460ec8a215f41405bda8f77d335c65ee7e64c8a7e73091c305d0aa1092e6cee164504e897c66778b98e81bd8124cdb6cbb51836ef4bd6cc984f7856a884bea7fdcbe413c875f97dfa1273aa65d698cf4f39a4c9cbd6fa76bb7630c8d050b9057b61db8669c17ad5036f417ce49415baf8a844c22bccac775c817a29924e851beb5ae4d7c63c6ea835f856647049569e6c24687eea6295378a66c9fee41b14621e93102da67bf0d1db3044d5be4a014bff26e4f36d882b415766687e9a2734dbb607f8aa900e277ccc5c877070c17d23f2c237291317d3c31f7f40c26bd6a3741c6bb43054f45c1c9ef646b65004a8397f88b88e154e39953bd4df7a25dfd822d9e5afb4a525b9d5a8f7d626884c8d2359e513da9fd642ccbed2f9b8aebebe74cbdd2c590f6b35545107e750930e53a598150892bf0c8fe92c41b896d6f888b63e976c298bea91e3c5e277d2cb95b7cc90305f4909dd1d20f504cfb104ea891999323dc5c7cd11b950e267549b09b9a073ffb00f85fd80bc9ee1b8d0432b131c2b4ddf12a46e9957c062ada106c1f1532c4c439dd10924f426b295b5a0522ec0a6a23eb4292d0f5bfb108d19d6777ee3e2610870cee430887b77f1462f8a51097beef21b213a5b48011f4f408603aaf087a9e5beff370c69cc5dcea22a097debbaa402744c1cb37309a9b94f400e595b757958da2d0bdc2b08c2e45756b3e8fcf91c9627a42623488e46443adfe32d9a3f55663e6cab1c808f33871f3d4ec2dae41b9b6362c296b90410a3ae3a20142964ba5fc5467ef7ae3ce758c5c3772e0db5db6e32f4a65f6aa94d61b01539de2fc543b57bdd1b778a141bced4faf1dc0e7008ae735dd10cd5efa34c33cb33bd5c896c5dfe676d22ede7e4c7687b50c59d33b948dc3ce6cd279e5a95e44d37de0225de81a232ca608bb98a8f4dabdebd687e4880491dab6ab114bd01b240b67420e33433ad983fa28cb3339af00883848b7c6ac1729f22e673ef3d793ece26033d7fe5e9f2f78c24b9a2e780f053caf9611e1ee856c367ab555a26edcb2ea9dbcb18c437b535f7fbc4d693783899f66effdc9edeb3004a765a91bca2e664c572f1fb7d8e2843a98b1cae59e8eff1b718156a92dd659eab29ef7a0bd98b97a72852106da4fa48d302cf6c75df9fd3bdb6b9ae9d7824d6b9155b19cec66fe00aa79ebba4dba841baf6d827b401f3a47cdf4d59e3206c0f612de5dff17c1cb191689c2bc27ba04edc9a3e504803356404724c8111e39e74fd706ee06326c10ec9c04d67048c89127dc46d46293f7bb37cdb1080b316f7cecd26595b1cbe8633dbfbd55dda82277374c51b31456721851a221bb238a44d477b4bb9b4e33b170133c6e7e34a5671bcd9ecb7738db042d0349069c6b5fe8edb42e2c79f892bfa7984e6e56b0aaf62786f39ba27249bbe2fb5cd1e5bf5db08502cee16812221c3e8f8663b71756d24493d252f48d12e7359132c564b1b245b6ff309200f75b7e1d326482045b10c8eea6bc29fb15b6db3600836210dd7103619f2bea168d11fb89aa0ba17e11e203bdd86fa87d92bc3dbf10175175b939425c2e7812f7b1665e321cb7fe6a86c256e5fb258dca668382b289923bf3f3efbb70e1d3293045fc2c41a2955d3bcb3351f46b9edd912c38c55d211e7bb79df519fe11d7534dd21e6484919467befb7b6c836c5c6155073db80bfbc2754321fc704f5c2ed664e4dcf07804c41c937f6d272a9c5c46e9dd80e35561a8416887268435b6702dc4014caa537ffe94ad31bb6b8e6dc8a8086944b29064ecfcbd49c1c6631cd0eebd7897936f49af9e3713a15e7cdfb71c4a20781587d11d6d50f5829086b4f3db072b573d81789ee5c04b9e125e0e930a64aebdea156e824108e24e75a7e6c68ecc7127578de15f094287230e41d1b82295731f29ad18511fbc151ed906cec86faa5e46f97a503b648a2a035e339c5ca12ca7b2136a1c4cfdc33aabcae211b486f9c8b6cfacdd1384434d5444c5aea596d753ed942b6016eeeb6dc6cd10fc2e6318517fcb63596ea35619b8c0c7849db54b6d44a1fe938ee516b7bd033279e5cba72e6a06187019af09336616e2a149620818f6d6b90b51552d877120900f4002401887c35c697d4522d48367787ffa1d35b0f8da5894877af74ac849c865846fad33e1ae45158bb52bfa2e267acc8a29b961320d09d4abc198e060f13a30d864e5fc6e86dc961829ca2153697f5bd74927588ed77ce0a64930f82df5604e452114c5ee554c218f06b28857b5a08ca815a5059f86412b186390911628906316a44f9888bcc05d48cd14e161be80583467b518827ebcf0a280e6d32097a9bb5b3922f2d48230481e46761f055c75ceb3e00ceeafab239146dc171d2fcaf0e8d31a5e177ca53979593b1ed5f8c6db5911dd47e1e80838f9937f19991b3dff20f99d6d7a42b276f0d5eedbb7192804de909fcdbaacd90abe2f8ad399d444587faa956403a6989f1daa8197346cac2f6c0b77b7c0fc742798789716c6fb8ab0f907ba8f581cb5930cc10e4ebe9fbfbf2b5c8052f8a2cf92309f6b75e0d4a315fd52f0d8dd7539f9d428ccc9033fe540d49aa33fef8757ff68dc561082cfc03d67f8963a0ca3cf187913fb30ea77676307528a8888725b3dd582bb5f71df4213532c75d41abd4c41c81943dd207dbc37c06da011ef3b0642dab52a4428ef8c2bb94271bb5c8b2611e4af3f11ec9f353b39c70a7e1b4856b2a3345e621303311be10b86bd928b26f9449a3624c47e20f57819742d1ece2a37a4a3114d70d23b98e7223172991d2aa409ac3b1826ed1c739f75655353d7993970d687cfd0c024c7d73bb194fd1a67fe7b1b6251c88da732d565bc7ff74cac69ff02c7401c08fd0c309e69bea8765102024521243985e9c48f6f604223e565fe591b524c3744d7a0644e04b4d3765fd6244336e992235ecd95dc5140819a744ce88b201e4dd00029e9fb633ace6dec28312875fd9de4aa7c2e18ef2a208549ce97a3e9c2510275d8b206c057668d682da02f9d42a6b78325fcf24f894cd427df64edfbef63c99d41ef9b7782f68a3c676efc9d689b93671ce87f494ba78f652072aa3fe770a1ce8118689fca378da2e3a09912bf0314f7d275a33f615b27066b28f7563a1736e1c6cdab8ed217cc315cdbad9d77f41f8e420b119266d4784c8396c6f3bdc4ab46ff1e72e5fd7e27aaf71f4975e772466803f465e93fafc1069259b9c669b794be31b969625ed49b785423d6832b98db7492f920291c9ac7c5fd943b74aaa6eb424693c9d28177876c1ba9165601f4c976038a04730edf3468fa1a65c6b513bca4b02df07bef2e9fd5475e6bf98c478252084bdcd8bb1fa6c1bcc6ece644da17202486420307f86cc9139ed650dfc88bf7b0a233476f01139b315527d3c80fbc5998b4275a4cd15cc3c6c7095ec15db5b6be1ae75d45c06bff4666b0c89bea855cb217dc5ed81a3b162b96faccbe59fd2ed71282393531253b351a1319357967b056702d42821327d9ac9f4bb66360f66083a4fb97ea2d14fb9d2c5e56d3cebfc58d869f6da6b7f8aa8bb29a134b06b0e41f80b560f46bd677381face98d0a6dec143bded9c8dd4e662522b3176cf03b15c80405b88bb563923650c4fcc13fc742b296ac58f4a3248bf445de4a2f0982e9f40b7a68a224e5c470a860e69721102d54f3f57d67770d27cb063beab03ab439e1f63be5d7dcf23b2e22fbc891b72a5cfbeaa85d12e477d11f8cb92293d4da2007da01f8ae7861c76ac5b2ef7f10656af4936a4c2fa09e12696e5f64d786cb0672ac90a4a0a03a96e0597cdc47d752ecef1760ffdb3500d38bc052b92b1c8875470d29bfb4daf3e43ed085d3cf628a62daa5ccb43d57fe039ca628be4b6668b866985895f5d51dc9632866e98161051faf8191d28b4932734ba69a18b8d0bdaae9b345ce2462477ee29db2ce007ac9ff4ed08e252afd4759edb569e13b9f3eb17ac0a7db30d05c432a8808878d81002de3dd58ad0f766c8f867299d62d4357c91d3ef2633e83b680a0c2795dbc2a4732ebc92e2ccc5811f42fe7371e7f728ac8efa6acc19d9295928c18b3ab013143932a8b1f91ec7b8e3c5864a58c6373ffb3cf3662b21c824cf8cf6a880cef94d33144c4a2db3b52909890447e353ea0dfc5e1e85df0bdcdfafc332ff1680ca3a1e44725bad5ac614d70cb542db39bbd824333cdbe8afa159316f16dc0ef92641f198e2463c396e92d95157449743255b09f8f532df7b4550c6791a2bca2087750a472868457b930f782b9a9e332fa25f96814cd2e78945f8664011ba79dd256a64661abd8af3b29b59a6b033ac265d8c13af3e0b9282f31a0a85feab34bea8d156cd0aff250ab9a843fe937ec38e57b337b3a872c1e6d299807f3a79a2cd65110ee527c7b2634d99e6c1417f38ce86e166484f1703ff5198f1cd495e8612b92f3ed4c863e5a9a2d5c4702674d8b7f4bc8fef2ab7493e3fb538926ff1871dd471d8a64cc1e1144e290f9deccec30477516999395aae57147bbfda83ce064d5d282b3f2b25369bcf356bc6f6ac2995fd06a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
