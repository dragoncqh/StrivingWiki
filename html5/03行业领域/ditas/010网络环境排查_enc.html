<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"120350abeec7729acfce1781a5fb83a6ad8c10355d9a7a3c083c71084b64ccdc25fb55a3fb1f31b164c9e538451f5b1418493f5a62ce92931d3fc098c0e9cedca4fa867316e040e2ea8bcb8504e61c48235def8d5e21cd2c401b9b486a409a195689a0186133819359e3e78bdc88fc987434b5c1ba1dc58f4f66272f8635ee6ce8fce0082006d11c3ccc94452e65273f293f09e79c1f6d8ba95f7b9a15f4f3c86f04f2ea2b1e64534f809379529f84d0af08032430672df814811092f9e65c2de17d8feb9f63eabecfc2e6e0825163a84eb5434652a3e5850fcb7bfa7bd16d78be1b6a14c8a296d66380406a36ee13c7b00f6c03402f6a7bdfdfabfaa3df7ef12e06ac30a6f2ace8d99a8970d1ef4a167103f6dff30182554180ef44088b3ec8108b104cd534a10b71f1561ae5e50e2182282d5b759406ad2f09ab6c7135a087de295e253d333e0ad7deece23c9c630614c7c1f3a18ddb5119e058c17b773b15f050a5a9d92f73d68a317bbac8840c967ed9d1e07ddcce5581e1fcee82e2e0df445e12e6afb8a9ab79662ead234e0a2746e130214b4b6e087173806346d126589ed9092c03dc5ab2db526471a5fe8a2d518b695978506c75d0518b3d29a8046ed0110a290b2e7355c2bb50182e1edcfa2fd7219fce0c29f21097d71d7a43da20eb9e5341fb09d939c3a8c87bec7623a796ec9e0330c706c55ddccb47bbf9f1754595504310b1410fc57c6b43de4972702b029de37aa944ad463a14f41c8150d6551803f8ca2f1d65c850059830717538db6efd243c260cdd4420439e383ab475f0aeac1c17ae3aaa569fdd6bd60c5fdea94fe191ca58c39cf5cf494b90142efdaba02c2845f535fa73822d3c2a75671b0dc1782e5f9601892e01c1e20439639c7e9fa66bd48c34668cfce76f757ad864c34c74428b30c2977caac817dd14be11d82bf35e1d35d7af385773167dc221023da09c8ec03733719eec36f6a960b1a7d0c2717e374cbe418d862e36f12211e3c960b856a7a93fd0c9a9f8a7968946cb86f0eed8479a6e7b7a90d7de33c6678fcb59b263769357281d899182d403f50859fcef6e536c6554a1078d8fe0863b13f6fe3e397c17fa0c439a7c62f303641fb76f5a94df41f15a1cc90db36fe5207762c7009daf22caca465b08f6a7474275081980dfc0e36f3264f7cceb57bb2b5289730fef3418d7ca52b261d4c6389e4b3fdd1f457d9f2d53146004a9095b4d08114163138b8703ac1e3df8ab5aece78e87f42cdb7c3f31e4f0a923a6404de605164f921d46d117487f565f9ffe9413dfc4cebe2743c45312a16eacb2a6851f8c50cbfdff2d9ea7ae927fcf91924d90cfbdce7de863951b4ce1fc1eef6977b0b26936991cfde6baa6980d6038260533a02eeace7fbba04721ba001af7fee735da05f1ad494a991c76892df09b029c62d6ddea83b20fef310e11f08211513bb4a1617d7176d0692d4c6851ebf2f3daef1351830ef37592db3249db4a10e27f2986a2bea8014f7625b7a607f8c16fc2e4c6696c0c0cf192c4205f239523514e7aed047f0873b55c6bc90b288d8bac101af18a9670bbb68cb0b97bd821ad92dda5c07b088db68bc3d15eb6ae6513e9219f6a0edf406d135039c84503b617b5c0356ad8e31ccab5e2c6a8263a0a91ec23aa63bf5259700b590229204a420c423f281225f2e196be01c0ed568a2bbb69531bf67c8b2c6b154159370cdc4eb6dce68f7b8f34f010a49af13d06399255e6b4e9882e739c4bffd6ce954a0d675fb5edc40eb6b40c53735d506a5d2e213690532d0cad16cec10bb70c349c15482beec63c30f4e170194a4aac38492dfa4a6ef94659e3a898c855fbd8ca90a9b99f8b597a5f87f2f582bc01dd293def31ad6af7b470695e6a7dad2bfd57323a1ace18fa0525af4d49db9e23d4744252a525af7db248a41726b6b400f8381618f9f615454aac963852f07e6f21cc916174157ff24420d91e00303c0e962c3078f5d4627e9a1a76f2a3888efa586304cc8760345d2cba2a0f3f50f261b6082b3730d41b4cbd89fa4306ec17f6fe93e442afc2c578cfc9b9fff7860727d623a93ab0c845502f9163a976dcf896733f6b4eee42be72319adf61902a43111e6e3f03d28996004735adac97c7c961dbc075f7f1483d03d80a92f294318eae1917622bed90f48e53d38337df4f7f6c6c876380f8df53dc4f12b7f3115822b0ce3f788fd97164023a5050438c3140c11f98c78ade2cd78beab5c91a091f590c7f996b3dff6c91a2da8111d7579f17317547e7a461d948e1edbb01d2f70c698e8d0a7eaac6b49edb47f638f1990e2da61810e6225e16e24304ff83a4a21458a08ec55039e1956ef17c4c710fe2981235731225f0ec4ae643dfd4de0a87a066e0f0acc22d9ce606a91275a5e19384f3298c416822bf13e01bda08ab4ba551e866415ffee51667f096ec1bc802cd362653d6bec8b1f55e94a8f1152bd9dcd0c99e82a64a0f5a5fe0e581f7e386b6e79104c37718a5f929d5bfb6a8c147cd09050e8dc69ac89ebcb8955c00ddfcf8586f28a7d1c6fab16c131995a5485a4cec8040e6e38b6fbcae7760bad3f9628f9a33c340ef0abc8111120183fb88c5d790d33eec8c1aa8eacb2a7ee8e4678ca4ea9ae21f5d404a314650f8e135e1220f594ef5289d8b52c2d6512d66eea4eb6fb01499bfdb46b80eb3902c348dadce5e9467bea8662e273a12364225566bd713a237c2f9b93e85422e7ab5105c7019547604b8241529c7cfc0973731366b928b6cc0a8b62a796519af769c37e3bcb215a1c1cd1241730991bf9d3e85b43e4a0031c7489fd04d9d23949520049f6703406dcc3653e1d901a3db895323d36ef4b72f35c0dc2b68f588192215bb7ab977f6caee1017202ab945f9b27831d7edbc26cdf09d5da37b9a280f109189333b64f3cbdf5516d1fdfd8f36da32fc5e950099dca68750bd72ddda3e602fb28f8148f9457fe77729d3329856e050660f252137d5c643ecbb0f82632586752afe46d87e35781624f6f7f1ac467eed01b7ac657de1b72b8d5216fdaa8c1ad83aa94162d7d2c4c6b8b3cac642b95420a25c97b7c0c586a6d974a403034b1317b1b919c8a5abb8e7fea19091cb839c2333ce4e752faeac03e5c0ee12174fefe38cffc012f58fab65f29f86873a63957605e8606d9ea0dbfb843e7398e415442d4f6e9229f878c3f6a06f9786b0dd63aa7cbc83920e3eae256ac59f344b3a4708da82a5fe22ba32104839950d67c6d44826f0a1d3ab15d77b0d94b6e4a80ec3c9ea8a76d5dc4d558303b1e574d626b5091b68bf8222b2c7afa41f67500c3d84b60155e3b32720ebbdd16b1e72616a45ad09c8f131699bbb305e4bb59fd438de03abcfa6d140191bdf2acf643412f6e9410ea4223e7379cae33d779d6cb8d41f5cb26b0e5e6c4ab9df951b2b6565dbe1a36ebfbe146f24b4aa0e2df063df90429f37cfe56b7507966e03e1b9ac53314abc624b24bf1e1b49ad6bd743535b318bf122b660068d27425f4be181ed5e92b067b48f5ac93078e5e69cf551fd1fb140f7702a10f76ba6a002572650f67c2d8fe7e26a9c8e21777a382d93d207974f100e022dc2bb6f562c9fbb824320f0960156e30eb92fe9879be01cd5f74f945ae9c03ce3471c35d0fa4780b47b5ad570fe4b787750b8783180f2df84d291f3e5310bdf78d606082a1624dbe62062729553da6ed2f699eac78d90fb25db749140c3daba24cd8e8703b513f8d2d2ffe4d88a4a7143f5b94e1a3d326728bde2d3f8f528af8d8d14e4df07d575666a20411a91a5d62d275909b76230b24a66b2d29959d91d195734f2d675634463251f5654eb391bb77bc8a20cbd32145776dd2e81c421392c708fc80e49be54db59d8549f6c2be628a6e71c211afe04271e22338b90e965ade96262418270911c6bac01cfa635f968cd97868e3dadeb7ffcf81b2297440776cc0654a846deec6ac5af3b4c48a5932e5a47c2238f321bdd23ce6480edbf42dffcb708d1126aa7482ac9d3891bc12702c68a348b23e9ae2902a69142b89b959b04857123a3bdb392454232bb65f4eec6f612a605542b4e261dff269b41c836d2e72f031c4a9097b19e1c783ac1d2247c7be20bd033b02d2918d03ab5e37362a978e47b3faca7a2d246cdad23e5f73e0b960e396e0431c49523e25aea27751ba73c131eec902c820cf37cda70f141063700383817887ac776b933be85a6ea3addfca4eab085160c5e2fce152787cd60b2d164ab8fe3e2ee97aa79fe67066ae839ee9adfde81c1ee659b4bc4afa2624145dc7e35c5ab66eaad9c4f5d8a9c0eb665d4e2518b54338956f1a143583aa2203420f024798fff6e1280a48557beb0527cc5bcf3cfcc0a4bda3b04a3101d67790236ca8edc97cc12264296c7d878db02eb556be85d7a1c44f718aa42f78abc4086cce25836ff2e3f30ddd5a0aa10ef9e73a34f29539a2949ca7860492ef25a0e787aadfdd853845925880f8f89236b62c09ad73ecec796fa71a0e07952e6461c46b85740d5dc45c929971aacef4e9d3d50233a4a1d43b652d506bf8dc1d7e98dddcec64c3af6c781e99d6b30cc95d7e3a825809c777948216f9be51ef2c03ad73c7ce9c9ea7b51eb3dccc032948bc7e64bc656ba73cbd261eb6a3e7382f24ab866be3944ddb8a81aab7fa8243f74fc4797107259e52b9142d4ddf11f0f6b39982210135ca60c3297e0ebd2d7bf082ae21bf6d84a568d02a25ed7d18056bd317de4f719e3284a6f264a7de2e763231317db5abf77ffdf36ccfff72ddd7317dd68654bb0d9cf0e597fc32408a9534a8c30e87d672f14881018778b939c73e1fb670f65712bc93c9113ddb2cf9b0aac9126e4394360a31a1a173ba28c87a0bda9d3aace87128aafec7b3d7716a073bf18e792eb89f702718da751b305d46a34d0b7fcecae07663ca0aabdbf6cce11e9f0b5e083c7f268283131133e70015cb621adaea363f8cdfd39847d02e9585c910f5c00bbb0b54fd0ba2687f368a8d1fe9e4da7285ed109ba3b86fb22a7ae57e11b8df4ba1332351e62ec8e6845169e836aa2ffc6d70b4a38cca26c3957fe8fcf572b0f1cdef378282fe7fcd53eddda6c4b7de761740b669752879eed1bff723d85fecdc4b0d18d3b439610b46c1e04f94f7225ed2791514c04d7364ad5015bdb2416124920cb8aa7446ef273002fc0ae78cb2678098b851bd7929f9715baad42b120fe7e53fc328bee6b4e5378bcf445dee5bbe6897e904de2eff88ed62e9b646ad161b212b41ef939d703d28965473857fba1e36f2dcced94c5dc7e305ef13274cb0e194fcbfef2675e63a2fbfee90b7c197192bca06eb6d313fffb16ceef8bc9b8cefe394fef0a5e55c33239d28556648f975a7b4a66798c912590a0e6e8f4ccdbbb456745d5a18fa73101b715281d56d8b7995003a3fa02047fb893cd2b367fbe117d6d1418cd38ab7ac67305b67295cd94826806ae74b455dc9c94cb29d547194e1a4f0262f976fdb3c87144d6082455cf443f49533c4c94320c8679ff5e0586cc7cfe077fb95c9457955b26668c7ba78edf7e314a07269ecf4bb29f0ce9e9565cf0f3a714f4a26d923225589d789b90674007152b4fe59c0ec9ba6d6dae518fe0a0112658e1c75d0cc55ac754c3301b7fb4e692b9be04daa6623eef677eb63e3ee5fa9520098eafff210178fb7997643af3f6950e6ed8c9e4536f83cd0f47770ad455ebfbf00fd83e26fc9d196167be776449734c15685491cd06befac029b70999a44e8bc13b185f7e31ced002dbca15b36e0d417269bd2a0b660763ef1002ccc089c5269d9311828f70b2c72ef411ddfc9f6025d0bfc465ee17aad28906d5d2377308714bfc10182f9e384163a011f9b9ded29ffb34dd2405b21fe72d7bc357e8f2393d1b4937a175c9293e9f1c4b05e211102d5393d6c4e327d3e2509a4f24f9fb2c0b6fe92c1225fefca9185c8a4abb640027f62c9af516ccf028ace5485df14f9117508f6b4b80125615045d4413789a8e590908d43a2757c622ddd52e34dfe8d0a4f4cd1d9b20d4ca2efe674b82f06b70232dd95251974cd1a4928965c7aedada4b135224656f513d6a5b504b80600ffc288b01304455d63ae43abb887ebd51f83353d07c3a0e9fbe1d9aa33a1671a8fdf685a13545d0291d34288add320a965747c1323219163e52737b1381612063ed7770ca368c8f4b3a29b8ccbdf15dc16da0096c6a5a751a7711924405a0242c279f6921e3ae7e7359081b82c7461433af133b20ea29ab2639d29d4e7a8c5a5ce3a11ab0c7de268b8d533da0821c33ffe661425145464567b0f61a159d179b8cad8738425469de3dba55e678eb9327874c2fbe0f87c849e6ec8f4b0786ce7e20ec4697997cd470cefbb0037c9f670f9e3f749ec56f6718282227ceb50ec138fa58b513c2a9ff43e5e353872f2a9193a50779e4caf065feb65e8dd718e30f0fac65f09c79c8bfc17ce57fddc9f644b13938bfb63f450d891c8ac8bb483b2907ba5ed00288231a6523a61bd0e93ff68649a6fb758a2d8af9c00cca218152123d36e2ce531a8316abb063a84be30ab6cad04d3c71c711f4ec72ab7e44b90a995dc13cc78f0fd49c597f4bb6c1088563622895ccf97b0206541fa68e7da8d36ad3d1ea9169b183b7a96694327089fd1cd05c4fcd1e677848984405d0dda8b0465c98c031812285706ce78a8050ca80b74e2b829dd3a18333a3f3f4aa566ebb722faf71f10571840074db25426a55691344b857e59f59e339a53046caabf1e149789f03de5e9ffcaec0ce7726be7856255745dca10b9ba4038808a83a75bc53a120e31adbf6b3cbe692b6f1a1bbbcd62d2619babdeb34ec04f69bbda8f170e9764862122883784f0bbd20b978e6e9582caf592ac9cfd5f5abeef20f2a434c8ddded52fa5892f664cde7cb431a2ba4227472847251028c3c8a0bc2a2646a0403a213701486079dddb3096422576f7a7248d4c2cc6051645826d01050b913f56e410a3aa6aef2d160ceb4d025867a91eecae9efd85fe8da097ab31abe82a80de9ae4824b0adb939b5123686a4103e0e3ecabf5712ff74e1ab7c8e5214526685fcb5a553e80dc38eac3bd8d9165615bd8c8019a4dd2e1f464029bd540460acbe1d3599556e07a4c5e953caf0d77f7aabf366f8a9f460ecb207b9e36eaafaafdb81a544679202a5774a76eddcc0b865e595ddb31380cb7be6f7ecc33c829a9f1017608b60c5411da92df04f67f79b434abaa2d934c0a7e00f400a6ecc755eafb3e79634d63a27df6024886a45f1ba032ddc840f8c8c81971cd4770f2dbec86de74cc6ce3f86942de1fcc45e1df0a53c46b6fd22b0da872f5bbc665ce7616cbde49303e266ebee4102cf0beed4f0887b4738357bbed4887ef01346dc6a0d437bfdbcdaa0637c33936ab28783fd42c522202f10f700bd5550dff2fb1c0f7d3dfad29c19668001d87979963e8304cd8442851710d3549a17d9764e99bd64a4dbf21e3621b5531936f716c7c5616b35eaac624c6e44ca20a4c7bc2cd8a9fd084413cfe898e25794beef1e4d14e327402ca0176990ec41801547986ea894c715fa1d31c5984bf87d972fcc24478c5b578022ec88ae0d02fc765afa8fd26b03630ebd5dc964d33ef2af59ae9819533722ff46437407294572f2b12a7aafbe849dc3a1c93bb43029a896b7a4a2b50d81b2af550aa30d4c9c69985468c951ff78be95f6e1ddf0bb94f13bce8e2c6bf2746a2aa7257f8abd3b3cbd8571fbd5dcd449d467583624921cca96c3c837c1888b1a4974b157aea2b5fe07c301b5718a37497b0335af9ea0e91a088c871abb7cf7f0eecf35e243053fc68b973856e39c0d8a51b617f7e4d3a9038a59c6639f332d4258f2be54c1bfd2b479811604ae21a8e8c8f33249dee2968245988999d3dc2348e580de98cd2859175f6c00642c595700a51f2032704e169d4edb8738c559e38d3b56027bdd9331bf79ea0ea8e8284c62ab9d9cc607febc2a5bb212cfb6e8f8acfde5fdb3dfb2e87411fe51f674955246d3652f13cc1d512f27bcbc31f9f1cd83060205b3f1421baf790bffd845f4d3b40e5dfc2a129295f5290cc2d2ec51718b22a62d905548180f45be84b2e159d0662fcf1a0df5535e0c727db94a300581abcf646003b9b6c627982eff864a6eb4d417d5415b8131d4970d784ee0292fc4f7103999f20c755620b02e3f2a0d15918d3b8e42fc1ffdfbe9c39930c722f502e0bb31442031402554f85f2ebb75d6ab6ec4e99af16e4bc5ae7f80ec815368cd169fc58fca7b44be8df6798e50da93ab779136670d6b3cafa145c63672eb18f48c20de7c4ae510df34f45e7f1eaed6df0f035ef5196306ad509136188f54a5e0426fcfef72a04707e809398bb1be75d5f7ecaffb48b6e104a5af5f76d92a0ec76eb1ad76c701e07b91cd63f1a1dfd3665975690cfe1de29cdb11cd07229c4d65add69d095683d6ad20ad7d45fb2fd14b2ff00952d5a2a27abd6c94d66ea82e5ce51385a7de8a7f51e91696ac5b65f61ed14116dee0e2d40106e72c82e1531b7144ee1cd9702345796ad1f423e50faa7ca52336b353fe061c13eda5d3ccba67cc3b64347eebb61afb4947416e3c86a2043f9833ae70e56cb851aa32366216ae6feedbf21f9ee4c39e07d4788b787a43ca8f15aa46ac88c8202d328bcf3cd5776c4260b1cb3e87578fefc205497f4f4974eedf20f1cd1b92d5dd0d173607055d13b1c6e883c9d2b1097d9cce33dc630bcb9af99e16dd51dcf9b10b05bc49992c64764c8534938710b1a798051811d462303951abd835e5eea036196d690502d0c6d2ef85eef9e4e57128d00ae7355e58d145b7cf25cd70176bb9e14626f9d7e1a603bb91a4277a0eca2210057b6acf1c99bcc834d530a1b188d3f17b627ad02e138d03f98deff1802b174f39292cc1cf431157d969c288fb3c65ae09c9b84d60efbae04db419764b2c9c369fdf8438c8d14c24d681b12a23cc79035cd05770816eaec0435f80167cbdc878b847fe3764271ba8b3602e5c4cc894df0cfb218c67f8bcfae1f5e441fab3094810b8b8ae8f80ae1d120c1d89300829f1cff657c35e25d66f2c5f84bbdb5a325f4655a21925cf79ec17607b842e4bcf66de2ed873ea212c91bd6da25e7784b42ea50465249dacd5eb7b432ff5b2d05318f0248b25fae4b78d630eab91b3ea714005c3937a44f9f441c81f178c1beb01eedb6d86a93549e69dc83e5d75d9a5da29fcfea27744b74cdd648f4fce16be6d835534354cefaee02ec2b934e82ccc39df593a7f6722822954e1db1f1c00173aac2225df3db9ae7730a165d607dcf45fc7c73cd9e1542d4c06bc9ced46893f6543e8aebf1156b075658c37f217d7eebe6ee4565dfd9b685eb8ce5162602b691efb95baa67513a1076c6a94895e0251d2074388dec158fdcc1fe5ed4c17b676ad50c6b67ef0e2270272aa4c25f560119d77daaeb79f90a8f2dc30c08ea399f675071dca96d8f248d138b89483306ece44ad1730d824542f0f5e6c93bb18a1577596df311d8c512c8d5e6a879758bd8ffa5fe71631042e3e648c04301e0fd8cee829ca81e3c4994c5c637818edf6fb288dac2352689b88b17a1b1118262a4b72612a43397bec173679048a44d5e95137990007e28e7603531613cd64435ed2f7860ee02b6be65257964658d3356e621627ec43a18798e7f551377a7dfbef1a666d52b1ab23ba213f901c0f73a111ba19819c50d91ff10ad31b5c56fa3e0734577e9e6cebe8cf574d2ad43a3896c549b8efb98b0f2fe70400a4da46b8d3d6bd9344af46e1dbb1c31eddaa90bb0c5641f1a30555bd3959b6f0388cea4f4ce769f1082890133e113de6cb926acdcacc239c3c1628c89bd404b43fb1becb3c39e0cb486aed06d8527413e09723e8dae1e90e631e8bdc470ba147c5da3feafc86f27c56ec7d1795cd572279cdf1da983c8486182dc399d1d42fcf703e714e3d6180166defb34b52c8565a14833855d7abfb2741560d4ae2cf6cf0a627b74903d15e65d374dd757e9f909010244749588e964f20660e8f6b671c2109d659b2ff3528dcc102723a920d54c738ec2a9e9153bbe2020eb1231a7dfbf430ec3bcff4789c2f1c974cd9db6ee13079f6b4723cf3d0c89e04d4d99af383a2d24a8441dcd8a9b680a6ea1e9349fafa9dc94284db2c652f084471989ea3eee7a9ab911e000ba2d44c3c76a5b5d5badd2ab922ba356f8d13d4848b80a887557ea0a8f39452742566d902b8c69c8d6522494435a8851b3d7d10f0f19abeb4ed6cef77b52531fca00e83ff7719fac4a2789402b864224763a197d04b0b978399385f0d83efac858e8e5104b2665789a7b92fe3c41b8cb75902c7ba568f5597a727295d244c342eb8cb187bf8ba24995f0a230e7fec302641c761bfa10b3f7f29e07be58c42d2aff7c8816f50783fd68afedac813dab9341a5fcfbbb446a48ccf16770dea22d9f6d8c6785ec3d299f765d4bd1737b0a814c311fced8772e96c7f09773c19a9187f5583ab226ec9ac5c35e57603524c195839d3fb663f170182eaab0914b6e3f7dc5c924815528408f02fc61ae6db1f96184eb96aa9d6a9b29e5080facd302f277328a9fd4be8fdc179cdbd7a9a291cfa0da801d6e563a5a7f1ef520947268490267fee2bf66dce09b6b4832488c86d9f48373e7303d9a1ff294b8b8aa5e5c0c25e8e8d6b78228f26dc2b997e5009c2effa9106abd4077bd508e8cc477d375e17cba558ebb74b840a17714303271afb83113173550b1aefe0405eeaf0e5793d26f727dd5f01d3ee443288e8b5496f0afb2117764eedf18efe5d431cbb2ae64e3d4f47d785400044c253227b11a52ba7a2105c16bfa64b4c050cbccbe820e44c049a30c4b933895aee4b8be493a3c137854d94317a2004f73aeb2149c8966ae457615419acf1e6fe34cc1cc89e3a73da8f253960c7f50b4644cbfb1bb6fa2d7d1940833ce5b790ae22ac80dc57d2fb719936b430e9d83e4f4b64dca278885a2d07c5bdc0fcc95eb563817941d167553214556321f6c7ef3e394abc73a42c81adf79284e57dc820db4801685fd203fd3a52b4f5d6f40aa5104a32d56175e3762c8f0f96fc11680339d642daca155760f6ace9a75526b9acc4ab5dfea1932f67fe5bb164d86fdd7065a7738ce59e5fac0a26a65a62f19f9794d2c0724d27997abd2ea2163f6ffc04409fab9e941dcfd2fb794ba5d40f318aa55776b5fae3227317d6722e35ddaa4fc6fcbc4291af16ddc6e78d81ce5e45d92c3042f053d873ab44d34f65257d1862ec6b63aae1610fabc197df97ae0d8bef12574c9484d2a27dbb8e98fc7a05fe8af2958954997ffbc7d15933058849fd4e6209edffc11509945eb308f785918d0803a2398127e921b7d98d407afa1e89f089c70b1f49a95b244b1c83f9f3429db2b625bcd838e811ca728b631bfe0eb7d3e37d54addc45740fcd61ffcfd3db30104ab9f74ce285016c65ea35dd458a6db3af7b22e23658b2cd3351235102b0963ba7b366d345cc162331319b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
