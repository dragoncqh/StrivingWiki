<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b7d380815d395da9937455749ad3c06a9471da02154661b2c1a37fa65e5963cc6474bcc06235af592d95dc59d085ca97829c146903657287cc9f0d93f5f3c8e4159a398534245f1b616219c2768a3c8ef189aa1513dc7ab585a9c3f7698e1ae3ccd4b521f9197ba7cb275dc6628eb51c4f5ecdaad24de2af077293cea1cf10da430d235831641202a0935ae006ebc9d72e4cc5b3c315213d966bfe27c90a1799dfc871a6c3fd46e74ab9410d24463c19f77ef142980decc250b45759cb9d9c33e9d80becb6bcd97c64015af978bfdc46a27df9edf02d56c0fa81668da8302ab1e8b3da22eac610df2c3b3f12b7081914f2cdbc03372a01c258662fb80e288c029eb048281de92e46de1db83822f93cf63ba634411274f2ba238261d95b00da423f8ed3cf686ccfcd3c85689e609c2a7e52ca8180c68cb7f7e0276297b46c24d6322654c2c3e22f7e4d775424ffa90e147d0c78dccb293cf36ae1cba1e1514ff2ccb568b19c9a250ebd8fdc3f15e8521eba56682ef59820b5b3948c9d980fb222359b319aa64a2b5a6df6785d86b76bc8d8936dfce54b12798c40d0aa150cd43725004b4aaaecf078b7ab590164e86c1a0aa98a6104e929ea4989970800f9b8d77d5a43093abb996db36f1294f1ad4e381306da9720b71851865854eadf0ae588228b2f6a6689b61ebd5ed557d3a7d18793466a8638cf629671fc1fdc020f762cbad41c7a3ec5d8a2fcbf3a84380a91dc620c16419a0ae3aae016bb87af1403238c6a73bbec922c98ad6e993361692f32ab28c3bb2f3a22b2fce20847e1abef5324823040c78715b143a711b4706d8a62b357626b44935563e9c5a27938e2769510e1c21016c765a2a1ae773558d608bab437b85b7d4ca1bf3c4bed5ee78d933d62d5f0947d2b8e7a0c6dc6d19a2bf3b6f08c7c677b821b8e470516d646c6b2175d4435e845703a8118ffa5087a8f09749d9cb0d193ba5f5a328c6e930ea4f5b40efda97a506275a193d67113e0e09630d25801d434618969f92bb4f065909621dc7bb4ea574f2c176ea8bcb380c5d5be8b8f34a75b68cfd7fe11a5340e648c312e57bbfa6e60096295b3c19c3eadbc4af2f4d0232eea95cbef0f1d788e7fb43872f376935e07ccf01a1ef2f127df0c707c2a7601fa321a49dd8ad2d1b91dcb58c272eb35e441f15b757d7492a40af2b8beb5e4b13e71041cb596bbe5793b9cdb935c7e10450c16c5368b29331bd902a6cc94518283dbbe639bc90b0f35554c708f0f340635aaef24581cd2dbe45c9ebd8b69355ea67b106405016eb10040acdc892d90b48851ed7dba78a7f3c09706baec1b75d185169d0b87a955d4c19ec56987e2b664dfec3fb5248434baf7c5be802bca2e477821b92d1da790cbf46f8d9c865f277e3b64f2cc2645fa62d0ef7c2efa09c64e4f59429f24432634242424a3364d28db7bedd9704eb8c42790f5c4c4b6cab1fd29531b047ef13f90229fab014fe0ab1e4d2cd9616e09e981bf50300b94afd380e005d380965a9eae3d3f4ddbf8e6baed843a7894cb4354f2e75eae3015e659d5ccad3fe12f93e52d46b91d61632259bbd47ef86dda0efd5c3c8abe0228580295c9dc55742ee659940dd0d1929fcbf80bb4edbf70ec45b06a895ec0e186e0e79a46a2304919dd1fdbcddee9da7ee836bcfea5213c916ff84d3439e8c8dc4e2fc6f47a445c60fe3f8e563c7c0653bf8824c74bd4cd6a294e141371acf561d7ecbdf99095aa7e0e7e2b54f97e04662c6c7f4fe470da1a64ad407933386f49d039fd644cb29bb83a2721798666aa1de944d3f116eb8c37107b5997ce16c6c9b79de3683e41bc2ab5994113a5564bcd677940492fcbde0640a77a58a810a7f13a3b78b4891f50f11109353e9f80407728b447e028969a25da0755bd41abb254fef54477135b1dcfe7666285e93662b42c3083e2cb098293df9a00e166cad623a54840c624b1bad80c4ba8a1589b1301638c9b1a184a955b5133161fe70f1d431617914d59f215412ae156c6f302169f62052dd101de12a5f67844e24b95bfc458742365e236245d775a31d2a035a938afad7440c62942ca4144e8d39a54f94508f81342864f5539ba1915e88f8bb4c1a748d46a9f9a254f1f52de8d25057292769630856b1902216bd132957e858ac8e40574cad5096162d1f10c3dc3dd1e3a0cb75b4cd5d459e61f60a5665de3dcd063afad36d9eb5518ca7c6202526477ccdd91123860578002f7724cab31ed81560d26c350e981ac0b4bdcb7199b11f2b1a785f6a577025f33590eca679d2bc60a05001400b4f905a0b1d1b1a16411f0f5bcfe611526be7ee66afe0eca9b6199fe8f0eab323d3415c5c4e82ac7972168ddd66f8c63e6c7a220207aece22ae4717860774aa70a980039fac6a8479833069fd6cb351a5fd835b556abacf0babd8196452f833719bd16f25690c9fe9611f09c1b6a76ac6609baa2d091d5b9bb596f55fb1411bab8c13a40b2b1d7f2caad547f48c02d843ac9119d729e096ab699347c030b8a7f04e13c7673db5246a5fc1ad6a07b43945151088e87364bf7c835de5414b3313398cbdf9d8ace4ae29551c6745b663e3ea911c2bfbb9fec8016bd69464e65b758d1fffa6d099564257a4145b33c5acc751c3ab498f7b1d695a613653f31d0805d0d1e438916f1cdd8fae147c5c99edbac019a213cda718f665e0e519967243dd75d482faf0677c08a5c77799ce2e559fe4f14788d4d614ad9b238822d04224089db4b3b992be0c3629c095f6c55a7b3046ee8ca473a7a75f9bbed8a7bb1e706e81fde02645c418ff2e3e2c690aa4d38e25d259fca4f5fd367b7caea5b6935ef7560972d44455246325c4d8e438a07ecf601e3a12c879ca0e3ba8cd60cacd52f1fffada528880d91d0bad1c4dc92dc105e352c4b2a756524ac3901a2a0be21429300c412b1549dfc29ab9d78144fa480f5d7d713010d8a8e3d31063352b93bf6a4637ca4df3349f5ee99e7056c05f4d8a8a4bef2911b3fb1a0bbce5d5e283176ec5116556e64a5f60f084f49e26e790af820af13b919f0802812ed82b27f9794dd932fa168eef3f0788b51b5fca8a1b8a772990648efda213b7988daa675490e589af86678271091dab01921c7dbece8f3bc4eac4ffe87cd4bcf719e3f193384c88b03fe35415f60a2281badec97aae95d51f9c10871713e30aec793fd80a57b0379d497ede165f0533bbd25df7ad05ab28e6d1fe56ec0257fb304acf227701ecef9ea51b17eb608eee7714093c36c9cce45cbb154f4fa90312829688edaf160a0c480ec9792458120a99656cb3858e063b618dac6fceae6b1deb6f78295cc3644f06a86877d42e9ba67547033c8861fe65475160609058c612d4fb576fbc336013512e67f61133dd97a0e0c0723a9021869f187ebda220a6bdd0b13486cb5ed54a718e3eebf06897da12f3c328b625f1775dc13f6155eb035195e34a46f5bf7bc239788b611037f12e2fdde5ee9e5eeefe34f5509e30290c82f0a7570dd7520e0f658bca13506baf24087ef9061bbbab97430fcba1671de7e8445e3d53e48a9861cee240f9c777078e456df62209dfa447123eb1b59c65fddf36106745dd53e9e7eb767a016f1a4899beb6aee46df48d1560ece906931116f3df155876a94bf3d79e47a24caf122640904872446a9935a392eb820262f05990a1b0ee44828ca8667845d765fb67d20c7a1b81c589f869a69a0c5f1dc4e5b1a67ee2d36527ef3795922bbd0f1117a348262ce2db779b94143ee6ba540f2c9da78237861b0a84a382e5c309a9e9328887e5fc12871c577be3e36fd8fda5d96bd573d5fc9ec58b17557aad310f068daa9030e53ce976d75a1bd20cfdd283c469f71e37b2a29aeb0f916c46b3ef707ca790414f90dfa29672616b463a6a344566c6157521a8f024c288e0a923b5ed7471ee24031dc80416bd67b1a00e2058386d71ebace54f09556fccdb37fcba48d87dd82633a4e731c727b415a582447ffb2bd89861859de3ff04bfad6f637768855fd8a4457375c76b1267775ba65ec4aaca92aae925b91dd8b57c34257f15c46fd4b2d725b51038d117e665448cafc3e23066ad7c54a19af40730e737f8af790877b48bac9730b32223ad505dbd34c63db9c4bcb06d37426f2247d8efe9ba3fc09c982b38db6ab908f894d74760255788ee6cd9474d8889b829900295c22a0a9754d80ef4e992da6e4503f6e0056e4881b7d20f61d6c15457c65d455f2605504b599450c67352fd116c23eb0b79b8a3cd4804b2c06032599e31a885c83141355bdc88a47a0c25a219e1868606d61201ec8d5987032a95a1b1930ac02e661beb127526800d0e0cd868a06179f8813a2a9c86f38a8c945c3db93227c46b11325254a69aaae5b3d8cf2300415cd4ad468fac6195b558d9b44d2cf9355a42a00548fe63ae62b9c74e935f67e039b540f4d58f12981ad751559cedf62a77b940529822db3ef9e98f12da5b4da75991f4044ad13fd1e9bf8b4a0732213de933e8ebf994c8c2b67765a9c650108796f0b9dbb90d120fb4bb77a0479585280cfc39ee5c4d73aab32c7d2552dc0dc6da03819c1c10206734b431bd67ecaf866dc8ddb9fc1abd908030da736cbab8d1935e097114f80bc76920d36e784b5188d710161347e5f311cabc3100da6481ca895db886cdebffa19de180562ce633a22d231b7e0ddde33cb592d18219aabdfaf8786a52f5adf87426bb6981249fb8fb922eba6ec96fe56b8d984857c0bd0d89fe423dc727cfb0517dc2aa6b9016f73cbbf159388c8b7642da82236766a1e111d262a9de1c2eacce063ea00060f5306f41c68d44cafd732d8a77e1ae2c901f6ac8e06e39d14bf356b948c213063628d6c6a4f2899e4b8753e9e2882e90d466ac2082c4173ebf5a00379bdf2fdd73c3e96f5c8977e96543e048dbcf879615bce739fbc1e6f92e97d212e011b266fc015ff50ca604f265e8b37d50c2aef12ae072e318a29ab3fd1ef90213c6605a7bb21ab74f23229f1b07e02610fee2ee333cb2eb775808535f6981edb92525aeec6ceda8f307819bc54d821f07381a7d99456969ba659c80635ecc05ee3b49c72d86d9c25aee7d57af6371dec20b65adafcf2ed06f4705941ed9a6655f8e502b32466c1a3e4e393791afe5f244c0b69b068fcf21ac6002aecc4efd12b227dbe4d95782f3c40c692e4fae3dc2d2121909a5e840ca99a16d05607e61be7f80189df6e9cadc4d583bfd1019c093c4b958c2cdf63f3e846c2c021c84dbf75f9108d4e718745e97b7bb7652080f538c23578025933702a9126ad5aab6a8355d6a7eefb146e12626d513524ccc7cd6aeb1ba435b59ad87ccf5098e1031fea7ba9840bcd95d91f1a6e29c782e08ca630d4c783424c3d813406f995d4306da1d17ae46541026253a85722ec15d2c4b4d9a50bf6dd065f2f2d62c03a7bc23ccb68028869ad9b1017412340a1f1ced334d0f8458f73ad74fdb56a2d5bd25529e90bb96903d655b98a3be5592fd96f398cec9544e03d5252e9abe79dcf3fe0650200a876a867b7c127a98dc1a9d048980db610ddfc0796a0a2563f581ca1fbf63d57677b3432c46f617d8de6b9444bda6cd61bd013c3a76445a213e4c18d7d8e25b7997a4fecf369542780aa988f803cd8d62b79804c70bce7d09bb9524b85b27e7b57ef8f743e4fee585d6124a30035df07af8277269e21bc4a9b7bddc6400fd296768e12e389858b422676d0da0f0e63e2c45cf619b492e270e9d08f0128a3d3e82e4eabffa839a8e485d4b382b228815edebb006767cdc7df4e3ac8273ba6ea21496bf16374fa2e88bd81390f7858f56b6ccd8311b15ad1ff9f64610bc661efb5466d41defd8b432942c7002998e75565b2e4175ed12db9d7172399cdef60f9dd9ab7b6c56a4355bb01a131ed264f1ae6e45095d6b750cff49ca407cf641ded372ae1c5ae60ca5705cc1e703308d30a052c45cc5073d7a3d856713d6d94f04da72629e0b0a70415607cad467d70cbbbc1d6f6cad0abe557ca5883407c2418e6f57e4abc338e26763647fe6400fce37ef8eedaa13f8b6e88d5d8419c92b6b83aca0bf4586b5c1755fb721632a9083fcb597b4ad50cde7364cd0dc6bbb041454f0abc5b1ded9262dff70ea22f4b4eabe979a55c291811da016c2f6bad34084736fa0df34240b544b39f77e60b43827f283969dd391296cffa8e2735b277cd0b16c2cf774ff0d2cfd98adf429e75613ead5362c4759b15be146f6a9903df6608f82eec843cc003003d7412c27d344c0a5ea104fb7edfc1278c75326d12aca1284491374426cdcf31651b11f72738c49304405ffbae890e3e5b6eac2de7d7c8b68d6151854875d5dbf7bdf1044fd07c536939b94bf3492165d1e8dd6c6d6a2706b3e1586cb267c8e0819d6ca81ccb29df51a8817dfd7370abf8f5354c5d1fb15a869b73198701b712fc71f41753afc24c485cc3ff139ea41dbde2c8ebf27b975b9ad285b1b8ad01870cd3276436a000b2d752ce54fb8d813f58d5e5e0119761474b59032d0676da90b91eeac8f7d48e1db115a7064d0341f796a30423d724cbb96d186542e66d5aaf8a3ddbf5b3ed8a54431db6e80c8e4a0a2b29e17085964182a90fd7b6ffab62528bbcd2e8f622f5ed5a05748e96b84e5a4f12bf35eb2f0e06ab3b0330cc9b3512054ff4fa8d276bc9fa97c64dd115bebda9a02d60bbf592c8922016cb559fbf91a3dbe0c0b64d862a2b82de7b9f1ca0d4c1b55e4ad976def63ed1beafdb221ccdfaff91d4ddace56da5f737e5581f7eb87b4a3e241a0d0d8f438128143ab9cf6f7ca6dfb59f4c97cbf1911d381b3cde30488595a66258eb4bd184cea3159cbdf5315c2b02b0354e313046a2607e2a28218f4c6f3f593fb2ef23d9389634f119b22d460222452174883189f2a5dbe3e256376ee65f87be75f2f80ccc952c5972249ee62fb08a5824bafe8aa962cea721b329b331e6437a17f63800acff2ca13f6e42b82a5c11d8bc43e221664d26379047d04fdbd1db9abb49a6d30045d00d1528b9819860ec04a3e656f677f075a94ab8e8f647d03559ad73548f3f5a2256fb51c9b544af683f26e29dc09c4846d994bf63e0d63b40890d1cdf794f3f51b900a7b67fc6e18809a9885b4ebec8fa4b8a708f7cd6e946adc73cbab066048806fcb661ff3eacd8f1fdc5cdc3c80b5bceecac87384193273eacf1722d37ba2900befc82dee52687507b779e8f012ca4073abf0966b24f65b34b100e57a7004e58f32176c22cd44e964b46f6f8b2b6b5734ff0809415d4ed814ec9db0349ef08a165395a9f1e9ff0ff9ac4181b3acdaa58a3ead228221ec2ca6f75ec162d399e0c33470bff055bdd8b64106b0e97d2111d7b4e81e4634623fb76a3e192b3c2c5e1fb1f24271be8a9f84df4a0c03807413d5f79e896a5b7a8af1aa89b433d9753a0d5180265bce3038b672db9cebae2260bbe56cea8d246b16a8f619c4e69e8a491c2a924bcb79d56ce7467d53c170fe6cc23cb968fae3a48e48bdcc55ab3b6a451f9c85ad071556be36a350e650f6dbbad6e131975735dc30c75527d331664960b8c80faa4975d4b99d6eb25ed7211107e86c738ee4ec02a4c7b39a4615d78cc52e6bca5ffa2107ee0eb7c8e12ca68109306d1d01d8db4f57efe6d984a6040e0a25a89c5c839e8ab010ed35fd0bbb4485fa68c5c73fa7a1601124bb4879db58192c905177b9c636fb5b58745f19e8cb4869976966258d07b75679ea49498e1009bc3e99294613f22397e3e4cf07a05351a2c6a86e9273786f0a4b6e6a35bf7a08381c6e60b4e2962d849ed5f1e84b1cfc929e0c67ed00f70d57443f2ed770486ee35d55c51cd77c8bf8cfa95a4aec7fa3ea7c78d5eaafc6f39c7a2737bad4e7499e2fefd9a4c3d22ba7adb8ff3dc0830ac288eeb884cc1d349ecefd6de6acf14e7ecd616b912f8c07833d38854d5680eff328e3f687e02523ab4eabcc6431f4569ab56714285b19c3ff281a41963ee74ce8fd0a23e7d05c9ab026f75eb9da1ceee7feb5b909e14493f5a16949c2ee24d8fff04d45df10318856ffecd0df2f313e430755b42177102f04f96ff46f3b7e67a131fb50bc4c113b2ab78d27f6ae984814d9ac790c295acfda45dca36948cb857033d9a9a03fccdcc1d96dff8f84f77cdbf6a1906601c485c3d1cc099d8d1824a1d4d9d9b189e57c17b30a28107eeab70fcf0fef541fec0d69b159af3f08e2598845f504ab905e47cd8c93066b2d272245f1e07c97d20114a3af4b7253ac3c37fbf72e0473ed6d814ebe9633cfabd79ef335bec400a4ac38555052e7adddbe13d2fd0b3fedfa977d1979d03e557bcbcc7e2ab13a3f08a9b338dd04edfa0628d39b0556a9a9b87b2536502747dd18f41f3266b71dc7799fbb0fd074dce3e799ddbacb56a1a0cdf647d287888c7a9ca48a844632e856b01d47ad0f61e6052417ab249f29f5713dd07e81c511760dac0dfe1feb43481a84330d20611bf0dd73274bbe565af7f31c55ebee14efd1a9ffcf212ea990e061224a9eb574e754dddb7d8cfb6f8d514b945344ad0dedb691af63f2d061d06e67e6dc058c3fb637098416365ae1189f96f0f51d29ee74baa68c2534bc6b106247c4c05c301322bb2c5483fae5dd528f78c95adbea122ced3d3c3b80e0df0cddc9ab7520017087a638c8f2d918dafac31044aa6fba863091211440beaafac54521f8246ea6d706682a35e86e2e5a910c49363ea660d98feb0a07308642e69da42b68c442d5c412fe422568af7752093b0c4d6b3a3242dc78a6b561cb265ddd4402ff8a072cfdbd5f65d150fe916d3cd6696fa22f668f6c4d5e62495cbec4fb948d22e4e3108f0b160562324f6640d3fcbd08fd7eb494d2fe2c4d7d3d7fd71253ef45576c791d2597bf5c771250cf33485ad5ea0c44840902f97110b194c03777023ad5276a4373a7ad17a57624302b0a59e51c0abb6802aa5042e1a0e33d33ad7016b9619716911b7b59ce32e3e3aa780c9ead7347e44d88663e9be891dafdf333b4d76f93d44bfe139f20bf12ef354c352ace6dff850824fe1d1280c96d044780f56f5d210bfdca8b02d3eac59ea685ded2a093163952a44bd8f6ef070ffecc15bcba3ff3200de0d1558431e53e7517848e0216bbda7668a75a65f4408c9135d00533f14269a398fa0923bb6a22c77b2443ba8874e69ea9526d5b121b9d7427957eb63fbbdd24db60d51d845c91ea19537257099dc3ab5f3e33ee9660f18397f4617f727eb3d7ca17e2afff0c95a3b83bd56975208a4f0981cd8983778db0794fdfb8a9a5db4f0d85d9d46e4b2eed9bae0c5cb6d273b66457e50a83e75b037c91e48a752ecb0fa6ae52c7604f0532d2cbe1731ab1cb04822ce7e5124252b86176563fa0bebb1b5b3995c1848c1d36f602ead4ead26460de04469d13cdbb2935c10b8bf417c2f495544a39200eefb0513a7ac4dff18076f252f87636af4025c731e3a0a1b5ccdf3c6e92ea84471ba44a5f2795fab6725b5bb41f64d6d72658d2abe59989f18fa470112deebe17580ab0c5d8773ad19c26e8312f4082160136addf95130fe0209ed04fc7f1d4aeb113af352dcedc2fd84c0a2c8f446b0fe8e0b7a8a3dedfe0bbeb4e30349d904c7093c5090996bcc12c59c121d5126dafd388c8e0f2a9f1b3efc0c2fe69046fc7e07a0845fc5b0d2b3ae3929cb4fbb7c1c7f9172bce3119e16f36e7ab51b23970fa435c77a960f2d14239765aa4e711ff36156c781d39f732a4ff4e1362d90b55abd1e1cb733b385efa8320734bf0e709557a787b400bb71a7252eab8098326363abf97f8fe0e403e76648723fc838d1a3544ee30030e1ad2c268e2807f6818d0a885114a5e5105040058378a12aee6d3d928c0bef0c92e6fcc87ae308fe72228cac27d4cab0946b618bdce02dd8a9adcf2aa439ecec26bae8115387cac8c540b8387a74500ffbe9f7961dcf341f40d370c1ea3fde9061ab4b40e36b8cdbb232c8653fd590e58363c268b029332d304d0de8be356c2cf25808cffc8f7566f7d6afc1bdd69948b7954b8b5e76a31cb5a587ca07edba3f394779df852b0c05cf0c6e222bab52fa75ae1961b06ceca7368e16826438a62988ea354d368300841ed01a6d3172d7e17e4c9ac3ad6a562cd14554abd2af239f8038e50a5c3f86821ce5696b250b74365b2053e2723e0b4791806834fb08efd3db5e80807341b8a5f25e91c6206052530c9b5d3de8e896d0c4e826cbc78739d1140da5c4ccddd03637821fd4e806f1855e42c12394af7b0924fa7dcb3779b8db88945f979b70c1b6db807233464a1f0cc5617542077527186f2b5f8b870c61b6d028812f4ca7f333a39385059d69d3b1ac6f025a0a6a15fc720469efe6ec004fa28cff02a8e3dddd31ff095ec59c85657b244820ab8aac80c8e9defef825b0e857e09700a6cc5b573c9e635cb7776b57a86444f926a256139281c46d6b7870b59517ef2413a421a5efa3d86de3359552fd32115e2a8b9966c36a0fcd5f3c63b816893f63a510e17074ec436c5298f93e1db33cce33054096a62348de2fa70ef500c601cba84d4a1de4a3d76745b68f4d1e5d28a0dd4aa6be50d1b65777d1a8dd6cbb686e99ea0655ddfd741a6b1cc459a21c9d5d535484e9bd0fba06c4ceabf3c89846e5c861ef11e15dd7cb794085c67fef5c8ad01262066a00b5c57e593cfdef9db05a35bbdc1f22362fc6f81bad079d71d7bb4109fb440a17dd27016253ff8f50a1646c66b6331d55a678700f449d2c62d4ee0fcb1dfa94f5d7f6909f415ea16cd53d2df936d24411aef55a47fc70c968897239864da266f6cf8bc494d851e5154b6915db0a11407bbc102ae8ef4c62040880ae23dc90b8190b4fc6a631c9f16e02cb7eda77b6f8c1d4e885212526232a6baac296a929857bd7675b386f0c49755b355480449c225237ab2ba4dd7bc5b7bf0f8829b8331402e49b64fdc063e3a25d11cb680bd9de81d33a5f9fe447cb64a8f14a41ffcfc3ebc9b413ef6ccf97216c838cb831f042be631439055a6336b536430eb66e7e377eb3fa50c9f2e3344112d6c0063c662d95babfee4528ea6a489e1eb161c9863b5fafc080ad19205c0cb3c6bb7d2982a47c8f87b86dda8e91bf801d31441be8f3c94fc40d2d28c231aef83dbbd9fe80ef28635ef59f12fdf44dacfd011e2a55142894d8d3a11d5b81f1c2818d2fe0496894f286ce9a653c6524d0a31bfe2111f9d0a37a5b36c859ec334ef8676a5836a0d6705694d2100f954dc44178acf2a8b259cf5430028decd12c8d61cba1db4b4150b0063187ecd8d442aebaed053a10c7b4c5fdd50fbe91e0f6be5ae005be0b3015edfc811675c2d9b5c9dc7941fd9a95b4bf03958df4f0b3f6698fdc37eefb1dfba1b33e62227afb2e53870f1732abc3f98f64d8bd3ec99e625abf998f1dd7d47115692af9215ce992ac3786d250d69dcfa5a197aa2bdcf7e827457e94e083b4c36c541f550abe08bbc884a5107878d479d4c8ef8d567646129cd0c539dad9c453ec50da34b177098665d99554fc7856aa2674c33e92620eef07df29a7168ce215f471a3621a32b47ab475a3f7434d4776ad21690d7b6c5762cbc134523d40e7d612df4611ba3385d70948dc1c52a1e4ab2ae4b5bbd7209f1429ef6df7e13065f4594c19803a9a6e27c8a8cfd44c1a15577199f68ebab1ca0fd942173cbecd11317655dbd053e585c00a5be015fa337a9272c13bdfc9614f4ee137fc3d5b48db594384f47c74ea345c9636d118fa499f7dfd885d8f513318a7fddcd712c0042b863bedaf68cc613d185231c68fec5c748325f49ffde399dd32790e418d8b369b6c5f217e1616552cefd447731f75395bb9d2c259045563909d38ca0812b8dff6b47a82dc7da8a9a51031e2653f3bb6ce6d97fd9fafa83cb4fcfe401f2e0f92e45ca8241e24ade808f9fa193cdfc932543d19f3d4caef87baf37bf4565a538d93d914c73e5f6fc111e2d00614d1b3cfcac8962ffe75f063f0f051de94061efdd1da4914dbe8ad02ce48a989e5dfbac5f336cddf75d8cf7ba9c6623232c450df91cbd306cce417a928c40f7712b7c3820be25543eab63682f8d3c6883163ecb06837e1325c700ceebe8226f53600a7a884eb0dc59cbcffa3f4eded39ef9a6bcfdfa86276ff1679d23985b061b74fe3a528d826dcada0f53ceafc793f670d413faa4415435a9ca603ab2cbac4b73f93005297c1266838ced532e8fa4e397864b956441218c6b8c028f7a989f0fac8c34d03ddf88e273fb900b230dcf5b67af4d01ed770ae659d84d79e2090b2d37e332aa305f5a377f2b9ff5839d656b11e96e2d76cc6c409ff56948717b66177e55da575d4f4486f19a46d82b4c40a8772a5bfb22aeb06822afb61d90f7488cbf67a00e7ec575b3fc0e8b4b011113fc396a94f5932974d99829ecee71863fbb17def1b36ae42738e3029bccc154d7bfbac29c9192a5dbf19f44c29c5360bf41559c5f736b43a5b3f6e0b410e0fa1cfb610e7d6415c905d91341e93bbbdb132f47ff7894f7da09b3d92d5edae78250a1e443233c359314753ed52c2202c334943b11fa65fd418e442f829badc0b2b3d5350383b526579c0496805302cc30b13eefa000342bace6e72e78ed73045c722a80070675e6e707b2e3a175d617f9d59eb8d3e811b9f37f9055c4dfa1b75a275d7900d90bbb4b210a2ab7fd222981d96ff9c0fde47025d2a65dd1cb6ec4ed56af1ea7149913b3e9aba9c49fccdaac70200f113207c74a08338077afd9d830ff8e02af9c6a9919f6aef262f12a8bd25cd3acbdea2a34ee5d7d9e4ea88482dd14aa81b1468ff2aef6819386f705abc0c1afc9161d0cf33c4359913c96be19b36abe301972614b5dc0b574dedd757426e22b4d184d17575cd4f47f6208b77d060f24766a00671b936f459bca3b5f5da13a83acc97ff55d9bf50a9666315295d4b01a92400a84637786fa78351f501ff2c47f89a9901bfe5fd47f73c6066e0f37ce9a49d2eab8f98138b4188c4286b41baf67e58a37aaf9c481172d61795cc553125332843a344483d44abac8b060e11f06822e0217dd93d5cc9e5c9e5229aa1d8a386ced29560b2133e2598d3548f6b8ef53766b91f3763ec5c075514f08d80823aa193852c30dbe429d8c83a5fd4d07b8603881fc6c6095881c669d6af0f9e84e71073da3c235ff69773dd9e69f500c25c88b9ada9ea744fc8be899573c9ab22f7232bc8d237483b4e916ad6ad8aa7b76613a55e57853cdadd4b55ff2395b72b630206ff1aac1772151d4a153539e36e457df299228adfedf358c7770251c2ff0d13d3f88546be65dd581329dc5b5fb7bc9133544b209338652f16303901e11281e3892418a5c67638ff7ad98aa1fece2c007354bfd76a503714e43a22040633b39b4101e8af47e34e934ef941288024501cfc39372a9bff4150894c9631cb77ccdb71b9756c1da7d7e80ce10bd74d48e515382bbc44659378843d76ed5924b4512d47be7f5df80d535dab7309cc62f9c8e9604b58891820c13ea1579ba6722d75e8482ee707e8c7b21557a302c58079deacbcdbcb38fb8084fecb58cd76c4882a3a107d25de0ffa591647a28ced46cbd66636b44d79269a5c99d959fbd9da02ba627e5fbd76b05bfb6af6e1fd998af1008678297db8745471fb020a8b28b298c2768f3ee7742647f6d74c53c4f1dd85bd163d6ed09067f157a15a945b0d60806129ee4dce6977ac1a6e36103a606fb783923f8894e5f7ed3c6a4a54b265f8658c61ab022ae45aa2cc842bb26f0cd4b152718980b5ac705bce81172175b07f0217abe34150a9ac28ed3c63a4bc26ddfda0d54049e84e823ff9e36c20315c6b8fdcd03d4e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
