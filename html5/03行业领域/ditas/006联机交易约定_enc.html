<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"366b99c0fea91599546d3f638d8f797751e715a1e357ac9325fe088bb74bcef89b548cc430981ec7737216f2791b61d35460252bb8ad53e1b5713ffed251b34f3b38a6eee4ff52fdedd11518577f0e9625128b4177ab349b810c06190a31c60dbfc9329091bd6d861a2054db3d442e582a86e248661fee115a5bbb31e9d70b54c8b84c831cb11f461dd83929fb0c5e914b032e82bfffdd5e1a8ab374057fd86c6a87d33eb097cfa5efeef07defe9fe7ef39cc00e649ce9d4b123b54919bafa6a6cf3c3466f2848a3a7a917f557e6400b9fc82cd8721a572eb16871e2541487c98c81964f9e57ecfdf6e5dc54f8dd43610d6130e76b19d21ff3d46f7edf77e02403d46dfb58a14799081158bf6e9fe1c069cfd26cbc9e493055d16e6333f8330f03563f0f1420ee0e66aad0e17407e82637d48bc62b19987b7a463ecc05a3272384314f730fce2bdee9684dfca5c91e4a6702cb7cdfc68863ce31b64b3cd9fc2d90aeb423bbc38663900a56529c66b3a61c2de334d039e8f6d2ae1b9ffed660243e9e420a7d34d13f461781d394f88c761abea44b1084d84a8e9e3048a03cfa494e4a399df93e5d9824f1466e7422e6d5ce15041bae8380d1412e9f5cc6de7d6fc9d8c48250dcf0d4449c605d5578d7c3bbaa3e05484c622027b8c6574dd6fb67fea12b627d5e45a4d0620b21c0bf8e0f6d35a50a6fc06877c5435a8a2d4a700b5a4a58acbb4fff13eb804a6039235e13f86fabeaa679e893c64459a87466b33ce80cb840b5b169a459fc9af546eca4c338e84a203f15b3ff846bc8ee9c2690a155d888ac6469ee3b0f7fadc1202da32fcf1af87966ab8e727c152d2e9563dbf88cd230e4a1f63e7caa573acf783d938bfee76f388130fbfea8daae932de3c1c06e5d408f3eadad7351ca4dd820e900586c29eb6a89ac4fe0fe2e886e21aa4e9c4fbd0b7b44aefeff782815539ca96631882fcf2766be4219f0550c0241def96559a8e318dda964c30d422cdf2bb2cf38c8f4432a9576902d4f6e96110305c6b790a682b458d1fd734e05fc3a5692254023f27ed2a494fdcc6797d8afeb927825abd6ebf3049f200410ef6fd17da0541ac4d2f9065321deef21847b15428091405750446015b2e3b77a87d2f893e785499eed930cdc37a48ab695fc420f8682ec95fb88b9cca9dc00655c4f2df174fa74cb3ca46e9a4c5417ca4471aeeb28eff3e6175eb9e455e25b3429c56443335ca03ccc4dcbdf6976170d03f35f147eb31b958605a18e8ea0b183cecfe4c3cfa5e5e7bfcac4deef02887cf7545f7da60ef6b762a826c350b3fff73c8a1663d502fb825cef8a370e29335c784ec64793cfc4efbbc74a4e73735424abc52ec430067959b09802351d1fa3bd47d10c00cda6c1f7166dc04122545475b5e55af473cfba17eeaddc749e7fee7166788aae345f61806be1c7c7c85acef9547d3bc0b1e98ea0522ba348c0a7424c01869d336fe3cd4dde6a52a1019e8d4e40ca9aa0112f34e3bac15ff652c74e5d40168facd808e9d4b9b465512f72f3449116ea61685d508d8a069a9155d9f41555884d2c6aae1b10fb560f079f2aff37064a8d4d5df17c8542d0eeb4ed1d406458cf697c3fe1c9c236cfbda00fdbf49b1ca8a1d1e19bb32ea56770c26fbeb0455b1bdcc455a09e3261f4a9fa9a8366794460c9a52fe2c97a554a8e38a6e18db165fb2bedd4fb2df7ebad8e02b3d04f5d30dc29db5d093540feeda6a6a19d96cc8c6f6c4b467f3c996e8d752ffe4eaf29d62db91cf8bab6fc259c781a92f4a6dc1f9cfe24a3cf8674958a8d77f539b908b1cc096bcfbe5ab49814067a26c77452aea2646f1e803d4b5e542e2685534f01d7887355d5b0a12ce9ead6cd76a6bf14b7de91eacb83021e0497aba900ee5b900101964ca058f1a01f23776a1af6bfb05cc5596919e46b1822530dc34d307e18723a8c4f87b26297d899adf5f7e9ed8ecc524050ba11931fb24d9975d2114388c148c61044cf34b1fadad2d1846fc0bfe2bd50e6eab8d2c189219b1f75389f6d8d8ac41e81adfb16e72f54d039c131ad5882855d2a3784e874fa894ae7849701638de22a11ebc881984f26ef31fd216d02214da735cd64d8d7e6d81060208d718b029887117eb4cef11fe9afc4b91ce343ed724d0e011007f568eb7f5a8b26cf15960abe80580f2cf2180f32d791e7fcce672340529faa45f67ead459049ccecd72045b12a9ad5715f8a4c0b0d234e8533fb2c3073253244a8c0300c10db9f2289b133df2bff2a352290ef3d01e722d55a06bf5d0afc46061d56412682be34d9107074d72099c0304b5eac48974c800c7b231457837ce0c52f63b64c365e99d1dda36bfb105b390cee037f6ffa01a746fba861056f585c6581033533ada5e0fbbb4ad44dea356afb0a4e3c627451626a5c2848bdc9d24e93531d0c91da10724d6011b56d65c01ff36fcecdc944967fca858b20e38ee42cc6272cd12d9c3725d1fd2ed5642dcce67076ccdd945f4d7ac3692e43f89c5a3228d13386085eda66c83026360b7ef18e83e2dd56b9955f7643ee25e002b44cb6238a8be19ed55f96908fb7ed31d9ad0f33d179dddead1731a9b9c0a20eef8da3a82616b525f1c164e4c7cdfd279af1165558e4f123c7ec00c8d68b0616cd44f6937f00f1647a8b9e7b30ab98ebf1443f8ce6279c4b843c1cb667872d753639c463b045ba61bea38b931528091aefdfa26ed2963fb42852e4ca0a053740dc50fa24c31d0f6d4f029d3d3876e910796686d838e4a674cdfb36aa1e5a876334c3f1b554318f25bc3b53eb689724ff64f0da9b5ae01040b6963a0420b1082e656aa53fc674345a63a542e5c5f920ee9afae81a4eeb37db6379bd60a58d3e7e5aa1adbe45556bc3647d661669d8e5e6cb5e38efa4c445de28413a86bf3288b6447df27606d36095db564217922fbf1d1bfb9e3d3d7d66e87848416a1ca4962d895b12aad73c46cce99dcf170b0af4b4fc38d7a42a7318dec8c0ecddbd2f3687e285f28ce5dabcb5de136aa25306622f6ebb1e73680d8cee84491504914b763b3f7c9fd8aac540ec4f7c4cb41c366be7dae8cc1edd03b4a3b18e0a5eb464dcb941b2a7915703491bafbe7a0168dff6f7f2e58239f8b4adb39cdebb514ec0484042f6e88f28d0a8bb5ace0c825079ab8232374857d47b025a9164f38a184e9b50594e3ba40bd0240f259f21d99d17fcff9c8d27fd8a266249abd077a264afa2b7f4c14d7fab7338d1547d78a918ed9fb65e4db1b460def2bf922e9d8c1aa7859c13ba90a6ad4d0179013ccead3c11ad5bb310f0d9a8f57e5e85dc521089fff61999fa6c1bdf4c7b95a484b7d6ff6c9b2b6f5d84a42ec15ce6d0653cc6a84f2001b9c71db493fa8e7cd1fbaf4dd2e27411a971ad8bf30ee2dc215c439364a2b8c5893c700b1cff8355ee9116f7f08566dce1b4149e6c1b91b9a9d70c6d34489d5d03d9d0cacb49398a4bd7fb844200e27b28e81acc861b67aae58ea35bf65a2d6c971a7eb3d64cde21e6770ec0b2dd4ba1e59e52b0d4a6a24baf9cfb79059a6276b42d3cbb79986f9305fb277754345162cf7182bc5cfb6cfa1c688aff5418f5d720dbdfc985b4e72dce5da20f7a7bbb2e303aa7923400bc56ddf2def758a46fe7e57a588c9f477e4a78568ca8f868ab9a2ad20077fdd2721045e95e5b2323f1342fa3c22673cf3087a51b23ba6af678e868e9105bafb69b03b09a40980477a3e6e410d330a4deccc6a19d3476b5ec571279b5c255795654a4668f9ecfce5c33656bb2619f97ac1385292c662822c5b73e2f6e49af2e9d6ee99382a75020d34fa6cc79e412cd42a3ec3346e4a9e8e136968787a4c362ef380852714a9228a0f8915f06c59a851a52d61e67b6b5738a091cf820a69a2ae011b7e04c2c8a4f7e3ca59c2651f44f5291c7dd141a31a0c149acacef486811cbf933c844896f86734a6df05977c1efbe6e75b707568670d0d85f38740585a2917d232031bff93277ad2957429f2712d5cc2de75a3f46c010344430044109b84a9dbbd19e41aee4a693e95512c6476ede31b412626b700a46311664e2c4f14a871fab76a03bf8d8408058b5a05e611646e8f43ac20ebf6ba4b744147baf93722a102283dd389eca1360b9c9c0cab6333655e9a1d0a95a68418472c9a3a14a670a6715340ae232b2d5afc5b98d33a1c7ffa4df851a930d6dc3e32182fec9678b5150667d830b1530196998ec8c865bd4615d3945368fb791dd1df766d3c9e594d5045adfc78fc00e85cc7fb3007a0d0cd38ece8139b9c8afb0fa31260a88b04114fd00b08c62d6d4001fb529928122c01c92d54a4c68f9cce507f71e6198d4f20a39991169504992c7b2490aada0b199cd5c399d072d75ecb15b55c40011bb221bcad2be8ed053566a6d16822d1e7912f196d32e74183613ccbcee0e5a3e9794af01e60cc01a2962bbcad977d063662599fdf6fc3cc692fcfc7b9b215a4a88adba41879cb5ad8a9a7c307bceb9654ef3ed3e611ce7534b5c21f7e18578cdeb1116c6a325d5136bf925aba0e1bde7e7f2e74aab024e0e574af50a7283de34944153c36d1f9a7faba81f30d2a9684f55cdd7b461e75ac33b262d6446a7460ff6e591474917547bb90c6023070d078488dae8eee28c0a661553037838d81f05a0f7d1dc1e72b12bcdd52150ca048c0a36f9ea8ceb2ae11e1933d68c802f90e6ae7808ef94d080d90f4898394754d9d8886b0c96906dcff7e1209cce51ff125ad00e4eb8fe99c4ec216c0ece239ce8ae938a2fdfdc29c4a675a12fc031efd8721d62dbac01e48bfd1988f670953abd7fae830cfd38288b323079674c215616463ef2333d6ceba0e12005194df7a27ac064b4c94a0c4adf69655f180565d069765bf6c81ce614451e5c639ec14c9cd790006b94250e4184e5b8418f2c30789b838e80824ffb86902cb47c6ebbb1a801fddc1c89697b330a924541503cc8fb5b44862af8acbf22f508e1ddfa304748ec28f6f7b9d83b96b0a80f37158698bcf32de516ec5f9f7c5cceb6fe09b250818d770d536b856323e964a5e10475655185c7458d2390a2d6861440e6b0da34853a28bdfa248e0aabbb14f094ab295ec0d355263eab505725b357bddee628b56f2d9b246c0e59de9daeb7117daf5914da745ee3d1ec2b4cbdb8e29693ea21362e3a65d12a8ca324aa21dd23eb0b764fabf4e59e52c11d8683e13a00c39c5b0e4676c05bc40a56f1d328a81235529e6843b218e0f77a1fdfb4758ffc6fa0cce48cc8823aedad6eb0ca3fa4f38d87d6647eb374a5fb12e6a19c968e5629cafe4c3683455ce294fc93899b0ccfa82ad8b08b4fb49adb271883def8169eb56bd2f36d0083bba10246765cab44ad3142278cdb7b8771d628868d0d23cac201e0daf4014d850c65d9a7d858e879d570e4a4e58e86fe688914434487fd0438469be9d7a465e0209a26c55dff5d4cf988f39cfcdd5653200fe8e69be81f74fd428b73df7bfc1a1a02186f5e90c8d7e0c99caa0d8748a75c129b954b724835bd31ce0eea83360d8b1519395d04e63a5e60f179d9263f3a970bf8b275f8c14e807719d48b0389854fbeb815bb47a4b7ac791756413087f315dc2dd4d8568f44d409b513462110df579bad29c00eb9cd9094cc82a7f6cf72486586e55b5ba53cd0cdb08e01496904b89a00b3ab9c5a87c21534fdd90577a87e152d7efbcd3a6ea688b812fb29a95986dfc12d631f5e42f659ecf6d52a53053fbf38bf8642b820fb8ad659f467a28158e67679765592e4b1b2821c75c96bdee36b73d5548e5a14288caccdf02eba4661cdd38c6b33a7b793a3deeed37b752c54f6f84c30ef952775af98d2754fc73e846dbe83807ce4cc135c015a8b43a07c40b694925be89a83ebc7858c6ee4e1afe6958493536ed1c6a3a173ce665fd0e6c4e24285b21d5ae046d0194b3fd50be444932414329889049588843e982d63a6a1f480ab081cbc3d3de5411087aeec6e9035ad5a07c70c23ba2b923bcc0faa54549dfa475d7c8dcb4426c8edab43c9a8020e615bebdc2095c21382d0a502c240713fe4ef44e1b1db46ef00b3f699d16c87079b151fa3d32b420c4fc132f71d385c6f958390fd70c078e51389e81fab0d0ab2c98b02120539149818ec9a42f749b31c8c65593a8168a2b6cfc600d8477261f3ef1630b4d887ad57cbdca618226a694a5aff5c155c71718d5c7488f059d184bcd16bfb898952ed9a46c74b3055409c8013984c8438468ed5a1b11659576dae4cec001985a1fae72dec2c4f7fc2072b78e14f6a0f44aa77a90929b26752853fc51f817d7ec9acfbf093559f2d8921944ab92a35fe5c9df3b7fbf3b40b7a0ce7b8e584a0ab7159a88c9644e5f73e5b25f8f980300f847f4abe9e56138c0ae1dfa2aaf1cdad073f16ff3e204c807fd3863e788d894b77ced142f7033bfd23fe736101976ddf194c11bb61c09d9225d0ea09ff8d8c0d83c602c7265c1b918de901f67a62b3bef660324d1f7ebb4dde77f57a207ce7b959fa88ee87a3b8dcfbfa5ecfc63bcccb57df1d4e7988a03e4d6b3a48603057114754cf788b3f9778a9c5c3434466cc2d2a57492fd7156c3c1a9c2bdb18eea1c05e0a847f25e80872540b91add140a539c687c6ea214852b33ae7e578bf235d6db11f76c5d308a55d104d4ca93d52c49a3f7830d4079bede00b09726e5bbd3bdb08a41ab4cabe6a19fef704b55aa03d60682720b362cf33cff22201adf26503356042b097a24018fc50ecf5c2502f86ce6b60dcae27dd827928d7d77e75b2a434640c4aefc8ab2e524bd7e47c7d4671217562989acb8519c242e10083324ec663ba21cb4d0805390e5993610e126af6c3c38e22e47bbbfe4a8be2abafa2bec91e026af4f318d4546b3028e70e515b3d14ced67d8e327d16d47a8e5fddc899edff0cd109d6d3fad0e29d52d06acd0b6d925c06aba6776f2af2c7f3b3835a32bb9fea7bf97558f65b6cd534a413173afa1460d835adf8b26ebf7ffd3f5c910c06fb430dee527dfed3e3036bee47565ca030c1c300a1f2b01ac9e7c52aeae9decf65f85b1c5d287d14651c51912f293e64fd4eb275c48772f051f6d70babae7c0a0d22853573bcace85ea3ef727a38620e6550143320ee77766d8b733acb347002035dfb18a45bdbe805ec6f487f8df8cddf8fb2cced32e9899137d808f10c5b14cc2e9cbf7f25c3295d51a71e94cf69cb7abbb5bb109b7af0fd43c3b67e94c94c151f2961fa57d25bfe4bce110c115ef20a5bf5e806eafdde8213db1cd8ebe455fe4b662fd1711850cfdacecba4d959f67e12eb15de9520cfa4709864ab6689e6e9557dcfb2f7cecb6c70de7495785d58e05adf6aa86f494b92542c594aaf579fd867fd9317047926b9aaad68b9da5b779725f179b66c3869e5efe7705b025dc78d6cc01ad4d70eda77501c94c7f2c6458e3f196872db7302d383f3d27c48a212926275560a37bbab43af83ba7691d6a88c29090b3720599601bad6c59e319cd8f17adb20de359c76416780bdd23b005b310fd001d1a2ea593667f2415c947c3e70277e8782df26b5687602be1560aef0f9291388215a22d42a637157d196ff1a0d789f87cc383c80529f0da0c5c21b1475c22663bf873d5b2ba02f7faccd1747c5f567110727ac1a9fa48857b22743db73c2c4db2a922f8773a8f5b7c3746e289e00e2228efd695d460cbc6831b292027d0b1c9b3282616b19327fe14e960fa638213eaf0e7ea69cfff62dd125d3be1c0f8b0ccac4c13eece403e4228cf17a589ccf6eb84c721099c588e014831800547b31b44424a0d8c5b5f86de0ed6f42ac770fb36c66f087361d7717db30bcba87a3ac2c7e71cb6b5fe0c8549d952d50ac66a1a02a296539dfb9115bf761a05e2fc7ab6389a21a4ba53a1a46fd48783f804e5e9c723e7a9835969c6f3bdfdbcbb9225ba36aa4963f89920e538adb5c5b7197290775bd491183b5a1355f39422544087b76741bc4bcec07d7ae7f0c49a7416a37f5b3804f92bd3bdc55d9fb6891ee53eec09cbbccae1919f3f479f726978f845109aba71dfb0c2d9db810565eaad9db0af1364db122755e6fac395f5a3c76b5d42ebbcf182fb1bba5b906994e3b8b89118fb1602aebf4c4d1bd5231d0d9de81c1d5f68845bcd6916ecc037256d4aca798dd62e26f88e6885c3c3160e87ed5c44dadfdb4a7d923661e6d71a3ebd0ad6597aa7694d725e105b845b076a3eb2a788e3f5b6b4c4d64d6281c9b0d9c8ce182a04455340f920093c270dc37a172c0721e63b66bef3bb1f194a4ebce8cbfd173eeac36e4703f2d60ff8634e4858d6a66d62d056642a55c6b2ff4b28e9a4b230275c6fc1e536ac2409c99a352eb69be38479d82ebf610f30a2a719d0d795c9241ccbb9f296b0b089cf3b0f637bb2a1b20b5551b46eeb2a355df413daaa9441bf6f4e2d7d6084c32f530d28b94b98bcd5d4b2736e35189bcc8460f36c6963f6ff9135e3043d911f7dab715e5827d8dd76e6a7b119b7242d48241444888007bdbe47e3896424463f4a0cea6375088e5c23c1a0aed4d14d6ec1a3b66cf0756a6242e4553cfbe1d7d0b1067d1b69c942f5e1f358a6428fc5131c94f5f4ee33269f57cdc75ffd6106253f33550524ba3bd94091ff969ce45d81a34a1c4449237569b5f285d2d889dc6f37520a8fa52717b6effea3f077121eb16bfd1ef2aaf62b0f4ce9f0e2c282b5e656d8209db1ba076d73d6a0142c061481a2236977d1c30ae69adbca63569d4caac69b0d5c44433a5db4af0242102161075c6755cfa195e83431e03535067ea512f3287083bae020b34649effaf1ead229a3214dcbffa1695ea2b434bcd7f40b82e59355f4095fdf9f561a7bf0fc7ed6d2f4ff831f75e9202e706a947f09f7e19e8dd37b9685be41a7ca1761774d808898dc5217b126939db01e99456ccdf53f782b3dc1e8d5ff8d0136d4d5ef55eaa62b240e8c46b6125da925956d63c3fe4573a51c714c86b845311292b5c187c4cd428412c372732c7c81f56394ead8897357a1b83e33822635b9ba23b7494219f32f83819244bde02a8715c4cb9a559605f370305a60f9a99d95f41eb1a2603b510820eebde6da6f1c677ae6f775c046967d5b72d87402c2f6f45faca8a787bc16466c6e1d0453925dbab46eaa86351c5c4255ef4b6ef19f0f87db8b778244cd8c8c69ec6f9cd213bcff015a177076c4da2c6e0ed9dc7c56de36755029857628c96b9017892304c45ec671daa35a9c46d170e9fdf37c388f66af968a3d96612928f873cb3316c44845a3c5f42a2549d915270dc8f707fc0be78c1e31e37c9d74fb699e818de1a2ac6190d785a2eb9fd985a17eb5e1cc4afd9feff71d09c99ea5440b06df123a5cb270b9a5f80b9db972cfbf5909c6ecd1260ff79d649692e72a1217e46fa6a062a67eb66934eeefc97084448e0b40832ea88f1f42316528db69114e10571c20a988234db2acf2efcbd635cd60a2db8a53ba5fe9bce6f0225aab27db736ca2e12b573f784a4b965b8f2bb6d00b8e622f0d2f60800a3566ca4a0d978fa0f31ee48fe6ad07e27249aef549eca2903c1c04b31264c29f35fa33044cf58ad2e899bb09ce4d74d9c83fc84242f587680a8a42bd2dcbd5c46bab7e7018a8ec6b06698cf67f63c49fdfbd0455ac6655cfedfc9134c92e61e4fd31ff259705dcc7ae05d28062ead5048d8dc02b30377c09d3cec0008f83ffa0a8fefc76aa58f6f0bf776c7a23d5b61e3cbfc228c7b8617804c08aed8da3b07a8c3da8991cd776657f83aaa04f37e349ae4868b97c4318846550579ce55a10a017c6a959d1d560277619cba4deaaeec3937b85fbd8ca110a37d1f27f84739a3be5ec279f327d3b0d6728402f78966ebe843770fb12ffc888641d86c58c72833f351ade5e02bd4b990ade50f6ef53f54862254ebceeeccf48d25a1c685f1965e751a1754dfd63013db0cbb6a523a2fc6ce5589f66d0d0ca0a9d5c7d93f0997153a30d4d35342e680d25736a50cd7edd75f9a4ac024ac9154ce147d356bd6e8e20e27bfd65bc3d71e8508f2745e7c3d45b0b50e721eefe8434bf6a116e48075a38d7579cfb187cb9600391150bb2d2320b014987dcf52e50a8e2ce9cb48e516950b214416004e6ed54e6f153894384f77f08d038eef368a6e998e7a537cd1f2462b552ced8474a37476ab513eee794bc64ece41e75674628a03c02e4a302bae66c0f7e14eef0cbe9e223966a50ffc90d6a9f85138257d6b39ca10030c70d064beafaee2d5fbedc027d9d64f3cc770d53e47efab5fcb8980aebd74ce92ad7fc1930af200519c09b2001fa31adb733c01752915d791cbd00c2c2a6152ff89dca509271b0e3afe3bc84122d14c331f8356f3ff95676e20a7fb407609686084b72e0ca029a88cac7f848604f4c0441c46dc725e915fd06bece67b3f0e854256e190f3ea98497b13ff5d1ecce8113eb27d1dee8d51f802d01300da67b286a522e3dd7d5a52fe0d186663fa87967131a0bf22ff60595d622d7ee530ee6b37411f53af7c0974e0e1e690a987c52f4a3c9f253830e3c58841f460e16a1760533e27d59c93b42a3d73901a4ffcb75d354da97ada6e78614553170e6758b61d74bbfc296d656f4bcac0ee371e7a7b91e909dd055011f16cfcdb52cab19157081ff27ba04f64ba394ca19f9bc4d4daa83b8daf61b29eb0dcad5f054e2ab475cbdef40e1e8a8964eaa6b458d897dbcf2191c3fb497f70e9664808d99aacbdf8bb524bf8b44c404ae33face4a55dc4e9257ce1838282c18d872c524cf4ebbaff600dfb8f97e24815602cd5e6c9e1d0e7f136ee297c620cb57682a009be6b6f17b1559291bb49dcfd9f9b4adc9ff67eb1a00af254fd9904306bda484191121a81fa3b0eb70a9fe47583d9d9a1ceae89d6e026cbdfb5668aaca8e1c2dd8fd1a48dcc3b8d16385ec867b4950379062a47d1b4ec05a8c981dd3d6d291861b2367870e432a70b02dace5eb386e606ffffccac0de9e4de0e751127dbd36f8024f1282f4dcafdd5722a14d84ca0807006d3fe149b9e0486655c7e7ed34b70e583c5e2e6d7a4cb81d5bee2e531eabec51aa1eb13b64215949cb54ebd51138af5b9c0eebeae47ebf3f2e3a6d0aa602a9b6b4869617fbfa56d98bd8a08b713a7a9412959f34f88e5962cad38703543b3b6db5722b93d9640f67e01e679a2a7ebe05fd1bde18ea4396c4cc341c7d21ec476aa05398f5add43c075daaab3fe1a414697ee8475f9eed3651e47821a7553595bcd7c262ef6f910a796ee63370343777919a6b44b5bc063dcffc68f64712ce5e44410f6b5269b55f7adfb6be48d4bf04b4e7731c3412c228d109a9fc49e379f04406d90562247062a830f3137e0023651b58898fe7a365e80f51f26717025f6d43d64fd42988dfcae5afeab93f326343563aeead56ecd8de83b3cbf821608dc31fe2d2e93a8304c39fa89d1d2440b201d4c62ad228bfe841f1b39f0ba53ab976d0493b7452903df26525d8fcc63ba116b95a415b6c80bc83f7667de77df9ee7fce9b84cf50bc5f2bbb165bf1b88a2a95989ea43e95870a6a899c3289d25a47b4d9d27c82c10c6959f0f47dda85fb3d329d38cc62a56ca53926911b014c5d8a1a9810107d60783b8f2a9e6de384b45354085fb9159525efd9a01087504f8b6aae41ea87990916625212a1df2774e90b384216d674b79d5b3dc7e7310930c51ca83d7fb869e91eb5b8bdc6e2f34e9acf62f2b01f29fc97eca523a283559b59c29f278e17760f2531f8e51dfeb9204fa5459266e4226e5732cc2ad7c3290bbc74d6ca3169202bce57c204a9db96cc9c55231a952f4eea19a8667ec298f4e60d6f1a960da7e4435e54f698f629c8d58bfe44da92b48c875818ba050ee404caf355606d6420edf49e13000e11f90ba35acba2491bf65f6aa05f85864071b4fa79426d26854682eb4c6779e10c488a0193ac24817db7a324176f58f953e18ea6cdd56d323a03def1f7ab1bb174bc5489f3d37a051c7604a998d3a45002b20719e9e9234d92fda4a781482bc7bdb50122afc31281232a8fc58f169f08a8194f7d1f44f0d66eb55917e1f1308734788cead64fe2822a21f8d5999522c5a3b8768d6814a13793c14afaf3ea0c306a0dd360ba48eb5de9b917224bd40da4c39df19bc5adb760d2487961f040b1b0aa41c1a328c531713af01cc2acb6c84c330cf37ab3547bb9b0c5aa94e48a1e8535b1e5768cc09babce4783ae4657972fe74dbdf7d6b6d6855c3b336639629be01c9c36865a9046daf35a41592fd46afe797450948c5afdcfe235f9d3157b0cbcff0a02d0c6c8779096cf099579f0536e0b97ff7c17b015f35bc09daaad5c562245560e394352b3f52184672995e7db447f7dcc0debcc4da7f8cb7aeb3d0ca6ef29e9769f668aad4286b26370668ab551a901d3ff8393db70e4842f94eb80421bb060dd3b2634fb3b58bdfd786347318e8c749e939871bf87a61a2d19b7deb4de0b8e9b6871264dc24e88d2664119ce8bb0c8d9c9e8e902528d474fa1361d8d40078d40ffd84dad25457a1c4b0e03151394a74fd5db74c92a9a46f510f07780f01b849359994500f856bffd48302adf5b6cd392bb58754446236e62c59095d1f9902f6e68d5d9305a5328bafd363b508eaf5e1af3c67c0b3ea7ae0a0da22f9fe7ec83cfa321c738e4a4fe7e3cfde5dac527441f6c24717481c24e3d7fac9bcc74b65919b3d6f9d6be652e168736e32065b86ced32e307f6df58bfcf2f0594133e863062c61816d5f0497db2f6c7ed64fa4a25af44f7591e23065267d0135e963c0daf5da9f6c075bee1a2e7c1c7285a7b628ecc7fdfd542768df2b1bfa4d914248df5cdad2667b9e1094f395c5417a1fd95bbfaba9f157ad6546a000c0335f32397f20b8586afe68acad273a98ed555960fe2e9b31b9748599126cb13bcb7b33e5d36ebc2fbbaa3735aab133a513c4afca767c28ae179f1781307bbfd02b9d93541dac684c8ca1fe95c9797823b77179cbf1bd521db96201e7e7201947cb3203f87d52a169341bbae1c7622f46a1b489f23e18a57798cd6c78ff6b23ac3cb499a3ceaab0acfd69ec548caf381639e29cf916f96b8d275862d13864cb7be0090fff45b61d3d8abff3e2c46de4df29bcafff38e9d6e9a72d8accaf7f81b0876e550eff36144f8d4dfc5064fd5f0510f13ba9bcdd0ce7211e3898ebb37c1a259a8884b2c225503f736e82c3a4c2dd8c9a7833c8edc46bfc2f138403b014826195042a2889f4a9c1a153b02ae3b172473500c0321efbefdb31649fbbcce97be8ea5542e3c1b809a46d73cffaa46328096bd2e1b2459164265190ffd291a137469432f413cc1f40e5d777ecf536ff3f54cc20436db584ac6cad8917dd125d903c94371bd5efbe0623c8631bc02ac3b41f31cb1ebe1fbf22e56256cc330d39faf0674a3430f27ed4803260aa5a0d0d1442e194dbfe80172600ae08567ec6a61fa0af4147527a4b5f25b9f1b6b9d36593447971e89119d449a0830bdab49799cad494279237cf5dacdade9bb1ffa22921e5174282cbf578cb01207c7da031dda2330bc18177e73a487ca02d7334590432ffffa32adc9fa399fd6d3db4330bf475868f53efe778423e7be2fd69f540f70a908d877f7fec2c8908a65b1f6cf7247160ede7a89945897348c7c2780b74e54a207ed97e4140ba595caec3e3d2db8f921ce6bcda1bcf5878dc3cea466c1f5d3e4bea7f8b746926f3f8e8e50401b49020b7a4b89635747d7430a5d63b6e9314376e8feec04dc7f7165ba74b341111a1805259b2276f5926a0b97b393dcd39f4ff63ddc5c8e909d242e7ec943454c1dfd5631d3c3856e4171a916c4239933c67a245980c5d6ef1343584cdb3b4edcbd4b770d0992ed00dbec1456f11327d62a43d506ce2fd4b09670a043b4baea8d043edf4bffbcaadd0d21767dc5214b5a4020dee659df71e924ba358674032f9f8bd1f4889cbecdff74c13d2c11d497c9079a2238be22f5ce54f1fb0cbb534cbf4c5c0fa24115ef47ca1d660c3e51a2a4244a2e4512498c42d7e2f3aa6789fe70d3255e1fef03b20c54d4e8a2f67c5008abc021f8e343c382ab55b9ff9d308fe33381aabc838b6556e162306e743a0eca5d7347806c3cafc5ca455abf111a294958dab4c4760a7a23e22c2927619713acb542ccaee4bc7a41b5a03b43ef23dd778e0b92f7d0e6c520241b5affc5b23569110825dd6d37489a2709942a2123207f0a0d155d13aea09e73e20139c8a39bc6063342e0902f8be70cb09680e6814a0221e260e369e2d87c234d3d6c995acec88a2ab8c8abff7c6de4be25feb15213fa7fd4021caadc4b31d70641f1f338a0e3ac2494b9c8765bec777c8f7d7cdf299381a21a295bd9b8ea33182db9cea5346c6aef89b82114d930f60e1bd3f70ab85207990be1fe437696337c40dfc1a22c7a0eb1e5a554cfebfab304364c42ca5cf56249e651e020fae80f4d9daab2e8bd0e5565c8bde41c28e84e1a285cd290c95f93e7ffd5dd77dc0603dd98e8efb9b8f8f79e825b08a9d62a46652620b80fff85000408ad60459eeefcc6d32afbf48cefed03d663037bab28d1b7a9947c7c591f5b245b17a1042cd2d06f9dc5cf7cc94cd9e21743e25ccc0aef69e44c630e24f7f43ebab03c993a1d9a48f47a9781417fa7462a855754b5ca4d98727ac6a9d169c42da5fee6fe3c1816a6c67f686b6c83f015f7914d54d75654d35153795f417c116b8488cf89867b91dab5df79b3992701241933804c8b531c10ea47b4b1ed44cc8f69a1e0565b990a46204bb5ee46448e1fe6bf44fef2b0fc992b1986d13dcf3abc00ff3d9fe4a0c76a5fa65a903759ee473d6b5d5025228cc166d795c9b1acc54b82ae139d87b8f6546ece5e80fd76c4b12e4caf5e02f4cc3e95df13cf376100f4f4af5b25f2248b46b146ccb1c4b2427c4a5f38d3c9451a4d9b10cf483523b13a9432351528724776fcaf79e05522caaccf4c1e8b7adc55e0e00adf4092588ab9ee15d6b422e21aa222cce52cfb885ad7d889e534035dfbc8c35bc29a0ac92530a7feac9249c1c7817e660aba726875cda2d9afe70b4396ec1776b1868ac1e4a1fbc2f23b7026e7cca6f126fbfbcb3f1f0cba1bb832baa6820881f452629f3c4b68523f7506acbf7543febac63fa4f7717968040a74b49419015bfc7fa370b9bae772ff798838d69fa2f870de4df66f1129d52a88a8e27eaaf7964ee392cd3127b1df7c6c2ce0ebd680673880d71ffe8f2a6ed268277a898dca59fe3a353e051d3e5b5e82de01c4b49e9f0a94322c1162af8104688d1e6d48257b287623e332f7bdaeab8d0c5fe225af6792370a95629c0a0a32cf904b769ea36fca969bd5c6594da931956c43103b58dc2eb6ee16ac376609a130328b4c294f335cf720464e44831c54defd488236fe57166ec9a0cec8c45591130dc4350486397f73744ed30fa35ec54ec8a33a9088cf75ac40384e18118785b0ff40e04a5d7864c3cf7f17e436870665ab69f20da827bcbd9e86bdfa2cd7cf76bc4e739fe6082109a1a7f9b23f612c45834d138fc901bf5bcda9215749b7e373d82b3c0fc6a54c5931458c7ef6f600ba8b334233ec5db979f43d71898bfcfc9737ebd5b76c39afbcbc2382d8fdf6dd74f3425cec97bcfcebbea0c5d4dd52b65d05607d353ccdd9dd26c55ed027a78b0d307c2f12c7825f7b9c35b40e8a2dfe2b7b35cebe02f110d8de2715b4a0ac6fa9a96ded61e9697f1ce1204ef38d2b3a6451096d571b30285748958f438ef0f60798924029d335a12c20166f3b14ddd03e68c39db55179bc86016eccc3500aad0e30a11f821f6ddc596d1f45960b4541324ee9bfedcc6506df9a5d1fae71bfa8d7a53b867b933b181d80ae06504fdf0f2617fea917d7783554656a2279d2d3ce9f754ddec9c0343f67019eb26f7775bb2acff23fa90b5b33feaaef6e187b5090bd0c18556b7439612b0affda9f2671c7697161fc70638fb70655fd6be765082ce2f92af96dbdf80ca0c3ccc9508bf740be48260fbd65979dafa421dc7bf3fa5c6555616dc3eca6db756e13894af0afac9ef5834bc7cfd794cd7962ec64e3762708de43929a85cd1deb962732f34560ceee42a3da93860eb4d525cbb6debbb4536bbe0ac5a49a622bbd1c369c863a675edb8970e030a2ee244b378158351b472dcb55d6696d5ff28ff4af5f340df58ac599a7d08bdc23e70b1b0f5925d8b9b96e1c01204aa63cd2d2c8cfd3293ea0bf9b7b57a4c5efcfdc1503eb135c36b9ea27340b9caba6987cf3f47c7f2b2b8f818179c8e42b946334592ce80d84c49203461065976909841310367f5ec02508d0504a9f8fb93a215920df7196adfc2f00c556aba25214063632576ec99a03e9c08e3f23ef627288144d5fc5f0881a072995067eff9878313427f1bb400c80a799d5424236692eb333284408e2d85a713f5af824af47e72a1bc6ef1832d88ff9b64dad3f967468c39710da8d2ba05259d20ee2b578b72566699a31d8e4fa4f9b83026e57fb7902e30d4ddf0ea0f251d2211ccaf04a54b165cd7e5bb639d0ea6d07ea766c58e1218ba137d663ef6e84d6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
