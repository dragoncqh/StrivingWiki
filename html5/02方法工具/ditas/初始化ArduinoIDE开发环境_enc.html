<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"025f709dbaa5eaa814b207556fbbc5348ffd2d68cca029c8b3e52f24bcb5d537ad537e7a02b4da785190392e7773944b8e9b52ed2d793f526d88cd2645b7027b80c0126658a962be856d9ca3b3ef8823b9ce3e5e5ae1d52b2cf71f10fabf3e6d311dcd79a8215dbbfed98a86f3c02d91df439ecf3614f60cebb6d69f63fcf7e268687edd41dad021ad5ee5359827fa2797c88e55bd6f2e5189766ab8c8e9e420e5e23d2b81e40fd7d37ab8d35051befa3657c60b24f6817b95c2a81bce68db0e41e4b8e2dddc70c36b3c5d9ee578e84d2d269e70625360693d04fc4e8c976efdff4e610c375cb52d5b293c3a45eee3a7ced876f2f02f02269898825ff5ddee9b8b5e434ca0ae25970d88378ab6f2a9d0af1a78994d64fedbecb68f55f87e55090d846fe28f34b41102300aff1b0a6d5bcd532f76eb12541e464d006173d509b3a7f98946f62dee7a4d49a4ce40f8eb01c51655fd475b680370262ac40c881d32ada89b4e5b24664251d6642411da5a5aee9d903f802ab81c3187c3e9f657ea4215c44ed8952d768cae18ad1e77912f115d9d02a6c384fde7fcd2d4058eea23920e936b42ba5bfda7fcbbce3bc94de3e645966b199edad8c01ba8975825c2ce58850bc218a8c8d096551e979eecce3f8702a61332619d63c97c701e97f1a388ea7e2cc035deabc276e3e88dc87152c831e38605baa35c83b3a480b41d0638714843ae91b98a2cb23ba780eb5cb246c5839b7ba264393085c2660d406571b8e34732c05c03f72a8b9454d94831421fd3dae5978c695ea5123ed98fe98da3f3211ed2dfe796f2ad1a72adb27c0de23cb31d0a8cfd63fe8ab55f2a7095f889b806732ea5c37c51ea4d71aefb5dabee5faf3fa927c78d73ef94b0c0e3e19d89b01636029356978cfab9be00450e83f327defa89db94bd2c1632228f2d587294a987c46e09a99343e2b49392eb91bdf43966f0d20f8f13b222e14e59e3fa45488e65ab38918eec830477aa490143ecd7d29977cb44948963ca0d1de5d987d857a4f83579d9bc682d5a066acd8546bfed2d9c55fa9864df3c7c4ae5d1389a7c57166f661f11c34e588ff163e36bbc955160c2c31a5206faf2968d77f4270921c4cd26e1ad1e9ceef1ef29a02afd8b10fba5acefbb2cb31f326e9a1fdaf5056a54a9eb5323b60ccb5e9a07653221685f3e11d360481e5285478e31cd0258fb64f084d5b304c4d11a6d92141858a4003f98bcb5e280498db642b4f290a0fe932b65ffe818e475fced10b9e754f7ca3aa99d35793e0af56c65ffc32c8a8eac028a13af23253273e30cc5b30deeb4527a7e9483ef9666b6e745f12b341576b6fda29742ba6a26f8547f720456524b100ea10129eea6266f08b47fe800650e71f0f7030a07130b9ea9f46c7b8f643a5489339d3ff1177256822052c3a96c59c70c12814055da50622966bcb51ebd7d1fc7f83a117ac5ea5330bb5555eef8ad1c7f3bd57a487d6d21298dcf99a94ea5384b22c08823bf32c2a4d155a88c4cf001869b87ea1a1188163d7f6dfdfcf33bfe968c3af3eb8064c70dd117d0f6bcca594c948b1852369a4da1d4fc51b285b0b1c2616ae56876e79cede093a2c64547e97ef49b66ccbf8e9dd5e3fb361f7bd269fbf6a3936bb63f0f2640042f497980b126eccadb1e7f8c4b89f1db18f6e41c3bd4d7758916bceed74f4f14c5e473ced498e960478df8dd7b6cf2dc8fc07bc02ce28dacf48c65b198ccbfb9df5789c735d6ea88a1176beb939fe006d0ffbe53482fcd998b57e9bbc9b81580e790f67804beb8378eaa7460ce12bbe9075b3e5e10faf6934cbdd74da46fcad879e1e36cf2807532b13430120baffcc29bc2fc36fab785a87f82c07c5ef9815bf3c67c198d9deeb8c230bd6d25b24d985040d7bdd72aa57f2cb7a5c457b96b6820c3b6e830c02ea55ced36e519bfe1390db787502a0babc1900915fec260c99733980721d34e7c996622d60b68f689f9840857206594d0be91e89bfdaea81e9959f90721b2cb838898b28aaab0cee25a1cc01d05967007b78cf143ceb27eb53502237c20c9ca2c3260df5d4afe8c18867dd4a695011331d4f8a7d9085bdad6ab3e1c5cc11a5da04a38ecef0a6c5dac011e9ef6e86d1c6887c9d200b8e87a1492de315cd2c3c2ad821bb48c0783f115700e5582a6762c3d52a17d26177a55b819c26964fbe1ce751e2d8ff36d08a4238f9dc7b9fd04633b1763ec15730d69ae268da6c93989cb877b74d8e4fba244b7b9392e68774c4b633e5fdd1b13f0834024e30f076bc31bbaf5210d7696a711650c86ccf2fc4e9c5a32e52dbdd5c0f524237060493f7e15651b0431fd17a34c32c9e4a8636eda8c07522e170f0c4f21aaf19fd4e1c932544e26eac472ac47ec951efd01ce171e26111ae15c85a43aacc8d0bcf648dfe6e7e53d169372ef7f3c3cfb41e5a511e419c4c61b71e2cf05a7083d2ca52bd9e25278a38ec1b8c6675ee22933f96735104ba1267c555d7e5bda04c8ed50e54a843de38e1ee45fe3d02d8e50e35393d2e6e9f2e96a2a5326127fe6fa1157143ac28cba138e63ca034c8fc8d2e5121d7e2cd4630188eeb110c74a995a74446426bdaf12ca23887123276f428b43bb9f2e486f20c4c95c4c170e4fe8d40a2ea016c15e6eb06297fa47f47145585aaa9ea90f91b425df73d4375bc2f12dceedc71830105fca45924bcc44d1e8dbf48b5049f79b97b834ce29e29eb83f5d74d87049769266a7e91df7cac4f7f99167da092ffaeebce723f94bd3dd6a81f21ab99d1144449630d5f8ff94298bde30891fc52c1a821121a37cc6eefb0886bd1b644721bd38ec3c41ba616fe5d887b91363eb02580491653ce37d9d4cdb6a77ec7c412a52e3832c535911c912e74ce84f3e2edb975b7305101c6f5d7abf9b3c531b2366e8aed185366e92d973704b00c366a2ccbe73726b286fb9960260bc719cca22c30e096c0ab0b152f667373e3d42a28b4e2b2faa9be0eb11ede9175c8ae476ef99b894cdc80c1a3ef8790765d3a48d0e5990801c0769f4092d7a03f76fd901f2ee81fea06088e869b3042f25c575cb0615dd2d537d6f077939548c534d9407357edc536538e6b27bfa64f2220b916dc8f49c2971a147d112625f55930d8594b6161e32fb361304530db7030cbcae4205d3caa66474519815ffcf9986e5fa753d3bdb3ac4dc2a308a947a9a5eee22b3634799aaca6e1cef8c3508975798d7a1c288c47b2ad8647bf862fb15df3bc900fbb95219804e8f0eddc091a9304c1851f6f95833b5388a1c674febc9df70f506a0611195f598c1b98af605e1f994a5c02567c2065ab25b7da8768e74f10499fbf86d64594c2d0a92ad6965cba8af0a53bb6a30d06b43d7a6ad5bad82685779dfda39d92c528d6c62bc26525ac3155fedd20357ba8f5b2235ad3099b8730b370f54c781c72e754465398ec335cc6dd8e1558f7b1514869d3517903b90f7c3e3733987b3f478b0b9ef63dfaaef6cb9a32a53e13b60d73cd4bccabb495c00e0199b27f0ba70dfa238f02a964acb4c0ced08e447fd735eb783a0a01d8023efa9c5b99658c06b7df758fc20e7278b5b8f9c98b9c33113db1496da86740193289acbcf16b8f00f400e649ead908d3e81b98701232e35caeda4ead5cb6678df061764066aae2b92e7fa6f36f1f67275407c723664211056ee472a98e21cfb9690762e110033f8c17677f578b42a2371b4e784bb07850070d253d104ed7c725e2bf5f97b8350476993ee94e43ddee1f0a951c35d48fe41a8644782b1fe319527d3f98445fda178bf1a457bb4dd162f379a14e075fc2330b93cbc24f1c8df1dd1a5696d72027686f997501487ff60d2731f9e5d5e38e5e0ae3503e0c87a1ac201c86e6cbf02c892611558931ba0257441870c035a5fd01f0820f7ca93c2c61b866830d5d4fb3ac911dfb025e8cc970872a4f5fe0b4ea2317f039bb9dc6625e00df986eca144619b74a0e61d4a18d8782e5188c686738df8cc29506e5aad340465393947b4deeb65ee7dd6e4b53d08ae20144100884df1840c59457cf0b31bc76095f2980442aaa4194e85778b10a2ece386fc92f1237ee7e42dac78dc69d78795579d11d4606c40b33e0344945ccba5aed812053e7f63c0b986379331f5fe456a40720527507b0bb22c462e1e759d7a9755c7ddb7add5aabe7c880568a14cd6d1a6179db277d5b7685f05fedd4e8206412e2957a6baadc3c0e7ac3c3e25a8ff799718741fe89cc78a652b106a92917a021ba1ac3304bffabc2ff6a6b73d5e8c63b3ba36410f6ceda0eed66fa6cfa1651ab104c9df50cb2b97065caff22f8c454e9918efda7d2824398e0bee923156807677a9a321972845bd14ee9d933756604bd6a56139ede371c2cceabc36108c6284afbb60a9036d4c283bd602fe6c3501ff744da4ee5cc3e69b21d70597cd27513b3361816a82c399069206e3c6f4077b04de0a99e5735c23f27722d8b81fd13a953c60c5b7c25ed1f9dd2900dfc5130d907c25baa4e4bc688eb04b91eef8b4ec59f9653c8881cd3e6c1706b783ddc20e59467a584595f03860d257d22072c20f05497ca1ce3304ef269634fa1e24b897e8ead9e04d1067953afe62e9cd6cf7ab8d7fa3ae68bb19feadb84c91154868c4c882772bcfaf79ec74614d73492e06bde88af7da311fb16d307bdbf564c8ea94362f65f240c207d2389f75f52b60bfe026294d3c2e4207565c20e8297273677872d7b114b8c283b00ff2011a54acc75070d9db125c635c3532b709bf5f280f01351f9d18701964ef6a93c3cb5bd32e1927749de4bfcc7880f84ab66e01a059c86ef38782ae0ea7c0ec2ebbb49daca1e2543edaf1af0af9e48bdbecea95f6000de4918b6c61ef44818ea17b4854350712192c44fd58bd97207228c46e8c4a1061e439fce1e374debad686834bd32ae600c26ead911620a9b650a174a229795954865bbc43ca005b25bfe34d786b279fb2c0ab1faa4410332840cf96e41b4c7ae95e6599398f801f67ecffc224f5161971682b76811bd120733c224c45bdcfe0838954e5a3b57f3a369c5298c24a7629bef45a836e636a541dfc8992ba8f5aca0c43a5b3ecc8ec5c46690ae237b014bd8d9b05833b8ce908c693186100ba2940beeb56a754bc246a4cd6728a3420022d7821cd370530b33735d28f642d515af079d6d68c5d85f7ec983005d37d73e024ea8a3fc74fba9706b83fb22b95e99e9a4e3aa78c04abb4de3ee4b8216fe1cf99b786017f6ae6c82032f3217a6badf5fc64c9940a167992d1086c7df3ab1104fa078184df4cfb599553f53d7aeb43d1c7a4b713d0af04a5334a651f571002d516baeae4f89198dbaa5ab2f2330258dd1c23323c5baca6047b1dac12496283caa6189d657fb5723c2e4e48af90b96fcbb010aa9d4dd7594f2e98a75d3642a2a7242cc0e3b9af887c82d0ad3a07dd8c960b560e04043b3890ef5d264555b913a123eb20d3999925132f2540a80cd39be4b30050a81d32b8f208ab0eaac647149e5528e0b3881d39d058e07adaabfc3249e442e94108a0d98e49e257c65d9205348c4edd7de5ef7d375eb36b420b74ba6f4c8a458f7bda4694ce33615a2a0a7f4c45d5e7ef89bc847e65426f75d05ab0c2d74fa5e35d5e9ebfd6aa854cd7b10209b11dddbbc6de5ccae88b1dfefb93504ff6e3d38bc45243fbd56b5d51e40acdbfcc40dc36ae6ceefaef8e237b14571c57cddcf179cb091e24fc454e14cae51fbfe1f8d69aeea0ea079d990fb4259297b24e2d272ee738b27b49104b913de9bdf3ba95703161eebd916c866fccab54248852b822a20872f569a5a9abeabcce955c6a39cc6a0a1039b44b6bf6480ad9adbd917c420c6a0f46320adee363f02280b7a9e86457b7a15e3b6b040892d88e214fbbbcbb4064ee9d469d65569f55c1350dbfdb09f87b24c0ea6ac6d85569242d8b16e062571a077d9a1ab1d46301de2ac2e61c5011f295ac1803a72af7027348ed6c27fb174b8e5af408372c30c4f418dcf41c68482ebb0566814bfa5811dc05e10731c6e5f4d9d741af7d4754d8dab07bd54af7a3ad7b285d21d73860cef39649df6fe1bcb3a354d65f1b74ff949dc21d0cc943c43e3856d22d41bc7c1ff9ae6767a4911b3a8486acf535dd9d3f105be7c1802ddbe839f1cdfe11bcc2246f8c1a01cf1a9413304e1af0951241b7ced617905b0742017f4d422f94ef7b831451c7dad63efbe00d25aef45fb292f8385a1f0dac9cc8f65b4b2fee9ce23539b1e2f08ea20b4eb3e2213a785b1b437e0a7e7d320017ba0c9ffc500eec4733061039597705770cf2931c0a001051c4841a8fb0527a7c42f1a45c3e19be71d03ec7e9ed7df8ef36a151af93b55d1c60d58025058d82e1c00f1756b3b85bcaf5147ca7f1e256ad965c98077202f5476bc7c81ac78ae37164b9d205b26e9f611c627d5c8412301bcfabd0995fb6357204aab50841209ff60a08f14efe7e43986eba8627f961ef80b5f81d34f0874ca0d6b79101cf5a66807cfdf53787f4e5cd877dbfa48f8241a9197314ab7ee9afd4efd357c02f670ab08d0a970cf26c085d2c3e54d9effd4c5e7b784f8a8a1f19e6622da8611b13efd72798612b0d412f4e748024e96323fe48f0138efa896ed88dfb6dfab6556287da60ec7989c28b337cdabf09fc8b9b9b5cb372a41557170248132a03242e8b670b90d8f31228aa749cd68df75bec8149f294a8419f8e2a0130f6e7bd52fa0642ae6d170f3e816988d2fc30ba0d98d3a5fee6d00443335cc3d95a7be171408f811245331002ef44655fc50675de3be7fd0f340af9db22683bff334a6279c7c86b1d278bba46845c982ae6674c65c6afb1915630fb67d5377c1e5df2bb830a0027d0e3802d789b1920865b82aa7a871a5936ff8520648670b1c6aea32c5482d8d0d77c3cbbee833ab55cff8abe9d50bf6d3d40a8def065dd8efb048a4eee78d5639509200d132f17c8b71cc856267d87a15d6506459ac0af07b0b19f97525067536dace24e09c1b5c296356bb86b32660eecd1b42542724fbaa0607318dbdd15cb3bde201286ba063f02156fc67a086dcb4e0cdfa1df7062013f4d7a89b06dafb9e7812d27a3d3b4e261c79a7147b479a4addf7d3979330a2db3671408bafc3945d52de3c223cfa2f5af4dad516fd8db45a9be5b22474a63d3ed7cacbe7929cd31d53d176518a9f8c2df3b54b55438b2a4e93b4f40a260ccc8b2622e551b8ac7d0f0ee602d2c4ce57616506de2e0a348730a1e6281fc1d4067de19b805a4ff7271074865a0a09627044c4c52f3fdc986846e890c4223e5e06d1d7aca06fb780a4f9e26b56f978e376b5f9645c69d5ade69b52e56a0238a00e2ba715e93b6756b08c38064d720c3b522bfe2d531b3979603da9a39f7dfdc48a5894d366e2fb7f018937197cf54c39667d71c42d09353a53f4eb6bcfd423fd10f58f37c458cfed0911109f94c36c5f6c6fbb3e84ceb9af7fc0e7a411caac6d934694756f5accf284555af1351cc1d5da45b23205e0154b3a737eb21b627d256fa83706b1420b4d39f4bf24368c28b962e84b2c6b4b54b0f36f553eec7544d3112827b7e72e15ae1d39a8005345edb4852ccd98887979e624b9f63d3f8320732b82499d55368326ead652321c06f1ec5b3c207e6a93865a54f1206af998e151a2aa799e135ec7fdf39f2d5b0f479000b11d5ca13f779013411654ea5f5e2897f433b49fffc533121db72cd6e1ef1ef3bec0a9aa702d25696ad2a61a41946ca64618eb412c783eb4ef2dd3722081142a160054fe18c69ddf624694cc2d8c60c6f4b8359ed085764621f5ab0ab124dbb97ba7441fd3c47593da90dcec5bb1ab4e1d3a97971265026d0d12bdf686d759b91697048971fcdb94da0b1b53860c71745f3de44b1c367171ac00b0febb70a0b6e0436227a0785f609555c642ceb0dd584e5228370b4fc06dbfc50ef4dc9e5a422f50bb7ec764f8934708c03e7d0309768376ad3dd5083848d7bc984f8903ca4b42da0318ff801777d95c3220c6ecc513df83b1d13e01a5f83081f0f3bf571e4823e7171c012083e3a23be267a83d7e995b2bfb6b31548c5d73fa7005fbd86384c4927c3d2c9ad11195153ef346a0f2ccc1591ccdab8e1b8e1e86cb9a2c5b5517d3d113b8e451837374224ff6ad35fd315f2d4bac1529fca7ef9ed73f4ff6a7100fbedf6aca6c7b19a966c3908b9ee159ba7720448c7519fae02e8892dca8095d53fc1f0a5b1f678272c41b73214e72311d4f9176f758ffeca29406e530f762ee575205b7ac694b594e54583af72363b8f1c3246e063bf1053b9932475c84ebe7a397d4e3f715790015a08ceb3c47755d582967d46a6ac565794670273b975b28623a60900fbd6221b22a2e2ae30e23ff6910b48e3d21a5401894bc0d050af0c308e1af82fcd82c5de114a94193ceb9333ce13e7dd942cfe4313f110183166daa2b14a53087e62eb9dcbba7e3c22f18176242d7620d3267c0a888313b84afd0c7d695f36e1c2fe876ad03a463655ce524b61c914fa1f33d82770997e6a1ab4ffc072209c90172c429a6b7d138303055ffa5ead42b514603344c8323473485cc3839aace8aedc9891413f49ee15481ecdc9641f4fa6a405ee057b88a4c3637cd68e3359d7063cb9f1160f2cc917304e992d649d2c751ca1fcb9a0a5e7a2b2fdf5200226c673344fb6f37937b8e2aa250a664c272c893d0d7f2f3c2dc07f68c530edc188b81ad7394bbcdead9c4a92fb632d59d021ac25c777b20d60569f827c3917144666ec27aae26c1363ebecd68a6b60c517fd70903ca9f636031787a026f8d76f0a97f0fd7b7b02335516993815fe94ff81998a0f8e2c3870ea629176bd3ddb29f43c8e7282eff7e30f28482726059ecdfa6cc1e45d2b0af8c46fa2c7b47c53c491ded83dce5abb445c07719466882e420a7f21b8d80f61909ac1b8b64cf95c68440cea3e9ab65b30f2788700939610357cb11689234d11f0510d76d3bf92e304c0921891d55379ef3c242791fe3f0269b8c29d375ad1b8129bcdeb218626ca7afdf4a3c717b5d1a816aabb163c0fc55bd15cff6cad5a001e8cd617ac9c7307c82b0ba2761dc65fcd437b33335c69aacda1852e7d05a1fbc948b54c061a8e26e9ca1072753d24787b7aefc5d30a0e69ee4df653fa483142b2388eb6c187147770e575d45709fdd795f5182288be7e2b675bc64bc8321d8ffb87a15c9a33b0de24094752a9c97f4940fb0eccd2fce9f4dac72edc87c5aa88edcec2875800fbd20a83b75bec045624e9c42417989426741bd6808e354a3dc0aed6afa963dff5a561d02965489f8cc05b39ebc0d31f929b07397db7460ab796e59c734b0ebb50d6939b35205c1d2631c4f55f48da5b2f7c9970d313a12f6a3a8ffc5fc1c97bbca77f89a0848808a6334f0bca01290fc2ad1e11374b2f4814d3af8d618d81fb95c9ea687e5e827b00f59199ed5e01e42b2b05c1985ee371ff7779e4fc0028318caa7878ae80ac59cdd0c99a80d6625f0c2fd95f027fbec599e86fd89d58016a6adb942e3f29dbf2afad58308a940507e266bde4fc5c6a65d6777c36f059d5e1ad0272056befcac122f594c6eff38a2802450d044ab9f1abc89c260f49c64b65c9db16b522ffd6d00671f44cf25e26db15a0219870db9eaef5de06b95c6e67f5fa9378d64978fa7ce2c2f506e4eeda3fc4bf7060998fb702bf30b1da2e811721197643e3a0c965beff4d75ae2476cac7940a1544c4eb31b3e97c871a09ffb45ff78f131d5f2af9c8d77cab4a83badc820b40d3af3b68df6d363f2c611d1b251040f910ec6a4c8a202dba178fef0636d5695615aa7886219f861b06581561ec3561182fdbfb2198f6bafb3a068845d1c5b0a06d7c5c938af2c995f898c2f59f4839521c4ab3f1a34e564462320e107fffb81545394295d2444a0cd5721d14d08820320ff45ae51795f76dc36d401e158c08b67a9557aeca349d09d9f6974379357ac86d801cd002150358af524c814d790e3cc7e1bc180370e836fc7b50d513e24eeb573d88f85d9981acf62e2173b48f831add3c5bf072fc10c1d2aa2daf2549afcb9b2829baff5efce887a99a26deb8f5a2153217e8930841794b32b8b89ca59f85b7cf0c195157e8125701f348bdc7898177eef4091e06aeabb3c3ef5e05cbbfec5a13e26a5f9bae855e4061b83f613d9351d8847f127834316a6246d35fe8166c8d5e4e8c1df6195eecf853e25cfc515950433965cbe21170e6c1fd5bfb6949bfa3dae3e66c903da38ec2e663fce34b7964107c62fe957045ebd9faefeaadc2e8498f57c63ceee5cdb8280da6d72a771727d13f4171e5bd0f65ccd131bffb6303b7c6267cfe5f398d319a920968d2e9ad8c773de506e6b9e428cd577d7f26b137ad6d1c349e38a387fddd213641fef64a1f91dd214277d39e659793776b09eb7ebce5b5d16a51959ec38434e7d1b020b721f0cff24091a0664c5e1ddef746f44fe0d7829fdb494ff7b1cdd572e7bc961d2873cb96e2e2a7b95ffd679e7a803f62526bd52de8991a39a5904e2577986ec1a11f8f9fe8655c61bbbaf6c6d2a3d8ddf5f5293e42e2fe6a6c2a36e596186ed7ed2e704275c487390f95f87790e32dab450ccc303cf8d9d7501c70012fab384d532431af5a3c560f22c0f7f26cc6374ececf193a22757dffe2a15d91b0633e8ca289eb7cf91227f46d69112ad84e9bfc4fe2ca06c671ca44aad37758a23f5531bf06999ae10e9679968fa427ac96f2c7f902f5ca39f0e1a36b90540761dbcd88f27e91cfc5e84b84c4e158124beb5f018ebe084f019973a7240d6554bb77d75ac7f12dda04d6517acd03fd95ec5e6d9dd616e6f47de174ef6a5ab125723ff24f22a3600d30375138ac38c0261a4c6900a655fbc33d4037ab9f40accdfcfd0592485c653bdfc3d658995ed25e2837f1cc54499b2461521136a3b4ebfe4d621e1edebc0b11e252b283eede1a819b48171711b932f6f7de00559884f571ac4fc93b06685829481d086e4a0674c7cc9a6d563bef30eefd33a9166e0f803a3c4e8c3adc2c7a75f3294bd07f1f8bb985b2af9d43c6cc3732e5b9f33aa6ffafe384537a1b2fda28158780d2128d902703c2a1ee7bfdae2f789a78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
