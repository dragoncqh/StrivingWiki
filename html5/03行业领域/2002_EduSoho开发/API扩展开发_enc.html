<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32977227ebe55c65229b8b3a119cc913a89a922355cb6301ac20ea298428fbb4becaae57211036fc72486c44db2c5010bbfc2bf4e8f8da764785ff83362b0b12c5c5f09321767c5d751abb743a2074fb0086521fca9fb441c36025e13f5811ef2aa2558a7416adc3914dfa15fd8e40215898d1b013996c5b8b1f1d02a84e60e4643771f5921f0a2f0073802071db14937e5a3083967cc6d439f41713c09db2101d77b8df9ba9173debf6d65a9f4ef0617adffb330c4a6245a450d3811c630898ef1447cdeb9132c824619bed9269c4985918715378a4a91f00987ec4c79e4962d30c95fe66444a8a240a489800afd74a8cb5341ac8c04258c013f2c8cf2c05fe705dc2c7ea8af2db71d6f8b49905ec1652176cf3dccbef8bdea4b6887bff8505ebfdc17230bb702717ddc0d87ccb1c1748aae3cd3d58ab921045e0cb3cc43fdc93ac05bebc67db70d30f1f14ffd8d2f4adef2634e20fc4ae538e2f3ec6232f67f409c225a30295eee75d70225baded40ea788a27a8962cb57d192772a9fc0a0c92d8759a6446d4ddb3a328cde52c1da0a077b619786e20a7120fbcf8bdc9b10d7ad157e54be8dc39993be63d7e037407e6425b03ff549c3529530361dbdc808ea504c3bfd60fa56f4843cf3905a1c90d51a2001a3cedfbbe414bf3cfb4afa753c670ad275374dd4f05cdc9b2b32e44a02f804adfced92d1a38be5e7ccfa541cbe56e7d79dde3fc762b51e37a57237033a50805efee12c167ac4cb7a36a7f136e72d7e0c4ce208f78b685aef2ca587b572ffeeff404aef893520b89c56a42bf79e094e77b52254e8e7020a35a1be4a7b857f519909010741b499ac123a3fac659bc594b7a6cc56eee5903907b30353806ab233618f6ceb2793ba6c263065f7d3cde5590949cb0d3b651f5d30ac80482321cf7530a4c667237148f05ee747318760ffc7ce3361f9664f5a50b349aa878f39c6064fb619e5f08f8b9fa070d8ced427209077b428cab97ddf8f370fcdf5e5305fd6c8cd8ee18563c570441d36bac80b512d99cb48597eeb323d622627352a151de307a5f6ce7d3ffaf413fe41819e54a594a9d2027ed1740bfabe6c21e41efc726f99c6aff13c0c7169b8acd8351c419397b60d9a6f0eaa82ab5d885d451f3ec310ae1690dc13e0eeb40f348d43f6a7fc8df3a976becba9951b924e927ac34f23cd6b34ecd63488a360602286afa0f24fe877d213fae57ef491c0bea3138cafe34cf24bb9684c7eca36ea9b1a4fbf02cfc142c279dd42724a21f4714c6cd4945c41a3b1970987d23a6494e641b35c042c8b10f8b1abf05dd182d3ec2987078d48ca8f04196c1747577b30ec829678c4edc87ae754a450d58121921e69bb45030fa248908b1012383a0f76f427bfcc47ad89ce3fae17a3648843afe93c1d98db052aef94ca810e272674a441d56f443acca6a592a60ebd839e7f1e7377bde15cb6955c69edcb04f3f2d43c80c2c1d422bfd6c1b4be593707917a6107dfbb35bc2bd5b50934000b1493db1f024f548402c95c598c81019e17673824635b362311358b11dbc79b53fdb76dec273f46843554c6900127ef9d321e62a55cfabf28d297ebc3e10670a0bf44b5811b008492af6796cf6d626547375c74150d9bc375071a3407e2f0c19084f326acf411982bc3217cee4ae5decae9a942b88fbe8d1eeea8b08c789f73a2064dbc7c47735fe4df83d64d4713f6d1aa07e5fecff8e9db0fe681a7d0fe6b0bbbc412ba30d3a1b7f5ea6b3887de984dbbd366520ee5ff8039baee1e2ed786ab86301dcb802d64ff2f267b76bd66e508317e8e0c4fa9cf646ca48ce9cf4e60e5282f47fc0b5e60c6ceab883610bfbd48a6a9183835714c21527fe8d1f0ac9094f8b4456cf1f4445cfa83e2e3c728eddd751d80076742db158e0756015df297e18d1a4d9e82b54e3b6526fafe3f939289adca71dbd019a9a10de61e11cc31d79ecccfe153dfaa1e09157f61fb73faf889c052adc87b60d4f7fde8bd29f2657ccda630fa81f7680a0aaafe58f3282c05e31ccac6159118135786467c4d4ca263292851693ed8909a66c370d910e25119b68c660872fcc1c9f860114739fee1b69935cc2bb6a8914d755a6d6c15ba053be11c3956448ca0e9e3170402651e7bf4386e2d0edd2ce92a44e4528452166a09ad169a5281e3730567550151d0ede40739e13fa36397246a4d44f113b26667f56ed8fbf5f8678cb70a1dafa19e9ccc4c52853f87db1ec8a277f4f2151aa3c815d22f825420fa09c495da6ea9cd27c4f5fd5a4f18509ccb4a6ca4510c9099716ff6b65b0e7bf995200b8ef9a5e5522cda6905a84db01674d10e3de6055a97bbbcd75f717c6c0ea4279a0511626561d3057aa4497438b9c44e4fd120287027142bccf3d948222f32cd9d0e43fceabdb9605456cbffe6fd2adaeccfc509f1a5f87bac443cb549a27bb8fa04d048e30fac0f2d2c237ba369c71bcd0b14c0960405151dc3046a1fa1309ec3eaf9a5c9bf0afb25e9ce789e028f53e43b3b20051e0027d34802bd47a3904e65cb77e591f8c94d57afd4fdb3de87ca18e97bc3796e383aec0de54e3883a74d6f9a4aab4c4d911f5b30b683143fd8aedc4f36b7fb13162cad8f0cf535845707f829fe9585ec974c30dc2bf6e488e81e64976b6a4c984b4c2942224bc903ab4a50cf507cde6724cb57f2a704a9b60d6e5dcc28059004db33b611e870f5f9b38b2cbed415100c93e1dbfc07b3c542412a53bf2116221fbe7c816e49091f4cd01c3266eb0d3d3f53782e08600066f61dffbfaa1152ea2cce4d8c4cbfc1512b3479dc0efb7a283f552d88b9d1f20a33e1494f0b00e336858fa9fbabb16cfab91171be65c24d6cc23f660e2ac5adc477baeb7d4fe7d33a11eaf8d1ea93a5bdda6527488c41dbad2dc18df73a9b1b5f42d44f5e26e013bd55a22ba78055887a2badf2dc1225fdc0d15124c8dc8299b4d0d7f0eabb06c22e0b4a11853e8cab196d76090ddf799435d7424bbf4ddd299daa25a69adf32f438db5319abcaf8ff4d9f23b4e5233f1036b102a86037c1f54363c392c2863ba1fdd00919d91e42bbd97df9c8405420cfafd1807d3b5eb4883532980302cf6ee6aba861e884a71f9364f93e2ac69ead328cb088230f01e877a569d6c8d2fe28f7f178ac16ad344d3ddc467fb39fc1f07b2be70b6e4eca13645485f033c47d5b9b917d9b1a2fd40df7b4e7f4b20103c08c9eb15c6694cb32046e6f1ffa1d10e95a96c5183249708c37723a558f2492f390f5b958cda992628487ff47bd4f70618bd7e9952e1c1e38d1577912a8c837fe1c5c13698e5889e93e6551778f626c9732e134af8fd058dc2cc4ecae5ab232111c54c16f5c1891561bff6191a339eba33122cf6bab84c0889e0bfe6f8b0653b4034917ee343dc43cc6688c0e1052b1ae4eb0b02537d75cda710a33bc5197659ea1f8bf97ea01bb6066395845b7e35ac3973a786bdab3857f30810a5290a0d5db67426caa2a3b91a3d44c088a4c566753f04c562e41eda70d63d534f08eb107da96d893913bd6e90b21241711eb43639fd45c001b174dd44f378b6a8c0af55252fc773c00ab35abc6c235196abdd527b9be20183f0132b199987429494547264b3e8dc35a91b4339b3ff04192460aba53f36fa30257d55a2ef83353caa9174bcf199f50744b33d9bbafdf28a4ac90052e64554f7797381cf271a8a8fb1e3fa495d61e1f9291373388b912a37dc41d0bf659fe56ddf34b07eee9460c2e4b53b58209eb0ee8f386ac5d592897e4c82f5fd0046028a48cb49b365d5ffd8ac47f41d4be03f06aa1b5b8bc20aea61cb339f9e07eb0520693e4c4cc4de43e13144dbde24fbc49ff0eb13976b0a516fc961db4600d40c89b9aac021c0ff97bcb0f4ac56ab593e719cc8d5fa5f22390fc94e78bfb5e14d67a44d8f6ead8cf22f3f9a65cf65483070b86524af441def19aab59b1f3090183f18ac51e12dcf2fb823bd0024042cd93d67c1ac8e368a6e823839609e559f97a3da8a750d5b5c7dac5da9b9cf98f6106fa7034790f8644ec7429c32f9c216010d44fc46981be6a0c2930672650ad74ad73aea4039fd962bd4a755296a968099f8942660d87d2c652537319919a76c2c77c15860b996217e577e31c395a4070ee48558202932300d43d5000defd46901e07c5c4c4fc02500cbe742f79423fff2f0259313bfed02f6a28265a644e7878518c6bce1325d277428b96b8cef0dd1fca25188848d35a9724b61cf0785301afa6a71e7ada3b6f3fa0a41042634e277cd2551f413bf40fea3785ebe213cd5bc2b0eb3c5953bb9dd6426618a576e06bee5d177e357db866eb64a769c3b35374386020605a9b57949a4f110a45454d3a6a941a5c0c046e024f9ad903f48d50f56b731db4b46ca542a2077ea5cca5a4406ec1de511b6660b4ee72449e5b9821e7a4779df422e8af532d8769b3bf3c342f08fca746ad3a9eafd35b6321f1197d55e9c9de23c452b9c25e3ba08ca72ca887357888e48066347e7af234fc34ba58e74f92f394504c39599d64100b35170c9d35509720725668c3df7b097c865a307a96fdf647603fde7119b92689efab308ab76846a157c0264cb048473f679a355c8f49fce994d3ef8de0c3a73da359fac46edad29939ac6cdbe56455164ca5d9d4db2c451bde5ad75539b2cb8525dde2f30710045b165d77ae1658fe47b142ed8f4ad8854579612b9a4417e0fe4ca3a7cf04ba30c16b9591af9b73966c6d8ddcfc7656e5e2758052e812c861e0899862a5120d84a0749b6081c9aa247d51386f17a1047f15f738d629f26255509630cca1af8aeb4a59e7a974bf76494c5779a8c89db3700c56cbf721edbb792a773ebf623e1ab9c726bd5faaf228e4a591c854ff557bd392e236bda780ebfce85b93334e3d6a1e90c494ab4aee0e359f1a02851f07d9e20baba0b9dc6df50def3796344d28caed48bdbca71f2ac9838e03aeaec7472e047dbde3521aed2b0ed733532ee13549de8663144696c74534f30b969f4f8685bfcf662653269c524f0f64f2560f006c05eb2a21045c5742edc8c8c838617ea3d4ff4d4e19b88a99d129e8ac41259456f804e6843b5b91eafc6a6281e0bde79dce7749ca064a1c237979d9f23d2542939b7b96978e1ea45eb3b692f9ad76166d25456b66c4cf4a0ab807f9d2f8339eb5f2aeccc7ba66119bd3a05b45a3e079875f9c51794d3e04b8f2bdc0b6ffe7e120c1adb3a9799d1714f29f3da3e09fe4154ed84e770e1a4502f557381a2e15550b54778769d775182cb2152ca99ff1ee43fb6b8c6677fc978b8fe3195a007320f67cb52aec8220389a8600a97eeb3f1e69bc7891fb8daa9890c72fa60ebda076e2bbffb48df00ffe9d36f800c7601bb7ffdd8f43c2c220009ec5d6a64e77e2a5d96abb9ca13570a73e7905d709cd16ab2fcecaa9e0908784e3106b97691b0714bafbbe9feab4ede7815915286a91c97a39981e590ee292797161bd6839c4b42192cca0e6529f201d74aad68ee3b147f629947e948817482c92e62a72f8ae6863fdecdb5b3ad6152525b5c2c82bf0d601707f9b057c1accbdfbb0de29ed9f88482482db2e1a9d8a1d2e487eb1a62347da7b916afa34334b9e6d67049a2c20a1c7d2948374016b55b749cb7c76c8315ceda1363b6694e32624ebab117aa6137bd8ea934f4c8c9bd2a24459ad4b33f8a143e1f2c8008979051e89dfa77e7b63f53f81010d4a95b24b840c7cad6098ecac20de784987f290a4fd87306e5303fe6a6746ff9da224efd4d18115608e957a2f9b47844404b5ee3f2ad6c8691936ee851007d59cd0027e9484bd50c7ff9aa095ac5eb4b7618e46e03bcf422a68e650d8698ae059bc365cd654e3c5c82dbf1e111216343a6bc557d7eccd06da707b9894badc1209444d84ebb3b2608df7813f3061c9d10ec2af78e0877d1665fa7d4aa1f0c84d190204560db916912a8aec2b514c4a72f2e6ade9beadd22194d80e45d3eb5fced33337c225e753cf36b8e049d5a3c6f2d44a0b62c0ebbc37e92643b8c597b659bd00dfd620e74df64302a7d005810c71b87c68d29586929e714666ceac4045922a634ddaaa95c3cbac4b011b5f2976b1ad14053afedec4a173a594d2ca94cd19213809b784160b41a1105e25b2da114515223f8a3b89683c67ce075acfc5fcc33f4bda561e393f583b3a2c390efb232cd1cada24a40aff6d9ac25804ddc7965d6ce9e67f9a923f8006c929fef5d1b324aa41f37c5ae0b656fc7deabbfd169788a9d74574f3e3cc57701fac933d8e3c4e94bcd87a315dd51f6b882043f789926ec691df5372332ff195fca407766c7dcba2c5a7c1528330b56c7e4bed45c13dd4c59abe0352d5fec8d8a0e71be1fed5624fd9b540ca01791be16e139c7765930460cdc42b5adea4883cf55c5addaf2f1123d72be6fa9ead135543425aa1e7311fb050af48bf6da696550a4259151c3ef8ef8bda507ef2cb131252fb965d55b485f06d073f5a9c25096e60289dda20931f1f3babbc783a2affc4b3e64cd991d143fbd155abdc26baa7e7407cc06fd32a9614dcdd75b53836fd2d590420ea350e53e026325e11bb8db5c9180cd1f19b549959e5710a8100507d3e63211e93610f4a93c9bd40b48ace4734825ec6297777647c616b933c8fff1a429802614acdbbf3fdcdc53904bac0b9513927d0b501a885d9d604badd9f5a528289e1fa61f0cb0e61c61ceb78e10dadd6e6c78dd4fb383838789420526d8661b113a10300dd1d5095ed268d7ebbabd24e1b4cbaa6a5c6c8e4f15cf9121d7163e5d7302fa0248431f121eb517aa28d1cca78dba8c7183dcdba2ca773aa961f54d7b6ab51ed59c04f6998845ab15c16bae4d556a453d136ac4a599676d43f0400d6817a4e5573447da50508bb9152e6f578315b1d5b6a792758857b74ca004d3d36b1faa349e71c906877f62a3f03ac6c0534a41ac31cdd17591345e0da03ae8b5c6f2d3aa87f850822edf57f76d6593127a6cb5dbb5c94d78fe486864948d9b9987c68886cb58fcf75d6091c8600a7cdefa587047d6e98a6a690a269bce46d04a1875b506ab40eef7d5d6706f6b4d4522665296dd9c15bd8fb6dac14610b70ce9f7d83a3d240334b12924aa553bd33593b7a02eb6ec528b3e0b93b7817a1bd2418ae12da40bee162a28e3d9f63e2ef66b2e6c042a7a1ae557793d4740223a5f30ac5de70f019407cef8c8f4934bcab96a07868ba5f85efa12107776b9ed553709357ae3e96e2e0e62d79ea6f5fc103d7b17566872bddc6a0658cbb35e6e666c7c37bc213ae4b37c450fa2153f1de19712db4dd06686ef52144856cb10dca999d1de37ae1a810f7d5be892fdf40f4c3c793fecb963ebfa29e24f9c70d5ce53907eb6e0ea92ca478cbeda4de92a4e6e8cf590ea74dcb227c82797d6ad8e5bf3da9282547f8ee5ccad2ff015ea2a0c1b539b8df98abd21370c8adb3792893df9532fea728407e74c5a435302ea5ba4a3edec5df5758935307d00fc11c237357d132c5342689efcf11263819531c6994ecbaafec3b07ef952d332029a6497f5fc2f51ae99aa89b5e01a190019135b8809ed09c5c8d30d2811750a64863e91e9c1f6222a77995111bca5fd10a54b0e12311ca44007db9f482400261679c6b7234a8df85cc91df02cf317dc0f50534e4862d3277a129f90a3976deab1c4d6d83f39687e074a7aa1c7842494306e43eb0d9606be43f2438f7e09e074f8e740fc2f7caf2cd2ef52fae1e1d338e5ba332d2314a9c707262ed00499315f849a7f93f0909a3fc2c261d9419ec96ff11bd2626a75c11c01e4985c9144137f516acebdf87c226dfa6e98f07927ffc9641fa31dcffa4f765ca59beb29483e19e59c6df09317cf1ee6766675da10a365893066f30e7151bf3d1ebafb59e9a9d9ad1aa8a6d3c53ffdb87e7143d89ea166e13bc53557da774135c93251111cd4bf6a9c3be2c2dd14db55a1677d09969a572c12882ac670715cc0252288154a36a202223334799f7f3f08dba9c3b261c22047bdf88e1f2f0c7a6469e8eca258a966e98467420c1a06892d792c948aa84a3f8a69238a21255fe263ae7a8364ae08c5eb647319eb3fa657df196a20b29309c57a38984be2071ca88b4ddf5da98bac671b9716ea4b4a72459e5989cd98cc0a48229d520f125b3f28ac7c244ff37389dab9c39058478b39547317d843f6ad344eb019d20d17a05432f1866402d955adccced026a98035220f45b16ce0c487173d409f954faa7466bfca155f7440bcfd0f7504a26d56d752bd35fae4f2aec43f76bdb90a93cb128beb4ba5fc8242f94bfc67148afcec51808c7657212a0e497410774aa0478e996599c50f92c42d36cda71b3835cccfb22a86f42c75f823c9dfe54b97c6aa196ac0941719b7d24c9ab32b9077172f4e113e4ee297e667271080179619c3d88f11c46668581b598ae4cbc8371b1d9e1bd0b22f0de07e7450281684e01ca831e4b952c07f5c48677a6d87b75fcdd814edc6cdfe3374f77e000c8a754d0915ff3bf2f1a6d21fcc0cd78eb8e7612838d72ca2e49934d670e1834501a8a898eff9f36ea2295ca6ae5e6b0e24059312199b004c4aab268c77f46d535c385f7dfb7e860019216979e72633f88e675d968ccdd498fb4d3f46ca9feeec100de01debb1a27f5cdcc6f2fca8d201d62182491e8e4910580885978944d71d96be6cdc103b1d5364033d6da5c90f5811682593c7ebf84d3b75d039503e9f6b5acf5be3acf42b1fc98441b57c094cef0eca02b22eab797974725f3e3287581732da57c5d7d27eba1ae480ee1503d0161df5892e7cacec10cc4f900fddf60f8ea659c9977fa46baf4d441b62d2e5c600355e53145c414423a1754c46b55ee71639dcb2afbd54668c9d3e96f111245f52349b06c474bab3588470229d4e7e79fb9ea333727a5fbe9f19a65efdefe94519bd40d53ed706e7e35ebc11e6270a1e61ab5e241876c0e8bd0b3f2647b50ea0be974a6d62a2ac41b890a988bffa519a8c96e15ba9a81ab3e410f9e161f17c0e3a501f7b23c16815d6cd17a724d54d252e4363c1d762528cfb414216c5d036cc3d6003d64edc859e819c6c95ed6e1528d8fc0c33693820fe25c9d5d7699f7cab9cbb3a0b0d6322d4966fb5b4d1d77184b4589cacf281f01622b6b35ff0aa2dfda42620f52ed3e41f06b2b357e72caf5d6ef65767e54a94c6bfaca62c254f42e4bc63e825d4ecc227248bd0c7e056c2991764b9f6e06ee85ed4ae883324202d7b11f6431c06755e71eca13271093abab367f054d93636eb0d5c1cb27291454ea1275afc8cec995aacbe69a7f051405de4ffc34cec03c6a6f2f82d95e014a829aae9bab44c9bf547c1c63aa3d9a348c47afc937a319ae6bae855b7cafc41dc96c844c6f87c9683e21af00d965432a55b0c61b3bd4deae10385c56f1bd938ecdb773bf0737b5a21d195c4de498dd9f3f18727ee745e2b865c8978494dec32b94f64a8a3a35d7eec285477602e339d60b4937a1a1c182235d559d0696b10909c5a7e45575fd077f024605b051414dc16bd3f87061106bfe3b38db99873c952a34f318e0d5f1aefda9ce0bff1a3b58cf65883caaa07cdbfe56287c089f7b81507f51d1843b198d4e1af4280d945dfca445eeeb457c267e0c49d75c0b8f49ae4b1832917560a0b1b8063b9e6944709e8a1e7321a2a3cd24cb7fca06b6c1fbcad83defbc0a0e5ccd529510feddbe612056df81fb9dd5f02a120db6ec2f61b52a63a361e044de19ad7dc2179eb659455ae8e97a93ba24ef0145f5185a2db12c6b392752330a2a3084bf5b7ea311e3aa0eaf34dfd3c204f65b712f8be81352d3d44877745c37cf6cd728109d27ef8d8fabcce700f6dca2881a5f6b0915b17269df888dbfc98253ff8a9d046efa978162ac687f74066bd8828a96f297f2579db5dc2eeb37f4d1b3692aeb93a5831da5fede6c0fc02ccd1c3a5c98254b3750549393a6d811a2ab4a93fa5493937e2a70618a5b744deb5da320490af1cd1eeba957d2835a4ef1514f2f30dab65722a5c0eaf8e2f030b14ae7259af2cce8e44eb3ab0b66a31c0b465f9a6ea9bf6162982edaa8c6fac7118eced489574ecf6b2357cb3a171b8e5cbf30b9a6d8957c34dfd85f0d3c399f65a19e71dd562be3183002b1c75481d3904f548423d51f8bcd5d0f3af6995af39cffaf53a5980c32ac995b61e65dc0f3301cdf0596baea29507287c771d56459de0a6a3f5172b36879cea8d495641b37e323f39dde51d67d954c56309080b0d24642b3fd7093627cb46127b0515d104851f143fbc3997ae0f06d094cebf00fe1c0806a3624277a9c1bf655295a7ad18848bf1abbc91f6a3b91c4781fb53a317fd234f3a1f5ca2618b846fddb4770e2c2629cb0f1b9d08c122ef56ce4cca483e326e4d63bfa3ad3f77726748d42793a28d495b2a0e535cf92ffbc7f158391e133daecc3d1e40862150e37287db0bf43aca41a0c222e8e2ca0bef03b18ee7fe943c36753d219a82317b301fa2ac7c61c84081423af5bef104de5e80be68009efaeb1f5543f7ae2f7c32498da93b68c2f635a529c4bf22bfd3ea12b99c552df3738b7fae6c2449b35240e088dce8019432e3c4623b6dec0b856cc2aa61d00d3bef4a555aa7ade880b4f30dd5f61336dffbff6a544e1ae97fedd9c0f164c82a80478686b14f5e068b2ad363935b32360cef53a4d13bb8942fa81158493a4b0c4d669ae5c021f6a37af676238a23eec5bd4a1a8a504dc729a89accb155e4b9682ece62d8e0d5fa67841d3ea11740d3afb42b599ba6194dd4973a05c7d4f2770465acd19fdbbd3e7bde724cf198cd6420799898315f5abaab0537cf478ff864860e8715ddd92b57d691226e3a5fb9dcab25a3dd43b3b4502de740a224f89c868b3f1aa00934a79256baebf6be26e71b5900beef429132286c8b16c4e3974b5a3e5f30f8e6d9cd759b7cd0334aed7344300acb9b17bee9a447c337bf3e52e825680589ae6cbe06bed32f0bd2cdc518de4dae081ea210ed481eaf5c9eb6a9126ee23f5086d926cb3efd2176c43598853ff31ee2dd65c5bc79c74635617db09ea9f764723c755936669bc42dc578f83f3a9a7e7331ead6e0a58e2a67043a3859c5f636533850482bdaf7b7ef68b0fda88ac74359b6c962657a1d4ccd603f43adb472206b5e0a201b92515e90198d56ae46715e50fab2a75948e2cc20305406ed6b28d6c45782175b4238f9cec5aaa8f561885c4fb715f763b3ae92ac1dc1a5bdc8008e6fe7b12726bcf944a00e62341fb3d9a61d6441da623ae946f90fc5f2ea6811c0d8229cc1e250315a5dbca19d9b5ff9f92d8b779d3f5972290376865f1096304e306bbc44399511ab4399a053c191ef1601469352777894c1b6eb43f5a7612bdb0f72ae11e99514f20262161911d4da32c7b3eff550e0ce491f51e24f599fc4b3c94991faea51e0b7ae6070b413a552dceb85d988fc6801c196b4ec4bc2570eadfe3b9f88aac7aa192fd3a2ce2dc999ac4dcc5c79fe40ecd658ce2fb2af2b78d780e3610bd19ea67973580532cf22f2c0a95a77da45e633c5aa811192e396123a445c2e66f77cd08e096e5843fb45ca77afef6b6c2894ab1db1942c371f1fcd072fbe534e74a4abf6299e15e7405cffe0c3457d5b6d6b8be9fa045cfd5bfb876ece59227f546b75d7eb1bbedcae277ca174981c5a16fef974bb58f86e0c3dfa0fbe04fe3eb942fe8e9661df1e1dff1473d1ab321d2e5b1d253da06cc6fd120c2d47539b2474bf29efb7b918753e1f6dd10f46d7531c99cf6e568fd9afc2f3a18deeb61954961a07a074426b0443639a690a7729d6b16955bea2cbbcde1bea132ee49c2298c49ff5278417d10e42955e870d4d3476ce209bfea3bc15a67617ae93dd8c685e72ecae3137058aaf18d13dc0250195e236aec6117d2a3c0b7b476654c63bb281a4dff0c24e460f1271ab5cc5e9a98dfc844a3747a23d003fd46c2db7d2b8ffb14f8f92f9681bef4bae186ad915301147be0f9f8d9fa8aae54474b72cbba508e230241f2f0559b19cb9201a3135e2c877c91e0ded44e96ec8761cc38d6d0db7dd9f78d13cb4e6fcf8aae2ebc37ede9257e5ddf39c011f9f040fd01c059613d3724308c9127116d1cf2f82f9a268288b47eea768263491c91b2d53399993482f15e61fff0a8089921d9bc557e7551b4163daa7a7299c3a1b68981eb66e0d7cb0e2b0dd16553189aff373eb69d3e4fba2ea3c0c706335651e2ea1a0bcfe318bba168365ffaad701ca1d70941be8e19af83d86900e5bc64ec6f6d8595b4037da8ab39b7a7191c1f2227bdd2a10b911373057c4dc9bbdfe1296ea28152f91dd5b1c7d126d3753810eabcd8c240370d42fbc81e098acbd78ce1aa3237e85425c93a79b4cb4b2c7e1421b81cdf2d195e8d3fb030dec07804f423c7e3411cdc49a01b7e5967efdda870b0cba70d07701156e667bed6a8490f02c948edb37c3b544f835fb93a452c2cb99aac6d00d81a4625816acf678793bda642076052ee8d8d434ef7e134dde3f5cf8f2e20537d08cc5d809ef09dfcf008ea612b0bd876240ba11bd391d036b4a30ee01287d16c65fbc75dbc48bb24396659e95a889ff57d3e87646d5149dbec281326a0ca6b97c859ad3024f64cf0a0ac55ad71d51574262e3941dedf911df6cb0f0f171826005b9ecbb78f7123b40b61685e12cd0f0d928f3171f0665453d9d756d7cdd7e1cedaa2422bf5ddfbb8ff52dde3e31c2b847f706495e9239249339c0137a7f735bae1c5e5edeabcfc8922129e370079f9f1e04e2ce640f8199260ee806f8fe10517d2a8ca377491238a338391f5d12062fee57c29c203dc8d466fd8bc9d15838872f902ad872f354b915f2d85050409dc4b331469981d39433b39193a52501b0e2f5d36e86346a3c353d232c99449aa244895e3f12de49702ab62bf243c4a3fa05e19b3cf81f67420d8343e4c16e442c75a0743d2b930da7114eccba34dc9e821407","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
