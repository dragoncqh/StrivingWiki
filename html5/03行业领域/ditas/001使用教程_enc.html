<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17c289e316b30ba57803ff839960a81f0ba50fe7a41b6043d34af08537f9e7d092fb6ba87bab596b59d2d08f0bfb9da381ab5a243fbfdaabedd0d5d7d564e104677c1bcaab5414ede152c00a4483fd7a6e82236548d0fa17b6a93dc017e881dc6ea8ea889cc303d00eb1fc05b4192cbbc41da559972901a20435de297490e732d8062097ea92afe80d0e179579a04865cdbdc49930981f2224ac8744e5abf3f2b73f7c4cdcc1dbd391ef5b19ea8c2e91a888ea6bd34b2da975015d9e42a286215b99b0e396c5825cd2b0a65eef88a0ae6f04606029b57fa7bc3eb6e360362717c88145145c2d73552b466ac38628cec98b0af2ea65e9650bbbc35a2753d9df80ae1fe00cb8f99c39015c927fbd420e4427acb1e660a852823f4e233e9cad33221bb711c11d4e0532a27a846d33b446533015ba0ca632e368641fc3ea639fff5799722b6b281eac3c1d49cd7df8f6393a3126276c127bf5cf00aa3260e7b19f27cae5c771bc53d8dc232745290c6cb369064e9d99bdc92cca1e6cc991766e99fbd1813823ddb06b69895b64c17e1f37697e231ed0678ea96b1e76231d5d869ac2f840f12ec7f868dcccb94d846dfc9d88b4030a6f95c121e82b6c0365df9764693dc41f25cea45328311c62347dee62ce1bbc4915788135060e7b90dc57fcf8b72c3c68437951ffeb179b4c9d4fd978ba7b5c341a1b696856036382f4b69fb9c88f367f894ca500375518fac893d511ff95da407102810faa363ffbd8e9b9a78d5c177ed2e18dbc5e11d8504b5f7c641b1ddfd6f902284b7734321755fb6da3a5cf2606b048c2486b14f0a260f99437cb7beeddd8e9ad13b659176268bf05276c8c1371f44227d104e13a789d7c1c132078dedf27e022cf04e9c21f1c1f91185579e67e2c9bad787ce30333b52d8f252fae8b9cf867ce2a645fb2f80eb82bffa8c3a083e71b533926344b2a6053ff34109d57dfd38027b10981785809ea5734561d5d903f81d53a94e9c69b68093adc7d033a064228530c864986f189429a233c60580b646559a1513b02add4a61e0e06c85d3db6c554f963f889ddbb93c5af1fd9c883d2ae20890862bc342cbd154f03be6009641bb4f5d013ca1c18077926712aa6521ff4f4b5900178aae1fa636eb4b605f1ba0cefcdb75af0d413ca956748e1d052fdfdbc3f11667fc011acbcb0a31f90dfb699a2333f4bafb54e62a466c0f80816dcf3eb02afb1293da71a8cd24dc2a21f7a087411a3b50fc1b42aebff27709621a68eb8f7c409eedf4986f91781b3055c1aeb370f099e3142560d7a40c5979ff48b0614b296b0e5df8965d49b440465e07e3599d06b5e537aabc87bade060cdb7bc2ba8147f74d87f4253376228d0b247edb2e1c61c3be26c945c9405b729a2bde4055f6816f9d9bfb1092e0d7e3894a8248492a071e3e44b63361ae404b6d07359736761d66974846ea2a6e7cb6e0ef32b6c0be769a98094a4cb4f085b779c39245f770db239e35d9f5ef128470dba8eca18a5d009cd73a37a298ffc87e815975fb01239464a8ff63f67f376df772b2ee9ef011b29c9051981ac43aa9abcbc6eedfce3fa01357db5ef8b87a5213fd989edb753cbf92bd8989c5e3b3be170756e7a033d78c5bf8d896b5567fa46bfb7b003177d2392b046002b32abf02e59b42b20e4c482a9dea8ad30b5d026c0cfd887997dbd145cbb592db73cc41d87a4a507f517706a46c89652e2aa0a17cfc18d8ea473bd1cd85b88ed1f7fddb3e91323c1929d2bd4e1fffbbd8ceb2eff88c0020b9e298bcffb0c75729fcbb26aa8d79a6913f68f0727cb58e611195a504520147ddc4dfaee4bace7d378ba59c6fb137fcccb4e3259ca6532c63cccf75ab09157b1903b6cf24e18e4781c3bcebe0bb211b1d005c6c0b766d44b8e55b4962b75cdb6119c380305248932f3df0533818942affe658993c6b8d4eeda518974420a42280c2976161d2081601e04c6d93c2e5d91fc1f73f8f115c002b0ea096d542115a15b9d9e17e92ab7c08453abafb895ee003fab9de3df18156590ad0c0360fa92088547c314d2391b203cbce59828a2365c7c48e9a3ed5cc13cd41853ff6bfaf9f3fbc0bbec459fcdd9c576fdcc9e0faa4a74433fe4e53332a29da1097539b604a3b561f44a2892c5bb3448c2b781309ae19dd6d5966e6b5caca528d39fcb0d5308aeacca9a1c5311f056d6a3a27efb609550bb3533cc90fd7dad3b7c87996460e2b7369258247d08f6cc05ad958296fc4d39facde7631001453ba3ec0efbfebbf7c5aa276da29889b0872f781ec3ebf7e86586b99d514dcad1259f839892db586c54f046d5706b22455843b180ed9895d2a94d88b9ec2690a227d9037cf12d6892d18cf800a95357dd3c97c658514dbef2d50a64503d2220c50ac6dc23811193e9c7b5f524702d84f6f7dcad3f3e4504b3da534a3c76e585264fa478aaacab58fda415dc701abc43862b09f34b16298462d8adcdf8b0d7327439fd79aba3673760403e3cce7a980eb11f0dba0f7b081d5b5c1b3f7572ef89437ec8b0b5dab1de8cfd43a0d857b1f3b49945b53a4982825790b158b774c04f1d884bd833824e0dc4c5bb066c19b88e65962007a89915331326482da504201a219aec59c8d4101c4c13d7acbde04bce252a8d1f1928d220608f7535c7bba5dc17e62e9b9efc8505228a352dea2dd29311614c4d37bae2dd4b688338b537f3880c9b7f78028057fedfd83831eae1c6386785934db580b590c87853bd3db7e9b13c670ad1c1fb9f70bf9f3980f1e3f5846c79574b2c30ee4747a6fd7a12ae31b799334149c9504775137a079df9b93c5696404571a80d206f557ff1c4081448843f1f86001cbe629511601774f5095e76b7af8c783b285433a564841d5af931cf0edaab9c551989462d128824753b94dfc38dd90f67c53bbb147161b356daa7220fe6efe69054ec21736ee2fc0bfb0415d38b4b842228010b9a941ab1070856e4d6ba1e2e06137dd91be1bff7a5c2f4097c91c741e111d114900e049f46d0b12925f6c2788b8105169ed65205356f4aefedffdd1870d8efa61940f6c6d66ea175e8b01188a4f6e8e83a2125e07281074a0f3798110126249fb1dd5a91e51b35fb83c80376f382f9e523461cd441d6a1658ef8a451ebe68e0fca824863709b40dc718437973cba2db3f6289387f995932804e97498cbf98dce1a624bf81e70fa9ab1b637b992e0e9e0bcfff2a1683d447a18acf31ede678f5332e29777bbd0c627c2b4926f39b125755f1b006175af4c4322cefedacf88fd1363641293b61b1d2bcebd690b760dcea4841a3f3758e115a4281b25c6cf7a9efc2d609500ad30a3ef172dc3b24b9d95d94a0df0eb8000174eff3df81d4c3c41d2654914f4c8bd4324283e45ce29ac5c59e30c34734a7fcfd6b7ceafc069294933f12d963d68fb5a1a3e21f9f4e1c3bd6e210d2e82027e77b58da6d4e7638eda0b0e72ca5998fe472c8de75cd7f7088099f258298bd1b0df51f19296cba040e45b103ef518536b8e2900ae85efca811881e07362b68f1d4d7de63a166b8bc014e8d8a21cdf5c7c245864a9e7b57a1ab6e9adad393c7ec5cb4e992e8c55f1cad4edd53cf8c3ca50527e66330ac67ec4c23315e494372eea246d9b4cb590640f4354b1eaa37546f5aad60b643d3b4caf901ec6d87565701dd6d9cade3359b9dbfde5ac7fb073d750003c181341487d0391c5d176f61c31afbf1f678c079b27ca7e5b9342155c3c111743c14c44a864e32e0d97cefdaf30bbd26bdab709095e91e7f51a8d0d01976c69f7831bc0191abc6f9093b4e4fd3b2a09173100246145a3953bc10ad875e303ba6818390197ed796e290042f24e337c0c15ad543d12b874aaeccfbea21967b769f424f49e5e1c9286186724ff4b3826f1443a13602a208341ad0abd87d26fffe1dd3f33655277a3b38833a1a834f71979820b1cba9a7748e5f68f7e17e70055bf539053fe2e2622a2c196094c414fbd49a383d5c34a838764830b2de1135b86d152699886097674a033b1c3b91bc0df31832dac7717942c139e70433259edff72d5582bc4607edbb347c8276e35bca564e28ce503179f56358568686fc605b01d9d6defc2ecf7be53945004b446c94f8d0fdb5990635a5770db72fcc4828d6ef70979ad50c4867cc9b0c3ccae1c915750a631870e954c552b131dc097d68d11938e9d67c6036f1f969a02571b132bb49291c6c432b35518a2f74d694e7177174a727222782262b47651b7f1c1495461c93823a12ec11f06d6f426b1a3cb9b3761cb6926decced8a5667dcfe50483815ad2fc07ad695393d15ba8891394cb1b6076a663bd74f28b75b28081d113d959ef9ae256f0010d840924b3dc0de40a0b9117ccc2b5e29536241cc4b79420d150f329c1bea9989819d792046d1f37664ff6e2b8e04e717c5e225069dd22200e00fc06a3d5559ef55734b39d7264caa988dd8fce19447ec082ebd39a7fe74d9ffa986d2df0c3afc1530c8ece8562cc99c4ef83450561dd6a1b4205ab9b32b9192aeecbbc2b22ea5406c1ae900cdc74dbbf4a63627324bcb80ba95c2ecf4d1f13af8f747f372272ff8d8fd9f51c425a0d87641e1b850a443797da0021fe4fa47075ed9418136dce1c21cb605c28527b8407f4b4d2afd0fe77858624196fc8882edbcd26573e89025158fc20d42dfe05fca0f5b046c20c4a933167fbd0ca40d8a8ce8e7eb80db8b86614f62704b650d3a16b0ed62892511b056364a589640c26d4db25b84593fb975472f19632e6b53e3019de252b118714f46f516b45830a2df81807a89b772c4be92fe127153efc7088e67338450dd002ddf12d8fe174e5b257cadd6df2c03cadd60ecd1210c78efaafb3fc59229ece981834e3ccc8fa20a01e4c77e4c6acd70cd3973034669f53ff3b85dfe77df744a1ede095961264d82e185622df3194bf3f59f33ebc55d2a9a8c9dff48df5d1829684d5c30211f610a2dfdef6b85eaad0fc27bd24499277d03ed2f304650b3c25e7114ad9ce980561974df9be7a9e9680c9b0c19d54bab646d524aa24f18cf69bc4ca91ebcf4865ea204e83fa3c957e73d0039435806cb49a79c2dcc935a3c09c6cf3ce62d709205ff858a71d12385706947065d0869d9029c5f4c1807ce7952b2b31337d2685b48f9ea71d94c1d0e7a5a2769638de26c6ce18a2761296cfe9e9b53259e6a8a259bcd8c33c7f482fca1921541ddb81994d021598b874579b96ca62aae96170a5a57e1aa6ad34b7ce14abae9c71ed8e3a643445e0ae4cf758b2cfea8ec7d695e7a1720f35a52d205618cc7e4fe648edd0d8b8e3acd4b03f41406ce73e97d725d96e75f78fafe8b7128f70a5e086a444314716c09d4757dd2aedb755e8767d331e5940100630c3c31499b10fe60b56d792e1bf524c1ae7049766fc3fd1f955661a8bd3bdf0d20ea6d9fbdceefc8f9adb41a87fc4500a3e33a95f6ac85de71f78d02bfcdb2be42ac252910e3d3ad18ec8c09ec3ec7149f585015754cb93ea0bf0279cb09492e86a1636eb00832ace0641daa051f1da63b82ae6643fdf713bc5938a017753423fd5aad4a384383f81295a440e8074291e05f89061cbc162e3e72b50dc6dabfe6191f9bb92f7b2ec1ddad26499b4e135a29a80cfe57c0ea30dc68f64266490260f41c8ee3687f7f78e4c6253c4b1ba2424b0970dcde4f5846b448fcdd0bd26feedfc86bdd1e9255e02ec6f65719375604a2832f7b14aa9e23704167b740800be681c55ac8396c72237f49bc4838d32b4283218fba0b857b99351685769a523f7aa8befeef0794f01d45509ab4e14fe480810fb40d071ea3e18d1fc9a9bb144df3da9150ffb4748943e77acdffd696f34692670d055007ffb3cf32c15539598815ba7f42210a4c27191f0381b20e865e6f3576b57dfd87685be8fce685057b9485e14f4b8a56e026d42edda2eb34fcf5aa006426c27f14c9b3dbac401155b54ab2d56e98f5f46584c1f43c7e5bf920b5a36975c4ed85e4a3651fe098e777313be8df32070dae160588a5a6be942fff09ee93437262d71f08e436d117256bac06c1c85dcf5beb984b48c7f3407b9622945b1834350def5f2951bdd3f2de7073a68abe81c6866bf56d74a960a572d1bbde90ebc3e1663f81bee178d3d669e4be30a33d7e188ce9b504897245bdc273d308c25fdc5a53ce17dd1e4d19b0c36e94876b77a2bb53b3e9ce7d33baf37f6ddf3783c0d1a6c6f6f824c1de934ec8003038e995eb9c9e59db36562587d8655d1686af02810e8b7eaa02c64c71a78148fefbbc0e3a8fc6e29a681989e4ea4f2c8536ff3f0ff53a0d7b5c35116625505c53c269089bf66c002d158125d310e36fcbba4499034e00cd5cb97efcb23f4e507c8aa439ad4d9481fac8bb202020d1f54fff59df8dc15226619931a956d23571d4d0c89e21eabb8b3050c83300b5861be877d608779e14dd3be152616285e8300ee3d1f04b216af7264b122de1ebfa92d68eefa9ade6c50e748e2acfc854379d534fac157b6ec371705b1f1d8ce06d6d523f319062bb38eec2c505022f8152dbcde474cf16300e22e70e032bdd821cae0cd34972b5e1bef027dedfe2f93e1ef1d1d889f5a7a8977344bc384dcd7dcc26c266fb07500b958ab1292d65a07db1d6dab3f69fdc6583d62c596c674b3648955869ecc3bbc7eeafcc92029346545c1f5627c6a1c56f3e9bb7ea3cc5c8bfb912653ef009ee7a79af4098d46fc1dc544b904fb0aa3fe256d5e9b964a42d6019348ef6610a8c025596aa9222cbe7beabd14d25cd0945fda03fb9da46424dbc0cf1b17a0c51023c3f546deece8e716f7c6d8fcd881cddf78ac00d0cd76b7e6ebb949a7478cae5970741d5c0700ece3e5a4c73c660f98c201276cb6cd0ae5350546c681939315d2d49b8aaf662fadc599eb28356bc1c3f30155ac8083afefdc21e490e5520425c8e7ba0973ad5a082ebd4adca9a14e9114a9109d3ed38e848ddbed3118ea8a783ad0850b377eb472a8e167d992bb2787f53d1b6cc720156c281b257bdb6e1dce322986ec2596eac810e06dbb6dd0613e65e432aa70d5b5063619c37de37f41402df83242145516bdd41fd01b9410a753da3b6bde01b64eac339aae3c0e0eb35ffb916fb0bd5e66f5c8057ba18047b5495be02460fddf384823115858d156170323817d5724c440659a61bb7e91867ee5606b174c2cf2615e53a51eaddd0c99c08d56c2d0abf9ffcf36f325eb08aa650a94424654b193715bb757b631cb27c174fb48eae5ad44f044c64d182223b022d2af445c50464809d92220a9e8dbc819e87e6ed64bea2a8a24fb2c718e743c20bc8103ca7371964695dd0279cd51d5f50245623fce1d69dfce1162e66e62a1a44de948c3597f4c77928a67cf9d657979a639c6b70dab8cb3d721975c00f35a16d09761319d9448e8eb9a5276c38de56e6074798c1c6ae268754c3af159d1981c3f99e65fc550291a98ffd5d0f70fcb2672cfe647e12a5773a5180c51709b7c9bfbea612af5831f0248d7db2f9de19517b0bfa158a0b1fb99d6bcf47fa20c0aaa5f931d7517939ebda7f94ac74852abe029ede3d4cb9f518d93907edc0fb5e15a980fb75555728689de9fcfe16f06ee5d7e93ef9449a4c5c80a41b88cf89fc1aec37c7cf057f4c46954f359e352de6eca0a85474bcdeb389ebed2eb2986fb5e011ee27a9001f85c26b5d847aa1eefc9da0cc85334cf23ad7c9676157c035e234e321ca21da0c55add366b8b2a599f37e0b7c58a94fe978e867c1e4bc3213eacd65640d1a3db12887094e7893fcf220128c16508a15b8bf2c3f3385acfdea2e733e14eb26f4e6d1f85f0c4078dbcadbbe96fe442b35e57402a8ce953bfc3d39612dcdaf5a76d7f4dc07da8b3200e363aa45ac1e04291a3577015355f8eff2ae3add17658d6ccaf17935facbb59b47a7cae43eacc071b0763b92b2cd2e0c4b102af770a99798328d626cec21821759eb3b0c087a11663dec6386e737a5a452802e40c9962746d4ef31dd2fbae1faf7cb45431d91c7320a9e977b357af5c1ff2b3a21d11567dd5fc6640b997382b6f5ff3d41dffeb11491ad672b3835df32d568bf225702abaf29f2fc8f3befd47e214baf90c08b78c4e369e2769cd6b232debd3ae58d696cb71a17216371c09a4bb4fec82834b45d6a638bdb5cdb9e615c02b021d7dab60ce5f874701e7fa8be5641b39a444f39dde033720410e092124041f6808e687d4ca56640e3f7ee84ae70a0be0029ddf5aa73f8c878763a55dec59e5d7717ea8ded00dd19a4985b0ba210a4e51cbdfcf5c6c2188de6b6d7b45d256e388d16fdffd1805ebe4fe9188f691a902630b25bcda2844636765bdb1908540644b7173e9b87049520c5156da517a6ab0eb50b3c71b90624ab2028e208aa09ee3d9432366ae6e2ea59c906cf46be5d6971adcf226d4f976c0fa6d7df9425f0b97d7d33941644b6812e34de06a100947efecfb05ea71c755a82031932760c7d492adf49abe37a124597c6564625a0c83807844632305335b9e15d286fe539310b1a28f93ac35bba584f11d4d85176a07e0d5cd41f09012f1b8ae932e48b309e2144502d22e8b283040c415f2f5c0df5cd96abf6ba8c5625e8831d744e028e5ab38f75c0bebbd1873078702e7a1700eb0bc4ff5e3fd80395e03bf12a8a7afd59a069a9fc31d8ab3e498b98f68121e7dc26a8fa87ffcd4a918c2bf18a8e3e5cd02fb91066be9abecc417a885ab57b9a03b66e7ca05442dd515f5911f7bbfded71312650b78b1f919df330e8fedf9fe7e3e8b04181fe00cad83153ae27c24ead4345f9ac0c07d70fece3abdb15498dc705fd35f661396f16bfcdfa31ff52f9ff78753fe43b99afdf1537379bc97c9f5855167739ed7c2cd7ffd794eda7877a4627bd31da3abbaa3c8ca379d8a9b6a2d99661fb615329c8fc5d73d3c27aac6aeaa791261cf4b539c331e71290c1f92f81b6b8066907b479f2ce6913438fa2074e6924b814c76c673324575f10bac527365e3ef35d124fc5dc6541aacde1596ec5cd7c3b298a0fff9a3c213dd8ca965d811121638ec589312dc7dd922efa4f840d27edd884b1c0ff81ae645b46d8603656b9c7cb3957d7ebd2d50f51e3197b62c80e3cb626946e92b4e05b09e1b80e77de537c79890f2069f73361786861cb3e503ea14177e9f5452872e2db531c47a260be1a35b1c350b6b22eddf8605a9347a85a03bb1e6da84e25660dd8f156bef68aab94eda0915c21c5cf6261eeab8c14e3abce848050fcad2da9837a107a637a5cde27d5d4179219db61639b42084d82e0a9817f7014a3e06b54027eb89ad747f01b63eb90609d3054e7c78dfe9a52c93dc93c2213aafcf0c7879a2dca100c6c20ab83b53528cc8cd6f470fc955d29d1958aebba709b80ea477faac6a9c43402b6843cdb8fc8cc1663cb89e2f9e7ba9aa3d15e0dfec1555e737ce85202c8c4473a1728028eb618c740a4be6ec8acb9cd0ac159e1e278e3a4b0fd9d22a8c02e21f3c6a0c1527a269abb6249618c22f0965037f9c19751cb6dceb18a33fa1d8cc1e83df5701135d976182eda6d35e24c841d035bd62883a21ace8f76f3eb1f3ae56b84f8ad9c459572a7d4e526f5bfa5114ca4978ef4dc6a94360ed1b28ffd12377e0f23a40dddbd1ef1b181a95d768ab750d679be45ce3893eaf4fbd38ed3f95f45fb26824b6649501922181d559c3502ce1c64d1ae01ecf95abd1ff8fc298a9312dd10a4916af07f0d7d8baf1b25e364de95406ee1eabc8277c2ed5b56294cba84251adb24a80704e04df3d32bdfb2355911c1f9abc9b7d90d4cb15f28d2c2c1207f29ab3a06b8a484fa8a9b7f80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
