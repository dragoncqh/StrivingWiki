<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70be9a055665b13a276816377aaab65d120df04ee3813bb0aa7aebe32927ebd4c47d42025fd391251e78b066c474558ef217510ab1836f84f5f9d0d6a0bcbb5a33ca0ac72c01dd06b5904f37fcc1750b651d3b9daab69d6de9b2f10e743dc53b086b7c5ae8e0cddbaa3221cf6636fcb258f36919a2ed265a1ca44f8f651d384b9674af2f1e5680510f90b40c047a07fa58f5e7d5b4b012e7b443c54543a2d6a76c39c98d3b4828b76abaafcebef68070e96ee496c3c890c2816a1f449847d76a02671f1aa2204f0a2f16b15b9079db9ae3bfd680af4c8de6986e042acbb9460971fb25b36f6ec2cf4658cc0f418a0a7c5aa09856dd22a41bb26c4bf62c15f86c2052f3fcd1ff4e6fd55965e34d4e62ff7c3708cce83c0413b3d14a675ed2a5d8b1241e379fe2bb6f413d9980ccb9a9601a38f8367981c07c247650db00cee65b38c2c911fdc42db044bf20110b4ac61a6e7fbd4d84bd5ece583b44200554641167021bf933872e69da3f2af50a99be75b1df444905c9526031372fe1dad862927a9735353a9c5dedb2de6e10ca8d2f909d6da593d088df1312b5c986aa357ed9cf8187a7167b340e39f289a0e011fa6e07e24431674a6db9d224a70c5dd0f83b8ea0821a0a84fe4dc6b77233ce7a8c8dec2f31c2460fe6e89925e009ffc496f0a3df8eb77f882fd8b2826c1c4230bd56db2bf163fb422ea458411d32659a34416d486945a5c1270beaa804cd892ce448597b637b9714e8ab51992ffbdde0c246fc1d6c8582c661b47caf292476e7d989bb40515e790f2f2fac4780b3c48d1d8f376e6730873bce8cfceec001bb7d8b5e35dd814238d737c205513c7f611e8fbbfec19c96cd3838aa92e999e2ec3b1d37224374652d0cc7b1446be60124dcbfff53e86475d981a429b6a9b443baa99c9560aed7dc6fdd22756e6e4380e3ee7e76bc2e2a65ed4e2731bd3c73c3308cff734cc812f920552ba1d31dbd3bad79606adf6dcbbe195db9061fc3260c579fd8b958108f90e6545a768a09243fd054176c9c283d8b069c6413dd19efb1664cba7f075b23e7c21a904637bea09d130dc78d3dff310fc0dd126cc76abb657d765a3e6db5a5d51c3e62192e9b5f6fd16291c0220364b79a689a36678329d7e3449127c74fb6875b59a99aebe1a0e4344f4e6c9e1873ef7a97856c5249ed0c5c45ae22031f3ddaee9ac651d84fa31b023eec4acbadb8936f3b63b9d2f9c915685307d2431e1ff4cf1645208c2a69d4cf974e3b16988b2a07f8c7a194e3b75cba6532d825140f1084926ac76dcf81e79a6e3eea8f06d872a0446cfbf822d3abbec6b2ecaa82a474c17bd219e67132e6039382f9fade3a2a05814afab349120497a4fb36edb3c80d61b236dbf99526acbaeb31b78da070aa0d74235ddbc343589e773592474dd3594565fb89d340b6e8cb05671f817e02d9babe23df37d91277b6623ca3a7b3f6fb2fd88777710d1622274e41f6aaef276ea0731b55e700639c66d6484d3ad5804bb68e22e90f6c6891c2270ad9e16cc4cc66fa90930b62d8bf45983a545fb94df114a643d34baeeb661c34b735c64fc794e52ec0d6400a20e81e0b9d1ccee8a4dcedadb04a3cde2dfdc166f582fa64ed5dd293b1a010c26d8f268120c8f02e9deec1faed84f6a78e0c37f501582fd20abcf79b3e23c58b83d0c4cea4a086b8135bacb7a35d5f286d37ed9fb6fd5e0c53385b98be2630290922b369639e834cd747671da5bc6b2477550598d1673f298d9b56ffd697b456d41df43c2b7b23a943f5a014dcf02a83b01fe28c2593a0fa55091b135d4e0c9d4bd764f6003abb1da541d023596bbfcfd43eafbaace559466ce93ddcb72cce5cca9fd65eb3ce7ec5567f6ac69e7928976b24061ff6b820a663eea1bd510ccc980f4859b60a39aaad7a92c58e0d5c50225a4c1d87b6ef2f66608650644732740afd9e0eab06cefb1322116a3a643b645416af001ccde56b470c1c3fb01ff967cbc08a0078fa45d1ba4ae1c872b5d29a423b2aba94a951ce768243de7e65b6921acb0fcfeee6a4eb82773597255f65d6490fe8c560bff1011882dc3309b6152f95e40735a62609e3b3dc5d41357a7b859ed661919b7b402c61c16814b0e074c79903ad8a1a6b78af87f2c12c8f40776923acc2da654e282eefc9887b8e9e15079f4369f54279302b01937f034977e9439f3336f1e1854f6a293499588ba1cca2b98d3b465692797853c1c3716a4287fed38ea121f99f8924c2810741a2e9ba8f42c48323077a44a417bdc9ba1f1b3248a1b39ffa4f1e2a2e5e42c2002955596f717f244bb09963a83ea4e3ca984899d27fab0c01596b1f395b201a2fcbed40b5fd3cd3442ce3181e6d043a0c470426964ed52bc44568bff305b2edcac6b0345456c8ae7679188cbb691376fe32a3994a1bdd916ebe61b47ed8b054c469f7c3d82180748d55563890ff5e1a2ee2d0829be824f421da3a7eff6f600b51d8415e4f8a03b0aa9bbf588ff59853f26eadfad1939d0e5a137f47398a25b53e9b8434fbb6613427e0f2512ed7239b565f7db99ef0fc941d079953599070fd5d227bc9eee92b23cdc502be4c4a839cb4e4978a7e2e6cad91a6af6878ec3576801635309d85c77ed06633d8fe0f32b845c537da83d6052263111e781c3a00e279511c05b9bee789f622758eef39f022688793ca3b57cca287fd554d106591b5cc906338d895341a215f21da7e337f6bcd5d880b960ede88921d8cc9dc81e5535a9f15f9f193e232eae9ac3609cad7f3f65a8b9108b06711b7793a91dbb5caa2b634e9aa109aed73a965c9e6ab1ad9b9ebfd5cd939dc5848c79c11422fc7eb0caeea38ad79e34a06374d260fe0132a25f46b1719e806f5e3b6ecec5ed4eb3096ddca3bca4b750c23277dcda6f147995c4af794abe7091b2ba9ff05e0e475b95e3ab3fa2bd54e7cbd47a85ed4db3485ee29f28f94c9b6d7c89559d40d807ece9f190a32a46db21052ae5da5372522bc2cac2d25d2438dc48828c5ecee05d1d70d446fce8b06793e594926dc2435abd44dc67ad74d707b74b899efbabb6b894e2961b5361e3ec69152b9aed47034d6831044a560371c63b0cf2533bd8f22da8e1f988782a36b50a866787a97500ada6ac952d337f633a9c3fadc59e184290370a8b10e18578aed1c14765096544cd426e3fd67518bf624422590ca854b156506c48d6c54ab62ff8bcdce7124863a4c028ef2b048c948616881b0c2ea0e244efe881bd20f1aa0bd26d8294709faee5be557b823281cae21c0a76f6ee4a56ab4c28bb36350eb2a808e9a7732bfee02c29721a7e1de6df0a3218a5c07e171e641ff2ea06de8c1b304b44a1f5221df4c4fc0fe14a11aea15160dba82fa45fa7d3278c875f5ebad8514410ba79a9765fcec18c8a38cd7b52a5577fe0d1e42782d59a92a789a411fad8d7582529efb58b01129c5b083cff75231d669094930472107a3b7907c18848e7efa11b3604d1459bb93faa38f70bb8f070490b1a3ed686938c914b0ab624a8b3260fe2b4e091f538175717e26f277cc0f357f9f10302ebce67dea2c0902a6a56cc3d646aeb75302fd8e62fb7ca8337600fabcffb7a07b429c68206d8c32f0b704f531c7b4a9fcf7ed2fd85404b049e2595e11402ec38827f853e470181f51625b7a26d1a2e9849542fd8987a4d7c9e42f4894be448ec853fbb8d4e3216e1c2e2035a772e0bc34ea433e32eff4969562442753810219fe17d2b9b2131b30bf61cf30b440e0dcab417df93c4ed06765cdc5425110c7f6caf75d82257c3018d636db1881b6fb41535cece7a068d3fad1a77b750ec4f97fa8a372bf1fd080ae4ab68af653ad81e47a0a3ccc2169a22892e73cc0ea7fc1aabaa4ac8cbd2fc3850a427d1918c8841e6eb2429b46b4feea7fd5b864ec2641b5c1115c295d8bacbb9d291306978391aa0faaa961f914e0e7ef390b31e535e01e8f26b74c04c973392020765f2ffd957eb890b837181c45010b2061dd9daedb5f7c3370b7edff457d6fa7bf18e8f449f62699a767ff7c6d61fa8304885f74dfb80c818b4ef40ad1c3832c142ef41921bda0094e6e858d2887d89e18a7a004e1e31733db6fddc37af9b5223f3f3b2193738ca4163adf6ed15b2abf8477f5ffcfbc8e4ca2265d280b8ca84581f033d67ade3365ca343f271055a650939db81fd089869ba092646965119479da721d694c6d7e73dac5f55173699289313b5032a8cf8650f7d6d6d6b99d78661c267d557001db20b2bfbe229652218d346a6b91fa5080f5c9038a386778c9b8bd279ab3e003f1e648209dd7e171239ead653016fdc37ccb5a1faaed9d0314c9c95f59417f64c8fa2eeb24f245c6bf3005dde79fd39793ae9871c5bb2a878e6c4fe63ef151681a744f1d7bfe019ad8282c7980b3d4033658f3005d62664e38f8489df99e6e61fc84f6e40512aba9d776841630c2f84b6c517b24afd7af22bb0f5a4d4eba0619053431d018c75a76c9ffc04c9db9e53eec4754ec2c093742e5befc8053a9f50310191989ee815d6af3ac00948c2dcd8fc47bd390aaeae811aa7f6095cf24e682af189d91cdb7ac4ad77421812e4dde94b529148fb18ce11e3fecf5c3ef6b34ba01c6a2de3039b82d0e1de6e6c25921bfc697e291f18e58934ccac2b6c9b549f9bded30cc1883998e04fc53391f8e3b07ad34cd53e820a3f7b04d468e4ed4b5f977b5ef2a7884ceef7c2013b3f2457fa36664d649053eee356256de7bbef4e1ee864d95a05b6a21ab8831de5652a76c381741da25c5885f1ef9542d173670f969a28dd3e07784d371358634bd9cc5230fbe5a86360a8d2df166c3841612cd18fbfb8d35bd348f4e42257c2e99db04f89a9a973dcc5c7c7bbe21b2649cc116ce8ce1b8351cfc296e9e9d5a3fe2f9cc793dd3acfe3cda534077ef8668ca945135cb9bbd59207185e851d6f939a2793153565bb90a23c0b881d2f0e0a7dd0a0c39145516ddafcdaabbd34e01b403ee900bc38e3343030b4c18ef47133dafd48158a32696cbc44fa91abfec2ab9e2ec84281f86a36f8aadb1f79bc649671927bdbeb0f93b6231481e62a43dad0a9d9408f654b2f78c945080be03acc2153b36923e9c2a0a8c1991f6640c0d8c33ab927f0ec667f3766c0c7b5ba9b051be4cd8d3ee0ac94c0bb55c0238b8f6bd6554f5be7931b25856c9d745b708b23f7db6f163207520281d88148196840a51dc0ee787da73515b70294936e4e4dec806c9a7ec01cf6630922ee89dfc21e20ca04b8c5a1bcb7e47853ad98445df7ef229d0e45a91cbc2a32aeca85a8d2234f022362a9b3243b0bc8f5b03efba5c0056d139096a2095e03d4c28ef56daea14bba976e1d1b194aa97a0e201d0aea130d3b70aed07e048ca84b3cd90db5c37ae5856a99aa2be37f5fd25ea3917cae3446ae81405d66daae88825cb15733792405889a6fece00fd39b4d9508e89a5accf46cc63f7908f08789a3cc774f0be0bf257a3ca1d59c51163bd4975fd00727639acd6efb096cccfd01ebd61611e04460d168bb03acd3171c5fdd026dc58084ff451baff4f54430d6e3e59772a9ec1f2ee43cb378b4426482c81bfa99a6ec1c422968c7add1b2ed14a2db0600307bcb863fa3f31ba5c3741a6409cf8b44360698c13601251f757e98b210a602bffcc37086674c082f37b10935d99b3c2a1555904e3741be2c4cb330662070c5fdd5996c966bc42438a5b0d5e9aa12d30b9bc9de5d4005e7778a830f53e6653d2cd56e9b144f5053234739a08d6bd2bb5242838b5ada162699d44f474effc79ec79bf0d3876c2426dbd2a7796b07cfe3d71be74b63658712f7c1d03e6eab4f63d6770c847e873618142ae925882043dddab000ddadd2f01d042982d95c168b55b7c157bbdc407150ae2b87c84d3251c7d578034d6022dceb9ddeaf95f7b4e80e8ca40d31b66cc683d94beeec28d73b5c58d9b1898851dc2d1a0439d6173a70502ec8f7194f3332b82dc640f46e7d8fb400289a500b49189e85074fe576ec1b163470f7cf4d99166f75b51714956e6b350f375f5cf9c8919a18136fdc489458c012feb21090a5a3abc8c03db195541f61dcfa528915f13a628bc11d36e844e654753ec755ce9ae3f4af24328b04ee615d993e8aeb1411f7d2b17b9ec8040a9b56d4860ca0d30dcda7d3317922b25924b101af6f50f8315373db00331a678955d293ccc779f7887d6451454a1ad9b40fbcd42fb10abcf83b3b9d8105cda58d181ee97c48730faa351afdd257281065850b4374f8951e1e3c322db5e3c468c671561597aa98d3a244c502536dd6cb8b64e282cb3ed3f9b29ef0afdab7a41a753f92ff95a14faa876a26d8ce29b7b2ec2e5a76bcda592dc1944dcbf14db112c3fce8311b856bea391098b18f5f57d582c688153fa2b4373cee9a890ed263c6f7bd0db9c36776c36d26d27e14dab8f9ccd5f3b555b52e8fa767d1a5af7547ad3013013edbee27506dea8b772c95d91bff22faae532215e9a631d735b5554fc1326084e0175dc47fac94510cb633792b0db9e405f5d802168d49cde6c0cefa5e99b3caef04dda2ec62987ae75df3eefa0db32c73835fe86beac45e542fd32024a37ece605117eb81358b80f68714a0f2596269e78b6aaa245e30b1fd09c36a63954d64d2233662b1d4f3f4726f75f2cd3766273a0cc0d00198f40a37165bb3f29f7f8cf45e9ac52c53d07961e6f0b97015532edd864b81a4a06639bacc936cf6facbc35b10e73cd2b5213f10f436412d1932e8ea712952ab55dd3a63f5d6c52e828f77fc396f2e220d9c09f92705116309a14fa9c5a7076d94f706ebba82ef3f96d5a91e4fd010b81f7b201dfef14a6928c6a0e0ff8949241375e24920eae80d5618d281babfc52b53fafad655c85e4b32a975b1b3a99ff2cb3553184d8cc5c3a3383cc1bfc22c04e43e86b4a25ffa7cce25434896f655f778b3172a3bd7c25702e70cd272132e86d7e69e8ede445e9c2d0ca64a39934254bc0269209702e26f240ffe50b214aeaf9c87dce0f3a41ecebc7e59c0911039b2af89fb0cdfd729889222941bb0f58e76851a8b08b8361961d8128b5adca6d6ae41228d06b66677411554c057872e8af6f70008684b38a85aec8e321bf02ce38c70e4a49ac9853dc6db15c4c47926e50bc5c2f4dc93a588c0dcfd02733dcf6f8f6950d6846f2deb0e2dfa1ef5313bb6029564381eea1138cb222fee9756b6d00ff6e0df921a3468be661d3235686ab7b8a1ad1088fe1af0932c5e76d92b52a3d53e6c33bfbdb76b93a93098e9ffdedceaf4885d5a67c03e88f8a6be618c235681656c1acdb4da19e4136b97a1e6d13d0f0c8c965d9851a9c6a327c511c46f1000d95fc533bdb31c78e7baad4020f2cc2af16d5a905e081e8f55f5f22068aed96629a554e8716f9ec8b2e16624555477e62a519f29c5336760e0987631f9422cf5e5de485a2be578a0aa3439a1c846a80c360fd8c54995dabee9bb154bed69638193d248105d3813df5b19acbfa05ed6456d0e88f61e1a97387f2f01e5b7cc1f3ec0201870d1bc7a857ca1bfb7e1105eaa8351e5fceb4d92a425600b268711055ef21517d1dafdeec334a40f72d0f907b2d83635c07da7b30ad1d71b32f176782cbf69a07d9ec8ad35702594df6a732d1753abe295c68783dcdf7128f650f383ae4132f30913dac002e65176726ee32639071772b6fe4cb8147f34ba033f34967ac14fdd71324e66bdc4dc9c746f386c57a8ce927af3c3bf70326babffb27bfc1b0dd2357ba3edd2a5ddd2dfddb2aa5cdd4674371e2aacd9698fef05671a18253291c6da921f79108eb6b45953faba37d745b999ba4c7442c59f48e43a313ca90a16f6557a69a507dd636b3cc08aa6330a9f03a348c9eb9a037af57605e13934b13118717546b32d0223f191723a501da12881e3b2fd5993f0926c5215bb4c3ddc8eaac3606c0398ff7179097885dcf4b0cd8715d3ac8a0471e47e95b948fcc5b37a9e8d65b0f8c0a79886e9b1b0626ff0f503588d16ddd01ea82bd800949e7341fa1baaa370c152f90ac43df8816c50e80cbc42178b69153876dd8d67f86a74f607fccefa504576b1585ecc8da5c73f6679adbde9af023715a4dfb890ca8bf07c3b8f39be3b407b269827ec3030f69aa7ae157f4101f5e2b1679c553127b36cb7be37cf56cd23f3effbdfcd83f3e5ee732c1cb3f3a4033747e9e786e14927ae0274ddd3539d9d141dac2ce26b80bb1f5c0e619f5419013605ccd5571ba2c2fb1b077afac55ae79c9eda7eecb985904706de5f6424e26a9142f13d85f58146c59b37d058f272b0b684d024020e8c97ecc88efad6102293937acd99a958e80eb5ae5645d823c966c8f01a244e1de1038ba2a182ffabb474d13abf7c020b921a16e71c5c090b7a20109e4e4d5d11842bd981a6aabc14218cbe25ad225a400b5c1a1ee5769c34bc36028d8cdd270bec54297e7b4b254f329841f0298597da5f489e25dea9ff3f95a0d5456f466019a2764fe00c80be9de4eb03c7e7ff276109533b9fb8c0b2a81bf44c5e9f36f9f011a47e8eff9bcc6cc1facdaf54d659ffa6117724f61449a376667bacd88455ea4bba56a2a42dd6e1b90139f1d7dc38f2a9fe982820f95c949e58783cf54e2093ebaa099e5a9981710dfb4de455c8bb1bf305e84f99f88e32a859d0b67a8bb4a8162fd534946f73c34c3b8e6753104f4a2bfba63188865d09777c16b728f5ae22bd9d88fbd8bdba2d7ab5d30b68974ac090c82c50e07e23cee42613344eecfecb5582d19eb5fdf68a50b7a6534d573466619ac083b5f5a5b28fcbfadb12839b9ff8819109fde013cd7f7d5fe4248b73757ab7dbb9cac304c0ef5b4d95a4e3ffef691c765de99127723197f95d4472c514ce79074a84aeb5394dcc7dbdd4e45f039b042ce0b0eefde951427b5959da7df34540c71050332cc8e75dd662e31e20eaf69696ffcd1c69aafb6f203960ad734b48b4d7b9947b9585f9d1e686626faea21ff88b67b822911a6864f67248baedd6622edd564ceeefe41b52be1604c2d2c86d60c615df497f34856df35c73c260093ae1b4c3ca721133e9244cb6c5bc59c8bb7d65e0479bb2457caa87b7f3b77c042a380225d2eab101236eb57bb3ed93cd809f4bebb71f7a415a674de05bc216853198f43b7f3cf69b515fa63e0ec716bfd31cc594b7f907c82adcdf04d13f4d8c620128d5679cb705289981a8691294d01545d514315fc4d5142ac3e1683931b9dc180b7a09d4318d357fd716494b46973456a22ee3e7574752e6c73460e0d033bacf7f899170281e5daebbe6c3a6c07b3ca7ee94413f95f7f8f5cefbe6023e4ea2eb4dbd01134e0236c9cf981470fa2bdabfa89e480d9b455082b50ab1630e6135b18f8a0297468f854bab810350bffc6ea3c2e88e1a2842ba8cca2ad8e41bdf511991aa11c5594ff4b63437bcaf7d94fd1594cff05e5bd6859bec61e8a2617f645d2fd8091175c9ec02f86f49f9bfcb0776c47d004f30aca0ecbbbc77fa7d5d65bb5fa02df4ebc2b667480fb1fb74e4d82eda110a8bfe137277a33e4163efa82206d87b43a9ea314318bad3c69a2b1a9730f6159f153a5a0a6b0d8f46d2379784a11585dd981d9ecff2d8762e9f0e20d767f24a3f1fc2d51829d943db94123ce73a2facbcf48d1c02040aa1ed735c5fe3a0d523e0a4c7eca9ac32ed114488825a07a93595906b3425067fc86543db918389c273ba2636597638c9a03f78ddcd60d74d72de82e72eb50a164ebcfa3fc6b1783f1be70078ee53272e418e9be1378439c8fb03e4d6bdd3c7794472ef7e67736485b2a24a2a634628bdc889fa80d326f6fa5125415dbd79ad4e1c92675df930d80830bab560f378a2b9db82068d8110ab2f26c3adad79413789d2f1a7dfeada73d305efdb381d7e6d89b9dda6c57685295e356c106032354f0ae4e7d32c0538284116f2a68b2f72456d24fb63bf89780de60d3883d61c254c0a5d1077f6335a61c4e98cc863cee23c4bccf1fffe40168501f6b3210151445b8edf616b72760701a0520349cc498a76c16719823158f7c15b88d992f4b8b7b89c23709148612d9d360b31cc4aaace0dba9987d8cbbbf260302472de3b07cb030c78033d9659293085e50c0cfc08501d8faf41ade09b6edf0645b8813df3c402764057ffbec054e1409fd47c7a146c83d7d40afe5e3ba78b4f5b32907cc69917b74530f97c172ab789efb5e21c11dd858735b3a5366d12713eacfffea7b75e5832b4d1c47d9bb554ec0a0e5f73622cdf8e3a318f4b505356f5432b223911f92200b8b5234ded7827caed1d4fced0d1a1062feae0deb664c0fd1b6a41fe0de2956cfd9c55bb6847f4fa8218991243ce7278f5ae5a859e64c8abac391f538f8841845eeb5cec28be1796fed15b24210d9405beced43b7f1a3bde1c51b63cb25472985a2bde86e5952956e97e13feaf7a4f44010dce2c5f4e35b91ddcaad6fde91e0ab3fcc352e013b281e4b58dd398587d5a459a0e7124450e8bbb022e7db57ffc303c359ab505892b612a068178595f91046cfbafa223f11e0e1170f93e320fcf87268149f21459755b7bd7e52de3189789b2eb82e5cf872f795e896a7fc4d6ce1af4159a0b0e76c3101778fefd407f1db43c77a91aebad582c477f4243d4faa22d6bb5c90f4addb92803ebdbbe47c0cf696402727f20fd33520c0f91a30e9a5f1b91d8d5e235e9993f483ae6349c5ff14b0a47b8903be06e35a102a3717299b7927bbeb33c933d71efd8906db1f65a940fccdada6c34f719973ef99c5472a9d5a48a33b193dac0f78af401db54fabd3a5ac46fad2ac2539a72088e91e7b8188412ac7b155933ee7940b6d7070506a77b7c10ebcea2ff3bbbb5a0ddaa97f74af5ad854dc574c7de6f7e5efbeb5b6c9c4c6b934a7ed8ffed2681393e8dfc5f0236f3c4f38430b31c845d1aa3bc6abafcd0281763e4fa85bd7e94a915bcbe89a041e4d8e7ef2340ce0ec0442ff8a9795196d130379c4883c88b1f5677f4c20bf9289cec8d911dcd9bb70e4ae4f7d68ca2cefb46f2fc3ca7f38be56de7f0362e953a6f2e0fe9339fcab099e84faa116ede7de965cf98d402f386cbb3b61ef7d32068776090c7c38e392662690a684b3d4c0642fec7b17f97c5796cde7017c7f4cf4b14720066995e9d8fd0eceea242bfe8cc6946eaf598bbfce64ef00bed7aaf203e620da3331a7181b26453c76fa03240f3c17af713bf15e99ca7de529428eab9e7595859be3fbbe0a6fc92051bc141686d3c90719670dee6d3f7fe8ec436365e8f16f01399762ea3cc9cd8f35ed4b506ebc6de8af3a0a67f617d576202f69282f0a57ffac2b927ff35875b36be2d1325c71433530558da33ba967c7ccf733ddae49fe85614754a7b7e1cdba2ece778d087a216b7da7d573f1448b2aade2a432808322ee263d91c67da359c765898664d5fc1c8b4fa203c1875063762c1405bdf2f3b99334a08643ad5e1e7465f5d1c805fe79e312cc8a07cbd840e22c1b48d71234bf017bef639af2effd52b0f48b3270e89afb09a127e5b63a93ef0dc7840074ac34930deaa46755a8ea6dc2ba5e91c283056d627d9244a7404eebc64e935a896668e458db8aed7f36d8f378a5d738ba5733061f1c1fbd4da00c930856d662e78415cda7c7091188f51b6115006b0f2e7bf503f9fa71a175630477affee0e12d415ac868c3fd044f2248e91385464661ec646dc3622fc02783e015f6bde98bdec1836c98c1bd0afa6990bc1188f76341ded88a51044e00db6051cb91931c33f87e1498ebbd1440b343104a61495f83d8f9af4ea5b81f24f56b9cd9b09980608f02f85ea33f79d213004cf02bc8dccf8153737313161a24cce931c9a6587c141859a722ac8ef074a5a547b02357b82c99ab1d437c9cfeb65dfdfbe468561fe7120910bd42cf750dd205e04c47eff18414cb865685bd256b34971bcbbd8268e988a75329f8e2e5ec8b37ab7682ddc17194373e48b37eb35136438fe725b9952736bd1aeabdab0eaeff197acbce242217850d666a50ebf1a3386849be8240269aa61fee981a31346366c34cff448e6c8a52e86e6493c27b7e16efa2dae176e0580b160fd44e4b316daf2576c72963c462879183d77a31a9fbd2bfb9b479754e9bd3c0d58acc960c001146ebde5261bee956ed51c5d9425651e115ee0a9858acec73ead7add97627d617781a4eaf12867577b6a7088e860ff4433aed6e1546b7820d35e66ae9edc05ad34446723938755541d2e30c25c625f1a8a1fcacdaad72ca126c600f4c4a638f1fc42a65608baa3b0b05d8ec30d4b7bcbafd008e9c805ab25f1936a1f422367aca0c1fa882f060cd22e010477f7b6cd81b3828d508304b2e1e4c289afb09733b286b83ec91417728999c30c076f019191b3e20b41f7e1174687e9c0759b1530d494333171386d3c09bb3e6f10fdf76e3fae407f49ca467829e74726c93cc0b0a16bd5909138d262eb7ccfca79ebfa6ee08d742402541f0326bf19956a76961d803edad49e41a881c6dad1976a20fa59c4f1b7a5846842f72c5980ed51e68c2be5a4e5065e48be6eed4a68ab69b315084040b534343453ebfd6ce4e998f774c92790d70ae42dc0770daa8fbfbd2b3e145eec8d98709f89bb9bfb98bca4ac95f8f82ca88fc69a8dfba4f600f5cb323d5a7702c14c05c3586cf94880158494aa30d06f6709002a2fd3a94d00959551f723586c09155b7607ca159fec42dd375e57a628a272e794e62989a93fb1a617aa5077864e5542178f70697c1f1594c7c42d7d09db45664aa743c11174b7a4bca4d7c4fe2b6477aae9ba7814d678402fc28238c12f499d00f4a5994194860aaa934ef7df17c076cd6f1bf11a6355c817db6ec79bc034b2cf3ec205a1ba5ca91f57446f7abb682cc672908fd239b973c04beca68b6a958148ea5f51a4a400c17c8a2b65c70d2802a977eb3abd1eb37941b3eb2546ff564318652fccc3a0f71a0230cbf3125448e8033c611f3a64ca63c6ac06d994e4196d1073eed106cd7f18cb0e62786d7625ce4ff26623313f70c878933e52977291f689772c51b8406aa5be28d94c60ced62b229c0467e06980ad7fe79a4b4f8b23c65f447eae8a53a9b5c2dcf19f643417314ad936c5abd5da05592f8056428dbec0de8235777a1a732cff2b37d2df97edac0d966cd73b97a1b0f8b4bce6349e7636450edb81d2d49a58a88f4ea94cae599d64dfb5cf92e93262dcd40a3848156c9efcbfa76a72d92830cea1376c7dbb4acb46eaa647ccc8131dfc2989ddb38fc9c0a70197fb56f3f7acc766771389bd602b5c9a19f82dab13e341d63197efbd7e2f14108fd44b16a68356537b29db80df45a8ea8d0efcb192add8641c13b669d90947fdb89609d4baa764181ee3ee1977739bd24325f5b8244c0426feee061c1ccc930525383e0e58f4370b340c4e2636043afedecdeac8664ea956466a231dfb45c2dfb25e9312f39b1ed6f5136b9882a62f41e3fee317b15c472e7c8795be6299dcd4fd8c7d7f2fd63d84b751cd61b14f951ea25fc597929cb407f896938cab993290f25148db4ee6d7a78299d06c7c6f30c90c38ea29b78c79cac51c691c31e275a3b04b21110498da6d33dae18033da4d169f86ca01987597ab4bca7404a651cf23b9517d0e39ffea898cbee6c2fe5083d701ac7429631f3c7d765cc46c8097eaf8e37de4a4522c3181dcf034e91993671869a3755da05965803563da7fa85603bd55d6321dd30fbba07a83df43d1f7c43d99d7f169609ceb1b7fb8f1c1f0088714e82b6eea4371809729543e62ee38f359ced235d5ec180eb1e8b819ad42a02fbdd7027a8b01a7bc750faabff640240d2848aafd1b22bf01b586ca40a7eeb13aafa80c005e8868fcb384b8ea0c5a6edd50835aa8ddeaad9105d4dd604fe56f162e66e4aa95ad65ef7516a16e2665d3cab33e0aba582075009677184be8f41deab9f28544e53619af4ad81951ed72da3d185211630a5b50916d53bfa3f5dfae8cfe0e81cc058b012f13bd9d18018532b384e4be8d36a8249eb137b3eaac64e25926714d594595a4d858c7f1bababa9827e35c017983028659eac55b1e32d02b33aea5cdb3a91564e1a490ad39ad6b84e72006b2b13ecca556f48e717c467c369efed01ee50f8d8a61773fad06aa34e65de3c3ce7edd195b1c3a461199f67b04b423789d9667235594810b033e282ade2488e5bc3d4e518007f3bbc6e76542ffc971c09b3f101cd0a0a90c244c7bf0ee2555a743d2e2af5d6901e83b851d887b5a12123a99bc1e96fc44f9e5121e55d46b97a237eaddf099e92ddfca251433420be45625899e20e8ae551ec25a1fcdd04727ba33611fce7810ceb92d6163c200c8b051a66022bb9e51c4863b3002a32a869dc8874c34132aed1d7de4b013d1e83de9882a7876171709e40da5bdbe0e5aee5f3f25b3b68967651dc0b65bde3f3eefc05baf1d2f6e9e5bdfaef5aefc236d94f68500c1a4f2218727b3b5eb72b29ece93fd0bcbf5a55ab3de24aab2c590ecb2cf15d2c0514d6421592e7bace36bdfbcde5e794f0e7e00a18b30c2c461d1569315d9c8a1f5ee0f9c43468fc92bc53ac1262563665b7308b7b4fee474cc6da152142cea313a6268c7836cafc9f694907d5ceb1e6f25741862ae3a8728e8bd872251471ed50025d6c9fdb459add7830e9be108b36600f7af8ae42ea7506a85c529053b439176a12a67f4ea48bfd0d2fddb201f328996ae72e2f1c8466088d2cabe42509c25732e427cd2c32e5b04d23d9cd9c1b859ac5c2043bc003856605c99f042184078c9536dbd33b445549a631285dcbaf3fd6a2810cde603860b67d20107362c37adbdc5a58e8c0f25204a20cadf1010338c9a46908beaf0f60cc6a5202212fab02beeda470ed5c8eae11a9cd40c02cd1da51d595aded08fa9c600ff6f51a86575d7db9d24bff8923933059d26b75a67d19b78b39c775c89f9a707b824b2b78f102757a037675e1780afba3dab5b3c141ac77474c26936f0c0a7e891510007680f5c656226128cd43ad2853d68c40f07513fa1df4c62b1117904bd122e7f59e969ef9105e14f1e86aa1000c82e0dc9cd2547406664d44d902dbf8d62607f97a0a3df2f838afb0e3a3b232cb83095eb9b6d35a1e27578f5a19c133199aeb12067081b04040ad879af8e3d3460fcb01feda0b6c2e362a0c5b9c44e39ad386be56787c8966cc000b062f7c1836fbb70b302f0af4b016327bfba9888d28ac2990976b0dddda94b7bc218dbc2e8065555bbe1b7f1568e7b6071ae203d99229a6eb60c3c30952caab65f9ab384de2a458f19b16933b0acb477b551070b75581602742b687b02efbed4c60348da739102ddd3e8e6eed03da76d4922444bd793ef62c608fb0a065dee08bcd66b09ac1a7cf056da25a714fa7c6b547e1c4c6f95eb99154375304bc825d67866a842c9e83d0b321f7f2f653219de2d40bb90507571a2ef1610b1bab577fa5596c77232119f46d91e6c62b43d262a556b78f1637f42c7b36ecd98a53652daf78276a654853c6783184a2f1d06d15e01ec61bc3c900ae89684b13c43964773b51290108e8cd4438288d512e1b0ed10fae5686fa4c691ff245cca7e91daaebf73a9abfd761d585af306e12a0cddb0b210a90529a5cbdfaf1af4c12a5460ef0e167147ed8d60b155439d67eedb2e981740de050cdc654383ad6cb0f54a68ac241a0f75317ce32ee73f287cfd81975f44b476047dcc0f6e80dab223c4528200df50bbc33f9d8a6a35e5fc23e383685cce007c8721b6df2fcaece618c5ebf3bc5488e6b315af814cabc6c11f8d7b35de67fa68fe51d516a6452dc46a6f8470d95060d39436f8fd5cb59f4d86611c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
