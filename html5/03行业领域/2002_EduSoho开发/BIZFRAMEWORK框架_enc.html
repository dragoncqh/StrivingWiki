<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33bce8cbb61f83d609cdc61203b9d15cde6d2e20b833395eab7c0c4f8431f14c65c5a5a4090243f7049899fd6bf8b72298b123eb384154880ecb98e1ba9ff8d7e2ac21596e7ed941e9799ebcc2779b600f57633e8264affa695a06a278124c41f256c48db8039918d1531585b412ae547717a99339d07663cd1c850e0fba3b49a069fc1b385a40dfcf846e14c559e380673f85610a76c239d8ea5eee8d75e31ede3268c39a86af41e9c462e1d1a2dc06eec8545a0edc2f5c3117ed25443822068716c5a4c5ea880257fca01b586e3a7c4c6dbdc5baf41ff6d3b01ee55eb7377a750ec35ac1eda4e3ed8ef90a14f16b6c3e0dc78e97905b919a089c54915e4ee586c2958bad51f93cb63116ff2641d770fc1ffcb75a80496d9bd07a95ab88893fdcf7b6d649a503830b3144601a00b73695d200a561869bc5cba479c9a7a3b59c95a97d6eefaa4c927cd20751b85be45587e343c79b376247685c0260941723c167e839b23b392be5a7cd49303730d7754112f47af159a3b85acaca5bf3a42a39621f3175c57897970e2cdfb908e60547750549ac00d88f076fadfe882c7cd7052694fde7d54d4e6c1d00203246d8997e527b8f28d43b6e95771ac4c125d904ea1da876ede2dd95ee07e2fd0622124d4e14b822d39b1db5c84ca6ad54691e5df0f3ef36f266bd5e517ec59bbb082bf7db3b52c608a1c6e6f434e4b34abbf8dc65064593401e4e2073f31278511d1f85718d476eff2b0b950e5e33749b4864f725e71fba63f72e4690c7fbe9e6ed675e5a110bc5d5484762c7fca3c30cdebed8d33d8d2ea0345f278da00411a955ff69059869aeb3252f538268faed5c04f8bab1224f3fee4af0155d9230a3d83239dc687f761af63ab8c8507757bc75e8d17bb56c45c74a7390d9bf007e36a3924b3f732b99972bad26f7e8404cd481135d08cea6c085541730762734477b022eb1c2d1114ccd3e160265dcb7c3c1ce66b4f700fded2f5007e1d4ecac99b5fdfa430af2dd4b7527a65171ec09340b3a44f47aa5d9d11013ab85f8c4d2c07bf2d211055eacaaa3a19bb291060bc0cd2eb187f8f3af3693681b3e861f79637f2a73c3326d42355390a093aada28dae851da91c68c860ac8ce7e5e5956c2a225d1f2913c7aaba470779dd2037ef4ed9b310273b7d2504348f371dfbe62a9d7e1af8676cf680004ca51b1154dea6405400e6954154b677f8c952cba39f0ee22ad0920c2e42c570a6e22b572e4cbd6b931ce08ae83caccae634946b3631be6396b838b406bdc9f81ab1c4c39aa446e76dfb0ae268ff766e35bdd9aa519d2129ad6b0c3d9ed07c42aa73fb33ad4174c219f34eee575103cb4654a5fd4aaf4dd628f9727fd1d079031b59b09278c73df99528e0b72edced3fa8a9a87b396f406ed2c043ba5f863ff8612a2ef723aa3146da2ee5459523266e5bf2fb59bfae0d0b1aad1b426a53b16680d098fa170e5a0941068617b62c0b802a40b3c37063384e81b9d37f2dd1cf77a98b4add7929b83baf1f234ece5d1108020c2c61ee6afca66856c51be6cc8e0ec513ba6b59ebb26cc14c2ed9eaa8c3a89699ff785c7a8f07de6cfb4aca6121989d19185d1b6670f898250c9e036b227c9b73a49f5d85629076416d1c7e3d7d25021d0bec96779480b8883c32ba92121d9eca2735a9be479171484fbbb75586f877f7c0288b5171bb68afa2f989e6e2e088793614eb728e4d7f586458f7bf834f566e6ad76410a3476aaf9be525cb090d7ae900341e269b35c3ee47c38801c7d67ef4a90105e81ab776ebef4ac46fd92d538201e3c4306af5f55e076969e6045b93e0118be3be0a25ef3826273d0f90b16672677b49931afb7c7d2160c34aa4d30b9554922ff1c6777b6e0ec77bc6ce0416557b8c339f5050fd5a5793f93b064fbf2c38dd9b086c7ee0a16f5c77f82ab0dca8a4169d22c45df53ad6a86f17cd990ca71046cf26b369b87f5bccfa6ddf74a1103c51c58611a5492c60744dccf0258d8ee2185ddccee426f64dcb93e38cc791030951ab1798ebc50918911fc8403c33751202846e429e33b0c09b4d544671809478959be368f86295a2f6a15b29ea354f9393b37739e4fc56a21549c63e84ab0054d77b6a6accb9017520e081545a8a02302c6e031ce279a2449a9bc4538689458c57d06f28c0c4223a85b02ad20fc11e51959d839892ca72f7939efc7bec0087ebdda4102406128278979e0148ad5fede202fb177bc459ca6467a44898405f699b431ebc17cb47612ad24eaaba4ccb804a345b4e051dad264c3d10b0ff17cba0437854570d1701c87f1e0b718f58861d735673f0981abf57c64c876689cc8e0a924ae7257c195b50dce9d50ebc9ed4197420a52f487dc2445e2095c1762e9d4a0706a2390ca37ea489ac3c1d891f727c86a0c0e843ad5af2caa0c1445c9e1db93c292f502f9456402fc34cf1df0acfe5d30cd646cc87e1b79591cd66ab6a25384ce9432d9d098efee7f4afe84470b23df4e846a730e019dc9ce1133f2d02a0e07bddb1a01a112e10f53a75dbabbc2403fc63a9798ead8c0260cc7068ca8134c534df99388f6c1c869156c3f971bf08f0fd3a24159c207ff42f7b2743485a30c05aca2c1aa9954d8b78c32c92ef108456cfb417a79a5c2f8361fa97d9f0e591afab128d1a79bb0badcd4d63da78070f95e360f5d1c987d69132b855db68a882a7e9d78cb778b111d14bca4ce7f8220c044e932f6349b1751d4c3508df35af1c04eae67f7febb0e8c7856a7d5b4b946bd484c673176baa65bd078803a16e86a8b1a7f38e57a58114d059b3d214212371dc6d496eaacb0b1b75e6d35d611b53e084d8f83c3650cb00900eb2b497d5fb971623e61d37ff618989f6e8754d34995e737c5df8223c3af7d90e3b7efd3a9f3c464c1a0313666c5e6e485c3e9a8537978ff41f5f9d18388e3e12f24525701f4657fd053e90f622944dcd11ede3b4214d8936a6c9b2569bf2c087fe5caa684914809bd4316b715edfacd1054e719ddf2c1a530afed32203b3e6b90ae7c6cdd4e517ff7b63e8432204f72e5a027a127dadddabdf2cc333742d6a7727789bd05f1d79fd703af11c349d2007c6239aaaddab67ea9c86d932523e3fdab4353335fab4d841698d5ae6e776f784b72a3be816f3125800c0b9087505e7815c259bffd497c8966fa7f8d845f134cf5e50ded2db17d5223706489fd31f2123839acf73b13d3aa0301c906c69f333f053bef2bd2d7d9ec65612080d77fdd7655a3a1b27825061363c2a22c9b0198d860eec10f297e283bafe9db4b0c27ed39c91b2c3268702a3fb2bb80405a2d27c0487810fe4a7a2657bcddc430c28babe17d8910cfc67d98e90dcf149eea9dc62464f31b47527068bff7956cab5141ef4eeb89fdb2f742e93501e2b98c88753a50730f4f58bfd4aba1557bea6322fa5e5f273dcf1add359b172dc43525f4d8d553b565878880ed4537e0c95944e66d6cc0f80a1d3d948c33e7e3604243a740fc18b8ed0aec0fc52eef0c2681f0dce63f8f34bceea3deba784c74d2eca402b165d9132449f738b10bdd4c50f5bd6a9acda07b7ed4562722c71ce16bc4042fecc78a21a34d9ce5173d18542c5a0e158957576d6e652448c3d6841137c386540dc220997338129cfc42ff6e332577e29243d77d75ebe9a63061d4041a7ca46f6e6c7f36d48967b623c392d1857107316d5b4cb48be4461bfdfba476fd5e4932d7210b36528568746cc1b7f85c937055b798d6dcaccd853cfc5778ec24047ab3f4fcf0a8785570d0c1eefefb75464a5dc71f4baf4747ee7ca6c55388b14445fb8f9d677f199c7d96d67a57e0ddb0ba67f1843107b6c8fd1900817fb33bfd70346929f6b37a0d37daadb9601c8faeaefb37153ceff3ab6abe32ebe2fa16c8cee98142e3c798a904d121515170765e2f65f2a6deb5f9d6118915f973fe0083d74e2e3e75d8998446bebb936a64d49367c2f30da1cdedcaafdedd5e252ca757261133074ae0e18386e3bc7335e826ed637cc3e841326761f2116e7ae86818cb32e251ba1bf392c1f521c643c51b8b605f66b0e0349e298aac0338808125e424f8c02ef696d8c140f1bc7ac4c0401d2f9a5d19347babd35705fc026c5701e5f23f6f3a4169d3ccf2fe2b4015a4d1b0e5c6f353931c56b2f9ec5b89f6a08f15af8ba71c8615cd4e7aa98a706767b02cf931a2177ebfa19ce1b7c6548d2c58836c889f7fddbca0eedc5881bf518df1e60b17bd802db29846849bc2dc0eff25077146d521c3e70863a538b3fa5ccacf54fcc5262c2bdfb372f66c701ffab6e01c10e1f103df974982840d1cbf73464116c4343d1358908d949c1fab09817a53b8d722582ee32a365b37cddfa622538fa13d852717898e64e323bf63a2d13ca9da13c086e6db4e522b4a829cd3e7cf6538994f1e9715235a25a3815246a3b5b09e92e3800baf588c02c1b7c8d2171ba4f5fdc0a6f921b763d1bff447471788e803e55c68a19f1e9bd46ab9b1b2424b531d6d886d4c4b74cf5ef9f83501a3c105234ca706b503c50c9c1aed1f7d36576c3a4c1b44b630870a3f82d4a3dc9a953a8082df9d4d2b293944b7bddd0dc0ff15b0e74defc8ccfccd26b07088f7bf7342c414b55ba3cbce432a995778bc55b1e97f023117f1b1ec039c9207296910c1b1e2c22e474a146ed871b12a810ffa7786831f647d768a80e898a1048730b348fc37a5578fa3085255ebf714d3d64aadc9c7341962873fb6946d0623d956651c852bcd7b6f6797bada0fb6d08bbb7d14797f50761967fc0950e48c07b924c633464207d9b59b36994c4a27e2fc9cf5301ca6ad703488c07f5ac10eae4b6cca6735f81f6099ef5d4fe46f118e977b83b4e5bb52f70034fcff34ac488214151c0ca62261838c3cb72e5c1e847fd5bd01c003b68b1d3319ffeed9c6785817437af25b71c29f59c72e80fdc659e56c46049ea801d169e1b24c1514ee965888be325b0579b1002a381bb9426308a33dfc01550ee84a2ba37e0cf9de3f9bdd92274c7a6183ca876b9d33c5a3439369295ad9e336c653eb896bdd72643f2d1347bc926905e10b7caa464aaaab1d31a0e965014c426730d5777ddbb852a22c756bdcecb95e9f3d2d269599a607d93d3f427d38573ead79abdd94c6d0d9cadee45cd6fe26f5444e11673cc077cc6bf86223cb4ef49ec7d248a9fa18fe3664eadf393450008bc9e520418c78711953b5829547f83fc0f55d969c168618b3483c52ebb5895721e092ccb43af4bcd821c12a4510b623d89c6e745b1c3d1a787ba59a5c0b79c7797d42fee9d75d4341e39869486564839940ae74dfa8e026198be488d1398e2d7f5da1337470ffd57e7adb939e358a1ba6b22fb013e83a26e0112264aab849737cc4c4538cf6c87fd9fc445d31e91cb0fc626af4b2e59ecf425a83bfa29e1cf50c85cad12205a18cd02ef338d7bd1bcdf10bb9d0f3916486ba9e77a273a8c1a3d34dccb0bb84f3f157facc23740d3b44e0e639ccbb8cf80b86a86ccb959b868a82bf71e3f1a9678095492025891002267bfed44b6175599b2f7172c6a951c9fcfefd84ea3b78db87e5d4126f6805c52ddf76459f8667ef1d1f237a7a6b48a49a0a6537ba5b1ad5f6b01a6ee7593f1689c724fa4b3cf5d2e17d40aa38f935f57024cf74f0a357947f948ca1a852fea7cc9f6538fb8fc9410c5edfabea940a8d96c2b4c51562e44002d116da7e98559d7866f6948dcb6a3f68fa0a5ba5ab10808d0adc078fecd47f663916c98265c01b17d56284eb06980fde8f53b7a47ce3edbf07dd6c55c3a150a6fbeaca55a26a3b6d894ec93097e9c9a450c39b1a3fe4eec46e4252fce578c3b17a864a4d14fabfce5b2851b10a54fc0f2d532bfa7482c082a4928976fa897559cc0445598a2638098c450927e9779016ad3d307772cf20aca56789191e0bc53f3a29a9d41e2cf9541a46f127196fe4e825f77e21b36ccaa58f0c54fc013cd436c57ccc6120dd2759473d356b27b82fe15477fe28785a1eb9e6f85be07d6eecac83accf43d7cd943f0fac2a27fec27e30704f0e59e770ccdaf70d088514c39c8da221c87cb9dde541568024537e9877b422fe0f8d30a45f2a21cbab1a8675e6ff538b2d5e41f59443139c57bac01a2c0ebb5830d6f6231c734dae4db89b2ba2da3047b65b4d99fbd9ae3dcad519ee1bef62d7c2b0d6bfe15f54fd0f562725dc21489dbac1995700ccf85e5bf4f769e5dbe81b0bf6a8d70ffa41bc1f5063aa5ae961f02571bf24c5ccb003e8f035a7ce6bf182dc92a96ab5466651ca7318fc2572f2aaaa14b9fcd70520242014a30ca6e55103f3b6d342f2063ecff9ad066e9f94d019200c06d4572bcf04906df065ed2495bf335a82d58fc909d2a031916d21aad09c775214c02fcec50c8b12af7b7e23e10556886d9d519f5308622fa44423113b1510d247faa724c8825a40e78a123de51f529755883aca85e22e748903ced89eed27c65890c297168d280b3024ce2a2ad991bb389ed40f5a5d95ffd52f6108e7db56c79a486ae412eb70a3380fd79eeedff4dc622b855676c5cf17f4abe2bc9d2b2cf0094160fbc2eb469f29f67b6d3f102076dfa59fd6ce73ca61b9a1936684df7c19d15a1f93930c56f29238775c69531eaaa80843b19ca07f9b79f46991a6d4135647c4ae8931c1decabe2919687a8bf03966d853b736ab1ee14ee0f6ad0d142d5d7ff6d4ea81989428a8c6d0811a280d33d0a862d6b3f9fd5ca67f33ba17e0e04cc0bf474be193cfa12239bb044a27a2b715896b161193570a910e4e71b6951d06448209c60d697b381fb0e55a6034f5871f44312d8a12e98368a185c2f4d7ce072a530b0b48b01bdef51eb16d7a1c126c0024a249b01e8efd1c25cc3b55e093e6e8fa57ba85ad81df129e189b35ff7fae51fe2ec89c4d9c3a6bfac98bc215eb5e9ebf79b0f0b085fc62cadf4097953a1ea2945f4c58a83e4044566549a34a41d8fe8bde8c8bc08235a3783fde262976bf3da5d93556dc7e97248eaf4c5fab5ecb17342ce833f010044907a7700d895d167cfe619fce72515f26cc7fb391a7a6953609fa4eea5c459c9ea5a287649c5987eba5050f7c93bfb502d0af67cbb5e52ba1bf627e845f9c74f09c6e9ba7109d34528e43fb184d1f44091b81d63ac769278fb318f696b68981197887fb38cb35999c450d74cdb148f72cd0025aac84e32646bb42766e925456b7493968f3e73e7eebf83562b67414898efae54ddd79fda0dfbd8321e141ee3e7d8a6ebd3c158aacb3be246b67ce3b813eee141d3d7b644b719cdd852c265cf8e235c67e761d86afcad8bcd90337e2975e11c710645bd45ad14f498b8ba8c486eb4424057330afbac220e49b291e1c43023e4138468533c3bae5b0761616d482215570943fa3fe99a8269f998cf1d4cfe8dd8b0086db44351534ba9b8cca8481033bdc8fa21df7f9cb8419defbe2ef642d6fa76c2623031aef9ea8679444602d02f3e4d6f8eac9ff25c834b45a89815d8957034e078aef2b66f1de277a5b598fe43aaffc55954d64d00957377f81b89e4ff7397a93314da1d9410e54511adfaff051e700fa0ac2c3296d8f08044601f038f33fec3a70960c3ce8b7bf61029e8ab833e15037bd205951edbff489c68adcd9e949811f8e09746cf114f4707dcf3c57cde876e8e55c52ede1ea453767f7242452779ce6cd8f87917a8df7f9cb23d0cba4445c501e8fd69a7314729db39915b650c5c0349af5aa6fc848d46db8056ff959692afbb5468d2262bc90433ad5a7f08efe8a9dc999fae6674afadc7cabe9ff382a6526736a95dc95a48a04aafdfbabc859f98627c430dbe358c420840a15f08262600cfbf4207e4eae663889e04bef3be4bb10b4d50105a9f90b691b72c5bc52a3c4e01b5167df3d1a311f84b16ff1fb6a51e8da09c292ac7d7d0f0c05eb683c2de4e9f872e81d99c6d1478a53fab132de89fdf062e6685551aa0f028050c1425375b4dcc03157255537d33f3c228447c09a89c47e17483577b3161687c6ba286198e249c5c178292fb0cc3c68ad8ca9983ed96c4dd5ac0390c43decbd9e4c2dcd2741fb4b5c802074d430cc5363b9e72e6342b9613e00de3e6c3b29c520bf5d6c29361e5d591b5df8d8da2993c2620714f79b1585a37cc0088c798917e6fd6cd958e4e2265af4be0c48b36e2853936accdede31c7dce5adb20e7ab941b0b5a35d310d7b34ce1d872e98d7261877e36305f1b01de20698012ac10f3346b76ba550a720610c7c4efb9c9ee08887485aeaee3be1dda4ebcbe148152c5fd43652b2463785b14bd4dd9ce19246bcaeeaa5c89ce836c69ab6c49774d3bcddf04ab978d2fa39773644d2629d784d03249fcb9002ef27d32bd628bf893a52aee933b16e6838a2ed04f910b3140479b6ccc89a7e3f431f0c09ae34f2098de44dbc6ded6a14a45aaaa580df35cd567436e081e14e07ea45e8bed746a5103e6d76828bdd352af7a1f23446aa15bc651ae7a3296bed3d62a748d8533593c2e84ba907e116962bd18a76c9f5a373fd6166f4ce149721176f4146a051545f135f1562bee4ea85f09ef69afa680d0820908295d225e25aa32f250307b3c07f9cc1020391e81f270671d8714173811f4e0703c1a6d72f07d052782c66976ef7e3d8eb74616a2aa82a8b510878992c55386ef88343a307d5f4796379edb1c509b1e5371e649cf093c1c617cdfad83ac2deeac87ba00cac665a48b39d6e9f01b49c2464924a2364634658904752e5293ecf8f650487f3f5b2f0be106304f3eeb71d278ff98a9652f505309f539f60d758fee5b42b568a08b5bc24ce7e60c521a2b584c8e43fd646d5deb5c0eefd020a4546356d376a97e7c1f6d23efe07629565582e04dcdbc0684c5b04f818575c5b4ab8a3b87951f40e8c8a816982dc4ddd3cff85191fb4f8f691128d12224523b5f3f21510be69bb5e629f758175fa06cc29855d3c0a0fda246483dbce0395cd56a2ba0956ceffa558571db1821328721d16953113c700d97564761fc55dc153f294eeaa7971455b457c3bae7a967797d992d12ed8dde3325fb34267f34547483ec3631442b3103f889efc3a9445c0a7609c9087cb97ad589379966c151c9ce489fd2832fb921bdc80cf615053018229903d4f5cb9250ea12f9d8b3800a40fc4c2c460f61118345fe5534a92e13c6f6c5b27abda23b09d2b2453371be0e09c086282e6509aef97e72bcf4baa2b34b921c3acdd3089b3538c74d45aa7aa70c8a387d5df2298dfa7800bee5dad416098572fb6f0d3db470d4a775dcbad5dd5fe4738ef45085681d39943ca7102cd98779cddc0504b7c8f243d937427f21a6860b0a40f9bcfd1464fd37a1dc883d34f8d5e373cf61026a11b4cd435a9141e12f084520ec9a28b04a66f8a6454741724606e62b9147eb3025be0b6581af0c8a18caac91cb4b541358a9b05388fafcf5a58c2dccacff49ec6676bd3e2eaefe9f8302f8e78d65eb9b7b01e1ced5cbeff24f43bbc8b7a81b43b46695fc4227b753445f5dc5fe693b111b7b662148e4e2196a11956c61a066e5f7f6d9b21cc3009dbf60c6f1cc00a7e65e5f201753a3579834c7d6e316c17a7cfb467f1755f8872e3f09a8896f0c700a81c7232ec50a45f9b175c5eda000ce45082bb35ad3ac80efdc1a501d220a072856f4787479ad903031ea436513abd7eff69297bbeca45a84b4dc02ba21b8dd47abb1a934d2175edebf0ae72b8dd979e9910f8eb84a6d3f266ec9860c016267a17b4ab1482729a06952aea07a9e58bfd7d08b752f9be3fee5b7890c7a0bef586148240668acbfc1c90d869a60d170382a656aecfb04cb37173952fe0a90c89add7f5ccfaa0b873d2d3de9147e8e902ee3964479c91f723d0547ccf4bcaf9451cf30a663ba8e19e97f8dbefce70b72eed0cad042b9dd492387103b1ad005332865c980d2aef80fed4e951ef452229f9e2bd3d5b062ddab636b17c5a30d629f4262fbd1574077d048c57fb6b6d313913687fe0a0ef53589cd30d93ee47d6333425bc96f71aee64b3ea98c357f8ad5a652f0a24d1632a82fd91034f2dcbd7418bf67443f6bfc536134a1cad6087addf214b8fea20efe35e45c6d13770e342d22c149f4f1d0fc8b91802d89794bf904cfcacef473965bb49724fe1706de3c7278565f65c6e3208586e99a81c7ffefb1f4947c8dfe6b2d0fe387f1dfce613710b50e7ec7cac3e733e9c76cd1df988b951760806bea45d127e9074fee3b45a148244b9041463578cf135cf4691bb291d9eddfa9dbfd78b1938d8ce22cd648ef55f1161f4856f3b39df613398e113211c13e4460ba37a4cfbf0d7722e12046e9f5bca02b644a19ae8792b60bfec22ea067cd01fb110519afa94aee54dc2105d1419f1e2348740dc12170a3bbc27e8e1c7768d4fb36b5855df2d24dfc075377aa746797e64ec079dee786ade8fc9a01b699cf86cb8f81611437c914cfb114fcc7e20e5c4e5b17dde8334f7fb866375be6ad85d11a93ab19d9f8265767c958a7fa473299c29b0d5568e795ed73e19376461cdeacc825f7c387e334873c0110565a471c61b7b36e1586b63a31bb4d2ad28b4bb3e35fbf121c87ce5b64c6dbde82ed55348e397fee18ff28e9f1b9601563c045179f794cc9de74a1d07732185496949b48543bb6e16d9fcf538e22cb8ea46e822455eba91d858175db2fd30d63ffcc71ff0ffbf8152c7f1fb6a3fe3915e17772370aca0ea367e47888484bec59128dd11aab334710582da52bbb001a82bd9650da4bf08c20c3f286c3b38e84e72e7eea1f33f17e3974a0f4d2076b776609e6f16e4997b83bbc5592e6234760d74a44a968f98aa4f1339a143a56be6486d6a262b35bb3b32fe4b5ac637b139d84ba16d14c71fa0a62be96e08b55b187c808172d6b911754a22e7d0366110aefbd2d6234ef7aa64bfdfde7fcb4000db7d1d356bf938c4932415d2f4795b6057da82692414a88a8bd81e19820c5dbc568d766b6bece052b723e41048f9102c2f61041d6fceb00467c067d74031f317f08231233a1bd76ad046a7ff1ac4622157440028e526b2aa72921027c54ac396e435c17a660caa719d429efd786c8fbc946f5ddbef0b55bf48e938ca922fe5fa9a5ec0eb986574699bf020f4eb7ad4f369fc8a354dc8bdb40effec27e645ef2952c692567ba26132093594f9f1093c2124b533d6b91fc6b28ada4fff1231b054d49915ae3c064e0a297a23c4fbf4a89bd3277429dba1071591caed0d89e67352f059e1c717b44fd8db38200ec57d6a72582e2a05c9793aaa902cc4fc0098c68a87fe925a78cf276c2db5006785ebd1bc2ccb0c2855f8bb35cdd75c0e861450c30950371ff74781833f2b8ca7b714e831473f514bb3d2e28200901405b6f70194cda16fcb5fafa572be0aa9e7b6abb7247512e614d468e00be201d3e9fb7b74ef54d52d09e6fab3341efd52fda1ae55e26b46af7173afd90be5a2d8a5a0b43d390167cc89d7a5d04bc658ee43e1d14ee30dc18455e6ee5fb4e94ca7dabeb9fc0824d2c9ae9b3f25f6fd4fbe113b794556cf1aa6fd23a9299fdf26ed5ea93e1be60086e6cdcf90e9677119200e920119e4a8c100fb0333ca09044360e39497d2e07f0ca2731bac7295ae2e4a5e147d851f8946c51e8030586d5db1ac829bfeba73339efa74f2e9c7e04281560ffb9124b15751a85105ca00a98966415ee84056d76d0598a4957e99a339e703dcbecbea9afc51a346f6ebb41265034327a3754f3b644055e1772fef38e27bf0938e201ca285977df6283e5252ad8912ae75a5228df0ff5ac85ea47828f9a28c460711581af6cd12132c1f6af2855517f73f08c73b5bd0dfa80bb23e5b39b288f69f6bc7e2d48e449a5cd41c1464d1c1a9594e3b0ce3c11660484871deb5b74e99b6bcc3a18262f809ed157d429ef60d803a33609aeca3e6c648d347caf7d76e56afce640ba7abacbb73729a9ae91fcc44328f777c7af9b4a45a8c7ffaafb31b115f241f34e006e94f2e27699365048bdf0dd06a3e3d5b45198abe27467dcf60f065e30045ef9043686d80afab0db705986f69868d64fa02ea8fc71911677a7c13dbe04195f04c90a457d5c608c5249322ab7f868cd878c7f00e1fe2355126cbe39e79e189116aaf471e35522ee32378185ec9bbd2136e68d072661a2e8105ab27cbb15af38f8ede86bb3af709a53d4e2e299c9a3a079b878df853210f42e8324139cea0a4fe52743da843d1704cb5685641ba88bfefb51218d91808743ff4f62372fb296c90dddb575d7fffe903979094a915aeffd933bcefbba7b74b11bb11e77bd8bf55eac1753b08f3f42973a49924b03ef4a925bef9c5ffec7fd3c1e0410a1c56b4cf57f76f4f38a2d6e31023b0ec13977fb32e5add3991c9ce4068f91b29118a703e55905a22cecb76b72b1b8f9eddd3c967d73071529a1e8fc07dd0291b148d236f2bf2c8f652165dce77ca81b2bb13355aa5ef3cb18afdd88102b85f115c3539a222d4e9aec129703e8aba9094c45e5fa268f30466db59a2c287365e852398631f6d96e52df596a87d08f6dcb326d251d107772c296a793f0f35b458a9f9d71cbf941ceb40952d6fde2fdee31e1e87c7a707e6f31b16670098be89848d906aed65e6d91bc6ee82336e4c02e56a26be723c5db4f14e9dff591436590591fc69ef784dca310388f85f2936a982b2d6de16e22408b17dafac9e88007d6074d7b9b9fe709e251714ef311ce9e8207781d747aeea8f0ee3d8e5376ce2a7adfa40bf686a573815ad162b8bb183082bdf2919442f6723919a062d34f24cc4c0ea8072f30a55ad20956213e20d8921ec729b082eb0e572bef44d2615c76a7043a61f9599dc1c70c6f344a85eb71f6f4b6568007279b75f3d9305265c9c4eea3052893ab05a2e7f33fa31f96fdf79ec7a47412595909f2ff8780eead2931ed5c7b94aa7c791d9388dd4387cb4ed25a286e2a10249c796cf812d7a1146ac79ddfc3739101ad185c3b93f6e2c33c5ae020432cab44f3e159965e205ab2d524ff9041c1a97933dc40420c329bdaac1c5c7a1ebc4a4bd05148a4b177a29b4529a9d83bc2df1ecfc330ec6cf00121437f1b643f11ef53b2cc194d9bbc923d2f664063c30fc07e587267bfe54cdda18f990aec8818d7c22b1f7f1ebbad3436501c2ed69b4aab42c83ba41faee63e6f07ed579e3fc979c16ec454f6bd8d631165e767ef555cbe32f494474d5d6866bccdcac071f299b5e7b4708fa64690c64f7f401db401903c97712e46768a70c13759a2621930af0b453b68a2a97d5a50807fc2dd7ccbd0ac227647841103e362a48ed2d9415f477ca0d8c2ef260791f820916860c1b2ac19bdea655f531a6b36eb43891efdfcb89c3e28305a7573cfddc542f0fd162206f84fcac92ab9f79f2500a825aa0131519beeb8efc786673ea261985e9094bb807939e3483ebc6dbb55cda8b98fd9733f64bfeda475bc840a3f8b533d81b6c9d21a967d5790a9fec45677e656ac15b98445f78e5a0c51f52d848b9f461f3af17cf50ce1b699f28922c917b67a5d3838bd1bf00646f43d06ad0eb88579388096e89223513905470161205032c5c2b2ce236c5c20855e3020970aa497825fa7d06af4e7aba7cedaae43236302ce811bc22b90e898f9c98e3aab9346ba3a82ecc9df353718c57cd4cd6306f081c7bc260a1efb60bd10b28dcf4df43a1d4cd394f29c8a07070b40102bd16f674a1f75988b25d838bb4b9cc8a573fcdd1a47849525cd49b7bb2d6ba55af4dd9be2cb60b840ac51a02968e62ff0cf42cc0abba3ea55984eed2bb30bdf337cdbf62e445e65a4c78e141d7fb77161d91cbb81738001fef30fc713defbe049c28c4ca774a7fa385077dc4c80a9b987005c8180b9e3adbf2788cd83170da75ab0b224f4aa28c23e01855ac998c1a32fa12697d180bed2d85c7777ed708e67375223b31aa8283c831fc23d7c33d300b72626fce134ee2ef396d510f89586614fbddccdd98f84a6dba94fb69f40617a734bbaa34f6c5399324c2421a3568942eb0b65d550dbc916b3b40e7622977845c85dfd6583c90295be2a4a51a7c123d036c08348e5fc3838ab2baa4aa997da6bcb30036c7d8c50807040845d2279cdb8b2733158000da4a28ab5fbf6bb4616b2c8453e0ca862e6fbb2762806cc1e9aae78f4d94de38d71349820821e9046681a1b76dfd6d80799eaa88aba21ef4e205eec45b969d835ffa1aebd7b1ec57602915d09b96500df5706b1c9b152bd3fea03cccd47fe0e34e1c3e1198f6db4c0042b0e03ea08f3671be0dcc2f37a0dc3814792e0e03da3c97d63134e8288456cc08ef54e44dbe9d593b0afe3a49b9c9926a2dfa2b9fd757dc9f4ba2cdf0bebae86b4daf0136a65b90b677b4fd184a9407e318ec7468629913ecf5add4405be8116d4738dc285af30f2ab688670e40cae0b86371b59882088f3d2564063486888358267880a2fc26d3d3a27068cec3c6f0f94aaef0b6bdfebb768cdcdc795e4f2942a2717d4ac8d6b6394f75b6647ab78f07d9843ace3c6afc874a997aa46417b5a6b35567d3395db64cb31d6c60e839c9d0aa7dd4c7e8602da83845c2f947b574e343b8455bed3770f7699e425310d5964c3d382e19d616f70b679fea7ac4457b0a731c2fd8e3aacfc4dd12d606c57a0c99562b1341660a0bd85524dcb5c1af59d2496d4e77ba5c4d79dd82aaebcbf5749130fbca45c2ba931db5f07e3510dbc18b6f35060da206567e247d608639134825529b4c3cb80d3212a50148c2a8c60d405aa24d0d9f0a3b0b1c561db02ee0034acde73d91958dd87b4a677a20c8509bb367f229628ff399380fe4cb739efd19bb5b370e21029eb8a26f73281a6266ac267244f7eb600249862cb0f5ec67f502dbf0bce6ecb8faedf2df5deb9032de962e9ce5649cf606ebdded2b896d975520e047040da758400e2f49cc2b8f525515f810864484b2060009204ec6b62a35b15d9bd615f737b9bc4492562800d4a9a1a7fe08bef1827cc74c238e0a19eca83c5e9c355166b47e4e9770708c9693da7325d3f746d86a404b48302e1fc1f4b909231fe980bdaa8e1369ad40bc0539d521e8785b4e7bd1b68b1516632c782fe0770be8d1f6d34bc292635677531e8412586267a844c03c2582d84f725b88ad0f3c09bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
