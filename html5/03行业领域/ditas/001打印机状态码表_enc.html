<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82a27d4d04fc80069c15e1bd709f592ac8740c3fd4b29958283f7bf5cbe57ba0c51b97514e3baaef2c50908bede02e6f4cbce7ad0cee51a2b122c889163a6ebf0df1ab540140f6f714b69dbdae751da0d55daa4462232d58551ca7a067208ae0a87146f6773d97f35b3caff058bb07ce0d8f486a0c76a09f8a08e121c1db947680c1e3310195b0e8ce63a7f8085bc9d96a4195577263ffdd16fa28d35f79bae8dcf6698284e989da7aa3a71e33c75be80af74b4c4511e5bb77aea85adc4985624ed7fd14d82e5fa52053802634339a9ba2542229a9eb7168e6b15b0fec5e72fedb416ba3f5300c0bc48adb9976b5f5755ee5da876d7ac16eff5520c6d6d65586530d90758ad53b142db16170560071ecae0202aa63ea274df6c2c4939f3fce990bc17342302eb303639f11ecf557d6222907f28413cdad02bd263193d8aa9b25d7f5b894a44c03c50b8b5a54af6172d373fb3479e8c4f6bab7dfea78a1c7dcdedab0c14a9d7aac1e1d0047d90d8d75d6466a81f45bd9ab6e625f7272fbd6f2b48c6b2ef093d9553e82be6666f6e0a9a5fa2fe153ffb5f475550d10c2638e685c599a4eee274760df0ffee57b5bb4eba85aa0c7186ac9b29df4b6414a781697a8d6d7215d612e837907398aea37fd8e70d5040de1af39141cc24a05d77d7ee859864e08df095acfc505dcbcf3c46555613f013f923be3569b12850488fc1b720e4233aaefa78a10e57443394a0d6be8afcd9381377b36d2bf508ef85dd8fb9233bf0d9b665d03f59255dab51192208ed7a07460a98b6b92ee50f268077415fe44795915d161323551be64e92e1a24e64ad4b2d7af6145a4a454857078ab07e075bded5fcf32da2ed4719d5546ef8a96d7b879d3ec417484fbcfb51bffd47a9ac9dd5b87dd3b6baddb3d5d3e8d84691bee327e1cbc058de681ff8d0179ed46f438bd06b1873380235437dee288cd40926bdc99cb55a2b59b5f6d1264cf8b70f2d501330c3ba24d2d2d0abfa0d51e754285e26960afe99c1bc7cecb80d24efd30b694b6c4fdc949460f724e0f6d79b9c3e0f796322c3026858468466f37586cde1efa51a97f1375be38c0f464550dac7b3d30f6c9ad0888ffae2227c6ecdb9c642f0d780ddec81137e67f19f2e08d4aaf9898b6b059e12ba424c73ebabb5d7006345eab018f39c27aa88b9007fa5fe4a2975de6ab139a203bed8751274cb7614be107261a6d29837da99c63e99f492f43b776e4733041b71ff64585c951097eb089312a873d88655b4dacfcc7119ed87ad313d9e5712cab01b3ccae413d887f31a8e6512325ef6f6ff6583cc27d772f828004bfcd37b0748880cd81dff81ffc7374a09df27896fcf8763dcd73a45e4bc719a81f816e971a9c12847d24451375638f512eda3f85bf64fb970404e8b2f507a1b61b2739551e845e30bd978d765276586d2fe5beddac11dcc2465e56a9b950ae4492fa6b5f6b0c0e0a6e6bdcaffa519ceaa7f318ae21657fb04243f07fd4b13db52d995e58324c82356e7beeececb06bd914ff1e3a97acc6c4002f67344cddefb480b988d5657e4b5e3d451570c2b764bb273528d2c7e246159eb439d096b19835278de8852eeec08623ebc1160bee6925ee65509c1f6c839b9e5a0393f3c5469395f5d31ab4d5f18449ed3e7e064f7e96babfd8c6978c0fde51581a7ccbe404f7c19ed98ed31d0e8d24b526c84e4759f87ca20056922e0889751736577cfb94ffb381641e20334b04e0b277b47d8e56cb6e9227a1b6537fefadc7772d38b2727a8df776d5b3169065669206b6b9af34a21fa960110984822ed2770e79adc8c0c719dde31bf8979ca5dd634d901a0b7c7e339d9ea694c9d837ace12643ac0bddb7205a85be151c816a594c3c54d81d998639c3d447ca22646a278812a155340e5ac1dd72ac364b320b574da7f348d38c0deb34dce4f434df549b465118956600c9eacab056abcf2fb082735a82f36558c3e515e8f0bea7e133f9a7fe55162f16a9f9a50f1f2489970c0404c0d574773ce84108daad7cddb097921aaee9dee92acf5a78ef90f60ec61a706a76eb399ad38a77502212aa048a8643a7e0d01cc2f70752a4d3238a9598aab8de3990aecc4c5d04a2f0c0987c95be0a8810541777feafbe92058761b546e3be86aae8ecdf93832013d289d9b526ecf94a83dacda32b2566e756ed3e7d3256ea228a91b9f30a4a8602a63e296cc40231c3da0dc26613763083b50a64b068736b313664bfe8eacf225cf523095eb3b484065508227f118a34a4f624a6cb68267a1ad7f3305df22b637b96a3441aee526b0a64c47000b41fd786d9f290a455329dba33ac05be150b698e9fcd6d8332f6fd22a1fc43e8465bef79b4c565024d11dfe0fbe4b6a311159d17d59d5637b8be2782375b172f91a16ad16028e3a2bb7cc215abef42c16f87eee0fcf4eed3600633a60f0d7df727b00ec31e8af8fd9531c36073684f52e1085c72da8dc1e4b9a05f08c645815ea035535183fd63326b908967d7299e868506aa750c8bcf83671f687d6c05ea108abe8436ed0269347cb1c1af62925a7f207dc448610cd43baca79592691c87d3fa639f54e4a6ace8dfe57142246114e13b4d1bbdfaf38a6b18a97200e0983a3d4507220c90ebfc1e544780d39aafe1838bb2cb2bae586db7af0dedc0aac04c80ac3d629cd3d3cab991a26bac98e51be74c7d9fc097987ec926551e13fc30a72e5a3f2d9d25d940a5f28a906b49495978d3c4bb917631888029d3c665f5f37bb75ac6fa775e99eabdad255f2c62ff47cad1aa9402d345a5da02d5dad8c296b6f47d524bba961072e1b227e1a9f8aaf739707ca9e0e4f6f2b10acc2ef66012d6596682022c81ad44f373d68d5a0aa6e1391ccd0a4a197e54d2f5c5e8bffe5d8c783f75b216fc07a1b1fd76f201536501aaf6a7567374ae3ce27161ecf9c21208343f43153aa5184f9ba4bf6761a1642c1d90da36d4141e04ba21aa2be6deae1c182a12aa46b0ca6eae7e69e668206d9f0f0414e4c0a5ffebf264024bb6fcf7c896f4a1ff6bb319dec8c72c9e14fb79824eaf6dc6add6842fef2befa0a2164f554c7029c26a30e9492904ab73656a2b1e4687b893a78d75cefbd0734f07dd68bf07fc8cfe9db738396a4cf60ee93d5e3e976d8d820aa2a5eb3b5a06812be79d2a3119f57cf4f079f3a317fdec16907888d8a87e1dde4aeeb2a8da7466f534a5b93ac502fbe0a6a9e5a39975be4ba465d14db3284af6d211fcf3b37fd89843d9dd9fb1cf08350ef641192bb5f951a82469c1406a49e005497315713f91ac8fa12fc946ade1e97317e5e4072784b580a11d5b2b53559b97e6660fb3ccd9242f69295f7ec47fff4f417c139699bdb778207372ed8c97a6b5122e52b3793b12ab5e6d4baa449f313b028be84971fc4fdcf4813a032b2461ec90f4f8814cc841d6c9a1380465196d86f3d5bcb8f6f8c36e80733d602d66e8321e6cf0269b4202e8df99e024af82cfdf21af2816e5e29fe63f8a39637c0baac24f02fb5c82af20d2df2b176229f97588a508c1002c2a4f39b9911cd2e0c39fde2aef6bb4667649f1b5682e18bef0515cdd8d10e7e46a6c005e0f29cd9be626dcc1d4561bd61eb76a59f67cda60acc04825e539a1479af4838628fec5e82699a094af4e36f544851837060c872eb2a0f228746eaeb6727c09b5b23640cc98f16364db2905d1b1ee4b878ba6a39ce2aecaf55311280e63426cf2dd5fd16b72e83e6c1bc2e8ac7edc68dbbdba467de1e51571cc4f41480339d751e2da051f5592fe2153c834117fe6f7fd601b3cae52e682c1c55f9ccd7f441ee5eae06d64785ebabf6212be321f50f49294f1a08b5c1e0ab83046e9f64272605bde9e61895368e7a1894c650bbe1dd8133c96a355d86fdcf1dee4169f50986d6f635d3f72476b022e593b2481c8b7d4d0ae72c12ad3c77cbc31da1d66473a2f824ce2e8e8edd5f5983c41a95ffa3d69ab9854ff87cee3fc920f269ae0ea52a8ba976e7011eb04014006dd44e84957db9bf52e014b0baba590b351fbbace6cba485051709aed06d735e14bbde8a866da93133637027fa336f18067bd9643e4d1faa7667905501899553d25f6607a3b3280abd5b60156032d8d867ee7500540d7f1d80180c84b7a22e15d76017a4c2a15de3e13c2aea78fd80d1d4b2d8df418a8c80d598b375db3734c4ade2fe92ddd40a4b9981fe8207706e4008726f9458b0b7879007d59c1236da93044dd12020bb8be5dc5283cbc48ad3287d6b9048ec7d4a6b1f5504867f8a2be1e7ee618783f64eca63f96c14b51edbbd36bf9e724ddaeac688e90e85f92ea086d502db20e229f0daaeb85c8d71b5ead12060a10b0d9e2ca06ff74627abf2fdd76cf5c38c8aafd537659d4535ef7ff10aea7318444355b639f27523c76111973e19eb8bc6b5e4dd56b3460d9b7790c56c35dd461f34a22bfd74ae82da6e9d0cd6c2d0145cf0c1cf7659591e22062f21a3c94bb7522d09281d29f70f66ac0438ef1d3e663b219da5429961fcb7916452d2f87f52bdf0ae66c8f75d69b60c3007b634d8a37661c4fddf100da2f5858bd7993f2995bc22ad217fcad6ddaebb2ae772ea01e1cafac2bc6a7edc14479c5774ac1a18c6918c5f5b066e995d0123d6e3403813cad581a9d3595ee7f8700311ae123fbe252e30a74eca97d61e3a963208de021a832e11ae9e1e8008d8c7e9b1be12e763369e1f491120f40509d1b4531c98f51fc1ed74e4e95937e72651bdccb60922bd2e4ea411181679959e5eab4a275ba616888b929ed759c30beb34efeff053d4d510af1a9357a1ffacbe1c2e9e9cf1efd3c0aab199bf1730452bbba053e7bdc71487ccb3bf24b9dc29d1895494641c1e5795d7fb188b4a996e066edd4e95c0448417f009c3d56807114517d14dd97587d76f1c2598f611e1c9bffbd95dfe775b363356e9779c9a3ced4c6e1627b8c0db887f3fefa2536f35686e591ade14908a39650a04d8753557d6c8fd997f8f433bc45567c8323e4f082c17f42278681bb85d319998642e2f3595c80f9f1112a97df0135530a1433b448a925e70df5dad301a6d7535534c4a50de5d6b00e145441aa25ba942095dcd46a29127427e3472685e38571c60afa929aaa125057ca679ea4fb4ff64ea9dc06b0fedbf409e5644da58769d13c80ead1b38a79d302342c799f59bdbdb36a8bfa546caa56d07b8d8331725338297a70bb57fc1aea9203e4814badfb42bb7d0a756cf8534d4090175d153bdf5dbd1d91213a5371e7bb70fc2dae8a3fd2036d4f9df39a57c3e685b81d8e7a55ea3fe5524fb8e90ea9f1ac9e0892afe46c862debbda5329f10924638b28c376856afc8d314c99321b898e82353af838edc24d52203a5309f0564d9be7a7398e16304992ce065691527f2ff70f9d2f5d40ea45865eea1682111e1decdf152f82ffc5bc7deea428fee899b4d85d820df7a95a7793c266dc0e06cc6add498ae7696e1fa217743b2e9fbd5391402f809047117d6c8cb3740e8391e3cce7d63b352c63ffc8032b4f9bdecb725daff27f4a79675b71c587aa0b088f6532bfe819817f4f66c649bc1ffa1a68befaba0f7a54814ebfbdca54c7f895ccb7c140329b677fd1df8cee654364be3f43df4b1204a2783306331fe9636f17fcfcd2effc1dbaa14999743d2ae51e85d80f4b767ffcc9e31bf7cd7a5baaf7cf00c1a56bb8bef03fb49e924e2e543e767bf5b7b349622eee6e3809e41ed6af54a65625b1bdd28eef89fe239892809303ad1dfe53d37c1244ff1386e5af0ad0e2efbac06b809fac99356b3981c037448295ccc89f8829ba1c7728803241c64b310d00fb045a95a4348fc3d752c1326fedb6a4ae772be4f7558253a7594308a4148862e48ce916556312b377d3d7a30c78ce442b421b4e751144470ced5b609a416d6bfa6a7f68cfb829cd3be172d182c6a179aa5d9d0e06993926f532e3eb09d9e9b16963e9e0e5c2cec41cc3b82c1e58461a58aa6cc275be740825b7282c0ad26c629ed8ce1b7453469d519d6822caa72e9170ca09c259f13d278b44d3d94c3c9fb2d253a124fef81b2f06445657dc836b1c4765c3e935c1e04b22a6709303a297a962c942bf038659df4958d7b378a8242d863a3a4c52515b8794273f9583dac32ab61d09c38a63a4218f707f640624e22cbe5ab8e22d35d6a573e9338da898d6c66920f30500adc93da37ebd1be720544fa8dd01388921bd24d0f4ee48c89be5354468194a86c80d57d4f019161b7243644054d17e401540dd62e8bf337713cd41f88fe9c56cf74545d9b73907ae325d98c9fc2e3c0037f5864a7e1225ad961ecf3c161c820daa6ba6835e947405da51de1339f9d522479f324a542a9c3b935f56f7ddb1424e1252da1bbd2328153a9b72116abb828d9be1cbbd8a6c1c0bc23e561deb2788be9516ff79a0983bb0303dd7f6839c28744c170f521a185c166362e3c885779b4783074636b874e243b20183adf57172a75677cf1298719258d9cafe97a739b144c27b747e09d51ed68dd2be360b194251c11e214b8f29e11deb87b67e9530d5104f38530023529b04f95ee25aaa0a926880ba05f566ba0cc3e189da09cf9f3b84cdd6f814ce9a908b1bf1dc7a3ee0b7f949058691b24c1b40e13dcba99c6caa55cddda0f54324ae1421d413160fdbece3d08b54addc4df8485c8965a999d60c5af88764f4d922c700f1eb219f53c22f0c254e01f62087f025b8d0c60e84537755e32c3a1ee2ccb5ec8104cbd4e3b2e99d848c72074d809fbca009cef00e52648231fd4d3f75eb14a54364e10c516cf8f600f3e6faf0c0de390bd0792f50963165aa40f23bc96aac817a761bc407742f3d06f5190d7df6d5e1ad4789401f28f2ec432d69d1aec542fc7c91666d148cd67df1fd5e539a0ef8fb8bacb040c1ff9ceb50929d1d2f086c8486f83fcec54e88fc6a63a66fb5c910c849a8fc8ce2565668ad6f4590d6a59362d6c572cc5637c73d5ff96d086c306d7803bb0d986db94da90e18b7eeb7039611455171da12e050162223f3f76993451a827e40c2f1f515a6d10a76d4fa6151d70830a23f22a2f081261c49465ac1b54f47d99ca8bcded4fafaf4e3602b85e521aa5205b5929343c1bc92d3483c4f5a19f7f2891c5a45c5fd7107096673481a911016f37a0cd78b80b2cd941c5a4839d8acebb7c8484c995bd6bfcb0864cf182d143289973a196eafcfd104ab4f144ed34c6da677d342dbb5a5efc4d96dc51adf62e39389b0aadf908af6b5a969e0732e6e2f4b2fb6cf17412bf90227808c6c7f8e6fa50cf88f59bc852bb5e8f7c1a6339257033b04ef2b4c115af3e164a8b546b0ac64390ff3e14aba4871826d419cafbaabf5e75e7a11355b02c0f456b7610762a7f5e8f9776c0a21c459a615d9a8911803771346a18f58374371da0a68059250403bd8cebceb32cdc7e869a3206dbc1ea157e9a685289471d05d8c597ad821db457b2cd99c8cd6846cc01bdb0e2749b64d0cd5871789dc614ce967496225af6f45cd605cf50be3535564fddb137d8f917ae9660379f9e1aafc94b7fa8e54600d0c053564b996e1582b9006eed207c7b883ce481e745320a34d6b1d586d942dd3fc514b8f7e00d983769d9de8cea96c886eac9ab6598c2c1d21836ae818ef47abc60c7409a890981540b6c899cfc48106ae5239b28cc93212eb19f6015f5db6ecbc94514d78b195f0597fe39c84723b56744f519b7a610ad7f9b262c1b7d9c90e8e0325fd4e823d7da3df070bbd637e1ca1a4ecea4c2e5804c69efe2ee1d2d81f36ffd54c51e462d83962b658b7d5a546bdb0ad7e896a13c79b2055ab1dc8e65e78d3fca508ca89ce59e2ec321895aa9e3961e6afd5593e4f319bdca6ccb40a11846cebcdee3b2757e3b7a6567b684a8409b58ac87c778fa306f25a77e13711836fb07aa7d92e714563ab9c8078f50ff1c66dd4509de6ea11233411f5cc3a0cfb9645a1ffd00563d5a67f02bc36a904d157de1c54a0f4ebf51e3ee6590fc5620d1e7b922b24601005d43838feffa78a3c484e2c824f5110110afa02e086aaca50c13c0e6e1e8229cf96e2585e1cec672c44701a622a64d570e21676a8050e6199d74f0e776363aabb08a34bffa7832341928de02f2a4e2a39080201eaaf207e025543afab38ba12025ff1db7d7d6bc8cffb0f933b4353baffd186ad7990a66a00f8c46000800a65f9e7447a4a37f88dd4adfa93c516babd344f751a6f834905e091ee6bb33c3ad745d40b12315186a1d188b540dcaf5a4025841e250b49a46621982cd57e13dcecc7ac4e521202870ea70304628d27736ba152e41c8501e138f596461a0d74ed0b77afe574754cb0de1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
