<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a5fc18e35c5be09346d4a72fcc7f933412e3e45bcc5a4585a576f3eb546b88b31984faebfe6ade40ff4af4319fe2667ebca617f4362fdc33bf295f889d5568604796cce5cc7afa5b43df34096b8f764edddd513e39bad3c48d886429673fff6c5a945c198ba18f6a10819ad5d10b1509f97c49ff8bc564a317d02d8486b3271fa0a412a0a308f35ccf10f9bad84eef0c9f41f4532b6d06d6dbadf3bad11cec5ecb43b2245e1ee926fe56072861c14a6fb273022866a1b2c5ac41418a37eb715089785549dc6076198c9b58fd43d58dccc283ce2a31562b613f58d7b93d87d2ce420fd81297478f3349a5a10220367c53b087a5fdaec0e38f1fe13e7839ead85d100b49946b7d73ff3f9384b350e408f4fa64ee357b408d708cf786ab00d8d09a7d1096bf0cf5cfaecc0b40fc43871d789521f32ea6a24fd51d09d4a516be33c5fceb41f1be2f62fff936e565db0fa4089296232a464793891172c99c9b3c0b0f627068ff866fa3e321466648dfc49bbad18c845e0cb525c2b2adf59ec4e97c555f908a853ad8ab442d25dc234720be320561ecbab0572c6a126fee480c8da0a3ed2223ae8d71836e675d7106c2ab859d85ab995d948f917ddb1cff5a9d58c6b6cf698e1e33d117773693b5f86085f7372e344761b08fb7d87677e377dece261d23bfc42d9c9db999275d6e235f010f47becad207780c3b5a46813305f3ae2db67ed8a15cdd0dcaa2b98ff0f7377c2feb2d5c1a249a3a6917506d7ad43181437fba4656ed56da6eee387f1f28014459f8067e9e6db98fdb3cfbcdae1d891cb4ca45c9e6d749c4cad57582363b113498173049e1f97a3a5eb2b03b9be294c64131f6cd0770b3a3b043ab9701cbca54c8959798feb680c8c4806b08b9814a099abb72cd756eaa26f50d8fafc8eb34e0e5ee84704b343ba3e64777e97e5cf0e7b4339acf36c9a64137c2815fd273b3cac93c80a315cbd3bc6231beffd61eafeb998ef2df0ad61522a3a8169d9b66e1207654049378f7e6fd50c6c7c17d95753b19adc9535a6043a955fc40c1bf21432b2598a2b139d3f9c6b00389951a1f0c74b336f06dfd4e7a3e9981d22bc3ff01094d0dc7ea635c2ac2df8544faf1586d13fb72de9f6c9da93489e19f34e62bb990c3cb9842c5a80ccb72c2b085a4be788eaef0952f2d339b70d0c40d4cef2115945a03b779b41a0c49b8546a1ee0f72308aace21c3132760e32956982189f7285c3c5195c3c5dda56f09f1143c85c4b8f017f02a5b6b1a1b92c1fc7ee6f857ab5560fc5610b7e359ebb9b4306eed6db5560b8bc9a368af9ea2da58d78c4974ae49971f3fae5a53c2cdd60f3d174fc1eb0aca15eb526cfdd76068accff665f979e774273bd81f0a2fdcc6fa078ee1f91a838826b482ccc98f8951744b609b7449b71d03fd7f88f61884beac47071df6bb3f89bba0f2858cb6e8bb6e0af6c7c3594cbe931be2ae49e912e043e2274be9e7bd73f613330dfab4d69cb8bd3b65be01c6e65dab1bad0854af3184235a68cfa085962b28520e73fc34898606ccc6ebf71e0669365feec5292868ea724478687d53f59380ddb94e7b743dfb027cc1505c2a6b50a84e0cef89ac30f2a3e4fef8992d7a82b0a1c05ca9cbe377bf5f4976a5719773fae77f02b313ab1a0c17a0bbb84dc663ce8f5aefc01df6043f064728ddf9b56468b34a0de5255bb4b7854e38933b309eb99960b710214f06622fdc08d287526c8eceab72b9f6897db903dfcf2dabd4eee5c6a269be8b17eeb2806e67e2dad51445736867dbce4c0bcb4a6d704434ad91a317e23b87dbe8f74064723995c22766aeb9a294d5197cb5fad45dfa287a418bd98ce8a97ff9356126ddf0e8c858945d089cb6187b2943ab317add7d61ee1fc41afdf67991e6baa2a61f073e85aeaa03953463792cfd0c7f72ab12a0dedcbdbfda878da6cd6b0ebe3d9f6b53765a53a99d5a15238f4bdb4b68284dc2a2114fd1b989e00fb0000babfee296f010df7467c794ce797bc41840cd2e88164d5966f2d36234ec4bef7f98c576e27695cf85607090b82dbfb2d5031f2bb15fde40f9a20703033766fdb13f2cdae17a659c2e598a332d5f756aada5508efc8ed36e6ac7dc407e8e280f0d55889a40218f753deabe893d8c0e040367c1371199d258dec7ebf9439d5dbcea5436ee53be2d93f76a8cfaa77482ce05e41934ba4ecfb071276a7ff49cde2a8fdc4c64ea0584616138544f24c3a4c667f71f7d049086da8a970dc6a0d3857dd23a4d49b249fab3bf36be5aa4cb01e6fd52879ac99520f6728ba3ff73342dc75664710245b810be36aea9098bccafb23d38d738ef032e99ee09be6f27da26f3b3ccda225f2140f5a566b572a8a79005e850d9c9d12947e95bd921c5b32082c6aae0200013e6cf50d4433894b739b6500d00b520abc06ae102f35be4c173de5c993705e2fde3a00376cea7ffa7894bcff9ca4fe121192209e905d215b61ca15b188ae2704f5a4ac6603869b4cacc4451e06154a08176484d3ed4c6443773f0bda1545083e5d69abd0b3d74a319f6c37391b64325fe52064f2f78b884f261a707eb8947d029185e3ff5705b8364b5e518eb7df2fd68f6089808b834a27e7eb6eddee2e9c303ad2767d7d3b37e9988c0e4e9cbcfdf538da9b3550c73bd287207844c0be67c330a82dbe0afabc05788a7eae9ad89b110875fba68a5859c70c88fd7b3aa3e83a3ddbcd35accdde325da40f5374d4b99fd61648c1cbf77b29bbe20e650d4013f39d85bc1118c786541d7dca616889e5c67c7f6ff6dc9ec6725167b5f526cbb6dda96401a921fa10d9d16d9642d6a0c759a62c3c9e8b3a5e4aa6cadc1301ada7c4664c785c31dff53ea20714a802022bda6b8f351c32591bf9667141009b7f7bbb3e132720499d04da3f693c7687b83d18f15e9bfbf823966ad508b64295cc98bc89b9a26048b7017b93e199f4bd070492a4d75921e6781ed3e1dac196e5dadb89510a1236f46354a582b644bd587dc8d479bbd2d6b2b4e7ed1c90bd8e715d36afe5aa23dbfb2ab819fb351b54bd7a4668c99be0efe4d01f0cf2523364c99dae17ac20efaef8cb4be4c367083b6d01e505b81921695650201e46b4420ea8c9279a136c13a090c8396060f9f6db5abdb1c47b601050bd828b67cb14192a910dd3314e7c38e7726feb27332238fc12d93f650655bd39ce909387a590341de44a0fd831534f333f3603239a07bc2b1ba993058e501d8ac3adcd765408a7d961e0d9f0c231ceef53ff93fbb56beeeb6d31dc27b5b66d6f3f09ebee669c66045b161c588192b5a6e425c3beb3a00d6365695fa613db47e8b1428d6da849c65754117af8b04028e0aa1d2519f83d86c56521db315860d22af0cd33369a93bdfa598870bf8ecb8dc26e05ecb77ba134ff141693335a124747039810bfed2e14d464e7046bff71a88f0670a192e70d5680e6eaf03cfb0eb424230656748447bea655c19206a2df0314566acf91ec0dffd3cba5c0105554eaa6aaea2153ae4a92ba99f170bb9aedb1a278419f14df7c2aad760dd12135164658f8b9872a4b720ddfd23dd4b839c05c431e4d2196235a174310940a8971213d639455928ce70b3b6f30ba86f6a1edc8dd7d5a573927b8fe559c23ab63d79bbf1990d2546ac1d42e723036aedc1c6eff6440cf84fa3a3f0aba0032659b0ebd2401c35d7ea43c144782b6a921aaf46eeb5283f0d72728604b3bdadb6552e2db5507218086f0aa8af36cab4e30f209da315422f179f6dada19528933aeea3f99be41e6ff99683a0f680832c73e0366649fbe7eee9bdcc5b5009c316ebc5c210088d86ba34dc86e84c58f365c89aa34ba402b83eeca78c5b2790ae7ba7b00aeadd8600690c8cc7ef68c34fafcf6133b0cc8e6ff9c9478795b9aec307d7b67d13905d1e9dc176cd163e2a264671b0044c8207d07a39458750d26400711168ce15bfc4c530cbca90efb64b7d31a028626a2df6f83f72f194111a136588fe8ee7527e20e6d55b8f171d862a251b8e4b93ea9dc27b0e01745a82fc4fb83311283649f288403778b3a5e01438e67a813e87b1ee13415aa0a9dc9da110c6498969691e177031eeb8a67d3b041b201a5d5f110c581aea6c0c5af2f6da84453901e3c81e0e3013a7b269ca2a3c8f30019e06a9f3db4d1f134b91bb8272e93ddb2406e5feeb3a454febb03e529f6ad79f6434c0d7e99a59881d71f88127fd95e791cfbf59f2c27eb7c16ebe36d8235206cf865875e6f2e12f7013a1bbddafc6d4329abf7beba9c3e1a540d87fe71e6a470a83b480cab745cad8058c98c8890e40d5609a54e51ac2eec215f475f9278c47899a3d45a913cff9043c97c98aad3ff064ae38b9c60c7a84a7f4c3473e098b0ced47510bc06d9454beef3be41a904ec9ea32e31aac743ce7381dc7d85ff2f3f7d745a2d0f5cacb852f55fdc5ce9e8023dc46c53be1b05df019d95b2885270ad831c9033739316f9fb575daf5cff477fbfb825a7cab51de74c7c676b45416407520e5894a6230657e56e653b82b4046f4c68facdac787d5ce9049a4eb8b8dca4922d9dcc4a13cab14e462272bbcb5bab8eae892a165fba3cd61fcd8d3e19a6d3fc5e2daa3ca5fbe5916fad9173a68d66d340d84293ffe5364c5edd4a8a2dae0fb0f4dd3e4dbde19d2d72fde40c7a4c8c6c4ef705d5df69d0b0e369771f1e7a74478a86e94eab19158b97a0ae344e9071892c48908cbd535e93d417809fd12c4804af989a7e315336737889a68ac62c8bebfa8bc9a373a04afd25689ff42706c3d829a9291f783d0ba94895d35489610c30b50df40d585f3450b43492f392eec82a0d4be9ec455ccf43f8e939fd27553d64575f2deb725049c9ae5a9e718d240c51bca696ca9c1cbf506a64adcadd0fe8bbaf90e64a24c7ca26b4d0ade7ccb9de9cbae39d3d54ca81d40046f161c47fd30223e39f8e616857c97726086ef48981e1a5f027b172ff1f555d5b79f1ba68cb20d450f280124efebe6bc5044e6e432eb499d764d94da4282058d8417c0dff9723d502b844327b56dcfd2b17770e480e2d2badea4b457fb244e231cb2d05b350662884f3e1a3a496c9b8eacebba555deebb52856f0088982c5855d79e4103cb9897e434fa1dfc0dabe40a6ec53f41d5c0ce7c4679fad3118fe41016223a8d52f6ff5cb696196f4f824ccc2309a3ecebbdf115128dd9c4f54679ea783ccc39172c1801ceb11fb6b391e96f9f05cc8f42ad5cfca6ce313531de5905c0488b733ff50d6c054231731f1cc4fdc4233c69d138ba975a7f03ad9a2d0059c38e4eb84e6073b3145517e81fb2f87ab77b06bc38c92c3a6dad68c6e864a010e91234bea0f0fdc4da311b1f9bfab463c1140378180729882c1126a9d509e83c0d7fb0fdf03afbb8b74689decfd980dd91f0defb330835b84420b01593d07e6b4dd799a0674e1fe1ea931e239596477809de6e10a8f9b0019a4592b366eaf218a9fc2ccf26a25f1a7657e4252869d375b1f715a3fc8e17bce09514a76b1292ff673dae5a8b2ca039910a357fdc3420f7ca895cbf7f026f039aae3615961b82361b3b1ba4d16913256946f3461d352188a10cfde834f923c7ef76803f7ef72658453992ba18ab704692b0af6f323940c0cf1062fd61915fe818ff8a47f56a6dfd1803954521945716897fcbbb8122128b63390671ef62d63d1f1d46419088a3565bbebfdecd44d7f33a6afc831ae9704d01be9ef7569b08d85ec69e2ebab6d9e304d66dc3ac560bf7f64da2137df2fcff0588f783a795b7f148dda0fc53a6f2a659c28e8108ed73b6aa48ad10ef4289c2663b3a3bf0a8ade1b8fec6f6fb28899bd395c6766dfae4434340f5223f621a4c7ace9c565db3e00d4c1b4d5fee1adb3a925f37b0a7e5ac3e7b71dfa274d98767b4f141a647001f9307145f33b4dc2b58731becfd397f925429331ddd84ef5964d953dbeb0cf5df9a3faa1ea1a3ceb9710f2a635477b424cc27b792fc6d377bd2b8a8e446f0d8dcc3b647029cb23c3b9679936fad10deede6e209573af63433bfd21a68bad8ee15e2cbb52b6d246f9f78951a6a16f238a5c4d6e0f526b0e0192505fc356d9701dfe74e41614a33d7c9e1045516bd5cc3e1d2dd666029b10682da0c9ddfefd3228bb1badb78abdc98325e93106c3145c120495b3796532068bc25bdd0098190026907fcbc3cce3c10ed861f15d93461aa1ccda0cb6206dbac46ad08c76e69b04532debac321862f56dfe076a004f3f3e1c871319b9052aa93f0ee0832730898873367d4ee0bc822afada66f191027fe07fab5305faefb83da16d95ebf2821d395387231fddd0cf1ceae76e606dbf034b72a37c9a265b9063cc9c7dd0040a3e5dee1a6c3c43629718f4e57fe3de66d6004957355e3d82ec84817831cf75ae4f08e843e720b07f98f5e02d240fb494de14a2fcd4c3b83a4e3a47515b610530764086d35c3f7e2becf3589a366881a1149afb6dbf84b1c4206f6b64ed76bf6fcf951cc248220d84b8ae7fb9fe5c570d416ed19653d9e99bf39ee7601d76238c348f61c9ac7492ce775e53bdc91195dcb06666992a307eaf97d6638f73548fbc08f269ea50a5ab26e81e0b5b6875d405944863f64d02df7f27c6ac1e9b0602b38f5cb5e61bcf969bacd93f0e6f6dc57a33a8bde89aff45d2754c1f99a01a7728f787e5cb26559240dfa936589e6a7f595041d99754992fa6417adfb028e8b64ebefbc9ff10921269e63eb3fc85f9c36667938fd76be0ab308a5b30ee59352c1ec791409fda4f8ef7e2f47071a5f80c2c03d5c733ec93d6eb09bfdf56bb06393503f6cf06db88afc9032de999c4a7c309b5bfb7598420867398d31f77972eae5a6ccdb8107e43a2183ddc326e6162ede7cdc354638b0470fdb5b933dec1e058e3a8ad09c8f284830e55f13dcb2c9a8f9a9a39819043b4ae48923c69f01b028161d579df0fa6b3dc44e6bfb3cf3fd7f57305883da47005fa0d008a14c7fb185b3979741e0e6703daea38ad5ef9865c69838598c3514d6b37510cc21ecfd51d3a3c92dc18053d3a33c16a4b059fcc1eb1c89a8b839628147b5306bd97c5f59dd261da7402b4d2370eb880477e15f67d9ef7a8afe16cb8151c240232497cec5c67b6535227344bcba334b3599cf21a6b603691a77e2e79283bbb4b7c0802dd203ffe8c5458f2f7463eba68bf22a968830988a80e3fbd25317dc69c68f2d089cf586a33d990d69bad19304a5972aea7055b977addce42f529aef19e61d2ea55923ad222294f76d0cbae2dd8f224e37a29d9bb34fc775ee17132e4ae595e4fb8071d5c9a5787d4d18897ce078923dceeff85aa620e50c078dd817d5a5ac94e24f3ff83f72c26ecc0a990f75c1ea9a360d92db612b34ba3088a334439e1891a6ca26f0cfd8cf14952f620a75789a109a3c633815e8e029d6aea8e0be3aa20fdf5f60394e5c5f5f8daf374922caf9c419bbec6934765dc0f41615ea238338f272ebe67442f54edc0594be86977da17e821d1606027446b503ba735af76860f4b8ce2b07cf017872a2552fa0b0dd92bd596ac1dfb6898154550335de69bc6033c0f71deb6cc71f13cce366e0a8de84a5c3cf685d7187728b9761777a5a208ecb36f16b3d4d7f7c2253070f85ea4f8d699cbe788cbd061f2031b8e2c797b73d9e2b5c425fe2c672059470dfa115ab9f84158bbab6668c6f5f5b179820d2c787e8029a451d06f2addb85054771ab83c375e2577e5eec47b399126df27cbf409f4cc2cf481709f31f8af38c0cb921e7afb644ad9736aea1c4c3e243890ae8e0f608f8b71a2cf42983b6c139250c094dc171e2eeefa6f417c87eb046f10a4b15fdfd5d83d90b9e0dd9be6ba310f0b6d38b882c385ca7536ded216681b2033d2132f896faebfa51616e02078ed1ac1e39fbbfa1424d4487278db6d22e2095e647c4a09ac0ebdb432fc0162ba01f06b10e88b17498a9a8ac2f0455b370ec14ab78cb5eb040dcc0caa789a3bec8c9b4505d41097bf6db45c045369e4236b91d33905921723926910ea8c4886e94af37ab1f9d65a3209cee1b3a0d10f23a14fa88402ef81b991a99a494bd651be2db20ba4d2a25bf216bcba5acb991d1f94ebcd0db238532877d18f5d43888fe56caa8c2452a886e77421a7fbfae2ff07415aa7df2472ebf18dcad31fce40e3220c825536e46111c831fc138a3cb90cfa060859559bb3533eb679636b093aae11b181050de38f2676f72b93a1b533f360e48b4cde6a218d799ce51d9505097ab43678a0fe2e0c1921769cf8e2463a792dde05f0ccb8ba2df882599aa8b5c768f632081762cd537cb13225a8841c410347668ed8cade370c30285c696120f1dc888b8ba0485f110e81fbb5be3b07c8a8205b53873cdd67d2b95a2989d0b16c4ff448c45a1d5bd6bd31d2e393c300e4c41f7333973f0f88067d9063b02ad9cbe56de5bbd61b46bbd30d3a7306b7a4267b84183cf0d9bfd451f4ec893f94fafaff153342cd9f086b5f2ab9cc8211c0987ba3a95317f813d2de0298feb49fb995cda3e9b9c66246c11de221f0464e79214f8cb7cc2b001b8c5b57166561e4ae978e7fcbdd8c419ab4741fdf7704ce71fc7d123f1f59c884ad4428bd9ff49fa5d12163fe09dd3845db6dd38b94c4e0c77418583189aadf3f93647c581aa42b397dc14050589911d87bab4ef8ddb6a2887e1d05c9c949863cbf2aa742164ff3d96a3fb6630516cee5850776032e1119a9f40f68becd89084b577d31eb2b99baf2cf5b200fc88863ac7734a303cc3b4e99b11cc7d59435a1f9f43a40b5080dfc331924126f013b906966aea15a162d9a119cad660f182231508fa3cf1a57bed442b174dd69803df43a91340aa1d7a26623dbe82ed94f269845c5bd569f715a965d32425c105d285007d2e87c32b80fe925f8098edbc0231fd83560ff8e93e7db84e45899dc5656d1559e1561cd9e1aa98ac2088e9355a92f53414d67fe8be6da0068b631c41b1812356a4126d1dab814ab9f9050d7815df9a4634ab93033a11ac894e253dee12807a7bb887d4a7cb109b3f1c4d7b30c8fff49f76ef4cb174fed3dc613907ee262284924b568175aad1ef4cdd06f8c6d1349a3a60c404ebfb870025a31393ac12b195d957075dfb4a58eb206b5149e06dcfcf58d860c7e9877be6a80d7b422dcf640a3cfcc6a35e217a95994fa9b29066e473de3ef17f4c0bf280af763ae0cc321907f6d4e22c3352bb98f936a646f0bb304796213f667286a99fc246fa19afe9739a0e97153d9ba757ae47b8f688b40288fc1b38d8ba3dc833f33cca41091d59bf7c78d5356708bb177b37697101a2e74e0a235b1c53181d2c6d8ef3378b9f022aba4c7c181af70184c35f2f47a35894f6167bd1143213f9f0ad718c159dbfb1c2b425c2f2b5569d49b34138b16b9a9354792b977bd2b1c8aabaa44a956dcc6430f00e5a9a421cf144122048e666e9e4a5f78606fde5b7caa9fad3306804111b311dc556dceef8c6db36779530ad99fb3aecc5e2b7b038ffd3beea214a10b8e05d9b79ae2030b0d6c4f74530efc2b8911b000815560dece3a8016bbba75fe1fa4e74e5e4b9f30de3ebab2414f0ab2ec608fb0a49e2bedd726e702c2b649f6a13cc26b7eb71ae025dadb4eb09f9964244f8fa555b481878689514d294dd26febdeb5e063690ec316c7b18e7e60229ca0ab816831cb5e67aadb695871ff419b3410b21db93e8428a6560daed6a0d581cb716da61d1bd865f4c5e7f6b3f9f4f2245d140d9ed6caa03e6dc515c142210d59f501b62dc0b8a0f53a11fef9ca9d9b51b1977032c265a95f27987595399c6f3df32fe90e4b1846cb7cb08eb858ec299ceb2f652a00cd93720553ff6bd6d69df4a7d2ff5fca93f7ac8cf3e19eb879944c3df2e51c875efadba7c46d3e45ef75b060b8a3d11bfa156762899f30f660e29bd7e1c0be6bab65f8cd4cc62e5a172d69ba34ebefd5bf3ab59b8715c7aafd38032e832a7bc31f494ba54b8c715fbbf4e196606f45c0fb8c933e62500fc0a381c88164433e3601e7c4a6c0e222aba2a71cfedbc864d0a2cab902d1df97138e1dcb39461d6f92358a9e175c68f0bd9984996d1594172e3a5c5b0d7a8836059b0da92440c7cef30ffcc592a1c55d26a9ccccfae093377490a5e4875cc6c1cd8f9fc130a035064f34c5fec8aa795b379f7e318846a94709d8a99ac5fa746220181492d0427e20d1a81268f69170c0be94c6cf0384788ae031d1a81e652e5bf4aa1db677b29feb107aadad8b803d58dec734c06d94b21d9fd5a8d8ae285ad6555aff21f8bb0d56e053b0a7e30c10ee267a153191a3aec84afeba9c582197c1ca0668968e72810c0ea168f87a295cd8fd616032564b512034e9a8d6aeb9cc9252e944ae639d21cbe8a78363f73ddcdd5db90ebe6489f2af749841f996309a5521c594625bc89b93dc329f203c9ee659b4a6100e9fda9f438604fa9e635f7331a8b900ad574f21ec238394aa2e8d121ecebb7f235802287698518d1172ce315c8f30f7adff3279f60286ab4a0ecd71d83877f33e6f3a0319e4c2d55a12d0c062aa570deeb66763e025913f30d56ddc331ae78740754384d3d484f7db1ad50a1844376a0bc27a67428f073cf7491a16457131ae046d6ffa09ac6389f218e9dc958b988dc6aa78d83cab50927ddc3a21a9dd10872f0d42c92dbd5275f7a220a9a853414e2ecaff03b99768e9e576a173650f609a2045eb57241f46e09ccf0419cc1020573ac10684170d1c6801df8828ef04618d9e17cdd6650e310d34a971c48a56e8df3e3c9c52cbd47754797fa6acc226dc59f17310451ac06c36a9a68e2a72376a39bca9afdf32306959c72f108883a571f7e4a9f6adb7c74022048f031574b70e48f140ef69147f34ee09eee260267615ec6e3e4fb561668438726262a157942347563fddcd9163fb448cd90203102217dbe87485dfaa479cf81df9dcb6aef17870894d7ece28285e3ae53d5ecf062bc2a9d346aaa85d072cad971d75e99afbb2a93007d42572b54025808c6a704e91826aeb8fef3b90e910e329ce3e8755699ae5bb7f1512082eb54d03ce3a8682249329cbeb8ba645168241403dd6ffd42c8904937738f72c51cf8ccec7f92b6b2e9ac6311b7c84f2e1c0ccf6ca222b3a2fc4e67c564a916b54659c0df92a53ef4275213cb5c91735655abed0499042a7708dfc4949faf55f5509f873f73453c98e924c7a1753e0278ff7307e3d7f0ad7a7b28f17d4ff4fba89c08bdedcc6d05b25546021d9d8a918ea12626a1ac256a71629868da04adaa0ff126fba805779f3677f0be74668cdcef40200a209dd682d1e7e96c3a24f2e8d06d6f701f649b35ef38f8402d7961b26525910cc2068e63aa1a0fe433a822aa54a8b38c8cc2afa344605694051b912840550e8a425a4bce221b9972e3effa2036832cbc2bc941504c9e39f3848ced4f5c97b749f69ea29bad431d1260699cd8b80e6417f5df6a856593da0f90858a8dde6e9cf64b5c672b9708c85915b1fd5271b6bf97bc15b50ec94c0fd49f13a4cdc781aafaa6a75139fff937d567bf094b42da321dd8c29f12ecd3d79f5906523a9d36612f2bd0519b787eaf0f30e2b0c6a20a80b4fca48d3709b1507ec98b1a5c9e1b2e19f690057c735eca63e95a8d6a9098a6bb852b42b9f6f5d3d469f19b9b97f67cf6acb77c4308d9aaed2fb437cfcf1ae9b45eb726c2138197fab3345032537d3d6936b07adfe9ca3ff2b75a21d4a4246bd49f29fabd32c85df15c12faf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
