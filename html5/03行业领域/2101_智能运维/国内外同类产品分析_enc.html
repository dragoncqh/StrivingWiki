<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4cf85cbc6e2eef433319cd4f4ba16ae222bf6b77a45986d7df9d46119c17daf2e209ec5ee6ff78c244078676241293cd6cc5573a274d46226d2b7c7c9e6524f5c5104cf5f72ef46a5ccab0be1f2ee0fb0b4409620d780471a034561f61a62d2fccca39f1ce6f220c527dc2987fa696c53720f3ce29c1c190ff82c380940bd3cc908e6a5190578a682a5aba4dec109371fc86db3339b1947ded444528c69677c46a5805c13b0e5f4f049ad8a2bf6938dc86f7e7c846ee1d9d7b387200133ac5af041c1556183964aa800f9538cc084b90bbb33326854a8992ee3d9e8a4f00b737a9c7df4f2ab99fbe5757e5c8cbf1812974253bde82b683c672153985156b8c23dfceb2561c944a500314c995effac56cff0b85e60c556bceba75b29c49dfe44c25ba3026a74a15441e79fa72497ec45e791861ae5571233297c2b620fbf889277c118983ec3433e5ec8d9622d9b7b8681725a863e158f9d47f02cc3fe77408ad64655473787d8aa784cd62742f61750f412665d6a66161def4242b3e1c1a916dbc796bc7a4514002502f3ef1a36b2e566d575c2231033bfddd92c66460de26c14b0ac0e21f5ec2bece92bc8ea101f1f5fd9f6717908bd7cebd30bea7a57b1f42581d50ad66dd3ca4a5410ddbb2214f1229a5db6c667b570def4f06270139cb4c36f1f61999ab02e5d3bc4fb2d7b7a4fae4c59862bc4b90241ea763ee9b32608a1f2e1c9a8f621f71d8eeabab6993c91c850787c3e06a1e6fd86906060cf0c39605b0d986ff0fd3e00fa593e6ef82a4ae65f7a8ae96d779b1f49725cc86b5c1c33786e84c1cb0260e26472a2b5cd1f5d7d0a7c2b904c9891ea7f443543af5215938999a6a256a22495eb51d1b3cea7d58e7d327ad85dccac0a2d487078dd56c21d111e1c5beb5f8bf4b6c50db44f5ffe83fbb9c0fab563579cb3964c393bf0241c4fea788e097d88f9326403802db21dd14f2b88d934372c0bb39997f78baf1fd18a36d8b34a12089277e994628e37763aeca0306359de3ac7fe7a4a9fc2d75845ca872c2e404fda8d985edd53e3d7b04ba5ce34203e073c0d57615e9796cb0f31f14c1711d901cd2935c217efc891d34b27a4a497551aa8877e006e15db800f476acc856117c73fccfe7e2e9881d70e46953590f9c7d523dd7ad96519ef04e54d9ed267b692bcbb0bbe0118e5ed2d5b7c1b6058b47e9ab41b1926c03dba19c20b07f55499ad8b7de8abcd4f798e2aa34e610fd1d417ec726950e4166856953733797650104ca2ce2344393d894d0eaaf07ac8d989c93a0e3c26b12aa9cb51d46f89b5e37d1b143ba0c17b99159e38280ee4a0ad502d77b49bc86bb1ef1ded56d02e58fe609e344f38f63dfe503b51b041e2ea8b8c031a89f344b9cf2beda87cd7fa3f368160d5eee47e762efa640bd12f80bc221eebba464d7847206f2c5287ccf5b132a762d00544b522dff5537014724297176fa09a6556bef2a59528577d904c6868ef174d3d5af8b26f2ec1ef6894d0d66190efc362cf0b14e492dabd6c0594511d875442a360995b3f9e672a13719de327e00a741ec236929c8d8ec0390a2120e8029886b83822adb26cffe82cfa364d59b73c4872a03c47ee324f2c61066f651de6d876aa56af1198d1fd1486614f1df28dfb0d6397a55c5277b5d61ff14f095197057be9c93aec04f6c0adc87954e8032edfe2c338f7ebbd2c860226828948af952e8c0a71ff07c9e4abfbf68cf7700bfd9a106f918c4cd8ef2855db37b1eb18decb934ba8872538ca83d7e273a92ff89408584756a394fb5c9f2c920f9af7e2e326cb379f475cd6c841673362d1eb331131f27f1098111467758adc6535f8cd212e5b9b58778a5607e797fa237f1622efe66a76ba14ccb1cb9381aa0c82c5d3bdaac706a7f458783ee1ee042f9efd6495a6fb8f6b067b24a98ce64faf33af32c9464b5ca60ff6932be7cec81354e693d2389b27b71663663e62a2061ae10472e0cf3ee3b2f002f95aff1137613473adc252ce196dff0ffb5a2c49e40e6dfccccf5ae088b75276cb16d24f237c4f652a85c144b755c6834dd0d2ed18faea4a3d29af8e59a16746e07399b203872d8e7619ec04a54835e06a1f967a47f6086c5c2948290dbe922f900812fbcf1099c2434a3b27618f1a3d8435e9ca7cfd2020d8eb96bd1fd560240aebb1000a29f7fc52985b4b6d7ca9f6457ae6b9cdcbaadb6ab2d2ebb9603ed912b9f79ddbb235c22dce7e7c15b9a20c5bf6183910b937897390a88adf8436eeb8fc6ee6914f8d206b34cef785a0a0f066c69fb2e88e5f3db7f46df2a8b101687583fdc5c7317fb75322427940db23808d602981fd80a330f16b223d6647f07b539e9ea88ba28a07ff02fd85af1d5cf942ab8d404c26c1c18fdbf91250626ad0f50ff7cde2d1275d564a7ae458778fb7787c0e894461b808c8ac4a1410794bfd55260975a81f567c9ae697eaccc0f90fad6d18cb2520e1a338ee603a75ddc8a1aff8d096558d9a2a0f73abab3cbe2d0d77639e1759bb7f300110abe99e6ab01b5f9f94ac0b6ad437686462c45d3df5d13359819fa6cb9e5eb5efebeb1261bb663b35c2679eb60ee07eae46bc992b9006199e8ba2d665ef110a44ee3a4cb25de875aa24f37e48da6c542a3f0c1639e5589c5be8dc5cb62299cefd0fe05473277203acd85c8c22ab6c81cf83327c5af53ef484aaa9d67b9a273cd1f67538e229c68bebe3557108e12ba07b6cea17dcf59344fc6056bb200fe03f2996dde5a06c7840079ecaa9ba17a78661fe6124f1ec190e1dfde3f373a7a32a08148d38d27d8feef4add7cfa2246166315bb951d32bcac021ccda841db9d41aaf6a48fe2bd84fd0dc6d46647576e873377e85ee24c62fe6b88a0acf9c22aa831761d163b41956e07f84f40b8b3b57c506f1e17474aba5f9c123ff2ffd2391c5efc049ba4fdfc4ad6c104170df1985d2e3a94bc6a0a4e3b9d1185b6cde8a59cc9e1460e8e3c97138b65d79c3b4048bb1f986d513d1fa2297d547c8ab6cfc6e2cb4ca35ebe40b22c9bb6ae5d6898c5668b2fa348f9a1d95f5cd7c65cd2195c1172b9fbbdfeebc1235984a49d566a262037265da806dc1fbf98885cc8f07afa0b26189c45d144f55e025301966233b430130307921a3e0d340a6353b0e07816d43f53e9f44474d8e9aacfc9a5e155c45b18286d4d188e3c9ae8e3ac4ed57554a98c303c32ccdba0767f69f37622c99584c8e8e43f4015326bbf1621f4a548657728c86f6d41b92d12afceaf23c70212cdbf5ef93f999d957c1a78d298fdb58ca372d6af24c7b4958816d057222e001fb4b51fa34d0b7dd4bcbee1c207e94e39a58b35e275a0807c7b8fd5f40334e5ca35424912c0cc114bb330e24b0cabfe65a53d0c1b95b158526602f41c75c61ca632299326174386cc6ab082d0f893638b8c6a036ba372db4ce862b0bca1dee9b5bac431dd6003e8aa8c989a25f542e3744ae6abcaf2a3b915d88563c44ee24d64aa5b85574aa2d43072ad7cf3a0941b30bdea48c3fb2eea446acbf73882d65a481f8d0ba84bac107e68b1338457cd62a66e8d8346db524b36e6c5da96e9db1386de0f99382682f2679e6c2745fe3fa3b3f5d2240326ea51d52ac0ffc7a41771db694d678497a11d6e5db616ea625db07072efb7ffa88b778ecf97c46a934e93e36eee52b8e07ac199f1936ea6e1c1bb14846097f826af360027bcb30f7357a7f6a33dcf602eba2dbee496ada7ab44d95dc861776617fd2c74e2a85d92a1a0f015edcc545ca206933b95beb18939b64e7d82d916854609a2e598010e20705632a9ecf120572c947b289bdb7fd69b8d3bfd3d136e57fb9632fc2f0ce462b2822f2d5ce994c1adb1843aa8758f112716a4ac46399447d876c43cf1d0cc1c12263e62cf7d0c89ae5b96d263a97c9f44019102a6aff6bcdb3c157089e3d3e96d68544dc09a4ed0740c7f7d7987922d571550fdb5dbaaaa7149cff6c592ddd50c0716a3608017a9c9db55d7cfd21e1fd7faba1397da3d8896d3c95413f4efcc7e80d1bc0352544577abde3c66b817931f2f109c5c62ed418be512de04baddd851cb8c544f2cf2e6246bd44cea854b30b8ad6a4cbb0a29637ad1e7e6823fd52cd591cd92ae10d26318516d1a6d71d8b11aab9d90abcdfa2b3625cd393ad373ec22d362d5357213bd42f6d892c330b49dcac89dce5a7e403755ecbcee66978c93dafaecb4d55543ed62de1fa9275e14e26dac53a1697a38514ba6ebb8ebdb1fb3aaa15bf079615fb7152ab2ab9e982336abc9049ffefcaca9d99f0b04444d0b46be357d283f588f32a7317c97d7b418af71a3079f32d02da4e4f7cf8406d17123959f89b635fb8efb75400f5a132ab1c966c14228d5f72a50c2e7475683e53a53d1df18aacf1829b8474d944774181f8021645621b4ea98286bf800d45183a08c58b4e4ddf4737052d1f39b706ba1c4f39b46380c6c3d02c17c326e085bde01fe8220e5d785ca2ffe72a348d5210e3f75c3e7df0b450551208c27cf80d8c19b215bd3fb0e580f00597812b0b9e69bcd00d1a4368e6a0d77bb85202663a6fe86cb0e78aa2c4b880b6f8f0314276815b4e7faaa72057d5a065f18805bd3585eb12fde8692792d1c799897dd8d5f83ca37c9c00b0844294a1666835fe38eaf726d93baa595211e618f3036cc1af3c2a7a482d68acdfeba0e9b76c60e22a81e7ce495a083dc8102bed729306fa72b735f493133538d41389660306627d5e137cb187bbf6e2213dfec7a227d732d85120c5850b3ee0f371a76fc11a2b1999c7b2871e9a3c3382af91675564ec3cf59810788997055a337e1832f0d5ca4172366ba47c711872ed83b33948a32247f48e4056769bdd43e56e5e80f07cef29e9026ad226ffb13556880001f079c93da9a88e6f0b783aadb9977ef9233be9f253104f0008de5f71c27d19a9943f3f0c25edc69ae880c8775e777b0e714c9e400d3dc1e6aec69ae3c24244684ab78d96663678757ccf0cf7f1d715fed621ff62e02e9e99edc3291d8da2c3f46f9d99227deba21ec4bdf96d66b66c02e5b673975b872e53a052b8d090270b11be6d625c3c985f98ad3dd0f5c8314bfa8987e5b00d7a7e198ceafb367eca8ad73cd3c73f233b46639196c0afa33ca6a2fa6a31c34a97edb03b70cfca438e4d13f1cf34e1079b3d3275d5663fc30fcfecacec3cdcd5c9595e3c9df09d78e0b330c33742d8bee73f247dc5b25f7d646f167cb6e4c30da2f492fd2a9a80bf061aa89e5711ef5d75b97290e1e922dc1e4ef24a3487db64aca1fa89fcf84e91c4636b024764553aa4b93f1aadfaf7660add0ca307b92a3e42a6d902192580d1a45de08d466c150e4577f0d6e0042ef47c18aea156521b98c01939aa74627b43cec370b31e94181c78003b6a0bdf862646b992681eaf364647c4a8d2a5eab84ea82a716217c6c66585a4068ee7019f4aa2649fc12088a3c6bb55444372a05fe48db61ecbfaf93c0759c462349e7da5580045ada3057f3e97df0302a2c4322938cf5396cbe5cdd48658a832b048c8a015ff3a8399e4a2da06f4c54b7b7ae3f9c8427812e74f0b7f55d0e893084b742478792fe5fc1dfacb3bdf067f4fb607646adba2e5c74cec78ab83d55fee8bb364eb9356dd70b287d52c270e17d8cae2300e7b35f4b57cec3f3785ee08e682314a6454ddff8c0ef81698f2667cd4ee547c05023ce15a89ae2fa35f07f1e749308075406690768ca9945ac31c980508cfb4a5bc9547f8160f7062eb89c1a17f68cad87a0cb66e5c4ed9040e445068762ffc149c9bcbdbd86c452245841e0e1e71656f170d6eb1f497b23df9438ea47c7bdc1c8c0180d2912f358735e177590d71336dfe2da75390fa99a166cc689af39ccf429a4923ba07caf8513154dd52966b606c5980083727f7deabbd676aeea30ed0a4edde86e592be81b84f1029e1ae72a60a125d09979e41bc4e468a27101350fbc0be00a526cc16dfff6d85b4494cbdc2478374597ee0ae9c46f10b94db5740cae52195b6c57e5adb63a4b1a73899afad911bc182940ca1f817f48aac82475409063e8ffb6ce717f4365a05ace24d634b60a5ff3e3e188ef53a28d6b38c4da52fd3fd8c8e2b8f97fab39294d389c374a2f602517b5d16fd9336744f14caf806f3e316800b1fd2a0b70398448309ce6b2e939643dcadb0d6f8032ea73927fd0c0d925f28169cba7ddb3aa2bb6f2f0f5959d138297f07baaac9a64f4af7a11676a4313ed4794d12e7b2fba2a5beb29a421b4a563234abea0ec529acaa24130fbcaee7b098d49716e7c85821a711d5edf374b26b5dce66eabe96e6ccfc35d8224b5b954ea479e7d278d1b05e12f598bc639b9de6ddde86e415ee5d008eeaefcbd78aa58b434b9b4dd0892bd7d5d3926ddd88f8dabea1638f5de4ecaaf04647536d34decd3dd9ef4de4fb7724b9d843df6be93cf7419be15c8efee82867674ac5bec075913af179e245637545417643f6d2166edbef5416d4387889b0022294ce35a955f101682515b9bf291282b07cce609f958c917cb57f7d737fde91c8cd3204d42d8d9a2ef7af7dedcca0c956dadb0ecf3108c2a503a671604adc613636fbc92f8be2bc0d690d41c676e2b49a8ce6326e143392e04b4717bf23ab2bf790938abaede9f7a54260e2a165b8c479c05f64726e5ed66afe5f47b612a97579a1e34ecd68955cf508b2a0cd635ace54815602eabbfb3ac9c8657a3d44745299f7f18e3904d5cbabff9a592d33c5668ec0a1ddc47110f0c7da3f516bb065052bc9e2918e9b34884325c8620fbe9bff3f03244eefb0fce0db465d86c130964b25acd89e59ce13a24538de8998affbd59c0d95cd13989932c6e6db4a113e958159710b5d77f8b92b8cb01e5542ed2fbf55743a007ec77bdd5a3e52e4ba61dfb6b474d82be22bae4574642e48c0fe1226f32ec4ff31d3bcb58f3ad670e77dcc364749dcb6c3a5c90cb7d54532f56651571c8da8cb28cee87a00cfe0dfae45846963c41459551a9cabb1da26451d4caceaed8ce6b916ff6c2817655cc09a66c45f703d4ab69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
