<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b50342898d68fa86da1ab1165d0cf8f58cb2cfbd1f5229fee25ee6ac2dad6c0cd1ffba7782b0ff9bc61f197fe792789d256d2fa0fcf5ee703a71a20faf1e6816053747df98d5f80af053627bf804a6a95d649b7fb22e6f758de24f5836348ae23fc4ec229b4de5ab0bdaf4c18e5072b045d9916f2811a18f09dddbf9943154ff86b1e78b65e93b34754ea502d3be0dbdb58e43b818dc63479cdc75e8bcb8f513f93983d00083118b38ef606c23fb77379b34138680a95b8b8333bb9c7a1e82b44b64897fa68f5e933c80a287738cb233b3c37e262fafc1ea29221ef11842c7d58423add9589b1e0f14d1220eadf74726df854e5f77184b2a10e0003e74544f4744b887fdfea57a92f368dedb3c02122f069f42efb1c6bc3e5e3dabb2c16ccc095ec615826378d7ef3eaef5d25563c8aa6d4ce546b12cf24ed0833639402017380949ffa46a8438d2597e057253ff20ad6f5c0db050b28caf6597991cc1842a157fedd736a7bea24ae7eb30283ab0f1dee871069259d3fb092e41e7f72ea326cb77bd5e9e72a5ea6a35507d3e3aad88abd7c56f28f4db9ee5cea073a0979514d0da3b43576026e8a125f44b80c2b730846926c03f0f94cd019263646168ada2059e3ec6722d39dd0c443d3533f4552a54fe98dea52873734845a511f388c0f44591d1fb0d317a0cc2f5e65c197e565c38667285ed33452699e64a8a416648a046fdcdef63df0e9755348e4bb11f9b4e4a323f06fd2ccc8f38524cbf5640b1f134f9af4468b1a4c67ee9d0cfc14df23de4bee69f73d46b8f8b169811c797d1fe10879afc06ea6e95114253ae01c36fbfb1f672c614068bb6bcb53cd6626f3f7cce4cb8c6092d8be8071286da91110250e5fa9b08d6a58cee7d0f72a7ccdad75afc130d65cbcb4c61b505b650c3b656ac9acb1d180775663c6572c40a5d0a2a6ab10f0e8cbbc1e6c838f1b00283d85fd7fd2aea4836582ee9d8be3eed32b90de795db3120a30de46580bb456fbff5d3cab715cbc3d6c86b36f09a949d6e3930368f897cd4c2f1f8aa702dfaf87bc689c65ad3fa7ec8c905d0d5e6caf2e5038b2f452604995546b6fa34ca0037dd92c6317e04dfbd768b277de247e6bddbe04539901c30704567de87831150fbe0e928ba8c9dc3bf5cde94ca4b10d7383cd5c8843bee407fc73a93f83bf5471d670bf5eaf6e1129c11a80d8a316ed0d5e1d1db11dcc6bbbf4149d8f3942a42a8c8f60943aa4ef3768632a0d0319dbdeb5f21293f4dc8f4ac281dc5ba1ab5f093a660f6e82fba28f125b552ae138c7a49852d7a5beab6a67f82c78cb36a76d203d9100f7c905f47998445044cbb2459b58d3a440a51217fff7935db5201c8bed97ed4ddeffbd2dc31beab6470de2c4ae491c8337fa91843f3acb95525cc5d46ebe16fc687b181d3d45a4999160d482885874566901d24056bf2962f7a63e31297de8107cc11d5ff7d46911bb6e29e8f6e38bedf4d22382896d9e7bf9c4b354517ce1daf03e7b55c9775f285123d09744a67222f72cfa4023ce53624b59b9baecb9b08c79b77bf18ceb3eb100712a7e15163bc681f920bc57a8d321123fa9a75c0929255fe727b39b56412b41fcc7ad428a28178a7f4dee517b7f4867ae0f203b147c6779dfeedfedf6eac6dcf506eac71ebddf350a5b02ffb72e6f2c158fc97f2fd3751eb3bbee3d604157589697bf0986e25ba376bea596559e694391831cd1cfb3f557e5fa67bcd97b227d8eff1bebb99c6168fb09f49965a07429e32f7738b35d952daeeef1c38348d93054e8b4316528890af773dfc6bf7e3d9be2fee6e0b2ee850347ef1d76b4f607adb98630aa44deb1e76b899b22d710934f0696d87c4821ca918c6b27f328c921767c268833032f907aaa98ea231b912b258b982fc40ad88661281814cedb524625bd5d9633df7c3a1b6c6b0836aa6513791595204d5be7d5b2ca4986e325563a960b5ca8c4e1c6764704850bd994f00f76a84f2b4136bdd52ef53686e615f5566845b384980cd46d92c21b6b4f8c26456415fbfd4e748ae834f7bcfe27938ad7273c411c25b3a86644eec2d1cf9c00ca4631ac67dac5824815d4d9edd1623e0a862a2da50d3ae200d455581caf2b121c6df5c44e1ec1091b7e358a82e8bfe425026415ffc417c7c97e4d525851adf41dc97336dea89f89945ce3ae8545eeec53594637c96482be8bb90373cfd5b694ac103467c5a852752983e0bb9a8252d61588ac5306994587be8a9b2069100de7ec6c2f5c5ef6ba1ad4d2060285550145730d9a72c10c5ffdef35105e920bef719609560cfef539783b8df1e20f0d8493e80cc6373d717325380b1029b67ca815f6a60cd0a2158340158c327f3243d2498b02065731756ed3ad290f9ec348f5c7775b5d880f8724d9b6f791bc93d369b4849ae02a48dcb8a31b3c28ffd7974f287dea2b9ff66eed02b6781141a46afcbc5b15a283fe02eb705701d5350e9047060779a3ba3c21a391a2c0ace9648cb45a0eedee06990a33c3a3f80bcb331f1013bb1202d100fb8d8f9e19e9f56f1ce8bb9be599e57cc3645cff4a8265993e3547f320fe7503019457dde66fa6af2f1dd15d7cd11b23ddb75f3ff233c16581150589708243a2391dc16a07d6dcd0e57f8f4e762c7c2dbfe08dbbc2659a4383400a0a3382455415ed332073a5e027685c0bf5e9c8a63066b8dd83a8bb0ae327a0d827010ee6fad06d5b50eabd13d3afdd7c38f068f7bab292b3b9eb89c998ceede3a95ca0a9990a0175a1bdda347c0faddb4e885f4ae12dd28b0d78f7b2413d514d5ac0fa875f969035c66241bfb89d8b45bec3e3acc3e0bdb1bd3c1a08261aead505af3ce5ad1fc44807d8aa9d7b496b20f9e357bcce0621671494cf7fa3a971747acb5a62f3848341d609bfffbfc7c98e7f0b959aa6f96d4328b9d0c2f9c8c903067375dbb39ed917ed229b253fdc75247d4ea42e1de1bf311e178fd3200f226bbbb63ad01986e8408edc742039a8f9f58bb38a0b04c92b2f9c7db0660d8f79c5ab57074d3004e0728bf81cda0c91ca4920c0a461d2906494a423909a250c94bfe1befa6c57f73c13243cc801bc38ababeac3ab02fda0d02792086c1df0217bacb75a614bac259cd245a442571665b99d06bc573a6e346858cb04f45322f6c5695db4de73357a29681d913b9d9101c4cc1f2c715cb3473d8c507decc48755f6d39909e4b470d7ea746ee136209bd73d88b8c99f91e5f4b394974bce72a9145f29abef394ef7b303785a4bf14ab1320527db04e83a7ed47218e92e4876af52878f944a1c4fe8f940f5b02d4f0bf1b8a04c002a7d37c12b16dcafb30a6cf84d8dfe8ba2f88d4c97e6d5884ebe11c822fe1071fe6d8646487a86db4e25d0e68853ce80ef071c2187aeb49fe2f723d9f376d797361b4bd9433434ac20c01e3d551c69969b2fe6c381f6afbc33830ab593a1b7f78c96821c118faa2298c0e7835cfed6df381a9b7d85987b70cd16aef884559daf098747b4c95526b7a758275d5fc25d4900ffeb0453d45f425ddccb4a5eb81442f0ae64547bdcc6f50b7e13ed86fc40c2c83cbc358290cf9cbb5dc28c74ee6483b3a8ccd436a1c4a9f96bb91bfe86ecd684cd36797c5927815123b834067800356eb49bd8cae9211c34ce694b46999723491314935c665de3ecba09741ad8c1bb95e70a1a1c1bb009325aa3737e438768bd9b9436d8679af641ff2c91509d9bdec443fdc61690cb75fbc5160fdae055af8983c697b68f0148283f246ec11bf6b53dd2581187c755ce6be4919bcbe397717cbd7f76a82a1607267fd3c9d07e22030dfdd5a7cfd6ecf64d8299b973bbf46a9eb743c6247d16c1828ddad9aaf558bd78b043d9f7521fa9e224ecb6b53190260ea4b3715f7b6939bee6f77ddf8645af2c82261b7dd2df37467199017fad1f074640ebf6424f9414d74a8acb2902444c1e2a8865d4246a456bc780fc0ec0879a8e96eaae33f20852eecbb31e380e8d75edc03e36ee67bc24fbf7022c180867a29bd850f47bf8d12a792119f0df478d6554b451620774e0ee5a0e40adc9ff89a009c928b11f36e2636d35027a33e3ae557dd21bab43e5214c2c2143a062e8491d8f024119cb0fd34e14eee8d9fa7b38d7bfa217672c7a92329ed8f59785aa4f9236762ca37f92560a557ccd756f1c1eaefe3a517f1432bba3bfeac12d381d3040121d5a9da1c608b6e393e6f32acb1604ff2ddcae86cb88770163266dd63280b3d699957e967bbcfcf46bfc1bae7cb0dcd3fc0e031136cfaa3dd9b017a48111adb3eb0b4c10de90baf768ce59246266e3d822ab951ba752da20af978f1fd06a9b1ed1bf399b5d0df0e373ac2ee10e60097349350e9e5323984b1fe58ec75bd8a6ab10a495ca7f480f18c5a4250a24953cfc3583ed3d3e7c9fccbe45aafd7e3acbc8955e2979cb3babe5c0dafa68ed64a90841a0ca632a54da78989f6cfedd3051aa6ca8dddf73f696cd0c5148f430f77fcbbfba7c8b5d57f5513bdc93a1ac74693eff2b501d45d7a3002df7a79fed2197868db8c3a3b2b2715104000f2207094d202c9ac8ade0aebf14d3247a25e141125cd0e5f66c29546dd7ab7d38eab78b06428aa9f91ae237b2a5a485e793eee47fdeebc27f27b2baf1630349061f13ae6180ff358df2e4eb67be22250ed1e195c91ed0a04b49ae39704171bdb8c20ca465a3b95070410cf26017627a6b2aad550a55de8a1fc0e5f638e1b0edc3420062b39d186f8eb58a243664fd36de528b086693635fdb82460359117a033cdbde5835e704afa63e0129953da90a82547cf05912de7aa4558a5745a204acfbb5d5b979d886b3a493f5890071ee897d929e1f9fbcc0d66a3c71c5552299ae119c730f42eff30cd53afbeda07f5db46f3b9bbb4efb6d8c2bf8f4972e7d132e71d9bcff71c30b3f5982a460b43e640255d9d749765e59e110021045790a804069dc9ec8f31f234969549877cb949583812a35f30a9049791d795860d3c912160e22b1cd943444b6d86fc572510e2f6d6694a6cbd11647a2421dfabfd4de35b049908d016854dafca71cc9aa44fc368b3ab8beadd70df6473050e4a9f0f3b0c38bc3813dc7c0c1df141d0dcc0c70f14eb1bb6589241a3c3c22b228471be2ad8b591398629d8cb305cd13254c99b4e8f0176ad8c9aa4923deb382d96039716b023539b9bd30570700940108b6ffc0b64214174632d8ed04185ed00de212e3c57c75715db49271919351d036db5f3233a3db76e765b8eb62fe42d3df12e50c25996cd5598ea0582d3da7f8e689dd91ee6da6d35e509ed5389c31a4b66b7d181764d7dc140fd03d3d9bb392367a34912474c9fda8282c4ea24225c6fc28b9b66b670ea4f1d8def6f74c8c7173e81459e9738d209ac29919deff5b7ba3eff975708c29f834baf79327612f8868288144ae02b61aeeea732571b172ff302f91d0346fb6925aa83feb97af7b0afbdd94e5990f81a9d456d8c17930d58f44b25d3f98cd33d33eba9dad1ba8bbfa3b22b3ab4e4cc4ba9393ea213e46944317ce0e113be31b394d198ef259fa59d955e06c2ad8633b9e36208c0f4a210d2f6c49e46f5d477c3956c5c9689e7268bf2753e411cdbdd78677056be7cbadcf709d7c8adfc4c4f01ff0c5da3d833fef9699033b4b254022a81da3a87c37adf45562d7a341cc4b0683d6cff65a8f4292b1533c9f2421bf829d13edde497ce4c970692b20851de51394017807d6155fe9d912ef1e0857afaef1e7d1868759a669bef1af0fae8f5dca7621a08699b0f2e59303e79b8e4179923aac837b1e0defa9b15e336bdc335404069b4e49690862b4370c3a27af3d5774ed7c59ccaa3b5da12890ffa53713091652a7b6404df4d4343cee1e11b5fbf792e6f48a2965af9a292e04665c08d6016d28d4d0bb7b61b3a27da04a4afd78acfa6f8fc0753ea625f244f9731b1ede0f3311cd6a3d0f38702d09c2c2105d5895a217dc5cc53f23db9bb720d0618d4795e964ec5fc2ab3e227bee311c9396282074b53ffe72e208e377a4127a7d5157154c7df4655d21dfd29b6d5898590316f17931322cd0dcc8b901c16d85ec24387638107a1817fd0c5a819a317f73d7a30d041572a5ae3b2c1a301b1e7e35466f2e6175a71e71a5ad671256925e6b4b15416d4ea3881a3c0755b095cc2660fecd1df621faf718e6713706a23457a9b04d99c7f0dd5fd2fdcb9acd903488beec306a02214413e1a457abcfb594aac609b9887c23c80112ef8fa8d3b9d2cf741c74f054c3c338c67974a6bff39d5c18bdc7d2418dd72b72eca8fde8556304e85fb14b46ba25c5e682a66fc98cd72a964dbb8b64279e42d921fc025fec4f50425f753d60722e029350bab18773bbed76b0bf0562c40e856ed661e428398d9ed14d58149f1ff8b0ef5842fe454d9eee67967021fe9de0268adc86daa265d53303cef9170c9bf279d6b649625d15e33aefa3d25fbd948c957584f5e6b9fe1aa224fdcfaff04823bc1afbe5c5d18e2ca051c0a8dcc346a746ffa4d3b4719386f009fa859783f5789b69d13e2429c28421f9b959a2f488fa27aaf2e26bfc80b994d37b7959e24360be262d997c9ceffa08044d1f1305e3e5e7ad3ae9111e8c6c4242c1448731fc8480dceb4b4df98cc5711e2f23285cefb21399be6253eb2a5c08f70766cd15fab88671b844feea7b0d5f77d96ffcd309da1c7a4cf0a309cc0f2e450ae5f6f73e01d2eba77c380dd8aba565015c3ac69ced7f95210ba9de5afcabbeba8b4658984aae6dc5454db3dc2f3ca35991b3bee53e0b9542a901c668151ff2002d3b107305212377ceaa17920524586690310415abebacdba38bd70dc1dd80bdefffdaec6c5da6b2f114e6757d66ab2f4427da5e587cd02e213e97f60992ab54b3c374d77c8e10f8de8d1ce14e58e4a15cc8b6dccf58541f97c9f90feb9753999aaf84332e0b15801b44198ad5c0d3c953a84899a864741a5cddbc3576f344df1ea15dd30ecd8e87488c60772e0fd8241034e748cbcfeba45988a1d44a6c3f0437fd40b9ce486d7b0b786efc86cc2eabe11fad6a30cf3ef36a871006b39afd78ee54ff6b3930e39be2a591b28df39ab5aaed8d309a38072cbd9821eab33997b18f36a95184f5f075b132538603ad4c0ea40819adde0ebb191368c7635e184a2bb638e6a4119318a1600db1138b1bd5b690a33cd71c45cb777e9f104ef3771d4cfbbcc6215d70405738e7f510e09ffac5c25a2fd16abe0a89e54a46989a820978b2b616d007cc5898b27216b2a4cda5081db72a1e4e339cf35d79dcdb7de2fa224381775b27a57e2cbc4817e41404e332742b4f3b1ecaaff1605f868c68c9825deca4eb914559659c899f14865b27551ad84fc405f80629479fb2f3cffa20ea8005f3a72308de4fa31b3ebe39888432923f8bc4f45bba64ddab64fd6d2f875900f09a164b33a52d949cafdcf3f3eee87857682fb45c13a46e2a5d3a2b19045d4b30c05fa1c23b4831e0ea35a2533c6dc55bea25566e5cadf50b5b521a416d9da246c330d5388ad46ea599ee716578ce00915964a281958629a4900cd7b75e9d7f20343250f342ab5f92b4d7106ded6badc1ae19bb5f09e4a4d02021c13ae46ec414ffeba0a1cbe606629b84b92d538e1b4cd9aebe7de592e02934aa223634db27142066a163f20965e17cf78a8e59d47d20490550bccf4cdd8e6a2ac47fd7edac983e6ee0f152c63d7790522fb04c8ad123e2fe2789474200e2d807f2fd23af83f40190f35ecdbfc5acc82da70a6356300b2ea7f516b08d837acc65998790cf2fe4d4ef227ce2460d777291e0e455bd1105a578f364081396e56ad820ea2efadae7f26ac746f1004a2959817d2189e29638168628352bf89aafd6a26dfae667e84f4e127288d7af35a18376c3507d96739373c8724bc493fec8503c5103e3807b13886891c9741d992f0ab581ca2cb846265064caca7909dcb78b7876396b4eda6a118da3b9a978d4e94a09adbf90a7f47e878d3e3d9d2343257e4ff5dfca04dbda71b738811f166a8284e47db6bea3dcdd0873dbd687ae587c6321a3ec47b0178b9f0ab601ccdb89aa280101e819d5b15ce617f0f7c5ddc434a048246c52370c701fc505df7045ce4a7efc8d1307078d1b54adde4277ebd679b27d1ed2dbb9df121bf7ab0646328e95e6cc4f59dd6163882c789eb5895aa3e13df7d689426c96818353b1a0ba8bb4ad5b2850c2d64487860b307f91326796ba31e83d4bbc10c3c193b96665a1e1753768a03f4aafbef950a4592cf7eb3f2072cfad02a5b5df3c9678aeb0b1d251a9a215423de28294d634de7cd7f8c86764e04b19b06f5e723c6e0f32abebf23a6ab237b7a0f8bcd566708617671c9e3835a4ab8dfa5f6e7acbbb0dd1b20967e7a08ddebad8f46d02df9fb005d8c435490a8aaf1d42d450a51100563b7b4fabb66188c34945d027aab8a4ccf1c7b7524458940c6e945f454fe765cbc5ce0603fa43fa22fbc2e1605fe114543f884ed06f5a31a8df62b05c79fa670ea507bcae080e4698361616a56c9b857627a15d6a493fc264f61cd67dd066c1b7022684542edfce869ff909bbbf52878c67b1b572e7f5ba1068ed3745f8a1e4e689b74a5678034a01cc5cd35bdb2ca610c7a00b4d988eb66f17f4e675ee8fc578f560331d882f065951b6ad5ff08e27140dc4f6cdd90b5877785c6a4c0a8575cdf723ce88522c1765fe3cf9899a5e29d14bcc8d43eb0fea722e48d6af9745696c9c9d362a9021c602d533e011a1f3118974c4951b2e0f993fa26bdb718cb333e685055b90fb91a04a286f6602550fc151f08c1d664844a8df96ec723e24f85211a4e86e808ca3750e2fc230bdc6dcd19a1c67d5376104944fa8e19799e3546f1513c50da72e067f4b0f5f98d6b95742b4dd3b62569db9efa747df9d89373915aad9a259a2bfeaefd9e7ae5462fc9577b2b6640c3cedf2c1419b80c1fb14b2f1ec504209702408187f098d68c564aac7f970c463e12c1eab819712d0b850efaab7a6bd7e9443428cf02a8b4a6ba5ad33a5e93cfa85f30a32823efbad61842a32327c6586f0c39f85d8c80d1e74a3d02fb302bf0c6421930d51fb4175471cdaa1fbb66f621625c1f779611230e1508ab46be8eb2937517aa4e4bb8e3be69a03fd41227c648d3636b84fad25d8dfa93a17cf87b3973126d3df27170df132b3776eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
