<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6eeb9a8b3a1e1983c1939e2697d473e64a14f491356cc46d4b4bcd5bbea1f2b041b64391611b12be6d4ac714ccff29090fa4dd746ecf1d70541848aabe11243cc9c92ffd72d8f0857b8096afae6cd9a6e89a2c3d48f01042c4eb97720a98dffbf4a8fbba72d4ab5d9bdf46ade4cbcd4f82157dec50fa5ce37ce0e449ddab4b4ed1a26d4f1b829b33d83ad44d5598cfbfd72163f6960044ea855ce55115becc1000686f4261cc0ea079ddf3fff78578f6cebc2ac486f8b458e8231426243026197afc51aa37dca95baa04a608f714bdde4e343b30989667501049ba273a552e600c15991fd642bbb5f62dcb20168f503131be92b58fa4eb8fa554c9f38d991a05ba7d717962a53fe3d96b9d21a937bc1d6d71205fdc253ee09b534ceb101d6de007da1fff280a337f048caed8cb90b49b09c497d2795b79061596b9768c05269b03350d03057417b4bd697c759f91b817795a80ae5e61e98bb44a7ef46897118026e6bad8570860706104ba0e7c82587b3dd73982bc34b57bc2596b4de17299c37a952cf244b0349ca1d022dd360bfbdb4a2d36f998bfd45ac342ed42a2f43876c5a8c070f087ab53305c0171272cb6014cd39693084a1fefc34ae16c463a78dab27d9fc1f4159df2211ec3bf2c6e3f5c472f6a5c139ae9da58701762f9c6f3a817bd69101b237ed23d05c2d1012ca6f3ab21aef7c723355b37f84a9fb0f4c495e88ed0867c27903f7978920cd50e5a99d564acac520ec0213941b05c87aa4f734e00b26bb5558fe998e567f95f454bb50a6d9301a93aac7b4e72e9bd47b9be30fe3bc0060cd6a809f66e1b2a922e6b9ec1b1afaa1567cba7238b14ba1d736bdfefc74fa818e0512a660721a15681300edbf85bb95be59d4b369975bd5f13fe594f55c4e96d3f77643dc8e580a18cd8d652fa12797d47bc786b97ca563b075b3bad7dac2e1d40226b574a0b22dcbf04f93ffd7daa241f4fd0a24ecd165ac92d19eb5f262df1e473e32899e32f0d3d4e7a08def220d0b5fbb1c63e4527bac2582564473610c6a8150d5ec1ab304d529ba9d68fd7bd96b09892fd2538a8b5cca00631ed6efcdbbb70f1140688730e90794b9c2678f2e097a9086ab16b9029814051a00d673cba4123246b904eafc20624e2749b76d4e3d954e51007b15f50f80615cfaf4dc4ee9b278a1cb2a4a2b98dabf7e7ed56cbe15ee065b100456be2a9fe78187a0020183a9eabd23344518f7d1ccc0ff00e3af7f5fd828e6b666b5ab96fc8a79a694c9161043f0b708d527859e5136ef29c0f8163554cdb4269f58fbc2b59e8ca905403cdefac54b607b58fef2c6732d4e2d1a2348dff96198bcbbd58cfa06683919d02a71da44c6c674403524e51ba7826d0842036bfdd3f6cd62f4ff3b8be27017d3618006b4816100250f997fbd27519fb5464154cb098f7c231b917ff93d59e97c1b012d196dc8d2fa8096ce3282a1eb774d669d2eadf4e03c651dade7afb7f5e40929c47ed06307f5488db3dd143d0de7824014d78042ba9d9921524b0822f692e82db45fbb806e74babc8d836795d872f41fdf2e3ebe732683626e471568b39b0d438c84a5820c1ec4ca25b7e68285f6b8376a85c48d2432ca40998bf49b0a41e4981b2c2cb00ed625c3394c16682ab94749181fee4d3f404d1f4900651d8a0306d8f462cfd36d5950d803f02b396621a140544b183c3e2c96f69869d441bf00f527db72751305f016581bd233024ab0b2f234707bba37f171ad0996407965ac388ea1df7032a44d55a538545c2bdf2c2008706e8ba11aead47e01010c5ce91cead7142f6e24bfb30beef8810d4f4f0c4a66217c405d5ef063eff798d57882f539510b28efe607f87fc7ec07f5f3003d969300602278ec7629179bc2d080252f752004c12400c253e14ee72918660ed653007f317eec51984184575fad25089e4457a551d1c8aa15dd3b60fc9bf0c40c1aa25e70b08d839e85b617c0b7e402838e4acb2765a8ae6167905396342677f96924d01291a77c7c2e15dbbd1466fc1a2eb1f86d0e5a379cf245273b5340c2c25acce2e1c6b5057b0c0ac8aca3780825b597183a67492d0a7d816b465d26b21a1c6b49db6bae61bd5827e73aa00e4e74ddf9a399ce32711a4e055d775c26e7e7675b00bc64d4569cd27b864a1ed5193d544417f40cf0040498710590c8e2a42f1ed97b78a43236f81c31ec1df0b4c38fc911fe8f2da5bb934565accbd103acbbf3a4d05e825e73fb87eb33843f1c4601e10145581a276455c1482037a57568c3cac0514b24d11b5a23f5df243ac539db6b61dce6e7bb6d4e4d6791932548d0432a188be1f12e996c48b62746729837ff8c94e762fc86de23e8cba6ce2e112148f000b8fdb2ece6027ab1c82b1decbd4563e7b74ad8b5f9ac771ff0d4c24aa4af8fd5356bde42c86c2634d0f1aaae366d492ed78ef98143cc73c35b95cf70fe51fa43e4209435fc2a48f64157c1790dca8534acae308852b3c313286f17fe59658062e13dbd8a400c72d78ede8c0f57caa00eb0190ebdc4e29978e23b76ff8e9cdaa635520729ee5110aa5e5c094bf5925b4a888e61a3468cb58b5e079631242553114133300525c9af7b330dee209072b72f856e87406ff2c5c3a8fce31233e3f7b9c0b2db11868540c8cbce0d0b9571008cbbd3023d29af1bf3e33b6af0335b9d17b8476aa91d6204f9a6b31f5ff13cf5e5c055b17a5b98ea04f8128ed96bd9b933637784a330b996e90a4b5c89586fef317dae13334f1c9136bb36f9a8dac8a7c34e9799fafa055fe1ac76d46d040bd187d5c751ee213935813f201cbaaf18580e1a278105ad4dc9f74a3525d73f55fb80432173a0d6ea9a31cb598cdefaae6ac869d0c6a3d48f590490bd488dabd5ad2b23a79d37002599de60674aa12148e672b1f7c4ace5b5fc731929c3a332a712ac1c896eac130fe2b637f509c625fe51d58b6466ac081c45ef77e64b5f882b51cca4de3e23dd5a60096258b63b36e03091315872e7ddb3834adbcd4f521a4c8ee84caa4640b857b07d67daeae8927044472bd29058665dcea65a2a533202243532beab61a45399461c4e5d4dc77b7710aa98f8b5d48f9a57b4e81911d841c5b3010419a93893ce672f399e2bc0fed8629b366f295b1157e4a2e9823497a09b3c64eae80ddd665a419c90a44b4dd23a3c14c5cc9893ff909be7455c48a80aef66f523e6702482203cfd244ef1dfbec20cd3553ae52c6d8404e5c8e4555680d16078eb89c945f257cb52b7fc30543f578157db581ff3ba7145c780533f70573074456fdb5cdebd3d189e5e13f00667f5177a446cf21803f96f1b5bc572fc7042700f75cd47cf2f07f938731d1a1f674b9bbaf840add4a3c9e3ed817c822dae0146297082a13afddd4ad2ed8586712129f46bcb08b320bef156981f161ff410397415b20293f0a659e795cba16040ef04d7e2581423b718aba7ced95c370577038ec81f35a004e091bdbdccdce6b2f4dfeadbac504c8414bd1794096c0e3aa0d2853f59d2e0fe23c9b900200ef9b066e8d9d4809c73c47eaa688f2e9739f5c61fbc45d5b8654738f10ec6901e7506147f084a1af37c6e867739ab18adf12bfc3a5e053893e7c081d45e2a246290bd89351b0bb4f0b69f61b4be7ecbecc8f5a160ec8cf9318aa4e828043bc5257d6f33b2d5c78a92444958785a5788b33db948b9f0b8510ef5c687a9f2fb2d34d9a19e7f06d8dfba60fc1bc5a76baa443d2cc1e48e6481ace5305344cb3b45f3f810f132059894cda47fa6141610c65f32b8c6ae9805ae98f410575b8be10ffb1f66d79d0ece0165c611290fccef7a84119c1724c2694ec539fc1d9c8573bff826b92fe212a396089e7ac1e5cfedb9eec3358ad0962f75f90992e4daebd397ff8c24de5e2f44b3f235590f4ea33a54a02697b344d393a7ec46feba0e623c940ede3561a2a9b07013b49850b14289e46325644d2e1d71700afd65d5ba9c9e55250c36bb4ca92e27ca7794964828c0a3a2ddf7077ec2e91f77a32a45597b3485994ff54df8279c53f77b767ff6f6f78c98d41552796886a7b1db146ce8f153df5185ec55c8d5720f8a8b72461124b524ea523506583a69817afa669853bc388b94121231293363aba14cffb4d8481c94dd95d115bf3b21d2e71d2932be5166f0fbb0637a9a72761041184c9f22aad29625e22ebad4e45092ddae944b9971cc05c8df01c6214ade46a046271afdf040ad3bf20064bdefdb465b85c9fc31447b197a440061492c1203b9ec9d17b1b79b95c9c6a8e19fe95756f0994ad76b0fa8be131cac0136ed14db7060bb175a07130fe1e450a56171709b59e13c2263b029cc5aa71dce5b99848377811e26a41d539f8ab1789026baf4441015cc01047ecd54eda0ba12dfeb8ede9230ee687ef294baea435cef96894463524478536239e23d4544fe475164cfb3fc7ebca43424bec108135fa3bd2079dcdc0accb39b992af1be4c2416f8b74dabc2315d8db6437271b396145c2631e131cbf7201dd8858f9a567178f85489d032eeefa2f35b5ecc4787faf2690627b6527568be8faf88613291772455e04bbf2be03384468bd9c69ac2a80934f226fec766acf30b8721a0ed3842888a6876ba6c1233f6cdc4d0d449e23bd23cffac7794d381bbce1decb3b54ef242fbcda46b18b7238457de7138fba4074fdfd7a1b8ab7e3c3cfee50224eeee3d6a85582987b8bf1038921988c955cbe228122bb8b2c0353bd041249fdb1bca2190ff975db3e3dd901cd0adeea21ce768bd3a088c519c6c2c624a743ab93b405ad87d8ea55c072e9c7d8c5dc01955cceddc779bdff027dccb92e162990875fbb9c8ba6b6141cb06b712dbfb3d372498a949c1b71260e1792493f9a71fc507640c45af44f9613a36fdad45ee21d8ff1571295cb594bd7b6014c1ecb79dc826d0ae57e44b6e21972a5d35a1768a17738446b2d8a0b9dfc4ce2e8e557fdf78f58ec2f2e98b07ada7e2c0a2b9c157f613e1f8eec2828eba6d48bc5ec9051ef2a2b11ae572690049d0d0cf27abef991bc3bf27df425f689af393e1439226f723ce75e8ce4e1fe902f2ca3d49008f463d0248b9ce6c7d74f61a1d99d7362423f6c0f2531421155f853c0f2aaf0147881d8af153726a7c0500de964c9930cf96b0adb998888683f3347665e434af984fde840e31c82156b334398634d450651279ec48fb620e59f92819de7c5045829ad5457b692f06b16db32eea6e00f0627267bf14a3fa7c3e14bdfd63b121eb13c69a88fd57b06fe9023b7b467840526ae9317b6cc9e3bcf0d8278e40d0722778573b2b1fb2f46b95fab4c285b9d4a2357d515827b1c3c27b5494be60543e6d5561400c566ea7862678878701dd06f590354a1b84d7d66ff072b6a36b94711e22499bc8216544e80a2ce2c77c08797ce95dc3be332fba2022cd20f378781a9a476bfa788e78b3ba07d696f28dec350e5ddd77a55a43a9770f8c58e699175fcf55ad68659739808ed716eddb5b76a45969fdfabd4ecd4b28e854453fed9e43e1ee18369dae92bebfb11fa85aead5c3fb60dd214d3979be44a1ce3bd84a4347e62de3aa6a626bbc3b2b699a1c52d4720a57daf8c953c86bea6cc8ad74faf1d995220f15aff90fbe861575681d7fc730c4e5858f12dfc71045e4d9b61107ff6f30a5609134473e2ab0a224f907dc28831411dac45f136825016ca4b4708351abb67d9e043cc5bbeb3eaba69e0cafe4514e2aac3275581f9a2464008edcaffe87b86344ff69c64fe65614d11aeb342b2558bb95cc3d94190bba58f36804df42aa686f7305dbdbc20491170564e3c35d8aa248ba8bb4f4bb24f5c04cc3e39ce5bf7d82f855efffb9f7bba9ee8a45a6797243a78090936aa79d74df40173cc4bbde553dbdbdb9b1d151cb9f8fceae1d76f74b16d923d829ad3b46a67ab1a8351e60253852c2aa350e2d9adc851ed7ca92b0a58567a0ceb32a11a0d76148e64c9e0190b2c4dee54f346be3f6d6c5d1f27111af4ae6a0b2e9bf46f546b3dd54d2804c18fd830794f2cd986282ece9183c911511305160fe017e49fcbadf5ac482f9b1acb4335967ee6020fff3ecd67c3b036e836249362163ce5ed3c4d505ffbbb3729296f1d580160bc36caab59835a1d04578c287815bd1c3932be1d1769eb1dc4784befdf9caa6a15c8002b89b33b6fd85eb7315b5f04c93be5c1330d9994c002e45a33907adfdabeda8cb5650dc97027b07e3d2192fd754af71cda10d49cb656d619aca08544bae18072c45de370a45c5eb45ff1fde35bfa7c23e3e67cd257da74f2156384f474e8785e21e88f5167d365f10b4a7cef6879526fdd1ebbf086984316eb05e90faef6e88d3ea584c61617ff7c37555fd050b3d7ad1badbf11b03d36dffd49f6a3468ce50cd62cb11741e6e2a99d2a532e448e25362845f953088713dc251ff6bb77a7dab9ab00e96ac1f626c6c39ccbec0694ac99c422bac670e19c47ef6508d9c571248b2ce0320be6ec645fbb1da31903a2f7ccbf47d9269c5f3ba308d506254d7aacf9a9e4319394445d0e4c5554347e447b3bdcbba5146e9c2c4a2d81c5588c5395617ed4e920df7668e2571167755f3e04edcb04b70a72e1c74406d959e1a59439ece5fe0efc8af1270bcc6d3a66be5752693cb617fc2401ae006123a1ec26a8a1afb885364490c03c0b87440603681bb24e7ecbc5fd89a28e3f1e535f9a1eb76eeb54d261e2e96705b3954f2e1913a2e5f71c887e27c7c5ec261ebb0a1fddad1ef3bf7bf0e173ae0f5be7d90774fb8b87505f6a72d6a90aadcfb82318c1066867271e8787eb63070ebc4d91d79c7b62ac30623e3b3394d187dab83c9218fff23fee622ec1714dc605c399dc7be43c286c14afff93088a85fd081064e11301bec0450ae1492e1415f2da404954bc3cfb7d75cf0028361678f3b17fd87f6ac017c8c53fc5fc71c8487f9c31bdcd15529e339d509910ea55187d471e2db5c6ad3b0a932d1500f88609d7a713932db861315cd8971dc9f44d85cc7e7c75e6cc56bb050d7919b51167550a1b6a09e3b5c862752e2e5ec9da62b0aaf34e901ca6d1705b631867eaaad5f24cd00de09a4d532365bf8ef1710a93c59ab0b036c09dcfc829a715bbf70f732837f26bed0f414fd80eb3a48c2581f220c84bb3459f378ac011c90c5aa6c12398429d7e4a5e93f00f93f4cfec28738e02dcf40dbba61238aaf43957f4f6adec4aa601b80101c1fb04c50fc81f4e2c6d7a8459a45b639dcebf795fcde229efda20a13f4e04f5caca2d2c870f2bbfc2f8db37b30c04d930c2b8eb68109df1d16598de8a4e2ca570f69db50c244fbf94cf54ee559515f0821ddb713f93cca1e48671a5dd4a7fd114d4ecf23c4872dd82bd5d8fb198d1ba18ca70fd2e61c2652320c2ff8e3df5ce9bbf70980c9d5e56ba1acc1aa85345d2e185bf5817d3e8bc9041d7136a36ffff1c6a696d4e8889f464f700b4f91d09306325188b5f64d8229938c038e78b8adf292bc9c32742b649c3ed5622dddd1306ba15a30775237613a4a845fe04d915dda112860d219aeb584680914d772a6a5b8213f16e9295ec7aed82c834c11bdaeed9a104343fb86f9492e62da2f6bf30680a131b08158fccc9aa183b437f941e5024b46fec97ab62ae4520a52a9e13dd361f9d8c452966a852cd6fb7033ac8ef2386e895da71e006bcf13ceda67a6fc749a85438905a58d15f4f5e9255763589e720f3a29bb85f126d4e95acc0b264fe2ad6d5e2713695f56d6465735ca8e3f540c38f673737afa72cd4163a8a2f62519e3e7d0a781024405152a441539bdad4e24cc83b4283f59d4842061b5c161df986ba1849db4c3561b20f64f0e71e3274e0172bba5638eb2fd58c26f4dc8d8d0c4feac9ef8b8d96d726b240d4ccd79e9e795b9030d4ae1e1866235bbe7f07eeb201261abd790a99522585cdc9a9924a8c572901ece25fbc77fbd8afdd34131c12282d40287057e7a380b446c6ce7f48efa783b0956dc9f256d7029260bf5a1e9f8597952895aaf5ff01a9af1fd416e2b0230b2aad1bc199bbbf7541e905cc3e794edd050218ed2d79db64eaf8f45a6a3deea9215150cb37daed929b24e1a012fd8238efc4db70cafa2eb28c3f33f32744d763c482b494828b9ecb61804dfeaa1a71b9439185b55e1ba0395d085020eae5fb08a0a41747da85a87f97d24a0e31228be9a2762c1a9fa27c6c478a9363128890447aceab63003580fe4213055a757536b7097709ee89b5de1a3353c678c3597c660284169f7b6cce767beb8de10af7eca29a4857bbe3fba7f9246509a54bfff91a08bf9c3231faf4f31a51e181112cfc86bd1cae93fdd749414905dee5b234e15d4c0df297d9576d8e635a87bf60e957551c7c6c41d7ffd1b0c123257889acd1176935b23dcf88d5c028eb0ababda383cbe2e8b06abef36b14136317713dec53182ed5c769bb9f844a0ed7b3b2ea1b55414347c82a39b692e07a9e36484abe0c8f7d12548ac027552eeff37334ff25fa0102d82b7f436850d3fc606a40fdefb83439b36a50736763064f2f4996e71b81e77c7c3b43e42823a04c8c310ee0490487b40eb6bfb867b232498d7d6ca0962b31bdd8619ff6912a815d7b3e768c6ded2d446829d9635844c9b3a1ea5e888d5058280888f0792aa9c2f00686456f402307c102dbb4339f445cce7ecaaa6845056c80f7c863a7b097c6ddc0085b0c9302dc096a1fd4ee780b73fc6e8372f6143f9038fb330bda16f51ae0ef4b578df1720bdebe70d624ac1a9cccdf98340589c8db26c34d67a674c3361d438b07933953daa32454a25aedb61afb64a22f369379a2ec2ec8d5423ab05008f3699012e7139f90268c56df81f2b55c12354f36805ba9cf8d436fae789eba8cf25b1a408ac97909878bf1c82782729a525ac28b387eb7e582ff95e1fc8b3f0346e52b594e3b44ef25c78f872415b76446aa59eed0c1962af05614d452a51384a80a4fc290d6bf2e1aa9068f83bf7ef2852baa0f07a4251c382b7f32164bc2846b12e55a0b51ebb02f7d70b1d511a07bbb6c683d7ffb5d38f7e50375f2cbe49ba303a93e4b8df69e36434e726165287a0213c256d4dd9c5167855eacbc88d373f025dcf9e63eccbe3ed33e66093acc723dbc5167ab116238f19c1e5c2c9c798286ffd663b0c790ceecdf9a5a93ef58114262b0351a8695a16e6611cb2b36da2994e1b2544ca5f14c174e7b0f206e2c1ac8a61cc7e8b111a7da4e859692c4307e7d4781ebb37920970e8e243ae925480de2866a6afee995bb12dc37fb809e532b02a78112f65549f25a3685087404a7692c9371e7c8aaf12df8430b59e86253e7fb0db0b77ef08695d1d9bc97c391c45aea81231e12e5c56ff9883290f023fe9d3ebbaeca9cdfc6005a5eb6dbd780279ee50599520e3a8b223419b03f5c5ecb895234ea58397992b2291fe56adbeb866f097d0b66b6b9f4e74c11a0a20e63565b4cff2180678aa9d117080eb7fd34e62dbcf0381baf9279532270b1a5b7c2eb37951214d276caed1c9a492e0c85c972e3b1b0cc2d192104c8292a52e19ac11068d96ca5fff8737c994812bb364959f629c087480a3fac8405c01413ecc0aeccef49907a368910ba408d39f7d624d62ab48083d86adab0659c3dc4b66919a24119cba4f3750676e3b2a1271bdf97435484da64a369c08ccc973dbd4828207f352c2e59e7a8573bfc8162a14b0d65e196ca1f6f55cd7d746e50f51e0c987797d4de9bf6e128efd07255256eecd2d5921f8ca7814d12fe0a75744935bf7b564c1f11cd6c4d0eea28f501a9d3802485fdaaef5539d4b7d632081ce83aadf359e895468ff7450ccab8f62cbcaa193121b9d07be95211f1152581","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
