<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff4c85ec3b08f198567bab8904d5af4e15f06b7bdc5efe01825d33053b576fb1339b44506d6ceb4370fe88192e4c2ff67c62f8339d55eaf3ea0ac3934ecc31bad33813e1bcb62c8854a839305c206b38950f67279af18f7bdf3741c1bcf5c27b7e286ef65ffcdd37d17a2fdda56b337f63f054fe402538deecf87305100f53f70d2ef94cf3a0b7ec082adc68d6af528b9fd7a7d41f742502c979a0972ceb1a091708038ab8f153e1e6bea8f95ec2b74fce7bd427fb7c9415981fa91a68b7bac80149ac8c13522ab1d38973cde6e71261b8f691b573e5435ea579294627b6b85b9b4a8906f339aeacf3ac5cb203cb551b0179c4489deea8ef38266ee4b768f08a271ccd73ce03c5c025508d3a6778569424ec5f5fb96ccd1c063dc2d75bbe615b9d7b28e0c73e9988dcb02f589e4517472064677028ca0d0b738b0313f581d0f795da49b42fe8c7c8dcdb2ed0c4a53e45110a8c0aedf6108379b6d909c74c554cf4f587b3bf3b00f97b98d59781de8609c4890b64d9ed2464461366424da5cc3eb0ae3b8709a11f5a824329d88e80d89204859751b781b2aeea6976e9fd682aa14e8fb6b4ce7b112453fe31d332a8e8268796d6d368b89e6bb1badb448ad95f6b3a0a1c8906682dc9dbf3e91d022dcef56bab869196bac12d8b2e5776096879a8870c484ff5247f5d4c291d8082a9c6fd7dfa9e62500fbd3fd3d4e3a90935368643d8e639bd283b2574eab80f04bfed1c437a3d2790150c8b93f0af7071bd09375a637eb27b551f454ce89bedc4015966e850b98245c04b851961fbe7088a6ab28aa62cb76025900148ac5bd6ae29400aaa2554566254ebf6b5e0e1970f3d0de24978e983c068c50383b5543ffbf3241157bde3dc767c188cccf24d78e13be1432609ad097e785994eeabc1d6cb08946db6779d002cdeef0956f0b4feae4f015b46ee5de215033ccad8c733b1c8bc66e7c0960c4eaa070b61793b362ec4f077b9ba3f55d9ebf2d4ac0de2b38713f9072e72f21c51a4fe2882db5d6d381ebd4e4ec11e2db4a921999e2313867d88130a3b54342e6b11f01e1fa8e3a4e7b26b476cdf73173418ba9623eb4faf8c207c1625e4ec0368242329fd6cb50667bf73a65ced1c8cf6ec8ff97dc3a787556645b3253d57a8f0586f1696afeaa50ea0ac27d4ab1a163901d939af424f85813e82b67526c93cbf04646ceaaa0da4a3c417396c555f6ced0b2733f8f7ca8891f64fac2f43d04bf2769d3dae59972d304fbbbc4fd916a3409ca80bfa5b35660c128722cf4658a7abe7f8fcd1a3ed975ddc4d8cf803baae32229132777b61450da2352cb3c49cba92e593621abab9f27b124693f7061ab4289cd9a96aae999752c15e8f21f3f98b0497f0e88fdc90e2756d925c5e6f245473fd7b359760a29422ec88a1595c0575066ab2bf3cb313596f28d48b88ee5cc006623b24dffbdebc9f2967502e2b2a287c84214173755534a084c11d9e171b34d74312f32f867eddfc776ce54e3ef9f8e035c09c37ec320cc44a3688f77d8228bfb77d966a7dcc198f488ccec14ab90ec9a70f2925f473a6efdadb7da97ba22f68037ec96ad558a99d35a742075f831efaa71c42e7f32a0038a44818f6db3c00ba9ab29d9186199ff0a396ce00053a24324f4821a84ae10d824cb892bc7b83008342be415ce7b8f72205615066a42a45de482234f2f5a4e7c279a0e9de586be958e82e1bf1cec08a74dda5efd286803310f4c2670e7c670930e8fc4f25f0cf9dbad39fb48f24e645a9a41ed11e23c69a77b64096fe1ce8c2e06a9d98a99bb550ee5b0213de0da89aac2e61b06b6d6ec59a776d6ce127ef90a37ab1c8dffcdb311b61e7642592d061b2cb34f747eb295a417cda2e8fea4b43d00ae1831a369605e24aed9cf57b86ca12fb25f3836bec650fbf79b6b7f2a8ba75ffa6f0aa4939c5b723417c756123e0d241c0302084ee76dc895af6ec014b51b68c1beb6b9e95ab7194438cb8d74be4000d768225b1f480bcf21e8010dfb7c1bf2b6db28004b88b782f227b93d8d36593f169d9ac771c8ebf28b4ae3baedce8196918afc8909573794c046e84f31bb15129f3edc1c836f30d0c1533222dab5f5d800edce4e274ff77c90f0484516cd20f143e9402070e9108b9622b740117e13e1a94ed0a64cf2e92f9f229aa975c1fcc227e3c6d3d481b28fea3f099a1c5375aa6302fa6913ff177992df81bfda7b84306c746790b3fbdd829861b43f7b2f8e89cf703701b1a2393824b1210d70249f9e97bca5414f6a6bf89a9e118fd639e8e49da3d9d37bc97099e003a462d343ce2498893bc2208052db1a9e2c2f37af6c73be2af7f5ef4c16726cb8208c5af82fbb019b00319b190205028d961ea9e1de474e3152612248f69800a7248b3b30ba6681139488c2dd3ec86fa0f30008b624eaee965b0194e0cddefbacedaae6b9ca6fd4b5981a2dbb69a654556ce47a6f0f26b823142d5d4adb6aad14685a60be238d993504942772219253c8640c720b9db082be6346d40603e745ce6860fbe2000e29c3e00b1c32d6b6253327391d93e8d598765a607c17c996d81cd21c3f918f83c8dc83c08a6983b0a25b3625cc5552c6e5f0233e2713cf9714cb60258bcaf72e475fcb9f0ec16b923140110d9dbe99aac9febd635f63e8cb694ec3f95db758831231c619befd0d0895bee3991fd2d7c01c687874e22623f2826e37353ad7ef583f31005a2d8062173eb79772159bcca5903263ea46afe74444087a666c798da7b7c763effb2464280d180ec5c674bc442726620615a04d6d3623e6b4768ccbb582d11f4026157ec13ade1452cf19dfdad390ca6e4f97973cfe546f9845fc88a340e2d9f76aff4206ae7e90d07b80805e84b12ad85f169fba9e70f26c4862e8f0dbd65583175600f6b30fe998fa7230bbdbb628e85153dbb48c7a5fede338209855ca83d4105088b9e401600c3d5a3fcccdb2ed3c5eaf766cf1acbc6e24dd6dbf864127281255292b436eac52e5d5c64e1bce7d6fc1700ba93ffbe00e8de9dfce4e3dcf0915f0635e53ac38c2d4dea7ca01670a0ba2cae67d8f8d04c499647750a81694cf1edb27035e1786bcd95810001432f6eb666a887bbf89a265bc298067eade5aae9ba45813b86dedc270016803b89850ff9fe9ec318ce1a3a61c05030a86db8f128267af2ab9fde0a962ca35f0ded6a0eb9a23c77e72bd30c3ebc360641415be54a69f97f4302cbf4bc3f7a9548d906de0d0ae5bb7cbdb428b1fb428993ac66b10ef117e0a50291e0f6d679e9e23f75823fdc22426304c38f616a03fa96aa802b3cf4e447e30c0a59bd4abbdfcd0613c281db121ebb33782b780ac38b5853c010e0c1969f31c7f8cd138f506e7a2e896969b9cdf79d56e6783dd8fb397a95c31b66da8c715f899c827d02079b1cb9ebb694613c3cf5dc9a5fa968ace2ced7f5a530a3913486b9dcc3333ceb969ea24688b67e7a3e7e7dedffb2ae083b399a937ef175df39e768b4f19b43079cf371a8195f228b82728caa3efae6354d32b2f4d1d825b8a8e832cf16301a0043ca911d8ca945970f9b721433abfb1bf469e50233d6aa6f731a4946cfbabf52444e325d37b20f54f71c38d70eb89f77e4b23e9fd818c3ba84ca2e8d47c4e52e26cb4940197fa18e5242ca348fbe9f5da82244da114c9b17140ae16e44f1bb46f2d1e002b45177b7a36beccb568370dd600792fc22dd470a649917286408ad5f29f31e541fbbd5d698504e511cef8c0dac8b264522aedfd91c11303b8c2049f3b7a5eefc1a4a5b50c877840753b1b5dff95e351351a4b257e1b7f8648b8d5aff52e0bab4c9d0897674cfbb3d3a43b5aa387d8a283b36dfebf348a592245ca0626b08a76a915a94713df04350b97b3dc0609a53e0d0f52974914227030fcfe2558e66a016553186a8bd48065649a4461431fae4168bbd32b7d2651bb88d47d56b74e73de5af18696e6162d72ddc21f96bd5408b954f3f894df1c6bc55ac11f53f76e0ae0977db6f0b8e6387ace60f04ed15c19d1bbd77d14f826ec07160793b2da5dde4e148f8a00cf74b8daaf89acf06b16fecb779d900a31dc0b479999ad1b2d378d7b4c6cb07c3385300fb5ad31240273abeba24c58fa334f8117a06c0e907d2c80a138a6145450e9099dc5bf784d610ba168ffab1266f56120ab2c8ace75a69cbd9efda9f07a5519113d78ffe7568fb96d873618e302d56abc306617b6c75d1df38fa91270ead9b9637fac872129c9a1fe3bc35b7095d160983c380764b8eb1bfdcfba0ae7d044c8c82c502135d9194cd9e21b0d8b067958b6b152a7308fcc9fb76069589faec04bac39484727df8d105398b4eae2ea79dbb37522374f09a50d77977a9dd4db4da7a6892c8638a5500303c63833ef7ec9655312fef6a15d0b93a3e76044592fdadd58e936505fb0dcf230d7f89b05b3211f3b82eee5f96c40bf6cd71e1edb6050401db44067a2fac120fd658ec75a11516c9cf552477665c5f12fa6456cbd721cdcc9dfd56aee97d3a59b7b37850d183979a091884bd2184c1ac0a1351c45b42f8cb79553ccb406befc722894da60aecee0774fb945fc7d7a4808e5e99873cccef184e5ef5622921e7b46d28d06dacff1b987d03d78a97eb8ded9b539bcd0205673d063d01f20a6b21d261f9fc44339b03de1cbd221c2cf26a58db7c21e719b875cd289e91607128ac7a9c79e64113fbdbde0bb163fa088c80b70351c4a6407790e914f096c34fe5b54b885fd3813fcc8b98d9f8f20e37d4678c46ba40d197938211ecfac4fbaa0e3982a1d3216466a3cb1fa3253eade8790486f0da465714000a4ee8f1c2c1e2d05eea6d4778d861dce57cae8819f6b51bd7afeb79ff3f97e54c5fc156dec856e1bfd431604ce3590f386631d4fa4143b2d2c7552f076aeeeef3c913286be8b39f99420d2a3cab9cf92be837c1673a9b6f78b6d8a34dc52dd029746f7841e3ed209d847a5ae5de8b72cfc24e325350091e3b51af56d44cddfdb22dd5e8d1213dde3a7c1b9c6d337d39c12ca750bb93b22fa9b0359ca4980383f1b81627303030c8698408acdaab898c1c2b4613bed04c62305e670eef5857498b0a86d0badd30f75199019b124d69e6ccacf37bbf479aa14a8baa5e9fc8cf1fefd55425cd61d4a60e9654da63e75e7c47d84fdf02fcf12bf992b680cd27ce71f1318211280c50b70779776ae583085bde4dad6392cf58c0a69f4df18ee691969f9e440d829c83f08f4eda5f997bee4246bce77ef97ad3f35f799fb2e6e4e44015ca5eccc3f2eeeac3ea2c7540e969b41bda4d1ebbc09bc7c5368a949d2576e223ecff34c149cc4870511bf32a5f79f6907e62eaa75f9fb2e928e688dbea9ca0f1a79ac9137c6c184457cc31dd33a20abf76c697408b613f482a30032e2f4872e2b7125db453b239fa2c0996cf48ffa4002b686c2eb414dbf65bc94376a0828f0c7e958cd62c621e3f4eb9cbcde71623b63fbd00fdf559637755c2730039bf16051149f75cbccb9324a36628d8d837b5149c34aa285e81c4c3185128d914265502ab0f931705faa51c15d5fdd6e1fe787c02febb0451da6b394ecaf1c14e680cd12e1c195e8f858767bc2446793cf8936e32e03447192505278c7ccb47a02f1b5694be4927c1d926c7c11ea8b27620043205f0501f0563fb02007ad67bfa93832d7d458aef0c46413f950f4ce1da657db7566e06053a453df2877255955e2aeb57ed8ea69fc605124e6e63e7a35669eee7e540c0882028cfc4619121c8e2e15ac1d4d5d37ff103bc3fa5862003fd83becd453eeeb3a1acfb7406b5765630bc15a04e54d5f5e48365675225d5cf1bb1ffd9ddcfdd3dded2f4f929677cc9a2f6c94dd304fed298a87d779b08a113ada7d148c98bfded93f367f521aad33618f4a9273b266ebf92577ff794e567b850122207aadf245d6826d5710c4cc4ed978ce7911c4232db98d5b5ee076a2915d895d28be24b2a86061555db76895c18092856b61e3961e612f2eea76335580000263995550e0a2330f98373f0f67a793a2a1d483a07ec9fed6cf64197f642cb4db3fbbb8d9d14f92ee57615be2613df1a8dc1c601c1387ec77dbbe5cd29f4f8542c95910fb4bd427f31e364f291142537af49fe67118dfeedee2cddfce99bec9dec71886bb8b30e4a51c5e7f5f44d6e49585bbae752855f7fabb1d4db1c48d652a1e4ed9f7c7ab8cd7db8f1a7c93eca8c7a93153ef6f1a7419c418ed786f6f9ab4f3be93543d61039001b88d40bec6d1e412050012dcbbeba4f30f3a7af301b053a09ce8cf10232d1d0e79b50e927cb4f7db8bbfe3a740accc359ea6fe3f2fdc8f6361cf6b0d192d190611fd18b0ae3c65b1abe0c4bbca4e06653b554fb42c47b246a5cd60ac03b08e69ed54e4371edd73590a029243ea8322b056cbd9e3f90bff657cda2c2680f3aee7bfe98dfd8d36d134a745233f3357f59055a887b0f2d907832a4883eac53f76dc9a2d6b9c64a515566d79b83c5ce3fd9ee8b4d96f5a402b84c12b823a0b95556181c01aa6363a13d7170730979aaa9e77fb7751a268a2d330e4c2a372e2fcdca983474b7f70d7c4599389fcfb194087ca7cbd38115e615f29b55e46146eb940333e1c1ec51f68b2c7bfd93e59f5649fc469c12b0f6992afe049bc366282e664c08fd918d488f03bb54c44cf7588e0faaef5a9ee6c9e19c0188c7dec2a3a040e751e1336218ccd578c35b01283dd2947a9561c55f336b6a6d2179bfc4a921cf4f2747a36991e9f26424bc57eceae568ad4dbc73ef6b6886eb7704e17559e6b6f82539f010644de6cfb10a98ce138435ea759e397e6d6021b32d7790f01c75bfa2595c68542f62497c4d73e16916763579278045e7d11e73125f2d4ee2cd8c5ae9128a549278162a5cf2947690012fcba56a64df9255dce93f75b72b4df518aa7104eca7c796b7c2deadfebe3c337110ad656bf40570ba5ad5b42ff452e11adcb82d15bac0affb26f1938d5e9e3fa2dfa48cb8cfbe6d3c0c934205b2cbd420dd8233880da172b741bfa9b1a6e6cc8263c49db24fe3cb11e3179851de06097e5402da8db7562a700ea56906adaf959dbba0c4dfe8df6167a286ca9b46ce5c0210071f0d68d4e2bce8f09c31464334959ddf3505bf137484f1854c670e6ae6b402d557520c195fad4863a04bb795de5116ec3edc9fdb94b114837fe29fd6af1d0a480eca6cd3e3396bebcee42f7fbd931351c3ea7d8c6f69e344c6ba4d606e4473d8a4bb7a8879c19057b56247a0eef7bc6ad7b6656f08bb87d2a1839de56ea6f0730d13a1551530fd30630b1bfc08a7f345a4621654355bf6801462f5611a617429589ca5b931c36534658ccdd55ab8091cea4fd607f85f708e45fa0fa673fbf857d8362435882e251f1826cea027384bdd7f801922588f3971486d7656b97df442914889c3df88074b8a35f92bf58107ffc05f3896e7281ef4cffa3400dc3f4ddeb7c8fb1d74cc0e4a924d1b31e51f2ed16bf3c744c52893515f02df345e29fe2b944f70f39daa0c9c3b410b60c54f40c3ee079231fa89c3adb60f38fafaff115af2113790e04808b543736ddfc61cf3430fec9c3d8f07169f98d76e7e88d34ba93d1b816ac1a792558515ae251204169b352e2b96d8296c633e72678eff531e1c21d1e48be5353fb8847350842652ed4c3254b5f34f051c86b2812d2faf8b018cec9c1134caa4434336227fe6fa20d9724ebe8ef28d768a9d24c47df3cf25d61985bc254c2814dbcd0fdbf791dc9f22cc81993c30262cbbc72d61d98439bbc032fa53bb05740d8099919a03a744345120bd0fa08f8c943e63e705e220776006c83d2856a9861b891db76cb3f4384c9c1696a7150bc487385469bdef69f75a12441749cca190dfea8bf02d5a743138e12bc85822d31d25c7dbe2f872674feeb31c8302b88cd5983b6eeb6b18cba048fa7846389a81300e50401e1e57af6c8942aa722df008d0451f145c631b02c2b472123d1d9aa2eae46df4331b2b9be408b276aacba00dfff7a675074682cc6aafe919edbec32d262749a1019e7d8c39460247a5475381239d93cae864d3f95cd35916ebd9edca1ecaa9bbab956dd5e0bad4923a70bf0f4165af0aab5de43affb142da3b0bcdce2eca374776937c3289c97af65d10877768ce80ba69fad3c9dbc85ea5cc0ab72f87ff388cc4ac1b693fc2faf0f0f95f687ee25539fcf74395029a2faae030da0f5d86b46d1b66a4c324380a879957bd944b96be7459ba32d28e554284d023b1ec45a3bdc8e90dff865e1f98ae96761f8974d04e3b488ede4314f40864bfb0346869fea578b066e2b5c85b0b68b0b6b6be357e62ffc383f91287c517bfae5e1d3454d3f3a27824be160236e207a2b061b7e18eb28acc3470de4db8149e66748ed5c3cdc1f6ad568b79334a1084cce221da93eef2983905eed470a0347d210a483ceb6246de29df5618265e6a6fc9914b946b0a92717b3e4b95104c134b41296b92d826e0e9cbe629b16a06eeb88a1c7eb6a571ce13485ce6de977bbccdce399148a6d228fb8813745e4adce02e0ee9676656776de3050a8a395d1812ec5f9e8a5cd8557d1127ffa49fca3a1cf80f4c6bca1765a3f11680f025f224ae2213479ea83fc34295ff1ae234179ce8fb95029859fbe6095a0e5c4d4c590e8061c21e1c2679efa47b139cc630c04280b333875d901ebc79f4be09cf1915154f69b340553d00f27c1c730898c3ca92bd3ef3574659e61dbf69f35551f91a3641d7fbef5df64ecc492a1ba0617db932a0197f6ef26b7dddf1126109a72f1e4c6f60667faf107305733d2960fe22d77bdbb402cedfe578e3c88ee3ffddf41b002e963d042623682e953935e569746feae36f035056e8e40ca4b5a8c919b307941d71c3aebcf078d83c6fad9269b9ffd3310e69b881a273003af198fa6ea5df04c22c37fca9bb60a816effe8a6c85ef29efcfabd25d8885f5a64913f36fd80fb4f4257494a62a887e0361b94e5b4074c5750dee1cc619024d78651c24cdeb2fd18613148b4d086e06f923a97b1bba3074a8f942939facecc31da8f3620bf15bb218f9155d48b4e053a7ad747b6a9c8954d4c48050eeae25af561023d39541005b827eaa8ffb3be319b426c36645ac37121df9bfe329ce4c14636913363d6a37a2c415d21fba6f3548051d33e45593562a966d25f3a696831909e115443a99a0d37bfb7c10a8a06e39b1985a4dc7fc2915095f2483e1c45a777b54375c019eeebe05b555a8dd4270fd7715c91d8f78865651ce693766601861ec7b66b88125a3627353e8cdaf335ca9c812edef23ae013b4f8cc4d7a9806145d7372675ac7597057fdafcbde2936fe6f1f77f6866912a8a443df81cc1718b08e4eefac6d2a91fd4fee79a29b004799da1f01fb0ebec699d99e139318ab8a6b12cffd2dff150be4ba675944c6393ebb952f7a92cde2f074291365e43d330e80539531aba6d0893d966e3edf32c61148eefa6fe96735a7c43228f9f35bbe77e018f4b65f7d7df76a9226a8da6d9043176a258bca2507b7b2cc4e415cb39bb975790c61b3db85188d58adc6d62b35d0f640aeaf41cae8c44e3613bc900d6392bc33dbe05652972c0b76db889d6f40cf55d2cda3edaed9ae7aba07473d2aa7d28849385ec01a56eef1688729f0303f548299b43cf118f0fafdb265adc2d363817d1ecedba14d5044753b4fee17f4582e7da91355b78b397e7a89a622aaadf4bac7f7b246b29adfe305396f194cab40ab0f241fdf5aef2f36b624dcece7ae0b9a02f98db33f2f77388ddcc34bfe314f7f48a14ab3c3b766915d2d3c802714ed34ebf45f0b29f6e5022c35bcf95e04829c0d2f1ec03a44528118bdcd843c334404efd9491dcfbe17db07e72ff1d840e847166959b95e89cb35b361b4b673a4d5e627d0589b4001e8597078c4686a3998cce879ec715083eb55a0d7a29ebd43689d3ff95803cc219e5c7466472b919a6f932ae29d5e68e4c5d3b416dbb02f98bc187814a70e591be1097ec78701b77efae18a8e8606591284c58fa8e480cb4ca11857e212e36a62c9b3f952095d1950a4be4335e44289ca7454a341f55ebbaca1935c01d82619708602dc07c88249b790ddb7e3abc819823086d5de8b5dbf9aae6ef3f24caf70c9748ffd2bd3f14a8699b764ef44e9bedfb15f2cbb1eb06ec27dcf571f085cf869a6d8190261250a99335c92c64e18c88abeec26a09c3e706d35ecb2109aa203151ebe0c2fd684f63885b08fcf47ff777575cd4e9665da419ec8c3ebf6946383dc56cb41895112865f32816a2b308378dda1064d9e4ca305eebd0e3b4b72f7229aa8a2e16e0fe62e1dc61d4a62d8c8017087454161ec5f7e18a58beeb3d8c1de88201f4d7c644e12d2466c142ff9af37208aa7a295b6845fa0bb4d0f3c0805646cf27fbe5e97b59463fcc9a655b804fd679056a25bf80ebe0841c00fa6320d341dc728dc29dd22bc89c374d83650aaaa656f5e0b1867a267b63e77cb42ecb88b1ee02a152903d18f83c9bafc9abf993f02f2b5af311e6d158ac50d36fcc86ec7bc924157218ed409f13278363a190c4c76761aecb57698f7cb3e372c7439f09b51c6bf63460d7b9777ad9b37727edc20bdf0cce7c11c9e9fd711d698bf4605d8c0b0204b5d9723296fedad70f4d262cce602e9fc12f89aa580aa90a22ed9ee53c0051f1948601573f43e0507b55efc836ef65666bd2146884ced0fa6e8f67126b8473332e2306e647819a36e86e275f41b52da6fdc0855f1988555118453f719d34a846d6df78ecf86d1ae3570ab1b52efe24bfa9ac6fb7a78a1466c96bdd61eb10498159d9f4ea0531a1ac227d7e64c297fe26dc78a87c95a15666a3ea848d2bbe8c4e11990da51e04450ef18c85c877542acb217bb3a33d1777e21bfcabdc0011abd1c0f846a60a83aadca35e61f2ec103975cdc2d1414f615f64ab6f873f0f53dd00fe28a5e8bed5b6fd14d1d9e7b7732d310bae1faa8b68a47281a2298bb49c3486c7c692a241bc6cf8452da6eb29958d6e7a9f2bdc7f19ac9fb2b0650d7817e7e16b786cb189ae34244c971049bdaabafab6e4a79a32af275bfe31cf09d9b59b8fedd4423990c123d2a5e5de3e63f2a86ff0c9f8ba52e6be3499188331622b6320341f95e7e95f2a00355580a755cffe87b4f37459fae27767c8ba7f7c2dff2f0e93ebd95511667bc77581819ea3285c9119d3edf1c296d4f000fea88208dfb3e2f61bdf3b2e5e6bd2d6e55329b414134e008ae00dac9b553e411e2111438a341dc338b03638d25a911d44d6302536fa36df1e1eef7284a53e8f8d43785404599a51bab88cb8f3deb2ec43562cd81fdfb3c458b0fbb4c644252477a44cea7232dd27c5fe4338cb7b7b40e92e4c101a17e250bf525880823149de1643f6dda7e9eb3bf7cdeda3cf807727b60825eb4fc5dae2e2254fd6596c2c38e8cbeb035597351291094ae1ead3c4986d46b08b80641c93125de918d3a5707a81fc876c7a6643618def09181e9b400adae11ff8cfb9479d6d82b58cba2845eff92708c1a13fe7a915f79c54e8428712aa6b61e80cfb3fd9d522e8217d4c3509e1ecd3aeeca30b0e3ac1f0698b6f35179d1a4d65afa812455bc90cda65468227188962d9e2e25caa1601b6089b6265cad85c2ae7545d9a5018cdeea3560e82ef583972170af2dd61ff99f5d22fdc34d0614f9ca065ef0ac528f07b154d712a82f4a2622fbc3423512232a2c822068586d9e8963e7155d7dcd269dd8aa5f0d14bbbe6f7c9a1e8694feddd9136cdbfac74846df4b1324e349392129bb592d76a8e546fed3ab5fe7fe8c2b7f18eb1ac64f8659e92ad3abfa51eee63498b8850bbd45ace4f06063eb2e936dce34afb02d0cf389d16886d28f954f46aa7ea1d8529a34bcbb117d976d1a033e0083c47215faa6f3ff74d1d7f709ccb4e80721d5a90dddf3643a6fff4c5c311ddcad0b9b03963c83d5223c78fb25fd8677ec3194ebab60717ec0feda52680ab19274ba9681597dd7280d1d09de73e3867aa1798d563655ac22762f805bec160a6d23507a317b6d7efdeb5869ad0ebd5a66746c32661556d42ab6eef397001c089fb807c5c35eb524abb7247a55f4e098f4c1ae6f3e9ea6c6ecd384257fb1b8c757fa200857ce8523af9dd4df7d041358f08e0bbdedff70eb18b98f6160ca19522570df4d2ca2597e30f34ea7c51dba1372a106ae1b7e09864adeeff70713512d75806835ee33b5a5058d561ccc504b8511a328ed6157e01b68db4e9fb05143c9c314db93c1ab0608d582682702ea6e5000dc49aecfdf4725e4637d743e6edd7991a695e98dd6b3f8c84a3617cfc35c58fd078ba57b3296ef89e75e9c84f0a15f9acb1befb830ae2e3b4ad828d2110ee96c84e7f6308df966e4b976dd6ab789378e0ae007b3a4ae6cd6215a1023219b0f3cb5b1a4c0f85722a57504fc57c5ec195c580bc7718de564646a974715c1a4692a00e446be060adb564d8e94c7b8f7810daabcb8760c476fba21c8c31968b00da4df517a289546b18d00d145008a0a1d20a3bf2ee8bc0e8bf21813f7535827543384a39b99788c3916bfc34e76462341c475e31f090a202a5c4de168785500c479f3075f53e8fbb16c52e92d46089702b420e7d8a0274efb89f0b1e184aae917a9386b03a7d69fae0e28a3c52d66de0115a651388b7baa44da8c1167b821239d33bb6d7a893759fc66417322b511c4f7aef3e402f85a2394f98d08751e34ac28adadc3824d2298f856b1c0355fdedf72f7ab1e7addff9f92a2da6d1d5ad615369c8189283c332eb2b280ee2c92c364c8783920df9742b359f1ab7e583d2955e0a077a371bbb63df1572479206e3dcf5f2da0e240f3f1f555bc16257c51506afcadbb432dd74b1ccc073084db27c55a3a7af26f8a7bc5baa437e89cb087c4cdab85180b4471cffefebf6a63c215338218dab366b9286c0d3513d7024f5cdd7aa6ae4721f58764d2f7adfa00e61b87f7e8d62d3dcf99bd633eea573bd459dc016856e29e99014f10bd4d00b3103a2f64aaf282dd54cd7338f64901b106e1c2bd24298695262513d311b4cce12b3d6b887eda65e8c2bc794ebaa5a13b82356edb03723902af252fda6a04cd92ec9bca95925c11aa6c4a6ed14fb9f2e851bfd89d4613fec673e969aeb6bedb7b92de0442001f810f2b8bc3cf7dbc4a82a577f0ad2b672a84bec2fede1a792a2dcb9e496169eb887d9703e6c9ea61c676fb7ed49bb2ac801e18ce4128680cad127a08a1d2775e8079d1890e8cf3f3cd110637bd5945c86e22d7b3c1cf5fb392976a0076931dcdf079d0c40d8a3201cd0e6e7b4f9b65535fc8e1f77448e9c8c9b774f56c701b226ea448717c6bc1ffde91c4e9f204ff32a5303536cd92bb1aeca99c2d591606ecb5153ad9b18915ab14b58aa519c95fbbf3d3f436b0203b2d95f9a4dd620a42354e30114da9f30c0a299f3813509f705bf3dbe08b219906fe36f5d9ea4a808e0efc0e551e196088537dff14fb2e9ee3ea86346d64b50bd6dbd7f80f2ad027d9fee7580089bb7906c0141c4954ee763befdc234035bf483d0d31eadda5dce00a8500f7c1b5fc8a627962fdc4fa2e056dd5943e25acc432db5e953e752ae17dcc27ada26378165192ff6fc7f081c665290f0a869102e29267c082435bffb4ea9b3dc17c12191c4022aa8e92b663f7f5d55cd09d7483ddfabd50c0e12c6d82f48e121f58d7637710e1dbd4831f107630a3df693c38958a716275593969c852a7171ecaf737910bd0f3b06b7c0f6c3051949b256bc64ccf073a523c772df94943c3e0aea7b1d6a73930830325bf363d1df271018d59a94b7b9869ac06dd7da2509a3b15dc75ead324a98b4124a002d5d0d064b84457ae8506f35e021af7854921c7561b62c9f0fa8aa6656d5a65975850074cfbdacc24511881647188f504ef69c3d108654066a84fa8696b6b3058138c9667882b1e3af05e3644e568fa2983f2a4cd34cb955b34ccfb6ed699ecf874a085c0d7c02bf733a38e92113005fc27206241299dd617484389c9df08d2ebf13c2d4c0c5e982146c2ffb8856aa7e69052000e4d689e66f0dd2833445a90c122eb450ea9338b92cd69e2da94bc9958312306b19008f3f889daab81f7e2b5e4b3615e88b58ee707f9289a64ee91118695e15651c1b464a6bc942fd811ffba2964b995fb530942199bf863826d3eb506ac6bb52802397a15f4b0b9131700f801bead08a78b2f44e5ac181fddcd42ca1c96a6194c243076dc774491006783e570c24b603907a814b3a6e0895b2958b30957057a4bb2b8b5e7048e5fe856890000e9df5e7d4bab2ea3dd5ff573e06160efdba194309b06c3464b593179ffec5e78bd459d04f934adc7b941e7107fa652eb801b07bba3aa2de7e70766a9caf9453d66c40a2990b2502153a00e3620235ab1cc823fcb9b339d965b5c1f5debe0461cc33cb12971f445b5b25b4ee34993510dce5ca95cd5bbc654883080021007a2f38fc80dffbf3434d9a05c09199b9034a6b27f818403f12fddae41e9e09b2ad91dba69cae039b966fe41780486237c1578eb59c18ca11bc885fdaecb0cc1791a7f9f34053372525ad2ff6f09c1e78dbee8a6fc8983b0f561f212dc48edbcd40857c5f9639ea8b0bd385c1ada34c5078964324c0d682b0642b7ebbbca180aff5c3bf2e9340b062bf326bf1d53065602de5ca1f3447db6b98deabbc3c6f9e88a3c13f04b5e9e2c4c21ee9d42f7df09ae90cfa0428388b1b5f38dd78deb0f75e5ef1f6d18001d9f9aa225608747637b14bb292c2c92009d1b72760a06a354c3fd7440a7cbaa91f879d68100421d92fdfe84945baaa901622a6cec1f91a99d3ac65b77be6b3d748ad21a3719924ae982c2f1611b0e84a61f9d6aa5c52d65794f57cfd4257b0baac3c75b2b88e92451e76fdda0cf4dc8f83e481357dd200004abe7907dc1556654a0d8521c6e0be3be4542d7035cc0dec0da6a6106729725fc55a68d5d4da5e26f4e87c9a46986d775713f623c1391e8672ffd587858284b445ef9b34801481f3b92205e9073e7a946fe6d48cbeefbe5069244e7ee403b5ffcb13e7438fdd4d3c34f3a04955a26074b3610b60db1b60375e5a25772755f945c6b1609e2cc807d3abaa19c8c7e439968ee1506b038fe970dcfa346c63c5b2658647b58a5e0ae10f937552c5d1132c52b67d125497a4f81fab7b0e05a51bf8ef4ea5a780722434398c6c4e708cf23c96de818e2eab6a1aef41bf64ad18f32889a1483902f8e6eda75862a47837921cf4ea43cdb6646d3fe75ccd980a22983459df3c85968261c5dbe92c2038f8e7ebf06d7f811f08d70fcf4ca54561d55495caff546da779b99a3642911fbc91b7ba76703c9026d6bdb396e98dd5fad6037fc2cabc09af4021f7cb6e6ce983737e197dc0be02b0b1b17d5406c37fec0fdaf4b3b32a2ed4e9fba3acadf21447fa9ecac60ddfb012950819851e03ce2e7572c030039161eb2234ce9a573699fdbfc4428ddd16a8c28c04b9ea7653b4766ed24554a411ac39b981655fa04c013f7d6961ed8b0a93f46d50823a0f3bbcd8b49e5288bd26fa3b07c6389fa92d35b8676990f234d7d695e1f618150f05256bea70eec070c2d615aa488e75c26484fad174e30014e0c6b3b86538863fc02269761f8e4554e54e6922814576711178d89e5afbd0e10d1c599ff7b7591fe7eb50dd9d73855e2eb1baeb4f6d9db667cb2a4bb74e0a1ee6284361d69e0e1594919dc8568d3edc0898e62d569f36aa0ddcc5aeba129426618465ab417e67378433af2377276923dd1474ae38c6606b619b4a406666646caffc3a47c0cd6fbc8a871cc610abde891556b295f03fb8a46facd33c578323f9c2b06cb6fed281f1ed01716d6d44b76ee2d20298915b164c13f3a421c7f8718d3cffb980d6deb8c72199ea67bf3edea09f5d64edab1933ec0a66b9bfb2446a4f55d6dc4b498db0e383640a601649d328ac54d51a75532a45308907ab1953a7ab28e3a93c41ba82673d38675f1f55eba9f9060728819dd8b9efb997769a4708cb562c7b0a9ebc943f769351175ea9f35f820fe974623449b4ffb2c1184156c6545a5d16311fe7209239c190d6babfdc7d5969a4ec6fff174e1c8b60d6264dae0d5c9832c0cfdb0f8135d4f5faafa1f157c5aaef11fa031013e71b1aa139080d2f155b18658fb9cb72c486b3ab5df6b7fe9cca97bf1f54cf60b659d3c1ddb52d347754b7f66bdaf6cc0ed03e18823eb65d2716e30d663a8d880dac6cb418f00c327335e94b676445b3cfb5d421d106543c6970cb2b23e3ae019f4f8bc37561f38fe9fd3395b6d91e3b28752a794399ce5917ad1abc05abb0b4c9b8e86a916c581be09447cb350ed2795e303c47e636f8734bd051294f5501d12c69ae75505fcaa072e063a9f9b0b6de2d28214893e97960e2fab0c99d204971724dc9c03c2f8b525f96359cc2f34373dbc0c23c9640d02648242e8287f50f4e1634389f9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
