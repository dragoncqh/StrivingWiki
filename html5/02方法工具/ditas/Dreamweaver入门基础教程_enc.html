<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08a8faf8922a67d5868af7f25def2501edf3921f60918916f2f0166f2878955b6a29438a55e8f6fc12fda5d245890871661c523722250e84f6ab3f17190486d695e6e36f978f26601978f65e59da846e400f59cb60043488ea1a22cdbfaa5cc814f5cc299e44666fb77a5f5ed0b1310ccc8d38e5365ed53e9805fa59eb17abffbff340218223ab8011ad4dd49fd270969983e3df027bec0ec9304b1d1b6b7e5196703a784f22add420122430a3ccc2b23e374c9a69b5ccdf58a81175fbfe948f70bac462559cfa40c307eb195a5d10455eb23f9b4e5e562e07fe67df7f676e02590e7a2048d23fb35947b3900c00ee82bd6957f7e664480b8f34f8d4ad2728c4ce2569b987392a9e72f5100856ca22a9bd60420018c76f5addea7adb9e9ae0b8b7d9062946c1d68cf4e0c6895cc41296a862064700caaae0a1483edac5d72b8b4be557bf8b74a1081d0abbcc5c36966f2732f5680ed32cfe04572400b8ba3b99d0f12c58358715b299b085ae746ff4ca1f52ba13ff64c3da83297a8ab4d611739be3fed5dcdff885f4e68033972b4fc19eb7b6994a5b273786019b01a1585c00145db6a31e504caefc167a7070ad47b39ed0557d461b9716699705eb729555831f8c4654bbb69e532f9aa40c6a2d88bbd5e93348d78e20d2f44d3be69acb81d095978cc6c2334e92cdbddb50677dba87a2aa38d64655cdab9f6545c5e5f73698481fd867cdb5be3b5bf8bd1901d44af0c3edc573bce9dcaf955206b55447cb5a0d9ac712db2d03df38d43fec3cc0ebeba56e22cdf49670eebbd024bfebe5e88021d97fc2848cb36eeb88f5ed580e8d33ba1b2f2b6ba6732ae4525a5b7159273a7140b795ca02e06fdc5b499b4a6f0a4eb4428ee537636d1cf44993ed41420f64a17840a21872de5d2739595e00fade75a1525e5a766ebbe3772f527755b1e9d449311c7d36253dcdf5167aa238d28709eee438b55f7ba877aef21fb5cc800f0a606ea12ed172ba4ae948d4547304939a4c46b72f476d10ae54db1a9681cdab9f718ea3589be9300e7318265cf0d59234b7490314aafa3dd1547e1e540fc365e29c2cde4104271a42b90baac8189bed1649ae8fa2972013cc813fbb638c142baf9fbd0f4584f39b99fa4e77f8de51a648077ad06f05dad828d9faa5ef349c75fb2a81f438943326417f0a1068e67a5072d2bc406a95c3d95e2b4748af32da1faf1a43b1f27e8f5b23d91b3ca3e8df1cc6d03a0c30a74c1771c4864e4f821098894246ce72e5e27ee44c47d9704786b967270ebf0efedbc95452af1751a72faf124c34f093ee7dcacdfb1e09cb6cf33a51b4f818dc974d25b76797150e33ab53086f3ea7ae44fc882cf620c9b496807aa4c82fa095aa6348f85d5bb6c1c58c608a3f6d3af966fee56eb68b50d69011afe0e8d9b1e2b15ad0d462b7e45c42fb8da5d2245386180df82ee3b04c220074620bd6df32346bde836362f7b1d12ae982c0dd8346f3b2bf778b0af6b509a50197dd92fdf981fcde88deb9b84df5d86d835be39e61b1cd398967de043fab9a952e0be13384724491b6e3c397799aed961a3bf04e71074313092bc1adfd724a65bca8fd1aff424ae4ba786c40a6a653ddad11b57b6bbc8d199fe8094a3790aceacb34bb081acbe3eae12a3dfbd3d99d80330b29f134b3d085fe185b3a79f12ca9ad6c7e5b02a1678ef266402c96d109414e508ebcab54751714fec5191a00881c835633140bd1507822c7dbf1bcf27de76a1d72f3de5d84fdba204776916b98546b9fbaeb0007e785b28185884a475c5e8c9d23afb70091ed921e93e67be2fc94531bd45b623eac48bcf85f106a2d74e5905ba41b8a2d297f2a35a8807d70eb6a6fc0fce8e1e27090571753ede6f9fca5688535a9cd9dcbdd25e6e82d3fbd62a5c3f9ddeb08c5b520355811be9395c330ca56c2283d44bde996193bd27b655c55f30e858807323909e342fe92aae8b1ede4be34b05450325f15321347ac3152d156be46d8e5f5af14dd07acc0592aed597355917be70e6f418f3d711fc95886324ec04462ff36877e9168bd579ca7da5af376899fab66f9ee5e906b959c00569523f222668813d4040a5b5c62c388a2e46f3d342f2929dbc5dad8e114f0339a2d9f3794f1c6e49ffe8ad7204563ed8afad8b13061ec488f2351d56732c574c97d8854d0c80b86cdc232be6db02b4e7969a43ff0c139a73525469688f6458be1c57804e01bc29ffc7a05c9e854075f18ab1f84e109ca8d9ec72b8e7b1437f0d3e85c81ab57c1a08fb25060f57576e78d0b996e74367be032de4a73fd3ed3a5ee14a439d82381d5b1b0c2a993ce4300eddb3b72660749d316eb248cbc8e2ec2f3491b764fb9237ff4c464edd4d2ebc675a81d7eb75dea2b51b0acc4a5fef48c7afd170f8eccabedcb11a423725ca0b33d6bd838b3a2db3b21eba7f25b3fe5cc11bb62f7a0452ab736d5c5d6aefbffb877629cd62aeceac0d1d1cb0025f96be49cb2a53ad5d5007bd09bff1cda58ac9033846e32dbba354fab07b07151daedae9ebf2c4e46f47f1b9d9f4d18cb350e8a3ccb30b792d73703f0469b0999daf94f5c1a74a912c1c125a654a240ff484f0e3bf432b219eec7461b84c7352aef0bdc50ec9346f932e0e2ff23ee3c1e715c0c19b6b0f458eb1d4c65d426e8236f96f6c1cb8fcb99a042cf6c027679e7a186ec75d6286f750cf10eb374427657f8846a04845b79553468610c53c1e6377dff00c40cba9a31428ae17d4bc3b2a8acc3a72471d1870d4c06e371223d6256653add89642641b91c3845228a425a9d5e83b85a5c93123e05f41202746e71a2655b54f1b2fd340fd01d1a6684d9102d0a8e71e4a41fba994b6e0873a2f0c0220e65cb2f0472e835d3025a163954ed69c7b8568731cb228f695c8bdc7f5bc2da315fb55614b1ab8271e56cc65fefaed49fd044805922ed195106c24ca7c31e8c93d02e94edd43f528ca91d1e3854d164e7188b82ce420d437707a28087f2ecacaadc43ba432837698b681e2cab0d8fcc3b414fa4e50384f70018f783a76567fb2a4a3b5007fc121fcc4c5528c62f9a4f68b6c2324c73ee32d8c55d63101f130d9e5b5b9aa091222dbcdd5b6450f2022e65f563aa9c5b92b7d89f6ada9329b330d534be4cef0b7d94596037b1f4c32d9fd5e9605070403ec0ade15f74c24f8b9be7da74dcbffe5cad0d4ee80031c5fc1a1491765e6980f3a28c94fd4014e1273c1e66f3d25dc08e1cebdd500f1feb3c763c47abb968649ac4fa21f9e7c628266f5143016d9aace9c0e1a087fcde4d8ae9303a6867e94630371bb2bbcfe06b88b322ff41edbe9cb545fd5f095bf66700bd8968e3117de80b9b81c1412af9bd9224951feb4169a1d7fce191f8ff1071074efc8a0754f4da1d2a61d54293165787aaf9407b6aa0b456a1e0761d384ef70d74d1fa0c6c8bf3ee3c10e79949785c10fe52a187478b4596e6eda63d09c61f46e30d29d86942940aa5ab75570a3acfbb67623f95617b4db0eb1ac5468db02274340528e624b3dfd91b6318441085ea7e5e601b21c42d3c24e5bf14f2edef869bf8e9273b0efd3cbfa381e718f4494cc1418dbe117f0411b263e49589ad461719e38e7c318457f2cb566e5077034f0a75fe3896ffeb282c4fdd90cb204fe46ad21cedccbea9268a125835a7c92cabaae1207cbd666471753e1016855c22728ac8ca87b68043b3a751e6a727dee7c3faf22395651ae6161e9f40dbd9f855a94cc4d77e3c5a77cf6b1831aae49b56b9946651ba3c01e439fe55595dae1351a8fbe37b8ec2a993f5d3f3d3415283d1d8bb2bf2eda354ac33c12b04eba008c7890b7cdd0c72507b1eea8f318e447f810f3e039064ab5084f159a817118e2b8dce36a735b30f78246a00d286bd6dae6237d74163bafe275a87ed0efe8a754ac2594229ede04dce9d6beeffd22cdb8b1a7b72b0d4bcf62f1308cc35c8fb84ac1df21e0608630f9ae796079252506fb9ea87ac9c729ecb02d0a06a101e2e202548651913116ea6e34c3ca317ba9b1d9a44a324dfcddc0c3c41c15af6a9a5d516c9286d4ad086722720b18f7848f045594646e6b02885f975bebf90b00f5c9a6e286119ec0a65662bfe1eaeea89fd2fd1725732eced869374bccecf68050dbde225b1a927fcb6ec7b3e961e921e756be71225541709d6981f3774e286fd38e0ac88e634f0399ca6ff4d4e0cbfe2e5a09eea9fbc8f50c69493f0b00846abc2c74c01ce39e5239ede50256c2a576dae24050830af528befaa75a542c74b8ea640389826faaea7f64ab2de28385fc95587dbba22a1fa47ec18bb31286bc1b507f881e1135526123d5fd69a6fb58e1c982856edcd2501f3ce5fcf9ea6985f341fbdc40d982106b2efb00d5609073fa9deceefc177b86e5a14db7d6ebe975739613db4dbd278510f2715a19c2522424322c0a9813861075c0718890f32b1580da4a7e8c990aa8db9c20a787a86ee6bfeae1e1825ebd9e4e41f0718aa2ba98f3a3fcecedc902cae7d353d5c31561df9b602c4c2ed6da7972371c8d22c9d0edf927f9372dbf90b54ffc68238d9b481b0c65b1fe2d72c7f7de724d952ff51d79327748dbfd7cb976624b616929472ae04185f5714c92aa6472a0d62007d6c36ad7016472479023d963359e21e77662d906f15492bdb5c03dffa4d2f891539f2a0fc3257476ff553b0e85607dc3d46edf6e1c0a92af4318e692938c27640c6b4949657fc313932db51743808ddc83e0d150aba57197611af372825413bc858fd783f07c20d0375fa1ae3eef3e3fa13fd4b7dfefa1708c3e059c5da6a185fb12ce4f66a0aea20419dae2a249abc06877e00a6eb7b73be1b53bc318c0581f29775776b1b1c7bb093fe286b70bed6af6801e4b2a31b4bd6a2c8e94d8a70e6a2816082bbd85ad54004f4275e9691640be3e6059515c64de4fe8cae9a7e481f3f31550f77a66b58f1194cad5474d55a8c45d8812129cafde710777fbe6d40a33d7dd7a4f71e09a5b89d5c9d797c4be379c2e4ba23267b24b2e4c7942553dad1f5f0058833112eadd42a89f61cad4c764131afb96391ffe309b1f58f54e4c2f40163d75a1c8458c20f062b5b26591bd31b980ebb6c3f1270f75e1f37dc69eb2215c7d8a8f9715cee0da5c4907bffc0522e94539dd7cca446ed48f3de569bead25b76bdcc7ee766534fdef8311e8497d8e6cf31f607984943e299c6451b3c6e7b098d4e8705daafac8180eb189b868859e5ffab868fbedc16c0f71858909e383216dd0674c58986841638392ef49599f2d382a5e3e98c6bf41d5cf588d4888d06d5fab1c6df3c86e3639b317bcfec3e2868c605fbb57599be93da10c7cc660c3f6b82e84d79e73759d95f8913151b4bf23f38263e2aba5010e05035f229aef6c31827bba8d921ef4200394073fc37478062300e4eb694975b6052f8c3eeefa0024bb2cabcf2e751d367b932fe32ff9b123dc669e8e1c0d6cb46eaca8be05e92bc0a6cb5f7f69d29246ff3722d433b801a3c31d6ce339e718bee37c2f498a2ca5bf8724cfd2deafdc9657023bab8f711552d17d9f126d391a229800486cbb7d6218bcb77513d17893f8995bcbd06f050871dc092a354fee231e4ea64e3d8c7af7cca04954159c57137a8adc25b95d0f96473ceac073be8a8bde20b4861d0715b4f0b68f6955a888c39e485c22c7eb64853f6802cbbf41b2050a135c34a0da854434f3748ed8cc3c6caf7da9151e8f007195158376c55f2f58dbde574eeb0d30a4c9cefe683c48f9335740ba8e091612a540ba9615b548231cd6a01e4df7adadd54eb2de263cab221eebd40f01a37406977b8685da93daf6e82896810c76ae03d73120639e551e3efc8b203cae1a6d0624dfc55a926788561f00e6a4cd612c57b7bb4d3281bc621da7d1c04ab5a98d1afd5157797444e34ad4e7e5583791c757636c6eff21bb12c2b5aabb0319884e4ccb8c8f456d828c82cc2e509d6eac0fa92184b5f67aa94b8f3f4ce6b2a5ae82d65bc4d697996dc500d83901750a1617d088842e67b4054f07eec91c9898437aa553de5e8c2a8633851662e02da5cceca07fd46925dd2f1910f8fb39a54795acc23dfbb3d3fc06ffdd2ed6c7cdca87f11856900253d13a32b1f0ddb442ccd7d046ec0220f4b95fbd0bfef96c983b14f44f74a74e52544342a724e5de15419776c46b218c6c9fdacaedc4d09c35819ea3e5686ee72683fc96cfc5cf2306ec8dc780c29589e551acc37be7662b4797a326d2d1d0c9559fab91526df6a905ddb04231471d42d4ff8c7ab2a0606c3d80a81cf18b3f31d6a2f4d52992db6013a9fafd1877d2256ecddab6c9f174c0d128c42862987315254d763fcf148b33466142b337ccd22a8773f38167bc60c7389cfd422cce41517be419c1c3173143bb96ee9412908bd99e44d5c1b4b42d72d6bab81571e31ebc36826b149ad594b5c278442c62128dc823a9f873f48c8544e9feb7f4f0db18e893f16a1108a839b31c04dc0b3069abec577491d1317997d25f52d3f242cb41c9353b08ab7725f59f04fbdbbe8c5596963fa7947f87853c3a5590158e79b7fcfcbd9bd2bf21ba72591563f757ff50945c274c681266d87c04355ed3ab0d5477118408c8bf4471146b2d916ac040c1a82d31a83e105af9bf9f4862a15ed200d9182aaaea3e553f0727a00a4cdb47c7a678483c9d23175ea14a4375eb8dd03201e04f22d492961a5079a21345a2b2cc1da44b99bd1967d9c877db58de98484da1591be0ae35951b98ca8333ac6ac3287a4b357d52c8259c290fbec2ab6d71fa77d8255b4ee6405fd14442fbe5d4294f1fa379606f9d427cda7d0c1f1796f10eb5583529f268f86eea015f598acc679130ae3818fe5d585ba391b68e6597da3830dc661fde6979c4487ceba4ffd25da3dcc76ab077ae45af7af424a329dd05c3624a90c586882865d36d35408c4b53f39b5daa9722f000983d570ac76d3f7da275a598d58bcf231a76ed5b5a2124021ce9e81bb6817d25c366b264eb5dbc54771698ba7fd949efc8486fe5ffed7b2aa56e20b88ea86203803d007312e8098014cfa51f32ef7e950f8365a820a0deeee17eead438fa6e05d818b3c18c5a842d5872630ee121985c11a10dc17291a9e1526308455f7f8c576c88b3ab4b5719b28f51abe21d4075ea1be556f2a9fda564429049f4003ee540db62a5979a6f85b59752e0c0dd3bd5fc93c3b8855ad5dc3dc0f582db5f9a35dc4b2661349cd54bc339a648c6c9148b3f304cbb37ef66eb84cd958942a0deaadcd547bede918b983c5e82ce37552e1c89d9f39e1a27459e7039566c49113979634712f5de3a220e9a054b74011b3e12079316dbde8977896ee9a243ec4683d62a3a5297afe38844178080d4faea270fc27e3647c8395e3c1b74163f038c5ce50c85d7284f3d0d5fb39795619c1abd9715d305b8cdaa8b175416229936d504867b04dc1ba47d5687591a54cdb461c4c93c399e5e63c4d6b321c47aee003b0bce1cd8324369c023b3d6ce0bc758327602d67c922697f83e30f8f67d38cccfd99d8c2d189fa93f4a1cfb5eff016688e13d174e2accc70c114628d488a057c16614deb16dd5e553c8c2f612eea2c964206461e2047c6ccdf9165772e3fe94f3552c6814421ccdb0a3f1962f54b03fc06e9f588dec46e45dfbc4657209207ff711452f9e10dfc9987d7ac6160581aaca495aeafce8af7c04c34608c39807eb2da9adad4fb682dbf175a72905ad42b28cfe5af9a7cf4cee4f7564897f8f844beae60c3c5e0fb95a0c428fe7ba53353e410e8a29cd4811857ba8e0eb8bd1b39d737b2b7773dbba4658453541a5d3f4fc6bbf5c97d5f2f4dc5b59d7de960bae1340729b451133ea71d30e2011654ed804876bbefe48d2e23e2f7dc0534ab2b955dd692888df01d1c3b7bf8bc6bad625d0ef901ba291e08c912e8bf1ba8c3a6c4fa6e42f5eccee71984059c4b81b2aab4f089e0d8fb7200879e3843926c8553ef365d1e69ac8e3920764c7b908f7191de76801ab577322512ba68f2f9e68fdaaa03eab64ffeb1108ecb14be8a7e33980e218e0b2cce909d1b4cb3a4a0b55f0ec56b30dacf91e6106bff0e6683400e9f210acde6be78ca73346cd111bfaf4e50aadcd04fb6ad1e018131cfb0cbc35b3449a00de70927331df600fa576ece555d72852edcc6b251024df15e456a922d8e5f6664d8af0506557a4b40ea6f9e7f8fce872c86686e213892663a9335ebac3fd660fe89effd3b5338eae53e9f2ae35c9988c93f484683220665c9869fcc5e6fc6151b1597d69a794b7ec905b9393ecfcef12f35a4d1562e6b80da7efef5641dff329b5949f50e74b0eab690bc38f1af47c29773e39d2d3fae3ce9f82a16e129c080a5ec3561525d3b59cb11e3d942604377783343afa0b724366d6dd8f57d19a78104b546a2acb514057be06d0d6ec03d90c222a74e32e3d9129deca5df0557a8ad3a57d62d10aaf95b3a985606b64ee05b168a9f57eecb039c5bd036768cb7363d2c2766976671b06b68a285858be1220d387433d2718d594a15add358556aacd4e3522c89b10c5520565c9f82a4d1fef8115d6a8286626561a868bd5dee5b48e40a948f3ce810016bee02af0f7ad8de5275ffaa59e7bac0f38da6655d4562ebfa1c643e76499991d45d9896146eb7a571da7dcd30129db01f5f5839da0490ce6200d7b65a69463a7470aaeab69e93164a5ea56d60afaed3b13ef7ed825d44366f1479d054936fa6c4fcc5edc4f5a49a6a2dfabbe31a291d75ccb5b7fb6a1606ebc6a538cb76018dd261c6903d299e01302b7093613a431acf8484e432d2134c555840ebe093ba983239f5b98aaba7a89ade8591f942fd4aaf74243d7cc6c68a50be8093693fe62a159d1ac25556e9473421201ccf2b544993bd5395ccbcd9c04dd7924ff6b4199060b348cedc6506b7a52d57c274a9d1e631bbbe3f57fa498e86acc475d18551b604c2e4c52635bbdddf36a11abdcd3d8e5e804c600863dadbe42392463ab9d0448690e72baafd4ac616c6889b18735a7a13aba493ae7dd07d188b205d0939387152dc1e5d7e685bfd0958abe4bccbcb6616f8d9e48141a40eb1792fd94350a29b73ec661ec0fa61fa9d1f94275033ec61f82ce1ed3df06db404b88c6094a70ed96579ed74c9b78b570c4ce01d065290b5247d73d278f2d7c4c9ec7a957f8e52ec908226348065205cabf189e73c83de3e9089c1a392ff20b013d81c73bce83c53a812527267d37cfed0198262ee59e803b07c5f61ba2250941564f17407a84ea84cb74e901ce0f7176fe8c579a96df97f5ece798029280228a6b7e94aad6209101e1e0892480a15906e440c93eaf9371ff8d1db2bac37d1e1b7a8be077fb61fe519a077de794246b46afb5b2bd54b63a350e77c67ae850acb71411def0fadc009c4ac24b14bb349bc5d96aae528f40a039867757bc0d3bb58d10195c963de0124e67a8635c0de233c386287ee8fb5e2d2fba6731dd7c1c26b5198845f64c111b95b492dadee39148aeaea872e3af49d461052ef4350ef0270342053faf7073b6cc7290bbff99abb70d7091be4465ecabfbcd152e52dcf009d0e939661fb562ca615f2f64f78a561f41c8115b919abe0a7ec94f2bfa311f3459892fbcaac6a2aa6c4db7dd252a2f3b871822e38658ee233cf70cb28bfbd20346f0d99ca8523a65859bfc86b4e6174233f6246d377bd6c81dec04220f5e0f644237c3561d6766b8376c5521b8eca74b3984f9cf0aa48c01a1fd045c78a40a606441de8872397c89c5122393fb19504ff6c4bb8b4d8d8860e8b816163eddeb2ff0211aa8263249a195bd8ff5c800df316f3825ea561dcefab5e54c7f429df4c1dbf7e9bbc4777ff29e632eec3ef9e4f1f1324f38e2207abff7e0a4bdb26ec4d9e9de62d34a9c404da22a522e44ecd62a736fc3f87e7e65862ba8e354b43674b15111967667adad57d09aad85bf74b8e24f0f17066a35a044be603d7fe8a4d52bc6bb75dc634ae0f556880247619b8cfd40dc15060dcd92e08b8e67ffe35391043d6e05020bf52872624c081644deec721eff6c6961f2a9b8dabb4637f3ab735fd652923ec3d60bbfaa79c649e8e5e6373d232346bf308ca98a2c4f3eff6802a6f4094ee8de6cac3abfa8f41880e39f084b2a16be37c33bf61ca94919ddf8f78bc09e45932221d6267e845912c060fa758227a42e582d3132899b6220549f0b67ed5acaebccb14398e47e139bdbe5d84d495eb184c8021b302d79c03a9a82fb844cd056ad90da285276cfba62ed42d145af93ab765b6d513478171f9520b04ca4965d434c57bf692b5219fd9044e6d117af7377251b08516c5e35df4813bc6019bb032d60a30482e507342a852d15a76283c4d536ace809bf151017cdd37fb0f7dcc7e93894fb1054eccf28384c87fbe01a3521fcdac85a8fa428bf34d45e4275eadf9261511e0fa02370c505a0726e13f0f56ea798ac11908485ba14cbdc73edd76ce365934891cf7cf88509c0c8c607dc2a550c9ccedf64e0b5bcd9bfcf1cce2d4a58ffffc17dfcf9f8f9276e36a3192b1a030d2846a17e47627daeb81b6cf1387a7072c59ec5a2e629d8d4a5916b959f62969aaed05e4931c224c8e2d078da44f5e0fa982366813fedad04d3a7e92e00ef4f9aebb41f761905f38c38a6acb3cd37ffbb42e47e1f0c1e6fddf263a6aff18adc92f483d32556983c3db9274586b957decb9536418f6ad88f0b6fcbe1a1f1a852d44a509e9bc3ebbc1b112bc8a63bce01154d1c9c7b05251b649edbefff40e021f231fb4d323c4a297123e49c382c7bcc4af722b0a58da670701b80ad3e4f20720b038a9c6f8e7413d4a477ff471b6d12e74567c3c55a4e57609ae8fd27b84b1e6496bba4d2ff8fd9cfaed0516f2707998ea548305b9574105919cb5470da398828165741c005e7b0792b487a371cec51a0f306edb0727991b63cd5982cd8124c0722bcf9f7829d498b63f2464993801ca2b503d20f1602de60685cfc289ae5980e3c81d8942f531dfb2dc53830b09d0fa2deda79ad36e5eb7e57646fad9c339a6be5d75dbd85bd417e72a9e4e657046a201c25f45f20955c3376029f722d033a9f10876b6b4d5cf6ce6ab888d66071e29129e0a1b6897f28c4dc2dc2bb5e6e691d506c418778b732300607c9f3351ee3ca8e65764056e51ffd9ef25b481c3d94470b624fa48d862bbbd22210f73ba86e0e57cff297c8574fe38be6e98fae66bed9c71c4ee7f3dc71d53af46b4a5d26327bb7d087d3e9b1595b886bd7d3cda043fde0de853f14d604b66642c5fb2fb8db55e3da32085b293d00e741d5aa2c5e8902fd0f341629223846e64e44b98255147b92d32b09c557213bd1bf1beb849763bb9184330562fce07bd1da2d2d23b2674a86b3ca74761871de2115a5b5b2574dd216d177330d03d5b5432949c803c5f1462c6447339f9bbdce834d7cfb13efe496cf2e62732693d912e7ea0aadd9a16f42fd51b7ba61d31765e50bdb8c2649c34044049734240014dcbe1652842fd69bf509d8a406f903e39b6f95cdf6acc754d1d5b0843620a6c8e830e76e45a55926d5849f1578f4f3482fafe4b918ce6d296cbb332d39e91d767fd5692f9ad05f8796b2021f57537dd053b9ebb8410362531e65453881a8345f3fdc93a130b1cbb6e9711d94a43f7d1617ce8778d41b8847a647ff804bba2b3479e36025a696b15414779f32422b8b4644c54b5faad8ec0d5ce8bdc79830a1adfef969cabd263d01140d6ab906bb3aabf437272511707cd28d80acdc284b37de6c2a972f3918dd32b2c336ba829a90388b795080dc869dc4a63553c4edd1bf22fcb3503aaae680c9ba56eb11cb28af648cbc2406ce6ea6b7e28ef614c400e71ff1e3f055bb88a473c11e72c17e3b1d46d5b789c3d085412297f45997647e6aa302fbe6432bede7f0f29c233de3bf08aef401a71d117337a8308f7c88ccc96404bbb87559f7f7b363319166ba5564b8123f55140ec8e176028366d5d2660bc8ff2da32b6999e8db5642cfcb6ea983a7affb473733cc3ef03aea0f38061aaee81b05142b9eb9fae4f21909b43fadd9c56b98b4ccb4fb9ea249a9f7d3f3a8f72c64614a340fcfab3bc1326ee1ae7053e4e177c3f79d3d6ea1c429cbd3d951252d5800bb8f5ad660c28dcd6589f0566c48a89ea2c8a5786128bbf8e558fc520c763cafa7a087d4107e1e1b439c6f33553b702d67ca59f77a5f83f8888f9b12ea192a730fb6a3f6741d269fccad999d20ed55fa3a718aa2b805e4f6500c1d933e81be3c2bf89adf2f498879dca03719d5abb90ad680ded8d3466d379034b080c3c91fc79b388653ad729d474870dccba70fa33c3dbfd592396e4b4fd461c3571d260a39dfe9f0db91bed5c116e7b69279d89d30a6dcd000c8106fb0d0baab3d3c9e15e8dd319ec70e3b0ca5e624c6916fc112c6ed225f81f84b317cae775be1c6e16b1e69abfa924aa6d0b81220da47671b89d967c2a2112a9dbff1a0a15b8bfad7e6d18a826c03e8828b4d2b576054fd3d820589dd57209cf9f3092185885e82f7af95fd6c8821a7408adb9b394a91c0b6e3ed9af21624867957a0a97e17e6f72b21fcfee6bbd42764c6607267e842ece492916ca0f3bd3b89c232694de268c1bd5ad882310f47c43e4c64ec89e9e257de3ba14c7a31644822427dbb6a47b1f0339a184da997c7e5017f7f7244e679c60151da3971adeea8dbaf7b28b3e409a1f76683ba98e590f8c78ee0b14dccf61a4735372f64c3fd8124122b2a491e7ec12d1d77a808b7d9ce1dadaf642cda5cfcc7acbfb373597fe9fce407ead7f311063fd344c47aa0b4efd44e159a20c5a507e4015b4596ba4241deaa310eae204fbcaf9dcdd188d4d9669da7e5fbd84d2be63b7786cd9e6fda7ed837f555743f920ff38c6a50130e681aeef12a63b0ce84c724cf66b9fc22962bf57f6dc3496b091cbd1715b2a38be9e1e05a8716f6067bf7ddf6508680beb571bf26995f0b54f289652da74acc38538e8457bf056f3222ecea76f253dd41b08c4100281763f8f4d52da2427f417d888294e86560cd808345c155584974315076a3b243b842e5d24b47e2738e8080ec7c5476754d8ada78a5c892f5e5983b9098e44587ddec89414ac3357d6cb7006bb124fbc800addcd3fd4cfc39f512029b76c7c78f3594a51cf784913efc2b1083d601feb0d9c11df3d7b0f4689e7db060eba3b7637b86e1e21042225ee94f5c36fe865ddc5b66ef670f34020518cfc6982406a77b2f3b4ddb998493b36f400a485b52b024979f762d12d0cd9652f06a94f50b15730c32ed52f2ddd90f7ffffeae45d7ec9a16eaac04f852d67b93e79bf9c3e15409409c0de64c23349b173c719913d1afe733ecc81d0366ede773b3b9bdc5dbbadb23d291e021a8ca408d39890ad1f2757ec751b0dff2c9b44ec6d93f77821f1cfb227c5dd0d1cfbdbef48f7a0c90f07ffd4c47bd3b06b0bbcd6221bfbad014d7e185ef771cec1ea4080a4beb034e973a8aeaed6ab43d2811f8078a7da95fb32aea2ae2ceee2a7c7c1f1329ee2038b88a47487440d3d62dc0a422a39dced78b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
