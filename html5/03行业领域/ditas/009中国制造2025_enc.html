<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cee13c81288b3a40c492b0b8132c666d53e085b62bcf7091b04650123c31e21b62936fbca5b3ba72332dc2b3ec38f0af08cec31a2065728dc9c152c5aef5f1a38828b9bc7d8481584503a78db1b3fe61db010db279beef469fdb2708539da73ad17c769ac47cc3bbe975f77ad379bcb5f109b845bc6e8014acf007cf73026505145f9e59a10bcda6922220ee9152390b32e610bec4277e44f310be7f22ee0b6fc2dbd06d930bdd767c5ab5fbe6b1603e5d2672730faa76a403ed1bcf970e5ff6fd512326c38c65e2388217538909cb0fd115f65924730933d7cda0bfcb357f277bb12d8f564bc977f23b2057f5f3bd62e8f36af5dc86d73a881c190fecf19926d35928ecc0188fa89c1fba5338697f02478565c50cc5e0ed95cc4e9398aaacc565a599686009569c3ab5215dd749f1d8b3bb585582ca82a9101bcdcee8134a756e719ad1cb7b0e5dc6ff503bbb8227dc5972165a1e9270e4129b92549f49589a3355b2adadc1eff6a2368c2c9451f087f5f6aafd26a7dfad148fcb2dbb5e720ffa8f8e577244ba59cf189bd6a7ba3b792264ca38711d381481214c9ffdbe1e88b38fde9dca9e9c238ca611eed984fbcc7f4f9eb499c23bc322f26fc629dbb8d80eb01c6195ac44275b4618551686dabb972e9b804228943d5fd930f58a25c1246c49ce0d0da307dc4bb530d7029963e05ad65f13cf989c2e0e5833064a005f690f39dd7b80728211fa06bf1846f0fc8f698e586de87f2d92e31489587cbffefe3c251ada3fd67b5b04f1af58c12957d90b17defcda0172dc9c2185ca43799a39e7e5801dfb3dc6bc0c1ac0b1b486068e1c179acc387710365cc86772e68c936f8567cecd830bcbd726d72ad7510e06c6c0e63b2e23e36393b5cc650497782bc4908ee1299e483d602ddbd12856c555bd04b081a143a06dee642712c2e53ac33652e35b39266c581be64e8501683278e7a8b368113bfe65e0316494dba08309bdaefd700410cd134d913e13807faad01f1d8dbfa56a41b601234f8dbf8588fe9bbccdf887eccdf5128ab782ed2fb7964f17507237528b0862b3c1de64d8b8627ca902e81e3ad58088712eb0e477de9a171e4068034377da87be71dad6d3aa075b240226f0815062a506943ed982eec2dd9d2e20de04e6ffbebb4e71c48b67673db9698ffe55d2053c55f66ca1c4c3a671364a74f7d27ba334e4940feb69b0333fd28828b35f1f9dac1e15b6b8e1f844b74e5d3680a4c63a0473b1604e92ed1a34e379c1e75c7a30cc9705d5a968dc270ef22d5cc833ef0edbddbea0e35295518ca33df35bda08423592098c348b7eae0a29dc6fe63bc5cc0d11979f4e60d2b594396f31df693394139c53eea3d0b4f758da2d085e1d64d677af4f43e0a176104a9f29642584108caf60841b7dfa5cd643eb65f19e65fe3e3fe835f7982034a88c34f17bc58dae53f501c2435e9a50802ee9796f4261c9a9c4b1f40e0c97d2d091a8c0ca153fecbc3b3bc79b8af92656fb15a19fa5717ee519c6e8e1192cac258e6833b87a0f914f805e2a41b3c60759f083dd7da4b24b463ed0c3bb4736211831395e084b694af1e345a95533f4ad4181a09fc6e21a41e8193dd242fed07efc3b360c99578a69c5cc1e5f589465413ba4bf2115f26bef0526bf6cc53af41998686958fd98bea7e97b1691cff476cb45ec6909330e361cb888114e38e22ff66626ccea78995dfaba4a5d1a4c38f13fbde69f4f81b60034c439250fef94ff1fe5275c96e63909cc9bdfc3509431279fdb462fc0a7f34f06353e1b297fb694f28453d27f2c9dd579bca384f4fd3db07bb0ceca050384afdbd944b5edefc05fd72e1ba46e189ed70bc9f4fa34979e8caf9508efe7228a201e3b20173ce7dbabe28c6441ca6698c53680761ea301371d22e6d1c24fa8aea889e34884e9e63ddc4eeb8822c774ffd0c8a9c665b0ee148d5cc727395d60be17dae973436a0e7b952199f8b3ad05845eb0452099e7ef9e5055a8ea9e33ad7bed3ff11628c847b05d3e676655aa827e8cbc2a800f80169e0c6e6b0388a2510050a7f0347d065813cafefa9bdbdea33bb2813c6e84d762fed41f30229ab94c4f1c4b57fc71545b56e5dad8da51bd233512836a0079dd36ae2f113beb7ba766522c951cbd34f90c933ea935195302f7ebe62b929d3581c8a30dce1d4122e2cb975bf152de85e1e833c5f9dfc4158a66a76555b58e46003643938b87c676ddafb62ba06ef141d643147d58161cb8fe74794a80c5554ef76698fdc23b797b38de1546a195ab18ca389197cb325008cbaab569bf3d27536829818746086aaf0d4a5c1a40729e6361b94888783936b086b1b832e8cc200daab02766e9d45b44f6acf530117c01aaca6421075d1715a268c69db1525a1d2751f40a1b8a73c6786e9adccb1847a6d8ff6318c476a341769c7d3df2b797c33fdf44c52be9701ad1edbb6b1082ad94fbffa700399fc128edd05e86b9b3af79092685529126de425cef64b397bd0083b656654c3060044e3d007f6fdc49177b779da7654dc0bc5981ffd012d5dcdaf20329020e838c67879d9991f56ca186893a1a42776ead2105c5c205be68acbd4f8c9f15bdc2f9d763429bc9c937c572848dde3f530529b3824ca4e0f8f5afdabbcef077d268bc61493f9c308a7926b43ffe11bcf17ebab82a0346d60ea01fb8b52ac5330b22eb9350ef03347948813d7047eba68ab92460ad0035c900606c4810f5a03d64b3752b2f40679633ad84082d3a27d04e692cef6c01120cebda449b848844ce5faac6faced20bbcfc613b89dfbb9d8e11a8a59e3a9d8bb84bdbd0de99d9addca14fd204ab03c36f890902f12e2766228a3ed125a1e399edfff10e3132e35ee9c16195e25a3e771dadc3d3be2bb5dcc003c0376b39b372b4bd149921475f60820323fbf4c0c15bae73c72890f2f45a21fed1298cc0b91669e6a9f079fd755178603ef4244ac18919e37ca62d95e5f250708496e6285f2bedc4c55e51269c7165d49b09c5e7b732008521ea6f4620927b3ced49ca117aec05dd196b2d639f5091eb8f5678d747efab77f20b116d499dd3c1894eaf71da51e807d3ff5ccb8f2bb65941df37c366a81548db674dda4f3bcdfbc48582c5f053f50f49861b62cb3d607e4209680732de0df539263243e2fe831c9a41515f8d2570da421c2557e1f30340de366ab747b1ba49dec054f8752b480c0c68ac921c1c138d3dfcad3cf41ded6b7841d90e66cd8b60fb13bce8f2fb3e68bb248490ad5827caa64326a1a992f2a3253fe8c2a0e2007a30f45432769803fe809eda867ada9a4340572f4b9e18a562a1df91f8c44a4ae84f1099757d6cce3d84f3002ba2b90a426db27f58f91b68d75698e6e9097f464161c25a1ef8853180f000eb502f48c935bcb725ace5f71d431b3f9dbc841bb5e9a94740938027d7bd45915b8e0cdab1395e4a952aa8624cef74c58c5109969d9a255476f009acceb108af82e77e7efab593a4c00b413c7d11bc6e68cf325d612dc4b0c0cb41fe6a91a6fb37a5cc5a9b9fe5b4e84c6380d25d7236d31da1713878dda957d6c8c801434da8cbe89317ac5aa62467a27a3734c5990aa6417092fa05c6e62248552a97723ef9a59a5761d8b60766aeac0ea2ec4fa1f3e1388e68e012989b2fdf69b960bfff43292b6e250bc86ceb94b136be33311713fb1ea1b7b8c84615fa419522cfab64d7a94e7d82e9780ed470cd98c1b6cbdbc6e9d093a097ba02bfd7ffdaf36fe8413e14b6d5d01ff874ef9a2325436211a81554bd341a5bd9cdfcabe8d1a067a7d14e3631fe099328725fbdfffc84ceecdb35cb9fa5813f28de83a16676c46ec84c2a91f4225d24052531521bd514442dd57d427a35925d3cdb7b5942ed2209849aa5977c44be9867b185eec898e950bd83b6c30ab0468e2fb3454033914883815bc3089e99a51e2ce891b1d0232f5034d88f2b0b0902886d70ba5848f2e7b45d2e0f2f3d223b9f6ad055faa463061418425586bdfe3fdee78e384fefc76ca53e2a2801f218484d999f1bf7b3367565b61dd598317490430138437a5e628955aed40e850183e8331883982ddd90787fd4490065d91b4d727ee7b643ffe574cef386ec262e10e9d8ea107748f18abb9ab548e2345939b6c233c053894b72b2c7962479987c622f8d93261059e82a8a5671d5325ab96b79e3aa65b7cffce45683d8ae7f6be23d0b3514451334a26d1b8793c5b3a1f6a47e15eb4a448dc74eb72a2e92efc33feb607e46aab66336a81db1e1d6d83f496be36b0fdaf377b274d0e13f2edfd93850a30d7ca07dd05a871a46139e8b203267b9e6ab8712baba6562a44e46e171eb7093bceca0da74466efde75a43df99c0d84ca537866a810c6add51988b616248cf6bdb472d32ec696876abfd72028c15324a9a31c14f5328e3e383485f09aa39f051968aff0082c48d5fb8e5e1ab9cc584e4822c3d5a2879c70ef8e3156fd5e1fafc1ab544b16eb46d221a95d73a7f5b9d25936313f3e3e7bc2d4849acd5d8e0026505ca282866dc0bed37909ccd6763e18ba3f93d1b3f1873143f60d4bfce9ebefd7a848b86c8eda025e815b39ceab4fc92030aedfa3d9c716253516f156fd3d7810bcd6cc7cab2f4d79c16d9da79983f10a4cee19f63d559b60eeef6c25bf45a1c7cc994a0bb1ae3bc0d606f0f10db726279e424f88df83781cf2c50d72259e52c81268b851fe510e236dcc337d2e27bb62d4cb7e37989ab15d0901b59d9fc426ed171237dd32331fefa49c147e6c619273e5d65474c75a6a0150804ebf0cade77d4e86e132f5ed3cb41ddf0165d8064a8ab4a94dbf86f400ea143815cf98468b7fc3695e5dbc490eeea18c03f5fca2323544c44c2295bc22f664acdada132e87fa3bf360812090ecff6a642752327779846afa91ff543d918954839e3b9b67c9dca33bf8f1644c32704d2c41cfc47a0469338fe5c5ad84c097184d55ed42acae215d68b841677a76b714719bf04d622fbd01d25907e2a76504d63a5c2915dffd704630087a6eeadeadd186bfa4cc6a15086c111abae71644730e3d7b161fae0d3f82b02985a1af40d716ef77162f5d08d5ea936d6105fa7601791a40f1cd334372f8fab16ae54140a179c2d90f2f4fabd3a2373706fbf65dd05886af3cfed6be504d5bf042a8559c916a2db00c218dcc76c2f5cbab416073fdd1e17ae1eaae3ec43e8214697bfb50dd3f3d6c8f3eea06d35a0b7dbbbef98c4e34e3deb972b13b1ba65a74d01860088a1249496b43ba1e0e595e556d0b58e3dc66d03cc31c55e49cd429bbe308474c3c70d4598f60b1f5f0f8266c773d7e3f4d1900d55f02a4be3ab3f11fa44116feb8e86f88b283f687ed27a4f48b4519269ea372582a47c7639f1a0528b19b5cacf762b2796f5e30cf62a9670b3de81c9a5ed4ffcf557f9ba1389aa7543afb3bdac6584a40a7d9b46b923d5f5c2464ccb541379e3a399e67275fbdc659436c2fd1e35c52607426e2a9071ce5b93dcaf47b5ea3e5de9de6148f29c47d95dde6ef1311496a13500c17981500999f666f5d36a1aaeb0845bf7a598b83051aadb8216e1b4511a787319eec9c3b3c4124130dc25580c25e3ce70ff1b29db63b52f2c890b06bcf8e787828a15ba378e13e9d64dbdf415d269ade1e6ce166495d8b7708f26df4423f54ecef0f82d3652c87a9418749b058a1cbfafa0caa568fc0732986bdf7fc21d2f34ba6215603017e0bb40c9398687b3c3d93a574b82a8c78b5b86d83bff7f193b332a5b857b99ac8e0732a1f9a3c8a06a5da9e156c13741464046d32b1843be6369eb998761a923d90d42b3aee9bcb19e08050294b6dcfaeb25b2cccb9375a496ac825a1e482f012ef4a341456249449ebfa08cc67cbc0128347b489f83865b2cb89f826ed7d6e3f91c5c27907fb6b0f7c3107844de4ff1ea8e01089d07bb6ed00b38454e368eb28d9710badf70a5242cc5590a892bf02194dbd09c5fbcc20e9898197e224aed34ef2fbf2479843b2dbd0433235e98ca3f0af2f2d7b63ad7ee4146aa2a7cde47d7e24b4265fb3341cf2b397513f57188d7003ac2492d0917f78de658be28deef415835ab4d8ad637fd3a1f671a362add5e9fc9e1c7bb5f74d01837067e8b96e33fd2c5842e7836b97803992c4f1c65df8540ccb9c10d94f81a9d6230e5183cb036b9e235f2323df2bed72ba9e309b8eadbaf3fb52dd2026bc08345e70e63a92a0e636974894361c143d18d646053ee0a539854a5855ecf99409b742fc704390e3668fc35cf1307f2acf7905c9eece4ad16b26b3b366d929b5ce6ad2ec26fe4dfa6e1a99d78b8729ef4201fb4ce4459bab69c5d2c984585723de00a9fa3db9a9d429b50c151fc1a9617252d9f3e196be3d9c5e375ddeebdea25544117dd7309ac0ab4e0b221ebbb4b115fdfcb0283af3f3532ad9aac2eb492623f55009369f6dae4c626f372eb65097b7c727ab2570bbcac73a911c2ba3295f5cfb4b9c65b97adc94b6097bc2cbd8e46855ac092d7ccc02a4e23ac0a339d4544dfccc36adf6a145929fa8cd79f97bbe2dc331921636b89f84b9f3e1ee242a9cd2871c77bae398b836636c1ea2236c7e6dd5e1f622cf688bb3a0b8fbbd72702343a5fda9ba5318634966cbecdcd4e752dc639c8faf5c1018e73f2b51def38f418c015d82a90a2de48ce729be3048396f99ac8925e1aee04ceff12f6c9c37da8e744a77e94bcf0e89f238d6a49caf0b70ba570e49954abeab60ac9beb8790b7b2562f87056a002312739c662d453696b5caefb3390842f887eee5f0362a8d79246516e3a9053e7ca148ae32242bb5e296afe030cc20bf369c912671b88f854af4d4874b916ccd903368626e8307ed5ad8532e445a2b2bea74b0e77cb8cc5b00fd9cfd36d34dc46afb0dd65bb8aeca32b16543c90b59a552844951131bd73b1fcbb951424f64c0ec2b382fb6cdd536d7b3bcab8dd4e2a93e7ad2cad9983241d1d5e41920fc87273035e54881523d5300f1c7e225779b01221a939dca478ccc158350baf048abed3ad735a185ece672b337a2d8aebfc822020115cbe96f2d5e9a07f3d51f226a947c0d781bb0aadbe5747c809da6d7ba0535c90313bdc97d601bd5f4ba530acf60fdb63a92b723c2b49f790520f289c0bacd7e053b593ea25219dcc1ee8a4c8ab2c2897ba8138bd749b4a9e669c292850119cab753532562fd4cda65e1e228badd3640f53a3fe349f322bc211c4d5eba2f3025b098c1b6d7f15374e9fb9592fbc630a54bea3236f20e3b549fc8f8fd3014c9f8153ab554f8eb9b8abef9ff145f78e5914d6d6579f98b7cc1fc58c7e7e9490bf82600a6e10f8b394eb9018840b53633b2141a0206df90024c27c6fe2271cb25626e2336a7caea4ef2c8401abd645453d571a9d62576649ac94c5a5ba369784ae27c1fb0d32d1e9437ccec0b86b1004fe49dde1b94820516c96e14ffcd7d6f180ad48275445ba779204e4650922f26dcdc9de0cdc02c5a6f997998bbec82478df68ac02855624ca2bb17d2e2fa10151b0893bf0680226bea8017e0f4c3495c086c3ab14197e9bce1b4a8d27e83f2b05b273e9da038ab4e799b807a565dfb3f802f2c834825b2bf9146f07ebe9ccaae398eaa6751b1157b75546b6803a19d8feb5ab5f63bc8a56aa99426fbd7d4418d11cd49c26c62414a83ec33f47998804fcc212f9639572138a023b32aa90214a6d202c728a58ae65e1c0fe16fba0c515f01b35356411a5200480328e7b718601ec68463e4d9d753bf5bd648bfe7ecdb9be14b993d43d16283d5d4a1dd62149cdd03de9dbd0ed9c4ea65ea7ab8a356a93354f1e8ff7ec962c3447564be64beeff0d03ecbe81f47e026e53132af45fa4d849852ea79bb69b803066b532468f1550a39d648979b0dd58961706be3272e5afe16a1c9d7bb036548f2887e213734e06e968a8fa9958b0afb0c007bf4a84de2b1d582ecf88573bafc32233a386dc237e61777145a9e5d69d0f702ac4cdcde1a89c6b8db813ee15debca9f00d701797e7760654ad28545cb95cbdc5af41112c5ad595a66930d84efbd2a20dae95d2a02630c1740ee42d0df853ae1919ab67ba78392f3d563374d5b857e75eb75cf5639891d17ea4bd852ebf1ef4c5909d83ed217b686a4dca613b02eb548ee9bd34826823860e3e2fded45b971197838bf0fb598da97394fccb345d1f21197bc658590405cbf86be695cc0db173581eb38fd5dd848007d68c9fa03b210acbc5154867cd7aa84e551e4e95650137866e7c9e466c71eeab0985b841c96c2aaec48d3930872e7e3d6d57d54cd8f8d746942195650db9625cf923a359838be5039150dbdb15e5ef88d41dd1c58ea59849bf6c51546843153934002723523494fba658a7292bc420a2bd94d77c4d3721891b395837512f849567cf4d617f9c63636d95c2ba5ecb3b5e7f868aa91c380eed34c8e23c1e5f897ad859aa8eed3c298bd9ae7cf7270f93b2eff1a1adb69ab17125547a55cb4df3bfb72f2ad9325c1fa0def925725ffdf540201585d8e40a1b3068fd9ceef0007c6fcaa5d1a88fa1fb051584e45d9b0818179a12fc5048570b5f5e09bf6c7f4abb31626b6e9d0182eafc088f3807693fe92790ae38eca73a8fa79224f0660c649cf3d2d0ebfa9bd2dc0fc6bb966c0f4ce1b1751637d17c014a4ba9b79fa73a1455dbd538022006fca3b7235fffab4293a28242145b889ff918864e389d8f6dcc1347680d4b0c4e68d478ba72e69c820e86361234a4ced74ff30065f767441663e1daf3fc573a9092f29e78d25fedae9280e7d6c77226bec93a9c1f6824539994088b030e8e1af9ed6916c9b6c21af55d578d5080f2dffd2eda22aa0024040815f5de16268ce1cfef3a09cc26c5ea4eb1ba6a30e6f1c3ed17cf6b758aae70570cc56b61919c7c0747bc6cd6fcbea3d05e1b0aef4d019c7be53c0e1c74371aa7bdd1f97e28fdda51db5ebcd58251b80d336d8fbe170d38527b15d542ea012073cd1a75c2eab6d2f5cacaee2004ce14895d8c67c1a8410578c89f7c52cc28c427164a9e25650ffde0cf69046a93582f5daa555a951d739ba3a16750572951c485563ab2c5cf9aa6befc370340845232af99c4a7fadb480d923b7e09b78832ced707c5f93591b241aef5b963e6c5f66bc938fcd87d2a11da66157772f0fcc030c44f0f54145b57772abf4c7a4d4bb87e3cb5a6efd1043629af55aecc814378e0c35931c77068a2430e94cb33ba28aacb6c7419781dbc108f562553c4ef4cd24408c23c85f4a11d0c13554ea693c634914bf864f5bc9b8f3fc7e001c05d047b476c294da7d8b4e29e2e0c131834fa524713871fca67c621525c50cc9f945d54b5e3e48bbb686d1d72f390f4d346fe39d457cdee3a944b81cd92f309661c3a8e0a76b1c19a56d74891d5af9efa6912b4e127f0c494e5de50c208d77f1684bee49292196c42aefa2394c5a035e86ccf57ee1ce95d6eb763b0abb88949343e1db86ec4b741b47bbab7923dff787dc273b9d9ef8510130db34b9e1a9a0fdfc645c25268aa1f0bd5e9eb09e8bd4e49e9ea00e56455801070e9260c6494636ac6b9561ad491a9ad4a56513b054ec1bf4eb99fd10efdd64f8caa6b73de9ffa26f4e1665450305b2d18ac5a06976423b93bc76cfa5895efb80e2ef8e84640908ce78e8042dcd71ff02f58d1c2c27607fdb6b65640ac919c09902bb362b4603c742cb4db1f98a3020f4d1dfc67358bd0177716ff09256fa300b3472ae0df9d50b1f83823d2d2c136f2bfb0b8dde0fe92bc5620b77dea44833404b2f50ebfe534fc912b00c8956e9d5a4a47942facbd4b65c1a685e87fdfdac233fa190011a2fd31416692b471b2a0202889c8f50fbe631bd52c456b7b8a31d269cb608c8f7f7f4e1d63aa0cfcb703a68225859c7c0956a6e2ef8dda26b77142cf9dd5007ee2dd910af2ddfaa3092718f665b280e6273b04ede247afa5ab6c43c5f89a3ba8acf9900c622b6141bbe734e719f4aa3b7daeb824974b241ba44b305697f3ecaadc36080b1794f9758c4b53e20a6042db9fc109175a6f65cab1795c58c610d8a50800e1a8aa12126a0aba19f8b32a56fd35fb265feaf127c584447f0249cb87bc6953d2c63474b892ea09b6fa66b5309ddd0b31d6d92e6c06408eeb3fa251249e237b28f0ad948d0177c2beae8940146113082c24ced73351dde999c08d3836feb90557e243b7bd7664c2c4be4236eae26d527c841b48f26ef89c7eca7538a88ed8b07008f983845c3529f9fde9d923ce511e555236fe63da58932e98180a11971f9364a00dd154c0c9b53d300e7256a7e1930c43f36afd1b99e14ee942b53bc88d5f1608953ddd352a0b8a19ce475acf7b0e374f04acac8b071d87c0b14bd092bb8a6825564578ccfbcf0f8cf7416c924bdfa12c926882a80e72a8c4498f47a3afb7860260ce589d49e2d630c59e99ecf88b2d7d4562db4f73766f1a402197baa0927031c7ff32700e4305ff531146808170ddc15ff2167d16a4a26bc9879531cf819425ce0bd99ac1b8dae1417a7f54a1dc62b9ffc15d7cffaa6cd8f9f4d0b23611ad94a4762f9eeafb5f8386a6c457d2425c5850ed277b0286bcd1e9575b11b23a321a3070ac4f58f9dbc1afe423522cc9183a7f2e0bb1037b4fe414bbc12177bafe946a8c06a07da33f292ece73ca6f4b48eee7e844c93bcb4f9049d9f15c8fe9b5e3e4080725bc5f62e2e2a02941469724078f09584551630fed41aec96ab158e00c8c9cc049fa69010fbc9fafc138c52c22adbc241a0af553bd7082429cda0d6b7174a0ad42d98960f9a5e9ff886f9e04c71daa3d004e427c5799353feb11451c66b9ec31aa6495779edbf03d3be88913ab04d28150ef3586521c088331b9198f1445e3351407753244516f26e5cd19c46b6c956231d5d7853dc6a2b84012d2b1a9f32e35a71666776f66804d0ab778030f041a9ce221e54e7112dc0f36c706e187e8979df8ff6483c25ba637fa589ff75134615ae2a0bebe7703dc8f4670cc9737bc66509014e39f4a40680373bf1be081ec810a1f898cab291f975823476971fe5697335c75ca5879c11bf033d9080a47324c61c58b3574dd817b4e8a71c537f599ed21d29d87978e6b0ba3ee4242dd45bde4d524c40997efdf9622db8723e85920be503a0df5fff5679ecf55da67ea63be233108ca6aaeed67ebc333cbfad8db61d3b1f19d9b07547c055043c0851753707378d1b7ef8ccaac4139aa6201bae4df525ca06c043cb3c55e713ca4c03f491febfc907ab30487493c2d6d98d959dff55ffe4b782b5c5b9f39de456bbfd7d3d325a3d895c8c21d0f028542441ce50f07fef648b6eb4977dc8b97bf93bc7e5c20070211963cd38a66b798f0045f6deb6eeb817c7d2d027bceaf39253a407eb6caded76312776640b3b9a06cc6e842b6b4d373de387bf7f525359bad951b88f5032d5f5026e405dacf151511ee0b53bf21582125e434b31f6350ecfc8d520df96df7427032a7f2c69e5ac0c4a87eda9628a4a11e76e7e906eb6a7a86315cfa27aa0704f315d08080efa29cd4aa1f3b8cdc835d513adb6511257e5db5554f19e9d3224c6cc8be3f5675edae4f26ff2284566aa367722d1e77f38f9aa12b82592e63191fd0b79322f0f025e51b04e5cff11707625bb6d73a38c781aee91e1b04abbce4d36a8d0445d2c7bab1f0f0c9ae8a8213903b49289d7869a3cb44e8adba5d07c3a9d75d13bc70c7fdeb685166d9c4f9926ad8218d82efd41c2d63baed70e583b3a60b82e10a519100bcd54624d09c5ea4bf740e9b744af38015fe64a76a11e67d2cadf64c1165f87b484a052cc43be4425878544302d3feeacecfd063243d3a19a4ac21feb0c170e0e82473ea1efe4eb652a8b3ed6bb29d7d8160f801c6fc59a27ecbc341a932c677d9f89b321766b44c5bf0b351145f9228754f9347be05c89f2af3d8cfb803d7625c4d73ed6f93906847330e936a5cbc26d65e5109afecbcb6914c96a5421c7a2599d41ac55f75e71e792b46d2b0ec09e7a7461a2e591cc44e309728a59c23444a1d8968f0a9a6eed444e76b8e10f5241468ca6c519769e348a8d6a69db799774ea0e845eff00e02c8f0886bdbccb94652cf26d5361566dfaccbcedb4a12d7ff36de1fa0d69d6887d04e5085828f2f85375044d19e034ffc73dd965caf5c38811c1ad8d6aac5268b033f331ca154ad1a76f914af5f5f28b3ab89d3c34229922836e839b475ec3534d8222aedb0dc0d33c9ab7ac3d11c65020005b1d5b1def3add7cc4bb3b7d58c6566f8eace2586217979636f3079f04e3008e1cef5b35dc11c783734714f95a38154d830184eaba49d42123bbfe4830d386415e07d9371b834b3e7d89aa2b9a6288cdaa22f765fb2d8436acd7cf6315aa07ff12cf7bf5616140350d42bdf7647975e0e246eb2ec8252a4057b45f5480a242a7b170f87ca7dd1ed14313989dddb95f434efd3f411691919fee1c4e046c2ad1e286ec101cc2b630580054577f7ff219de43e8e126b3504a9b3e5f9bf8204b7364e2577914ae11328fae9a40974a2da8ccd748a0a2af8f2fb969a440cb92ca8aa6d935d2a4eca77086bb3d99be65322980e19459dc9a09afd9349c8476466dfe1e6781a094e010f08b8ed6627e6e02cbda8dfc1c20a8f3b9c4ead58994dd57bc3c517daa194dcb09e6826cfa497b36bd7971f796e7afb999ade810d375c8cecad43cb04df6c6840b6beb08e634e888402f93d3c7490fd28ab610f6a0b09b742153245e98ba6afe2682f1f97c658963e1973472edb17a52a34cb0ca0acb5cb0a52494a60d6f43a8b55e64c13656ff79e56e48a682273defc12bc1bf8166dca21a84c0b398e36d94767d2c887328d435b1dd549efc1a239506a9937e5b01a4f463030e32016c10932f0364004a0b84b1189c8177e8c30816a161d996e6cfff9c631e994d4b4feaaa208dfc4801f385c126ca8977e008ba28293676ca76f277717c069da786840a148d63b76930daee7a33c0e4547a2baa56ed3f78e214cb313c22519085f371fbd5991881ecb726985042e8118a64a8002da6192caf96346a5e495f828c37823164478d45aead7ecbfa72bd86b4f28c664d12df92e9ba0ccca98be0a735dcfb5fea539a0dcb32994ad4df60bbf94a3a558e9e4de6d3fa1ca465d20e20d17c4784a59809686b1a21b045e8135acf556766f9d8ab413f5f0c43afd8ad603cfa0485029550a996e40af9ac46a47f57a994ae5eb1b12160f9239c715a939488dcca6128802e6ec1119ab870d8591de851f7dc3405c4b15a800e7346e85fa70690f2c1949df4eaad58c053fb2e6525c7632435287b8bd7a21d8e17cbeec8b2bea7c5393b15c7e132593f01d7e307861dbb0f56ae707125568a7f77ff5de90a1c867de730c427899bac7762c174c3e6a15f9f0d619817115ce189675548bdef60ec4123b35a795126e4c569c217dd5fdf063ab929e41eec2f2970091df4ee46c069d271b0597be97706c311e8f17c9ed224943da16e37f70697e20a2eea3a3000f6eeade9fec0431d3eabc58d7a033860321d7710191e705d791fa21038209308d5f23b5a35d60d26fd2634c7540e3ba9569c303f23093869d3b916b7bf62dea824e4a810e456501f3c933b418345c000e64cb5bf4c08ac20fef8ff13cc88557aa841af4d146391bdb00f04e543667797802356d10c3fefedbc9e33dd1c627dedc9816f70a0e4d7440cd284907c85e69d804685a60355918944c381d9e4dbcccfafde69e30d6ae8d02e0a0aeb0fada03018a8ea7b4e89f72541d816d50d7e7e788da870fde1a60d4d35c7dd4ad98dd005d7d2ad38143d634f9ab36a6e013e2e3840b771937ebbf0e519b72a5b06364505b6afc4d7d67108864aaa75ffe285d2037c3280813371f4dd7b823de7272766843ec0aaf696154c1012bbd408acc92e5c19f10f376c4f476ed5f81cbf8f55f95d516a35c364041f4f51525d4b58102d7966849869b2a4cc4639b164f687d1e4588da908766881e83ca8942cbc7596e31279267431195cb663e2b384faf70b34415797a86d0261302efa751cec62f105940e848ff14e7ac43d36d66e6b9f39ec0564dad6b0e24585f626ad2af7126b21d9693149c9e60fe6934a6ab3f43966b0f063c13c2b63e54b33ecd60541be5a5648a4d8ec0914bbf006dcae1e6305c690904bfc4c1ffe67c6b334713ac728c47c21435bc5e820e1a0fb41d192dc4ac807fc4b276d60172125c22448a4eb111d9f0bd15118499424a167954d610c77a65009cc21ecd26000bf73dbfb29b706b3c33d0d453c33c938607bdf6ca0f0ea54e98f84498570e1cc4400a988650244bb5348db855724b1ad922fce0fba8bb036915b3b7da65e87672797f2ffd4bd0cee1250a9b9cfd46777a06a698d961f39711dba95e7721c5d5129e375b23d6fe398236dba0e8d9d086c85b842f6bfeb4caba2d3cc8c36bc3c5ee19f6686edaa31259d580f7c6a92ac9dc45567c6ff2df9d105d90cf40407c4f49b7bde671175309a1e9ee1a9217b55f6cfb830f1359e0416b281bea42c5a34c626ba889f58862b52b7d3d0d51ae46202f51a780ee84a7f4fce68848f8308fac753980295206c4bbff23f8d4d3768119650997591b4f3699c14d34aa53a363f15de1b5adcd729995f8876249747c21fa36c5ecf0f624cd7dedd9a2cc485ec0e76273d5dbec20014418b71843d9c5a1157905e91e399fe8d771c5253540b5545dda31a898931bed8b78db3ad5020f995a31f8160ac9679527c31a74ec3e3c8529126418cf6b2250d8630ef37e0aba17d69cc946683c7512d0832fcd81736a5e93cd9f6a3e35236b19fba9edf9e481d34d8cd9f4ff7906286e3ff605997bd117b6b5f828678d0b8a74e9012a24148fb8e9363b90a7ddb33369b9b5011e12c06d9a635662c0ae6b69986909c20fa0c29030ca515c973a0b6917e8abbaaff8cc5337ddd009d32d07bacfd1728beae95de8e8e2e53cb5c31ab733f882e5af157b6918556e8f79d9ab48a0ff37001c307a48f6711a116e37bc044e77187da8cd3038db32b2aec71122ed3205e5bf7ee84a30229cdb0190e25ffc94c5d90fbe58ae66945865c0b0cfa56641f56a9bce64fe9d6695d99f3efb37751e6501d1fe94a51b4ec3a77a29f0338cedf0e745089717c050a3cc47628ebded6f18dbd72dee84e473d4c96963cab15ccefe8c1a4851fbe3d41eeabd8bccba994f7a8c3af45c807c099e8e1fa9e066185d14ca9cf075cab93f919adfa7a6a67f79fe1e1a96b0bf1c20af7b46bcfa932da46519363516fa4f2385e44a8403676abc9c99b15cf6071d010196efc33fcaf8fb3d3324b7953aa325727621dc6a53db4bc8da4fcbe04e4234fbc2691e775cc88b3217622960143c605f66652ff8f3f0457380612092b548afc05cf5768a08696b1084b6d89fce13d959ea17d614d78aaaf69fc07482cf895b5c41f0eff1f0757a3ba2eec35cbb3089f8f49ec81455d0c6579020df063ba7dc5cdc857fdbe48f2e5e71a103874119933ed90f5cc3074d374a1f351d0aea40399b263f1b98a4ec6a1912d4ae4dcfab3f2bb14dc19bbda906226d675e0a4d5a4023ff57b771c4776df8c5c1cc4e25b4d460fb8d7068de4ef03392cecb976f958ac6f0bc4bdec0b0ef50cf603b40bb3fcfe3508c682017019bed241d9a01407aaedc6bae39db63d849f79e373fd6165831b5dc35f7d45e18eabb36b0b3fd6dd1e4fe1cd4ded1cee365b7925d6b916f8d2f0eacc7e4faafa1a851dfc73a566c4f2ebda5b5291aa491256b88f0e7d1aa2df9cf5a458c6ea1d2d46c607865c40b106265bcc1ee36eccbb06782fe9c7375fa7dca159fa0f5f6b72e4822db7de84a83778668e0dc577460f103faddac6c531a7291eda3c58fdc924b19fe12b977ca4f0272cd717e6b6ea902c11870e204165a219e9b2c7bbebfa56a34b3815ab620ea9692f7b3b1afb3201ebec99800ed56884bec5f6b852e3a270aae67f48c6f04467cd635dcd47d508154cae81cc53d18d3d2d42be0ed582dd2d9fc9b969ff19c765ce3dd0fc0df13f653bacf9091fd55c721db626a34c85c13f573ffa496341cea90df6e57695811c1b06b95df93e8ef7de1becda1734ea0ca0cd46f219a93885fc0fa74c5193d05b8c63d970c5e50bf6e39401db4bf1fb9bd3e1224c456b00deee93d19d84d3ef39d7a25d5215a0bd9703dc01dcb05f93209cf2e9a87dbe952ff4e55ddd9517952f6f4dc23a771df9d0f9cc28e98859a1551990ca37ae3b1eac9e635706d10bbf02786ddd94eb1d87839e7ccf6b6620d0268f08cfa2aba65e8dc781da385218fc177b996c4aaef5cad0894f692c186c8bfd44e3b613a64b367d51210d3291b7d24165ec21b48a70d5bfe5c819c3fff730f70b0f8cb41eedd4ad3d6d1d4b6db7b54e1e2b44090a9f7bbe4ef0a468d595bd6ca02a05ead32d197b7d576816f80b5b8099c3686ecb45f32dce5b9f2e066cad39c0f139f49882e11f2486c4147e91d21ac1becee3fddb54665a65a5a35204b8ca1244f15e7ee2a87d0e088bdc4ddf2451eae9fe8601b930308c5102b50072fca44c11d04c056f21e8ca8cf001bafdf3f2fee096ecb9bbc54296064e8542c093e926901569d51aa96cc3133527b180dd388c7c50e4e4732a4bcf5ca0e8ce596bbc6ff328d5cbb4bcf6e521699945cc88b6152a45595eea36ed017cbd04979f97b23fed0ce60feaf92cc2edf6e636e67fa31b392264bb7e44d3eab477d11e253ebf95d11a97a85d0b1946b58b33d252ccff5ca6ef45a5207e9c6b59cee1aad40faecaefe0968a80bf0a93e20784ecbaed4a37d2a02041a9c1004b2e01c537f90bccb1e762c7569dbc550a0529b500a857bda67e2ff6541ff75f8b80c332cee428c5e8dcd1827a9bdc0ec6d7a7f911967df8d80552ffb9779c63768d4571cc9cc7b6327254e59241c9932fa573c27f4b50b66380cbb4a16a4e3992b1cffa46c5dae8c8311e352e13f913f7e8f9076da336023e9ce42c0453f5fb598a728c794971c048d9487bd0d97a3fb2494cf55b150c9d493a402173b7e624160cea35782964928881db00b356a1591cb14cdc940cd484c0726e46f8d6f617d6a5751c419e0cf5f049db15d7a5a2e19493c7f2e087bb32a5a1731bebf9dc1b9bd344f90a74a09323bb81da251d2d2b76e5aa41fb479b8bf36a856af523321aea8511a44bdd5c22b8de435595a84613c9cdc310f416a1ae54ea8855b9cadc50134d674c7bc495cdec6f62866085f52add40c148096bf3ae27b08fbdea786c35893710f121b4e31a450ce9f2b784ca63916949bebda60bc8a9aff45b498f1c38955ba567ef65ecc59cfc3e051cf93e4c5ba03897cc5ab5c7f851089e90b00609110f57953c205da941b5f525da72ddee503c4a0bf6cb993797ff3ea41af4659ef8a454ed389d46e6d2d9ed2a33a8c8a23c0ce94fa0d20c0731b15b17924379555bca5e7ef7368bba66c7a53d14d2adb83e6d964656f47498d8801213036afb4476dfcca08daf1c7b8b01c1e0c39e7f86b6afcd160a99490dc55bd416a087b19eded27fd16de2251ceefc8def12e98a639e037e4b237912fdac4492182f54968793f317e57b0065f03751ed6f0b9f012764bdcfa01db1c2cdab2e70b58467efd152ac8b323e4aef1d00a131e8df5d37715c542b928748ee65bae3c38421d9bbd7a0036be08f4dac0938e618e7bd48d4185ef3b3edbd9c38483d3a55e2ce8e437ef16616d30a2ead58b1e43473051062c7b69a34406fad02d5eaaa9bead7c8cefc720bf7487579bb4abfcb161b43f5f1247876532718d2bc71a8b9cb265a8b6c19932bd1b77ab00257483ecfe8c98fd8c10a5302154c922c3159b884207006ff93369600aafedb8e62df396a2cb28486443325c56281d76b58ae2c18a79c731d6fc123a7951a5fc304bc20e7e7795c3c5d8e74913195472d54ce51bfc72094678571e566413436960aca9d7e8cc0a3fcbe948b9e0641224514ec3db24d439191c6f3e1209388b213be572527185887cc38057af740a4d13c39026299f7b9fddb6fa4c9e90537d99f64f2931b17878367b9df0266a39d175743044a2807cbe383431496b18cf01c3cc75c525b8c4d0dc91487577c72808828453abcb0aacd061b15e1901b51fd1e84c5637e17a3bdbcea417b4765daf2920e441a68a979f772da4459e4ca59ffc898db8575d64ef05136c87a0aadd3cc62c0e3c7f24299b0c7fa316782bca80975325c50119d00c2467cd30f8acac9adf2fe2c311df1e9fea38fb2ceadcaa16a3dcb86e858a05f5240c48c9fd8ffb426384e0b476189595e94f1cb09215c607d76d9ae9a7251728f4fe8f5bc7c0d2c5f9d3127f107f4e3bc94084bf73b91cf5e5f408832cd8db99f4be8db26326030909373ad9d94b8841bb411584212f2ee5100dcb48a89d49a1747b17456bde2c01579bac2a30cfcd9d0e9f5da1909d1fdbae1ad348b9ae1a1605218837a326eb1f58338b54325f239d9f3056589337a35795e5ca55e302197829366d9c7e076a489a533740591c88b1971dd3a4a9577113ee6593ef845e2cb6e97d99d6a2618067673bf487caf03a8a4b5ff51a44ffd91acb8af083d193841dcd1cfc9d1a6a1df4d1edc434702070bf6f279e8fcb2297e40d445b2f0cbee963da3b9f9a2028a5346d73a228d154147ad796e3f481bd4de8d33e9b3d5e99651276cbdb313808e4bb3c2b3c4ac43bbe5e715746573b17fea42d142df3ba918c15824359316795a87b15660cd1101fc152b3679ec16a86e551578022db3339257da27ae0566096371dbd80739de56673f1fdde44acc8c1fa95d28b280ef20e4ae807b6f86593a5657edfeb98b64312d111c3f0f8776b5407d4a12be9e19f53429c40c279c15400c360b682b8a1594aa6027bc36686e7105a01363729dc142e1ae2063cdc585070faaa7e6ee84610bf2f94e106ba1a89dc157e44bbdb444d245d2f069c62c01ee7b51cbf44425576d5e9df9284faeb5df5a4a6184040d250b66bc1ea2e6ff68c0ae164e46139bfa6fb89d10a6bebd74044207da748029e36549274814f7934931f770309462a9dce956221b1e07b7c0fa91570afe188ab90e6254bb0172aded8d7739de9384be70910f80744dac37de4d5c4bd1a45b0e734258c556a6c8ebf30d476e45c28f7a7080e349576e93541bc9a761e9516de3cb3581a6eb963c5d9e616caa15ce9517538a99b281f035d3db21ce3dfde427a0a775cbb485d3a1bbaa2399dbbeddbcdad1681e7e7ba55bef9b69ee3fcccd8c89195c90f47e8e75b4fd985fdf135f73972fee186e53539d76344fc6cc21ebc4199cc64dc9d4468fe8e8b66baaab7a12772dbb872f7f03362992310538449c3085227b2db0a9d2eef05cdc1d629e6ac7549427d6a7cdb1dd166698db27cac9ba9966effbc53134d648b42a918b494dee89d517cb5dbf7cffa83e4bb5fdd8bfe0d4db0521c365733de66d2720ea272277aef706fcc3dba1e4e8679abfef3e2553b65ad40c447db96fe1fea1f7ba6db32ce594e7d45c187a7e7ec217d0ee3bdee2e6db1a235f9ee88d340bbd739294795e0acfd6b147bb35fbef580b5d4f85c0e00ef3d7f141003757c02e7532141b127184b813c54949b6a84bd8ca8e1fd6140566d5522686d02b586c784b3ba13f8dab45b1bac9b8b1636098d8b813a06861144eeed343be9902280a69e717881923f29046154e76eb8339d733dc9fc48975bea67bd2c16fafe045c662b5408505dcd299396ad83020c866ca654bf37d9b80e8794c98ad29dd8b0622a56dab5f8374aa979fbc56d22253890281e816e8f6a8d2f30d9ce56b3d54d154464e56c91e0444d2c0843780d63fb44702cb4e7f7bd16db9765dfa4d0587dce797c67c0af2aaa1b4349bf369d60264da3fc9afc450b5354ff3083ae9f359780492843677e53453c80e63c35fed73980006b71eb4629e4b548ab976950ad61c2c8205cbde153f19fca05ba96f6c2da52c01cddfb4a7c513349f5d2bd69070e2217e99fa4393c83c1294833dd7fb086e28128626ea5d73d924310938114ad9b873ee9d80c5ebcd5d784ed4bf4654860c81924d18b469bb60926d547b1b4bb50d842a1686cdc1c0ac858545ea7001305fee9c4da4a3bf147e30acb804ae0927c02a3abb9d4f8de221b42829deada0417e3e05aed98d7103f10a8b166191f6b44deb5f0e38c3da044f452779d6156f4d9506f6f1b3060eda7409b51920462791a69cf098eba5250295eedc78b34bb93ef8f3a348aeac180983e417a8d45144bb9384d014b078586b65680f1d375581f6ba0229ef701505801e7a26674988731d1b1ee59733c151ffa3fc89cd35c12305941b9f48da13e5492c78b8807610e204ff80807b4336dccd13e7ab9438930f87efeebad62c1c9e176b45b6d5517e88a05ad72bfeea426207c994cd8438796a719e9a9eb84f690cf3d9e033d4d693979d280523539a8206c58c630e9dfb7f688b9e4c1a66f4426904b35aa8a0b6ce1edf9b8f6ca7253fa38acc62c71ca989d5912384117e426a9afd8997956e3b040f4b1348c0e3d2a0d2e2e1b480b86901f2ad475a49de7ec1f53e443218d77cac2569f1a4afffcad1fa95448cfbd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
