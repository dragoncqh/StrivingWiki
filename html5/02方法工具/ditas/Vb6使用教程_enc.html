<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4876a565660cde74180ace1eb8ac446017e6ec4f26a9f2cb94a651907ee6d40378face662e163444b366b7d8191773bc69ce65307ea42a02f4a47908ec462d8916dc42c94f7b8c809681f216ad5e4ba89282f1105f3f89f7183e507b13a613cd1e4218abe0fd6f3f5899fdf6b619082142333677cde838c9e6180967066ec26e3200464a80ef60b96c0098e61e945bc89875de7b6220f61904a4e5670db051ca0ec0808aebc7f42b6328b303c77e6286f3c8ba7026b3e7b852d8612b31065cb52a8f1e635070cc585f1ea3063f097f1917944a408f158ad9729ff5651e91063943050507028ddfdaf7fe71fb839cfd483ebf95de5dee34a02f8cbc6d248720a3552bf93851593db483d33d23720acae9c889feca644df48a59b5e39c8283dd70d0248aae2d9e25a8abd0212dca5d0161205b42425fa58086abf08eaf3beb08bc5abecc9755135ec02457864c0792f9086a28ebddf19337418e2484f3378c734a38cca33cd17e1a3500ef89f5aceed8a65d746362ce842e3b9bc691b7a12d1e6a2be35682bd5fad6e11ae3388a8bfaefa0b8e014a4a2ff648c878db7cecbfd11973621885c99b7d7789b116cb726de948bab6dcebb74fb565fd06c9b9796f4859cc0624b73d32bee58f4597680882fcb7d6582073fd9d0f398cbee51fd854657e464daec2ceb73fa147c9fc8f93454f88c2036dc0b0531e8ff8edfa91f1dd11f205e1ff6bd6630650e0503c61d4e4fe036256aec8ebd64a6c05ce5b2ef1caaa655a37c3c8f971a67e0a7499630eb0d6538598decc9d0ada901df1e0d3a9eaa47411ec11bc345616c725feeb408e14870fc124431eb1609d42f1dee5cba61db6991659b81b5b104763e4e686d210fd9634ef7c999f57e36849cd98a364987c51134ca99098d97e7f229f5a5ff1bf9462394e7680b9dd66ed26df39b0aa31eb972dc13a15b0b2bef399fd69a14be5d9bdeb40aad855b18e9cd89ec583a828ce42a75e583a02625a804e90c38ff3c7c80ee6f0ca931921ad68b2019e3c696c5745bcee8ac08500121a80c06a0e5868c1d27c79b4e31cbe34f7e4c67715926cb6349da4a59f46582f00e194fa04c7b105af4ef410204cecb1b87c605f7bf1f5a196f3488b2a9438ed0b1c1afb14b64104666a4caf51de8df547413414d790a5c86c0f8b10bfd1589521d298a1e30b12e57e324c05d7be6446095f03bb3e1eb4868b6e5234f54b88166ff41a598923ee99a954f3f1f3829690abe5d84b1a39cf3a03173612637343f2db594625eca9200c43e8a48a922a62ddb32aaed932cccce76e3a3a503170fa35cc7f03ea28cd89400028e9f3e15ca287ba4b4efbe08788a217ab1aacfa09cd75248a827e65200d35974293597ccecf15b07a0603d1af223a816dff59883a08535fc8b19098e1d380453e1b66a6e7259007b65197581540dd73bf97aafc86d7806a4b6cb3f985d15b23b6ea91412c4f452f1dad925fb00b579cbab286716357e7e07674e6bd096df96d66d4472e871e44a484bf8ce2793d723f417d82817db518f56c20d83d5ec001e1739d54a40bc58b40089c9138cc4627f43b01805643895b696389db1c4ec6a127d4a05005d27db8baac3df29592fc8a40127c2d487f278fb5b3be427894566b5d43cd2927a902df26d25f49c0972623c02b26d52785598f3e0ca462c6fc9397e67bf1f578d667a207a9586b470b3a768545540977c1076d7cbc0155d42822cffefd3b20b4bc3bb8f56421e70111797403027cc84cdbf1e9a9ef4bcc76f35153d105133c8151a0da7a849f00e15516955358a1408784cd00efd3cb1c7986d3bdd84437edda3b21a26332ab6825c248105cc47edd24863104b4050f3a7d071fead6dbdfb23efbf950c6289896cf24c6e06ecb21443c4c43a3ba77edd9518de1a794c760800bb07e51c1b9adde7fd5d0e283db0153842b452d0f04c848d6637ab7e7cca4e95c0badf8e12eb185794dceace17d334c63806fbb15d02dd6098d3671b24c5217abc98e431cbf45d3360c379ea1d3d32c46c3c76a5084b33916b810a1bf76bcec19a2fd69f8f5408834ca1b46f236c14a715c74a1fa6979001612eded19766dd8b2b0c867b3bdc28ff7b76c69146210e862b39e48fbd664ffc6f8acf150560c50c0d1acbe01083fd1654c43bdb70ebe0b2dabff3703e8453902cc17c3f2946853ad4fb86090e75c95c50c2b53f917f57210c162f59a494ef6b550314003ed92ba766bfa473cb6a1f86343062b56cd040e509c58c116464fb45a1f094163c8a34cdd67adc93ec459162c8d9e0fbad165fad13f23b084b5af55626dc44e4cd3bfaa0997dcccd5231fa10e3bb7b437bf42da5ba05841d7e23197dde9d2fe4afe64f49d8db72acdec5f0f285d5824b46707d0c4d4d8247946822e1bf8b033da86a6b3874fb24398af3cc3ac5daf362847e880df892962ad5603ee88b9823b26a10727dc70fbfb3c58d00a91d9d01eb9e8d592e4dc4f98a962ccc3a05d7c856bea9e7d1305990650055989e766bda85170454f75d3a400eaba8714d5389ec7b14c2c59ed8884f6c79a6b8abd4d4fdd835b547dea92aeed5460c19acaa7156c8b0023ca6388082f1331bc3b30e6cb33d489821c72557b1553247084317b5a0de1391b3ac639c65c41d7aa0939578645cb756c0d7e69d3e061e8152d2b5b59855ecea4422a2de2cc4616d2ca3fc69aaac80f561a238a92634a44a9396a2b674f0c8eadeaa2dcbe60476feebfd0ee68ab23987a1ea5b8e28d6f24d1e4f6f0e585dfc62a61a84f5e48cde056cf75af8a46033ff1615f51db48c73e617d46bd0dd7e2dd3c258c7f7ac5b31ea2851b65bd7777a1a504220e19c79ad159129259bc3fe3948f278cf89f9b44acd19f63fe83ccc2d71ba1c912f4566fa2a97d8ef4b4e61bc4eb0f813b6d380889d87ec9676d9ef58665b64c0434fd3b77afb86d0c04d0342bc2f92c22889547623f4bf397728ec2d2646a22ccd0026e6f2332828509581e0e21c413ee6e32e58e1f5b1eeadce20090197e24843e5da7300d23a978f68c54311a368150d1605077999f5306defc8d61ebcd91df2282bf2b42bc4f70ffb756c5547bc9003955c3507c2f212de820c145665534c44fd6ddef16634d74fc2d3bfd22e01f5b5a2f8e8fbb879dac853a28783588c42d44124223422abea02517eed986e0a64c01d8ff2e3041628a3c0109f9fa034c6c0ba9d319b6ebce2635e3fb5095d6357f9d978c09bd047add9bd8c206a58d3514cde6dfbca4b8512e92ed70ea54efd5fbc213f42b1bcb2b564b7867534966636766dd2ae639927ffe2c1d8ec10af76d736f7319081146cb576995d980e3047fe7977d51f9f7b81bea47604aabca15e5b4fb24ddd9b773a2c1eb661e2e21d96709b84bbb8c8cd8ad4f1d59e4b206e4ea7bb9952ed603e703338df6b3a024a1f90f7b4ace6df2da69f7da9148d41a8267cfe2d85ed3eb9898dae4cde9c135b2c610d9b69c1d73e022eb9c6488622b55b056ff9a138232bc3a7c23b45bf2a8963693c8c9815edb918dc0adc59a2ffff4437b6380c994ec5e044151fe4966f3ff8e9d35dcd9e74171db3319f3773512869b40df1c9c152669858e5d93be50df046191fc959d143d8291189785c79868362460b39f6c52d27ff0ac645977ff2df90638749d1d7fd58973d44ecb498fa7d6f5857e51d997d3f5b3b7aec97660965fe0eb87e4adeb1a4bf86c5cdffea243417057279a69f5d8073f10c08bd468d8c9f3653f4b208a5fb12e677f254520b351a661baeed0cc84d7a7e72ac942a7650c3ed1cd0a094280a7880621e6fb16979003947e4be61b78126d098e35266eaa6509476c09b08880252bbe4c4aecb1c06935fa93851906a4c62cab34ed7698d8923460cdd9e296e86f2a0c27b496cf8d605004e2b50e19a9834f612b924d07737cfc3498e3a6be02a5deb8420f5f27dbee5559370ff34321cb60610e310a5d83e371165dddc821b9b2abaabc78cbdc8ae738f161a96b4d5776959327dc52d04617cce64c3b602bd960a92bd93556e89a79f4c6d796b094dcf573f07328b973ea465a65e1bdb2e0d73add66c5d13df94f616038d5c7670c93f6c966c3bb9d401b3681ffdd5f52b6c5ea98621a57041a28dc3ad11969b67eca84e6a15f017cf8d07670ce538e7c023786c6d2036748de5c7c8ca4a52c310e6fdb6f78be6643bf9b90b0a897c4ddb4e4b20c1eda76ccd7eadf752015e00fda35d74c98f7583c93986f7e9bc26f428f150829782b964b4603c694b6cd04265dd77311486e84886b68d6932a070b349cde60555a1e59c7f9b401468edb831d2e61d81cc2a767c34aa7474cb96db360a744498902ace8af5ed6bc7ee82038305fc8206206c4ebe78f2c214039e67152dcde9749777eb282cdf3dc2561ee9deef488aba42d2b4f662c796368c92ad80a7fc0c572f6e791d88b8c4a31b9d1b750f176a0461a32e326e14913002fda064823f5293382984538925891cb8e3b47de663cb03dd48191261b484f9bbbbcfdf5631a9df3c03bd7cd300559c1bacb3877a71a9cf89ccd68615eace8de1ce898f03414001f303996569f781f293661bdab278bfb591d14b90a7d10659f2e2d5b59c8f9bb67115385b9ee2fa0d168a37fef66d2e3941b97b3e1771176806967e587e2cfd2c5f36f1f70fcbe174b0388b5f049a9eab1de4e05ccd0901ea16f0adf8cbc36d4bd30182c9759f7e9f37d50d864052f0d014ccf53ab6fd07be060a74f85c62ecf4648730fb47566dbbf46581c18a494f238802fbb7ec729c0a3945266b81ffee78eaf015348f54578fb3534a65bfb92303e63ffb0f87e427ba8e6afb465aa6a07cc115a29f22a4d2ec0ae9731677cbb4691b09b5f8782788debc2ed1ae6268aad3efa69d479f02dd1ef80593ccb59df75202a1870ecbd53ae6dcc7a35e2c4843ca75c89eac04a2788f15c3a5399eeed00925498c3c7d923be86cdbeea1cf5309cf59c868b9fcb94ff24a62aef741cdbe331edc60ce95f6c8268a26356b6f0d5d814c421540b0052d036dc3c2114938fefbf2b28efde781e2821b31bbcfd30b7befa6ea73c06de865ddeb7276205f35134a91f495539e18b2ed2c51ca81117da310d5994aecc1f66a128212e100696142bd56d37ff014cf265a3e505c851955dba2d41285c9cd77f1967b61e69da8f7c6f53d1e357bcd9427e990901da63964343bf3be1d6be7d1ef3bde7425ebfbbc5dc0c8f25b0718bb106d4db7e9eedaa47d9c147cacce495b88d3b1b2183372ad8c4e5b84d2273a51879a91356e3400a496b6783538579576ebf274e1e386dcb1bf2aeaf4938bff026e450455b1d5ff6a909d1ff66ff3f0b2f9557ea5e591926ed176cdbc97d80b27adac1d639d6fc95a2de12bf54841d16871c0052f6f23be9d93c6b5e5d9ee78e815be96c5dcbed44c5abe37a7902dde2d0dad57c930f5fc5a03b4c60e1ba1c0945ea37a1c1165e828e249beff9c829571fbf325183cdbdcb26a6c4347c743f5a39a11e305747f18e31e83b67b3ac04516de5e0b88a0992e3b49e38f0f4e3007338b2be384c4a010280b789b6c0d2ed2c1c6ee539a5cbe6e641ede359c061e57d65aba6b0c35069328f271e7717c8b760076ccf32de6d068b17a4712f7ca8dd3a2452bf23fe5fcad1dbb8e6ba74afec65050380f0f504ac47850880bcb2ad93c3fcf6f1a63d9807bc2540e8b6b923909407e43fd30ebeb26d2c583b55bd53cf19e287901044d74b9562dbaa5af404625de0a8b649d1e80b5b1e672ffc9674f7508bb4d2ea297c7e88548445d8f856ff7a2dbfc8531f7fa6f2bec302c52465f36d7057c01cda21587e3a352cb925af8a3d0c2aaba13d74f3c29129e110cfae3bb32ae1b0bb0da4acbe82638d08a927d347a26a1773beef88c32b6af52441e741872e87b120dd7ecb6cc76516083fd445da27c4f2c56ea98b056c65ebce986397631f63b9fcf1898311fc92718575010e908a4d6778ed3f4b568c6294be4e183547146a18b9609e39de2a69487f048dd9e8874cf009c3d1baee23e34ce0a95c6dc377a2731c0ab18aacd00bc49ee2aa2d5aada8892e96efd91a8dd98561407898ebdf84e3d279dec3fb8ff7fd46accaf4cd9bb1b437b4b1ccdc9b26d45a671da529093d2ee23c30830bee083e4c866be15e08238a84cc7f58f5ed842b61ed24636c60d2b0b3313d84849c103ed8da61391956609d8f1a4eeeb84e855147c31591773ad350e7ec3679cda001a588eb1971c1073a523908cb112f9a237317e6e08939657cfb79e8ca4ea717903dcd0788f9644e1c775a6332dbe1c10f4b3813995d52477a364ebfc3cfd64f0208011b45defca8400f8b504bf630c70209fde8b00e9babbd346ee331b6bcfbf93704ef2de77bccbc606aae63a6eb9858c2f5a7cebdea967de72f99bf4808faf41ee686fd75c069d59c85b756ac35152d060cb378ddad9f290584b9cbc444ce55c02788c1c418264b238cf15e63556ac0b1b13ad452b3ee0da81413b719f18f72cff50b284d022bad08206caa6b7212d41b63385a454574a9f2f975dc780592aebdbdad86d16a28508bd146d6cd46ea6236e9280b22b08a93747155c3084f195a66a630e6429ec3cb941cea6cb75c013448192c080a774bdd1cf4233d9409683c6e04e490fb45515b6ad501048703f3cdc9165d0b8302a0cf558b2d3c85dd05db02f32095cc53ca43ed7b18acd3d1b1a03cfebd2007d0b4cb5c3c8597d61b68ae29d02ba87e7b2a5c5732205e9916cbd9f6587d11993107ea8d787d280a2c5e5eac1cf53f489cdb511f9aeb68fd2383ae2c24666d40207a5d1f2847b5f614012c604c712b7959ceb8b7f00939feebf016531209f5caebb399e0d366467932efccfd2571a805630839a1ccf97fbe91ee316c7ef0e39bbf8b00d2deb54c9b84eef95b6192680924cc89d5f43cc50d3b32c699993f95115e81e57007b8b1926b8e4e5d9db6b7f16588d3b100b802c8223a8b4ad6886cb792c214fcb1263e163474408577169a51035617bc54450758091dcb34b5d2d327e34e5b981083c61c08eb4aef54af33f093ced5a11faa89628717f6a3dad020d1b4e9a1a534380090aafafa079f8ec25715e123e6b259c449ea90cc1278d3910534247191f1bb8759324f0cdb6908b7b8f9848d5d231b095762af214172ddadbc8e65002ae0c39977dccdbb52dc8d23647b0bb07bcdadf4ebe453f55f702812d8827025d34a0f1236a57cbbea41a90b97231fd1b3fa4ab7619c9f1df77e892085af09da49ca11402839b76915cd82e07ecb80f37f67dc5abe6260138e77b2020fcdb2d93d1aca07b611c6f0d8be754c0b185b34be82412f2d0e1e49798e005d13fac4b11bfc730812120eb89b8f32914dfd5eb98ce42c9ed83552063e154b7429bd448134610d3c4e438754871449df55845e13bc5f033fddcdc785754f08400244cee67ff29157c8f07448ac5143f54ebcfd2c7c3c65d23c10657826f24db99e3385345279bf89e85e78f18090daeac286519df5ce6e310b6f04cfabfe99cd1997e15c8226f73dcbcbe45c576ce8d70583e75114ef8b54c697cbcc2abb37e595ff98a6f0ede41b85c085a1a1ca59d0402abf85ade182eb04f3a731d5018e562fb7c1af8c6da23554196cdae646b8aba0c92c4692975afcc53a77d4043ac85b49e45f6d45870ff256ce475f74fa83efc9b369e4c21d883216ba6e3d29c1e36c7fee1857c68f268492470ddb1689a5204b234798c9b84e5fec0bc1adc52c9df33e8a3034648a31339d2fa04aac16ddf39dc05dead1780557e7bf228991c9b1a7478e4eb6cb69eba11cf71a119bcdf1010c981a32d540c70cc2795e5c2331660e04e6e779fadf3ed66d8f6d110a4cec9ccc21","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
