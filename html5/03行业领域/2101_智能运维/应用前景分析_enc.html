<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d7fbf4e7ac71972bd988fc59c3f405a4b0c39c928b8cd8dd83df021ae0db94627e3999a868f9bb2c9c28165db46618e3f9f80e279df04118f2b135929d9525b63120a84201c25d8c3b4f445f7fb073955827ed915025d97732772cd774790af30ce7049294cdb75f45770bee0fde022cf2929439dde6b278759d0bbb1e84dee54e9eb2c264dc637cdc5af0714b5ce9073d261b374dfc1207cd079a02e8b7a95d89b59215af56159fc7ad5436796d266e77d5d02dbc8422b238a70e42ee4f70435559612545c1f1b2dd32dda723a2b5f36d57fad5ac721fe1041951e9f41afdd7e187d5189cf4a8ab1adbb5ea5b617099d5eef5165a69280ff700548484f2f77b9adc76d0753de40efc9e86551b9ad5ac3b9f24c0bed20b786ef15da86c1e1d28b9cd749c7ac3fe1372307ca28d2ee87f00e9fcbe69a409dc4457848ded11773f72b447b20cf6436342e9244ed0ce8556ce4ea4685a03a1ddf843c5095cd12b4e97b3ea9116f1d942277c9e3032bfcac2b33265acfa911309b5e70f534ea751e03c2c47f81abeca91aed5cabe1f60d457fd5224e0e6b9c998758fbe0bc99c1f81dbabd6de7f6556a9a94a5ae0bdb8f8d480249fa8d656205b1f820e2980ca4086b282b4ed888588f860aa7dc55bb5e5d723b94e2027ac8a8256be155b709730331ef9f01669ff7728464a2272a824443d352cef37add12d40943deed7ee47c34b95a339c0d944a2652e92bf122e57e1549f172713532e8e3b02c7d4d289fe97ee04d7486cd1342e426f8c8cd3638d568efd69c977df8ad8b4ededcada186f44cf66f0bf8fc9169e8e8c2c647ec834beb1cfcbbb1fc8f2ee2d737cf7bca7b39e7c0dcfa4d625235e89442c493fdb90c5740dc2cdaceac9ae54a8e34b830d00f8f69e594d99824f682ee7e7bf4823e6ff36df35ef5dcbbda2fc16bce04f9e92908ed5284b684bace4abe182fd59dce739feb381b302247a1dac11a7e99c18fc225bda34560ec15f6e9a885863788daa1aa7f86c59653f6f0e2089206873164b2ad4e90b1314d392a05ad54f92e28976ee6f96356ba83bdcb63683c028e325aa85eca14871417bba73fc85351d3229792c2933a2892dea7a786ad7c7cbd1d0b563f65f1c78d2d1713abbdb2128e01fc806b101b0e839f65080c282346e595a1c3c892902d197dce647ff955570b67e23977860f9d11428a5f0fda748ae99b6743a4eaba84b57a892ee3db3bff40a1abad9e7081c1e623b4edd3061a1118d79b6130e0d56187dec2611f129adf500f3ddfd51ab49cd71194bbef0ec0276ee7205800c780d8b309622acf9b12357f27ae112cab01136d21ad1cb34a6cec9051e2e31263edbaec84adffe6aa3fdc9bd3e3f048e6824d9bab6f7a2982c45045fc7c60eb0f5a218608b8fd73ab203a8e50dd43adfc818f8146366d3b8b2945b9ef97f59b1e4abd27d41ff3512d0caa979ffd900b1ab42e6b048a49b767b562ad0bb9d3a9e80ecfb09688839aa3388f367ad0e5e702246ca750e8b681a83afc786caf0929a811e5718be0a2ce3a4ecc35b493dbb9e707e1233fa7067a369e0467b05e9d6e92930e85ea73725dc16d44dda15ab17a36257af50ad961f1b48b1d15dd90acbc3cbe9c0cd7d993f1b86b27f849ae1e9180b22fe731d7669964ed2be922dece7bd9d2f59873f3f6f1d7d748d39b3b48eb02d45e1085eff4abcb42c0135300d4321bcacdf18cf483c98011b01ba8c7de86e026f40897a5e28ea5fc5d6fb2a3f0021e8f490ab46480e2b6f52eccfeacf35127c22f78cceb59abef52f890361c37bf1c6cfa36085e8f3893ad2d8304eb3e8af1ac4c9de6ad6545032edc777ee3d866268ee22a0acff85a7d76eaf944b2756086f1b33dc62450826f16f98f8e871a81a24730740130a53c072e625bb90e912adc9f05dc7fe218222b3ee94122c181e7eedcccb2124ed19c7686e25c0ca1f4215de2507f0d587cc544896fc35e0920a490715f045b14120d53a26734fb4bb5fdd56473a962dcd92a9cbc53ba1d3bebd74f75f84759926848f7aa2920412fda24ca4f2fb283722078c59e8deb424a43ddd68375453bddd29cc0a465ebfaecf9adb5f5b309134bdfb296333b7d14b19bca87bfde5444e9472711d9062df8e2f672822695ed1f4305a82920db410aea5a92c02a129d8a64ccac32408c39cd6cbc96b232bb734850dd7acb1decf79dff3ec1dd7545b264d0f81f8765cce3a5acea90dcc24bb0ef3b6071b6750bc54f31797c4528fc56975f0d6ed36a9870c8cc83ae0b2b1103b8a0f34e4c12dc29f0c41be7adb3fb8478513f036a64fda95469da1e92b1327b82208e13f992c0ff6a1c1cca286b6a74ed94147ef62eb283f8bcd3173f1b399af120c366a4ef40a33d612042f1ba30a79d72344c986861639ab3307089ead487042a5348ca076f48aae951862b70c84748bd88b2415de4c60b20f1525c96640df6cfa3d1660566268e09aff36cd4ad2b471ad6c9003d25ccd8494e722896099d08b3709a0c66f62830dea6e056c3cbfc37982d2a87c0af5c198541eb5aafb80e4197d52d5b0586b4417d0baf34d0ae23afc0982f0c612f8e807609e304bc8b0aea28ba6fcb9032b222679f0f32342e7a7fbba18a412b747282d74d6fbcf2cdcfa66e72058f6c66032681a15d12b9075ca0e3728e7785844971df125c335d9f73b861acfcc1e5c1fe7846f3c240a103258a20513ac3f6721c43c800c1c5a4832baa6659c4b754019bdecb2e7f03c875104f5983d9dd30250f6b430142807d3a2963599e8aec20e88f336792516bda5228efe2818ab03e765153e1ad03197b366ec4d168b6dc2311e2c7fa0659faef3c54c163f3b82f32587c0a73cdaf8c5cc0ca47983b094a68b885cce83f43e01a04a78dcedb5c3d68e350419a69e6e01cb793a5488115a488dd00f1606ffc8f92d04adec73acf28cd1da3bf38bea7de658a4abad36136bec094a49c332a9c5d2ef48f7da0d0180ddc9f4f0593192638cab9125ce455af30b061d0db4d17b1b64134d01f7644490db1686d1d3148696dddca7dcbe37c0eecccad41d2a34cc79efc82a1c1643ef7dfb82e94d95d0d0c5ac6b15b7ac1c775d05aeb191e3073cf7d9258156b7c37af6ab7a9fe6c538a9d64d1f8f42592e5d455c12e99c015ce620879a89fa958d1b944455ca485e08598dc80a4c952ecaa6b8dadad032cf2ec45577884b6f4bdd141f0463e2888c8038cef2ccc035161f89897fedaf69f67d3b3cb68b8d3bde66fe1de6678e88da225691696f880874edd2b1470e027fc022dd80a99ee5847da5ddee03e006abf81e4b8248b2e6867d10f2fadf2e73f9c86a01d0cfba83d3c6153c12d97f56e164a515f1b6a020ee1c9eb4edb61d786211eec2a71462ff3fef06ff46238d761b386ac819d3a1c040f0e21944c760103b173e31e89d21d4cb822e692ab85d3cfd8231b21856cd086f72b0aa682209fc19cdb2e502854140dbd923d6dbf0e4060c8449b3e10e7f4cba738169e9d14feb689e7fe91b160b2bbfbbc3178cc38843e958569c2bad9c8926b5d2532c7d34f866ae61fa96da488671727baf96a7b22e4dd2823f93e7f4a3e15426088b780090d7c4b02505865a4adc9132f7a58dc9994b03df555b5418bea1c73c52daadccf912183ada9b6fd4e639db8c3f73adac8c4e45a2ac56e22bb0afe1c670c9e94128ae0ba08621aa252426b10d7463f5b49d70c5ea6d56bcc1d5fc36a755a74b0f064b8bf7db7a5b5e01cf3ea2410bb07475c57eb0a47000c541169cebb5eab337dd37b87128a45a27fec9c7ba77e0d4e70a6d5075d63de028183515d1d2f4058a769e0a3aa8c7c4dd433edc4b6c6db56b4b8cd09958dd7c600c7b5ab6823bba716bc9a7222d3d19c1cab7286b51f642be57afbb5d691885848f927cf16babdd32f2896a98438d78cd00b188e61d31c10ecb2a78fb4145f16698864fe68d52501cf451952321e82e7b2ce8741b938f1d8808aa06328f92f63b102ee5b9675da52d0cdcaf86eea7e3635a439b0c2d08c72e92281c6219a9fae83b5047e04a97430f7cee4d8d0cda1824713fe7eedcf558b6e9ff02f7e7664396f0a7047c9fb6a1fe771852d9b1edc9d4f8ecb2dce9955a00dac3077708eddf39268b082122c4a88e90f417547539c5f602e0ab2f3d0064672672e93d5942134a1eeb6b71c926cc6d6d2c7931d75c4c63ba6b5f5d41986da23a2796ab5fe2a0f4111e95e0a95a71f0b509426dd7b6840458aa701cda9417ca5a35c2c22216c24fe9ae6b651b0f2cf6f17785f16dac3aa72f2fb7e81b21a9e8564fce43dc46d42ee9c321867c81788e7dd16081b3aa633e685ab5c8e264675a49fd2394db887f1364801b9496c749c4b144ce12b723428902c8d3fc510c8a2d50f4fa4c3582e371c5c90ca256c83dc3b4f7546856c2ecdece5aab54ddaed10ca71cacc196421d35ed26d9367f1eb82ccc5f516e442d867b0ace815fc421a157bd5ded323011ddffef5aa31c12822123a4b3ce78c04e110c6efcf75c8a96b7cdd1b6185c9300beab1e5b5a6fb082d610413f389e5dadffffea4fbd7bd8d5ed1407d41a172d9db9553a2eea181518d868d176127260f3ffdc5b6c13edb78bad43f1ae89fcfebc7126b5f909e1a335956c69337bd624ae3b59a899dda0c8e1641bf8500d80b1e81a0bed7f768683208815dc49272d560be9a4c7adec7fe8b1b9d76774df47bd2cfe3878787fffad82b36da91e616ef0c0c9080a84308562d5842f9cb46664bbd35af2bcc3001a78bcc461ebf6b2b0d2366b3d4ea8630ab1129a5a246bbec4fffa61a4ea4762c4893af9e1e4bb7aa2b97de65d3e11c82ddd62ccd23a64411ae8098de4f207eb5576f6c63eddb146af05d044a2aafdde1b730f3db31cdc6b598e11311df662d8b62715ed3c173c5fd0ecc2b8b855341587bb68f71ce4ce5045e3cf9ffa715a0436eb7bdeb3c287048c3852ef1914173785237d71d07eb2dc39eca6d73d44fde39621b175b1a7027c8bb11cbeb4fa1d7a068d43fb3bc75eb95fb1849c1a379bc3a48d034a5ec03ee9c918ea36ac7377fc23ce8d62e8bc8b75bede82a425729112c1c1225d659a954ad061b05c3b386783ab0b5c7e684f5484105a0db593903aa352c3c955b30a054d23cc8c205cdbb1572aebb9635e5fd64583a9f39ff1b38a72913ad523195c89bfff6ad4d03921bd84b8d87bfad10aa8ec7705726d4ca7eab95d578bbbaac7555abee4cc52acb82aaec30f3eb5355796b04805403bcf3ff930a4f468f83009c3ab71017b082b9a92e2d5170abd196d8127035babeb4843de13d8cab5000fa6b942d29d0b14c266e6f4ca12146568f2d53d9ccc2067a775baf56623838d316a266a2faee2816a87f919a863c6238e0a9312a4c98ea0721f0e5a3628379d41e9083b2b97f01b20a423ff27426378557a597b634bfabd5d309710e54f1a7699edd0ac4cb1bf01bd96d93f1c384cc211f0702d00ffc95af5acae71d31ae2cb1ba7e55e4db91f4ceece7bd497398629c5a9843d87562fc673bc588f3b2d6fd9fc7f30bbb1198c1487173e32384e5c8b1beb2b4eb91163621a8c113ecd75797ebae2ec86ed74190375db151fce3643d0f2127030a25ba1ae1f509611a6b75241fb8dbbe438117cc5e5fc1056f54cd3f72a54f435db395a92327c2a554c3cdf552cffa26ae9e2c37d24a9454d3a8131b00be763c1ef6919b698129d04387298d18f738dcdfb37de0e46d48e060cc781395670fec0976148837fd5e08d3fdd9d31c8c9d3ddfaa97b49b59366078cef543b147061710024162815384014830118cd453d0f73cb43965b45b352d2cb6d7734d780a2356925a5790f01a0e85632f2b2e84029b1944ac1dd7896b0a0d47ddc47094615274eeafb7f60b76bfd0569f34e3289127a04d0a6b7a4a533b6563172bd6d38a9044298813997441628052598cdf5023e5f0f985bc63503395ae0194e7f28bb497a96e9eba803f4e25db63654819a79a2ab6d7a6bd7a8a7a6c78662024f28878b8b7f841688120080d86c458ea120ba2c24a41a5d87445d2f4cb698662dc46f7318db784f29f3fcd3dabcdb2d8b1f6b2260560937942f9d0cc30b71ce8bf574c8c83797c478cb6d5ff5c007096017dab5196c52306b0c0c020aa58a09a0a540b2c8a1b9133ec458189abddc482f251d78094376c3aa9b4627a1ccc4cd9cccc02f8ee35b32f17647081d943f4bf4d880caefe164e7baf823b0e1cbc4b18cf71572d2c4a692ed8ba4747e2e87cd77fafe836f298071385ffd78514910784c3403cd9f76fc7a8a67722803cf2221b14f740c3d1fe8d6118a78f703fd84abd0b716222b62bdbc3a7b50455c52a98ce3e7cd2122e9f62cb86725d6505e71b6590cbccd89e6d1dcd44eba7d3bbb3b5488939d52fe44b95ba15b497f87fad8be7dbf065dc3d3a9e34c8bae9bbb2bca361ffc16b4062eae7f68c577f9f8d38eb6f2f3a972cf8815aca501f00ea034e3361623cfb2ec3c6ba7473430304c8781a6e47b2c7623f5c5c946fce6b1f934ae1441f5fe699b3dba14a806b87e671cf5cb83103c59c57466eaaa708a95dd10c45e2e668569dbe3e16d71df350a568fbd5e5097a389cac9bc05db85958741a3f9d82dcc3ff85b7c61624a416f976a3b1e76885db48bc9a5027deda2aec3f1c6538521a14bc3c15ec25120b2226c1648e6b8caed7c81b5bce1c7e514a9323e926aba7f977b9c2b9ca8d96eb1a1f7e42d7b4eb4752be7afa60643773d4f49f6adde99cafd745492aa453f7de369657196403b5b2676672fec409629093848555e906c3b85e67f9074ea2a6dd366eded5e2e72a7974277c82f5442610d40ef3fc0d7878d836b0519ee645b0124f9d60ae14c4c82e89a403652aea02d9215de17c406c8935388c493a2a475026ae07bae008d6b6f0ef5e628d1d9a5c6dc86c593a744c493bc906cc36873ef6f44d1acac06871e32725042f06877f3604bdf6b6fbbf38e72b146d73a5f0619f71ff1f4500750927860229858909e70a1d3d1bec97867fd28a3fc6852f4f219f9a844c5182238c65a41442f7135104eae637bcb3fc02f09635c02131fa2373bfe42e044c790dae3c5cc5ff6cb6824181e87fd1bf0bd135982515f78508fa90a6f9705ab8dbcd7524d506e1925f1bca56242dbd8399d7ce953fc123785ab8f6eb5e676c95cccd5996f20fd2a7e061d601f01a48ef895ff9dca9150b297a11240418b8950af617d7bc47fe0657bd616bba5027d1153ebe5e3777fb81a5a0d476f207a50ee685dcfe089f31e2b9245bf8ce6802d9b56ad48c6a1c4b93b5bd414f69ba4ec65ecec61fc73920ac8ce6922ebfb3d36e3ab7c41452a08fb50c323e5468570238b1487ec573ab4e3cad1352fa2b9f88ce0e3426a6b1a858da80215d0cb44526657b5ff9af634018b54c2af21b8276565ad8d15ae946588f65972552fa6057fa194203f744076be2765795bce5ac620175bd4607810276eb12c29cac156e83a001c5db005cedfd47ab725f342ec5d9565ba7789cc8c7eaaf53cb9a71812f6e24029c71ee935d568d58102c5a88681734d32388c6f0b7d7b3cce5d4747e2857b170530f0f7ecc8cd4acfb6002855b25714578f8b4a9011daf6a93f835c138ea77702d1d2b955b1c21eb73fc8ce8e696023fa4ad25fa18b32ecf59fe2664ad3f95ee2fe8235132e5204509c384e16d92ed85838dc63fcd40364eb66b3728b7b566fd2571116a4e4aafd5980cd177661eaf3007f5f18e1a60a9b0115e2d8ade44d53e76348cd512fe94a617fb0b28d156eb1fd801431313ee6838a2185ebfe77164aa6d7466c5793371bf8952a78344a2cda159080228ee1ed526ca24dc4a4dece1deb09e06f1d48e35f52aeed4ebc43847f20cb7d0a53bc70350c2ba206d0339ba0737f9257b74524daaa1a5ab6d0767743b81ea339afaae50155949bc0145e031c10a057d9d1403a41d6fe9217c15e3355294aeb7e32f430b2203e4a22a3f91c9102e486d266ff1fff86ef60019ace2ab0b0dd9af938c90cbf3c7a2b331876da422167bbd1b8e847eb614340f3dc26f98b097bb1e50b16d475c6a04999c1c80393bf3f0e72d541bcf7a36b17a1d892a0f0c2558b01a39179cc90c62f44c12f7a9acfe9854d8deb61699ac714fa5c718e3a566d7573f1a89fcab5dbfbb56c8033add81f184685b902faea8a63266cc3563ec4b16439eddfc3caf2b84ef84c86c7de2317bd10d7130d2f0f44e8d8f0313ae7c8ad302a7d58693eba8102ce3e232e7e8f5116cf601d46ecc99010e7f66e6406ca8329b0438e25614293483e2111f502e9feb137ba7b0e1d5ab5cd4545b7695456c21fe808daadaabe907241bdf9ce8985618560a83af166f455a0ed7abb0eb0a84ea2ab2d838b56edd70e91cf0ff746f82a94348f13b27be732101bcf8561dd169dab380a1afebf03e0afb06c375c3b9fc32cac1066fc98bc5a96ee0a03d2bae183d7183eff5f83e69fc5194cb8f06c4defec5b7e282a13e05af1be16c77e81646f3f7d0773b109e9e08ace86ab13fbac9eb0fcae3ebda606b66e1556193de13a314fd151c996ec2d3b2824f5a3444920640860411c853c45a32ac2b3096530a9b87eaf94443d40b3d6a7c4db15c96a04c229f4402da68d30fb2cbd371303e600517fad4f4525def596ebaeb0365e4ffebd349c915611df420d8b7233ffe7a8709ad77e8e7e8d09420b87f9cbc559065dcab61270ceeefc3e01faffb0bc0a3a9e77adf4523beb795a610f356724f1557ff0406d9fd64d11235cb3d89d9bc2bd82d7bfa7356424e9aca4ced7a7172fd3a362aed08f1378398f0f37be20e49b1056e07364a6bcb6462749d09e93261bbc05da657491d024b4000f8894539120fa96e4d0c628965ef22bd34d369fb1439be65958cdaa550d3518158ecde97fe154e4220a9aab0c1bbdf12ef53d3307c423508af9ade0f146760aa5ce730c9917e1be16129574ad8ec5eafb1722e92285427a5f5cc5aceb55910c67589a5e54cd88c6e88378c40a373b4210402895ee93514645d8c75147b91052a82556b893520f03f1f6c232bb425a45d42e3cc592d06b9a21e18a1a7fb78a3199d4bb15934c57ca0eda97f1cad901fc306cb3762a619601f1148252b65fc2b32ef50feb4d394e23de3d20cce21fc642a4d05b0ce41b6fa393a6b941929b830a5e94baf71e25286ddeadcbfcdf9d71f41945ae3580064e8667fa83453fefb51f1a954e7e5e61c25a65a46a7a63011f02c2095e79480d4f2fcb901cf291b925ba115476d8b0b6c88d9c628d0fe2680462688d2e1ab132aefd09d8fa9667b1584f21b6c7af6434ad5501a86c7410f933a5eb1b128b27d9fbccd5de51813d9fc77f0aebf8eaaddf5ea2026bb47036f1582325daff6c5fec810a51bdf078208bbc54658b3699ee2a6dc494fd455bc15d0a5ccc78dc979a9450d4ea138c06417f5d556d46d079ec70fe17a15362e49d281d9dfcf69bc513d3e1fa35ec8db251c6573369bf8cba6d22a58735efec850b330487005b2a678bdc768b5b5441e2b0adc8d1dcdd845f706dbdc880d5c0e3a613639b6c7aa7b544efc780c06a31285486307e717b66dcdb8f74593e2e741f750c06604af663cac2bcc7a0b20e29f437bd920ae86f711d4401b2bc608d778235727285de32e696662a8fb224ab8335392de7dcfe679fd70e20ce6f7776b62f8582018743589f17e3da5cc4ac569456e240ee423132ed23d3418459dc04088a1014023cf745e4eb151e2266ca3e898a3ec643b7cfac450d98312e5faf6083cf2dcd6bfb089e18f93b07d33ed98689a286460575e800f716f0b691f8cd6b94d2d0e56e16003935a6be82421018483187683254899cb813719bbaa273a20d08c9bde942cb958999a901862109caa29a7975b1038aecbf5ae6c7f0ce37cc2608604a391d5df4ee0c7ef465148e870dcfde43a500617d3d1f1d3d32d91287c8ef7f1c8a17e4f1cda4c63bcd8e2956319640c984f08b7b51e7ceb76fb19cf7d0ef533d8c40ae32c47f880c24ca12e4ed3ff17e2fe9238868500e1d7b0c57bdd512ed342b19b0a0ee09ed44c9d9b2a561e7d9298a1fcb5411d22cbf46d0f71be61d1b90970d654de27bfe03ff8f40dc5aecf853ae851c020616761d662c06cf8088ad8a2e8c817d376ffd92bfb27869bf58140d86781b4e0be58c6a7712d7c9870e160b931260d877861bf3cf1650bc3e3f80e194f7c09dc83558f4491ee3af3abf1ab45f585881d05616703b5b3f97b731e569f28f2cfbf059cbc8e05e31889537c6d81ca50a56260d105ddf4fe043daf41e58c7b024f67bc66df1df4b0f6d6acb69f9158b66e5674f79df8ccc83439f1c26b759af75ef4a29fafa1edca5ea7beb00b48f91d07163ee097e2a5cd4471549fec312f757bf8d103fa3fab37ed759d5fe7a8bc3db7248cf3e655b41ff490e3969c222ded14b741dfa0ce0a1a75aabe90242b73dcda62f4bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
