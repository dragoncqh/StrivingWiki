<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b50bb489240fb42f4cd5a53ebb6485a5a5d58f8903ca51b7005cb2e075f53728e992c8d4624eae23c438339dc6026f144f11cb82a3d6d0715f03c73371fac7764515a7b0bd13aa1eac34df4442ea99ae850087c5bdeef8801c78691d5605d6bd38a24d1370e8a65f437f5ba28bada9fb82f071907dad7b3fcd5943f404145f9d926c9a6df10ad234db48395720484c6c162479ba13622c67f13a24579c47f0c839796b0a2d60af7ea7104a12d9061982ef15a5a5f0c1b8ce493c4266f8119ec485f0c1fc319b00d5be9213c559ddcf778efbe9ec318836bbc1030212ea9700781274e5b6b509edfa11db95227ab6f2050fc7cea329cb37adcf199873eb613913d5256914e797be26c97ff61e8a4a69791b7f310ae0cccc591e3f88a45184a1d2726ac0358979575cea571bf0798900217796a696c329366a13b80016fd37c08c39510be6722822bb61e92b6f86fa83e5a122682ea5c51bb8e5498ebab2ad7f8b3c55e63de2378db0608853add18afb79d79f3cf231cb6e2803e0db686247a33f0a2e22432807c6334422352b205d65a64b68edfb7534b02fbf25d2f6116dad04e01a5a51f8638ad3e84863596eeaea47cad6cf8919be37540a308f369fe14a660b1e407b32409219044795e1b836d89d51c221b8f04604b1f713d39af8fcad1d5082a13d421d730d4c0903143e2658a0c87d0172baff001566585cd2579ad5cfa0b6c170806ccefada14ca2edef889f8a5225d3d92cab9cc8753d55cf0afa82567d0974b557d34dbc29aa91df587470d0acd58f346469ce7022bb1c0fef39c127e8f11ba8e045c4516824ea7c4cb17075488bd15b0c980f0e51bb7ca76ac9712c9cd8e9d02adb775c8f8b1c5592ff601a6835c2f8a8be7f8e87da28891c6b6f83c1f3cf11bccf622fc191cab4942d7e3592b90a6e229ada919c5e64fe6371245a8484f53b159904261f5a822061c314aec55db57aa000c4f196573d69ee9d5e5b554a7500e18e72b12ab22c1327c42ec921d73405646afc4cc75270187bf24a51430a8a2a85c7c556d4b73d69f69eaed47da091b202cde8f6eb15052ab553fa42b4358ed4abb5b83b147b6ea8cf7d42bab0cd9c49ae017a08adfde757e5dc6a7c8b544465d265aed6a592a0f8a5c7ae3454364617003e243fa48bc7ec3b61763483e00d94a368c938beb948bfbb72163430b2b79a68a3f7f23c1e2380d8875d8af7f186c6344dad0460bac5bc7098dc8995e5b3bcccc7c9dcace3f88e9be579b81766c8768fe5b0108187884585d063b02d1ad3308471783ae8bd0a97f37e66b7c6521c78c901818d2030d6682b24dbb12957b39ce6bf733f8f7ef30feade3bf7664f383b2c8f2a1c391335966e53f606d762d3b3561805578f9447f771c039b7db56709c744ab380cabbbc2a824a51ea3ff536319468219a9ceab2826b515fd78077fb0aa0dd6ce1bd6f094c1598bd18e133b486110ba83422b4edae508f62ffba574bcf2ec64d2bc58b1d8ced18929a145ba5a6a47e17788cb3e3a6288d4866a3d092b8ede694ebf6c432efad5608bbd5f92bbb05def3230d8b3547872fe32b9b89d54e57953a8c4fe712473ba484584e453600b423baf3860c6121ccd50a00607e5305f4f87d120400534539a305fa2ec6a113f8a587232b7bfd7d6b932841505cce9fb9f9574fc6afd76d666380e1a4e670a0a9956dfe5f3882a91260bb58f5aa06a046eb519a8beaa006599dd3c0e4cfbc2e165b73d95b24be630a342b81eebb83d5ea12f8a6ae20ae1daec6b77e1a4b9699d96464e413ce3377e718506e5fda71c9267d38760f26784bdb3a65ab651d1dccbff4cb56b72b97f15a114b0c4ab432b317c6696e4ea8f34dd18ca5de83da4190e5f8a495e637b1b2c7b4c200edc0cf9eb67dbb0a7f311f66cd72b85dfd27009aa71634641323bde3e1c62ab2912ab933a16070fe3d597029d601389d8f302044e636125e196adb217267242bcf357b887e4b8bca2d3bacfe4639c6eb24b9145ddd8049170b30d536f1dd39b881198c977cb609e1f62c3bf1d04f03bdd724f76dfe9e24721d63fb47942fc3ade564fe44cf2c1679acd262ec3bed27c25b60eb07b05e2fe6d68054d9c022508e36576966bf50b06394d28ff61fcabdb9cb2c2a0e557945b7fb86efe455bfcd342be9e7e1b6579f9ec6524b0051e6890a9d95d7c229de711588687a4c3a9a0e81641b876879c1aa0f12b0209170d194057424e95ebf0894f879f479370352bcc86eedfbdbea1449fdd5e306e1bd79d44747966eb190c186fcbf987f3945b6bd1551aa256513e3c6e8200876316e6ea5aff18ef2556d3f053266d09c6b7348eef7f369d7e3f6c5b63e9998062ecb7159953da3a5a305bcd01b36a5817fca41399e50a8fc1f604d91ae5485dca229f3fbd5d625d63f77e4a005c325933ef58280b72a0eab663f496f6b1389acf37ea4146a1b6c3c20de543ef3d721f3f0fbbb6e4e3e198016ca9659fa8916b60b713ef80dce96f16b124fe8beb9d4cb98605a2cb3d34ef8ae779616871f31f92e51d079411c312c33547467580f5f4a0d4ca3fa942cf38b64d0dad2159e3afd45c4ea07f9186bc27e9f341da9e1bafc2ee0cd07fc1e3b9969323ff0f26592c68a2194708789b073208f97bac53b94f117cebc9b14e6aefa969977f2c1b9b190ea12eda8a5543227f6f76eeb6c1447f53b290f0db8254fab376e261062ea74102fb2abccddcf2620b9c6f9a18bc761b401c9a62cdc29b73cc193f968425dea50b81edf2a9b11aaf70903354673f19d6d42a933f1c42e1297b3b522a5ea03f2de6affdc1b7a8d0639ceac0fc093925690b03ef212e017bfd209c3518c2aefb5c31942da29c9a632fa37aab92dd075c1507130667b3580c1e5b5f6cd5ae45a8565ace031b75ec382713a4960189e8006a2e7a8a0380af5b736ff69e1681e1f050a0156cb5157e8b1a1210108cf8f9a592af2062fa3eb1d9d18cc6efba8044a309c5f2682a333fb279834efe9d55c37eff12216bdb94e8b4becdce1e5c2e833dd9a074b28313b925fb7cf4ff3d734f4c430726b5e7c6d137dba3e1e7f0afe9b724453a61c093942c9629a0cfe388c639e5d673a109d6a8b4b283527df26cfb518b4ecae86e793d4ee6701cdce93d76196d4dceeadbe3704850e92065d4031cc48de82cddba2e1d0ab350a3275714d883dd43e2a14f86cf57944988495d298c89283d2a8abd094b2465d8046c9934735d151f0b1eb38202ad1adb9f103926544bdd12217e8ee7265b6d192852b139eaa64c23a3ff05bde688237f8fb49ea2b100b8f32fa3c58cfd165824c7fef6724ee95dba7f8870897188def2fe33eb5a1e6782efcfa57707eac056ea51a60bc906aa1b1cd06b75522f826b3cde778930aa0263ce8e3bd7784604a818a572b07fe9ac6df6bd35f2e210d42ead1e46f836a534251d218bbfc3eb20cfa03d4fcb9484ded6b0511bb3b091e01504ebdb29a4932fa5cc2ee664903696ec18bd77c609b2c598f938fee67d6370a8d14d28b7ec66a29787e537a562e09b617e58106c9a3a854355dc1cbef90dfc2b79317d80c8f65db0077fcab989186c2fb929377667efd9846d349edff0212cefc02efc8f4c2ff7d9b63c41512b6b0906225f865f97bca903f906bc5cd585ff0fab1cd680b5159de35a9a11fa5fdbf9c8c23ea6147ed0f18c2d675debeed5fbbfaa1cee8673e7d58f92e4dd61ccb89f3e9c61c7804ebba323cd562054779634d5a27d9914e42d4ecce0ed775189ace5a1936b5d1ee58ea9acc2e04474903e533db5e6cfe13dea7fea555c2718f399065dc799af4c2c361763533ed92e6644f4012da3bfb3de117bd912837ba6abd7d284db6d779311a3287745112bec80bf86d4f8e379ac60c3d88cecdaaec72c7fc91c470d30a1cb3627f140aca72e799a4e7144e6d60c6d5a8723f246fb931d02e37e2bb581253dfed53b618dd2a62ae4a70637f43a20f21d0f951e0639aadda68f3d61efe20e8c04bab68676917c2d20abaa46653fc2ac8874d2ff5ab489325491746dbd5e42ba8f313f908a1e8dfebd51c7004e800c31e0766e60494bbf8e071e85b103dbd604e55949a56e4eee7b13ae23ee3864db106f3f9a1cfde142a82080722eb95f9c23dd8ef57bd63c423eae55a97468a2d3c659dbd18abb4ec934a80c29e76e224a72355d6960822c19aea2d20ce32f32a51ed5cd128dc6506d3044cadcb0b3a6f450351662360ea20245020400497067b05b92e4b96dee0af8a959634a6e94b03466ebd0179a0108d3fa8b7ca9ed2e4f7d74f0469c9af41fb78c0cf562f2cfca6f681bd99211d9bf47cff69a5c3b342c94ebdbfe981f847d23058e3f5794568e9b506a1c798da1d11e391fdac6e82f386c1d4df48710c2cdc9cc89577a2432f30d1dad9415b3bf853ad6dfeb4d16bc28a1deb704c48174cfc9bad75d70b9b12096921d0c07514f03028682c9847e634c9a74e48117fd7e900426be492c4778aefcb7d4b21ecb0182b9866902557e897a08617f70024d367de58d4e9a9b97b8868375c48b920ab665b20bd39cdd4bce372ee3832756b155f792f0aad537205c7d0777eabb164f6895c9cb70c10e2d390cbeb2fa5998bf09e3370299440624520ba595892908c0f9474428498315cf3c2e393ab96c23e4bf2843d1f9897fac35327d4898965a154bde6d7aa627dcdc62ecec321ddc1f0a2e5d8ed86cb7298ea1bcee5bfd02932d50e0c444b5af4df307049506ea36e8bede95fd187e4fe22199a5d1d2aac06fcf0891f1a9f67bfbad27c909e515ab1ebd4441f5ed587030e1c4203e15e543725a107e9263d364297ef5f857ef76d106e870efb74eef71e9d3b279857bc74c98aa9aac76ce1725476ee74fadbee41a7cd914884f47b514fdde133680e2ac15dbcef2f0185eef61dbc929e5bac84459fbca45651a54b7df9e6b39ef8f4a4f9b68ecc174a7d68dae09020c99e60eb1e63ab03bdfbe7c7a700920baff58ea654a6cc053d2ac1f7b4590a397ab6bb548c4a8dd3c1ec8e9afef4091f0e470b8746bd44996a753ed3bbe941fefbada1a83e336c86002cc1a1edbf30a0f377f64461229ccf3dcf5061d8e5f5bd298542f8b9db5b0402797ef2003ebc476fd9b859049adf1007a02d63b3c86848b41479fdb110c8f26b934f6ee84716c8d417a1b461a8908a01e49d0d20b75bfe8f8964c026322b7ec109bd630ae054e7128c94385f406fb66e007ac1c5035d430cf02bf4c1f447048488d1d932628844f77475f90a80344298b25faed8dba155211bd15ded7127cf8f37dd6537d9ebe9e3c8b16e623e941bfc00d18aff6ea71b429e9926dc915cb7be28d29b0461f644021b0cf803471197beb90470f54a3ce4ec51cc93b76f7cac9ce080f7e93a063e4859e987bd8aefc62cca482c8560b1a1e4019db127dede8f81f42275a21cd0be73079b809c680e19b02c134bcc0d26ba648c25e7d207a4856a73937c6a12ee11258aced38038a96b71c85655eec93142cc4dabf95968216270c80826add2b23eaa9ab9bf5f6a8538b8ada5ee1b5d6503fefb69405a6d6f991cc2b0c9548f123cee9cf2e878fc0b72d15cd1cefde49a06eae6c2b36cf7bd0cf772ef4af3fba84c1d4a97d187331a4f9415d30c67177fd8874b90ac56123a494792398792c7df0f08f77d6c6fb8c75230b1cfbd05709f88375c47691764095bc01c83f9ecf7e760b7a827f3f6cf4b61984bb0884cacea374afef334e862574cac495599f10c0147207f0a346c67fc92b5ed97287f7562cf1f3bccbd02bc40790fe868b36560f6b8a11b826fbef249bbeab96cd0ba19fd204cfcd4c08b7f6108106b73fcb7878c2db5268a185b7db7b488c0be61f8963975a6c8aaafb789df37999686befed793a50a74188e0a7669bbc025b087d8f419e86594afc2e5c57398ae61df6640dbe1e4cdbd6fd52218d60d099bfa9a72712a37447e73704540374df10bb65f1e1074ad08996a2a7b5f5789ac0e840f7c3587ad7d8d1e9c05e88a11336bb9fc3ff052f79bb95c25e0a646ef004d1693c929ee0464a91d34f2378455596fd8ddf8636a25a392c84d3f270918ab012137065b197e0a70808145ec84804b27ab8ea88ec55dcd21339a5da5568bea3916697436c997b015eff8022f2346c70347cdd2cc625eca5416e744f421d7d55ac01fadd649a35c86186e83a5d524cf28991ab9a8b019e46ffa0a98e70e9be83b63a703e652adf1b60bf060b5a23fc62a865468a821a0a58ef96f3c61c397bd9d0768363158ee838d4174962ca3cf854dd04df7066b210e229f1e3d4ce20be5f990e328f2efb9204a9e39cc09da5dea939e2182bafb11c2d13ad8dab88f3f9712f3690910b45280a053d9d40fbb6df91d7abe785cfb14852cd5071ac5a7dc0257acd92e596fdffb93fa6801fecf6a532e9ce957c298a86831df28b03f11382a427856416f43f9812a058afcb5f6df80e61ac056ea9ecb9bdfc37ba9132d9bfba28fa64c2b712700282cef3b99ee9d6bb747ea5be99875cde185ed7beaa43b8e3862f4fe11bebb3aad4e33bd7ae76a778936f0bc9743aec0e8b1ee288a170ea28007c31d713ecd512f1b4ffb321aa39aef61f45f4b1b8d53462677ded2e66f543c0d09ab32310ac926938fc3a6917defc845f9abc58bbf88b087ec3e316d4a1f519ef868169c7eea80c078fdb2f5783a2cab1af9c1dba92ed4837a3524c074c04ed5371a48cd64ec86e75ea6772db173428e707f02bd4f7a4c6f5786af8aa03ca6a60427bc73ba64c35638df288ecd61732f29cb368a4f740f991d5e9b42727a7bab77fdbaa5270ac49ff3f8b87831235f84aabcc5b6133068aea40e5c390b5bd3e4ea32f757eba52c0706e432b1c1921af3160862185911c0b9719b08dce471ccbf708a48ccbdb5121fc327398912f21f3ed0d64482974acc06519ec42f95d893af652c4647e482ba19e71f6c818e37668d830d07f243568be998f10e750028eb6cd33e2439bbb4eeea7c138937982e51a247f41e725c91e11868ed71e08a2fb0df867571fcb6e80db594f71a9dd2d7317bb34925b9889543fb2267df938c9a2ef35f2eb4001dac756614a4131530924935ea77c882d48f6af04daf87e2c55f96771a267cb4e706749b46fb337ef7f33883e8c027c5dac273ed03bb9d308f42b532024b90459ce2ea98c31c43afb5cb5dcfce175c6c624baf1565339f6272363012337e8cfd3a807115462356fa1032652ecb64c700480ce49a746d23fa9fa229e431a738eb698db08c1c267e6bb5e65cc070e61864a44b2ffbeb4da1ac221f8ef2de9e615c2c45e45ef4e04d30c8e319fb9b85751b31d6c4fc94a57d661542e6aa4887b399467a6fb01d5f8c3be6f17f99143537d701525da91012fe318ca262aff591c0f5b3f938bd6e9ec7f78d498f7ab3b40c57a1c37b91328d9b3c8039eaa885ffd638279dd366439a6f2a8088a7ff0d0586e853771671fbee75a13622033132b3406c15cf39f995238a6e74546503c3e80311b0319ffc933f5a6a6b754f91fc166e2d21cfef84c5a3ca8df67b90b5e2ffdaa61e91507c189d57088669dca7a3e74ac1a3c0b6c669677a7a356dc4edbdf874f98e2b9fa6bdc53cdc662c362546fe6670777a433f1fa7787eb710131a8267ebf912603fe603146c71a6fe9b9a5ff82f2e72a95de9e5b1e7e0c1c63e7166daa08fed69ea57d4753bbbb8f4adba4e4eb15bc12bcb46f4044b0f77e0be856fb3a1a91e87130f848607e307bf62c07bfe68d1f3823c26ec9b600210acec89ef1e4a04b366931d83aab9b8d1f2dffe34a4adf9b99fdc6876a363ae2d8832cd4a45fee5e33b4ca3e18cf9b808687fcf2c31acf9c594b874644bd1e9b678f9fb93a4d2cec8be1e5eb6e411eca95c3cc62092937daa4a37e01e866b53fc1f2e8127a900f6c6003308f4e748ed5ae885a1b7d477fec9e759cc36f4b242738030c1e548106807c1f05156df2c491aa633e8f0486aaeb3475d0aed90aa0f71a30b8bbad1cfa41a747d6638e6962a8d9c9046bf7cd03086696fe8857efc3fc47416b1eb6a65fbc2d4a531e8129f8044f9c5e7e435aee61214fd90e3f5aabf65f3f44ea0e23d0dabd25851d9732df7c315afe90798e12a3086491fc8b49b1ba342b9bfc7b70aff4998a690183811fca4e6f78f0cdd5718539021a0e070219f1693c0388b2498a120302d210edda9693e5f3d7e6f14ae912f39d5d2aa3c833fea1d63eef65d7337959665663bac37cdba4fac64a70fe9c5dcfee77548404626793fbb949a591d613fe9f678bee416ade659e34d68bb7ad458c0e69ef36fee403d748e49d8fe79cb32e5ff2b192d3e04a2c57cf3ebfa11f32c42167a5ac82c91b0623305ffff337b925bd25e2f52f4b5af3472c41161a5de8be6dd4fa6f205bd21ff75e2937b8ba33856faca3686e16cd7e5fbe5ddb78bf31cc80bed03f7d5365f88c930b76cee8253b4e0bc56a294580d215d3328d21e6976f131d4d605b8dc1f0d952b6f7e0cc88230b14d0aa76774bfdc67206ac551646b750b7710ca88fcf1ffacf19ad6e4cf068b0e9854fdad1655dae82c4d50e0d893eeb4a17b2540ee1579f7d8383f2780c2c9bf72265f5de603d84b1c772ebb6283458a3ea8353b642cf4a777205ee1fb880e7189c16c50c808adc6695e7da87424a27f518085d99d8e04306a7d2f045f24d7feebdec7b9dd4c97d4276d0e8292aa511bcd085127040db5079d406eec87d74d90c3abc9c07e1979b2dadcc5fec95ef9f23bd48debbb9266de51e428e4037bdac42052d6a063a830881b3efe4e789272266b221613df7ea40b4cee0876be9c24f036c6fc92b11620f42ea390dfa31a3c3380e7f8c8d19bb5dc8efd90e1182644c156f42e5dffbc63e67c07cdec4f4e95998936b926b0943fa7d58277ba017434bf55279247c83ad2b0a3de3b01fc9b162ba3674192a93c9949202cad9d38798921d2c6279809ad412cf649bf5d636e177818e3be84e9b839e4b6507c0224bfeddc970488d3ce3fc0e338f1d5b0fc248ee323822498ea13c7117666c3beb6ae98126ff9b0f1fc45ea3e27b38990e6cfa51d55adabafa439562e314d212ec88073ba839a5d346c44e9606de13917e41db9e3f2cd02ae33a7d9b376203de4e7435a8e63d4a45b75b5e8b8221a07659f4de250ce0be2ad2fcbd260b95574ef9e90f732c409ff8b647461990f360e2e3644147a622ce327cd8e6fbeaffb4f0434119ee26c0a78f904899cd89a7ee6c26946ea16fb2df4f834311d422394662dca8e3941bf0d92f29264df0ead90c5cda1105bf87d0e342cf8e62871bcacfd88b55afd156f79c8b2cf713da7db0d2dcb62ce404482779c36adfafad31fb18cf9476cbc167d01a6b071eadabf93e75e47d0463fe9637739d479cb1dbc61db712a7e20cc1e5c2dcf86975ef1bfbe83880060a84447659e8042407f688727738b5402eedc5cc14792788150fa51e27eb75bb7a78f7d7e4f329ba581d7554c1c4567d0ad051e82bdf0ab3e488580c6e2ef6c6b0029bf0a30dbaf797ddcdb32ba679ffd6d4089ff2f929db761efe15578e95a428bb884bed315d23208491ab732331a2966e2055e53fb656464b646118881afae18b1079a3b87163f04c35219b78455be915d5422376c818a67245a6b8a23530149da77c0b6fa19d4298715995909f9cc61b62dda5d10b541595c4fbdb7508e59da82a9aca743099f69c31f137a307631cacd264277f1b6fedbea02e2b9ae411182baa9232b1480569433d1e5037215211acc07eff25915f05c6dea8179f3060620e67d9b6ba35a50c08d731436aae248605146dd10176a86129a6e5141b26d611375c4d36f566a45929a77148f1724f83a95847207d7688f77f75b95f21a0e6239f4ea0a76d55a8c799d739fa168c39af7e8adda31946442c3130a1843f5179edd5f02b53b1f9752ce79292a90b8803234fea7fe52ad9771f9b42d35c1aedf24f95d797d1419b5fb7cecdcd6f798ede39ec4b5696b8a0ea87d708126e5fcf87f68c597eed33477acf54f023b6ad5abcfcc77d54056b6c75cd654f543fa20a409fa097de646734f6d6fd7924ecc379bc996c5b1e116a4986b04406562443b886b7c7b3812da5c0ab68d541014f912d02581426558a829c912708cc7ab36e70a061d5efcb89ef7d0474a1c806ceddb4aa158013279b3e30d60a6472f0680f1cba65ef936b92497955cfb4fa6f0f158459df4d2d8b2bcdf07ac8696b3e0f5d94a3bc060dbfe5599406f0e4741c437dabdafd2a696c9eb07bd1fab75df6d4fba67dc89f0b479059cda3563dbf9fd50c6eff93529b321884fbbf99ec66f48ee28137c25668eb2f9add7b07f45973816b9ed8cbf51ad341ef9ad1feff212247e5f42f0ea3db12791b6023a5c61d8bd187bb86241c477c5d8cddc1ebbd52650f9de4e45690425c593b36a78220746148d2075049c287aedb83f64685a6ca844d4ee93f5d2dc5e431337413efdd0cf17af5c2e3a006ebee4d5f284fcaa6c6ba2524c9d72968cd844a82f333cd416286cf011a9903cc11dd8e74a6ac10c88afcb42ee4dc64cc27684722d921081ef378f2367908f43bf8b475dfc3fa08d0d5bf53c0a83c143b2dea39dd9142386fbc802e05f86771f3d273fdebe69b6f4e97dc4c5a5b3f944d5b72ea8910460f251655c4eaad784fb65518d74e7db00c25e50f2034908698c1df7e1ca26e2efdca1105393be9eda9dac134b7adf2896680efefc8e3d931fcd00b8ebc9bdb5c4160e566687b0ff58fbcd66f91d7fff34ad46c2bbc0d16283572f9871ffea77dbfab880c18c6b178dca35257815e97e26c8208d217834dc4ba7ea0f88fb5b424f5dcf607411e95a979014d929527b2d09995a15c17dffc3d8e528d7d332d9894e8d06ac8264070018ac0202bca28df83be4bfda2eed23955ef717451a8165dd957844eadb322e9441181ba67cfb3ca57fbc04f1fedecde9b17e3f3671bac8c09acefa07ac183ba6e7bc0cee5bac0706baa4016b4263fcafebfdaf65217497fa110e4fbdf3bf2782d595fb82436e159d977a00188e4c2b654844baabbcc78b94d6cc95dbf61bf58e19e075489144cb867d1e68b3a9e8cc62bef538e6ab9c119ced047217c94afe9371fd66d8e8a852de0a6a175542c6e55c26d86eb95ddbf783f35af6db2f0fdae93f25406f16cbe1182f5637ecc6451829bc5e0800133de0d1c71e540e9355b52902d4372c0143bddcb2bf80f4c78a9f87a42f6d433a83375242ac2ef040468d6bd53290b1b97384a7acd94b012bbd1408a0bcbdaeeca4fe6b9f01208e287bf383ca40bdc0e23c2bfcf719a74cf64213acf989986b19df37a9f237d3a8086ebc09af98fce0a64410b4bed67e5ec88cee2aacd38b8c934b98edc26a6cd4d4c25257816edfb8a6a4b9329bd74584a4a4910e7f23c59969574a58a36213a9b6620344f57b4ac40db9d56601ba2795984817a425e7738acf5396f86a5a8b5b0977820645cb2b0630a2fa3dfc3761760b04e2672e05fd1e2fbc51f799afea6e78dc8db0f8488efe716b6e52095d64e2b2b73465e6ebd05fc527aa71541831c02e636d5f349496c48da79eef664e09b8d0f87e0cc98774396ed0991a293092720e8da526726265f1e189279d52a892bfac59d8a89446614e33c0118646162bb221acd32b7fac669b0fb6ccd2e0a1551ecd51b15c8d05205b46787705e43e94a8ebd4ea5bb2a43f502791459122aca063fbd6b0bc433fc8677d2e8b976bc305a44c4c8e4e5b6500398870009e49cc8740cb63149d230d6b4f66200c88a279e33c6fc42c189c05e46b57dcb618ff5ce15c7882cf1c16404375df8f07e3c165af82f43c36b756ca6a2d62e7ad8653e86dcae419e2dc1322004b8af5849f1128243e295096296e9171185621809de652cf2cfd52ca0786e665a0e5551b9aeccb26b1fe9fcffb2bf4df356061a9754dde2438c0ee515f3e0a4226251a4190a73cd7adf476e7d34a9fb87d9197ed049f800d927943cca1c9e818a028ef7ae4374094f68976b56433265fbee985e607a34e6273046ac86c048a214a0f21874357e9541ee616fcf275c5006861e3a9bb63c23eb7632298415172600e8f453c00470e815feb128473ce110a76b6274b17946b6aac76b30e2f35081d6a1b0391e3aa128a7587d7430d087bff3cb14e3d7a034504703a8f3318ccfddcf7995776f879a96907a46bc2f56fe49de2ba669eead2ee343036613489b604703eddf000a29e78a84a1f4a9e764dd2f1926a01175364712808d7065224d5454e8e7106342e620bc1ccdc66f1faa5e413e5ba8423749f0bb7234c7a8ef3aad638043da915e3bfc9aa2998eb3873cc3d76d73f16528a82ba2d283410c9ac361d203b7d3f0c29f1c1090f58bc727422136472b379a36b63fa079259eb686bd8cb14a2feec1ae1782c02813a97a84f9ab887fb089eedca19cb6f6b5683da7cfd00dee078b103b6cd689cb872bc917ada89b79409ab7bba4e8f74281376a5f1cadd14a26db897d1cb960cc20d7521b4cbf2293f7d6b0cea106bfad93c861b1f3d7ed996cef805b0c0f4987c96df5a8041ffbd271f40336c2e39b91645cd9a769dbc9a9b424e47eabb834c70409d22e35b7d7c5264294210bb8cf601ff6656709430d2010734f8b02c9d14174e266fe9957996df66bfeaeea15bef46d8ad6ce44b457aa96919e0d95e546939b9fe684e4e18a8fb40e16675cf2a8e2876055583fcff435dc1a8d72bd0f68de6c7772a9a0cef13ed2322308ed3b6870d5ea949d01a37e4f80639e1a1fc21ba96cbb53d3bc9c2e8654b9ecbd9eeeda85b8868745192f440371b0b55df7c351a8b15565e22f5a3516f4e3f64f8870ed07013eb70f601cc928e27453bd0403c8c9d90affa7319f4af8e74df7fc662723d5168e2782dc09496534456141f16b163520575c6fd0875daf9515439cd83ec5a33e70e3a69bb60c057fa050e6a2f709a49f85b9e458335c52173a203c855ce882b638a3f656c55908a8511f7fcdb7fe3ae412c63b5df7ca1c14dacdf6dba1cb42eb8f960d136e51e1edc2721cd549cbc3b5f2042c2f41a089969532969345c0633018538c73b21dcdd7ecbc62065fec58a16bb3ad57d82eb7c4fa3114d270a0b449f2f7f2ae6f9cd52648cca23d87c5a3bcc0e6954868c8c4abf12b52bc45f94874fcaabf112f607028920280de3ac1c0b8799c989deb120592f2a277a05712a39fe64f2fda7eb3d908a0f18b9a28897d9e7d329c71ded22d86dc6c43d6fd9517bfce5f9f884486e7ccbd207ef8924d8c741f047f4beec10950401a00d174f345df4692effe7c8e8f70c0855601ffc9c832f514f08e5ef5c591704255e885e7382099bc7d03a21bd1b96cd8a0f612600d17ab8d12ec02b83f58bbc10852b7787dedd45fbb019c73f8d5948c2304bd804aa1152af12851a814483813e9fcb416e636102a7e5818508931346083acddedb8543423f4d21f8043a0c8870ed007aafe226ee198ed0e5f5d1532edbbc31f1971563fd393fa85cb731b175b103522de60fed828117d7fbec3f68653a995e109ff03356e0e833609b47c97f069b0ce55a9fb2647966faeb4a5c82cddd55eb37ec82c40edec88c24c52d9d031860aa28688628ba337f66a162783105f163550b4a2a5500155c47a63626ff3b1105b716db595d9d62c66a3fcf3cd94a6137fb09e4796d79126d58fa67311db922c2810e52f0e8afc6c104dab2aedfe658a0e556b432b98532fde9e1be80440f7299d25ab61914744866eaed98db374151a98686e7276ef369734cb1ce83b6c6529b8ceac3839bef3418a894e700077f6f9019a2e2a175c829886c2e4cc6b53be590e44320982c646ad38f115c61f82bbe12d2072cc8e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
