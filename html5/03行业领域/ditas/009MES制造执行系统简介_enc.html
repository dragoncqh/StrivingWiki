<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99c65052fe9ff65cd49fc260ed6ce3afb92feb517aebafbd067c5475dd2330ed9a1f8e64aea07ad3bbc1ff280d35e7806d0102f7f555ee4e031c04620d17dbb30bfe42b71bfa3ba56b11513c3b357056ad55a7864eefd23afe308816dfaf753e69cc9bf12ac93146aa3f127d447f1914ca1a23560272b0093d1b960796df887cd20d65d47a029104635004c8d975b4b10953830a0ed78988b5cccdf58e104494618c78a6e017d75bde49ad9b4a640711aa3e0c068027d9779e81bb2642541d6cd3e8cf86ef74e404de369e7cf701f73b8bb1186f0e7c2d8364fed4c5ec5e06d6a6d0ecdf4bbf1b039cf3a6b862690186e37f3ac764183e57dc5082dd85a9e84bd2745ae5b53cd5459dbeb032269d10a821f12d6a4169088adcb1a52275d64a52a75adf90f9e63ef181d306bf737bb02268fe1e8d48ce4a9473eef1763ce381c24e5b8b275618cbb621709f4d96bbd7eaf36f4f1ddd483d5237665334e1329333793b8209ac1d983fd29afcc4c7d2e2889b3555512440a4829c51983508174f10179a270b77eee266236b09255e4d790e4e7eea521e9b0d907a54165717042e4e5b41aea55fdb4979d53c55df9dcb47579f0d2d03c1f6b017e965c80df07488906bda7c36e9d8e920fc175aa7411a1a0028ada6961d5a91a0110884829b58537cb57dd33e8a1c9a9c2017366f59da79b2189399e232cde22b02e0d815238ffd97b1021a950fb13e81a2acc04e47c4869c8d5c71ce9c8e70cf8365fe0ae7d131c128b3b4206639ac3228d86ec861e20b943b66322c9f8a146dd0806c32d1c2331eb969aaee27bcc677cfd80cfdcdf9a77d9a848ac7799d03dd6be4f79f0917675f91c152bcee064f7425f951e07f72d53d5fd1db500c65edc3826c3130cbaa0ac12fb3320895d65be08a4447d9ac64e93f7888a16f730422132265a6c76e12c2ea3caebac86e80dea5b64dc9c0d001899fa5604668379847aa0c13398d3ac617882aed92a60c72a554fcb15c3599a6f8ba2b01f5a4165fb1333766befc405005f30af2385954ec8937970736521167b9da57399bb8cf9ba1e179853491164af7179e0c8af83e151d4a5cbf9d5b3e2208bf77a7559ca492e834cb8b0ad974f882c50a974ef075e268dd5935e635695d48bcd4d4cb0c763313a763660d2f6815ae87c4dea0261445a54d2fefbcf19e9608e2837584f96325b21ac639a8622123174f034b0cc838bb47a30724a48caa307c0f108274da45bfafbf7380654d85092cdfd8a16f7a6d012543c8e28691725326adf821d470061cfb6c11d0ac543d87a4a587e45457e66af803c343b801fe981dfa3eb1d153414d33bad377e33b464f99caee93d3a30e2de23cc561a4dc3d67086b45e392556068e0cfce206243925df2c522769dfe7929622bd79c09456c44678cbad9080df26acf8cb14ba70a53f15706e8889991e97252a631567eaf59f5174fe84dc1bf1644e84099ba520461d9bcc52002f0f88515810c1dc05153830a96ca243890093d2a30b1c61f2fe47a87387573bb55d8b07eb50c8b1c315eb9433c17266717c12347425c1c3a51d80042c46655b1b3815f103afc320c79c709bc42ee8bc69fa2aae87e52b11ab65bb48a271750e77a133b2fb0e73d821450e91613c8220745464943f67df95be3991d1ce182a2ac89e50a6d77a78a8a43abebebd33e4267c81e95aecc3eaab3c41b6b3ab5e1a7d034403ed73c6e23cf8e055e88b21018ff9c2b301c45ed0a9985e7be908b8c977a2fc7f84fc598c034fe859a17c5cff6b3b68ba54fbdd66c7249927d252bd8f3df4606d1d1acabe70cf0d13a68ff083ee85f7d077e0ae3878be8d28e1b1e9f7a66b89a839b45f424f66944f9c65a89d01c8171adcf96e3bd83148145d6b44ceb10608bb43ddd0660ea1d51d8c0ac701546681b1b6f49d81b8e97279fb4945b76f4e9da032cd1a993b0df27ce62ba90e2a26962a5941744f39ee395dcd35abfcb921c639acd3db50391978c4f2535803596de2a397304924313ae386e3b0feb8c920b82a4e0270d32e7c6d6924b18e2d3a47e2bf1ee05220154459a396569efa220eac3d614df3b33159d7c96ce2514402d8d9e0fcc066c13093901f71a544e501b69a874a9b397f8311d450e1320d02401330ca071b020e6a80e8c0804812d6371025b32c5afa6fe4795d64a45a57793dd720f455a7637472a48769a8674e718825845335f305ff590bc841e694741ba31eb0da5cd501b93ddb0c1f10adddd70ea671a9b013e32ca11803476a11ac48f39a4a93e6807d19639267b6e7f6b2a76ee4ba426aed2b7dc8bf57b920a8686993349e3d91ae28634aa1eb6f66e455ec3a6c83713de2cd77c4b200234a7779267a90bf4a37043df4ef5286c90aa7524dbe43174a9dd71e82dd007a3e6dedce3efe8f5273582b09a24a5a6df1b926b0c537e876087b81a801e779fb279dc599deb6cce3124d3c8f3ad67c6eb9cfea605855e5a4a6a92858f99f6f356024b043b384b8363bc9836d70019f414b8fa18ed708804edc49b3f6b821c12084bac579c96f7a36e498a1c7414a7251c99f216a5b7de6ed0b00dbfaf1fad792cfa6071cd6472fd6ccde755b9acbafceb341c82343be14e45582b749b27a2f5b56f24c8b259b63902130e9d9e621efb9950272ba028b0c5d5ddfc71f98c73753e65faa388354c4a6ec950c9f517463011d8ea1aa0fe9306839fc181ebcd4abcd62e2097dde00e2fca40ac5fece24781985509eb10ce6e630121c905bed10c4b816901bb1fcaea754e9912a0509e93b7c96a9a59bd2ddd756704ed56fd6116e3fa2699608e7e8ac3286653715d71e2edb2f146a45f941d470722ba0fbfe5bedf8981dc5cd72db6c23d38c5e7e9da93c0f68abc8c3f363fb7238cfa2978963d24646679e132fe7c908a7de5ea9038148b083e5faf9ed80f7afa7557e5ea77cab190e0ad344df5e74fca73de69a2413d46ff9606d82d4e99641e7db4f530a4713ead60ab2aa67b51d68021ba1ce189a31a6990bc4fcb7140fda60e602ce4e213201a99596936634080540f56f97f47b0ef7d7278dfc36f09d07fbcdc7314d46d143cb314ef064850abe9ded1dfee2e2dd3a9ddaaf6bb3fe98d92eb43842a2cb0752bd380553404167c01dd4c8e6611987895899b4118d13a0f76bbacac9cc1b03bfc7ba0b65f7f7dd74580c6cdd10304f58a6e493a414941a45f45bb76a1a2df43d29d6232d09f3ac6137afc320405333095024d255815d9d6bdaca7a24316c1adf649c23df795dceea4a43313064c3d48f042235dbe2f850db288c83c6bafb7e1b170ef49de860c7fe0fe62c1b7346d18ab80ba182cddc28eda97bf18e8def9c7f58fbbefd59adf0cbaa15f7f52d545e09cf43e5f33cade1c2f0a06be25bde97f0f5c30db30708f53186cf4c72109737ca63057da946689e9deaf6fcac71ac9c34abaaae67c8670e384b12d099360a7a7350ea25f3b11dc6fe808326088106aa5a1b1aadb9106f1e6ffa25fab993490c4ab1ce2de185f8fbe9196c7adceb8e8a9e9a48735555f271f796026fa9dba3cdff936250269c5e77cb5172b224114fe855a67547c7ecf34aa4a1a086fdcbe6e18ae7817bda87dd4310a3325cea8a1e040a337e15300687c7bd9ad6cf7be700a5e6bd8ec6be42e001f7c757ef4506a2bc15737c652fe0d71560a8987150bd59b81d2a3d55cd2ca7a0018e4519bff91179b8b448810170e7aed0fb28e7a85e305fe53808ec41ac302594fc462bc328fa22023fc50c4909cd80c832b6a078be75a14dc756a529a6c0384e1b50b08530183a441a9dc2e5e271e2cbea6f136025fabe6fbe9545eb61f1398abaa3a5e74137d4bf45ae711a1ede15ea87cb5ee887430eb8cd29946cf0990f4aa6186f03d0f433e594cd4b0c268d90160821bc726bb59db7b8bb39326d1d20ca712f87e67391e81bfc6f12becc53e408caadc48612f11f0013496b61b6f1b5cb1b6bff8bad756fbf6f139f310818ba96f21bffe01da930df56642255e651bd6cb1d5d8899fe0402d187780a164c90e124f0e31ef1dde6b4ce7471c01ed0a8d6fe7726cfe8c941e90abade1842368aafc85b268d5f5efb0566b8d5e536ed48d189c9f9e8bdc63d9556af7a61d279b611700d4d721228c451932d10d5fda819aa34db3288f7ddb3103b7c54d8fcf577f0ae26a7bd1286ee17b61a40bc524fb9c0c4f13ddaf57b8374633f1c854699aa86fbf160846596083f6886b199fad602c3cd595a3c250171a97c11ec1b65518ece78a36727a21ceef0ff783cc1ef3678bb19e8f142bc3a7490a27f67d6a5b011d885474eaf590a21b2db482eebb7a96968906fdbfb14d27750394e51242d0abaed38f64f1149f38e63e538087def92fd2a3961a7e355983528ce32277d55fe2722f9733c60e5576ae672d1a38ba87d6c6fa3603723d8318ac3842e88f335db5eb3174c7c5ee83dbbb4f3173b3636ef3e33e6e458c08bfd3a056af4393b52c8867cdd1b0b1cf993fa5327df675f56dc1d1d4779f678859cb6580e3ca9069cad474931eac0e3f6fbda316a6205419536caa9fe2ceddc8df051aa9c7c65f3c644f3be1964d1c270283c2fef11a534c66cf4eda1a2040fc689ec0818be87f9122f8365ffbddbbd2e9acb0af26aacfbabe4f7612b702aa7b0a991b2eb25f9029ab54510c2cd32278ad8266d30aac4a0efacf98746902ffcb3874017cf2e0314c03b0a58bcaf4cf1ac6d843f58d17e4e0625be9062038f7f9bb0a0eb36f326668f089fd8d6cc88597cff8290c4dd441d8aa208a53c8ea3fe3d49cc619f358c9aebcc363383c09689675efa731b31db10e5b1983da0068e32967b13f765d80193464694230b992ab499175e6d2618086e5f8467ee57a54645ce71ba904ed88363bec11fec2adefc78a5bc568217043d960f4189220b389dfe9f5ade128c614e0f8e6dcae951bcc94cb8cba826b8d7144735b23a5afc855657e6e4d344c2a96290c1064fc8a78ab180039fe897b2510ff72285310e8d56bf49fc7dca8ac73f36a0445652f811b25542a6e8faf8e2d2075b315f6f36ed224ddb8378fdc4ab655ab046fe96fc54964050fb7b6350deb3d02c5ebb8ba5f440a646ec6f902f66d950a1bd515c9a27e5f11516e74707c0de9f0a94701eb3c65b48406ae180bdb0a0591a86b8a2900ed424891f89528dea1ac971e655cce0e49c2dbf5d3b5a98e0416d1539889d31e2c0bf98bb7a0af519ba8f8e99bd9efa1ee263f1b364f44996d4d3c970e4dc20548dd3295744073ec7b04aeb2c75cccf2ee513655191b34f317d561d902d264d426e2fe425baf3d7d7abbd6cdbafd9669d5d7f58e1b87721fdbfb8706ac9adb8523d3abac3979dc9714348de7e5c2f744ade8b0806e4b3f449ff7a968d6e3430f206590bd8e01bb857e709bc320cec0ffc2fc7896f47c02db1acfe39187dcde941639fb402e487218e324ffca44b7fc6a87bfd7e4052bbdd7db35ffd891af7d15bc6a35e58f4ddffca30d4c0bef86509d2e39608cd009a259b9cee31abf7b34b1f5e986400e4c21421bb9663f0ae56903497f49ae986cf8d8e1e323d5ad3133a6d0f699a05f818c6d08809baf06cd2d375dd6cf00f5d7558e66df7ce290d07fec2e3dd8a8dc376d65bf8f28c60d68bec42e378f03003a866ba9fb265a2c0bd8669b0035b579342eaaa82f1c4dc2c157e757ec62490c405c713560ef77302762b8da086181b0b21350b369e331377f0fd2a9005a67d5e54170c6b3e7486f9f94a3a440671b835f81482f27b5a73f26c1309dcaae4501703ff786a3a77856c4f6eb560c00befae58e0cd70c24147dba4dc01484784f0dd4979e6080c8054f0ff7b82591f23b96557563ce419ee7a14852123633bca959ed92f953b642ddb54d3bb02c24edacbf164be2654fa6207a4b5a9c831dacc7631af938f11a441dd80ce94b4e04e855980470c27c1196afd17a5cc68c27c9cf725879b9f6500e98eb854fa84b51e88d7a49264590460c737e7f4113cfb3a41f4d98a5a62dcd78df2b779ec039b73f48771b339d0fcdbb66777dfe988e03b47bdf8bc916d869ff0a51b588a6866a1ef77ce062cb2530f289f6ab7f556d6782bbce6acff24a6b231800a270de55681b7fc3bc9069a16a82208c18f3917847415c9e0ad467cb9e396f4e3ad415aae8a2d739bc72bf245bb8607d4f7e48dce2f529fb43c816e84cd466858c2393b88ae9e6199e37ce204d6f627dbd3c3952995115e51ab9bca6d38750390295896085811adb8655334d49ac7d557a2ef7020e53351284712b21f4f60a3c37f7047b8fe7976cfc643cf6c255ee6dcecd04c077ea0476395eb9ab091bae37b0b48939eedfbf1e29530518e72df9f494e42e4dd13f10f487472175370d413a998167599bd5b5eba9383e4d948d78fed21a1237f268110e160dbc4a2ecebdb27fb7c0b7e7c569a8fd5abc455cfc9e2ff18c327c7b29725970783ea7e7744cb7b20677c012a48624ea837bc1a3b531b780c6252aa13d5fa1ab659b958a7a65696a147cec5ba56a4d19bbdc6988efb79d63b83da3ee8d4c5b7567cd465556a15fae3c42d4bc0119500ea26f444f3ee13dd8ad3a87a3276fcbf633da5a733daf9e05ce984de1e90f8ab49c15afffd58e348c90131e0699214723df062c874e2e49673468c2f1bb76f79283c44c3db342fffbd5c5854586037557662bee244b54a4edc4be4438a3160d5994e8cd081b7ef259685b44972b61e18abd6e7acce2e904a941c3578dcb6e441d0618420962e3bf5014e10070155b6cc21013d63055c9925ca81e3064c39d5efdc2b9cbfc128e1e11f0ea1e5bcecb7ec8453611f2b06ced91adeedfb7c7cf6268798b0e107d0a6452fa9f81ff549c236ea7a85edf66d6d972a9c9e57ddf0039640903b58f50842d5117cb013eccdab2f5accbb8c943d5a1563e0caab8d341a33b694145511e520a209f70a44c00639d3051570b304adca9b1b6f1726f1f2d7c2b883f8ac5ce45ebc673e9f26779057380e88ea604d6acd5f2d79d255ea35147aa54794aa7be6245c46a68756995691c4cd6291ebbf80949def8a58eeee6122bec2f1b65d57e34d9444832d50f160cbc6722dde23222289a7b139085ac83aa42db3d712b9d93d27106f8f9671ed906cabaa8579eb17432c78891c8b504a8330264ac89770c6f9c505ac4107f8d9f1fa7da900532ce88a3ca1c53039f51a1dbbe4c2a901f45b8d5efde5c1a8615782cfda5f6977cee820d159f42d0e842fbf33c07cb542de6abad88059521b84c5521b75804a53cee58b4d82f084ec90ae77e0ff724365fb0177a07f0a4847673b9102288abf3658b841ea88992c723857f86b642df5bca9c8a9596151e8f2842f94b4a0680f3933d51ba707d17d83c868b39060c9413ffb6ecfb90db8576039a4806d3f00a849bbd2654c41e74844c6a8c687f74e0fb4e3408037c3c853af5e184ec2be8b001f261be939f4fb6f12e4689434aaec83046d34f50fd6268e1a7a77186e894a5d46a103434b8de86862d21cc88dd2d387de9dca3dbbda4da8dfaaa5b904168ea229a1f3f4d624bfad6c0a4e9db0ca5e08fce9026b7f623986eefc876cdcdc45d8bfa557665d513fd3579c583e99db461f4f8672ee5e6bdf63ce95139a43917198ce79927a0d7db4b0d82d43360dceb68f7b43d866a62d269afd57552448374948ac5d2e057aa943f904097e78b2290f6694106783872c637d93589a29bd4ef7fcab5715a5d01e7b356a510de820fa66747987c0f78d9d4c28ebdb0e56fa8047aad4fd0c97742a5c6cea41a4ff7d4084bd482a031628236a25ca06b129328c65b9a553537b5293aa78ac694707a7aaf290173c044ffe54904129758cbc8849a3801393fb5a8ac63944a6528de5a835f1225bdc1db377c60c5319f0d6a7a78a7f560ef8aa49638267e5c9df08be46aaa4be990efd3436e6d1ccedb03f15e2407fb622c344e5db9a93263893af20acb2d275ae3e33b1bfc0c3ee506712ea31e12c065e072f40e7e4651e0628943155c411219b0a66c4717823a129197566675f191ed5994cd90da71321c1072fc299feca5f103b4a0932d6836071b3102863d404f5f78243dff7081be084a1b2a81b363167bd193ea44793ef4028ae7e791a699606832a9009df4fb096c8329776a642dc9803d4cdb71eb496ac9ecc722516ff83f61e1b1e63956af7e93f7b975b880e7310f1b7565fe3ec19307a57b6c5c1f1be61b19084df9500e393145ca643a1ed58ab98b0d315bfa36407b095271cdbe86f9360b93f0069b83bc6853dcf138028353943fe1de5ee3612b5a08d6889c71e49e51d9883017639988e28910bf33195c225cc8d1aff2cb8afe4326b094434bc1ed736bdfd44cfbbb3fea776d404d41e4d8416b7e8af289c686c209a2d297e60c6c4b213fad9b208544170c0868bfea5b37dd4adf72b75c72259cd8e5181eaed59e4f89d7df316061bde0059fe280bffc753b30e6be2d75bbf28de0a596e2fef4baa0bb19f8c188a7433df732354916f9c140e318d0bf0234519fa82e0eff5aec8cd4b4bccaa80d48c5b69aebbdb79fc224bcf29a0325811a2329318ab44274e511c377635cd66b70838e6df4626dfdc99b10ff94cedca640cfff80039e3ebd75e16fda993c9d07d8cc74378aafabba059588cd8a496aa9baecfe9fb736f47d9afa6b71b581fa7097bc18b92683beea867eb236e06155989706cedc47ef654bafa8de13109a64ba7c6796494541bd51b2c1d02f491c745e599cd1daf90ab71a8bfa65103b631f58a88e6d9a173edaae25df488c9f0fc93c236eeabef5150313bc675168594a9ce50d1b7592bb220f869e4c9072ebdf97dcaa9b859d2089d07b7788c2760df927672fb51626785abadc642e5666ae0d4d96c63bc51f72ab91ae123d3a3a0a2e4de960c92ccabcb26c9e46d55838e1d88f028dab0b799deff2382bfaf53e71edf5de675963394d2f64c7e230a0648f1f441296f5fb45abf466ad0c2404bb9e98f834288f554dd2a6ffc7bf98d70bfbcacf802099c7330a8e4c4c1d4483578f6d4ed8927afef523379a42ba4926e5a637b2574faf25d094e7edc011839740471a3877ca5560a05b1ca6a53d8bd32c655f0f90d62e6e5a9b7551a999bfd253fccee4ab05a8aff46f7b71d9c2b9e9c7b525ec29dff8e48dd5b9cc7a9dc08e522b1b59a7ea9cf85be869e85bca919c7493bdb0f8d7d12d31d8736d8f46070a834270b2d309879a61e7255d740ec17f7fc6be4ec58b6969b46a8cb1fd0db86b3a5c51b1b0cf9d595f8b767f95784605daf58841d9e3ea5da75e01cb87f9658ee61c3cabd9433a45d0d3a0b87c82a00a7f5dc6d5723fc904c2573118a7bdaf4646ac5007f2d1e3187072a93e949cc521837bec98698e424f1a24f8e8d9a2dbd84826810127ec1114a301a1e014157809612a5cfc0bf1904ee31e0f1a31f4325537e113e9323c1c9480aeaac41d5a0f2e4b93d21d274bf73f364e29b13f26ed80ad76c0947a3e302388c73cac23f96969a2932bc1be5dba3677b990c58dfaa2e58e8ea591c8cf328aff18afbe149fc51c751f54d9be528c64ae76318b0fc7d27e955420662f1168f9cb740a39788116464a229f14e4a68a76e3fb892d7c223c2f221649e012d07afbd9aac369e1276b5425d2629b2650b6ac1afb647eece65bc1213486bf2ec0ef3d15dfa5f912f8b922e32d1fdd08f2870dae9939dd552ad649e406ddfcdf187658e5f9e489757764945c5d901c7d21d0cea9b6a7a9b1d285ba3d601dca5efd701b34ec0d75e5dfb50db94689a54c085f52189a634ffc541be3608659156ee0dda5091970d9621c841c9b1d587fa907ffd1ba8aa16adde3508e9f40bb89786d5b0ed9bd6437e6d647878450ac939889a8297b6a9e2bcc7eea20187f50c235624fc82c3e813f14c0066e765afa6b64558baa1f40535fd8decee964ade7adf33700cb75e38360344ce34adccc9d01e363321802414599edfece0ce7c53d86b36769c4d05b39dd5a386d40b97ba2bd5c04617edf8c27e8b8f1c544a60aea6a8c2e5d0a91b7e28378676b5619aae64cc1a97d907c70a5f62b00daba129b0bbc2c33da68a74689d5dc8c3ccfc09512ebf6c04f22d936e4c748d55910eb428f7a3c1d02e84f52e35789ce728a669b55e43e5c524dd0aadb81fee0711ce8e52595d65864707756b063a7040a69d5fb5e212b010497cd3b00e7701dd7ee4aeb314934bb894a7adfbceee0f85c90503ec4b88015c8ba302070d44f5695a56d36831bcc95908383cb707de7e48cd42aba830b79f89798c9b8cad76446b6830c0161aa36063d6dc6b9a1348b6e16b62167d6eeea6c1f217ce5954c94ec3099ed0867818128ea967652587905aab88c97c4d1c44b43f1e8addd192090f93b988e8fe1766ab1e4450f3ecaa0104ed3936e7321e8973bfa5a0374f2795724a2d606e6ad14e5b63e3a62437c8a63b2ba22526ad37557aed7341eb588be24b94cdb28f3b906673421aff6a10354b1cca235c774db96df24b2674d225d412a038ab87793ff626b1840a011713b7cd94fdeede44fb232a2fe743cd103af1c224ab381a721315e4c301a0d2459997624f6253af6aa221fdeeae2975331ac7159d1b4e2116de942906578d83701a453212e487dba2912852d69e9d42c16309be444137cab284759e7dbd4819c382403c70d68e273d10574bca89c4ee2b8d704a2df6ca93cd751ca4f0b650ac362b6deee3ba2b0bc0c6ede1e64360eff919e4535b5d37e48ac4363513580891b410399a38792d496ad348507e21729f378b622cc9fc9b2b66b6b504510b6541d3d1007a8eb725b890bee88d6c84723fedf5e45136a1823e8f02c5e33742d50db13fe8549b3778efe64a932c13718782239c524a95ef1c330e4356ee9fd9881d6a25f4e46b4558f1272edd0c693cbc8ec58dc2c668a7cb200ac5ac5ad3615e61af6450ff737600a7f0013831586bf35681dfb3ac916216d06a3ac4781f0071c5cb5a0b2a3d7c821e76717ebbbc9a33118eeb56c4f00e9e410c5a3e9faf3698c6ef36b46442f7e19a8fe302b8e4af84ebfc2fd6b86fd13b3699173d70f87b3b02276f1e1e090d0ff745f36fae3255ee318f4204557e919b98d5fedefba3ad34e81e5b8a20a5204fd7335a68dcef57174d3c8ef9cfd8549092e4461b090643f356858262d64263c130cfa436c5510e8a3340259b27919789ae99ce3b5a9d917f3ec143f97b22427d30d98bf147f3411bbf2adbf69ce3804851585b71db42b0226a25de2c9f02e28493e24526614acb5ac51d3da9f2ffbf13338d48288f4a08c91fcad4c631631eedc66417444f9384a95def25de56d72f94a2881baae5a5722dd8d2def9ed41e5c112693cd26af510d3f7d052befe4b790edb5bf9d33c49379eee52c53b275476941613212e684eb7911fc5467798176aaf0327f5233ce70f6962f5c0c6e48c10705413266b34bd4f36a452b3295d5c3ba604e13c13adc2f302f0cea1c7ac5f9554c4bfa1bafcde2808165e1dbe152c9f2114bad93e3ff8c3eec2a96f7cab444e075818d45ef3d3be029f5c95b9866a5801000cd0e565e9b93cc7b7a872b2169ef712fbc1b5d0c127a6e4ed3035bb09436a54f2220776bffe0a2dc48525f1c0bf4bc11593c6ab8e91d09bf281904831b23d008aac0342923752c375b683dad94263638e6226222ce9cfd0a23d954c947306b41f48905dd2e290bb5594a672e7440a5b98c76f68b299e71496490cb4e85605aa6e4d068786ce610622a22ffc250a486d753ad75460ef1f20122ec6c0dc1c755bc24fb9f3f047364368ce8585a67e960719b959bcd4d5e1acb99d37b7138ac491ec3b90184e54281c7e4313955cb13d076ce1bb35a207184f9e7cd37e47c7d8a3a482a0bd67fce4804befab61a882ea61be2906e3acc49a7fc7b8ead5788230ab4a5a6410d9b596322ea3c5f953fbe29f11bb3cac1628babf45b210a50476107cfa1fae6848efc2048b887f4353faa404bc749b370c53746b3c80d92164c4da90e0211702b4d87bba9d741035816f7de0bbe3aa9646cb24c187b304e01ffed356107de564d959fd3bc562d410cf370523a49af07bafd94c777f762b32ce99a01e5c20a41129e0dbaceb068a754995c3a37a6122a38de13ba7676f93dfd6f795b49bcdd578240fcc3cb50b4a8480adc064855db156ee8ef0ecf5809c65407bf6f559fe8d2bf65cda834aeba5bc7f9faeb36b34acf1577206ce10f6e1336684dbfd7195cd38cc0abb062345b1ee13e7da627e1adef9a636703baa1f5764369ea221b2368c3d5bdb16b591f95e386755347c2d827803a3ac86120f1352b868f90db7b5c5835318d39765d3d0d7b032461141ef5745018c04224e279d00147c253372b0d5c175e1d7df46791d6c2e4f07412e3cea3149308b1ee13f79cff72df4d9018b07c01229baca4406375dfad1c0076302ad2db426b8882698fa9b6fde67d277091269c7d08bdd7076c05f18613c7a5bd999e018e5caaa49aa69f5af9311fc0b7de120c9790baa92228059a8d46d69c0b696412166a9222b65f9c142856705607745a60229eef27a9f809efa387ccd6b3014a190768f003a9a9aba1739aa17bf80384eb7129141fa8188593acef9b6a584f5bee9f21f78730eb4a267d5b2ca61ea805f748f99c6ec0d3554dfa961a3c7fa3035d65f01efe860df591492a1cb1a8422d9d2ccf079c8b32eda492c8cbd0b49c3a35394a643138e2be8cd9c5a8c28220ab1b26c5355719deda39caa74da4808f90ff8adfb8e0e54ec37da18302f7e9051275c7f49a0ad406f8cb1681b63c50d9cf878c491fe3f0b94b12d9eb9e536d5833ea3c49a6d6fb6b9122cd184785fbded443bb3f44c2b3324f36ce33f83941845ed4bc7fc0263dacb870212827c38ad75be25819d8fa4945e2af99a13196f72e6644a7b09a71fb2d87b3e375e6a106b7ceaf38f8612732294e0ce0707ceb5b61b1687d7c50da492d6594e97aad5374a3fa307c5f42c923d93ec383036fbae9d32a9e10744e8c38eb4ca343d76f04358e3518359bd6e3437bb716098f241251b32735e74ba6bb9454df516835d43a4b42d68de02386b0970aa01b47242a3f726c84f995539d5594e6a04bffc9969a1137528e0119e012ab67f6e72d2dbe6fec0805135a9d815dd1c4f871d0c49e0486998efa61ce70dd582449114c99faf77f5342302ad09a82b9ea561a4b28ec3410855cc22b4c5425d24e52d16df588f22716eef037a4d8ad453191b89eaa3070ff1c783a07f1f11c4791669dd264e08c3aaa25e18ca2850abdab9ce10a72d62e714a2d3f3695639262e540902f3e7e9fd6cea958169d0cfe80600aaf8c0367bf3cffedbf43d521421ce3b685c06c5a9aec74911fd126a1f0650a5dc092022339a2d491a7f53ba3659eefe2f5b2f0d2d54783746de75d7dc190826a0315a6098ef312880f9a8f4b6b529ea9586b7cb64c6bdbe960eed7622d34817b44f54c1e684ccfd5ed1f8de24bd7b873ca561b64110d68e8aa0c03b2ee5e3534dc1de71f531f7d99525dabd2c786d5fa1a851d89c7d7b979cc31c7c6204444e5e1528404023880f90dd6c956067c5fca53c23a0333f723017533bbe3b34c349e636c5bbd21d0b162c7e5a8dd9dce9ff3fd6f1e7c2c94e2546e9fcb23e2d73a273ac80156af721751b977b0fc35bd42e54a2c5fcb81491df5c96b9c1093ff8dd2f2c443982adf86226768149c02bc18dc93fedc1e8118ec6577765ec3f9d1aaa9f5c19dbffad318cff729169bff0fc9f5426f8c8b90a6ce1f3d086fb9cfc80569e976cbded427245b41e2e0e483862bfcedc7c31a82dc75baf9762aedfbd224f9be2f2ca4abf1f2bcb61509751a6559b3018da2f9bca0486605fda40bc0ff243523e1cf96f5649115fe7631a67e88d3e1521b08098029f0cf140","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
