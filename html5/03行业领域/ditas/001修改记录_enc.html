<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dac4d3189b515586ace0c41cdef605381323bdeed89c99bdc8c347bca7a106884baaf035229047ebc92fe2d71671d5d5a1a95aeaec031b40da1b7468f0c0c4fe63c01df3081ab5269294b07890a7569770015d02a34e7c29b805814ba187d84fafb7a7b2f72b928f5405d820f8ccd27435141be3746b40054fa11c14c4dd949909ba7f1124a9a4bdd7e873d4a402e834ae0df30a97a316eeb97485ea7f658ba52a271c1c9d16f3e9e1c5cbccb1dca30148f50e2f637035d2ce5b75b7fe552a68e8496dd8fa2d9d0baa9550fd56d65ff2ad2e87ca4f192d82a61cac4315e8c5c1188d4f99c4a305bc9532d0dea289eea741cc928dca58556bbf987c69f13dad8d219aa73249e97a4d964a0d728647732feb01773d859fc5297a6e6a50440c35531ef98c17c47b51d00d8ab8a3b4a0fcb8605636ae4c6eab488626f65a6560c086c54a2afbfb371f47984d7503e5e54a8ea338f4dfed1849caa99f0f608be2040614ee7ebb1cb3479425dc444d91c2565dec50a37bbdadfaece13caa305da29aaa627efcac8176e7666dbfd2f7d9091c7a172c6ca9f062f3bb138940916edcbe9b9175ee1c9baeff290604af766b9f8e6649691075fe35cde4b224bb30ee513365e01870b7090ae301dbe41a8a5d4b4b5d1e1521c31ea785acf924b28f1763b80419c2065de30dacab2d134af6618bda08614ff791d6cceace97fbf8be2ee14d6f92aa0391c18b7b4014acb99bb3200aebca9478e5540b20334118ff17a228e93d179c5c91e6d264594d9dee9ac542cc2e9497da627fc1243ee465c7316084d78d0c7bcf0d68df1ce1866129380f46fc0de4fa4d208f450752b1fe1600d83954059bc0ed48f0ee97965c74309fe36d4c29c125d8efa0b475abafba6487677feab52dbc5f500e1fcdd1f73e567c4b1c3d1c3bb9c2e598bab018fd9463777ad10536383c079f209755ab401f4f5ce2a6d21f1df8d86729c676b980686db0fe5082053cdcdda9c3fad64c42844802ad08e50a64ffc9f367deca6b799be09894a62c75035dcb6d758865a968d56bf38925ad3b87bb7c3f6952f455ad9f11a91bc7236baf05acc78338bd1f242a4f93fa46c5f4f5169aad43badb31dd816520b19a690b32de0474da9f1c1c4b80e5148aa8473455e30bfd54295f6a635f2b2935c50d684398d4da6a12ca56105cd6d123dc94427106ad6ae00f42726aee145de3fd679ce61170155400b205add32d338f2617e6bee94753bd72d4595c4013466f0e811eed7a1e32932cd245392acf2ca2065fe093ca99349ed2dbc706948b043d9a544142b9a844908c0369cd238a2b425631c2f30aad473dbd6f5d5d4e6ae052287866416bb5ac3b8ac574f7987dd25bf094f1f060bcfc1c88286d8abe86b3e84aa15d09a9126986a1f98230b466fc932b864acb4a3b8b9879d29cc3bb4bff152e30213f0009f40d733392b7893c65c98af8c82e099d9fa7d1afa0a602d7dd88dd66646e799b95f95c9e680878b67c6504ddc0ca7ae81ec8fcab84f53359524983d6fa3f6c2748055613b0d3b756da3d6973344f7e90d6adb137af56ae627d0370569cab2f4a95aea0a79746ec2ae77d7f54142ad4d2196bb0019f53c931d36f4e0f7e8d8c19ec7d3f1206fee929f24da1de6389d156e7ffa20d1dcce7df70d8e0e13df39c40f6ccddbfc503fb309de4097a2678f4184328ef48dffacdeb9e7112c61ccc051882867dc1ce330cee4982f8301379051e3524bb9b84b014b8a4e2cce7a34bcbba8234f97e735128caac72ec921ed95d3720fc634610cf19bf2696822c1dfd07e3cd19c7df68d140c4ba2d9ac467b8877a854be48bf827b477fd0474345cf1b95ea80e014b8d357a30bb4d54f0b0700093e2fa6bd38e2f1e7540d306d0f2ddd35000228bbc6006c98b43da67e290f35c4549b09d4ce98d8be03ac82b298e3adcc520a261b5ab4d867427537b92d1c9b721de2d78cf552f2f9a78371c4b99aed63cc9af57082355f5a6f08c032b9cb114f6443307fc91264fae6d0b6f806ab567d356e48353da495d776fad9fa0dea8005317630f127a53fab2c1b577c82c44c12c73d3e495509ba7733540b99d5a6712a7b346c2df48d74c96056a2bfebdebdd5d060035db7ff2bcbbb3d183b4cebf734e18dbf228095da5d3b36528fbd338f56753eb80fffbb720354c0b0663ad2519317829ab02e8a68825288e6adc2216f5a04644bf63c336d9008ad12d8b482e48ece15d848169fe54566e48757810c264eea5fcb1bb4b1d7835620b7f759609053f2b46f76db82c2966e6495b9d6a016b54d7255608df1766896fbb3fbf7be1d186418e6c5a899040456177aba606a8bb654bf0da118533d253465c81958c25e7282853e4d321c394e74d8db6f4c784b252e963e8d5cb53a0af0b024bb58637e45a2d46d813fb09d593be33a2bbccf3dcacccba7c3d57cfb2752cd08bf786823045a76371254126b54a36f9ed09c5957e83a3b60ca5cd96cff003bbb7cb5b6b8bcc69869899bbaa0d09d451576f9fd7b39670959279b10cd5e78c39e38a26477ea36c5b367081d0844db11b2a9cf497c12dde71922eca5145bec7fb8f79203201d760a0ca3763141a059b4e5cf2091a561e95c41d1a9585bdeb17826becdbe37aade2e531636e6235eed1bbb495d6a84c11f2314d1bbe348b20a30e1463a24cb66130976e320fb8a2d2fb53350ddbb884ab766a3542347d021a1f041807814d5462244326afd5a04ed6d27927094fa8e963ec113f0bd5aedc56e2dc6791282768389510da4d152ca0a327e24cde94fb6d83b03997a04a8c16f5e56a8f3f251a0a51cefba4db353f80314c9e79084219bc2f7d9348f6a7293deefb355ed5bc83e44071c8277381215355a7309b0598d0a9c7bd74782612abd3ae9af4f7d22e859e4a3540b5a36bb007a264b5b1bbcab5a10b44eb7a909499512f0ae818268c15df40dfad189804f5e51e9c981ec148aa0f60f1845f8676f33f4d7a1cde3fd2a25aa560c9de1de879d3b300d9145a6fc4fbf572415aecac54dacb4205058ae647bd371447c584dc412cf50d67335a035fb58faf3a77cbe33fb2426b241dd8baa8cf98539a0e04aa9af836f61dd694f4788c4eba78f14f2c4395ba5aa191c6b876c395d27e420f2576599f607ed1d3369938a26f4cbb752b8bbb6ce777e39b6f5632c36a7625e6164f15ca4dc2d5469859f190ad8273bce9cb4ed725f19c424601c853c6ce085a7c11f5566de1257d9c0a57f62bcc303432624b3aeac33ccaf4254a3926e0f3aa184dc15321c30fa6fd9a67851c93c98cb66573963ba7b25c7fa76caec8ae41fa01c439a71a5a93da557aa18da176847f2f55f6ff70dd2c2285b487956670b83d4d353152b4f216d8a790610d8b37b38d93d723cf1dfa54499773b42a1f3d5e867443fbae04153a180a3745d1a44d70db2d638c37e8d3e391083b73dde8678fa2dfe0e99a2b628dee961c68bc5ff5e1b1db89715ba73e693e6b13b5d1faec523d0fad14331254e9ae3f7a3a291db256d166de0e51b666a78390de33dabfbf1ec31b0302acf3e1aafb1fdf958b9090b4f08300a895651f62a77644550162aad1229685eaf29301c30090f0dc51329facb29e8cf25dc21f503d46898901bcc772eddfbc7b8da1b352a18884fdc74cc87afe8e400318ea72cc432876fa6d0d6cb5080e7174f51c31ac9fa3296f2aa4f0d57de6bae077cc0dc71a304dc84364e98a52d3dfb87f4ee3d99b1a3cafac9d23667819b67c2e20f7df0af2e3e78b61e6f97f4e5ccd1419497316b986024e948d17e8941ab9edd46fd60b46628d3a49ad377ee7ed973eeff502c26661d3d0b94c08ac4b872a6dc9a99e8a3585a45192fc045e458ed63fcb413c83b7eb5909df23f6bf75c3ed24359791903db4355c87596c3413cb31667de4e70d39234e2f751c96d6ba48738a2f29ceec97b1fee7895f87cd672ec90a6dcc9c099583688f937f9b1b783ebb9b79e5f34954929f29e4f563765af9fe2b0e3587dc61926803cf06fcf491f78c9e5184ffa7e3aaf37c81a8d5a20ac24246354f90465cec4b205b4d8b6ef71a9be0b09038cc16b94dfd502bdcd120f533979e060ea1bdaef845d29ea7bbbfc45dafaa485b83f96676ff13e19f934d807a2e031ddd18f3dab370dd3c4247c8186ddf6a4bfd4dff7ca8983b53d53b960597393d6a28bd3dfc36912a57a101b31128f512df1a0433ba77be3912d1446bb9dadc20c287583c72dd63171aaf0301d0131c04ba08a2b4c28986ac2403e6aafa2651ae50e9d86bfbcfa4530fe5dffd520e1fa9949fc482f1a5efeb35ad701f3b9b1bc6d2ba0d5574560ef4e2ccc64cc340b873321b2f3516ef669cd415a165b4df93d96c36016186467216aa8f285e4388be7bc47f8fc768b66fcb80b00c03afc3377ca883875fcea240e29c69bcd683bc6a116b6cedcf70479f0024006d590471f26552dc828f8782488adbe34b64d080644b39924dc818fbfd9bfb164996acd3e4173e6591b9033b098a6691742f12b21fc77dd817ec176b248f2e3b98002e9cd5f60a4a62cc3bc6cd23e5d35383d84c0734d62cd975de5e21b4e5655c026f99f63967eae760b495d5802235508f241f94c2f0951ba8966e8d55d208885f2d817acfea93444a82483d99c48785df309b5063b2355e18f2b036be96209266ac34e148ce578c9867ffac05fc047525dfa2ae50cf33576c538f8d4fc9114f0f25b221b4f55e8f745a02811571c92a4633bb10ca0b3731ed4346f353aca5f86382e3dbff92afd5cb50d6df9968eba230dc4783c114fc7fde2248300793c4c120cc62765bdb53cc3ccc970ba01d848c823e3987f5fa804ab73699a38c911a8fe9ec74846b09bf769968980308eb2daf10e3c2860f1ac07ba5e3e310f641a60bd171a82aec97857651564975eba3b627d5cd1d999ad9448a2ae504fdbb7ffc5f3562e52a2e2ea5e57bf594caa33b60aa0b89786e5efcb7647785c3c742607b114b69f24add9fb0cce7862817fecc05b7a5dc170fbe0b052f50e936f2076aee909f97ad66c35ad2542df8c034747e3781fd5e303568c23daa4f7878b52f4cd0ac1affa1bb0780ba6039c88c38c80cd894f38a6491158439a1ce3876afc4e1981c87b9159191e309ea4473e50bd77627586687e3786ea515fa9592617049f86e89d2682179faa387a2bfaf2e0f11060ba78f8d560c29a9619c7963dfc784b9c5b0389c1d6bb8ecbee30c2939e127410ff132a504bc4f38aa05cd524210652beb7a74992c0385a3984e5f9625f9e2d479ac3234b9e8a29e7274a9e938c2080e8f75e558ef25eaaef7b922a1e61e08674a5bcfce874f1bb0148fa2e42c112cef2ca28d3cc0d90934c6c6669254c84f29eae3210df331b334d969efca8a0d038b13bd0f43249f833c4b88d02cbd37efc8817b84509dc54727c0674c72fefb7d9bef3b76633d297807f862169818dbac4854d3e0198d94325e076fc1d4635126b7583c8f7d6254b19140c08a4fac1e0e24d51cfa0ec02e1301d88972cba28e23dbceef9477452444ee5b64e1e943fc6eee772539bfc17b6961dae155b4fe0ae84e464b876b4a51e707bce15fe9465d0ab3df54e00304d8d224ce96d2604d12d3b9367187a7f7de36d3215b71a6bcbe27249a7d176ae32cca3f2c0ed12e62dc43af0684c24e6fa85c8b1d54ebaafe995d1128383084f036b6954d52c5f730d0ee6aed2c82c1b159dfba5fd0161b40fbcda89694bec304ad53e59f3f3b8c528c8f78f7a1e0acf6409ff331a9fc2e1a87680692cb70d5adb924ac6f3db63eb522d5766e0007aa7d58b9dcc87871952efb8c4b3ca239e65277e5a0b0d83548c09011d4cd379b471c5f10ca66a9e954ee12588440795b1b4c886077b76e4566e1f0f64a1524ebb2ffccbbb76106cab5c8c747a9253357b837926adae08eaaf6c78913d74592705c99b5f8e88a6a82804e5f6576e170dc50e439b521f68ae06e460194ad1aa3fd2d8a8ffe9123f6cc3f63577b29ce83f9d3a7d6af9c5db9011c58330836e3ac409e9365bbe5f2b3d652d0c5526b4162ba4d39052d14ffa1ac8d1e0db7f164b5bdc041c6f0cdef8f41e57f6b1e0b45a6e4bac324a18fb56fadf4d504560068a1de77ceb135965617490d9b270324ee9c45bb755c9515e34dd7835f1c44e3065c91968cd98df5eacd67924d33a69987b5ca126e62ac5ee3ff125a3d7d30217b0ef862244fa3a8d94d1fe51b82e099aa8772917d03de558b7fc7b663b079a3af8dc3bce9ff806d8c725f1b9f7e87945f91bab68e0b4e1c2109de83836644fe20369c30543802525b3758b4a117a33ef6fcf68b71d5f500feb7a7275c00f00e11baf9d55cce865d5d1b0c023361dd4a8159321a5d3b03461ae2371fc91f4c9a45d6e5282da58349856f46199f502adadca8c250dc2459c5ef44b72cd93ef680c4b92fa5ab38d389e9f4a6c467d4aa56379041c145d196e263bd0983543327a87589c183b0167ac68f4b971cb938580d5fb29c725fe49bedc3419807b1c6bb6a3bf622150bba66787ea1533884d832ea28f13389130e964134c8e134b805451442c214c182156ed8dc6c9faa0da1d6d377ccb1a10c175e16857b2aa9079c7aaddb0e97c979e1c51da0a2c761628f71f3180eddecff90d1e8fc718e41a7b428d65e8ee4b52a5902145a0bffc701b735b044fd82a2c34ecf59d2fee73477e45dd9168c0c9302e417f3344a521aa50a036660195aa0b5e527c1f593e0e2c4730ed7f6d0a32ace57451be21e0177928e0729b733dbc9db1133aa909f7a0cbe30b9a138800fa999309c817ba378ea765112729248f55e2848ab7be2b9c44b2e4fc780cfc07d15e09bfcb5cec18ac388a6e8e3e07348fdc44c0ebfbd5800f0e49e1b45d9387ce24a1f0fa4fc52f0f50ee42e77f3c11e98a458cea24a2c7e7a71da98bf356bbbef130aafb7dc4234adeb4dcfbe3d6bcfa30cbce73cf7d0d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
