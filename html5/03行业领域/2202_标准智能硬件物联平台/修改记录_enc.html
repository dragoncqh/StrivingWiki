<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77db88f1b2ffe983e09680385edf6973e36b2c5c871e9cb9c4948bc1321e29661cf5417537514ad173294f0788dc4f8248ab815187e7122864a3541c7be14a0ea703348ca23bfbf419445a80786c07e8a2d165067eee12920f7082558cfa52c41b4ebb800c8cc3f60e43af2d7b86a42ad4211b646d1c6f22d9225f5cb958a2c11385f4ce542514ee4ee2600277da2df0d9f5bcaef0e47836133d4cdca4ef73d47a7b02f7c34f245d25665807e5817b6cb524169b6d30bd9289e8818d373b61d17e757a6a5154b49086353aa31fe093a45f474438de6ccb34c84fa224839be4cf8fa83d136ece4037623f03c62414cddcd86976cad60f838ac33c29257ef24b62414ff0d8ce205c7c35fff8ed20dc11a08f0b04ab9d9db47a62e336e5ea2bb83c0215b1bcdf125f141c1b2dd9c2a2479df2e77c7a9b85f6a90ca77979492dad136f8db7029b3eee8eddde13205967c0624888f7f15e8ea9ada30f825fb72f06ad577282a9f4ba04e54c773d552bd5c2ab7f7eb663486ba1403909902b5f2b56a3488bf63c89e217744e1fc0ff07806c217fab3eb3422211a2c8fe69778573f8290cf265f84ea80d8895958b6e5fa7f4be8ca3de91095107e166ac8a02f02dea00ce929f94b405add1987c389ac62a949c0645a84490fd8179a5bd73856a7e5866afdea198e063f8cc7707dfd2dc13523c338c5b8b32ee41b3ea04cbface41fc5bd67ecacc4e0dcb676489be711881c39a47f1ef63d123793f41252d633309ec3ab70c880a79aceff8f29c06388a0fe33882f8de88928098fa9939443eb59f7d2c7db47b1c19ca8485cfb27c63c0f40b7fe99c6d856168f74aca1691a707a1f23535a24da372e99d3b86cb6df48024ec5e0ad3db8fe3834c9ba2480a098cce8f7d3bf62f611b857465d802ab6536364bea501dae4bb9f51b7949a23821d71c70f0f180fef34e16a1efaf77d8384c96ccbeddf76bc8de16ea862e07665904402d507fd88deed1afdcf57418a0b915cbe8de367ebf5ab9369e45726ac44f843bc906656ec2a3fb897b61d6fe2866962c4b4922044a527d3f86b2d2d1d3d2ad26bb1eda5bdb1c8d7362edebc6d4165c9e846fc97fad7ca77b26e7a96c0fd071bde78c9e252b5bcca8ce8b85d4309b6d74c8df06b87a23de65690e2cc665fb0d56f665bc3b0e4c195963a2cf6e434b3143f4b509b72c64b49c873d77b1a6e5aad42436e6395fa760d7983cd3c47aa3d6d126017bffb7e4d922479e4f5f8887db1dd9e28ebbe912dbec9df6b484ccad3f5deb47a4d278eac3a482b9159ef6d6972446cd80a6101ff82bc33faa89b986c379e2492e70ed4bb14ae672eba46b8be5f506635afeef80ddcd6c205dd429a9ab1f8972c49c8f513653aa8fd6ebaecfd57368789c923d6edc557fba71754229bce8671ac4a626de13076959a2db7ba46b90426c0108159c295bc326d5cfe3b37606c3f162b1ca4131a3187e5e962113a663b379fb5a70d5d3653af4b8c7e25e2f7bba97a7aa3285030d9d932ee3eeb1d0105918f00191dcd20d6338f4a0fe5e6ebb37f083949be4d9b2a57b262c8277889314be4806416ca78dbee64cd34fb9e330f5afb1e0cd8a9fe1beb3bd2b13073a171bae3fcefaf9e09eea341d5ff448a768be0e37cfbf237aaad67864dc89fb0c3c609bdb3a623388b2fe3ff6f2b69facc6f185358d9acc3f1bf3cb8536f1c5bc94cde21537d509eb9807b7778045ceafdc0d42dbfcb6d4ede0e23bc737866affbf98099cf366fd7dc81e51ae8a6619908e8b7baa7bf4661e141cf4efe819e2cc42d9278b58f6b392160d33a86c25f7dcc63c177d4aea511a5d919b5e772416b5f16d9e51c35842465d6d52577cd76c29d682c5093b905db59798e55e3c799c2b2cee2413e5730857a75cd74d5e3cde42a15c74ce59f568e7b05fae68b034d5037b3f005fb0a8d4fb661b775da6f384e62583b01bea3895847b69913c4f61aba800d99ab7c46e9cba3e89584f491d94fb3a3e7338d336a9c177b51314170eb1357ad4b5c6cdfb65cdb16c780c8463a7acfb83fb56a1161e0fd8f3dfd4321d9f91e45337b575761d63fcd4b8ea4476203129c7035618fecb912eb626ede3873938652699b120e5fbd8632c330411851b14d92328426315290d47c0d29f081e1516897e84641978b0b1929058d7cf5147c2379956925d2feb4ffcb63e348825ddc3755c676067b16a7f1b21472320e5970f9d463fc2f94304a933145d29b477e494a74a99832fc26dd5fff877d5240db46d0e23376bf62ba949e241c29ac1eef9319d44b5f790c82445efd00a425a24a2860daa06b522fe28456b8526dae800d3bab5140267185b6131d520babc58259efce377e2a55ebe7fdaaa9929b0dfec1a88fc0438ab9e0b9124f22557ea2dde1a35eb281f0374faefc4040abdfac0e8fddb9f77c6311d61c98e5a8f83bff13c7833fa20a25778f6e1a37d7272c05561d74aabb1f25692fcc4763cddf881a815b1add74b0a592d96c0293ad3ecd49638d14b35b8c29e866e483c9ddef6d09006fb06db67175cdc23204908e05a5a2a8dd832c4ccabac92dcad7b1cd733ba7e4cf250c25cef1d7a09368a7f027e8091b1c53598832111bbd8f567854306b547a9fb81cdf0525722c5514db884c2a875cef36dc12dc1c5dc486973a50ba74b49db8f7fd2f8607817c7235ae242e01f9bebe20d72ee93b419fbcfd918a24b6fa19bf323d0941eebff34e273d528bf3439b844b9900b2840c745078bd875abbfec141f59300765f813a6af26a1da9a169f31bd4a459ec653c9e956f80d7f8dcbc4b83d90766afd67a10039154d49e4b3efce665ad718dfcfcb2b1fc0ccd8290b9e81d6e6f5ea9570d159b76f3dd31f2f1ed5f92ba86d0411e68d3f4f4c27680e15e389bf34b4582c55949a6ea1da7b17ea18d0a12b8ae56fd1eb79deab842b7f013550d4e5b0dd7e4afd72f9f97fde0032da16031fcb6c4a95aabd7aeaa25ae8a60aca4bac5da5a2ba44100d83a00d6b47113367b04d37a7fc17e3e6d4411588cb8d1e999307e6f9003405e59b7b23dd90126c6fbd6e1957dd3edee95a89fae5f59899ac9d557049a39bedebe702691009c338bc5be1bd946a2023d4dd5acd16df0a236ead4c97029d26e1dff99d5d30e5d4ebdf42ff83bb827cb3b511252954a2f5f0ec5eb760684514f9fb1b966640e6f0405cda157ffcb01ca8f7a11db57bc63b33934f3de3f3189a5a10e6a0a99b9ba8c37c1674a364a10b776387fb415ec70f39b18393953337ce29e8d4f55d118e0aabdb770170ea69833a887fdd3b580ae0135153f57da5f75a01729104a12a3bd73614062a94fc8f79775c5c0b62d766416739ee1c27648cea7669f26654ffcb161756f773131c77f701aaa5af081d5c24f918890dd78e7ecd539647ca7e4c62def97cabda55724fb8c94368a32508d50323bf92dcf7bb565354a2e5fa8c7b42c84747e02315d11a2815e8c08e41d3ef119f1a42eeb87495d57b7cd7dfaeffc67d48d7d22b13f8426d32e11e944c28bd8eba621b13ce584ec148821b1a9a0ab705d302dd44e5c41ec9f98288a9342a17000037a43b840008d0abbe4eec22deb541c2eb8791e070180efa4cf93c76044498910cb024a5bf56e30d2a25ec57f185722c9981a2ad6ac11769df6b5d27c6367f6c259ebc45b2438d24819860f4c98ecee012f4657e504293d2c1e4895c2d21b3743d3fda3e5da53f4435ea1427c868749b841cf2f69917a43fab773106a03791680184faa27d31a0bad1b12f9de323f3ff548a9a7a17b20091cba70e6ed12b935c173d04554a2461996a8a25b8ba47c645e76869084a1ec059845a8c6fcd402c999395d97ce942fee10ff36e3371a71f0936fcadf912f6d0a6a2b531a86573a1d1d36fbd72463193e9c039a05e57c41f8302cfd4c8a034840db4279718d5481f34c73b25d1e264b555947cd303b5ae7ef3755e3a5edee7fde8b6c5db99986de6508aa2d4ea4cf3ec61300160ea96fbe67fd951557d8152433b0c2f1bdc88bb7f620a6b4772cf5210a2ce77e9909dbb2bd500eb52231cce9a7ef825668a414174fe7819a6048ca36f34fbd62d25284f8b1a41caa45e6a8e7909260f52ea32c8c3b1b1c55305bd9527d450fb2c8297dab06b983fff1fb05be641b85ae2011d5f17773fd8b20790dfd9f754201379d9eeef986fee32bde1c562e6cd44b4336b1dd15b38397f0fa771921126e64f8efb7d902650628557dd7bfbc2c2699e116800015f406ee7165c7942a2ea41186435d46713c9706ba64bf7111814d7b4636fab829c4e91e986d7a7e0aa97e81bb4ac7e4bece6bcee0e6857cb2f2a8d5109529f42f32edbe4e48ccf0b99d3ce163a929f6ba6f1793a9cd6ecb1288888d8e93955939f21c23a8072c6f24ea2f552b9e0b0822395ae6fc1e6e9e8da44c5a1f497053fb33fcb09f5b248f7db0000ea87f541b1cfa101bb48ea5235263ea089f8f0e7c3f380a21292e953de70ff070e1ab1196a1d685914424acf7675488287f4a2041fb92e44f0f6850cb1f53121a1e2fba2c463f11e2bbf53eccd7b9fa811ad3a236875159ad8670d3f5218cecea51aae12bc2a633e3d16f2d6b2399f73408c95c800cfcf132562ac3262150d5d78e94d58ebdb3405ac3a88bf30c29b3dc5571c5bc0b3862ec057983ae37f25c8b212b6becbaadf71d86edfafe196f38c21ce51930be8a86dd5b807e795b4f82e8c823ce52fd5d8a197a9e9c66ee3bda833d483b7226d12e4ca8b053d3c8256436ecbb20eaa401f07ccc87fa40519b9193fbef6b6e27d53ca26f3e7e56cfef77fe5d16f46be95288f1e56caf53ebc1ffa59e14cd13e87aef2228ac69b3714836f91d9649c5a1d874fd2895c1a68923fd752a4acfa31c74a69233426809bb6d677d8dde1581f3cd40d45d522103afb553408e273ab416d3f256426538e17cd0c56d64300910878604b65927a331573b8e107e05175f8a786a832a50e8717d21260b163b4468f142fddd964a30f3e6b643b2917fb951c1e00198752ef1e113a41912313d0419111d5b9357169c0e9f69072e26cfa7186b79e83a12be692a7148d65cfbb9e4dc06d8acfa3068fa622192b6d170ef482f177a545f0006385bea27331cd946c5251887d9c6dd3bc274343433801f93919f7b0148ad780f96013cad0dc59d23ce5e7a674d76f974cfdf89ca20e4e44906276bd6178d9ce533635a834829fd213b2098969b397c4c074000a292e8317334bdac9f45f1b72f21096a9f5a75f40c213a5f045e4454a978c9fc59ea050c4d427e9aece41bedb7259cebfdecd9878cbaef4f6d5b99264542d74771ba2c621b5347e8388b2fb65b71970e5e2d6fc4893da2bae0663fa0cd774bdff17a6b5362e71539ad11fcef1f8e1585a94760a77ab2f627c04a36c61d9acbf5ead8f38f6081c64e158be46dcba4d6d40d6793b749840662b3a05f8b97fb604ef2b0f9292823da503641189443ebdc0a989d7d334de0a0dd93bc236bcfcc479d24ecd4f86d69540ee194bc8c28194c3f1b88cd9dbab88d1ddfa1966428167d4aed8758c5b5663b4b74bdbef884147e3173bf725cc0d16035fbd4c2412c8298e03b3ba805f61a5ffd74868be8e72a6a920c81c5d5f9582fa6673fa2f60841911c3220823bcf413a6bda13ddb9d1fb69f08cc94ecce4c97fda597788695873d47080f6290ea018da9ad86f8f65df1188e2965c445a897027aeeb022813ddbf708c8e69a592f3aa038ba094b99fc9d8bcc16f29d58f7d1df28fbee8856262f30c3eb5a0e3b8271331384e74a18f96c9b6cc91b3719794484ff808386a1593cc7cbba7326d8ff5acf0f1a148d1f253497c683c67b4eedb12436dd577f4657118a04d3fe61108c37b4758fe9805947e040dd33b3640259ed19a83c9d5aacad2023e94f8dc5124cc9714f2919c78300c018844053207401e6af8318033ea0ce182d4a27e7bcb1517db61a533c00b4ba80a6ca742959180d8401aae72b9cfb9c6d2a6ebbe957bbc491e64cf260dfb71373771eb687027c18512cc747dc682cfc029a7e309cbfa868ddb65fdd93369f51b8370d607625cfa00cd55fead1bc57838504fd91d42b0db8b9afb3e6c8d6a0c3a93765f4c9b2c27f3b4d0c608bbc807ecd2a215bd606c1c51cf532efa8b9957b70ed9aff8a8f0016bd940e9f5e612c40b305024460d6231f8b02e2b52d6d06204cae6ccc37a6da1f7567ad503d4bcd161523d722e34b1268053f42a5397430af3a143852e745999072bb7bbfab86a6bb603bd1655c5391078a6fd7bd0789b42fc4e784b2b0b17d115856a41a3b21419b39e34b64598e99edb7c1078324775e92eb158a7916d272e77fb668f3d0f8c8df5ac7b7b0bf31252daf5c1c5446a3996e525a06c9bd80ee34e85bae286ef07195fb3705ae5654e08409826ddef2c651bc7507caf718b2cf921af62f5e3bd1b50abe62f69cabbd251bbc7efe257f807da8a0951f25974615a62bf35d62d660b2f6bf99b3a96c2a3284b58734ab80abc70d305e5a799a24dadf0fbd6a99ac4b06c5facc9c309c5a7bda3d80daaef135f4c2274d3cf7a8088bf4db0bf160d58bfbb94dca1919827cc58dd085535e9fb4fa402c3ae235db6fc942760f21344616581c8fa716e8a1a39bf0bac18ff45707a3fd93fc0b5fb635098784ac1b215a746c325ce10826aa13eec6c2e37e67433b453307c160d4af15682cb072ab44302917f68516a1992facb7a8e5a39f743a89328e79b881337aa9504945dc72af94c4f54a25bffbca56a98bfb2ba55c4d776ceacab58d3ae368d1ddf3c08b7a8e902566fa75c1ade8b44744c50f04b5a2fab4199263d5ebea15bbaa56adad9136e93cd38fb66794ce552bee427d32171faec751d260952c46e949530ad3733cec6fe8402397e8b6e5d988e0cf4358a5ae55cfea987abe2997bc461339facecf0e991b0c90e39a41c5ef29d25a5eb71b9ed0505eea87ffaf60eb353196309ecc0719bbeba12f96bc763a964232cad35fdd22c85f4d578ee7ddd633ab8379025759d851efc8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
