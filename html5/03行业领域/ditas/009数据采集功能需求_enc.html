<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4dab5965e2de2f5fb35f16f9209db32f12643f6ebc26265d7b5af1af5021a2f19fef6f0139b8d3d470e82633995f334fa91ff742da07ae3906bc134f7a7ec153705fdac8b5500a5bcdb17948649c5aa9cdeab75ddd56562acea42b5533b367aef6a7336254d2616d8f1dd49febad401fd485e6fa05e2730d0e88aac5472fe614a24f8cd605de9344c5e58d5b0077c6a36e26878b6928c07efaa0dccec46af72b18e72300b0a4b3a54f420e3a6ef050c87a528f605768d61a921603a4d4380e13f2f11839107c58aad087dff6bb7ade6c29c287cf685c47096838546bd7a2d9d5478d4b13a917577f7bc05f82c48cd2f3f99b9e0870c60014ec9152ccdc26e4d72e29746d03c4ba56e903414aa96b55efa089043c7ba92f4f0057f56153a6e9bfb63b752a64ebe82b65be827ea9c2b93a09b217bc0a5777ad3ac870e4e44189d161e559a8e6e162a68b419aa3723bde53996184c308459c3d1f168cc2177eb6024d4cde46139ed89c2f2fdd997ca75b1619b87854630d02077713472c64bfb5a5b8e99da951a0e81fa5c6f88038df6d37516120336654e058dcbce2abc6303287af03dd8742f71eb05833fec4907d8253dbfe3532cbd06f7f9d798f1a28c02251a83f351e7218bbd1de093eee09db36ed906337789e76cf641eab5b4252140e94a314d75ba723a9ba5baf919b8caf9460d464ab0549e96cfb4aa9d4067c92cd9cdcd29a85da0e297a836ca1f14d34dfc722fb946404584e5d947b1102afba3849b842c1e5f4f134f624ac4fe0b390e431d05ee939fb53a6ce962f111abeb16223903b4da58e84a694d015ad1540fb12189bdea10fd193e6df486f2e2af1846be9ee749f67cb6244df1db42491a1e618d82c86398700d5abd6cc9d342cc904749aa8d6bfba43ba8498f8bff67bfa5517cc4a8bc1de039b005638e929ffa87b3f6f463c77b96a96e305f806477eff775fbe3a5b220cfaeb0cebbfe7c22d4a1a7d029867789e0d1b364db846f21a0126fc2a0bbd0e20c0a50238bfbc93ace21cde955fa69e392501adf27d22b24284bac4a594374c53d59ccb91d56333472877d9f8b75f1d5d0d1df725a0f08977693241e6beaf062c9658e4c9c9385aa9fe9dc29c39b6c5ad02d20f96635f25b6e5b6fffa37c93075c96e3ef807bdf8fc889cbfb97c008eb03c4bfd110f43ff9f03315fbe6306087a67212752074b90ed90ebfda7fe83f29e8da40b0dc08181077b9612d83d2df4c201e14736b92e591a8431ba682a642f646e1d7c0f3c5ed58b039b55c57fbcd2994cd9da90ef7009d0da8adbd0dc78f48336b89030381622567d7d8233c337e7a61f14071369f9a2bac1d08b674b3ce8428232748c9d19153fea85c3cfa995006069dfc991eae8f83c01c86a36ddb0aa2d7fdf3df5e0824b188252691bd4da9e03a85475aa8d2c9c629f52af468e9c1f9b33c78e582530a38c513b88cefcec686fa60220274e83f3d0017ac16e06d00d2375ec495156b36419732d80c942b2ffc4b30426b92cc50b25e34727414a595ef7bc8a9eaf861e1683deb8472a22df465b4eec9162618f2aa4f6d9671275dde1bed3b14da9d576353b34db52d784a7751984e4a84278d2379f03b4746eebef8408c9a5ac0d5b5f73cefbbb42dc976706b5d57d0bb4f7b9ad8e256269428da82f2b0dd1c95ba8fc9c8d20c98a7e1611a38990e51c07fa0faca04a1f9b8f957feaaef71ee8c380cfd273401fca215c4421a780bfc174b622905ce23e6ffe87017aace497b600dcfae6283d6ef58987f0d64401e15e7010a025c38abb8b687458be654c89c7c6793ee189a918433bcacc6c2b81784717570a39e46853cf31cc784139ef2c661c7a6effac6d2c25d88f3dd7acc0f467636ce06b2860908895203332768b8cf7ba2292f4640122dc305e1f911ad45e1f6975fd4000b4988e275f663a353b0de7cfaa0b0860a7b85ab80539378b5115c9dd101a42f2a8e3ca6ea24ca117626342df93b323708b22be9a650a15c0b398dfe38659f8f9fbc60dcc59c1ae27dd2441a9613ef34f86bd9dd7b374d6f9a2bcb3eb732d2612194a018c45075e443dcb4c3434bd2a564ed6a227f3906387553e416109edb598e10134d351679c50bb27610e205225fa869d6e569c690ebec6ac6fa2ad9c2b20235cd0a983e2568b076f18f0d6691ad533e9f0f7f9027c959afe114bdb62cb365d6c43f6369188b87a285f140039480be6b39f36885d22755251eafecfd65d8767b849972dcc18a32b50d9565decb42cc6e1c681b98d4e2d6d6240029114fb5a758d9155207e415e2bf741b63c9b1d79ff74a5b7ee0b1590f6c2f9aa09e1a40c3cf7a6140a85903903602beb0c59085d5175a0fc40e1aee21fbf65475a3977335d5254d77b9559bc376dc93b4b5f172ae456070dbfcb5adff3338172cf478dc6f8739f312aae12304cda21992efcbbd75fc04434078f62a53cd3afcfbc207333675fb66431b65bd3f073cc9980702f919c5de1f7e03e4dd646187a98c8ab241e9054abf239e1ce0ebcff389ba1f09eb512486eec01d1a4daa043788229850d58d3fb95df4f59df49d638249ddba194b09ba10cfc5c635eb7c74d7ce4fcc1e90add45b6c4dc1ebec83a1ab36e2765b4ec4886fc4d9bedc3246a27c826c094ec48cb6c202a0f96b9063163d965005b742872026453e3932baa442e7f71f121cbf48be429e942b75085cd5ce8096d9d2279dfff39de663306e445ec24d24ac965e01cf7b2dd07abb91bd279b7d43aac413394cbd8afabcf8bf694ed219775f9a95595835775c51078a45eeba25ada7625422dd607cf454b77297cb9407e78630c0de8d736e6abe18b73c074b000ff2e3f13cfb35aa9fc481a0eecc0afb26d211d6ad02c271dca5845b8374a81ccfd0dae51d4d63dcd78ced5f80b1a23794e81af00fd6e9758e5a764901b6b0e7e3df1863fd7f2864f158c5edd34f0a9f2ebd3475f50799584862af188e0be7c3a23a6c60e564d79676b2566e8a4c1280b17f7d41ebfb7a2597641cdb9153c6975f02d6d3dedad4ffa88e7213e8f2c99d734b04fff235559db677e228a4898cfbe03bf9f4d707fd78de6319e5878facb6e284c546bb0b6020a876b97e7ecce4e2bf54f1a793b5540eb63697380ac092dcfa31ca0a0fb4b0d861c063db55f72231da496e5190f76bbd8e0c0999ea65d68ec75b88d334d240bec5abbbb80594ce21df841ce8b3f8ade9bff275d97146c89f9157b376169943e66458498b7bdf095b8f47b4999ed7d75fa6455e116d7fe655340967b44de3fd47c3b513212a3b20feec4d4e91b127e44ea1b9ff082eb0bbced28631397fae5d7559349087a4ba3ad6cefcccc64fee137a738ff9d971718668aa9bb2f947f2170d006fa808a65d11c640482e4e9545aec4517d8fdbfc33d09cf9633d75a9c5c52cb4320e2db2fcb20f3ed4d788a4a69eb8e6f06a37e5406ac49346247d43c2069fdcd8fe66cb1eb63dfe882d89d26c9b7ee83b68d7207e521af69022061aaaeb9495fb458a36596503f66718d6f10b460edb7b116cd1a17f14315cb2915662c025ae231e590611ac96d4d1af8e45401ef936d3e4a9e878b0083bc527f94bd00d034ebece54ce5e6bfd22eff4c71d2b56c6b56020b87349382ceb7dfa36da99286dcf241214e813f9fb9f3b5b3a2fdd6b3409ed36d6301aa0a0ba6e68c430ab9a11be91d551ab7524fa11275f62ffcb5a7b98e4175f7e32827e19ebc65b1cb680d266748ae8c99596b5205bf01b95b5d377094f4feb456d205f1c2015632f7df2edc925c809de3e8335941af6f6efbe8a036ad7419c9668c6b4a2d516580b73b08bfef227dd3fcbe0d57af3a03e3deec3ac8c674d0a5d784a4eb67fa5b846bbcbe803bb429b566a5c399d86cad5b8ff3439fd8f1a63bf619a9894149ea7f426156ac2335af16f39aa3e7bb87697c2c593b9d792509a9c3f689924a3a20e85887f2b4f86638ae2aa7befa1b076e9a89b87ad2ce4ee085cb4352b1d23ba75708915322f8269cf3ccc8fa6f0906875ba64cc690d04ded7ca1a9509caa4a4d9ec61bf86d169fff175cd79e44feefc2327c9de057381f0a3f9937bfed3e2f93cf5aa04b2ace21d8d5aad01954cca426a16b1f377026a91720b38fbd32ade4b5b6b49438251fb200db79f80c5dfe611467a1a296006a863e6050b2328aa6a266054836ac3bd3b5a72b9beb711aef802d2a02e7ebd88f92f5dab5441414566a76452df1f1e1daf6dfa2724019abcb6d840ed74b66e319eb7306b7e39d9d18a89c222111b2c060acb07e45270d19e8bc4dab07caa733bf38d10db99ec4dd7bbdfc8f9f3dc53268f50f1df48f3c05828cf71d8173d6b424af619ebf04b934d1d8fd8172d4e896d778022fc0d6f3c1203c1087685e35123adb4a1446e9e4fbaa8c2a8842352b7e4f19dbea7bb00e406a4f2e06d00733f3cd95379310e2ad5a3bab824f3b2247a3ae6d48f59028f4de6c7a80b2ac614164c678d8ddb9aadf4bfaf80ba007a833966ce78bdc05d2a843569cfa0a37569862f50437a66f42f0c2bf8f00f169b127a676fc9f1da821b05498d9dfaf37bd2e29fd1750d8adb4f7a2ad6871056a536b48ecf5fcb34d1cebe9d144423524e7d4938a61cb6da84adf662d52952ead67970acd7aca89c491f4c9a16643a6287a28e90d6e44fd8679bc543b65c0c9e9c8c18521f01dc8c4553d9293e23bfb7fb9372cee5810e797ad019aaaff766539a9ab9cccb149245d89a2436a69fbfcced90618f7968b01d09703bbe05e0d15c3bbd1aef951e3d4e278ce31f2e49a7f393e6ec40ae7e4d81368f67b9ea44eed8144b23f70ec6afe3baab90c05e24cd1696e0def1cb1dd2e90241d01991bdea499fabdba598474f0e06d46de13ef5aec9badb19a709ceabfbbed9b2c5be45ad82cd23b72a0c788b66522cb893f303490769172d997ce4b6dee7f4ce2eb23c40b4a3786686c883686cf44fdecd6ee84856b284d5fa5d02c7703efbf16df02d0e7ecb8b98d41fefdc6594228a85f0f8b832f7109a1baecda3719c59cf932141d24cc2ad0fb755f5abe38223e3ab46cb364f5a08dd6739a442841bbe612f0487011d54bb2bb4fa8e58d25bcb254b98ffe824debb19e51f2545d9bc4132c0aa50824b4bb5627cbad036dc2e20d2e4b4e6274f3a11d379ce79c189623ae6d15c139ca7b0c67a266814cead4ad476d12de3e7f2ed7a0a0859da497b0037be1de8960201a67a297390bd1252c9826d1ebe683725e8ddd02eba6a10320fba7ed1e3a89308e19579f17005c7cc82d85408f6271adc5e4a64628093ff808528f968b4548c85299e6ccdc62046f1f110edc7a2ce36ec8b539a0d9dffb310726f367114e975d7ae69a326b74e24cc9202b671f2f0a901cd59f62ab68bfc1c7e80e65ea5690045dc84188e1bc58e339af2773348023396c1992ed2980116a52ef823acb977771a9830c289ad3f789672f22fe1d9ea8bfacaa0b6f7a351d3fdde1571db9d1d39b25c6966662ae878763d3533e5108fc6a9e3081c9b6dd12af814de42e7cdb722bf18ff50852add84118008a557ac4b3881d5fee1ad2c3981bfb2c3b02215540d68ed7a92d6ce5da63f98d8852e8ca2d4e18a8bb37e6827b1d32ffcf63b44691bd4991f1d02eee42a5890d6220f1532d756033c61e90af77f743dda14c42d1e9118eda9d6352281284b91d3fbc7daf7780524598d5fe0b5ee903d24c0022d2987158706fa99f0ad909ee9fd99f6772a58952f288eb17d548b91a0047be112c8664540139155eab8eff4e43ac78b678a5fccd6f74535852e72a81924af2867c44be8a18bc676306b54bf60e2f96f4fed8ff469bc3576bdac6cf08c8f140106e2914826e70deaed0d669a2da4161c90a5838f5a72715e89d8c9b1bfe8936628e85c08a3a3c07baba548391a264ee1504e41f5eb31ad265b904fee6b82f602d8d3825f0af11631c0c53d1913caac24b53e5a247a6a45b5966165d9f1d7c090eb3dc57f0f89f8d3110f97b7e0982adac0f43868d6a8ca886f4f41bf054a60b5ac38d7fb9354bf4353857f842a1ac13b5b3e76a7a4f6e8eaa5bafa39d54560ccad41411dfeef0e8f78f76ed051cf76f1c6cac9b358ea20255a2c58d40f76856403cddd9d545fb5e9edafca70e236dc831077e5ae19f31739cab88d4f1d8c16751bdbf4bc2b2bcd9b1b8a800245d47e4ca3cde6ef4c0cad071abdec10e4b47c0be4138c78ce42d53124ffed7c162d2829da6f95f93281e074c4fcacef72329a6d038de3e439549495cea8d9d40574b1d9dd02a465994f53327ba038bb5d96c3ce9f530cf52c0223d83cfff316214caf4e62bd50faaecffa8733af8c08297aca8ec2d179e17a4ad9461d341a5a6c1ebde92794c1332d665ae51709e4e060c9b46c763895b46a494164bce8a9ff9c40640f31c9e6a6fd03501149790f037879309b2525a5a4f90c850133a58fb0cdceaaaf8e284618d29659cee9c66c544ac484ffa489f868a8fd4577af6b8cfd01275469d6addd46637b5df05fc022d265e6b241131fa27c199889bde130328ab61529cd19060cb2aa30989be1825fdd765eeb2812a619daf9ed46fcb7dfa17fdbb0970f5f6a8276aaf385612d67732d480bdaca30aaaee1e395c90e16294c1727155eeb08e03b050823373f51628a59d0c82f6ff62cbbebe607717101c65d49f6c5b7583ee2d9b84e1ebaed55c6b83004445039dc6b69c77a336f544c0a57a38d9ec5cb93e86d4c3a5ebc8830570d3008017c8dac3011b962d64c01e4ded1a374f6eaaabe2837a7975fe7547a6722c098523b8816ffaa5698295a48118c0a08a8ea913a4fa4de05689f1197df9a80dd8af77319f3056ef9e969b9a076d7ff3fffb3909a1555a87747706c2ac03a54821a83a79f2fc314ccaf00091da95f54224d9d5eabba125fb1eacbf921f3865e8030303bc6962ce19999051e6070e3917242808548e94f34f72838bb016327b0c9be8d05bd92357eb05b515aca149ed766e5ae3506b899f74eee660eb97222f4da932e215dcec0839967bb8eff0133b0190e392828de801412fa6de05ae673053e793b3251b4d750b28a1b38d65c9d4cf92a70f1e3f77e87f3012074b5f2650316e2e01c00e83ae494908a5da7888356d9e4408eed978e4c83f6cddb68018567640e5a054a7062894a696dbc363f6da0abd9d0aefb4ab428bcfde72b241ed385abede2d1e605cfc81dc9beb7e048f833f47fa7d44727d08a76479000dec49fcac08bad91b308558fda4f389ac626b26ba30cf21ceae881bf50af8648b452c9cb9b5ab31fef394fb23811d7e6b82da81f68e72f0b6b5fb0af4e3b490417ab0492ca6042dc69b5a8d825415949668a3e98117e3581a28aa04e4b3802c70b445a16767a4c6f21b3ef2358f786e7f14f892ae4c4b4ccd7f1a54211cff37407903b13a9ca5e760691cc39e30ddc2b6b970bce65e24e4227b8d5ec6f6582ef264513f60203754e082af484e1c3f37970aba8500130925d1b7a3947d930ece064c7076bfebe84a89e06426b15699aeb46ce1ba563eafec05f6c0636db1281ec764dfe2f3ffb25b9b068f5c938e22be1574834c59e009ab92ea9477788230b05217e1b11b22720272f6a46a929822d2f36a0df9fbc895da0c8945a22cc548c44705720b0cb2e88b04036486a9588a1b914089ca0d2cfa86aef8718e7e8b19f011d4262cefc736d31cf38adf41eb3791938dc07bb3223645d5dadf13e3b0baad670a51a86b6d9f5b01bb1008ab387d11b0323934afa668d31d8dfdc5c6b62a6dd6d3f268f4b7bb34e42a1baf45d9b30f2527fff0c77d41236146f860086faeccaafd25fd4cb1671262b3bd0e22a983529273f216e902856a80e15538fc3c6b2b1dc05bb054a5c5be7ff6dde4851f906f73682a499047cdad1dc54e5ba5bc06c804612ac0c11de82a7d8fc921f38ef753d2ed4f8017e319c6e8784e0b43bb83319a4909caf086bba153257840ff1f42193206e82b0e8877635009e5b7fc28418171022163e8fe0796aacd7b5195bb2778b3586787019d10bcf51ffb3b56da0c964873fc169901182f2cb41635f73457ecd828a095039208538f983680c88885e02d9118525bca0f4bf1a2e1d06adf48336802e96b7926998777a373957d5b60afcdec30ce1e24fd8488e2751c74804f13fcf1ebc6e02e45198b0e29deb401741d5b749865d2e762a06be637f1793a0a6abf505c3d8a94d32091cc211ca837f8c9e1d562941425d79a3db11b5fad2c087b6f687ce6847896a5a4387bc8a1fa9856ad5e9fb0f85d208e1d452a49583ccd12c82c3a409fe60eb6dd3dc9b52eee919cc7b09e80dfadab3d51d0bd71946dd64c33dee979696becb00a655ef38efb3c8b3749e9259f650abf9072a8d5f8b3d2e6289ebba2e26fe3cf774fbb5d6a4540757d9265e455e007e6244adce62ff61242f369b4cec22a7a3d271e402fb009f49a0127757c4622fb57bd01cc24695a0c594b83af17b4f473fa78a66b7dff6170b24b92df5ff867f5f4bf2ddd925271d9fe7af4fa279b6a733cb64ebb908334df1b59e60437cd6b0d920e63e2513b2507a3b4dc7457e3ab57bcd9641e3ad72be308160cea61ce042e9e4c76e42b7c5405948cbe9b2cb0c080a6ada53b6300950d3051ccb3b41b6d7935f81fc6095480dc98e5c4c5db930cf1946b6d4b24a4b1bd5866f515bf49f97e5c3ec27f3c113c4f8222bd2cf1ef3e642c5c0c9ef069cd2ef167","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
