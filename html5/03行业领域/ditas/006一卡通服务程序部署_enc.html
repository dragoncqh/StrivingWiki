<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25d18806a540208ce4ab915eca341ea1e2982874e325d058564d3a94ac099e29b2ee0955809994dc721829c7bdb1a52ba8cadb1138bd423d2dad225f26495f52dd9f850649458bfb10426602c845a3531b737a4fd9d525852fdeaed2c2e89cab2c00c6a4c7f8bcb42139dec3cbd082eac2e51a9bacd439459fe4cfbe888c7927950ed8f2755f5b5c0d4d79ba65c2e81089ac91f14be5a6119a0893da0e1ae7ac58e99db85c04b7ea80452d976efd6d6f1df1150a3bbb209748c362b83cea1a45a35ae9650af4308c3a8ced456803a0658a75dfbb14bdb045b393f64850c1410b31b33066ac011b1c350efca5d70cdbad1fee0abaf8dd3a04b0f385a75db49d6f1ccfedecc03b445514462a4d35a163e4be94642d63cc9be1d6f7fc79d9fd34813c4042bff7040ec540e246bedace776ef48ee87d8757580f2ed80747b751c7cabbfdd1d559fd0c463761352cbe4104bdcb8c331d01a1c19fcde307887b11ebc9b50c2727e78af65e74c068c58576e3b6b7d5ee5ec8cd4ce0abda9e1df3cbebc1d330e834980c6e5989557865228cc89b00c01d58683a929c2809e508d2282160718ea29646825baf952ab5a4ed557f6240290d1df531ea26c4d6e8d5fc700ccdb2fbbd9f62c94a53409027afcf8fbcf1165d66ccf25ed70ba65fb7a499cd47c64df9a774aa7f51050e8b4830b145a6a36b702cfb792c59f78eebd78bcdba0d691d541b97ce5d1e6de0898bd51d756156183dca092a3142100b7a254f1f059b30364977076241d2a3fe9e6cb792f47cb6523b1f4acebf1735912f18c0e3e2692ef7bd6c507d91f8df6efc72238dca0d3195d26748a152d456d5fc47716ad30dff88fe02ad275af3590d78a41d7630f14f4f099d01d541988254ad108edeb6ef684db79778b3115fb6e2c09915d0d6c8404b54da6cd50a52be189fa7d1c1e358cc4e9f6465a893309e85f1abcdd9929463a0dbbd2fb4a4de24b559d14631d0e9552c7d8f17928123eff8c7cb8f38c9d9083a172824e9114b63e4289aa29959194bcb6eaabb502c720d780854477c32741f40fee75ea0829c10522e17eba1ca2da4f34d6f90e07cfd6b7c007f369f95e7321bfffe0c1646aa3b421e169f59901501c80bfc9f8e0c3a4d36e288e5f2d01e299d95cf80c071c7ad8165f559496805eda970d7dd13d26a48d0955dac082ca61938f0adcaec615e32db4cfc3937156d640072fe44bbcfec302562335007f34e73edbf39cc98bb261e16fa7528a30efddccb6f5e5acb8c111dacd606eac52a2c28d7b312e2ff25aee18ef6bccdf2e3ceaa2f25d7e4db8d016c91e0cfac4fdbe078c5c459b83ccfc869822474f022ef84fc35ecfcfa4f0560868c098626f9f4671fba44d6f34d3a21eb499c3057de489cdf369788968458dbb6b145959883754c6773ad4a65965a96b109867e2bfc9b511ea9877820ea06d7ee597cf5daa51d01185bf17f6d1b316d7afd85b99fcca823f7b51674cecebde2ec500da288d313162020639db86dec2f0483694730c6097212e05d900628a90dcaac6506ff8f34e61f9c9443cfe84a8eab8a814592c11aaa8702dde4849dd94cd705032eb2073c82ac22f4d8d047029fa422a47c887d872e68b7258bdfa545a290da7c3e8a9c379fd0c241518ed40065a6f3c1983efb5e99e6d1d8c018bac5f7d5d3ecfd20218aa663c6c84aa912a25e6359f1d0519902e49332651d7af09a9557e99c87945ea7e2780e8eb0fb54f21fcf29dc93f60a8d7b84272d3238d0c55857e519049a9306c699e3f7824dd7218ac97b7776a1ea8308b4ea26397c8c013a00292738f9bfb811718b0d3c64469db3cfd0e3f214c1e50a0d7b034a268de5a2b00e18bdfb497fcc24c54894391a0058f41c2e4307342cc4b9c05e16602119a800b9eff381faee0c6a4c4fbc501c4280e61091cf294c65cfd2afa0285f130aaaf8866a401765d1e03ab7682f50e07c46025a21dc459711e473840596644c81672f2dbf74102aa1c6e19cfca01635adb1214c983f6e9eed494e7a474e0954f21e0ffe06de9480fcc69229c0dbd201c086bdaca28b4a0ff9f010ac33407ce0a0f3be3fe46efdc3ab743ac9e1f56ac75c22ee0c0e1a5ddb833ce55a60dea63407b9ec79a1ae4d56e7636f29bdb8c3efd963eb03a65327a535efc3f3262be6399cb4a1301d3584a295f45937d61da7c77943e5de5dd2be7f5f67774419a7e868de9f44a08fd111dc4bae796586f2d364e96d48fbbe20537c3a97e2527ce8b3c8156d4e32104f90a0a25eecbaa4fec7f1a9e5b1f7331deaba125c3f290e1d6f405189263d995b2ab7545debed2e3b70591ffde221613513412cae98fa08bd0245615944f7d8a782f356c4c72a268f188e08a80e41995c9e4cf6b5a8eb912c70943fda10dd2fcce1c8954c25dfbba3c2a3c8b51328508c02ab8d0e1c799ae601daf9bc397d58b3dd94b3b0ffe6758d024e37fe2435d007ad1c974914598fed68f1477eebecefb6276989a11ee9001a37619192d810779e8572bc36ec0c5e82afe415eb7d6b4faef41dd5838dfb01b632a19117bbca043a765901ee671b347f3458bfc952d41bec7f1230fa22be5fa31492d13c4fd123cdb924f84fae2a42ea61fd138c87d6d17051d9e479fa1b569147f4e427b62a29c425708c8628161c729caab7716c55107661b0f108343861dd2f189c895bff3de0744408d729fb529e528030c2244443de774e3eca383d60ab4625135989b8d543f5232c87032e7eab8e8dc376b22c66f92fff335069c1bb69a19f7b89ddeaffb5c5efd3cf1bf221f8f3c0f77a0537c26206bd3ac6e253a010ad4a7809eb282876b49969d17f62c75dee17f5cfbb743f6928808cec73daf8dbb4a34b28ed1c8d7adc1cc4140a4abc89f3d198f880b24c6603ca2d3dd12b15fcc99f7b9e71a16824eabd09129db3c275172adb3b059018ec402bc7bd8d6b14e1384514acaaa41d4141612378784787130ab1dddddadcdf5700e42e1a49500de87d6673bfb055ee4193d27743579f2e1282c693d8c43d1b25c1864986a55685e777047d25e6c2cb26faea76c61e3ad1c64c39b01e26fa5ed3cdaf7924e8f56273193e0e701a07d626fe429dda04023348347f358d3d9c7f2cf9bbe95712dea661ffc09f8ebca94f2743be12d1b8207130cdcdb0d2b676402d8c1bbc0e6bca89113bd35449a43842619cbdedd7bd5efceb199e3b9330882a8685d7178eb8a42c49da99d89a6eb35f4628a806a8a62c02e83741d083c24ec6d2465ac303714fbf5bac1d7fc5b287fd0a1d9c1c392f3a8fb02f90d6fb9de1d544ba1b6e65931cfb20de930333a0d933cb7c3310853f2924b8c871934795cd5a87f4b3ebe72c555cf37dfd7a05ae28409bbe9c1d25da6416118e4c0e6b2b915b791974c9444a75faca7b58812e53ba9d5499bd488d0bddb3dc849cff6c70147487dfb4d32dfb92e987fb3a27646ec959c58d4a7355d8dea2832eda9bd8257acfd2c26e9bbdccee81614e963aacf20d042f7a105bcd2f7aa1e83cd3683657340c7a33795a20dbc48c178c77e7df2cf75414b45543fa62eff8273cfeb3e07c2f9d3109fd217331ab010da2da0144e9648b88a2f2cfd382c70330c90dd37d6c733f387d4d243bd30d7fa0d91c4a9bdca052235d10f2950312eab2ad768f5a09cee7d52108add7609cbb9ffb311d6206f92ff226ea3705a9e88b319f11252de941ca5c6891ea3fb26592acc163af8d8c724d06b7f4cb8ccf91f8bc3789cf1d825fc55bbe09dd82f25b7cd17d628de502b07f2fea9cc5ec3df867adb775911d894997f7721e36b980067afb0d3a8c4f214889fc0a7d6cef7a9c875bc11bb5f30d027d252657612d5fc085382a06796c87c11a081a4e5ddd9066c7e32bf4b309c49130f9f9bfafb570c37b66c977f9a929afbe58c92cc104a5eed1b85fc7949a78095d726620e7e631b077f7248f562cbd8b25a2b43e9c9e54017fc5918c69423414544446adcee544ceb9acfbb09564f5d898dca6c4ad56dd51c6a6ac1e366b845d9610fd3217ae91bfab50e30d4795fdaa2c449eceaf16850381c2db3dca37ec3267e8b0abddfae82ff53a9b89d26d436bc8483cd97ee5272eb5372938a74635248be252fe8d161bc1be997d6bc4c4d523f9eb7755c318b47fe77b747d6a7d832882e2c605fab443870b29a98ba7078f041ea121a5e5f9aa37aa9bd098c3ff1c503eaccaf00547622a1128151790b0218bee4a8e031f18e2c86204ca3bac62c0fa6c7a79ea44de8b6e615acc67a1a9922e48b3ec513eb9ce34ef690dd9f176abd788b33a5d29873809e33b1fb132ba8d8288d8ae1ea8d15260a541d88addf38a1e126cd602decc40a5746c258718e2b6d901d06c099ac11c60477f4e9f3339b253835f87be5bb99475528f6aba567372d64480ff497e381d6a575c460052ab8e416d8b8736d4f48f16fcb19a8c898fcff22bc238c4ab232516caaf130b094578682f6d83a77243bcd5cfec127cc5d683c61e8df08ada30f8bb07a4acee5521725ed8753cad6af1b9cf1d3683cbdebedb91db305b45e8e68dea8a2d74c6d1292b6ed2d526fc6721e17615ba1a7f12b06ecba10257abb9a7e5145bdcc0cd5456e39a2a4724526ef8a6d50e35f29130b5e04f297d4e791e4b72d3dc0823ceb0a7cc2f434d406b181aa2914cab7ee819e34455078eda4206c0025e744e61fbff53faa1291ae630af04190e908e400efea4130e945bf45ed673cac17c37ae3ca464d12ca2fcc7c8212dc151f58adf559ff8efa80a8f6f746c71fa5408824e11f765d739e0687752bc848c79baf64396f5df6e4d3e388eac661b0f44db3f9f5a9ff6b1664548122885242e3f9e6dcf89f8b176d9591657430f8056a4e8f4db214b5a6a0d3dc3f14b73b18eac7d780b2b5c93ee6835bca3d4995a31cb415dd71f89ad2c6c230963c0a720176565daeeef52f5e9decc353f8351ea8933083e0963c3eb96d76eadc5905473f0822a71ed91e12852ea7217fc4e385146d684424ea08eda681ab7d6f9c429534be11e074f06a68d91b4efbcbe652ba266d02422c9863f753b7ab66977f52b81ffc64b1f9dfbac39f9f3c014b8be0c0b7000a96e414b59867b6ab0702ab34a780c96681febcf7e3bacac8e3a67823dab61eb9f6866871752cfe12cbf3795ed725bb7f5cd6c744cebae2a8b5cf3596e14e4dc820258fdd9aed5ed55abfafc7bc26d22fb30f613a9e2738087b657ad72bb9c4a364e9e84a6e01c8f69aa436fac31206342a7c5bddd8581c38a03bc18a30a5aff5332b7bc3c722f9d46591d12cdaf002767ba2fe24d6252cdead79ccf82ea61b34d46f789b7a97b4ef4e9ee368b3967e4035c0c725a410dbdfc6d13740ce8f65de0deb20512218c660cea884a5a0ae2bcde777ea3094a2570feefbb4786c1e83c5a7bb5b562fb0767d54ab5e7927c5f5d8de58d84072011cf68d9098468ab8abbeedf44b4cc4a7020093b293806939af4e2f85d013f2fa9dcba3c314bd58fb6ac3fd7db6729d813436c138f6b18a5e5c98c9b23862418baa6c90434e9700e5db387973ce3e517061b94421f5be62c6f5cbc5b8bd3b3e5992de6d0a0315269dade91412c66ee991fad87bbaa974223009ba55ea1bd5d206e7c8ef54fbe3a46978d8bb2137f7a58b3397e168b9ffb8c9243ac3d065981a5b0105c399064049ec316e77ef8450bb4d3b9a616fa5c19b84724660a1d39163d87a8ed5bf40fc55d8b66945bf5608c52bac3e794afb7720eba643bd20c90c571bff0e4db887b8cef10022724ac46ad91c1f263b0b1921757b12dc44add12e4a6f03802ed95608ad034e86351df7335a375b4c699551f84dc299cc2d5db5b688bf3f03ab6025ff6968e34ee75270bf4dec1a6ab96c9b3c4760e60dbaa210f1872194e659155ac6af78ada8d4b219007b955a09d5aae6b417ecde946d83eafa5c916369e34ead8381476ff3e523ab08a5a2755b243ba9fd6569e7b49048964de3ae9656b77caf7372d5156cfb00fec1724450401f87c1c3831b0d499b3d7f63ba1d9e1728f858e0808aabf4bd51e168e7eb4f1a9ebd5a0c965a27664a9047758415e2fcdc18eb8d7648954923c9d0b5cecdc75dfc4534294f0f41d14d1e57474d32eed40554c5c85607fa6668f0c719508cb281540091b4c9c578e02b3c2e0b848c8660ae67065cfdf7fc35a1ec9a280576431490bdca2b09d051277ff3c48e4b12d4e96cc20a34b26b25faa6200c9efda53933056f3d481fe535e8c3eff2a6c6364e95a17e8dce33929435ffd49a7835bb3eec2e0978e12583b6974cf863a60479ce51697c1dbc1a0ae6b5aecf6a00fd648108365518c74cab205647e1458070b6022dec983f399ea91442c698623c8fe6688d84af2400da37edb173b418ca77a437946dd9b791484ea135607a0664b8b85bb72550c878fbaa5858f19050f12b3d4409363dc9b007a9374b1992791c5f715a745c7ff879e3b96ad1a740a8a36ff0669146488b5dc3c024546ec4f1f1574f90d8e79443d4b52002f82a7e39044d5ce465d5777e7172066eee631411f6fb329dda928d156d47867708381d176470da27800153ea4069948df827fba796fab46a74633e2adac7228a0a2befcf43ed1812007cb4dca760cc07fc8686b293a6246e6c1343ce44bb4ac6ec7c86b2dfad8c71aa65a00acf922127ddee49cd3f31f9938f7a65f88f08993b515950fd87394839f1287b892f8a438c991480f32e2fc96484eb6160eb8d863ce85a1b023ce3ee171861397fb626484d233d72080f22ad72516d64c56750ddbbc24f12a35115761a33633efc1d6bfcc4a206983d8a2f9d1e17b8ed726314bf5347c30bb04d7735c55ed17d5fa32ac77ab854efe899537669f1ed123b849b3747d2f2dba511dd82fb0177d9e96941f9ab66fe3a1b2cfcbdf5a571dcf15037423fa453e6b22bddad6104895b3e64cbea5ab650f422d0426f555b756df61e08d879d688fa68bb2720b5248d4713e3fa62dc4f86a4da17961abf12915058446e9970e714da336ac1a8640dd53ce296af624fb729d2fafa090c06d00ae0d30e2c1ee0b0860df763570f16e90b7473d1de5a15c9ca22d37e7b4cfb21ed9b22eaeb4a5900fba40c499c197fad6be4c71b486d73aca5cc4cc620d0955131ce718b3d740921cf82fcdac77b548cb245f9b58f7fc14dd6c3cddc4f12f918fb5cc0733646141d832fd37191129a820a3d55c1a6f8c374d16e7300c8bb1aed42880aaae238390f108ff38389d811d60187cdb5719d1d9fcfbf4ac32b8c037dd44bf1c33b4e9370297d6f69476d0ca9abc1ec849658690e31e108e0a8c065dbfb946cfbf9e6d2330c2c5bc35b3b03a25cc409db2cf93b4726c321a2f2e9f323a566fa45e45535045b91ffeec63445b748017a3738deaf141e290ed2a462ee8b8862c01bfffc1282ca9fecb4e28a60e26cc3fc91ac44a6755438e740ccac7d27650a4ab10e33d2b75b12cf0201c32771564eb1e395f95b6ccc1fd7bc73280c05254e0686d4dd3b87be13fd709e825e7ad4b3ec33f390ce7e05c96fbbc73598c45116548c47205a416e956320de0d908c4f4e0156bd12b81711b49faa15fc67da77314664a6b66fb00500f91b55d93ff4fc7f40b1674b380ae309800f4490f49ae0d68f21ac519965b0a95acefeecd86cb46301eba1005158c768bbfb76ac241317543459bf9166980177024dc1c476f4dc7797f6f9ee493d5b357ee5a5ddf26ee6c929e77d4cc6246d143956b371f29fb91db5f2856e460a6b94238c455966464236e3fa52bc9ac3629cc2ca8622b6f1d281bff07366adb9b5912fbd04a2044ec909bc7410b00911a5fafc8be8aceefb457e724100789cd958e6e7c13a2cae73f04f4c11e54a5e2cc525baa6fbe6b12e00d48472e385bf6d450768654f024ca0ce094dc1848fbc7f55bdabd770e7bae000d724c1e558a80ebc26f81cf531b5cd800d1172d376947d98e826c47128cf6d1328d7aafeae015f0f10eab3bbdad2bbbc62c0c60bb9e6eb8e0390dfc76581126ace960993ec8896a0f4ee6f8917584b9519796916b7424b60b5784596edae4d3134db4ab179cec7038dd00ec5c1259dcb3db897b1ed7098de92b328dc118eacc422c80841f28d0f879915f0f0dbd6ab9c776d9bf4ce9dc60451f3ad0d2c3759fc580db30723b11cb79ca68fc39d12d5fbea81e8d9750e1497b2d4fca6b8e99b0e85ad2b471116edd1f2c1577d720f18616d186850455f0775204423d745ab22afd49eb638489e0d50c2aa4bee2ab967074bf7c2e5f9618165a78a0bce18d8e454bc60e6188fb563def2ff94cdc10ae598fd8dc64e4cf3dc46c0158178953aadef03191d42c80c28047786586c5befc35857395d30d750b570d3c8a17c58d17b2d3f437c89000da800eb13c86cb21048b9b0efe0768d25e3e20ebc4018d2e8509229ec6d1e0c332580b517147bc652ee1e5331f58c2fad21e2ff9aed338eeafaec269953db0b837907e6299e7cd676981dbef452c96611bb9d9f7f4ed2eddec12111385deb8d9f79d6cd27eff2c106c37dec48935f418b65df1e6b7230d7f1dc811234c004e0ac3d0a57dad515af404b3eb285ca022e8f5af95196d89006fd7e68175cebdcfe7d5c56ba905e270d5f179d54bb411d1ef02dbb44546e62ef8abfeb9a67c2f18b34f22f443cd5d7d8deb1e789108f132225ef68a4b1155a3dc5f60bb08844dc58331d65df819add4dc079a0246729e8bd67855b620a4de7b450fcdeae046bf78fc8fe4aaab6ed9e66d9389522a9e4ccaaba410a2b15bcc97dc83e214f3e44dfc5dc7e1d638b53469d308efb792a02045fe831b4fa87b02dcb45dda169d24b394d8de9276753a01b9000d9b8ee85c24aa033451ebfb6cf505159c823bf97ccc5899d30bcb592600e80147b96131b10e8395238494a2cfc8ef166fa13e4a4b372bd97764732a2436cd4172d4c50ad1e4a757bfcccb04f2dab807deec27e501eb0948b3e2647ade704b1e298ff4163b25c5842cb562982b1cc3612e52df0c584ca1d35d7f498d094241fd4323826243723097b8c10e42191834ab75c40c5b7fa9b1750b538a8c259411023e97f1e4d5b48394e4c6368787191087f46862efdd7f7dfcc56f41407fce4e9885a10984db4b0103be1d19e08d56c9fb04a9f1c38b950b97dbc64e04d1a87d74ce2869fadaef81aea3e01c834380ea5364331db09313a75e9ecc461c934afa90a8de3c086d197273303418120d218edfaa25fe4f88734b0951c18e7915624409ce922a043c232af7ebf33294d582b261ef36bc7da61d73a7eaf6c528fac1fd98144e512421973e71d77cac71800bb4459b130c4b542f4363944aed2d87e568e51f48ee522776547491d326c48d0f5d39060fc518aa1be5a693d8d22730a0c34773d054bf0cb151bd345f1417a1404ae84fc7c124318459f0411559a9b89d7ffe3961c38d7fdc7183ad70eb40e2ff6c6383f78d7afe274794df4bcfec551a2a80b4b7c8ac6b898aa328333dc761ead9909e63b01026ac54ac7944589dd3e7b35d58a145ea3dafe167f7c019a2b2004de02cc02ad2eb9693c833b0ddf3dedc01da479f8e668d5cd68b3cf2972709040e7ad915d1170c49296f83a345511f6f83de4c6b82c443f677ceca0f9d4c33998c5836adc8a57704e485414887c742dcec4cdd6606e1c3edc2e474be9ccb3f343f0f17a80284930ee20dec30e2bbaf6ba67dd2edb3e4bcb29ca94bb91e5db9d69cdd989f1951712adeac27b1398fc42422ae9b803611ef1cac019c774a0776bff65173a6dab248d54b3282f3a6c11fd4e5cbedde9eea70d6f096fe2967fe0b3d87d066a06f54e4dbfb8b9dbda9292f7f85daccc8e7bbff0c8ef897d967fcda05f50ad6612d4aafb2ecadc4ec63b7017cac080661b4328bb6a35745423e97262bb4487279a441a3975ab8a9ede5e686a8d032d1f56f338e624e0dfe39a37eff975c590c1c954aab157b3cf4ca8e3371b45bf85d830f3dba9b53b8f772cc35b5d852ed3ef9bf02db2042b4f8a2fe16db90f89f7ad85c4ad597b318d7d5c2b80266742fc808d7de7f44c1a0fd5b5fa2dc395332a6457ee2530976cad3ac90eacaf4dd13ac4fe20847a8df046465424e65ac83ef4e942bc43109dfe3b87069cb2e413af9f824a39fdac6d51191ac9bd65ba1596c2a3a01d953d20b97064b211e157f7a1039c2c3a332084b40ed6900823c97f41fcce606101c275da1663e1fed249f7565701f3a762b132045ae1cc53fe65d15d7943aaf15497881a816c8ab6ae8e706f6d8fc4ae41700fbab9afe0e5f3ccb959634b04adf6e4fd697902e88be4ac2fd5a1e2c6fb91ffcf65af8cd28ae40845b862b1396d75787a319e188e9ca76d2761fbfe1ed4f9543b997465513134dd9f47b5241aa66c6ac6bb30bcab5e9d4087eda2d363652c0a4f2070f6807e4790431ac90eec9c15e5c412e43c2735a470a0b07410417a3ace8af321a5c5de1a0db405990cc1ebd575ec416e03c3be50d43f785c5ebe9438bb4986a44923de9fd323dc1e92753274ece88752cce30aef322afccd8b9e99da750f96725d091b8237ce487d3eba353aa4aefa00e05c5ea50633ef4d00f55646a330f02cb7a9e5f29d63339cad7a3703212a65df60e3188d35bc0ebc10fdec8d88c6a328e0c2a242338e5119bd7923fd321053aaa7ff18ccd47e52a24b0a5bbf0a7a08f6ecc994e64e626d3e039123ab0569c45de75361ecf395df5430e8df0622ec308c149c29c29d8e70d1ed157fb5daeaf8a7fcaa331385b8a97f1cca01fa6dcd32700dceff69488d563e21e6da0f190f91ff90ba57b6e1536cc86352d6f3589608a510c40550e2114293f72522c8013e82df1fd71775ecc33f417986c68437fc650cf9b2c8132a63845c57ac934240a65a2e112f316a47fcdc85d47b63156e0cd0892e6adc627cc00c54d29cf88b0731cca06d7520e61fdff9514642659592a9dc7c3047eb97cb1e5c4a2d5387e06331fa239d2dda87eb1aa529181e9b3502c74addb6afbccaa5be06f875611eacaaabd1f4a76c6f1b4f9c44a3bf01bc48d6edfb9873d838277de1e3e360b9088fd1210760824a2cfff1d145afe47c3e39984576b7576bb1cb4b35f60a22aba416d107485","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
