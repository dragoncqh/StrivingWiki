<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88fcefaffb90b04497a112f7aaed12b8a80e113421e869277b19ee4d6970ae07bcf7200a59c6d9bea90f1ab4ed8d61d3fb395458526cbaecd65ddc0fcbfdb6a22f212911fdbb0a11619b2cab267d33e4137d30cdb93951252689c7660cde24f528afaa0215b1a7c0daf57d3e84dd9ac3aea5d5a3bcb6ae82003a749acc3fb705ee154bf60f496ff8497cb4631019df1b5a769e58c08d58eb9b5ab8e27a70bef81fea4e61ee2b3ef9558e0c27938ea1540fb24d5d09629b9a80552e6501c10e38112a13a70fdf967f323044f2b14a83bf2ed020ed9f27c74f0f832cbbf0871662151fe9dc118845a7110fb57488276c6a2b418a196b9943c077ac54d09c4c9dad6dbf374f1e09d1dccdd3f9d9948d492c71f3b717cb415a001b376e4f79fdeccff5ebc488f519eb25562df30797e246d652df1d1eb50e640b2922dfbf1d3df7433159bce64502f71d6504b5f539fc44ba489f4f7c23872b2d330515556e9f5a7ec31c1760a9e1fbb19c15608121f383ff7faceee1f91d690c3e2508f09a9672c60c818ca6fd3687863d8be28ddb3aa19ae5af3b9d26e98b7f925fe63a8fbb49aa5c77d79a9418ec5306316c6a8898d630e344e054c51128c4921160e71970dccc80782dbc2f008ad5540a87337424ecb03ec53338bad367bd9569527944b831f4e01a2b62e2c8ddb6bf444e9db9a43cfa089a6d5f4099d1d36ab27ba73caf14d92521d8efa05f347f7470531ca0ba29c54aa2d0005e00e0d5cab008fc40c4b0fec9dd32470d85373ac0cb85f71fdfd22515ba5c080f959c5b3da56389260ad2a6855b76fbe663a48d3a032dc2ff463c4a1f0472c6b79d3002ec97a9adc8f397efa041f980903c37dc6f53b079ef8778374791cee457f76c176c2ad05f9eb8c61b79c243159edeb81949a40d97095ab74d455e120111163046fa3a0bfdb05cfb7a1361b63c36e44bcaba683bbd3679d9eb629b617d4edd82fd52c41f3199aede42c0d168edbbbfb277162454ad21de988cd493c76a9ac7588f36ff7b2bc1c8272e62352f70ed3b59aea059d229ed9d4bb0e3364153e42aa7faec349e0ca502955de1eb53734e90442733e1c1c05ce78b921d15279c028579af73ed34b66aaa1eab6de8fccd160378c832c72ae629b7c48dd2a4ec04e9e4792f32654435c15a31a818676c53abd208701d2d29da23addea4e13e8560699ac6db82263c975a03d9608a4dd98b2235667bcf88fa826835a95f551879db3169d8a34055185633cb8e05f1d0d6f300127af7fa7fbefbfd540d211759c45691cdf305a3b5c5f37ba71c561053ea05e0016790d1c3b3a2f6eca6ccea40ae31b9e2acf8c963a385362ea0cd4841096f79dd34bb09e3fbd4efd0a30ad00f5d52a498d43864972afb7f7343a84f1236776276d4f968ff47b6e9d01075c33a1e020b897b171e97da76f43bb120a8d12844997723fc5b0145dbd7e28178469f1b60fe7d83807b1bb2b1f209f6135a490ba0a9b1de004c4219849d639b859d85bc6fe17be58f9ce8b2b3345b1e4feb3fbe5b6d71bafb60883f9147a7057425432f85cc107b72c1666e49931423eb4db3ed0bdbece0abcc271806b03174300f04fd8bab1feadaf701bcc4fb78f4368b5891cc81df473227744e5cd9c0e6297857f4e06bf822ce6ae8e04a3c39b47f6e27247026b9dcf932f903e776093eed17283959459c6e99659b86223df5e836b7fac6d55a3321f52b9a7a1809124d872d9e345ee616a245e65575748315a8bb1dc2aee2fccb434c6b009f35b80e35b3be8e156c7e6ee37fc6ea3555e7f0ae8f58e60d8ef8979286bb5e2a986df502640189e3f06d78046a6a3eeea1e9acbde86909f125ccf5d76ab7d613d552ad63a726f84aee6999414d6e34754178b54fa758f06308f11747f736bd5ad2f8b36cc07c61915acc2857a8c3393213bba3a1c971278f7fc9b2bfa4a590c5773996e23ed3b76afdf8ff921ee64f56d0e9ac2a4a8c785453d4220a7b0f2bcc87d1da14dbf66a538245d6d4ee39e9aeff3435da2b7c56b47e1aeb186574009f479015412e37fffac0fb4627676deac71f7fc41fdeb5f05bd9508116366e86793711a9b41b708ed190cd695def73c849f59590efa3b10461eb83045da4892910c9f190932ae587d451880f71a8cd1ad78f64f12236b827d998d498c8ec165a6e20cd8410bf7b77c2bd3bbf1fff12a5f42f84cf528c08e9b2b4c17e249e2c21d17f9232f00739c1ff5623af68a808b03dab46da10cadf84ad483b2be2da1a5252847bcacfd735b60699d37ad1aeebde52bd1204f620ac9b7857403cdd0a62eb08cb3fdbb95513551bae818cf3061c6da40bbe3cd370855cedc32e01667f035d00ddcd76e6fb5fa0846c86715153a7171584668e4ec12d24e7cf42f234122a8f0915de079552491a078d74ddf3e2dcd42fa4bf74da7841f775fee0addc96e7137fb7b53a3805532dd586e55df4464e0f3f22235ebcf9dc395ca0dcb61e336110ff7d81e8cfe2e9bf91513333b3d8667a97c60b253aa3e0dadb6cbde29669783631f35c20f62eded03c74c41543a7d73d32483bb89a0983badeeaf186be91a7b38514a868d4837b01c537e93a786a1406127416073c1fca08fb18b9561942923ad44dc6caee49baebaae579379b2711e4e0db06724a58ab29624f7bd2371ace310d9b85b3281542a50bbc53bda2ef01d199ca7808dd4fb97b77c2b6dc6102540ccf244f9e7e832ca934d00207d54e992ebd542fe356ffb99a9d11c6293853a71bcbde87ad3ea4814afdf0aa468ec0b14325cbc530b89068b25ce854415b8d5ef6f3adb7522b805c9fee727cf0beb2766295970a76d2ca96b435b50932ef99b46269e031950af4965976c009b53a9f322445431a40f1c6e8e6fcf387f24d4d7c449a3324dbcd75bc3d9ff04e65b2dfde2537b0b08b9699ad11dc09d17a54f143be2c97f5f4c80bcf64e3a6a1825bf2210ea0eb690c7a880db5ca69c2a78e0dbd5b4549563bdf105b8a35ca29b74bd51ad79c679d426f41021a9a5fc60c69a1c98a664ede0e82164895a9646bb27a2fbb0ba27e7072f24ccc7bb307952f39052669007dffacd613a0e8bbd995421561b44a7d0f928194ad94fd52ba3e7c56f62352140fdde67ee7885ce7dc3f348c0c9c3470df7fb6f53a0ceaf3e02e19edb2ec4e8b6b5adcff51f1b7f6f95be7d09c70c71b21db312992f6199e38a115cdedeacb8a3487a7b63ecf5cf09ea442a837f364a94d550d2d8e0a367823b51ef55e63aae078fc4a7b8f5d6eefab51b4869d9dc0954c92874d31af916d78b2327e719f1933d04b569a4bf626685e5bda65aa4061043f0f079efa3669133d2d18a2cdf05edcf0889b1095a903039d01d995b47db523bbe89c76353759c17deb7250e0d575eb623f1951c00f62b1cc9b958b5601fd350e8eb5182d70f36430b14509ebcee0e706f24aca37d61bbd58f9d49d170f5c1e6e2dc71468535921b4a8bd8537c486fca80aff28eebe2ab17b18cf1c03867c8d8c9f29c69d96d5be1097a62339e32d7703ae9cc9687630ec3dc40bccf0fbd3bb4cebf9c6ba9e7cac70d71c3734243437a6f41c78d3126e624aa3aef5662437a91e45cfcf23532f2987b3f777342cb40345c0c4b7441d62d110d2b3a63584cad3bd20fb95ef327151aae14cbb4336441bf8e6699c9f397793b83de37f8823609fd1d6ecea5774065da27747101717555ec7477ef531e555e9af981879dd7e503efe1e7fcfff52e1c71d04687ba8c780a3eec7c013e8251e4beda9fb252ce05cc23f7ae0da1bc6595f2a0ba8266a97e42c554eb485df43b65ef5bfe00338c01835c11d2cb56950aa08092304a68e76cf3ba90bb33c56e07ae6dcf351f3f211095345527b5a9b4679a08576f534f0db7e8839a7ac5540eaf1dd5ce9e3558c9a086898bd01f77cac9d38a242cea12f8e55d5b8a6b4bdeb4a1796b4791345c0a9d4d5e113a675e5c54fddc69bf4bbb7284525f708f69f272ead88a64824e310f9fe51b019ffb063b3106e1c972b6b56b262df4e3deb44ac76699b729a0b446ce4c72a1a4eb8a4f574ba962ed2cfad5a6b48e6305315d827a560ff3903fe5ffa4959a42822432dacec227c314b87f55242749f1406a7bcc500dfa34f3bd763d1468495d2b398149c56bcc8a52b09ca46e74bb2e62e8e3e028ef3ecbf2736a21b5347fb856f98ce6acbc46bac9fc3d339c490209b605223dc8ac0d4e53e662c92daf7044e4b7c44613f510a9be782af81e116f5d4653ff780110696a35377ac3b04174854fb7e35c7699e356950cd587e29dd2fdd5ae52da2473f23dd3021f37a735b6cd3b2c36cc37f1aa6d3d738fb115862748df7d0979163e897d49d5a312419a99a5b0a6c7312fcadeb4ac05ae122e81879562bfa938ec4c7c84f023c86481d4c2b7d8a3cbca0d353dcf5c8894cbb1fc22c0cd721e66e187b232545f9780809c07412bcd5a79ccdfeac9d39f92ecfc17b4d2e52a28052440cca5050723c081f195d5adf915cac0675b9a236774d9ec5444d28116023f17bd778f44740634b6524119f727a255c440fe4ae3473c207a3c4941c71118e5625d1ffcb76a5cb654ce3aa90e64dfdfbd63157e101db69e8c86a69c157cd53f5af072b96e60e2942f3ea8188e47a5c236590927103bf4faeb01aa18656be3097ec77d6bbd74d729ca47fdc40fca3a065592c1183eea21ad36b8c0a6db5d8715f88f3c70bd7e3aa8717855f460bd8765f617a3f769da96795e7ffd4255b1b1f6d8bf348460bc694529119149332906036e052c428bda6678e6d5f70744c7b35312eacc3b253eac8f4a53525d4ec7231b88f3e82b90fb44a7daf1050e57ac84a195878fc6a5ad0cb9330a6fbb978e66ccc70d7564053dc88911ced544a77c0b906902a56f919f248c652214c077d610cfd4f8ebdc7d2efa4603b494ed56b76ea329477d11f08c13e88bea521cd6ec4faf7da0f6c6d531d99525b0d2d2b7467b8a7e8868ba12f86e2c7f3aa3973dab0747ee7cad0c951d6990c9a2827002c18e373902a0f0d1fd4707618852a0fddf4de5f41b9248be20b6fe35e9b23fa6697e5a87ca191ab1ba647e6767f90c1baf928e62da4bff0ba0832b353d285dd50a416d559c390072f90cc4f480c9af16a6d4e99964911728d000f80a7357246476ed380c08ec7376a6c1b634f15607c3095cdb63bb6e8769527dbc12459b6dcf48989911212c492e164ed9ecf43f101ed2277e034ba25fd63a801d7975d5f07766ceb61f1ffdb7e0d536d71dc4daa0ca659cb43effba04ceef8cf85a80d276ab58fa5db436460b6dd8418238cb60253367c0b56c8779d92c1c4d7e8c559ea3f88e3936d9183407d7bfdf5e4e72f10f936b0a48f62d902067280816d974b86b04c2e59ea0b40488d28577da164507ffa86bb4be64b4c422a30a6cd6fb31f29424a86e5407be6c811eed55499c742acb63c7354bc82064d28cb8d5abb1fa7a26878d2e55d7cad6c06806a16708d8b0b425892a82493964fc074e8f0416d956751c574ccfa119aa2eb282e6bbc88176992a2ed4b3f7ff41e177aa994b07e7d2a81d47b7f3979681d5de18041fa986b0cebc66b10fe5aabebb3ee63e8ad0c6029a2d75ea0c435193313b981bebcc2d80148d7f12d4d80c04b0018be7e8895d3f58ca84225a266b0d2e8a74520f1d89466c5da9accd1011a67c429bdd36b57ecb8cca22831dd96446b74dfc696aa5e4f04b64331ee028e5ff7935fc156ba4c02cc7ebc56f78332c4dee6bf6c91334e84f2554e5e182a27d5ff38176efbdcafbd61e34ca3bca1ab25ea637db76b02ea3f1fe7446a0c3dcda924e6ffdc11177c083a12af990e042ae0758c90d3b9539d1f1ecc5fb8b6a0b50adbd196eef237cb8f0aae5c120926d9d1ed8a313ef129716dc191dbaa96a407abcc5b11330664dfe9048c2445f626c67f34fc86040949b8426550f3b56de7c08181f1c6abffe939d517f21ca40610560a43dfa50cb3d65c6aca8a774a34e0d9ffc076525e2d62f78d883d1925e8e08b83b46eafd5aec61920e170a640165479d160fe7bf695fb91a906e8e6432a37ecd8676cd267b12c47aad985983c65ef38f46f85f6f4c0e361e06accd0ef5f620ea363e721b02eee5b2ab7941009e4dee5e2d9e4a9a956c3c9f8e773f60120d0c95f21e981d706d4505c59599db754c6f8e9353601fd62538491a5c238e4bb507178b9b896f691366eb205392d475793ac78ba1bd22994cee863e67a6dba874f21452692fff029855c7dc28db2b1f29d083c8c476d837bf6b53e397f9e985f81ca1d560f4a3dddef03d0e06f9db55040072c7b7209d63e722f49fb77da28f67d3d0ee8590ea0c60de5ffcc5ead5b9fa37e33c9102bc3d80f2729d5af1ea2ee28e376be2141edb74623909afaae19ac8ee47c649ad060933121f53c2e48af1779a9d054191acbba8a25e493084705a8287979e7ca200fa3aeda0363bc1546b84ce6816d4ef32325a0a1f5e4f9e9f7518b7e6273294597807657350c18d5b8bd5dda83d6c4d2d36f63e7acc4d0f277438e8eaeb57bbb2e7370c28a91bf4948b86f2e77407b68f931b4b4d397e0bd8f4d107d5efe34328b81fb01d4f8a55b29dc9df408402d94f888bab5d43785184ca5a67ef069792e818af295cb296dfbd766b65372c9fee0be2b05c951b6d5514a668125541de1cfaead74ccb6d50d2788c93d71e9f479978f85a0b8ecc91897ca3cd9fe82452a769d0159b8511822c13392e9d10871d56c0345c5e163a53f71f1e77dd231a9e16e2adfd8a14b2d5f1e473c172ba0914a1f746bff89df963d32b519ac532e3fa85cd54d79018a13fa641fc672402b5a0e8373814761be4bd3e40d1804de328499bf668a5cfb5aa4a4b50dbe5d80a2f207ae953786d7b375d9d93eb3f3952b263661d44f85e79704f251d87287553f1eda018f6fcce28afb0a19c842ae0757abba40441ccd22d5f3f3f9c6cc2c8c335583eb221f01fb37c759ef588dd492a6ccb932036442784d5e0d776e3e26ab7fa5ab68d3cfeab9f1880469b1636c1938991d89ac4f91d71fedbecf571def622128423c67f4490e28988f3e9085466dff6b2eb19bd8a1a5139f292012732c4d75018c2dce9683a5c5a79b010eb698ef0c5a838cdebb6384df4f63776ebf0067e5c7d71434c11a9a26d3553fd176f506aaf5c83b843542f7affddda0ece734ac9f547fa1e55adeeb6bd4b3b7e20a56c88b76c1bc7e81f9417668aac3e4c032aed67b39f717420c6879b56b2473a699cdba1ae4923c18c8554b9a9519c641cb53e29d9cdb8988400434135a9fc7093dbdbc97ecd7a7710b9834c672acd219c5ed645137feb0a9f20b61a82c250cd86a7e8a38fa6ef9d9713b951d085a43c0b3d2a45e538400880a267410bff312372c66378eae8575ff907e04d8e10be862acbd0a8721c3af2aa0438b99340216db77e2b79b5630e03ab31c0d731ae21b2913cb341adedd57ce726a786f5bbbd39794dac9e5fbcbc834b733470219d1c623ebad8615597dee45ddd0c234481d6b126ad44a9777425b52c758eeaf06ca58c94a4cbf751e8a034dc655686ba83ed838bdb9fda8d4d0c2ee1da702d77df2d69d8238210af283a399af5c1ddac09348e5cfd95dc4290acac5bda92d0d2a758a3e0ddaf90ebf4e1c53fe9a622951b3abbf5d6d1a762a5e5f29bcbd70abfc3150f1b890125e7684111ad8d40a55db7fef84726610cd19e3f6a42614f702645859ac1081d060943c2468bb64929d4bac7fc170f4c9eb354f4ae92b408a308f3b0cc4f1363780b4ae6a83c05226b0e6c96dcc23e21f528fcbcd8454d721564522d2531d7c97666c1198f30093f87dbb827f86f6e4f568a4ab46cf0eb465fe0df6b763862cc3766145cfa5c193c275ab089e94ec12e72e24558c822516add5ffceddf752f50c702c4b60b2c7e12f589af5d5de61d5c07ca87a1d03190f3173aa15a402dd5cf5716c8b248dc1f003317a311906e35baf7418811a7a0b40396eb07a5b93a2468c56e8dec2ebb58e03a272eb11f83128dd8c218dc7c53069fb981803b318569913ab5c118488579a5565e6183f65f395448e9cf1f72c5d23d04fbe879eee9f4911ad421639b01a92890a1f8db89b021cae8b92d8d5558ef910d3f54052437e08a99b768a919d5c3da244f10d95fffba5f0bd89f17a200405753d9a4f6adc94ce03fa873cf5aadba4928ed19fc26f1490ad173771e692a3a586f30a053c877cfbf7c0817066d7f89a8fd0c8c51e1d15ae6e215b10b8b6e7d45d729b1e0d361ee347901972a9261223aa27f4510231afd9e5a9bc3f89921d973b5cd643f67d7a460ef1d4c9811a83b9eef37ee5361a97be87aacc2911a25d3ec59feafa0058858e9dcf27bbd67ebd1d0c3c0e9cad1e9240b37d38f59adccd48d54f8d810f54ee477c422af5be37cd531a6302d0acf1c05c9b8ab2d134ed9c3a164d06f7eda21737f5c65e611dbe7892362bf61ac982c53c04f030ab472c1da19e446878260781ee2fb96d8692595b5f8039d125a7f97827a3d1b6c211eddcf740ce772a88e59425b2b57b26c33f537a0d0fc5f68042829465ead6738bcbe369635e4e51baaef7e5fea2e8e6c79b60fe279ba5206f13f793079274abafe2ee4e6ca506c98d4bedfbcc7afcae923458901315acb19b76aed268f87f330ae87d1b66bcb97e1bb34fe40c00894f0939270e7ec231230010870f12aa015ce962b011736c0ac3c62c087505546a8a9183939d822a98c5a2ad71c7324b329944bf021c522de72ead59b58ae54ff5fa4c06edf2845694f9e55310dfd4ee8f30024db6c7edd89d4024588646a628a6eb55dd368a6f8c7853f0b048b165da4404c99527988e1c48a57e661718e4b1fb28b336853d6f5536a06d7b008cbba00a43b9d1a5262561708861f6fe1d42065940a70c95b0a72f5ab8f261ae336082563aee42b5744d0d23d959a02c8447dbc287e5865e1fbd7127d26c935c76da58054b292ba26bfe496be30aa7e83e61286de9360b9cc5672ccc0bbac70e9948b33da17950a54175ce551505c1d525d94e2f00d37ac69e9561bd28065dad4d3a20b44a5efed09ab68bb91abe616655a1a61d1ee54788280c91f839bde78a8b8c400443e3471056fb2b3dde84df6051dc2bbfb9b5bdd352916777d3a233e8c4b20965dc28b3a806a0019ef90200de871fddbda7351cd1a316d412ce275169431e223ac5b4ba515f76a181994a948e81858f1ef42cb81228503b9950d43e7557438d5e790f735570db76f549617adfdee5509bd64ae196dba158259f612c84f090be911d9abefcbb80b6ce6d8cb4f5f2b0c6e395e560f72594c21af5d34dc406f6ad4f4c3d7e90caa33fa513fb827d4c63da3b72a355915b872db85c8922452fae61b788b87e1cf015f34ef24c5b0a8ffa06cd274ccf8901b201e1bdd1c86f2d0a52968331231e27106a73ab8628530cb9b5c1fbca1fb99f1d21a24ab0061040492b42e9199f0cd6e6624f0a9082e4737a4edaa49029acb0ce0b2c353f3a0625548a6ff6fdaaa8c149a1f5766a48ab6bbe9e95bd209af5bf7674e6da69140aa2a7013afa217a9854a681b20a1c37ed68832d5ad15fff4f99a7873f4f68462c8c8792301e7fbe75587c116ad19d66aa2e388cfed97ba9a7ee26560ce4e0780f40fa4a39a122a0b40b028604c8dce93e342514a1a41beeddac1d37a4847aae717e23d7894ad83f27386b27322db2eb158d242531d84b716bc6080087059f4ea8d77711626a252cc5adadba355d33da9d99516da2ffc26bab36f6f1ea961b837d4c446d5ed55d2309360306ed61f0bf35a7ac643646340d071428337a9b6acecd7355b22e645ea70cf34c068ecda46509e3288d9a3e38194dfe03574cff3faac8c621adcbb178babcb3a43b0166ad2afa7cc512ec8c6c35a0220b283eab0d73a33b820809b7a539d6e9df8a362a91191725a185d5a0d73050c4f75729472c21af5706d3508fd837c35814d07682046fc016a0cc50901b292062a77fe1f32119d3cdfc61b9fd6a243e06ed62c5f57220bfddf092813d0bc8236a95c24ad4e4d5555dd492e0ac4774951fd0a80f2d48b962744d0d0960b9afbbcb6e4846a96e03136d05a21a5d90b01374062f3c3ababbc0ee10ea0cb2cbad3ffbd75022e5a14571b609b48a7004df059811d47fffe5b484c448438b1190044cd1ffb6e860ed10f2849a51f06ff343e2c98cdb3e8da6593eead2054f4b89a491d9a778d6acca74a85be72ee9b8d8e8eed7ba418f9349fe5c1e52a517ebc3ef9a083254f65c855f302349f82b80e05482326535d8133ac6e6682dd841573220ecc9afd3b6ac72f0ad862a384ece209ed202ff0363f560f6b90cc2dfc2d792784defeadaf0c84c39742b3be09998283f3be1325a600ac7f2be8d34cfbc2c86cd6fbf4b81546f44aa3b67eb6ddb35a76d1a0e20bf17c4bbcde9d4e25951d79729b9d78b1c3e8cae75ca6d76b99e7c8327812f2417cd9c864616e25be98344e05e9755fbe6fee53bc841b0688973ffcb1d6127afef9b4910ffc64f7ffbd50a5ace49d4a4f1ecfd46ee7cdc3a33b2b7b117dc56ad1ecb4c71073cf369cfa842f0ef67ea39255185f1da0b6cde5fcce1062e57d4ba4d69890f1e66aca06ba2972100bfe6b3ce0173d4e3f2d9121bfd00e99e03e933da63433ad80c6191eb13be23c9b7b9a5cd546ed3e7c91f47f19cc6f15c35f099e03058734fd9008651f5b3f41c0b5ca4e70d16a5eeb8a74d4fe69e8f0d819cf2d4c4b29b21498fdd2321d2533d97a8ff942f269ae1682e5cd23775453a383d6e0c835b50dd16e745cdd30ead44139df05b4e7e5f626481a36c45af44c793af33432102cc19e99d721bec241b696fdae223e12f2b63f77ec6eca5c780a07a3c29c9ec6abe68c5aa477456dfa4897fbdd43a412bd6af0680433df1e1269cbb1ac220a16d5cf9e66f46e4044c47c3e904a5b378d7d825ed809b17df67ce947eed5588fd98571c6bba5c9c0ac2d4797930400f3e0b3838861564f7a9bf5947534534c2ac84a76c29a6125e6748615e7b01506dd393e171eb4e1ac3e3feeb4facc0c2f3d6b5ca4be3cc9cbbcc4074ce1381504903c36e7efdb7d0f3a2e634f9c5cf8d04663765f9c996531f349db397f076c72968fa67cce58530b3ff65b3062b5e25827226a2f77008edb84c0c21387f4b883c51ce8ca41fc4492b5a6b852e1168d47cef9512e557f86d2563aef34fa33c182541af079dd9d1656bbd39d167d356a2683eafa102e4d7612b72cc07cd08a9fff138a48d8d9ea3895c49d16c90f1ac7219144c55726ac716c2df1ec1f3acb364ed30d51fc31ff97533c8d24039734a4f8bf4fa5439f55d3f75d777e1006a426ecc358d56bfb5f0ebf46b4f7db3800e2dced64094ccea6b535d3b18d5042bebd495c9882d7b61023616b93ff2934d31bdebe20fab5391de109e7977ccd65ae156ec64cb814f98964a96372664482d0548c1719f81f64a3ff51be792cf574e028ce91335231ad4faf01801fa3ede8471f3e74c55c98f0a21f6916c34b3060ea7468ec735baed8c60770c904204615e0a3fc970d851c0693089a8408693335bf92a981e2a2cf2998e4f370e88c52af264248dca6ebe7a1fe263442803a25b6f3298753462065c7c2348e657e1333bfacc6b35691a375a99a5c2d660228858f002234cddac6adce375488c6587539952faad59255ee01d06aa338595a7cabe48f73256785aa2d73c799ed7f300c71bb678069781dab78789d3ed3f062308916e5f3296d19b1de6a3aca909d09b05f43fb04ecbf1f1b44aaa9af063c54a45f282a20a775a7218c0291267248cdaeca38fcbad9eebfa6ed0069ca4df36a9cf603309a54438fbeea4ba80345aef0acf79734a0a35c23f11c05a8d0ea0af067759da2b554bbfbfe5877253234692d08853096da9eacf447496c32056bb61a6bf44d824b00755ec87ebc241ef02b8697c75d5ba56a1da266eb7a1c8f581a1abedce4d4b212c416cd6e875e735b467427b6213971f90f3d0678739307bf848181cd02d27c7ae1dbb1f66238a0e73ad27a6c53ce54cd29448b32954fc4c2a0a226fddfb1233d0ae92d461b1d3d9082fd082b94ce208f50aeb92c8e43e211363b3283d6a28dff2bfb89bd9fcbb37a30cbd0b7a54a1da959751ae11b0925475588628efc0ac1823cbd0a5bb64791651830d65d906d11d82582f5b93d64a3df5015138924f355a4767d770bae5661c1ca66b57c5d0b9f82dcd0990367aeb11bdf802d19c2c364a26c71b541467ac872703b2d2ddf9864d4417811be343075e94f4716defb2741e0f272a22826d002ace74e6fb881bb0a50c7c3112474ee0bfeb9487b1cca42e7474ddba0ccf560d433c619e494e602194d0f188c72b22d8ceace935f18a8091ed1582634f88b0071d2d4e7221a285d582c65dd6b9835eebff552d5003cd4f6819ac734593ab944f73036af09400ae795354d3aad4051a8f9bce0727cdfcd782ec23398e0a8c627b504a3ed6ad5904aff6147354b2edab65deb8b18a25d6944f5b2ca6f7b35e85a33eb11e9d3353b1288930357c3a937cb92ec5ff7439c14aa7fc449ac6d627467d0784fddf4e2995ac6ae20d2efa03620244fac7860179b59462f0a20120c974097aadda288d74639e687115ba08391b85f8112a879d3abecf379cc48b25f7c917d3113b49facd12ab94039adf4a4f8a1395a6151a7d340efa6d330fcbcab34b203d35466c7cf20d36b3a08a5838af1d4bc2b6dbbabaaf82b992a160cdea0abe24460d689cd98d575317c0ea8b01d4e3dc5888ff5b0c93b809f60b035a1642e8bc278c255a094113e5046e8c44a48e3469410cffba3efaef6bbd5cede13a4fd6f2c70c5b5edeb9cd7d45519d905f317441725ee98a8e60d173bb81b4a9556cf50f2fd0dc770c3b5d2dcce121a257d0000ab741c52089f8fe5236b7d785d49d15bd5ffde1d20ae39f8c9859633d8628dec93e67685f8f471f395f6d5ed7742348af3deec9e76840a0fb17ce7b0461a034a1bfc450ac40dfac8b0e173203e51327c6386bbda52625c714ea32c94b20ba29e392a39719a2f4840b5a782f918ec02936aeaad7575878c96aae1059dd5f84d4fe0ad5fda70b59628c012762885737f1b1d186290021939b26be36fdf651ccb3b5123297b76865beb6eb8df1b710e171509aefe7c8d3fa97ed6173a8b5d5d54dc50a9a0ca047a556a70fe9a17055778c2a30fa755d6f61b5feba7a085383568babe31187993aaae545f58b73839e92bad3f9dadfbd60e184ad91183078d404422ecb9b6bddcc626484fb02ae250b0f50a751e3523836dd3c341a704687e1c77208c6bbc29e0cb88a2a787a84cc70e8610c5e196f181b8a368f36430df77341c019452ed8a93daa6de17e0daa2c03b3dd7e89e8201e67f0ac01f26d6f1505094223fe535dbf88ea47a557b80c54450d424c3e7c57ee30dd45bf90794c93b62bad96b31904ccd8e4258fd6e4225d6c65abf9c505c5ac8b5285d8f87135ba8d9c9c39a635667d83b9d078896b8ac6427ba074ee9d0dc62703bc0a4f077513b5a132c49f05c69780e8926855daa98fd01ac3206420b803897e66b52ae1b0e1f9bcd784c1f4ad172491007135686a4b6d9044882124b614baa557ebb7b9cfb506e34c9db55eab85b2646a48fa556c8c4770a0ac1a854b8b418890a19380564fe75cc2285868ddce95c48c90b9f9c821a26b10f9599fdfd7f1292f167820690a1165701a0ec550e7ab7882bcfbcd8210bee13df10164c3c57c252cdc630c56abe64212073e74957e8d2cf4f43deff4b52784e9eef8ef9849738e294aeee6ed107bcd333aa1ce3ee8085cda066502f0d513bae9b3b0cfd3569460d2ce82057f5176b7688a4a49d004baf111a83e511b252c40709893a2e687fecd728e75c40dbdbef63509ea89eb5c8ba8c69d1786f7d45eddd2c2160842d9f9214f215f39424aececdc7b45c1fb48a4cf84522fbb6056ba95e10238972cf48b7fae0f5ffde68ddeca15ae553fc92b9e25dbeeb3182e00a21289a5464ae68e74aeaef232e3265b3dd1a4e6cc0bb42ddad5e7882284c9ee315b6732ccf53d572b38751c329eefa55cb5a91a3ab334bfc024c871f91ac4cf724fae7d17962ad5f05a21de2c44ea2a490c98463301d196f7632b5237e0edb0715acf83d2e61143bea569382eaa6771a607df6120799fa570f32859c2d17a2eb4f4e02050f774dd3791b170eadf4fe489bf798932d6b765b73c487ed0b197f3a3155a28e159eaf26ebae022826912201c62ebfe588a4df2ba5692bb2784fbcacae5c466ac5c9616ee07e4191a0baf0e54632f9e43f8bcdb8171d6a03e5a88e029af72137c9209de65791d4ad5ce6119f71d7be57e42643a02ea3035a5cfcd104a0bbf66a4d32b4c0d33c3309cd5c01defbf1429c1a57373e26027e2ed94830041d148b28fc763c8c1e2938fcf2ace02164bd1151df163d97621bed6f603478af4c40de063d818d71617bc8c772d1db7648d128358f9d54a2b6e66ccbd7e745dfc00e5cc927b9f0a68d8d3fb6a432dcc54eaa93c235047968988a597b4b3183b6e5913835fedfe7517090b5015375bcae838ccbe8daae3262513b5447263723873cfd03293962e0f433d26152f2b7ba173ee153b893fff22b777c7b84b8c11be59b04a4013c4eb61b26f9f553e6f7d5dccda21c3e6ec0a025a5aefbe17d12cb579069f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
