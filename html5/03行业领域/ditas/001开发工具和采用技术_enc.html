<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e411626193f55e0eeb06f1014d0129fa0178d828847c5dcf93a3aecc19d5b21142f9cfe1684dffbd726d662da7f3c26806a191e416e29941da4720a938bb0ff35dae5644bcf0c0ceabea66df6deba2482fa9fde60e27d65da0703b55dda666ca7d5489025c5e9e606ee4bea98c8bb23180c72e1de3495103937b95c2aca1ad8f6cd33a91a30e2c872e95dc2242d286ef308ef1c21fd8408bc94c925de91dd8fc8f8c836d95a658c02d248fd3debe35b876a1241949c2f6979fd33d397aaf46473b8e4024c2905b13f363bf97888c6ba975e64dabe8e7414f9763f7c5e8963d63cf992c963e73fa4a2a72cf41f5c6e996bb74fc41ab3b81effaada5cb0aba59be24224b01381fed59eef4f086501ac40e6b2f47b5b2e0cd7f5b9bc6150fe54c186be54279520c568ee98732d9808d2baa0728066c179011b5faab4bed33cfdb7cfa699b725ca67ae6d56765330c945361382c8a33ad37181e98ef3ef182f2a440c171a1c8e98c250a33af7ec79e3125099cf6a780dd6e1adb5ead37878162cb10f1a1b3f114c7facb9cad47cfd0cfa214259f61f28d8ebe8b41939b1d6d18a6791e16e22111be15915318a33ef99052870223b4a9769735b037acf2cd87cf15723dae273ab87c3676645f73872e34341f55ef2bed24cf3ad65fc522b181ed81da7ab88a7d18bdf52b157bdf35a10894d7a90b45dea6bea66eafb776f73476bf0c58615b50f824ef7f53f09785a22c4cb060cfddfb02da5713b3d3fa45a1a42faed8fb2b6737740266e7daecd8ff0143b594715cccceff2f428c69514d7122fee12256c529dbec5d1a25f7a27dc86a94f128c7ee28c43dabcd87915c91c1a3c4699872ebb71afa02b80ce8791ac5c65911b0bfc7feea9caa28130f9c3c3cf4c2f27e7b5ea82fe61e741d7e6fdead0c7c30bcfd5d83a75f3ac84c181bc09f605edfcb44f3bd6947532546df3143041d69a7ebc8891913a586a8778fab5667f40f7ecf0364dd86d33cd899ba77b4f643c9d56862ee31ccc1124f2cdcd384381852ad060d9d7a66421d6b6e5343ebd829c355a44389fab3f59d717aee8dee82746736a016e233454761541ea2f25f1591e6b6ab9dbdce726d7e0a68909af6b2ca1364c3e57584ca64d91f1f4804562bc820ddd1ba96d5b451ecbc479bf0712dfa11a90367a38ec19c5da46774e4fb128e1a06c8734b535a25b202e0583a81d4a6b13306c936db448441b47153490f8919a72ad12db80c4d06c716d387b16b2f62c212b4eb713ab5a18963d0fb162f380f1716496ecfe68fb2c68fad6d4a0754711111523c95ed437572a7c46688632f95ee8e68cddf4f44c709a437a07b3e1daa54c05a73f82582372636aa706e8d293018d9724b039f470f940418d8bc55a8f8831639c93b78121803b1a98ba8368eb5bfe28b3c2b55cd191824786fbe4917a9b61549534e9e0766f0b8d289a06bb954a60f453ce411308fa9f8ca2427e94062481a76d2f394037f662992317ad8f4407bcba37569dc5773a56b92682b7eb67c48c75c6b8d9612a8d63a7374f565b316cb76cbdf184bf0a4d5c603b7c8c92b51b65b654bbdcbd57d3c66939eb4af777cb6a512b87a82f474b0d324b43a4d680fae521a9998e8f8bc79c65197713a576e9b03e0ae2dd5afe7a9581576eda1d583a5fceb847ae0741261928d85997fcd8dc68957ff2a7fea8d6200c52265e3244743c2630469a80dd7f52f29835cf74f8f32b4368671c65523df24e845efaa2fd30969cac816e32d31e9bd1289bcb5715d688cf02180870b5a377fc571efb7da8f921a66b38b880420f98513eedfebc7a04463c7d37db4be7830fa6d8474326f30ac7fffbdb22c4b9140fc5ad9511e4a329da88e38c8f3dcea8ba6fca3ecb409cf86b877b4cb218af854fe02d360d2fee2a2b38895dc16b35e5bcda127c08c67e231af4347db4ce616833673d96d24380ad64f03c16b49e9b45c4795110cd15c4f9106b464536e41aa0553e7ea63d73cd176ab6f6a154326432ac2264b46268e3c7ecd5a84d78f6c6bd6a7701186678e61f505177ec2919dcbba016ced576b441dfb6d93ba9b3b726789f5a00207d46c5caa782c3b4d446abb3dd65f51d4f3da627db96c7707b39a438c91a9d5361dd89a323e023f4d43bb5c54d83a6becc6be3c9d458ce3783628c581106dd6761c56e7bb5475ab99f9fe9428372d2f7dae0b9cefa25493cb3ae6e2f8050c43b92a54cdef1c2dfd50efb0f42df3391ef56c3f8d7de3b132534384ec224e04db185840509f30e548b8de39306a3e6288ef8632bbd66b47cbe0d791825efce46f24e5b2e1ae1219fd718298fc8a219a08b3a7dad37f77c6711ba8b5a9f55b22b67a2b7945e2ebb9ea26df7471d9d266a80b34666ff3d9e383a257c8799b0f7aa267edf6774c7d488e2a06894834dc59a679eebb2ca84b23d31496674940c3d8ba170d27d7a63b03ee47863c2e2a9676c866d5015a93e9fb3dad6598e018d777fbd800c4ab9a35bfabdca7a7a8b539259187cd0bceb7826fc25c7a2d4d8e54ccdd96f5cc14750eb321b7f60729a645107decc459c8890c86d1782a42e7515539cee1c9ce78a9440cddb100f8c1fa54dda40aeb0c1a7cc4ce00e788930051759d8e252b86c2a9fdcbfca7e3b0098da51ebef70a8fd8a657544fc4511592d11f24f89bd83ac0e33b1b1b6ca97951d83b6e6aef9b2c9772f6b6a4ea7dbfc119ace62335a1a285ec55f0592ab540fceac92d4076431ad17745e25ad448b532bf2c16ca047de2086f9e2d586e20f23e1702c0f92dfa6466fa2b0466e42f68ec573d6bb96dff257c87a4d1fb2fb30cf170a10dfadb6a0b92e068009c4db0763b5fb3dbb3772d8dd4ef7c4b1df7826b84a557e7b7cf50483ec1a8bc913dd0d83cf6967ccc22af5a9cbd477196acc0cdf50b697119e8051a37232b8d35db15c053a17975cae8d0ee62b7bafdff4965f1afbf336c73d621a78aae6866be0e55c61cbc6be0a8720becbff7297c95d2876e7fe1e1db7fdd432c8e8b489fd3f6b6029299cc1abe00afb0eb2b83cad6c51832735485e122d002c8b6837d722c8aaf3e5c6d05e18528487cc6b317a280f14c4dd0385a8e2014c0d4a917a51e6f40c9bd886de3336837dc860ef66732460a36e8bdff8a11fd83b973e641c8624a33f72752adf157df67346da8a977e44807f1a744e77f40624f65b7fef998d774833147586ddc58a417fa5fd86dd575618269c50beb7d91f7dc3106a6bcb9904c80c745eae9b01cd2b8b300273757030957b2911c197075041a70b63bf3f75cf3cac42464dacde13d1c91346ddf97de15b599912809455b7c264a8bf1051ea578ffd2aac62105fa0dc22d743b6eb1b0bb31e28322c4a594a14e83ac9ff6562ceeac855c4c5e3828a70d9927d9b99d0b95647af433b2e1228ca8387a0e507f8d7642884c5490662385f2347acc069a3726c1e11ce3297f766b1db74390357200a1eb4a062094cd9979c7012bbbf47a847c384b50dd7bccbba0553a1509da5044d159c38bc07479fa7ff73ed4f52e1c7ad4c69471a9974d7cd1b539a010d6cba8997c3042110b91fe07992ecccc97e7b75e0a4a991814d4bb50f17a2c1339e8a15499fc05ece403a5b88c017e645294c693a5bfa63ea9c166b023ab705b3a9eb18d3e206d25cd0d41b657f109e081b9b338edda3076f7a6240ae5e8f3afe7b90e632b2d3f4c0c0c520909736355b102f53cc2926430816b214e6d3debd2c9549c9a8b8b50f1b3b01e62234e2bde3e7140af2995b30617ae0b1b6f1c70cc74c37fce311d5422394a914554e94a659fe5af324691fea02b66b1694b44dbe5ab1affb7a4caff91245010e1235c9da6f455666cf9267be80e656391cb71a1e499a73010d66a3cd671163d2119af7d14ef3754aedc24c485d608c26d01fb25547a88b51e825b3fe4d6ed94c436b2e5d67df4568b5624b2edbe97c65c9d5474cc5eefa7d015740f69be9cc56dfa31157a05319e323237f6bfd7a222c80d071c5527c3382fcde9cec1d0c911a97256dd2388e971cc41710e4411676c2f5d4ab0eee5ff52c6b72ee5e65874b082327b5d13363d62ba7025e9531a137d239fc2057deea71fa572b17a98160f57837f1605a91b0fd7fc6c31cea4bb225b5d5c9cb8e33bc17f78680bfecc00d8a9c91a45a229f572db30ed67b06c88ee124e93014026c71804929e4cb28b1aaf82a9e74014404cd5e1a712326b050cb7a1455faeeb6a27c983a97832e54fbd96fef9189d6deebb7a7091254c1709475008888ae5fd2ef93bad72ece765766ce25a3472cfa9e4b319a01b40fe360171e65c9dd7dfa8b35705d2fe0f576ae558a88959c598eaeabd93fab168ce136fc9544cc9ae914f3828043a535423edd27f8171fb90d3c8bf78789ead0d8747988696f97f91e208d1bcba70120e7ad5a6eefe3f710242080780389e6ad7e72b849d420855f2b79f98ec7b535332b3b41f0c3ca21415d9e40332cbb1b5c2ad12e9f26c1c6de6a873479b232e0fada8cb36b559e5827f2ce5b3e67249156fc2a673c1200fe4a325ee577ae60318d261c8782873d0298af2629382ab7dc26c4b4e98bde6bc86b6fc4965fdb598aca437c3d6f374e72b1c0045be4de24754166df3f4acddd4c5cc03f38f98e2246da0c196bcefb76ae1a76600965b9d31f3dd65e5d71e319a1c4537b86b3dae04202f7a37e01cafd096cfd58a042810448c32260636c9defa52abf7d17562478f0d9c0c84ab56626311f7715ab7811478d50538c2a828f3dc4acf2e1e3cc3b356a1ca5e00d95cc3b89113245cddf67dd3e3075b137a32753e210789f5d0a0d4a98c1ef744fa0596e204c25da1eb98743b1e7188111b01c86504726430af6775f475693f94cf172435b0f90ba59f2069ca1523e805a1ba84e11857691a84f2619940c6661928290b3ce9712550300ccf946490ecfa55bff23c1d4c2d153045a41256ca0fe1bbab407c98479b1f6d07e603d4426292dd8367dcf9fcd2c4d605a32ec57b2500bef29844ce3c55901ff06acd8e1d54240e19094aa626a267ce92cd70bef2bc779fb39e5199dbdff08de918b12756a9cf2a98484cb35ed26c3977edaa51d060bb207bb4059cd15987a2a4a121db60d7584bd5a58d6165144a187d55cede22d3e7c80cbb70b605e05f66cd20bfe7775334990d2a177b4685e1887a058a4501321eef9ace5a70c242b7fc71ebcba9c0bac8ddff36f24c5ac63bf88ea9e487fba889f554d85b776bfc7f4070bd36d378dbf70780cb16f2e914d5be1b46a0587a1e559db5c1182503c326339af6af4792712ae4edd307c2c855d4c3a83def8da91c13bf9a05710710b7d46438a0aa9c2c19dbf3d829bdd4e25613a53c119837b4f632b52cbf26fff4f76fa70ef2cb784f0ea66cd70127cd2139ad6f9b8ef216ec88a8f2d42f4243d5c5474e2d629f2f7d7d764f18b7fb09ef757440c383e17d7245f1ca2248166ed2615531238178326923eb5536cad8a40d34009bde520fe85d3afa7b3a593535e6bb788624cace532ecc379b77cec41c5bd72e256b1363e668fead04699c53e68c359adf589ee9e9986e17a05c5b87b05d486286fd5478f40c13ed217bd29e5e62991be6d203092517e576ff7e2ae6bfc693c720f990a1d72f6b85767c44820f1f9e719d9de3f5555bbe6a12400f9ef7e3509e4bd105392fe953f33026526dfe231646bbbcd4a85ccca60008b16d7eea0628b498d7d6b99eec1e64082e6c086bd028bc049e2fcafae7f0f25759cf28ff8f101353613b255a3cbcb6f926bebb4b9dd9c14457b64a22b4536e9f49b1cb29a54d3d7ad26992f8c5c6a513e12c39cd4d41c9937911751655f168713b572748476bd24745b13a2526168d8e02e41c68f859161c74aab01477292dd7c4af6053bf99cf3816005d0beaca0e8c8b83889c2ee8b69548839fc4c5160a6e6ae7cdf3c051d7e477a0c68c7dacf4ef9ffb2caf2badfdbb01fe6eb1318908fae8a3deb4c6e2395e545ade09d91df3f3a49bd959b275573d8d814acb511791b398af11157c4ed1be790a10591223e541095bea9e825216c87ac82abca283527b7dc4d9dc0a692727199b465161aaf5b6c03e6c7101e4bb391d8d75b987c87b76a556177b86d47bc123f34690ec89dc29b2d1f2be3d7110e8c3542caf4819a2d49e7ae38b9298127c6adfa6dbbc505bf3a2c96c19dbfb0c66272a9f9f277d658e8a5659fba65fce3219d72b1278209fbebf2dedf2e517495472a2ef8e29bbb08cd8806dc0febeee86f65074bdb905b13da78eba4ef816600d7d1a8fa126ec5c4db7722c598c7b18630911fb619956c8d4e9f5b33af99f4109061c5c64ed9c36f446ce664ab1cdb8223d74ff6099a60a32108671d10ac7f02db87d60dc5b53325602d1df6ff24d9a8804d36215782d45cf19392734ea0fb9273ccb40b5255e638be1cb43856763a21e0839e1f249eeb92695a580dae239e0625ccb9fccb04d6389085eedd235b5ab5028105392e3bb992f9cb616f71cab2faee850408a14ffe519fcc6d76531237559f8a3b17f6186b78d6954b39b2496564940b27fcb2926aa48344b716c6fffe91d733b437f4e1c132189c74f2d34620120a01b4d77579b72abb02aecda096da33627b07811f8ad07bf90d0ac08cffba3ebc59b93e674d844f6fa14be5888f17095392b3e61d686a4a02ef55eaf9246b23af31fa1e21b65eae6ab8a75cb88545796aa72d88b99fd95b21db2123662e7633d76c8109152dd6a0c4b053e58fcf8054671b647fe67424b0eed623bb7b7c262fe70ab42ffcff764d4bd86052a3e9297869097ebc823ea27bfb0cfe32a39aafad02df8d0ce36e1d0da79b4d08a22a0c8320b388b415127ddd885cb89beb11e10c0904b4b24ab44cb466737679d1e3dc3bdade71d95d9228b96cc5886b00e9138bc75d2fe2d551562b153cc3b74e1ad09594a8e0182bb41774ea99505fbbe41fb4efa3b4e0a7a182b2ba0bac4f44af241c5f10c9aab9cee625273bb6d3b4cd96c5c17f018910e6c9fa2412fa2fc2f28483a3d0851592b9c3d91e9723e449f9474d3605e446903e9cb7d1b05685e57d869c56792f08b99a44de88adbdc8b901fe39008b65ed5228253e32d923f1c8dc97439e8815a6fd2debdb9dbb63d77a82b4ecfdac3f8051c4de68e6d311536d6306c404494e152657379f7052d5b766d7f413bb30939ecffcb43e71cfe1c4be90013f7ab7f2116a782be1c219d89e167bd2154a45b686d2bf22c0ab22e51c7a8a6460dd0c509fcdeeef8722fc960b2a1cce29ea906b96951e798a8d2cfcfd34454a05eac7d2b862efd809e20be7552887562a7df88032f7189a3849cd33be3096e24653f582a9304d103c3cbe515a668a2a5df7e46eb8e9db2f00993c2503273e866cf49dfd47c5baf8bea516a2e9fc16202501af3eb537ca1753c4d8066a02d46adc0950446b38da428d4299cb5b5ce5a25db58a2e401566b114a905657c32e779c7df9034e332a38a856f472f8d6d72b3cb76d1c7a36ee258e68b0c8832abc906937ec71de677fcaf95aef00ca7599d8b04184cb11bc8b7d082d46f89f864ba92bb11d7564456dcaf69f2725dde922b9d3b0ca3a39fae68c400ade52a10e2d7ef2fe284f4fbc0d065b9968923ace482d4cfca404ae329d79a08f29b3f23366712bbab6f801ddd349ac06b733e4e5dd63ca216be2c3ace791b5ba003805b6508048065ab07a90f19721f343270647ce2a8cfa7de7a36b054daba0c906c6e308daebad78be11777787b541ac1617c46fc4adbeb652fae6f923e00cdcd3f7c7e4bce5b81e805a1be668dd6cb043fa50be884c16e019f9aa0c145019a98ad283e8fb079ac54f0246e8140b26e8f0267f29376daae8aeed4b75a8efcb659b75c2e97fe50015d7caeace2de4c5becbaaed92641a6fde6d8601f69f50bfe1bbff6e27347a07b32b342b103c29ccb6c5098ae1d296bdd83d0e9cd3f09e75dd3758c5b951216d1f6a08ebff5896f70e90b7b4276425e6d561e936909419e47323c681f4cfb1f12fd468605a1b85f3958107bfdafae32606b2a8c799360b852d5272a0eedd2c4fac327e3887523488d7d448732602b30ec8d23e500cdf926773fc9cea721feaef3d528576eb3959aceb8e5897f73fcb95def0fc447ccfc48877eb5c3195fa026af3be6cd1d5f3e9da68dc07ed812e62a0c9d06788a7df4357de0ba154507a5c6e94a9ba858833473de196f0c26d09de3485d6b99d27dc034b97e06a3d99f5895e116424b5f8597546f2e3be4b5250b45afa7a528c25f00bdda5e02ebc606d9a2f92283f0e15abb9379f3f0733ac8c168800a9c90f0db4905a624e04a35579dd4674bad9537dd36a57776025c98139b48d597363a918744a9987931c6f237ffa4867aaad6912222327e85ef8fa3ecc46f5902efa3b9024d3ab626e698712a5ea0ce0620fb025684748169185c0b2bfcb4b037d821c20f7391a110805e7d6882ab0272cb8a6e4b2991e2c4db9dd3614ddf5b131960b2f21b06073b689a7696c5f549466c24ac4465dbf1ff1189ca66893c67249c39df644ed04a474418fa5433ad8a63b3bed82edb584c5f8557a05c18421eaf3a65e933aab85f5e6d04614ce3e5d77b39a89afceda04f8d47131008af326ad009d4a5550b3dcc3f20cb76fe3cd70752f2a4404663ea7995ca997fe849209b0487eea64efefee4c4e67dab57c8f1ed121776439cb606e90ec40037b34d217de65ab9ed5e367f263adef5a4bf3c2bd15378bfd1bb5ee432e72f554d6bab0c61fbcc11403d0d0a9660cce58e225c0d69943c4eb21148aeccba344e846c4210c7bc47640f1f01afc84b879701636147958b3bf055aafc04ae17b6585d0d39241278e37bf74493705c1cef90d2dd9204c851140af0d98418e71c406d45b1d3d67261b852db34ef8a37073c1dd7269e3d95a137149a7607e531a3d69b571978c8a4c19f081e7c50d41bfa60f118b1aeb4420239a6faff8425547c96510405e524540f29a67b55238010c73953e7d09bd11e60a6dedca4a0053e428e869d23b1d9acd8c77122f8ea033be4f0808ae40dda35f8e7d9db9a2838019f66dc601624e35bfd260d387e5adc3ef7d0ca0d8e88728e691bb3524d83c45394028f772a99e78c0fb4fcd3b1ada6dbe3addd8b7985b80c601f997dbf63aaeee06ed3ffcc420fd4a6b924067c1a46aaa0749085194dedb60004e9c61a4fc68540ed01e8b4b89a2e0917de9903370415d0496ecc765522850bb1ec30d148895c596cc845e7f9ec0e4fb3dc29db67a69907379f59792a2f275df1e4bbff9e03c15ab27a8109f9c1de132c607eca6a94fee9de9f9f235b2bdbe5efa03d33d08d19c83e710410de78f1efd597d8d10b1502b6369fa8a754f1a63f767e638aaa8717e06d0e9a3a5b292f25ca17f79d21a14ab2b7a7ad6f0a7f0838cf098ba303ea24b2b47694c9c1f2f87d2a3b73998301d9257c1a198d948f09478977d0171d08f16b9a8dde3608412f36487bc05f27da291946e98a48dbc8f79c6b020ada4bdc84f2e40b63fb4d6c378ea7113b1ddb77c8ca593526300833cf5c50c11fdf180522a537050a86edaba18abd382c0077e823b7239b9538c2f68bdf331f1ee0f70818a8a8ac1aad7cde45821c1c899b7b2594a954e9ce16737603c53868fdc825acddc8a45f9d1093187e6d4a5ace54388001343dae63e254df81d1cfe84478be9369a64d7a3b42ca68be3831a382fe849ba7dd4f7a3cd6b792791cd917c7d46ae026356b1b72bbada2f726bb102190955d2367b817e76e3b0b950cb803a4775f7effe4b6adeab9011be517e05a596d78814618b7d2275c75712effc0087704b4decd68f9d40588b09b8c9025235e1d588ae43178d2319e8d4a887ee2ecaa777dd56f902d0bb691ab358951304beb4c898976274ec72766b3154fc2b39e5bb47753398c1dbb31a2005071930b4514176e3541390a7f0835424abb7de1209096b977854bd1c46523de360a189cbd80707794be2220a7d0ba28fc93d99902582836947cd36cde86390b0633c57cfebef2f54e6eb225ab66de191e30c0cd28db566440f3cc4c27a7781788ba1fa948442322a106ddd5d012fa3e7aa8b86b7cddc6d33892dba73a2070a30db7248719cbc30974bcff92d9b8f7a02e1e6f0f260b1b68d3fc70a3b3c31e32ee0d7d5c6d47b25a0c43fbeaab5d07f1be8d1dc43cd4d1aec850b63f38389ba6d113030ec03978593e0d19cbb155f8f9598378891a80d8aedbdb755039f8851bced5d0e708a1a2a2651afe5a1f844d5c0b295262542950dc34f48b55a9ecc791137e852cedff6eab271b49e2a05b80adc7075a5d2fc3d888849777eaec74709f8ebbb47ffef6264e68fa69a68b27bf4d65b866eeeb6b594e1bbb14455897fb9250963a67b3d34a49544914cc362a2eefad76e2120c46caff9d59da95704f23406b3bfdd377bbd7291aaf2b9417be2cd0f28ffc57d1c076b5314a4b5a1679931ffe4c5dc40774c06afde5fbd826bd570eb39d395278db0cb8ef9c9e9b73a02cbb68bcaa3b08a8364c12321ab06e64348aa85d3a27bc327668711a9905cec7eaec15d2b0113c4098c9374e52494dba743c6d5813f81693368e12c61c7835221978837701f38f9c2972504483cafc208ad5bba789228dc961e0954264c01561c13608e4d1aeb694c6496c31642f66b2e3ad60523f7de743189c77c482286736a398e33fd75395480c1f150b211f104799b7b35b8318ac7307d3a52749529d0bac02a3de0e187a520de644888c861e54c1dd96b222621106e48bb857ff256e8a57cea48b508acf10efc9fdbd443cba4ebfb72eecc8871a5220741b4d94c298c7eb5fd419e627f9c0c6c08e7f601f493ec9385e7cc096248a5cb353ba1441910df4a2d6a25ca1f33185a7fe2d29f39656c4ad40363b77e8f1d91fba01665a4ae7ddf8778a4e3a60343a61a4cd401797303c0bca70cf916171864a748c2bd6879c3e5a237a1dc73df773867459c43b3d10b23005cbdfd4f42f666dc887fc70e0e39778b3ec19d4f9acaa6f89d106958d5aefbcd54b88fe557585b844fe427b10310baa3b933b508338f8ce6791c094e2f9ba283f370e9afff809454c41a73db0bc1345fda3af87ed343bfe638a6f6d6edcf78080d93f6590d291b5cde30024363511463cbaf1fbd0d8ac1d17353b04062e703b2961fbc8e770b77299a5dc1e36a61c34cfb8501d9de03ae8a5cec0ce39b20565ea80da87528c128578f201f7da473a34f4a4499eda59b65281b3851673eda9992384b30bb0544cc4ab1186f72369e90f53f71764e1c306657cada232b0b2a1700fc9d04580a9a5cb93b820e7ace372172b4b8ae60eabbdc4d136d8e6c0e945c77ae9406187cdcd06a84ea35f0e3d125abe1db059db8d12eb6e5024bc6b5fdd45400a5385b788828a73cfa454484bba37e0723d0d8fa82580578138686693d25d78dcc43fe59c3d9a02b40c89c8c4f8db87cd1daec258c7065442557baa10e2de481b8f257ec52903f6ea4106205a476107574c67ccce973ca8ff5848ed6402d6730bd7c0f2aac7c38e9ef30aa427bd360fdf2f6b1d75d29939f0fc9d6f460dffcf3b6c382b79bbd5a09aa69904702ea16bea32a95f4d0a38d1a93835577a5a63a2406cd49a40cb78083883b0225b16ca8948c635925ac0f147363a077e8a9f437630ead9db6a0eb7a2fdabf4f214e0d65ab9d15d55348dfba08fea9673c135e52f16bb26b0f81dcbe413729b8bfc74b6d34aea01bdaa26822b36400251a68ae46a4566f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
