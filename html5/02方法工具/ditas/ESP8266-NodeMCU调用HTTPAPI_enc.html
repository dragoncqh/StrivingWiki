<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc80c2d37b64d01a02fafa83f8ec9b430d0f26bff011dee9baddd9a573e0dff5d04378671de7c8966e052a3663ba60ce9cbb45eb2e20e8f53a471841964e843536d03ebea093bd71d556b86d569d973078b6b4d557641a03774bb5104075f46fb88a25500ecea13ce3833f72b01af9ead69bbdfe8a95a60dccf662df230554a2be7e91cf15016cf76f336c128d4b7b9b213b90435fc05c6c8f8b28a0a853ff169914b76db2caf788b58a8046e6ff6fbce4c31198f98741ee3d9d17691838bf7f25485e0e286487ffb241daa1012c34d8afcb7ab899134af0c2e41cabacbad4eb768a9009c616d1281e39724a53fc2007d49150db66fa60027e798423a7ed28d9f8f61c969dcc80768fb0cfc00c2c9d02c48e927597a67d3fea7f8b4db79d5936c8f3774b73d21a488c254a342cc5f2d39cb3fa020a0cd7fff7395a9c5f2881d79c64d3cc20a17c170414b0771ffbc4f00c9709bfd6e11fa40717bd8959379289eca809c6aba38aa2994f0f3170ad1a5e69b24b99791ee0210cacf67c35db7676399c3651b229fb807b3c8bb7d306e1b299704a47988833688945aa511ddb8d18aace1902b4474a7847dddd38e974dcceb2415684ba73841847c8ce611027f3a92342d3808a2b42067af35f2d8a1bd5cb8c9882314dc05bb17fdbb5fde12c169ee833b9959e4d2a52243852dba0771026c93bcd7a09c3f13c2b6884db21eb2901b2ab152dffa6fe61b47fdcc01a462882bdde0731985b5b9c1909f26ae4ffdd8a5e915648bbbc73754031818616a8794985e6f3d39b156350e12250784a13a5a2c487eb37b99c0d62367cf9934ad205cc1730be69020c89d082e342e5fe415ee3aba1144bcd3a2d6cdf2311a922f8e06be5ae66ed8445ec8e5b1d02041c312a6835ad043e0af381cff9b588e2d685132efdfaeff1a69a415e810369c7174d38047f59d02e0d63eeec9c311b181f0b7c90fa03ace6b49caf650b8ddb516f13cdbdce78805fd1984dd1252af5e2d2c4ad3e47445aa5d2ff015bb208a95c02996d1c23602e4b2e1a16920601afa95effe0f60ef579b9e5a646a6dae7cf67b7dbfe215ee3e23f2883a3fa0aa062bb64feb30cbe14f477cbb77230cd2f314ca9d1186d9ffd13290fd4193c56b7ac8b30e54ddd02b647fd72866cdf4ea7f40da83a0a963cac2ce25046b20996e0e4a8dad39f2e8b4e5c98e7ea370b088bb6f1cfb3569e66bac1e5e2e6df9f5c6845266215382c04d4550e8434d9dc3d622e2f4bac13b2702f8b9524a16b4820d99c8ec479dcff6477bf8591b9bc2290f6829c9d0d505f6cffe0823e00bdc6ed69bf6cf0411e5ded31f53dcdfe978207b7ff9e00553552dd7ce7af6d20aac6d00fd2b917b06e142be383eb7f1cdf877edf418c62340d687b83bd24dbed7c9e28c46023814105f4adc8b88ee487f1133575a83fcec9c73f06a0916ad95a7630dfd4797cb922dce3603097b467f7937a00eda6c691176a9a3dab3ae975e74db72237ff392ea90e7afe71ea0aa1bfea8d92c9bcfb64e5d16708d92fc85f2dc9502659ebae29231979db98e9e5f83baed17710dc785c39ce79336cfd4a84467d14fbd599e7d577b7112f0c9e9050b74964be3735338a17a7495bc45c6135d27f42070443fb200890b99628ff67c26a959b04d24b86507cc5cd706554cfa98b3f7dde7c968ac5f42ef8ef0009451c634ed5e0a9e47819e89f1786da5332f8673aa1610f4889c196429187f59f28547432a20df2c46f6005268842c89f10d2429078977f9d6cde4061f0c39449ec1b20b572728bc8871ecef0b6f207c58d498f77339cb2074b870dc055b55b57157a80c8802187323e02fb7d1372ca8d954fcecb25786d78d0fbaba73316380f634db0e5a74d6ee2b658d68d8c06583284d47e5918054f896dd5baaf15edce70654b182d94ecf83524360fc4d02449ab1b93ee8157fca61eee32069beaf7f7befcece4cd4618b95ff40054f3c88917889e7d047961e695672c595f937eb6510feca8a05f1151b64f587d2255d2344e01016cb715bf45a49430a64c5d241aa393e88a2a845c160137f73588d39622f831a854956c0befc6f3df1d236e629631f3d8652485113f09fad73bc931f9f0086807c0af81efc3b465960fd13f39d7a8e6aaf6ad283ededec3570e5a7ebae698f89adf15449c4eede0c777318388aab3d0766e3802d22bde83ec86e92e30e7b1c02a4c0827cf84ab5c31de1d4524398854a35853ff15c9c7d58dea6cd866c6863c105a01e061e41e854bbe0291a48f8d4bb709f488a25d3681d3d95f26b275f941619b12c2fc9df488f8ce4b25a1d256d3815a7dfee52d811cef1f0568480be38c559b0a27eaa39272a7fbab44382e898de65c98ac3a2a3b3a311bd0077f431e78159acd4e9a67015096731f4099879dda0a0383b73729c21f89ef70664a707bb09e5bc54ccb3364376e874c4dcbf10521a57f47396e2e3f96892d3598cf869bb9f60d036e471994ee414b5a027193e2d045b83177affa2e3dd42dcac43c8ecf9962397a711b23d30db704872ffd4e6fa35f69bd1db44dd7aa991cda5b5fc5335e60297a18578b50bd5140aee75cddd27f8d5db60c50a961f1419b005a06a084e593b0d3e0e02e56e21e14537c512e648be2234c7f9edf30520db1ce7d7b06ab023274211eebb465254160e8cb3d71335128722a0fa948f2ca467907509fe1e3c06af2ee5b20cd26056b766d43540522c4a5ec0bb6b358fa45caef3a5e87e45a2fbaf30208dfb210a40254a680b0ac15e94b9b34b6511032a512fd9241845df5b11aa7f56144cffef508a1db9cb68b8a712f3f9c39305320c5c9db132f2be0805d2a51cacb199e217c270410a1f916edd762ff73e46934f6445d2b3512a88d9cfff4e97057ea3349132d09f1308fd4c160229ce14207f4a97aea736f0b4fd87c4d3e823e395123e30b2d5295598c31dc14e3bf3c8b4b862fa956260320f5988767fa1274ac66eef8c551fa5dbc71c5b767734de005b43cbf5647f3efbb37923b59e07f0ee2d197fb21a886c3b5bcfe6e0c7ed47abfe626c108a1db0f73b0b401a0e21e190b295cac4ec266b1bbf4dcee9bd2de75b8f75827c21ef2d11ecec3696966580ede0b26b3dd5a59aba6db0f3f7be3368499209e17ae1df0be1e98b0fdb511e6ebe080fe3374a312b84325bb1dae444ed3c11ce495e8e5aa98066803377612cc8717874b58a2b25ef8571546b3cd9f0e2d746aa013646eb82d6124920a0f4ea01526fc7977b0a88d217488c8d1fda09e59f353699969aea20623b0e28cabdf399be186509e42d621264152905ce61a47db34a59deaa6f80f3eb9dc6d3eab940c3f95d8b3c8e8647f6ac6fc12537edaf7d83cfeb8ea35896cb229785cba8f62132979bbf35976b1c0dc5ef7ecbd67cdacf19c55eb4e1ddb8b210c8a55ec20ddf8799719172cd0bd74728a94d2c3a4e93d75f3aac41439e72f3009154228c11dde09e9342809350b5fd0b2a1e81a5b858a52d2ea60a24ddd75501b998cc25d459e71b311921ab85f6e2f9733e145d52a7f460fb2c1ba052fc39f3957a5dbe9647d6de2e2c9460782b228650b91a56859893e512d44aa2c0d5e733818f79e164f554f54b1a5d95449023bc3e8a421ddf236177e7d6c637db5b4a5b8b2d2d3cf8aae6acf6c3a70917324da9cdd59ec6bfdff66522fbbd308112744d58f8112bc2f76a63022e972a08c1e8d41dd9068835ec4f7e08966b5da37c5a77eebd8f697dd42e5897b5bf32b0dae2b5bdd9548376c8f939bf7876f0468a7e8a264900be9e3778dff88e1d82b03409906ac5c9cdaa62a48dc4770d69d9bde1022791a14c61587014711600a27981bacae79801ee5f71793ed2acfc7256fe66e09db2481fd076b851c79bface902dfabf04a0e19b6d4e25f0b7f4b609f9bfe9befdb640b2d88af883300a2aa8b160a754f538c304977becc359aae719a622323e7c4c3e56db9127fa57cceb3525ce4e7684594bbeb0accd69df56cee8586f2a5a0a4098860af186613c0998846f552dde1f74b784e739aa75033c052361a4ef612d2a211c16d0478301b1b8f5f556fb63307721c18695f46b957320dc5e1d2424725aa00d70941f26e440fa175f16020137c0c6771d36036b3e7e3b35530d6b7d1c5f8aee05d451d9d6d765fd562af9a8ebf400824e160a47772115f3c60766d6403d81df76798125668eb36de2fb6fe647d271a1d634c9694406e6acac19655d2aa6a3e6c2f8df178b730cffb68b9c87f296c960f0a7dea401d5a882734a0e96aa9b6f364107a6010e8ce55986c07cd97c8373fab77341fc91ac8292d3fc3b079c3aca47e37358e7d9118e1829e70f5d1ef0a9a8dfbd5f70e9c15a73188e54a10fa26ace5fc9a960586f7fb635e7bca45ad1593690f3a6f223fab80bacd5c3da4fcd584af9e0058933638518dbe035a9bd6e6b26304481a89272e929680ac7e912d0407b6ca003d787606a4988a09d9946c9954ee578708f9ed2e77ee861e083f37f685bcbbcd17f6da3b9b87275c235bca41e3b7961dd3e01a9ab0899fc1dc763515964bde007e076025e37b040e6fd393464a9e5be70233178b86388be0332a47fc112d6751423678b702e1639663123901638121da696f21443432f9f6141a707f074bdff8d25b2ebe9800038ffd63ab11cde39e0bedefc8b78bab4e653dbe07a94eb01b52ee8cd2a34557dcb0b3c1c834f62b26147cd2ab064a2d01b80c9900b84023451731612109964f0b9d2c6304572892d1baaf84ae633c3ed9061318a142f5fba268f14b13e5d5a7138e35b6e85a868359ef17f3b25105a5c39de1d7ae4eaaa168ab3c18ddcf76fc124b846e63b65c9be602cf37c45f981723cda0ad5a177d71510eae532507462c9825b55deafc50d71c2a6274ac6055f59903c3cfaf3fe149037fd68cfde77cf2327864e6a456f7c99aca4a6d2601f8dfb86a846d4c450e5e606483594e727654a37f9b43749a81f7a0a1bc8655c116dfa03acb780b8cc86019f35e5192f25b16f4dd43ed74b834abff396fb05ddec6105d522b76e732b9d65e76510087e3300efbf37a7e0ac6154bc5c5b09abe3239ac4ae33bb04ddd6ad86921ce6b682b0641ede3413db0a2029df924b34975b9f880514129f04a3441dfab8cee4f6f611d4fc7e055fea87854c9aba962a0f8d35236385c21fc883a99d28c548499dff4223b3db88d04de8eae5236290c87734726b072a7b088e7acbf1c49362f779fa5a06942d4c90daa77509916bfa33d28000800388ce018f3d1a03d3b29abf68f1d7d9cef414396f56b9894a83b410796a11b2503f0bf63c01607801e0d93f5ed66f491ef1063857059c58be5195c0b2c0c5b8caee4c3ef589dff0062d5f33575900b179e8453d2f5ac42d867c548ac90dca79c2eeba62c9548c02fc484ed7193c3976f74c2404c94eb74e3ab81fd616d7743a9da527abe0d86626dbefb7cb1e83899e227b0c4a5d237bc84f150eaebb2ddd9b8f08b1e3244223c680cf9e226e85cc3c0517396c3723d8c42665a572729f32b5c9d5991bcfdfd1bf4aa2389244d9b4103f97235f5f2cd53d3bc277176fdacae4369f93fa8623156d56fec14725cb351082028287624d2cf6f5a7dc8e00402a7d2f18185c433aa7c86129d4afea0f268ae165ac0f5b62e92883674d62603f38feeef60ea69d7ffe2334f6c60f72b989d2e2566b993d3d61b4351e41f57c422b92ecb0cc854f23dcf83f860da2660d7a4a94f8070190bca71dd8f30c4f554a73e32921a9f91e4c648df6768499d0f0235b831ebcd31cbe374ae4a166d79b20ad84edfbb0b8c018f5948cacc3eb3e0c396abd07e2e0ca232d7e04d8b46c65dab5fa7ba11e7e6ba086820dbed6bf4fb5773b327002fe65b463e008748afcd6ef224890dc64236ac963a08358e2e996c7ecf933f1103eda5df47055f9cdf2f476f134df3d21d5b33e429204b060f7344c01c406be2a4059ded136d6316793a5c33d3097506ce91b0bd86951d154d4500af0ccfa16a0fa4deded48c599530dedb2462ab3f0e84c0dec3e5e7c1174806bbbd49ae9c2d861ff457105cbacb272fe43c60b55cb1ad2cedb180d4c1c4b565d9c3310373d147489dffbc30105ffadce2a12d2c2ae0cc9a58f8ba27b45244ab67d3f3f1044cd71aaa0e2da0ede896cc609f0459072c08819d7f07a2c708bc576ff93c3ac473339d405739df1e1ef449ded4ff8f061ba0a26b206fd73062fb88a45bb7d223bbd2581f059eef0245170a4ac6fc5b053f7a2f89848bea16a7d8edaa87b099846a15e710b3c3b0b377599c33b85334700abe7fccc92dbeaf2e2520b3ba3e611da3c1b6a8dc208f8d26f3a6fc7563576d6159af41cc77eee06ffd00d1045b43c10eab0fe5a2b349aed585666367e20f2b0b94a358647759d12728566cc789f90c022297afd2ee77e87b61fc46f1fd87da18072f02561768e807957182de85ea0819792f2f177334b3b44afb54b0024bc9394f9558f16213e3ca94015b1a700c941150dbe24bc5f7a605aa1d2e5690cd087e7c42c07b52cffd3fd93d187ebcec90ffff3d49d38bad4a410da913f79d205e92c9c180c3370b0d5d066e02304bf4761455805f619ad5dfa04316aa5f5aa40e59de8e792265a33955ee7b0eabf2e06a08fc6e15181029158d7767aa06f71c90639b67ac30688841ef93c7977197b8a1d2d07e710a0e8fab875e56456851f87b23dde79930a881bd621dc53f9d3b747441d82fcadf98f23196088d856068cd9f53ceeb70a51f5ea678db410dfd43102afdd751de9d95e8fd5dc9d1ed8d95334f5a5b22e838ecca6a9248aa32dc6dd029b0163ebd2b2fe84e3da7b225de34655f9ea985b1cd0a1f2c2aa28a0727bab3902fc57ecfd6ac865b5d01c035a42da9a20f21ac35a4175f34437dbe8eab2789830802c0eb4a4cb7fe3dd19af9ab157199f50a5ce2b20f13b6498a3800665664fed0741d5f02538e1d5654f0aa1997fa0628f88a3eccf2108b590f4b3c3388666f40a9e30b267ac3e14e5a55ae0f6b1b9168c5ac7d5452935745c50aa6d012d09d2ef3cc8cc59ee920f165c6872128611a029feb4b10b34a36880bf31235bee9c349385578db9de2f33fd70675c84710749b73b246a0bc320b91c21e587e3f40a05ca6f495e42af63555cb0e2c59dc5ba257a48011b97be469db861cd44783db6faeb1ab393c4fd2d1d8babcc0fb1c9f9b9517595c4494ce77f145bdd1c174ba0284e15a1d4f955ddbb69ca5b9aa485b03528b09b655ae9dd63176cce57583e487b06770e4eac832e54419dad43ab2c14d95e82da9412622c1481523ef06fcf7f30a766731c2dd00004c9622477b3eb6308795c9658cf6c7679309f11d560d54c9f0e794bc6ad97a5b11782010a331e8e6f37f4cc80ac0ed2d276b6f7d9ffc12922f86540c77c2fea9cb8bbbfd1b56ff9f12a48909ea961aa4f819569dd8807580de5283edf2af98b5016ce50faca9ca8a4695ad1b268bc319ce92839304cf2e77331428c3d68816650140cb4d67c194373f381d2978fbdba20bf3c3af54c213e73435903408eecda94f6a8bbf74a4da5dc21443b82424ec428fb1ff127d4cdd1de6ae5cad62fe48d2ccf9f22c523b613b1b7e6613d1d5dfe30079ccca12969e8c8a6ccc991e314bbf8fba40efa2b014a63db796472c60a14f382984263a7675b834815fc4e1043c7fba9bc9c6e1d44ceb5577d82f1fff5b42c27ca10c778a3abee776ebc6fe750dff586cd9df9fbdae847f17b910eb1626126160c00da4b274f2f940c4cd77b322267f89d6af4d601d0b39b5b0d1baca4de0014607a20b4380b6a93f2d5727ae0982cd35daf25aca64efdb0e917d2a4422f7e2823e824f569bf70b3ae541e58e9903dcd180444c3afb5a213b5531098626e8d9174059508ac212573e0de9898108f0c609988f06f641181a6d7a79fe8848e256973d104369e5bbcc0d2b17475884cf5422d036667cea6e913dd44dc9066c9f440598b02efe71b84fe60843c79f75e5dbb748975955888c6dd7e4efe0f9d1c87d2f0e80a7009da5e8740768c64c52c5b5d0146eff8c3561be52c2977553c6e386784be3b9a56b9c30bdd4d5f30047155ee5e9817f265fc336a7f13b5cb81f5642b88f1b6a9a4687232e7145bf27d509adcc8dcc0d757e10c8df5f026b02f23122dee3c7d5484e6e23cdab2210c8a48b2209fbf633801ccc217e81baf2bc12d450235189237d978fb04239d4db0d2bad4c6d317f18463b6cef3db6b0afb905ea5b5e7f176c69554bfb260c7b4049af2cb68ae611194ac0f109bf5213ff72c518471dcb2cc2979ffe2a1e5e5c7cfd7d966cdb0ae9607d226c937f7a37f259a1c2a4917cc8c2b09291feb32b90d064a721dcd6dbd04fcd15a7479d86fb72039c620399f408af2a18c0cda65ed3105c8283ce9a91b9e4973dbe0c977190a5ddffaf066cbd987e05f980584e21aae134c1482f77e9a380b741b372e742df60fa0ca8b1c296d3bbb08f2bed246bdc520a18053c788fc07d393f3e2d002c1a9a97f346d14944b54a5aa696f6a974a567af715a9ed07ced466b7fe9dda96954c30363c804ac63e0fa99c9f60a0f21a7efbe9bfff385ad2e5c1eb740e9955bc581d038ab9a41ab7374bd0f27fe33720317822766860a104f8d4139cbbfa48403e3b0e6becc72b6ad07f5719a702aed40f5193fec37daed7b17c4e847728c2773021ec4287e43449bc87ea6ad7593b93f19e5d908cac80284fa2cc3bac58f2f6ba3b5856a7046574a76064e9b3621e010619867317d06da70d0ac1d25fd2dfd4ebbceb7ebdc547bc9714975a0dcbfb321b688c785ee086ec5126c84930484f706ce9b3c5bd0d0d16961a55fdba795a39d8b39dffbce18efd0a8abed17bc6c06aed4d89af273c24296b3827da509995b746863c65c727c7099a9f1387dfe5c2f47355ce5e8be3eefbc0f0c24ebbe96b28e7a0468e52742217fd5b7634111bd61e01cada949b09b784883476a1bed0b670c833b21521f1c88c86600fd72417366b2e39cb27d833c3ef5240966eac1ff988ab1b3867866b355559183d35300d71cf2572752c9655fd8e607b33dcdf3a63c76907404ad2274391950c93c01ee9b50e931bc014d7a8c8a76541ba4c9bcfde19a9ae024bbb2170044895a72c47f5bbea9bb0f97c196567dd1d6635f0f188e714a70e45f1e31ea0b483c8e03ab24e2b27b746227d5e921a485e6fdb5aaf00a3a436e296927f9528ee5e3f831968828dc67d49e62ad212a0105dd6627d991a9b3d7ce2c744d7330720b0806456b9384a9b4cd32ad2b9c728a3764186eb54387f6857b3f4d1fffb722d51ef5323e0885d89f94f3b8e7a085d660e11cbafca817e21e16a97db011773ddd9c58bfe8d2bb9b64db7fea0f4c520f2dc7fa63179ca7b1ca5f0d8b088e81b3d2fe4ce4e30d37e1f4c53b4abff576bda6fc8f8490e2d307646e62f9ef94e2c7b260c562e15a6a919c2562a2a13aaec0e84ecaec67965b866f1ed97593c58200e5449a478aa54f256612ba5102dcb6327ee6baeb097a583cbda65b1e1460d8bef30ae58a46b4e9c1c85c7deb82349168baf5b456001a617a4c62113a273008f2ec99e4a53c0e6c53ea67ae90462f9981ddcd8d7b198a6add5ccbe527a21b53babca75faa26484538c3e7079f071012f52dc27636aa64b4b98e454030bc601fa628b452c8725715685a4a90136a5f68fd3ae41e49fd5d44680ed362bcf54b456cede1de824b277db94be9aec6e269733c1e0e909e94afe55df60a54a27c6a6c3418bb0a0b830b90080dfa909183ae2b30caf9394c9f3ec90b9192f1e45b8b89c66cf4c84d1acfb3688ba7813a38bfa5a93e67c07754deb40e351608e702002a86247cef5c395453b6768a895a87e201a3aa33933be16a74072bfed6c0f723cb2a56ac8d25b21ee34d46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
