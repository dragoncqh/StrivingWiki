<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46c61e2078433f4b8436966706cc2fc027a82ab63e0c98d7fffa0c43fcff9289bf0b71fe582fd411a99fe363fbb41916d44a583373f2e68af52d364f6316cd7c58ae175b28fa49d2d5c8882fcfa097530411b968d2d907e69f56c7f0c02aae15391da78a5ecb4e489d6aa2b9c5eb9d205c2999fb40a288fefa887dcb33de945e17a1210285d0a9ad4310b64a238a0af1616a8f08a57b73d7a64113d3ef8e8edd02de83725c9b38678ecbf41f94c436e36651d96a5e1b58d635983de0304980767b6c065d76617f85b2826c448f2693fe1b847e22662f8bbb245b07d6ab008fef229485705f568b4f8c6706633c2e6ceab4a69d4c2ba1e4a4dfcc020b77015f27f0392f4532cedb6f9c279beeefcc2c60f581fa13086ef907723713933d4ac2102652825510cb2fc1ae27d9e70b4c8ba593950012fb406009fb468c88360cf6dd3b794d09721f9c069e01795317b8763a263bab79d09c5ee65430eaf30e7f0090e766b40cbfdbe390dd27977e4cad2de794c1ef9009179222a03974e5731d0be24fb564c18cdd78be6193e88994b59ef7876b32e000d0d5e12974de00b7fa629e5355c98b0f8c4677bb1cbc36e8cdca75657769848bf6b06c8ba3119f0681e77658547acfb3183f7a5141f339a262836ab7e3672d2af126b8a2c438460cf76be58ea1841b27931e1d9e3b86a79368a3bb8220ab8b01c2ac781afe72fcb7ae538fe1e67f81b58f926199d4c1a5a36dcb2db3fbf3b3e990c7d1f52b46cd44d5e02b63132d424db2250e7520d57cbf054cd16b264298434b5d2d7fb129baf4928c740aea0f473bc040d6b14f96c63a0891324c1b68a71efff6598c9608f98ec433ae32875804ea3e7edb8f0d9df18929edca9c8cb353589b7b9ccdeb814230ab79c0ec6567c8f4220ba19218f935ef661bc33abe25ee772fa804061869542d6a53d483c8c0707ea5a88f9743c42132e595dcaff9501259d13d4aebd78ae1a86f9b554675b170eb7181f9a8a3b9daeb8ffa6737d98f25b31e1d650f3a9f03e716cab05d6ef58a05214e5490db677b2cf81072cb472f46b9dcdf64fd49035f010ee835a21417b5f218eb08ea408b7dfaf12937e421b93b20e780f6dce6b9fc083ad861f94a5a19e0c68cbdc405b0df6e2ed85e7706bc68b9c861e416fbe4c2ac482da0d3767924c92d8390f64ee9dba203d0286340bdecaf654826f0bca06f505aee91a3540f7f8830712a25d396f8ff571efd3ded9bc656e8b854ea5e82d1031c66596257e98ead34004f4b55ef90627fab0b4795bc10606dff423897b83772b0f447b3272f4713d55b233780adb071168dec8f909a0745428707551681fc9b6b1b6dfb9ee75b3b02913205648b1897ed40529cb432bf298ba9faf59f0e06c3e27196c850ddf556ff0d31448ed995149fc2b4b6b46ef130b3242f4ba0e8d3bd31e4c9fc4ceb4f8060323a879cfa5a9cef3ddc801be10ac41527f75d0b2f5d0ef881656bee34c2e671e831f6526258fadaad6a586d3f3bc4d6a2e63dfb06ac6d4cddc8fce39aa503525617e5d40e249f15616797c7c172f5ea872a1385916d81616c15064239eb0a74f077ee1f64526fdfce79cf04d97ed77e2e9bde930e8f9242428b30d67de9cc9af41a646919a6d24d507dadf1221988ece3b13d225f695c752b7f9dee2d0a0442ea1e25507b2cd7175b116682141477267c45733228bc43879659396973a65b78215040b4b92fede57511ecf843ecfa2195320240a092c975221da4b03776bfa644a7e50550275bd3f2f9c861642e1c5ddb13c7c077ccfd4f70b4758ada2f6508b8ba449093886f5e9df46eb337058de354032d47493291c481a6eebe40fb7b657d6dc344b9568a69b092f56e708f9e37aa539ad0a9ad4c623dea556d6bb3b253ea53f184928afd0fcb1a1329315179b64a82a0cb2296a8f78a86fb5f545031316426e975a55e1830774606ec5f05f3c62df5b09fc6b1382bbebc87581cdc70529d4f29cce0ea03ed7d985a9f48ef02cc7a7b82fa9e69a0e4b49ff42af8e0e6154be16d3fe5159bf5bd787f8c0d4e5662fc71b6f82a87e42139739304ff99d5c1b4d0b8b105537d40d94611c03bc0cdd0b49be2ba50ac4296b16fca4af82cc8d575ad34530bb306d888e4aaa59725b15ff7c5b341bf1924ddb370c0d91f7691ba715a9936453df589fa106c2587779bdce16f6a9972e23ddf7e5898719e77b36b3a301a4f99efa4a379633dcbbace496668138d1c2e6d2566c487d692d6f0fc2d6a35b2bb5f10b20581a74537eacf01e554f5c8a8c3bd54f508f4c7fdc831d1d3f762be45059da0f0a5cac75cf282de39fcfa9974e9874fb81c5215f5c963565799f7f8210c6b35ae5677495e1854fc42760d63048c858d2335d67c1a9e33338fb8880bd8376d865c46bf759ce454c3d66da0aa6a4ac261d070a8bec07d68d8f46e768dd2e10637bf7bdbb17b6bab006458a1789332f69394fb6d5b0bb28034fcecd483f19db7b25bb7389d98a6c83785e734090c988f85597fb4888fc53b4667b8ff1f50fbd24667ce69fcd6da8411ef9b1e79ada6816ad905fb57ea18abfeeb1dd5ada1560b1a05c5e3b2e53fe738cd63a887894ba9b8655d385b5035a66164e3e5a89e9d637e74b746e827a0ec44682fbd7ccb04a34a4b2bb155a70ca317ebb33b5814e0e8766ca307ec7f0d511ecdb726d870100f724245549aec6b679161ce77ebf7c59f7719cf969db3c79da39624bc79d8973d462312a9998fca0d6a998e5cbf3fd4efa783a8b3692fe43d094465e8606ebbbdd3a7ab73c525eb12c7e0de640b8e1f36220d870e42b9674cfb630c6b493bf454c5a57c13dcb7b5087ea8ed66b3472863a7f70bf3b9df066fe9b4016b5b237bb229588c37ed069d214a6192943235385307fe1c558b17f3b1c8967f39a5e8960ac44f3b0034dc479a5db68b607dba32a7972c670b2764e9bdc681c27be69b8551c295d4c26a4e720f4979978441d8163485847fd46c67bb0b9ab2b783c323598a5fa0b28a887fb39419490e057e926d10b99909454ac1d59a1dec13446db78f289fb35d244b3253d0a6369a80c66f283eb5320c3b7ab3926577a28a54d70b390a8b3122d8865f620bb8d6410bf899ca0a032f0cde8fde85445bf8cb8454fa1f118f95f3ae2a56cbb142b53c1962cd93bbfdb19056f5142f75780d67a50b28233fc5946f2bf71439165934eed4c5c6437992d11b9e5ee040d95f7653faacc9d44bd11946bd1142ca39834896122966697f73b212a64cbd323e946a33bcf7de24f9e78537b3f8ba1cff3bbdd4272facc41e8c1b41bee1cf5273752f58b9b10cb44f1bf842d84589cddb3a38e7507eb9e194a76d382818411d0407e135cea0382456b0098ebd5253a2bb3150f72a00542fa809d36f6b764a638a1b9acac70e05065bf747578f1ac12f45a4ba6d3fb51dd3fbf0c887cfd7b74fc0ae0c0010e27ede8d9671d0da28c43542ca5452bf5a560b680700cd02f9416f46f34a8b9a16d3efa1811f836b9af1e7344a4774b02e6b571761dc5bf92bf8123150756d63fd97afb3e26b5383643dcbdbb74607033e685f22f414eda7a1a8e7aeedec25b1ccde65e357278fe06f2f7b5c64d31b78a7fe90351199201dffc3e490ace877b90ee8dc04086172818bd56e6a992efbe785f6184e98ddbcd849d1b73b096e0faed3335a019064b752a39d0de4c2a95cf7c286192c8e15a61d9feacb0ae172b598a86cfd551eb9a401ab9b3ba21bbcd9d36806cd019d9d06dec913015ea5ef7c86890ae3f2f21b9632d0dc2d88265872c1de55235bfe9d435047993c3360aa40cf31efac3b4233e4f0523950b77ecb0312626ac5b15e0ad71a6784094bf8c47922fe172f97c1aa711a63254887b38bcd6ba065ac09554efd54c377af5c30c2452f6ac645fd89010db732761091e7695a7614e56c8ffc77f0256c274debff0b0d0cc2f6da629be02f51fac747bccbfce5d32d85bb65c8d20805a95e5a516d60be3f4f16541715907ae2efbbe291e041dc88a7cb091d0c9571e3a836c582e25b8e6e14f25eae70a4a0c3cbe849e8468fbb263ea585a996ef453acf52b3787f1fe1522b304ba01d6bca37b6aa3459e7d60022130c8da4bf7778f092b6f13fb282d028b63e6e93e6ce253ed1a4a7dfaa589f7272d80477db4035ad8fb5ac41669ad3e901d3fe04a5f462a7a411412e9ae753512ed27e38011a27a00f103a81e460ddcd03131a803943d07dabb718cd927a12b95cfb3adeef2d8d41480a86e63d3ce07d42edd6996b0b199076c10deb1560ff7f8b4a540f852e7cb59b4db84a1a115bcdc1b15f82c515abb21ff6db553d7dcb59d1a6751955907001eaeee69cdc943f240230e627a3c999dfa69b22384663b576f79dfe3335b2fb6a45de64e4117bc2e614e828bbcb9fcc237685b474ce0f788d64163d0f0d1d67898a9435830a06c27a81b4347cfa2974ca35123cf66fa0ff2858057c541651a8ffe0d08a63e7fe31aad87c0dd83e592a6dd55d063196ccdf2b04ba5bcdc717d36ac4e70843c364de316665cdd4bdf8b6824107735f35eecb112240c85cc83f8a89161b3654c705c8be4d3818f1fba5fe484637041e9614fb7ef35e8b75161926b3566897e91a565a3af000f33d5fd06e27a00af776a7a979f55f744f4602030b7ad9e541fc0cd0933d66ceccd363b63da7397cc8c1f9acaec9a41680c1ecf6421b206037e11828a1f568b68407968ae211c2ed9b4259efdb699ebbdfcfdb54072864b8db2006248a42409b5fadf61a41f78a20dc63542226570d6b8fc5ef3de191420f9eb9abf833bd202906aba64333bec4eb2e2308b4679378f7e218b88590fe3421c1412e7c2b5e8958dbd1a10ca019cbc8d88c125d7e8d96314ee464b57681c86901210718bb7e7ac7d3ddd97f1c7994cbfbdc16e5a380d7ba14cdc5ab05512950440f1cdb3f33a6dd3794f94c0dd2dad2232f833bf54a383712a7b64d11fbd59cd8086e1c41240b1e92a73a01e8852e8be25e665a0e9c3fc1fb5016d0e7a19ecc87dda50cbf6ab608e4f44dc5678ec8e1596c991e39b42cfd2ce3f1aeb0e9a06b54c69c303f6d673e70e6fe2db2df1328dadc1891148399fa3e3d8cfd943cf7f4ad7572bf39e2f89a7ae9b714675dcef9439fddf25f3042d15220016510cfb895fca12e7459b8eb2d9ca19d150b46ce02dc31b3d0de5961a6e18c0145d3f2f88f72e330019f8b677439c266985f3f3880df66e63b595299b850aa9379838516346df23945bb2c3b794f68dde20b79198137939667cb3c84871a0fc08277a7d52e05f7ea1d8742b9207e5fc7628c178c122fad98d357da4dd91639ca13ac4655aa6ac266824adcfa0a49c461e18fdcf22b630f37139a79e4c8334848b88e5a830522933ac5a636dcb4b6a9338bf48f7d21f6f850a0f276fca48a2fe6d7c4d3cab26a6696c168a4a0e345f4d037bb60f52401051fa3498c66ed06ba63245a789417531843b83df7c2d33cb8890a36db046c056a00e81e7e65a203262083f2aa9da2c6a1a541b0dd9709aa2769f8acb83a20cbdf337887ac0eee88a72fd7e1446cd7127c438e1ee42eb6a7bcb50fae2f7ccc92b2c8973adb6aa2f7bd59b356b1f74db9e9b7aae81141aa5c4421249d55990d68fbfc39b090478ea138572219f2e93222f8b54b723e0f0a992a8dc93defd10d233400f78676cc61424b74d7863c90b90a80a38eb66718720d02ae5f370a73901898bf4b5e2687ddca7ea55a17c68979da86b907c36cd2d9a952c903034344e460d61b9d962cef59b2b245b7044b58748430ba6c045db7621feb96c1b7a3c29f0a3684dd974ddae3c8f2c5203bdda0515a8450464eb706ace12930f096eb675293445f8b2263464148f7c04702104ccec153798321848ec0e0a9adc2419cba838b233365ac2f9e01f72954ec19bd4c7ecaef0e5c6780f798f4ca57cf74310f75255dd2111c212b1d4b7658309cb40a624079bb960b76ef640350df168bce665d51c055a3ed5f400cfd8cabffcff7932df526fd631fb5160db65beb9f87cb484f3d7506628eb7606bf037bfa7e860ccc20e72815ebf5f8cfc7c2929331b233f43e6e04c3c1e71ab4fa14fbb89bb98b2f59d5be317762592126458937bf1d9126ffa997820c60b8a6e474e27ac8951a2161e5f56214acb774d62d5034d55a272001569b04d386626780b5cc2d763efccbf40b3ee7702ece171eb3d44d035e2552dec4eec9c56155f9b5bbd26469b4adfab6b6dfbf8348a43577a045cc8129652eef1c9f7da2ecf1392b47aaf980b0f21fe56ce764e12414545917ac997dddac73a26430c41ad4f482c8ff6f6775308c88ca67007b1773d5359c3433ba80df4c755a686fbfa96fc3e753dec7c742d33deab01dcb37c247027f45a288faa8f6eba9e05f4282156a0d6e6a21bf87a3bc1adac1eb5f45a8736b31c0fb716d489d75dd33633dd3e616c2de360cd02e8344352fb702dee7421b4798c6e28ca7bddd3229ee09bdca89d60db13f28715ee0e2239e76352f5e37e7c2710dd818466354ab6f0b381c89737cd2020fedacb016f42688059293be5fb925df451cfbc6ce9a68f2eec4d2de4727cee6f1415299df7ab221293508dc7d75d11bdf087ced51d8add8c4899f34947fc787be7c0eb9729dee39c1d37fa5c23b495c5d7cda1e3238cc89de6b3226a40d3313bba2c19c30034927ef6827e7d3947b5c5006520b6f31921e89f2955d039a660275bcd228b05d642ca1c3312c0308fa0fee80c67cbcb2bb9762a883a7c1f40483b6e8fe23062f4a649958fb653ece6dad6a2467a2cd10ef7e20a1f5ed94e72666700190a3fdc83a6abfd9596bccf70d964102230257b9f5c9ea9e7f40768153747de713b8c5f2c4a5368a18cb30942fd4c828b56326edbd9e1639b5aae1bb40b97f0beb61040c5b7fe2d08c643068895133d5e99a76bf41b71630abe7b75b3e84b51e4c8797f47efd09eee0c95701a560a0fba4bb34a6e86ebe4e041be1a4b57a658346351c126383ac8b6cea0078e845cf147be090cf1ecedef6f77d3f31d2ccb86f1e1860b0c67d1cf676309862f36af902d0378214dc305e090fde2a364d3a9f4ecc41c64843821bb0519c9c49872c2ae6fe6bc8efc8955cbec84454dbd640ac36875e1affd68fc3cbc306a14e843e73e44bc17f078d50e9ef2e872801addbac831d79c62a38e9f624daa5c31033955ee01c4875bcd1dcea3f5238f7fc9377acb3e582477e5a0b598466b075f51e3712f99d92fa239176d6d8b735489a08358a73e1e48e30593a70b7a914ce16f06a5152e08435a9b28db70afc0e5d462e60364104db281bd35098689fb0ac4a16b0959f31aabd25a6de9e5c3f134143326809e60abf4cd6bd35b5605a992232c1334d9fefe3165ab587143255c3065efd4abc7fc5adad33cb343008bb3c0f969eabf62480287355f0a7b67027d17931ab4330f95ae0872979e75f3ba17afd1d7da5d1d43fdf642efc498514d475f21e425d23fcb46d52a60e619d5203a4a5e74072cd0cbe2ab5f946bc2ec447117137edeafa147c901e7ef05e5efa4e9761474c22464459f8bdbcb680f963367c7fd1e31762b234889d17b08f8d62c788d73c779b63a535445b47a309cfd259c22d2e171fa429bb5aacb26eae39482f8e46b230881d84b26c9dba72bdceac8dda074a30a35b1587b50cfbb09c23b105dc48468081a0a1aa64241930eaddc1de0e6475f4d7553c324abbe3aa14464b42e6e1da33b520af40f72ad5b8a18b5c6de9604d8a293a8254b5e4ae287aa590fab4b18802ced6ba4f7c2b29988dc06f8d58469ccb3d6f96ffd1108ed0667427c5fab290de7955b5b8a677b27e37fe782b86c546cb856484d474188d9c4fb085dd083eaad2007bcc0ce77476417e7983b44e3c7fea253d87d98365ce69bd295f8dd12409cc68ca0a4599e037244f22fbd97edbb16a0153cee89223b723e9f44c0543f05a151ded3e94eded46b54364203dc8ba7b220b5d52d17504096518ed5a37bc89bbee0323a376bd441c2e0df4834c57ec5996469fab4a0b769981ec826bf85dbb61e6d3dc3921a0d45914c7a2c09ccc447441f955a5d4d3f0a2a7707e3c24523729ee53eab2ea6dbb278dc0e976c75df4fe6c33f3f3fa5a08b6d57a9c9c154086b74a94b3c48ee59c6f5a5ed09bf041857a7ea97df199210b884a2627c4e2e57ae8a9b45526526a94cc96efcb24b8bcc0167cbd1fca2f0cfff57d820d4d5714cd9505e0ec8994d1f7b46ab3ee88766c8ca55274bdc1b8a78a51523da69371392e574e21d51e958e4831882739520e827eae21c16eae66079460c2e42d9402d01c66cde89db0da3c1dc0530606b2de2940a3e038c30d341b3b352","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
