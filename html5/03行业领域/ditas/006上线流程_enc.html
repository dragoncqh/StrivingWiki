<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"611866a55b9fb74e68a8fa809fb17cab43712740d75cd985ae91b12cb432c1d92401eaccefc9ee7417e1b6da9423d03b71c8e5cab3bc330c416e39015a00ffa50cd38f9a529541f816937d6d5ec42af9300eac2a94b6fc671064f3727454036dd6f268657e86bcecf11d7c6705d67f0cb3489f6837aece6f47e9017831c95310bcbf1d3039b12bc6d7f70c160428e8f6357471f7a25b5c7fce9a525da718d05ba80d2f8161f34ead96bf3d4e31e2ceb501e787173df2cda71247dc60bf448504994b885431bc39c681335e77e88d82f63a140947ffd1be8f8fae3e84a2113f36c7bdf3109da2aeea6843575cb4da0a0647d791a493be85e4a7d742aded2f44301a7aac209d6ee675848ab1532d9c543a908b3fd3e605c39104d9dc7a2d3ee396609b21f6d9c8dcd4e4b2065b69fc94da903c721fba0def7159d769094dbf7a80ad4d5323a68defd773c85375b18f94c440c0801d2c495ff5158941d0ca215c291767dc4fd67e76e2898a22126f2aa96ad04ae1036c3a76652e232557b15637e168ad29985400ae2393a5945ceb147003a12f3137e7b9c6a6df56d5a3b98cc752b1ec111ec5ac518136b59e80e1653c553d3882fdb50c4b808dc89f2055482ce5d85548faf0eb82823e15b29f0a7f54c0cdabab76d4b921076d0d47846c60d8b1eb382cb02d10e4bf5672cfa113c42f93c9d3d307f10be606aca6bbbaa4a71f508830b17b54108ecea32f99cbe0df0fddc2b96775b27221f0bd807ad81bf2155e21083487dc39181118340aafa92a3e5ec1c129bf332b3cd3c553b3962fd4a22b9fbe91e4c6e39313368cb5ecf859d02410f02f5fc4a2587212f887361a68485f45614d6c893d11f4500557f40401cf0b358c9aa34a803ced57e684599cdd06af81e6431e6b2512421930e7c4e2d9d973ca74c3470d43b6710c336afb5e021baf1ac57cbabaa3472ea61d9722a658065e7e091b0178a36cbbbbb79e77e8b2806b7467ee9b20aaafa356df7687ac8fb05e29cadcc05761e3ab22cba8e56c0ef49b3a7180f791e13adea8601f055266ec814c60948f415dd47fee6f600046f3d26d43ac43d987ddcf4b7b61a69db2b4488e9317a82efa534564c42f4665cbfe2c1aa2f868727bbeda47cc922bc9a612e00ae475874fca9e528ae00aeb53547e5f1198de0441d8083040460b9db8814d8b106d136f3b205ec9897d0889a38ac146588036af23f403d7ee813c83be030d707c705076b2997511f827e4d6bf006c888a72d92445c0a8b63de58a1023e1aef8487d19441ae2cdbb9cd95b391c96eee4236e05f1324a2511b2371aac2988d06d6e2a08ba49e875f08f6074e0d8a38bcbd892d7ba9f77170c5889a8cdfbc1da9159b01de82eb33e1f8058c187c12b5b71ef1415c08df6e27d8878018998d3734fb21665503e4119c0d7aa9604d9ea450565631483b219fb92ba927abf9ef2024be1634f793befead2d9a5617b92d015b069a877be66a8e50ad546e434d3597a6d9b0b48cdb6019836901a807cfc28740b5e1e8904956a200ce0cd8bdcdebfe579b76a96a973fd93ebfefe8b9a8dcdc60583cb04b245b2fb5aa78a7a6f476b74a5920151f83ef3528e51d1c254cddf0a968875e6805ab0f5a318870a4c72347c392d06b08eddc72856367f90333f079e12b7f421d92b5c6ca0164e937d8aa3a1dcce7bdf65a8ae5149f1d790930ba164e5d793bd96379abff26210c2d89841682a6e708594e1c6767f90d105ee6d2c0e60796ebdc29870315232810b46c933946de92083d017ea47f6daf33e88303082ae8b8448ac98f999987c2af5eec9d643c48600bb6d354b1ad34d2d2d5e8d62c41403976ce08c202077ad58517d07802036fa7496f9c72eaa6b0e64b9b803499d3e6fb198abb5f489d81d64bafc78df9df87bf45d94e44503a5c46571544269373d8f81f3b479e4e73228e2eb9820399622ffc85028b601780e923d915a8c8f35b77aa58c438ce65dbd90f9a3f4b7b894ad286697a215eca886012183397258e110efa089e9d6715394f655e012d0d843598b9d20c16b8b0d5bfe942cab10761f37c7d68380e1fddb47b0fc3d7c82c48c7c1f819c0c79561df93b07329d14da91f8ba019d127630ed5df95fb7e0f187b35e51fa317c4090f513163fa1ac77c0d289bf7419cfff098deefa6b3efd58dc7391f892802afccb788b37da3141e063be3bef3ef8af1928cf9968626b18bed9de8e321296c29199ca4f4fe26d387e07cb6e0b2ed530ca20714608a10c3dc42deb2d4d333efa46e248b407fdcda203158e16c824f9ca7686d2ec5a6fb1bc4f67135bf8d21187a1cb8b2c053b1576b9f1e423071e18e4c455db8fecc3165f9a099c75835d0aaa470358e55d247b09bf8dd015ac89e653af3fa3eb86e5ee42780c700d920d8eaefc32448da43a4c4b9b70cd6b2affc977a6720a0ea14f168272a100c749058293a30a37d7b01e672dba7486aa928102ab784c7fe9bc065c9733dee06472e45e5a3bce3f1eb817d836c0b6e745efc13c22e6ce0c6ca8fc4aa25a52a8244ea7bff63e1d1300f1725fd88ecc63d2973afe19d0a4b157ad7c00c9d9f810af332f613ffcbd690ded3c712a9539ae9b81211fadc1a01481596fde8e58c09a3f352ec1e2c4701d96e0928488f26f7089595df2cfc32b632d77afab3e1cb22a5defae6ea0a8ed0b8a0d96a1f4361efc41215c2a94ed60b89bc13b11d1c303ddf437f5480230b3961338c1a4f7da6d72acad1f5fb2d85f7ff7044cdd0f3fc306d09a57452ff82a2a9f24bd196a712e9b570d0359de71f896bc16891645a7c9dcbc2e08aa54dc01a77b777f88019c0ee67222786e1f310c971cb1cfef58603130b2a0be0267bc92d38af69f102e44230df09be371defb95cbd96179493a383a5fb75cd7c432810d51b8d0af83208f32664e7b68ee51e08150716fe0dccea736fc2dd00d35f7539da5fdccf42f52b8074aee5506a2b948dfe9bcc27491e514f87fc8618c483e3c201c1ada3e5aeb757aed2eeb7d5b2cccdb1c1bfa54e2faf3035c145cbd3083c58eb1d5980fc34cdc63e44d02dd00fef396df9fa14b2fd21b921af9cda437244f06352aedc71a49789bd8d81c74558ba60e1f86a9fe8e16db4658a6e2b08f4fbed06e8faca45dba443bc6a08577a7b84b63454cd15d18b5f602e778c281bbbc0cae0536f07c2e438aecc76e835310450317a9918d7983f61a37d1cb2de7cf09eb3c97693d510b9ff36ca4d9286d180f7f5795112869eddf420e01d6794c6c9a9ff7eeaa63be84b460315ec2dc8418a192420754527e8f95bfa184ef693fab8c7ab81d80456bc2f32efc352b6c67cc477e6feac1c5eaf6e75c9d2eb534d38c557f1055bb0e54b85a8667e145a0bcd4ff9f06cbd2ddfedca0dd13deceac326f3fb7cb6f88b61fe0cd4d611eea7c93c788c0bd39d32689ac604254c9977a9fdbe0de0fcb12f94615e661e292441235d0ab0a460f00558f8d875a47840fa677d71513c6e1143242d5dff61b120a60c146883004cc9d773d6be6ec6c213905de1ece8698b1c69db35ac7f9390639e2db2a6dd26afd9b1384c9d8d84e2f15be0f8866fa3f8e13efd83a7995bb6eecfc3c41bf89a815d4c9fe5a375bcddc9ae4d57ff7ef2108dc9fe582a918eff457e58a091db777c7085c0bc6abe32e1df00cfe1a3bd453742d5c113231b8c8554636636118a1b1b05d86c596d59f396233d2104ffdeeac2dd2e0fbb43789087b2325614eb5b0cc562dcd3d8109f963df8fa686a98a044eb312206d3523784c25b5fc371c6be963ce9e209b83e5356ab92a711c060b686b40db98df292f34fa7627f95692364593e0558bd39c7a0c85cbad91f797456b2eb1a8f0981d61b15e6df743216972dac59e730e5761ca1e85fa17771dd2b2d91882fa1680440905a6f8fcff81567f9249f591c2becdbad805c07fa900fad29ceeb673c25e8b263cec73305fe738e43d429ecf7fee4335628319a056bb00fe1b15e3444ad879e0c94e5cc53f906c2b7ce1cfbb21c54ebbabfd3ca13f33a195c233edb65adc48aaa60481f25ebcb0f6ed4199b3f051ae72fa025d8ca7d0855f7d9d412f8d0784f7fd458e41f12309de14dd4333353558165dcdd8cca1daec3c8c760c82feb2afee5362ff5d8ef73af2bc2b75b4ccfd088f2bfdd8c6b289af94e29b1a23f6546472969a92d335ce61f3b34ec618b6b82a39b1b6fc5b505b5dbd3aeadc2c1d2f356fc49b8328bd8df353405ca8e28acd209779d84c371ec237622ce7eb2331dedd87038ed2b433859507767899b01de3383165fc04754578f59d5d694082ac83fb2f62f1646ae3c8532304a38ebc6bf424b88142efec842826f19969e07e4d961e6e1ac487d8cf4d9ab84aca1f588b69552917dbb63f6f92f4c246c6ad3e104129f3ecd62bcc2f2f78ccc016544044b2bc29d3efee8cac3b455fadbae9b8e9821825d2f6443006716ac6467d962bdf831d5967151b6a313d02b227b9b9a378fe3f5fdb424aa0f93deb97f5e53f68a2dfbb3e00c01a97137632afd20f5191c34fd93d09ab5a2bac1d83c65f013aac8be8977954e1861459d39318e24b8de149ea477692411fe052c2f972bf923a20a725ebbf23c1d6febadaa7b19a9507373591afb29edaef779dd4de2dd4deadc6941ee0d16ac44b772ffd016a2ea51076a550402159f696b4060af65b967b34849e3912b0f5cc679f24f9d0a668536f19f94a20233d5730a70e482f3e88f7bf9f7f4da55d26cff32fc82a1ab2512b15ff2d2484417bb3bec51e50e12bec8cbc947f9a6a180756315054d5cd41da6422d989a700c6f6cdfb2e9c81931e3e3fb27db962117ce02a69d383e64668358daf2cb7d8692cc43adef2db1009aee46b7f7ab71a4dceab83f908a59312b2be62ad7d911c6dd64e4c338c000ad2dc98bce7bbda38c91e58fe7fe0d12cac90eb86214eba55bcf9ee4857445a32e9941e8a9b887fb2a0a72282b712757b65de4628cceb0b35ae3cf8da6b65f33b9ffe318d7cb097ac58bf7f37fbd57d629bb0aad8a6d1f36046fc2f9ca390b92f737e0e2310b8d40457695c0c3fbc5c19d7e84568cc2b470d070d768c6274d1c9fcd3d0352bbf9432f4d50c296b9fd19a7e9629d09226a33d0fa612877fbe7fd031daf0ed0e2b9468c7c004151b0f796f02c89cdf8c10243e021828b4a145962efa8ac9934c29c98fa59e5489ac36d4bbfd96e69d22f7b26d0b273040ae4e393b0d933075ff1bcd49d96dc75c51484b223adeb0c0b56cae000710e124522c8be34b82982bc68b4126e7981860fc2d68670beeb0c07d2404b3b9b03221120c216923e36b5bb5e511a1e9a4eecc7fa31ffd833a96a84a184510f5683cd8f29d6b603fea6b70b8184d3e08d71870fe498b46bbc6ca1d80a887374a601ed7ae1cb8efca3525f39b9e6747c0ccc9122d0fb6f949f0d284cede62fabc138c832d970e516889de33d3f194ec342b2365bb88d37af3408ba31d1a32692bba521d729a5cb1d7e7e68a8e8414d76a749c3c9fdcb9d620f4e42793eda5d9a8fb6d58bf203cd0d6e7eb71bc811c07daf2b9149b271e0848c9d78439d6ce43f0486760a04a56429cef617e75f17db9643feb150bfb69b5e6d4f69ca17deb91c56584b64fa3e2dde7db5c681474e1d9b19561e4a7bdce3d95330937ca560ecfac3031f7843bd68686a6e5feb6e9d815212cff70f82f88faaf6d2a350100a40b9050e8a76eb82cfaf9409db71d0394d5feb38c2fe8551fd5db43c2094db136a37789e83622fcad1c43c5f6f6feb0d4e7650503acbd21046e96ce4844415eb1daaddf7ed0f17472fb4fa84b028d2bd09dd874aeb14ebf392bfb1c1759f49e1bc55394bee7ededec7ae96c645b4bfc18cc35d778f19bda0562899954e42211f32e87d9a5a29b67bfdb974613d9a332582dcc6d20f6afea071923059712b396a0949aaf19cb8faf13aa480bf71f7f61a91e747258dd65772361036fc1442bbf098e4ebc3863287381fbd3a83dfd89c2a5e29fd96596458a6cf72b5a8dca8bbd7ddc43c72c57b8dce3a008dffc22c5fa99356abd792211f2dc5fb0c98899a3a075aa6b3290cbfae295e99355609b7710f5e28331b4b1d8248fe14645d417e7111771dea3939694ef60b0e28aeae89a3b81334ba8bf6653e55934fc4f75af741f5fabd700db56b3b8be8de65d8e4c2fcefda37346175220a1e40699b86212bcce568a12bb9d609a07942a78df42d3f8f3cf46c8d95cc1b379f459f2c539b53a703c06dd2cc066de3f2c7b5324a0c411c501f59fc6e91c1e9108b25a16a90c24d5e6bf9c14a83224676521ef801d56f6c3e99f0f7677a4e9a1e9d58d5b3cf924082e632e7badd8aea6866728a40ddfb894f78fe2c25d3b9e8eb74cea4482e74c025fd1901f32850b2eeec595e22d6ebb4fac0544fa0da472ebe8da0cff8d80cc7b7200218f0bc6c684a7cdf10b05a1e3cbda76bff941aa2749fd640b55b1f4831a56a5fe77b8dbc6d0d860c81d2caffa48409215f1797254dd96f1afd9d0ec480c3b325d5e0bb818f20d1b878bd863e28aba52b6f6259f236fb95e306776393ec52a50cce722a852aae0b1d21806d09419d014bcf2996912117f36fc7f271da3556542541cc81bce62e59f8ef59fe8f05c9a482e06ed56e60b46f38f6b0511267f74bc75e13b9aaa246c0ca5db7e579638839cdbf44c8ab6f4ccf176d84b0d0391bf5388858618a852dc11036a0f8462d24508b8be6a63526449312f2f083c548fe2e58c80378d10a4814de4e201e11cdf8c5ac80956ee4c735047d472fb2dd162c5e4e1b87554cb44e0abe3e55c7877a9562755667e5342aaef28989cc4c3734cb1a20a73991341a53900bd8803e6bb9dd6370bcff7cb0c993c59ef41b7108af8df01266edc86ce31a498c6e539455928f0547fd21e5cac44a421f094235ac4e15487fa361d18561de6817596e0b00b26c51188824631bfa79ce659b96b8b3f8fcd47617923bde5a9d000125458ceea9db2fc1702cd0a51db30f6fdc48c23ba8c86ffc0650d1dd44641caabdbdab75a862ff08a4063b90511d1b3fede10d2deecdb4bfd0972aa30bd161ca506c166eeb7e98dc0a1bf52f0a8b8eb1206c7cc9d881419927759ffc7cb850568db08f1b4afa2618853fa7ded55dab1022739c01259ab9dbf91ba84ceba74a877d754e24591ed35367b3f21212826d4f89ef5034c167eb7a8d9d9203d5e99fd691d8663dc098c197a8b21edb538fdb5412e51e98dcaec9f4b9e2e42377df454b37606a1b51c48c0ea77d7d153419ad3a6bc422fb90b8f717cfa8044a7e0c76d560aa34ca980f9f03b26503eaac327e9c0f5cb3d826f31feb504a5aeed8c6b368ea86a4c0e3da7e23191bc710aa3e6043267b28e054e97f7d51bc14d738e3ccef5939214f92cf9569e708061b01a902fd0a417e6a7f2774a3b65d961592bb4e39e2a7624cd010c52a74ee218f800a4234e0b8b47774fedd82997c4a6601481bfacc314fd2f42909da7c074c63eb5077362df6fa9b7c555a32528a2fb35f69b114992d311b82154258485170cc430120b16322c89df2941985f09db816f38db0ec5cafca440939d0b53bf00f9c42d18bd5041156e84cd8cb97b3a651dd9a1e25635e157087b5ab2e867e05aab4e2ad61ea3856697b131f47f17fa248d3b7b920d48442da31c1ffe9e7580fce09e8666d3b6cc9cf0c998aa92e04629d18edf94a8ea8716856fbf57f283747c59c7219c270b4a57f6172df202bfdb308f5fc15e5e7c58feeb1a00829c68a82b23f6a3451093bd04a6d4a0c3cfb2dce7f90442ac20ed1bff670e0a3e05e70d302f78595cb3f607c858c85d9802b114a04eea53d6ca7283d70edd54ff1db000af0a328a5c62da5915cef0cb2a91f14064777f4b264e4eaf225ea34ee2c95ebeb48cffa95b6acc494ee07c3afc33aeb07a914d0ba4a5220f9483ce8871f0ab445c7ac17502ee0c40049d7939c84cc20d1ac4ac6902fcd3f9c12aa6d96d5ea5c2db36a238ae118f50051028243cb66f3b6b4367f2fe340aebe7dedc30fc1af9a3f7d7bccd730c605d14e47081cb2e5540f8150a66e558959d7d71e0ab23fb099fd4bf60b02f184d3ce366c92514e301631bc11c0f1f75ffb1cdb6acf086bc00d9eb497078a3be2286852637bed2dca3885309c4e1d39f53e553affdb853d9436d00d9e8a9fb8c1ff3850e2f5b56dc46b445c086a175c03762ab289b176864285478d37c8d8843afd998fea49f56a96600d27bc63e9ded358ca5eb3a8095d5a5e9b9c594c04b9aeb18a7e37ec9303beea3bd0cdb0fea5dab0435cedf52d26e55731ae6f2592d266222c0491437fbbe57e59c623b5537c858f9a6b59800b37865c70de9db06f8425eaf1ace4a6af092747bb3f776b7b15217ce4fb38211a88d1db15508f8ea8d8aac9c20916d0a359b8fb3cd44e8dd9a2dadee8e428a17c44bda5e5d88f80fd5b3e5c47bed12c49db0ecb0162ffeb9d063673891a8cdddf88139876ae94a67f33c45e529c025ec6b01d19c149bb4955579e63c83bb06528b8bee08f196c1688ad63a9b16870a7de5cd7ea736e8574bd2b7c6d5bd1608cebb81553dfce2daac279a50587c37663a393774b7f085d68d2976ca83db83cf0baca865b221455ba47de488928af685b07fd03847c403236d26d742776dfbb2c6086093c829e4dbbb3d652ab353c7759ded999b2104a608370997032f7758900543bcbdfcb73cebf364ec06b70d548e5308849cfa1c74886e3050fad3787f539954d38e035d7846eb4c7ebcf95cfb771ffe4f7d599e51d0b987eae02488899709cda466ec37f3688ac391912b53e46cc8940867d46b0f2a2aa8afbde29226b16540938d5e5d2f233596938e9a0fcbf917c178e7e9fd569c27815ce7aad5ddce4b47ed196fad4f77e61d38a9491e04950cd3815b348498aa00fb50f7a7422deba0b2d3e4c19e549afe032df5c58a9ebe5297f574b616c028acea9d7c729966c65668f31e7458db64a2f7b936bb39ffebe33bef179e849d5d147cb6da8bf7aa2a1516341f2d342b2d6bf60c2c4d662804aff69cd461aea5534db4b423076896b2f9d7850e8404908bfa4575531eb59f7270e4115fb50111f0507d91e95cf91c67d5af94ae478a09b74edad661cd2d021bb50052e9f6a5d3e699c84b6f72db435e469ed32590849d48c34fa90a48993a757a21ef6b9c5061e058ee8e1b37677dd074300683dc47af60f694e20bc17c6ffcd5f0dec5be210699df0e5d1c9c7d554a6e6b7ea8834aff6cae0a2aec5c2bd72adff1edd917ebfe8f34dbb4677f26c7e522443018a386353207ea33e6acc3790b9d90288b773bb7161e642954c1558d30ccfb097e9fd0ecabb35872723a9e6393108de3b08e43d8dedeaf26c816c0df3d2fe5ea4c8b63b4e2ca5329e8a830f64cfef46dab58840216ea90e6a9314c65560499028e375505ed4c89ee189b5fd719c8c8225a32a50885eaa35fc87fe6636423105f76d919206bc1cacc286dd626756e1f840dcb07f263dbc78fcb0b0f9f52beeaaa77b2eb9aee24fa641454eb256308d27a810bd785c997aad795cf2211964a671eb737a39adc04fa67693fce3042f2478d85ad1e0526acc3b3798dcf7f7800cfd6b0faed4c6c321cfca8aa81e48913543f7e874a71c146754c8e1ba2e79c3f9de57efa6d1291ba8c0539e0cc9156e8cef1a2b838e7f301c24aa9ba70b69b6a6aede864fee24c06a9b4ede1d60611fd2ca9edd63cc189ccb06e3f149ca5b7ad45419779d02bf16b4ee21b2678c61afb1663a77943ba88f8b74ebf0e623defe2095f46b5500e851e595a749da2c5eaeec3e7814bb411796e66c1574a51702d4a87ffbb14c2450b03dbb427b4ccdbd7dddc38ac8cf10aaed533d8125f9477c441a9a9cfbaf724a315027677f36e885e3ef4da2d428464e0bcbdc89a02ce8f61665ebab9cde3e71cab51fa8a8334b3d5894a334a753f2d106f154f1b8da4a7a512c23999da49789cc5d6390dcf03d770913759258dc1f17fc7b7eb1134ff834ae306053ad0840dff58f540db36086805aebd539343a16568b3f5b59ae541e70a84bcbf6b7e08f9d45c0d2756e1a6e00a606f908b5a6456ffedecae40bfb6a05c8e82169b572165511034128f2a1ff4d8bd300cf86dd9b7ad42724b2eb5a189b55e50b33bba99e4d72de5b2a11162127a3c2c48f24f8817a9547deb0d2c04ebc56a39c87313b95f5983ce2fc6cfa3c486a00352ae7d50674fcca62508b97c33196fb530e6f964666886779081d23d9385374d88e8573a7bb51b18ae47066f1b14234f021740e6ea31a40bbee4900f7d8f38257a69e1a681c8d6024ec6a346e74fc13ca2509fbd9d1934f7bac59eda91e7c0cf15822c7c8189ba11b8932a3dcbe34c6c73c19bf00721c6a74e147e8fc5d52d04b0ac15b69ab142791a8e64d57ad5a65b712108d52f502efa041fb56df0fc588c51b4bf4bccdcf202749cd5437d48f61e52d146b0f7b633c15a3b17341be0946189742f6c4b98f80d23f262594cb2b19a9697cb2ac43013b09c5b68d37e33f55b82a4ef161c71760b967ce4bc3eedbd93f5827fb921f6b4d472d314578614cece7678828d8c51ecb07f1c65434c1af7842de58761461494501458734d69d0850bd113086eae9e91c2f62c27d673bd20864ee9952d35973cff31925a9809dac5072f31da10396ba3b0d653d709b5e4faf2ba1075dad77b703cb831e1f6eff3910b774ec6431fb2daf771b07ebf3734e0ffe31c852d11b621ca0752c89b4fe1a722d2cba2253e181e1f647b113b1d69246f2c3a17f6c966f7641d11d32ce48d7dd176e408dd590bbbbc789377d6857b2953134a847026a8f027ae16e963b5c3addba79d48b93decbcca76420f19d49ee698023d841096c8ec0733e65e3be682fcdd51e86208a096abcd811a5ac1f9544ce8b44aa81d62e13024db0c234aab718c68a96489f572ae467079a80a2a968bffee884f07f8f9b33b5032646f283cffcde64638467fd9dea5e129a689a8c07dc8d0540c4dc2fe86dc9c2d15906c648e9ea28a6c3c231c8220f37b2f396e3b784e247cf9d16f685352701a00b1be91556a4deb24682c1e14d3bd6d43fc7bf6f8ab6d889dddce81c468acc927458e328e003f4fe6f545a233ccfcabadb36113ec9451840d2a33b4e50fbdcb5155529701e56f7de43fae37d7f741a9cc8edee0777546a17e6a6fef459bc91f13712c16337a3a60e61df3812030f993e3d49294728a6b858eff3c06aef4b8011e86eeb90d3241f805ea7c15290801016b4c7c91f10e8bd01309153e1c440d70a59c5f95ff873663ddacc26924a82481736f3ccf852600f6322c8b98bf0b3ebc2c916167dd3c8727efb8774b619c6379759b56252fc88eb6c4a5a00fa12dbc251e1872aa6eaeb777fa28cd5023088f57a65a02b18bde5828456ba28380288a79b28ce2e2dd2c61204b8e33cff223e40812428224d5e1901a194a6a3055b3f88a09eb7f407829d2b39a3a3baae4bee1c4a7ceb03bb6f0af234b53e03e860aad11649e35fac3424a434fd6ead44e75086700ef3996bad5211289604f0f4c1e8610013d3221115c0c0808f7fd1efb6ba29781c35fe9af0ddab925333c7f406f9ad8ed6c94a1603d3c371e9f610480da9c93171241af80f1814c4bbf217e16ec6b01a74af10b2ee46a09c4b4048f75e589f814d06433e3ead6ab451a7c82d54fff38cf474e50a41ca2c17c6abc1faab7b031a1f50e2977d40e7d17a56a795fdf3ae1813d63ce0cf77578bdecb76469e59cf6b7149a147c87d64781c44e5af78b4ef19163e1f79879cae5e2bbb4c9c34ccfb4dd27dfe2038c4c660e09cf50665dd4574d7ae47fafcff09654fe94e9f0a6b2f5200b6c8905476b4fff97cf59ff52eb63800d37c7fed617a125c8fbcbbfe2d64163e720036024ab933d138e1e13f11ab583160206080b87f92b5df5583677167804b63644152197a3ef2239f85ef772af9d67d103ba6b9030fef4569716037be9c14459bc845a94c868832412035783678ce0f5f04eacf461d0727ff12a1a3dba47dd4fc470336bb9ef29477e7f973e4632317aef1e9a0738d460994d1362ca5d6e69b4c635a0e7195ffd8c16fd705d8b10e4529502ed281e4aca04ef2475c6bdbcd2f57d744a180a6fd8a41401736fa23af94b08cdd0fc6fc47b3d8982c4feb3af6e11118d1296985da762c893835b802b9adcb72c8aa1eac9d5ba03a46d1cd4928154708f25656c59abb15b246d96a9eded46cf2b60ee6d017f1493799eb2a76378592599dd1e318688ee149a920ad688117c5abb1c6dbf7aa41d969d2b7a8a06f9862e635a2ac2e1dbede40e53c4f97bd150a6cd4832b07a9d4db32e3a15b4c1e83f156152159fa9e782993ebfebd63eac8de13b9a765d5c1de4998737b67c5eaf05f9bef98872d0696c15f79818d9af83bbf6554fd915246149edef82fd0623dfc03a3fe778d922354bd1723ee8caa60e463cf25ec914b2010e683d848340e1653a9f56437834f009d5dd5bf0e5689628d69ca4eb84e641796b863870663cb4342cab054fc01ea0320b142ca01924e9acc75dcf2b85ecffa88f22b1b7f774b923d4fd80158390f0fb35a2836d074fb0e9a762dab6d184a27acd7146b9c2427c6416c0c3b12d8a99f434cf6f6f608d207cb31b84b8610e9b82f553fd11a02d9f6a064a0173e1483007cf63991ec96516eee3f4261334ffee930d61d78365a9366a7fe7eb08469027bab36e89161e55b9d32a7e09785d06af3e4b1205a4327f21b07e31b360462e7e895938e827b3cabf2730bcc8584af94463bbc22ba585df83aee3dc3725c0b43564a25a26de8170d63841fc1e65733220cca3fa865507a0fc2f7de2007d6240b5c2e1aa7ee3e444057cd9998baa2d9c42b5cefe541b14ac72b59ffc4f0bdaf7084af2d36d6f44eed25d16e3c241a859d10ef0ca3072ca7030165efa02762d31731115127b4d444f996eedd5b5a87dff3110f0f0bc4c335ac4a4e8ac551a9cb25eb56fa1fee63a6152e0f84c0328e63dc9b74f0954192eacaa4806964f46358bfd13281f35e78ec415072977cd9509208cd53f741b5ba2521b93489ff1312d89c98913c58386e70bd2a40cd2bed00797f09b90022dcc1bf46fb6d11b9ad86402747692b25f7957c530b3fb5aa652f182b6f47ca4f3d5ce8581bfba77cfe2d58e57082f91143568eeabdbc9f7efdcfcfbfa7299f28b344e796aa88b548476d1cd4d312ab12da63ebefd14a51f894f4c18f67ba8a833b0bbf258b60b4c7bc6c6ba0cabfa690cd2a092d9512bd62f221e950d980b1744a186d0b2eac42271eeb0ff63c8f74f03a5520c21e2ffa8329edccfcacfe4444cfb7270ce3da30d403d75189ad978b38dfa285af9e660279aab62cc6adf6f161049794156732f3b1880a6361400073b3e37e91fcd3e97165be792f7c494a04ad010c13424146a8b2b7526aff66808e7ce3a9098a08c04274880675dab16944d24d926726b0c02ea1384c9bb4f17165a575ec3ddcbbe2b5e6ee9d9c1739834e675df3d43584341472d3f09bb9a4aa2779c4780fec38d581397b34b2e63da96440ce4c1baab391bd9c6d9ba94cda54f2743a06d9efbea2d0afd5ce73eb9203fd83a976f17bd878ecddc46bc63a93cde6796f7d1845f60a28d57e8c38c16f2e674b6db6678d3c7b057ee0ec912cf09001b6533b2f40b73d33052490aad7d868f01217c3ced093750d36cd66884b670adc6f5a1fabc3c03dd6b3825e2890c29ddecb34077c0ae3d40a73e17c03186330e7e1175929b4b3191a21e1f77f0cd81f7c945354f9ddf26ecb7dd1f9cd2a00fd356ae00727f5153dbcc09de1b3f50bacb43f4de365bff41cc9ccce1f30ee769060952e6e284aa8705dd91863c2acb9919ba52f2f207c367298068063feb6aa1d33c3f5d2bdefc1fa835704188a3be4991538d86ceba7a2645e6e6ae57017f8cc1173d4e5e2a435f3aa541adcbbfaca4e3b4d325a5643af687002463b1547e0b6d6bd18669d32c7e91d1230476c603900ebeb6b43cb8a5b8e37bd770a38eacb8d0b94f46e6688d6702e3606ada8b7dcd79e8d4d8443a67b296b275d5e67fc11e2b59e18ad35d54107fc4493957ab11275fa52e96776529dc6823433f97ae0ad3b150b758cf8cd26ec57cbca1d7a816510ab62ca572be1478fbb30e373ec3e0f6f1ceebcb7f440d3b2629f5aeef020a214dcc0448a480b5c7a67fe591ba3af0944eb832f97319b12caa201fac95db3c9324a14da671fc588634ad75ebc7fbd8ddd5444c762606f17e748e925688c15ca6e98ec95c403a5d3eefa09c7e72dc2f23b54320ec7385365a40983292f629f717aa2efafff1dbebf72520d47c6f5c58dfe0ee6c2b16ef5a42c4f8f5342c868638f706881e0b99c8f6cef15d893c336f05e5760eed0dbfa60cd934e7e176efc47050448c3e21e7e3e7e737b1f86b006d2411c9ad44744017b7a64df7f2299671f63f4b83c96076f35374a537eeead988a0dcf2bab9cf72740f95609ec569e968f39c12d2d6cf38dd40c4d2d1a2bceeb63a790e8d29124dd77ad1384c17ca5d614e9b1e4970574778a0afdaf8fa21b83fd34de22c2827652af00c1ce3bd4fff635f968bcadbdc20195c644b5591ec30253bdc682cd5792be4042c3f16ae274a8b3ae669b2f836df19340790b74125af45d96171c8bb8d5d7b3de1ebcd8abaa2ea90c0a3cfe911a0bb2b50d6e08edc04db8a6e95441d4f2f1f66cccb60134eafa9759d2727a2fe2c33883cf01940c8d871ecacbda9d08b6fd94f181685ebd58d203043ede3a4bb1c61eac37186149a98095829e4a9ce3c7c81c00955b03ac3f178cc0619045852c3a1b8d931484d74c53592578434c4b0e8895b567875afe108f509fc3414becc199a441e5cc8086ad77bd589f3e9af7ae7ad72b2265e6c11a144f2ee8246329fbda8c6f3837fc4deaf827e7b9d4dec027ff1b2cdee7c50632833fabe48efe7ccda5f4b7557f59e2bd4fa81ba04c293d4657a10f275fa5f69f3679221e9c0083f3189a3749c219ac5adcfad76e5100e8a306381945ac43994b02e306c68b6a8d5d1957023ea565776286179456c9741a1dee018ab0adcd5096606d5054a72a6d6cb564507b575a1a45635ef053768473127791877c532ba50240ddcfcadb7741500762c824af69708e67073c8a2596954a714b11ee7390e83a0ca6c56a011f2094c4a85074e4913b40f23b7b790c559e0e5dfd4a7afe5f19586fe95e6d5868476b8288950f518f39714e2152513ec41654d8f2ae99dad14359c98b5005882431b4f8a7ebbef4b27ca02ab474bfc5b5c4cea4560fe5b3223c6a9f82052206f051f891636ad6e5241b81b0107ce941f7446d0f7a04b08eb1524c3f37e0b8c17a0cb3e5c38a3381bd665e9422e94f3f183d5daff25e2468fde21d863e65621a16d3f1e8ca3265a14872902b964adb84eded51f6f9cad082a4266844b69b4aadb63a2bfcc48ccf84b688768a8600f205e2c0e3bf40bb409ec513f7be88d7c3b225dd58a1a8671f8bbe4abd7b135357bfcb5fd807eb06f855f49f751931695c3d466f682399e56257d08b8bba7275536f59c9dba23fe1e2735b7be5e987e1b1aa6cb7c168eead228b72f41278c949689e240b81e87d266c09800914fce03716fe23d173297d3964bbe7dcb1bb0a076149c7515d15182aea3faa5c6a16aa6ba0d8a2930236ac3323ecaa4dbbac5cc82d57f34eef119161f6ce4d99aedb99f5c48f531f058d2690fdcc592d8aba9d8994c9d0e096d3a25d8c104d858c047ceeb3c218c89e39a7d0bc6b349658c01cf82316fa0c4bd868f22a95ff6a1d7d75a01b67116dc8082e8db2d07089b6f55ba5b97bc0d0bded9925e557cd4a0ed8d97d6d7f49bf026b46ea33d92dcfe760960f0c52120092489f1f69292a5205b186ae81115931714b52786d27c20d882bafc8868bd033aa2c7f1e615135033e4963dd6c3ea269e6fbd31d4fd0849c0bb4b1d31c79ec0c3ce994c68c2865263f8d9b3c2b87c9200f66d6d077337cf418824fe09f0b3d01a4f1371a1aca9e97a7dd10e3de1fea5bfb58a946f3d005c278e77df47f6faae69a99d91af60bcc9f5b961b8f56f00010880d243e6da5d2605e895394283619653ec90ef923c03fb7672a255e9c076fcc64af6aefd575c69b625b3344087e4f576b3a7fb675dec94201e2996cca5394034412728507e959d57d26919612a8440cce6de0ddccb0d0f0679e2f374d55c6676a4fd53e88943fd6d10a567c5cb31082e3cd53bba84a05d611fc60c01a7a9ede0f0bd9215d2934c8c15a7a21e304a60e5bacdce8705b62692a6a45336a840f3ebe118ccaa4ba3afa843189dbef0fb2fec01513613f2c1296cba478a5e8a3e8f3424c1762776e70e06dedef0896e06b58e1e7e5121b2b71cd6ea3bdf486fd5a3aeb29d6e7ab6cf4c6a0df8258aaf11b8b89a0f4984f3394f4c91cf509204bce6bdcf109271d3813acd245d2535b585056984d22cb3a54667f3ce1924c15228d89ab30fbc8e160b43eaa01fff5c0d3df40abcf03b45a21350334a0b42087ad91e956b6fe8d519533c157101e46577ea50691559e0b5b15aab51c5de1efa3f626ec2d15afc2313a9ca14cc8cfa24464627efae84b4d40853cc3b5ae7dc8e9dcb9b080613d817af3ccce793204801b473c0f1684e8e3ebbbfe0d293d48e46ed81a7058d72170b050cddea463f04ae944a08e3be4c7f97095cb09aac0368e78f2e3a22f3992de956e454097d6cf76901752004a3cb225bfe0c12fbe76d32d30f34b848b0785e1428c08ad54ae5c2987be4f67b385c1711e9fb70000ed4e15b25ffbf4fa2716890bb241a0ff6633126f9b4acb8a2de86c9fc59e0fd2fadf7c244237787a08bd9888f7f175aaf6c25652829eb4e103e39a509382b4b1dce425b4c92594fff6014e020960741fad0c24183fc3adc883fe3239a6126a4f3ec2464194a5230e1455bc56629ef6996871f0cb48dd856a30b1865335674ca8de4f26357ef4e44e202cfa4f0223230ef7ac5c70f012ecfb64d0aa05885be41e55dbce517da3399e5b5a00bb11b920555009771d29dbfce8475b53ef1f3b0eb7bcbaf5f7ddfdc464dacd8ca16e61dacead00da5ebb38d5ce99e35e2cc53589b2ea170f266271e8416a3eb7337a45a868c3345cb1461d55471d294b7b15ed77f8cb0845a392cd6c2dc9c3254a8c0e7fb42936ff35c449638005220a098e7807624628d1f4bcefe46a31d776a58ed1f182d4436ee0cdaf02c14a5c2b58ae53f3aabebc8b0bb6271c80b616fe8d331a018b57198f17b92e5d78b24b10eba9238019ffb512ba2b18d7b2e6749418ed8de8bcd1059427ab9eba5c7aeba830522722d845bb1744e8f94cd5d8ddd790d1abe9ad29d5fe77a5498cd78b0b737a3407e887cba52f7c83d1429d64e45b089ff40872cd2d98a38d8e9e49f51dd3dda68454824a34a72e06afee339e69d132c36f746d65c9b1830c9f07f03d8db31eac864967604724baefb943190c10d83677fbc857d8577bc3d67c7f56a0819f2bd4c9eec81c163d5e212aea4b20e7f90fbef05cf09468cb035be18af08be0c3850142403e9c24eb16380faf5f09560a6c8107ae465cd06d5bb85edc4cbd2f3ca2f93c1ffd09bc9c3875364523e91077eea716f5b5d1d8024187cfdde145dd2ba0f1d11165782458806b3fdf54e21b5b5af2b1f2f3079ee7af4de9a4aa8afdb390acb257efced5e829ab4fa4a1c4fc8e9ba7aadd48dbc9470305ba254aeda203dd860302025614c1c54a33d3ab36254f13040e59e12dc02dffaff8f2525e96046943d5feaea6c5135df70f00f3baf15af5812dafc4e39d93a50693d346b77c294f252d8d46b3376b6001ec3951fee663a18b36d8e21cb4cf25528dd07b47bd7499660d8b751d1b5b4bc91299934e3c3d6a774ba7fb8a34a4c3d4a8ba028e0cd96f7f4ec597871498a934f577925e2e28ed6303c59d7fb24cfb11571e07c65c2b6e636456473253d023dd11530b7b0cebc33c8394929c3347ca4aaeddeb19913f6c53ec12ecc941dcd0b2846f0cb01ec3ba1668ecd3f3229006144cce36628cc0252edee9041ec4382796e273bcd6fd708606de8300cdfefd1aec5d9fd096c08f830dae349ced8d3b8b3c9ab90995fecdfa2344e25a512736c664e47895774890783175a9ba7f0d7e9af75a8ab3aaa352008e46ea6e0dcae148ce7a044e050cde7e356480ff231144d5caaf0966a380122ae660e7080399a9e1f79703df6830ef774442e580a084359d794a448ef13e4c1c66e1bfe79a1c8b039f0f6c7dab7fe674f060a2c6a8e67909aeec13c7e6e684187cc0c13a1a5540577b3828b29ad93f1c9bea483d503fa05f64e16aa2b436164d5bf0e160deb569f5ce689e28771bb3e3be6feb19af742fe7fb616b57e3ed26f69c93735b8d6222e9a14f1cb89e671484d42efda6ec660430bdc5a43e26885225df9fa38724c259bf3ca04b02ac917b8aef08057615aacbd5d59761da25732ac0f431d8ad03ad8ff5dc537458ed5caf44818ede4d43ff74062fbe6880120471679134911216b6f484006ddce29761a5988165f3160c23cb18f15f91a9f93d04dbba94a98df2bbaf5d06e68a52fd739560746572881a03a51f130de5b55fb4430d89364d1ec15ff6c6102494fbd9f98f3ae27b24fed1f2c26deeba58a449710daab3c319f69196a946a99b7de1a8a5ce943eb943e0db7f3610d1a80938df31a9fb7e901f80800436e498f179a4f1509e472b94f18ae929b58c14cca16c71fbae4b36fd4f785a1e9a00629bee43b551f4d2e4aed5c0876c71c304ab571c1da9ba9a4e751b8643c4853e8540685ba5ff522cdd81272a7ee1325c204ce6d06462f37d7b5ec79e871375e1d050b547c1079b6fb501439d9fb69b3e66293a8e1d85963571bac663f6861bbd291af4058f76f84786ce7fad220385265a615b58c88a39de20bb560bcdb90a2dc3bcc8099db558e52dcbc04544d539675c5e82a165fc686282159d4a01662d94f4637669ea57ecacdbfa68b3ee4364f051c565700be676b2e33930787043b91f1f3817c8d2c7315889ba29af99318b15a8eb0d08b8b6d2898e047078f4cff898f43752094ea6fccf5a8542e3a590355f469a4733ede797563fd5f2362b878d51bc077159d6b15ef60e7dda6ecf6010301d259bc952d826da82eee8bd7922676f73d597f8c8e7fef0f41b70a0c04d3db53f2a5ae1b5a3f59f0e77e6a555f91bd8ec563c5bd73228501a27b72b5496cdc987900be8c04388bfc83a1c92561a013aa248c2dd02afc92f83c8ad5cf247df6be7f8c94962f0203d9ba6358ad4000366da21a94b7b84db6979e3534ed4cc3828f5c3f89a03ac53f7905714d2635e5b43d5a02f04d9f43410e683ae6925d9b39ad3696089353196e7a713e297c3befb2c4642cf1b175aba80287c11e30c602cb5a5437a2d5504dc9b9b4429c7847442487b6eeefc301419d740be24be82c362527d3871c1c7f87fa2ae9ffaffbcc746bb6a6b0d0d9ad10f9949b86acf277455cf97c3272","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
