<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41471cf77fb0054297976975336ce5ff5d0a60ea9a317e7f1d606007c29151920d9fd263bfac64c3eeb17ccc3714b713e576dcce3c621f55826b0dd69dd92d4a4291c372b8e9bf572f83f2cc7447556c27a96dee8dbf67c4801232a2258b302ef0bd4bda1f871d410a85636f5c42fef7e5e0d28e5250b49a3ad0f63f35f5d76319d85421546d5bf64a24999fbdd296372bd0c93abce7724a498f258758cade00eef5ea9caa7e68b97bfc98e69edc788bef5286b35d9647430ba9c5d0b5e4dc86593f2357cb173b95c7c5bd9280eba760182d19fceb1a38e4e8d155bc8cb10e5d1b5089769652291776b5c22e4b6f4d3f2a8db31ab0120d2b8e0aac894c6e4976a740890a51c85d6b20ef3071b8ceaf78da1162a916a08c01434e4288da9474f69d92dd3efede541cf1b3348e2651ee4be46c507c3a2baf73786b6e4c479cec70a649506fc6ee3ce118fe456c0acf65c2fc68afd8faec8ee1f42f1aecf57e5d7f8040b9e7991faad164cd8cae2b44fb30add7f879ae32f91b427f12e37f07f3c493da979714bfdabc857166b5ced3a02c6e2b10260138fcec0a5327187ee6929c65eb3412e7c6ecba0f8b4eb1fd06a18c4a1fdc79d86a978879b9c08d904fad91a7ac5cf9ec56565f24a02b862fb1f8dce9d503699a1e4050a9cf8bc3f5c668e6b8c4206470f1e4a750e857483380f1c7f4e7ee95207b95b4b642849372d3d9e10fdea38cc6e89b4785d074220024669979d162a4e01c91acae64e3cc9ac3c36cd0aa6ee471cb1f7eb129aedcd3091cf755126c54a3341ddf475b52d7013d83476f1e9746b3c5a67d9a2aa25ed4131501c25c4ee52e46014c26a5b4eee95f027882c6de73af7a776846d24a71ab5d094c93f06c1826bdd008a6d6d7e56cd2cd8c56db04cdff84a2de2fc6ea61a52b84436f70b6bfddd29b39eaae9e56ead275bd09fade1d2fafaf7388329f5dccd9233a8a4718747f9045e1f2c5c91ae5385ea6e7cd89f258bbf75d8a78802055254c12d84ab3f8cb156c164941ef5f1d46a88ae6e0c8548093ed607539d456355f1dbf511c5292cf9f2acd60be520e31e91614da90fa2853f50c642344232e7fcc80962b0ad6934887fc31cf4bc0b3a2394ec34a9c3d526ea6635c6b32632fc6092f841fd7b75f69d59c10f4f144e40cfc4f301a033699f4b752569239024c9bd3b77bd34be377c9201bb54983097a0304b78df8130d33346c9209a780b0cca4196809b2fc3a5469ed4ec97df7c8840c065862642111b40fb2e38f5c382d8a92b064a817e8a2aa9f04d9fb19c2f4ec0f8069223c497d8c13837e2da14e8d9d7a99e06e0a86e10e1205001c2ead272ab83011006d4fd195fb74b9c7b282b4b7d4493956a37d0f34ba4e3650b0bb6f9efed9f3cb822bad8c97b48e3fbf41865d2ada73be0d95f2c724b84ba96eeb43b9abde5b40a5ef1dd00df2733e78b55b96ea4799f86d4207fdc9912a7b5cfa8b222fad62095bba3181f788827a75111d35e264451989de2b38d4fcf3d8420acfbfbbaebe090ea17a931a5fa4652b11b29ffea653f776779ec7c993d9a1bc72cc47423ab7843085d2e16791602021c0e044c673ac9b059b72d2155083c7a2827b6b9f047811c8bdac551abca268fb4eb1cd3931d2c2ecaa54d4f3b63f6a22e72ee1d308ae7b49b5480548d83b90ab7eaff213e14e4762f726549d7e6d3b7b3b46cc1ac59e3cfb87ae4887052380b773ca4e384f08bb12118b165feebec40c2dc08b92aa5dd034804c1c5bbf54d516a748f0f7ad0881ceb604098b56a2855a9a1254bb908a3e65a3e75b9244c54ef26fb34ef16325a6453da2ab0a56608393f79232d063871b1b1e275634d6ee021af4d73425aea5cb548cd513769cda205b085102464d4fd5a370bbe0bfff448b96085dbcd38e0f8cb01a50a9e40d23f71c04114c5e617ba95d5bf8f78ac4157ddbd6bcf2ed11cdb3923326ab060d98ca41eaa2591657701150d773f38e93b2dbeddddfa7d7506864ff18a7863d11da63ee7839657c5d56a15c988303e3f075b40f3fca93e4084f02f8abb743d98973bb195cc5e961d1b88f887ed947363c6c7c8d1e3a396ae94bb327e32f3720cf77f9e0486ce46cd9b9dcc149c7a5c548b95f103e8475b911df26d55417ed093e1adbc124c2410b83cab99f02d46ab2f49510d152ee4fcf9c45a725ea3f1c7670f35028422085b9074f15fa3461596476d32396dfc5c5e0a4b67f66911727a293311b95a0e7188c1c9e9c29c7a98f319f333da0ac47d2e7099ed2dbc803e678b98870b1d4738a87f71b0268ee7b66523c3b57d09c6801d00c9a7e71dbbb55ab9529a1bdb3bc2d9ef5043f6f582b9cbfda93303182fa05b01a9a310309d17f6f1356ce74df145f4cd42e3649bef4d7f0c16ef5a5a7575e748797e5d8e970e1ec375229b0fc23e7552ada27a8f2e95b75de90e62266f1e82bc8ab1e1081328fcce0436f16a8e09b52d816faa058b74d1f66cdb9778d1ba8e12e2b479dedcc720d5f3568278d5b868cd027e7d44bc63bfcee5c3f9766aef0c5a4db4347c5c6ddf62cc035131a4bd847ecfa6c4829acfac8b2d3f672702d195b845145c2459fbc7f358e3132f3a30d58f617999280f5f54bf5271d3ebe45b57722f1bf92c4cb7ebced93043aa5d36d36dc94ba2f612ab4b6065f0abbe29deb51407348e7936028c6edf098e83d2ecfb4c92b7eed24cb74e00be86974df43cc9f8aa779a762e3ddf0e11477eaf5fefbcc7533dc56e179da1e7cd4d9145b41809b53ab40d1a26e25f371e824d7e65395bd2fee60464a36e1d5ce0ab227d4bf1633e0f9be32ff6db515d46255eff202d020da1fe9963119815cb18a98cbe21c6dd7315fc63db7650588f332bae760a37daf5ae1240050c1f6a0d89963083129e145197c01eb26540d383c699d060b5d8a72f3bf7cdce15f6d3feb67ffd7deb8ffcfa6374a1e8ccb6ede038e5f2a97b6ce13674f0c3938e944a7e185e9608911513f2ddfa8ca640dd3f78b86b91cb112411f4aa13bd5b26c1d6efb57ee7cb328af1654c1227258ac7dcd92948cf8b96a5880a8a2abd49204e64f91e5e1159081be183d8529a80498d7b030084b3cfd8b5a7f6d21873309ccb168d865245d917f12f812138562002bf646c4f885d2edb65190980158406bb9aef86f568c4dfba914df47c8beff53eac5342447a60338cb10f62d5f961ce3de581b8aa775c6ff80bc2872a7d97de37accdfd76bd9786eb57be58435ae65db78c3824d60525d90c8dba96a76ee92023f5fc641653c527e0274939a7461c7c0ed4f06fac0738756f98eaf7dfb60cd86bd4ed9cab4e9ca0fb922f37739a8159a8b12682e6c08fd0354bf3e855717256aff6e1bb81792a512793d9e210874a0ecd2d0e224b7a5af2218444f474dd084fcb4429bb63b600c57a6b0948bae453a62fe89d957451e6a30ef2e67b5cc6a5c55ffd3050d9e76e8348f2e0767d9f29059da7d9f719634cd34beb3d2fc4056b123767709f8cae0ebd7604ce94ae5da3ce03a8ab94cba63a82020ebf41b2eaebc48d9a9e5375275956e10e97dc06b95428615af3b721c380160e5eb10becbc603e57b4166c1f5e986eabd8fa043e2da5f4334af0dc5eede768502cb3f56e64cec7f9a6c16e5f57feda5de59ac10b26f5d2a330f03abee0918559e4359edbca15340b3c4f90749f9dff1cd3c238eb03c8e6a72de02c2df04ddce30e61f6a7b1f3aeb9ad868add8670349503c00d9043effcf9d98877fa306ecd098af51d7beb95d39f085d90a36836b6529c7b35d79ded795a1c26f432dd0044b7c3542b6ff94b9e194dd0e4373637df5f8c2dd4d341ea2fcfef619cd522f6ecd0166ea6928cceccaa223abc641bcb06251438cb5b99d1255f728d7acb5d643ed60c7b93bb8358e4b2f25943455a4a4b0aa641f83a8f40d56606ab27535c0becb76ec347ade2a51604ac0c684745aee9a7da4e550efa74b788c74147468536748b1c5e8a253609fa1d002a17e4422e76ece9172fbe079e4fae20f67424b3194da406d0bdffee3126498eef702ebb5a3cb45e7be5e1b037b07970556f69fe0d6480645b24fb57caf9564ae5a959ed04f0b77b63790829975899b2d4ae29ac13bdd6a421a9567b574ea0a0b6d520cc92213915753cc7a93cb4a7068a269cd0fbe9d5d3ba315e6d750fa06cfb6c36f3b840e45cea7d9966a4e02d6d30ede75d25e1099a84a136e7c1d8fe49e92d4fe611d0c8712703e9f992a8adb2cfc03a44093397d27232cf91be77f0e85848ba90ea3607c52b07a0098cbbd3fcf45ba523e1026713e2232f67ecbafd91d4184fd2992378dda514d231d10321a2dd542f7a6e725a185d729d60f6d015fef7524d1b69ce4d06b60644e260762a19bacdcce7488262e3bedc3067ec43d0969dd61aed9facb99b3fc9b51ad0e29b8f96e75b5635b070372cf9c8bbb6cee10a0e2087379c3669ad4a6a834cdf419993cbf9227caaa12f8429e96d83e57a89e242ba32d4a37391800f37c6ecb2d1714d1c976a59520451cd734c62ad56fb096091a36b7884ca8e24cd4eccb95f60e870195b0b0c938bbc5389ad804055a4f7d74a18bdd4bd80d29bc63f10dc4152904daaa65b42417f1b6703dc67cf0445eb23e3e69b99e5b9ff4a8891f6b06e057a2eac47a5fe1e9acaba7e590714bc866a1991b12bce7bb88ee3c01b9e44a459e508025b8f07b2fa98813ff2bf211269a4c4592c6bd07e246f1c577ab17e8ecfc04c357dc5292c545e318f011c9b8cf7b2cfafa644a329790c817db64a8d4a93364a4a5cfd5c01fc292c86fbcd372afa291d2c4a386b6c5ab4a4a4f35fb1ebcd475af210a9a2b0ddde0ecd49e31cdeece23113dbd069e4c7cba9ecb937da82709cd31950df81449eabbbb6f3db33adedd3120bc91411d2f2f08de6c9d4fba412452d5c3bafe73460e52b4c9830125e80c4cd7c167cf860c6950e5a300839dcbc7de16c4962b96ad894480e11c1413695984e67ff67b5607f1b39983d054a0b3be924c5c32a17d3788b0d047ccaf395a87d38001ab68f24cd08dc8d6a8d7a3b9f5e5fe9a19308943530a6afccd9345e1d5d3767b1618e3bb2230d6b732c7332fa8b23547418101023fe4c05d5a5020c30c4604a78c5996dfff52503f89d8b37a507c2c09bed889260b82a787c1a002edb37bbccf0e7b9c9bb7736d2a22f69469163c86d22ebd43d4153fb9fa2de6c14ca8a9b743fcf6fc9dc50a147f06e0297e2210567dcd0d11aabc6f37caad3097f68dc95f4da28bb4b657d2ebebd5354b7cfb3c4789af89e331bcfa49c7f7efba2b71ec06570dbdb8c094449aa34ae052de3e55de229f7b887844d5b213b5163d943bd7aa54b5ec371701c78c174c576a7a3f39980b71eb69a02c50850da6df21854e2b7c0fcc219ba94df442cf362bc472a1b36860a364a938509acbf8d259e745307d508af0936fea0740eebc91b9177ceebe39a308a384950ede6781ad90834f84bbef2c31fc90ef4f3b87d075059a92af66c3ec783203b4b51de99006410120138b2663f69cfc954e28bd3440b55926d78f8faa844028755e9050f86c770566e5e16bb04f8d69424e9e90fd7168953e27c27fecba6d1d99066e6139d3967a54b28ee586899d8d951e7ba0d98369a5431e7f7922e9dcfae8742f8f36d5ecb437d5fc425259822897c7e23db01835ded7e4f8f38755374fdeea5f52d4ab83e6013339b7b91fcdefcfb2c21efa2f19ee94168d1474bb1d0ee3d790d721ba3c473b1aa2f0e9fe1710ac80856944010f135f46fbeafc48239fd3f0345c8d4789fb3a54da8b2a5aeb7e2ec347b617d3b69dc77bc6c05dddc8ad902ecc3d1895ee1ac2427ab50e6412bb6adb2cb64599a645ae8c64d9834eb2598f690ef33c074cdda6ce1ed4bee54153a949b3b20f97b54fd5a55dcef5bc358e7cae6c6d1c02c743ba1bde9d3e4472831f444b935ba8cca5991d9a960986b9ebcae7bdd25b6ed1fc96d988cea6fa3201bcdeeecd377c6e602c7738023014714e547f7f3716aafa7d445e3491f7a591640e87cc7be8b69259ce968267c35bc26234ef10cc248fbfa06569e3ae0200b556582494d66297ca6e9fdfea7cc785cc3d58c65a85d36c70d4a02aed25ab029a18cd185674b1785fb688f0616c9ce53ed45b4d392b23c7a45177b6299cca54536918c496d6eba37555002dd307baadef4a18f58880beab6829f011a1cafb09e52a08d37044fb001b15fca48e95d7a4183b4390d95d8a22431eca109405b35a2ddaf6aa76b1640cadc66d6111b25348d7e1eae4512d9cc080a80e9657b5460d538c7cf0ba8220f7d3b4cc599ec302692dc82cbb5754658ec2936097f4b2241620ac32be8c91707fa21ad519176b43624513976760736da6be0adc4a7c84058989bd85114ef897017959cb334dc29a0663b8d4a7c3feff9ced151d84d87b264abf60e35a0aabfeb94f5eb2ce32c18b17baf56417eb21d39ecdf4bb482c850e5e03cb77ae2cfb4f2e68d588e53b9554f740515bd0a9baf93dbfb9fa25605d11fdd18123515408e8a908bc06f27a539b22ef7f402b8e5122294a81cd13e356c70f45209a01a4e2422611d0b05ce498417ffd563a643d23d969916203191a88cedb71f421783c61e0dd9f7c3b84947bdc65c094e1289d57b31b7b272363d6ff6306dcd0c0d75d21a1897c9d8dc4104c9ebaf8c44255ea8b7ef3f1c2b4ba99fc692afe8b4b56ed8f0e7def2f4ab6d90122e17eef599493383c602a6d468a55cc9a16b7ea4bc23cb608b677c68910a2d68fe99a984870ca07dde4469ce71d07a78c3d372234be655e9aa77e795bd58e06699e3e41ee6beb1cb5c5d955fb6e5c9a1bad2a8a75ea525c63f513a7e71e8523eb786fe1a5ab9eca7d794ddf62cccfcca5146f2b6cfb2d12ba368469c59881a62eeee64e3b79ce91e4f236584b48ead81df74eeddc4b4cf14f6206822f91e164e5f1fc2629e0080527b46d1fcd0b3e9f3fd65818e35afc3de4d958ca57fbe4f4766ccc07eabb92605905f69642b9f1e6d465181501e055877b300b39baccdc4d77f82ad413bd522749ed1dd21b257453923093a201b641251e3dcf2e2fa406eec432d606691471ab233cd5cf29da822e9d858e6d10be1a1973f3740455de31963067cfbeaf4e3ca5811db5fb75de0bd94b7da282f648041407c0a49d9bb89a32c0739983180cff9b6e5c8a5d742490da9e8576830d9573a6a408461acb53f3973bff54b8f8b393a85e2f1f62bb2b3b59c42833a76771ac2dd87eb41b6a773502b9a8512d2477d20b7953e318f70285472fea2d91d6d27102ae4fbe010fae429aa444b5cc2147574b59775472909c370080fdef2a7d3e46273d1ad98c59755dddd356ec8551aa33ae840fd5b78e21b6d8590423609c7205028c407919cb5924285ac9a6c67aac9815db1f3da166ee7f42f1c4a2a80b7756b6e13fe99c03bdc9cae52c0b9c22d92bdfc83e8e6fed15b1b51d74f629a42121ee9108e2efb2a5d61620455fbcb3a871b7b99eedfdb085916a15fdd082c5b5cb428853dcfb4274db19b789ef79de2b20150100a0c654e5c18d5056284f9411ad07e6db0c4f684ee687551f2379009abd0a0e71cb6d493df64dccd745ebb7a359d7e4141a3cdf2f84ab28a3ba60332ed791d11545da68402bb51d44ff88ce4931461160f1fa6cf3598773146a22769cbf5e2d3c9fe4f1d1629153a90f607067a30bb919fdeed8e029d3a2432b4cef08138a4b1349313cb94fb3b56534f71eb398839522caa0624cbdd8e8bfbf64062f6dd4ac7342a03b50e0695e8ec19acfb26de5e018b1faa23a811779a60dbdfb4f87f24db12228d83edcd375fc80e5d205dd32896c5da36eab9661330ac8abae945a60d3b6dc42cbc3c46c40962698aec46af1d273df1249013e4d09c9db7d7faabf8edb7e108efd59ce50c78b25e9cb9e48bd679fdbfe8c0e375f434f0de4c34e163840271231ee301295552383ca1d19cdcba4cd749923d92b9b631ed1bc398bc38a182889f513ff404ea80b704cf91e05888c87c1000be7b8d122c6633ebb77fe35b23365b0302fc4119c08a4b4e31dc55992eb6da94363cd92af846d8c8a6a737ef8b21c68928bd75d3c1fd734e312a14ca3b0953a253ad602d6c32b9bd555300f656e9210f3b32d5c1b5b96aec12a11ac62af19e7222346a7620e152ec2871845f71392f08c85bec13f060bd6b8898eb9cf3f4a88d85b4df7ce997d0a29367c7d5985c8862b0dbf5000989a0ff1957d14d307a9795bbf00af6056316184d38ed4ce9e8b183d9f1b3717f92ed2ec176cf0abaf0bf002eaf8a1cdbc7a77dc8ce7809a55e9ba4eb2db383025c83b476db76259e0cb6dbd33f4757e6f013a6524fe5cad7a1853aeedf6a2ee695b944fd5f9bf53d9af80e8f7ad9f2deb6b7cb2447c6854a81070977aa96df7cc28afecc802e3941b57fd894293e096e556a3b8f4c8e9e7d97e5f3ab086c9a8079729b6226bf83979374681f75dd19aef0b8e64e70c9e0b8f7cb9afea48d3d592b65f1d0f54c768738b8b83bebd923d4a7f309059f67a681e62d80e28aff4d1a74390ea5100009d23d55d7f03cb5bf034972756c588eb02354fb7f3f36fa605da2e31ca3665154314cb7d2652370b77611f3285a872d025daad322bd990fe40c82e9342448e20d42b67b8d6d171de5bdcf375bac44369a85531d5fb957dfecfb505c9f5fecac049f1c5136b4411f65d1ee703f47e31b26c3ba4ec04cc92d96098b5b1eb0b6b86206fb96f27fab70df0744d6f81957b539c78ec77a0f2c0b39e428d268ae9bf74a53d282d9f865a87d319909132e3f5ea2fea8d806c77dea74eb4bc35abc5bea7d90b7c5e84e16f17f1de40ce2406964e1f4e275dd80de5cce9cd5eee5efe3a1ab2a9bd2603e29746b4460c50ae4ebb613a1addb93f1838ab8ebeca66deb47536e2ca2dad7ff8d216180349c1f114712105ec20e6cf52784e8c7e35de6e4995c0fa9d5b42ab7d738326505ffc60cf2a4ba1f1be540f25b9889e701fb63223e49862e777db79b701cab496ee69c2add33b7206994f9ef35ac58126970a6f39c1735e02b9974fbf8aee01c5a77cf29baf4637a68b4ed821835e724ad13a03b406d107e44baf7f7bb0d92aec9109f362b895190fd244c290504e41485bf1b15c6200f291614a09303945fa64331fa100039815d72d6fb71b5c8c0ecbf3dcfb48638c29d24cf6c5c202c3a036e9c98e8862ba9df5a5e64c30f671c160eb2b33b9b234403235880a8ed93efdb0bb1275fd5f98370aa18bb187b977f2313a8d5b0c0aca3519c0079b181b7be4f47e03f8a107f9c57e657900c968f63b2ca61bb090e900f3d26f80f330653a34b59644b786cd193b9ac293d30623c36a7748f03e9ab5b69a674185f599e08646a6ec5c5c91a107d1779146aa6c7d84dbf617e4f8fa1d9944866df48ecb12a44348c2e1fa2792cebc9fb597b805a9f9e7ab46f246bfd6f2599e7ae1211920bbd8df242225cd7727ba1499bfb2e72671b8f428ea9dec911c19311711f68563ff71a65ab904f77383dbc4b0a5c5bcf9df0b19bbb340a1d8ad2781dde7679b4b8710a618560a56ef101d6c48aff61529c41d6dc92d306cc7a5c6048b26825577a4741e89c113ebd2e687c577c34445990af70f224cefa471e91d92331a92110912af586a0f09b23cc06aeb9d55848905a1cc98922e8123a622379a59d886cf804d940fe35e80836a866f37940370b0faec5892c670944d6cdf76bc378dc142024ea993343712bff8e0a547e16a85a321f7f9ffbec3bbf45dc841de4934392161bb1b50c389eb069ac46a06a70538d434624f101dd7a635828b716a58404e7dfdd219aada798f508fd16bc071a1717972b665b888b69296f0625d351ff243e87b2d1b95c66cf19383160cad638e8f98f9ff39e12fae8d9241781d370ecae54972e0a6ebb6159e3f4048fe6b59fbb387a2b0f5d649e93781ae05e2ce5cab17301a2e169915215e7bc9484298031ae4b0ab309881538b194c8b089c5f148bfff917685536b937eae9c0faf3eb609b687bc505de5792ae52877bbea902b459fcc497ace536a7eed48bfb6467c29ab74cef6508b8df5dedbfd5b9c04dc6b9e56b999bcb5d721efe3db4514a7dd6f6ff924459a3a35b93088bc96621ac69f44480d062f6debea082c355790d29b30297dc7e28f883f308461ecb12ac659c2f1a2ace6f1d4a4ad95891695b638f5b50c97f600c1976b8ef75b3278526b56284ef3d0350830fed22196dda3092109bdd93ce039ace8699a94940b0355c1c3f63fecc1cd5aedac417ba6221e3a9133b98f0a83965613f2255b5a431e7ff8c0f462c32144ce6a89e31f4cdfc0a9131a8d4ef35726cd8c98bddba3c2873d6d06ff9a35ca3cd7ae7c70f339c826dd9f788663d3f7e0898da6bbbd3de14d2e4bf7168eba64047297a39389f56924ddc284405ea2b31c52757d26ce401354a0a0128c766b949778c46ff1066d09355f9f77bf96af11e1a003a31007bda9dc5b91369dc0c2b787922cfb27a31f1505b0b2c23691c4e1e8d9d90a4003a063a9f8a7f4d314e84388d4c9119b6c89cdc37254db21d5cbfd4094f7b128cb932dabf80ab22181cbf775b439800ecb81a96c7d2bfb7a4c4ea22a101fc05684120fcc1ce2b46278315981932cc6eb32aa8898413d6c29957875d080dbc87fd777e643691e753c9da2275e3fbf37d1de06768482ad263a7ac5d0c806a7f098230c715fc6a7493176199feb74a31b18af132a0399c23f820b611fc7f24c06b94ad1b12e310c961093b7d0d25acb184fdf61ca4e6cea615ce9f6bddf3bace6899513100c13e11a0ec3b59989d6c9d7154b32e87c5cf8cc392dab9264394de51ada88d44208c5c3d229bf8d5954b30fd3c708802880448b7568e142fdff7e3ca08b8958a2695f60ac747b593737c1d9130f84575510cc4431f29e16eba02e684a15037cfc2e09ed6546654fac006181fbcdb4a706a4167dc34fe07d55d75c2324509d6a03ed2a2bf5d49ed691ec22327abf43282e48b28da19fc1855c6ac544f389e57d502bb42e80521b34932e83c93937654f5dbe430de38c8fbdf2e6693b9464395b3eadbf39d1afc29bf05293e0f834c7bd2261b8a6c4755fdcb38c269049bb7f767f31998c48188c93685c82e23808e1419d6be02e07ca430f6dd43ad63abe0eabba220bbb671ef4143d645658aef985b9da84e4aa881f3c7672732706e30dd99c13d6d2a99eb2321a6a93384b6fe9e85f7c837761b8d235690dc57f91c4f4971cd6003add9fb33376e1a1683fbef0a5ac1e64e031ed6408442cf3783ba0a27d9c3e06afee2054992a0c92f9819d3d49453b42904071cf4ad1258c220030a421d484b41070c2682b0cf80de26c9274a7819c3bdac5ee1cba1b95d14d9e51d423ed13266685c2908d3445ec1132354a86e6efdb24813c27d09aefb92c80127cb8d4efe8d600bbad6c9b9d9310785a8ca4e31e7a448e3740d8b5b9fff11ebbcac0c0cda9bf846d2194379db18860f176c9267e922760d08a7097f55d3ee84aa328196beb3f06ae69726afd39ed274dbcb0dcb6b33da778562911bc5ca53c39f06517b67fd5d27c8981a6f82d4eabe82ff5819c94dd671f7ee8f0634cc1f083fde322bd6978def76f79d114fbbfac4bc88394b912d088bc29626ff276d235ab7b7518d81a7881382d2207d3b837ed26af7463afdfa0a9e826ff262d1143de2349f133d9f0493a58b4464adbeab84afca9c3b35bc5c057705d269a916e8a2c165979a774adeac611b141285bf3103c335845ad3f00d359ed2f25471c43aa08f808431d6b2d4f05e6cfdc933292467f03528e4c7c3b740cc3d9c9cc82c1e6b9372ee94fed3430833c0fd4a1badfa2bae27d414a213ca50ca378a0ef4c6d9fb45a494188920226945f2dc45ff4b7ce5c7cec6ebfb196aba2cc32710868be08a02f8d689d7b85877994e67f17aec60c55be441e74854c998c0d72de8f5290edb86877170ec4f558bbc1bf591d67beb0137a6fd5b22247e5617ea48c404e1bd3c60af3a33a098f1b1ac982851423ccffb95b404352104b25300a57b83a7723d751df3326ca8ecff73346e21722b90a95d2a0114846b20ecd7f96d0d9172c37d2c1660146697fe71b042c3b369ea8982426b60333ebcefa24ee4a62d0539862dff354962f179e55123400b9fb06a1cc673d61a0bd4c9960281c9040a241411a6a4cfe01104851e10634c072abd7f4f3e508586e256d99a9954895459f34100f0e3ef9aa1223816d3794702e6d95a505f5e9ec1c7cacf1fd8c7f797e0893b6e84bf4d0518de811643ab698717612fc1731fb9cd29d44598358d4eb5985d12c8076cd2147a4aa00e992f9563a5134e6a2f3c61ada6288735137e9097adb45e24fd638f47f86fb0097de3146e447de822993364c67f75e707a3cc9359e11a3a2be2421467ba526ddefc67607e7de5ae709cbd354bbde0e1708226871d7eb14071dae00bbf0a5c9dbbb9c870a64d675a9c9c73af9a252de6a4ec9b6cfdd2b3fdd22a9970c75cb0dfa857b28cc194459e67e88c223a34dbbcda247ad41b0bd3e2c379ea468326a626642842447b57b708c8f3f4baf8b15bf9c82afa59a4e3efd0521b100a34b739a10a6127ff6951ac155e05495c3c6f8b00536e393f3696e1ad217dd653fee10bf9cb0ba25797c78ebb3fccbe63bc6361335ba68a029fdf859d5a833d13e4f73fef5d2b4ccf77b470e8bbddcd0b7cccfdec9475b0811aae4a8cf6cb698ba0822c5a8406cbeccbed11f9118b2ee9369b95b0af1c0cd31695e29af8c1a25469ebcd990c2773bf82ef8a9361f68fc3f7be60b7fb061513cc7c795a89506eae2db3646a4b79560cdc9450ec7849b77949571e5f406b7c795ecf40f5b6f82f3c91ac2e350e0d75fa2c1a2171409b3577b012f983eb47b3601b798b88f1b4ba7947743d2cb00ec2a830bc911f09ad01ecaa47c233a4332ea1695ea64ae48be92dadd60c44aae465b58c1eb81fd057edc88f2fc39df8774b901073708876d87cbd234c59d185041d1569548a87606fec0a1b7a047c465d50fd81c569bcd35ec7f2daafb7b95e05d78fdfd694a1bef7ae7daf617930921cd7fda3d379c2dec33874fe438017e4030068af9c5ce9124b09ace0345e653ad28cac18a46dd9a444a59ca8b6374e360f781666878606a5c7ca61271ca198e57458064dc2d14a6460ed645a52d593cc29df6b7bec16b8c49437919ecf0bf6e69ed1142a0b12391f64bca7ecd75d65f640d80297aee3d72590178edbae2292781cc074da9ef1a91b9f2995cf8af1c2e8d4dfdd6b50d1024e5b4b33d293e1250c8d85733bcc5e62a6eb9d8da13d643166f7924b2a3e4283bbba9eac2dbe469466d3f10a52e65ec753aafb03d957c8b43317ffa41ad94c2a2a239424b0502ca28d9714a048cb087fe3c272ce454cfaa440d971ed5958bb799533be0c07ecff1eb4e88fd9da1c3ff62e168473575f19bced43bfc63770baa8263778eff5d95c08afd5a52b3b81893972f7cd434c78b343050c0314b49be38b82c083449af29e5f810203f97ed665c0f2d55509327dd4bd9ba6544acc45c00378d880a8dc27c6c80d95bc1be826914facefe2703861dd494629cf01e43d93f7a20e0cf7bb4535f3bb9dc26d372e2a2704399e448f7477a1c91a4ea908eed1bfe070ce37a87a262e2f0a334a8b785e4f08b055c83538fa850dc9adebdaea5a960adf5184f703a098d9f7eb2efa74953e8a90106189597e7ad59d0481a6649595c77f3483c7eafef832bf46f2c572a794883f14316ecc2449e5727a8c6d96a22a784333eb7147e6386465af5871c540ec93570023e4c82c6d5dda6ffa3a8cfbefdef3bacffd13fa7eb4920c7937f31286426443b5e59a11990c4877c5cc759cd3e26e90e4a73e8bffb5746496873aa7e163ec4b5a9e0762a55a5a6f8ec166b1b89cd17c2cb3a140626f7b99c9044feb6031d680da2589d65dd32cc2a6b2d362e6b8cb20186f4edd1e49ee7874ca7ff48f47e9c29fd3a4ae68d26664ff970944e4b8547ef763f69d18fd4ccbdd5d249663bb9e3b27905aaa3822fbd936515af71711643fbe0637300ca637a10f00a5e6ce1e68957345baa43729a28025cc69d8104a77dbe2808e413a089791cc557d698cd67a0085af53e007d2b08855fffd361adc065de36210cfa5e7b7721b55272d35f0418106519f0c244e03a5b84fc6245acaa137eed6a9bdd848b4f6b384d6070ad8203fe87fc835c844d6b016b54acadd21c819399e8fd48136770751d9d1fab95bc394a617d34ef1842811309abb1988a628d9540d6627a45e84105ed60a52feea229da146446885987e1cce4e4e1175267e48e4548acf72b2bfab63b46919571c59e6be9e78a3f2ee2ab334e1672dbc5e330881501522d66df1dc0a5efe781324f1321a1364b440003d48f42724b11d8ea29fb3bbf2e3be974431349d03adf1f08b245e515297dc91b67a39926da051fa90715fcb82cf17148071a6bf8e807921f33f398c3d105653c743231f5d04d8979b2c4c390b8fc2e4c441b23b133a6e6ab676dd65a707f8a5e3474a2126d040a25ec12167c3ec7312a8daf0f2920c41808cb2cdd897fcf1ef8ee618d629ab43cb41e54f3e1e30d0dc8e93549a37ec6d07902a9d9055cdd611198e403b9d48289810f1ec331029226274d4299e0becfd1326333dfbff69971ebab90e29b132f5c22ed63409e4b53ae663954aef788d3ab9d4fc18d0bd65b2868995903b7eae0052cc8f1d3175dc13ccd797259478ba20d9d76720c000b2c6da0de08bd03979af8c25474c9e29ee2bdf13bbe6ec482e4415342cfe37b77867ce96e992624d02d8d41f8dfc9067c556b7688ebfbcb4d412e787c8f7e34af4029deb5475db48bc7deb0850b173f48062c39d45721dab1e50d34170118eb15877a889c4924717c139c36702e6f258224f2d08168130f833ad8607d279b058b8b8a626355b0e71025ab6717c6b18601379b14d49d4a7efba69f958a31a9dd3838b951478fb02a0864a958d2c21e05367dfcee55252f138554d100b0bf50086014e64184de32eb14dabf34068e94deb1896997ea816a804e045a33a7fd7442834c8841ffad5edc5c98858ee2450f3682baa05ce8955349cc6d6e988ef51f9212442e1bc75bd1305ebc40a533333bf12ca0d9063f335c2d69530e664e390433ff3a5ca7a2dc4292fa5dc520c9a67934bca8ec09668d70c7d646dd895c54fbfc2b51677624ea756d132a9518413d70aff94ab5f2fe4af9b3b60e7936b0ea7f54c0b71f58536b42f0d665bec9ae6740ca68c61661be342d04d26e1d21f63cd2eae8b23baa17a4975b4bb66ce70f1bde1254d8c4748af02f61e86b07b99d9a034725313ac68889df8476f72e6a3d82207093d5c30fc7cf3a0cfb8605fd73fe5e55505fc2c5655e35b147d39857552a57cc0cefa8faceff81f825725837f76a707795c706b57ff981a033f6944a59d170703ce6959c964d34cb9a5119331b32af1c52ffff9a7c106ae694f8391954c949221ac1024392259ca4660f63363ae9511fee6ff3ff0325f4685191171425f44f79c9c3cc007fdfca542b397fbdb61b2478307a8eb57bf4d968a3b6fa8dabdd5ca18fe3d8d3bd1690fe8bc5e21cca38a7d4fc609b171447183dddc2a3d5cf40e49f5066b853c50ae0d07f5427da55e5bffcb3088bd3a82720c4c637582487a81a0f611d5298e8433820497d72ceab92f442aecd5408a6307dbf63a931905b3e09bde2df3e93fffa633cd61ff530dd0a552ac14de9a1e0a3300f200d697c09e21cc03d9cc33a6bfabd59f6da1651315ead7fbdcff2f0037d6f6ce4d1d9570e160d9efa9c82ef8d6c6c65c85a7752a87c42546577a28d9c45bfd4e6cc5e09976e79c6e9b60639d0fe42f6f6c42b45e880eb9a24ff5cade72a1883fad8eca1a6837aaa43c0945afaa59f5b453b13cba15b0d9a1fbb74055b803509078b6d804a79d4ead81bdcef1b6921a0db0ee5570b5ca614826a3d8beb3ba556ea4c11a996845200bb1e356cd29ef2d7ab7389d23dbc784693583dd8aac1fa8fc54bed1a041f3e16b4e483c4e245e7029b25e5810fcf4f351dba8de05996f646acbd7ed630a4f18af705f005b19c8b57af4bb08019cfe717cb333f362c509413b16b0e27ffc12ad315d395951419782b3ed01af241cfda5f4ab08244f1e712f6505748ed252f0ca51c12deb32f66e02caa189bd91ada0fc61eced4e780906bc8d248fa0c6833f922be825c59db648c1f52c8be87f358cdde2b62071290b69451400e95f4f871f600858b416e50363badcf52e73db5378b248b30538f306f9b5e327bcb6597b725578b3872b39451f67fe2aa7bfb6a2eb04f441f28ef35f1ce81df6d3b8bf94d51b32ee30b1ea54107b1790b62a9f4e826c8a88c2c0e89592b4637c0cde08a66fc4cd30239bf961c46a674609b0ae168931b3ab735d1a979560fb88e7992474be6410dfc2f358c32eb5b87a1712a4ba837df961df3a8d8e0829a65164212882144e7acc6efc2d40801f1d948f212bf96e7cd9e84ca8b9bc8a5c30861d07971d9c421bcddd75c3dd90ef76746b7d2c445a4c924f8121ba836b9096bca22508043dcb6f730375427b6f61e38e2114d32a64e121618807232273b17aed41de98d66316f4d20d099025773ea8ea5b62a61eb157dd55ece2034ca33e7b48b82059f9741217198560ed2120a7a5c033780a929631f8e34212ee7b0ef14a50693872c94a8da7e798ffce540e47f910a2240d1fdb218939bc1caae89e9969a3a8147d572605c92b2f4dd937a67fdaf5b84c6a4ef6c49c2e67bdf1bab1970bb51d778ec6a3da754a0c4a6ac887ac1f94140f9bb6db33bf0617e68098434d4e0a040e0a16d798af069aba0444160badfcdf6709b0666edf581855d8281238cbee4131d0fedf79004274e2d8477f8f156b3e165dec657e906bc1a027fe4f7b87a25ad493657dca465db462f0e4c3ec11bf091549d82c98d7b7e1a9ae7d6185f1106c87cb7d80e330cddb0ddaa3c286c53de4a7f9aca306b7331069ae486926d7b383036bd4054ccefacb0c13e2eb00ec2188b2453d29fdf223e3794e4bb89f323c3274ba0de6c8e279c2bd4cdca361f157ddf27f6d0710c62bfbdd9d7c27db319e913b48f644bf1922481ddf2f76105dfa6294c1db7b97f5fe8b4db2e30a8cc92fdb34e9990828e54fbe5a10c9008b136a65d2754817d9c3c06543270ab478fed72b573bd131375617aeaec4eeca736cd815c57121ebe05d68b83bf8215d4e8d67707727ab9e68d2e289ddb22e7cf0678e5e3bbfdc331b8ce3be3868b0ed991dcfd62d07c6dc12263b9cbb9957571a29","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
