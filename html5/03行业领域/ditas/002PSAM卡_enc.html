<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f75f82e3b913cd83c6564ef8cc2c104b0e4713ea01d966cecd50b591a1802f96f9c545af7f1e550afe784f5ac2a0040bfb0d9880b36b98acfc31c1e1c1e23d29ae7bc92b954cbc5741fdc7493fac2f99dfaa48e09aa72f00d43a27089294d92353df7e8c6c8dde5c68e46553c743aa2055539cedb8e62ba822603743103a9ce41c039580977ca0b355989b3e75e0d1aae5ea47df3143605f55e4cd352e7c6f978e217a7e1892d3622abb43c206786ec29e7a30c34c485b1663dbfff3897a6f2ace773ee9b969beeeb496d51447a07392d65757b666a9f8089686ae9e0d28fa1715ba174e44f61ad9dee545b29462ebe24370da6dea5d7f20e3abf8c72337238d24af48924346017c8ca0b2a1ee312db0d5325b149ec7b28130e0e3e9a2bfe943a5a35e4a623d7d77d082b7827fb436ac9570ed7818f5d794153bfe423b29b29177519a5275310a8469b0ef9e070fa1ec623e2d4110ec9e30cf4c25fa2cdfeaad67efbc5f5782adbb62ed47927243e7ceabe6a15f77245057905d718cee96f7e02fbe6532769de4442dc7e6b9c6a83be33c76322bd92ebbf806911472a2b38c7cf5aad14be25a5b696d78461e825b5cb08d0afe4328eced64e4dd2dd5d634e1e80ac7a9125437f4915403ef955b817183776fc9b671eacb5cb066a549c64786b5034d53dac8d28de9197b2a57b9a4be56186b4f40054a433598f25e6ae8efac83ba7d74838bf68467eb3b01183dd387bd1802f523ebf41b16f661878c4de88054c397a4db16349d04fa59e69a3a502c55e6ccaf43d8410e0e68099429b78008061a07cf31cfd23f38d62118384fb19032bc664453d0daf1ed11cd20dda8fcd5e5457412978e3c79ee5c702fdbab52a3fa34993863e0eba4af89a9668b857aff35642e317fa55575dc9b8436651fa2cad3eb0c19b9e3ed53f8febfad472c03119bd2792bd35872700e4954c6a144b17dec7456abf6ef1aeae65bded16f7b50bd7e30b84cfe3b763fb3e39c022abceaf4680731677149bfc245e484524197df877378dfd9061441662f6de591d991d0bbeeed714b3ae1fdd9d2fc429e27095614cfd8c4cb07f83262d04ab6d759af43c88af0de8d7b16d4a98058a06ab4a77e7a4641d5ba734c73f899109b4d9036a9d54d0c3903cab033c98119d32bcf02bc3209fff48f145bdc9b570036653684b1099e39049ee86db06ae22d89d2b843c651697acc9c68016009a335bf2ec09289a99e86048ecd61cb504b72fae5253b494fc67528e70abc48b06f8da90aa5eef212bfd31b61a32409208dc34b4df689d1161e4c4a887db0e906019e9f643e853ffe78c9f545fd06b3c89fbbcb6445f7173b14419ef83927e6f43be95ef3a12a7557b94d45be1d61e89b30a2d8a33b823d7df6ab64c4efbe6d6281fa7be2740e23ba63e5aae3f9772ededfa1f29d0a1d55fedba898957211deb4414fe725204c67597544b2df2850749bc99534db9d32a435e60c74fe4a6f05349a1feee45866de6aebecbc95aa2ffc8f8fad5c3f787ed75f2df3f9521360fb37720efa12fc3de3d1816870db0e9f7920f4f285983c6a82a9eb21ba3fa3bac124907d08678fe48672fc1e5159c1d2c9ad80fe6ac4384c87213eed7bd8d68e37cb16354997d3ea95934ab9448b9dc13b363cd8d9efc4d0dbb36a5ed8b706d0334f98e0f176209a7e27e7a5eb5ac21e3c7318548c2a04d07fc97e259bbd466474219881fc2a7b4d2762e7aa27c1e6c736dd0f4bac15c692e32f09a279ce09138e285fc4896fcd3de55f52955124e182643c081789c04a006c06c03cf00e45ff59393c8a226aeee2ee9b47b98a55fff3fa238c1798024dfbed19ac34d90f5308227167457d772ddd65db86391f9a6a8dfe62f5322f6b3bd5bab719f73dceb0b029d1aafb5d8218f79ed4034d390c40955bc81932aa7f2ced6d9811a2a4528ce5547f55773f81b800c249b27ed77f2d7af8215e088611f0965eec3c0ef7c750b01d9ef5c03fbeaa8be9052eb099cfb0742371c025c6dad29e5842b242c814d8e42b119aa1914959c34a0f9efedeae18d3ff770153d72f85a13f43530232233fc5914699d0c17c3db4e62f428c92619c3e6969a0d68deffb4d1f54e3c9884010a5ca26b3b8cb5ca6be2185fe51c226ac752e128e7e553bff0277199b54dfcb1309c705e5784f3aa57656cf7cbff3a5998223f9be4f774867c103ea59ff61be85f0b293c142011e292010fbf7b189ed15eb5ddcca615a63f0266146156c70f6b8b9a96d688ef12f38c876d8d786d7ee92dd781a192da1aa66f9682f1606588e116a5f8e464c1249fffa005f78502c1b428c166119af79af367dcfffbcb1f64cfc4d24dea4ad4b1cb7e407eff3e4e2250e18efcc4934fccf01db4d956434f18a04c3aa57bf759d9d5af4a1488e7201aa6a2c49f8e27b0d2d4ee9adac078cd6af32c7346aff6425a191ae3f300bf4ca2b06895b66a77fb79092aded42dfc8e83f0aa7febd1e20a8b6527bcbb4ee8b15c5ca7e3a0fb6be253b775f9259505aafaf8338b560a546874c4df1eddb6219fff966ce47ff4234d39ec9a5c3e03b1b39cdcce0bbd5ba50d3fcb3a65993e5c0473bf35c6c5c7d1d1e22bac4772a9e659f5bdf06f92ba68832bcc8d25c134726116f445f85b5a7f4b1151c7ea1e7ed303141195721b7bf1b084a399bcbe2b89cf6a9417a793ea6ed72766e2d47390f4c08b4826d63f85f9cc742fa8f29a2ac9dd9da425d91aea39315f404d466c0a06ee5a34c35877bcf5ec8687818b74977d8a7a2e7de8ebb247cf520bb0d1b6a09b07496e804f8f199510dda85f7f7bffeb6f6b0ff9fc920d0186183d404058c1b23a9daa1d0852f8c21b22f3ce3e8555700f2d44f43f8e5cc07729ffd956ebb0d922dc72e2cdb5059c85609a64858dba3624427abfb40e9b0d4459adce639f2126c23d3b98588f0e08993c5daf2dc3e027613949c2e926227e721e1510842742697bcd5f04e21355f409523e4c6bf3a2bb4a933fad1f34d619f731058ccd0125b6e4978fd74fd78a298fcdb4b97b8bc9e60146acb7972304ea177bbdb41f62747273477f345321a3ba653a8bd5df7a756768d777378f8444badf1b8c11ae23ded21938e6339b276bd4347e56c626a5c3948a0709a167635abe3f397a8964f58afe26ba69c9f253145ae75435f21b8670acfac12434c4ba08a6d3e8cc7cb41f6f0027908008314ddc317f33c2a77bc7bbe5a6a87dabc2de519926bf804b788e55758a47bd698390647a4a2ed5c31bf817d8658a6e6dcea79063caa8c378232b6ab93c1c192b384c78b713864755e8cae7499cd380cf4468d14b5c075acbf30b8cf15523a5fdb0813cda23e54e1f110f20cb4f228d1f20db0fd32deab0edd983393e76fddf7d08fc343ed5dd64eba02a4c1afe5adb48418326f7f9b58da520386f5826dbd051f8f7fa561565fa5367f277ba9acfffce34d64a90d5bb89f60417e9abbe18790d02fd7fa1f3004ecdc82c253ff11753d3e57ac38077c00802394b24f500f10d865173abf188d7ff3644b90d547878b8c45e64ea2062104bab34c89af6678bf6edb5a97231b78842512f9d7bb854a04336e1b9759536cb9e3bb6f40023525c156c46440d5d5248d30b29558a8b2437106bd232a8c344694e6c71cf89670c4a59593a298938a5e0420e5fcf23419cae643eccebddc27cccdbab0aa74d9c154f36d9ec692c396a848f2a2c1bef66276dc44e848a80b103b2e5ae789dced2317b7a193c9a4134ac735d9da24cad738db371ed00ce01db51f2ad411837535011c307869c99602703679722768c966c1ca673690718683c27162c4b206cb40856ac6bed1fc48010385978695c03c4a0da426f9f8b15924f3e7deb153830c30cbc216bfa15898a87fcdb205e9e064edb5716f8b9acef968a78a18ca06e9875caff6bb30b73f703d967371ef0f27f108d70148e34fd64a86570d2f9d151e66958b8226e7fa7946ba227c3c125eac08f8312d439eb55ed25eb5fa3fc962c7830fe6f817be150d65d103cd348803b609d8fd62cdf853fb0943369ea52069d341af193d5691fb610604e1b3610c6e50235020dae83a324c8037bd7ce00f7bf099774fcbb57a8ebe94371251b378cca606971415256ac126db1f2b3048fd67de29945e92f6b9e1bac2a5e48b92d8051733adc8ba1d8c3a1b21c7c0c3e7a4a6d688961874a4e193fbf797a619ff9f26f6e2d650c9aea1c18ea5761330c425815124ec76957ae6513b51773e71196c652d04f85aa02f3834f4f5d7483dd33d2f12a0c4d15e7f4f43c2d0c25aaeedb2f3a7cc246a294288314c798bd6e581882df3b1a9d542bed34c1a964a48668da994db73ea70e4550e4f6d50d1a155dd2da70bcaf9a050d89687d6e7f8caff66814bd1ade72427108e7e753b2603c9dff4306b024f0b2c0ffe025ce85decf1e6149b0fcf61fc82f64be7edacdd942af5727b6bdecc15fcdb8da5cc8021b3f7bc3883aa37dc6d26dba27bd813dfea148e994bc08e84032fc41014ce315c7d4bf5a8b765cd00b0c60a402eaf3d087eb83d15766ee8eb6c67f2740beb06e985d2798ea19a08a6b810276015f7e628ec7db9d23bea11ccb323608058d181ae68b66564e201d1e94f329743aa945faf6ee87200c885dd4938e6862d56c5623f0f23450e8f913eac2c5df0d4df242ba2db9493be48f000ad33d6c81b5efff235f2a541d37d20acc984f522068bb6223343dc4f6b7cddf0abbf460cf5a970ac8ff7589a361289d320c1cb3c9dbc76b6db85e6733279e8656d7cfd0a184f946ddb38720c67e2dc381d1a8e5e1defbc6e2f857f80a9e783683b4a6730474b30f1d135f9fb9cde7fe8dc87bde27de3371bd50cfefac754bf9067cc5c5a202ebb2d79dd9ff4f4061a0e0e4553d0a7e0b46e2692dba18baaf4bbcdd3bdd8adb42fa1a1048705f94dd2247b2bcdc4b5dcbe15b48e496981a815948bf0241d0ccd71d250bd14521c83603519b6d3d4e19a5eb6d04326bf5cbf2e958ab6d0166db0422798cbd3741e69ba1eb3c2ab81e6b6b4d41277b9ad178485f6f9a397a320c1f0b01c701148af095d9f481560c8298c4b7fab3d3494bf48357f1944a140ee4a024f976975bc5668d28f98e38b079293684019855413d8a8c1e49c0295ab18161b69d65a5e8a217d25653281f3706fe772c7bfaed1965312580ade72af6db6558b192878dd7cda059282c423a8f3c7c30780bbafc2734870660d2d0a73c665efc953d284efbe624de43716b0993bc0589e9baaf4d9c5ec8dda081729c0f19d3a76d0e77cbe689eebba4d000dbb4675d60e4b0fe71cd90b8526ca3a820506abe734722ee11714af53001468b398838fcd843da27e6659a53ebaa34a36c856d3decde5d49d62cf2153b34463f68d150d3277bee1057eeab471dee4e86f452e93df311293db74bab0633df481dcc3d2079e589f1a4f7411859b3ad0fc752d6ce4e766b45a1f60917383a1f908a72d69eb5c6d6ac77aed08029ad5950995276ce7889ea3bbff502f4d81486a789fc998e97d651c57cef4a6bd94b337528b155ed620ee42a5e2924c37a1acaf5ad89b584d7be0a5b410669ee3978646ece05eff0d781a4f11edb3537061035b5844d75b8ec11ea179c5f4e7d04094e9bf3b8e8f85c9508d6be4eecbec693a1955c0db05e6123b3a233753f541b99c5f55e3d0c34b6a889aa67568384a66522eab330d87e213ac184dba14b87e97ddfa8761caec68d4b989c44cf4cfec66aa3b052c137ad35d635849d244cc2c7db732deae377be096df0f9b5337aadc36db54a144436ca2c0ac4a2afa8bef7a91dffa63bc02c4f6f027317aa8c07c014a2d5bd57023803aebfce7186ef103a24f9d994caefcbef81670a6cd8bc83d1a0acff0673c75ab37ecce97b48e60a826dc0e2e98ee21ada43f8bc41c016e04a3fef079ea61b63942a346586c4d067138aae871bdc0981aff114578169391f39ecfd343b834a81db38614bcebdd0677d463d0215949daab5fe05d3e341458031a47a181e22a1f7d52e6172a324315eab8b91f4f8a4f8c5b37d72112205b50da7e107ba39d4e24fa01f7fa9d6179141629210665169bc6c8e8ab2cbb59b9db50412c6cc22e54f546a105fbe47cc113ee01bbb982cc78b9a6dd7a99a767a3f62cc57df46664258d39c9a82f1d4c051540095c3cb21742a92e79dc71ccf45ba4aac2e05379000e02071951c8613f3caed2886e7776914088677dd40f6f9f726c78a7d7dbe94656a91079f843210257a47862ea2c696c300e3c84dda52635760345344c2aed0e6c080eaa760b083331ca3148381099efb66508ae6fcd762d30ade89905e0157d277c9763fd075c05382dae778c22307953241d363837b8e99051dd073faedc265d36d1694fc19b79c5dab4c99394e27a03adf801e4eae9009cb1457640b8cd96def930672cc89f5d0fd21bb267e07f2ef0a68e8ef17195bffe14bb67a9568aa6edbc93496817d08b109be255ea7800637071444237807567329decf9c2ad1316555f9294e08ae93a70cbea45da0fe7d8086141c5c451d01aee26f9a9eeb8486f65c3c4d091071c59de9a10cd74dc2250df3ef52c21527c95a7477ca0c64a87f77852db3044728a52b5bf6fd0b55dd4ea8b4a0e20881a0e9df5df1ce2bf844f278752c6013410530f21ae8a71f30dfa10df939a35c47ecfc37ed04adbc8cff9e225e64568faf1f57deca70c2ab23798cae3df50089ed08e3b50f4e03f2fb3b5db8aab4858ff0cf7917da0bd688bc4ea23df094cd530ad60674af480be8e0379c8cad5c1de1fd042ba9c50c7a8b733b44858dac8189fe0e6b6aa4901e3a6ac21b28cf1a9f5887fce69edf8dbfc574d9d7adedea81ff53f7be6708b0f0c45fb8fb7ad20fc5f428f60dca159a4872ae57c5c7dbc7a990bdf73fd78249c553b919c98820ad6136647e4ba360b245daf47ed0d3d6d5d80b41e15756611535483259a29525c1460774b8fa5b393393edc115aee72fb44563814e135894b5f3e7b04590ef886891743f04bf1b871df121b6c58b43f76b3ace2c14be5c977bbe0a3d9f2fac1a1c679466dab89813ce4ce1618282fe2138ea702101a82f3b9ac19d046851e727e669cd8be7482a45f9a758bbe2e6568f45d8a5b8cc684527b128202198da9f256d4d1a69ffe797528ea16b95d37dc52838bf9edb0f96357632235f8ff7640d0f7bfd98601a4375abf55e9046219d64f91974cf551f152a783ba70b26623b8fd59787d5d96ddf1618b0bdc9a8e1a7805b6c0fba96bf5b556a6aae4305229d597e965c4937167d4159d2bf33eced92b6a8e9e7fa19cdc4e865ae36c5d49cc34dc1cd13be71c958a6a15715cc2a253b5e488ba396c94c2221a1421a8d07149eb0a8ef24248804b660cc66d0cd87a56ad3c78954193a8d4173b4b42c94a419bb7f5628eb0d8df2ac24cd60a73ca6f9add53172b2c3ab7a36f5d70c0f5c6343871ed7973e42d4f5c762656b97174d53db68fcaceedf9ee0d4c0a959753161202dffb70e0773965ee97a1fe5e93b44fd6115318ccc3143876ec39fef9a767abc42574bfdc43368bb61ea1a2f7276d52cbaa03e9303ba298ad949a92459d3cedca7d37b1d87bb45a779025c257f307b0edbe6c794fbafecbe6e96992215bf8c1d946f154bbeae931ae2612e170d83ad1786a517322a311f9e078b015f7e592786a607efa21c1a2122a1548cc55c526106fe7aeba201ce2a95c092c1dae5a16dcadfc4643aab82113d35f1a7d35f1155eaf2e9430b8e790dd5aef607fd47a34d16e9687a588c851fbb04e76619b1fd39451c272c256ac0a96bd27cd1fa3b9aa15a9d180084abb02b7a1618b5041ca398ddfb5d289ad63d2b5375975be18f11e473eaab7c7f4ab697aeee4a98918960c6e53a7464565d643360f9532e5bf1d1d7f70449fc9b29c13ce7f130b9527fdd3d34fc0bfea87251cc0bd3bb5b82c6d55961331995f67945afcb7d82a1ba2350ac4f2b5be3a025d5478f77337d3fdff765d0346b66c40c876ccada74599191832d331807f5c042661989ff0fdb502df4b8a7abccda6d2ee55865bfdaf9b35e3848e8401d8c81d3b2f99662952724a7cf06d9171b83c2b1096472673f332c0e75a43e796a9f5d4a8c378b6e91e0eaaa2fe3c634e9c5b06e8b2cc28686dd506edd9434c47c472b8d8ca8a75fe93dadb42f7391233630d9ec2bfd50d89dfbe3dcef4d8b9c66b19673ebf9f1804bed020b01d23d0f4090258524bc24a3332d8a6681b17d5c4a0ff428da28e45c70600f9f7b04ce1679f48c6abf007b5c7c14a213244fd787415dafd8ba49e5c580c521df58e89bde3c1153523799e14602d6eb3cf350f3932227d1b3266820fbc30be1d0fa766eff7f1bb5fac9d0c4c2399cfb215eb6c05f1ba6c58f82f1f559f9ff216e20dffb0f43ce5b875c933055b848fc0868cb05290c37e474a52b8dd7b30323b47e7ea0f01cf03d5ddd6bb060c29b9eb75309b96b72832f23a50280088cae3251312c71cbe268e4203861b68e2fbe456e743d2dc8887ddb8f9fffb198c58db2ce694f97656bf4046e9bd492d82bb21801b7c3ddaddbc34c05c0249fab9272f26692677d07c7255860392fe7a47a42808b27f8186d850c178f1ee776fc5db7979f46f0e078c11715d2ff4bde1c84c286ef074fbf68b01531b205b69bb4f12be83f7a745e120684fea7985841f578d8891232d63dd9544686f10bb8eac6e0066b1b068be5b61765c05e2d1a100bd88a775fffe6edd046503e73a17100c053b64ed6edbdf3e841537c651111c500cc9b5671b537d53c2f6971cd683a5a522f014a9fb33335ebd078aa3ea22c8bc7432a12cd4195f446b8f87b6c4f37406e1dd8eee63d26f883c0dd2f0ad4fd3418b0e9d64c84cf6dac539d0c86e98b5f3732d1d2c559236df99813a48d618630b4b06b391164a3cd2d254558beff3566fb14a62fd443b15b680de5120c4002ab462eb48e70f0270bc250b920999a8a67699d9ee70da7b517e39c0ebebeb64e39dab8310a861f1d2f35e4b70362041a67195cf80d3e0c7dc1cfb6c7adf29639c62f09713363253780081c7ecd6f01e388bdfde845ab2a00c2a454bb44d13ca4f6ed2aeb086113480a8ad23bd0ba8044adc56721e5fb8e74e46c28e04936e32a0526e298283cf1e04b3a1ee6f3e5b6992eb49ee3ff253e653bd73996eb0855709a2cfc197f2815ddf00f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
