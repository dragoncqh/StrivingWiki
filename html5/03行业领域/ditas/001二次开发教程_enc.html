<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffb509530f32eb44870374fea2b39ef0a0af5a4ea51c87bca16c736fe5c3ed6346913a65bd29394a55b0a0a24b14aed4dde0c3ccd61ac18ef033ba09b7b1dd7624642cc50e67d7e4f2007f90dc1af203097b9177f5c5475c3fd6d0561ac36cab2503de0bdb4f1f74c0cb867667c911d8b0fe4377a404c1e31213979e943e51221561b6415ba9ea68d6206ddc6eb48a00ced13745484cc2929c2a9ecb74cb8e28bdc0d43da4844350cc860f9583c57eb3a916ad1a77ff88317662fb3c5d7ec34054d4010cc9f2d57b5dddeaf3a672a9f9e13f6f3a477c5433c244308a387f8c8fbec0e3ba9dde1d3c466ecf282e0b5d7141d2e1ccb5a78b9090626dc5a214b6cf3d268b940a48b016ba94c06b73b26fbd6681bfe6e256a28e4eef988058a025a317d412cddd0df1c6138d1986d149b98d409dd36378dddb7c38113b54522208ccaaa9cda9392f3c48641b9913529f96ccf093a5438c39230d1debd18c3e40e3b68c1d7318a1b24ea1d06f021ff64b80ed1daa45c877a3fa7cca5d8aa17efae146248b5c8b828c827cb14d8dccec47c213512e196281a99e99163b6ebbc3ecc389925ad6354078a3b5eb5e0f87e7163b6ac6ed0c71d818e5bbdd47c78dd7f89815afb8102045bad760e214711d78944831d98369de878053b933b781e8a9425123013c53ef0c55bc1dd4bdd9c39a3717f7b9377f08b20a27c8958c7717958d96c8275590ab39496183b9a4a47c2d011e3a24e807bb885c9dc3951ac897e74b3542f0b786e458e18b05e6cb6bddc63656df8981214402bcbc9352884256d91cb096879918f34276efbef5f8d232192c885c4314ae55c2a49dceb42ace3984fbf23838b1d571524644719072ac2eed037503c88ae708d9cae73cee3ffe532627b341b8918ee90ee34efd4ec957c674c6569a742bb6eab910f18d89e48a321fe7b0ef75255d308b64f6b6f9ef155e08d0c26c0b8052db044603939ec164e1579232994c800c4d751187426dcae46d0afa2748a21935dfb1f4cd7e97f9f160251997efbf86c0d1a7716f19e9398fbfc25f001bb2ab8de213b4a4ca7de11aaf6d088eba9823aea788ad41ae4d7c0d983e3fb776aab4d2cacd935fc407fa24587db4529a6097c51cf4ecf6b29538597b2e1a9cbf43a0247e4b855251dfbadc0367de9a041d78e6c7b6002b0484ab66f04c3a7345cc7efe7f5abb5cee4d83782553759f899d21dc20ea95c8c506d76924e2890813e744291845337160d14f0396a9dc18db45be6ed3cd7d8671481ade7af90025c2839abeb1d271d2112e5e9766ea941e39a49d4197ec6958522e9b3d6ab8c0000d19e7d4e45a7a06b7ef04be122ca5de9b7b50b76f21c22b09a382aa1f83faaed3517597ca6c0525bb9189858ceb43965d8a50be90210c86a7b37e210befb6d85af75bc6f0fcefb9985c3084ed24510a4136783dba9792ce80bb42e7d55dc181c24cf39d044e205da46cd4e13e465e9edd4815e557f22f265ce9e8259bfc7a33f48be237e2a94b5d10af52f285330cf06b645c3962c6340a7b60964a2be25628767bfbdac1bbb76f7d7687705c76f77cdc6e609822f384191129e7fe4c4ca83dbd4c921633b06e24b73274a2d3b25a5241cdced405a217c05bf591e2670b9705e706d49e506649b16631a1f3f280f05aedcf9e4c16275e20b36971f8a4427ca45a658c256eb5700b3f529ddf382a40ee5b8d68964e1223ab016888b61dec5bb0608ee03faa3f16d72e020a4127f9adb85fea8be84114012797bb0e074df54ad1518624daecb543beda6ec2fec0b1a2ff1e1d5e7552f92a13a8eabce09bac9096a1abc890b6008a7eeeb7d5f9e0fba6a08289b4665b014963a79a6a30a86ccdadbf7e43faf81fac416f2c2c9b5366d5cde4d24b181adf534f4e45359e7d126daeca71cb00eae97483f1e1e315e1253872c9d8b9763953f78a207fac67c11153622a4a67ecabdbdbfd57cb0dc1ac482a8b8d781787dfefd63fbdc4a2a087f42eb62afb4752b3ad63da33ed30c02ed1fe9192cfb039084cbf4e37b69c049d91041909de637748786b905a7953e35d314282a2346a622a2208083df94a2cc86835c4eec0f5d46da805663eec195164f30764d8c01fe87733d80d59309d1891b9f95a3963846b907780e630e29462d9f5acc06da5c872f42b22558cafd864c572b30af9da59cf7a12b095aa2ac02297016f002432170c55a8ca1b9293a807204907b3f4f731e85d3bc04e6825a7cb249ef6b9558c5fe7663024355e48e9fba0d2d6b255f6954189440bd5d100fbcee8fbb78b0e0e7a251f60c492aa1a37df8fdd34dd1bedbf18d7aaa4dc6e37f06684ca553c9401231e772b6deb7fb7349b4f91bfbf6dce193cc0e0df8eafdd80e9f281a741f37ac2c73e99090bd296dba6b7a7599b4c1aab26b1fa4cc2778dd7edfaa0b6c5114d7b4e239391a60fad72287d3e47bdce7f41544403f40817d04bbd4cb7d5e09a9db75d2f18922d133a18a44d3d7f0a98ece41221f0acc19d3154893e2902234e3b0857e0188b47163667bc0bf722b441edf4e97b18b7dcaaa043b584108f39890f6d150e9288835a7a030e1753278fd8585ca1ea457024780d3d7146e919e68050eadc7d5bfde430cf17f3b3834c626d95985236f2b34d8f26fd45eead20e337c9ee82d18eb2d01979f8555c227480df6115c97354c793c95c708b720bc4eea762774e3452ec1a9e9c2c2905bb79b696678afed0d835b240c6b3ab5f57f538e32f18de12702da474b36c0c077e5baca969d3e7316597a9f33225115d3d124678f49819097459400e7b585970b19f5178147396457aa7b2e6ebd0d14d97243edd8cd8f51621d195bdcfd12a26467eac7735186ac647a37d7e9ee343e59a1c76fc3d06e2f568cc7f46907427e5e6d40f535f67650b5489baea5a0d5e95a06f79ca5bdc24fde1e906179497931173754870e8ec3337d353e6b820feb656c7e638dd5b34ee660a47cf8903773ac9e75c8d87e87849496f407eccf1dc7ab3faaf822fb273186b6ce02c3b5f19a7170ad853a0d90e6234fe084d33f79b44a40cb75604aae29a1c06e0a622442de9fe6380c724f06a1f678ac172699ee7a9541bb28a7b25986083dbca7371649db06eb22e1fafd7fadedec073a18389d17a48e92f91838bce6386f266447830e0f20265e9b26696dad4efe62d7003560e26d2537a662441c5466ab29838722b41c7ad7713b00a4b4551d7fc9c7d42da37ec68434a533f75616dbc815a42f269af94de1454822698233020542e8d794c6cbee4511653d3daf26f5b2d5b20c29ad13311ca0460b2ec34fd457fa2417fc8d6551e4643f2f0af260bba4c9a2d06db49a6233a3de581aef506df17224289583ba56eafeb8091c21fbeb48a19f2534201841ddbab6e364aea00bded50f7e6899e08cef4b66d00fc0808e5339945df743194edee511192429c073169a72009ae0734f1b47c58ccf0fdcb6392abfd9416a6ab3db01439e9e548a3125e591ab29039405658d0e8bf5ca75971f11538ba05113f2fa19094a0c9517deeb4c5afcb7055200a434d104e9ea72b315719b7c66b82b81d730f308b667830cd50ced5c60ecf197d761253c24df9c88b1076b61cd31ccf495157ae4da7a8e4d9adeb2e39acfeb90bb574d24f842ce11e9d5a2bfdbc8fefda85d2863b532fef9a62eb896d386657a810fca2179950ab2a343439ba078f60999052b0cdf3fdb77f759021986d7eeb04179037165c10b1b13e69b81e6a826d365cabcf4080cb4798db598a7b89349f9067134c0b3b7347e9126d9839bc3fe65059bfbdf459a78c1daf3294ee06b491ca420f9e61c23665f5b09a904aaed0ba4a276c66f76df7218fe5b5a123307bc5ca18c505e382cba8e26317db7298781f11f375e61d89bb3e434809eb3b4c44689990ad0e609459094f35f5dff065b848e9d67f0988476185b59730e486ab0be053269be82a3703518176adb9ae8905a1a5ff364b4a785703ffd625c5f6929f88da0df634978dc44603fdd4db673b7097c8a60095c5d8ee0266bea3481d7455115451642b9bda9cfd9852de7506e240cbc3f2864e2313f08c9a0a5f2b4dbac2cff4fb0d1837c9ee6c9e735511e21522944ae264aba2a745d0738e51ff23ae6fae112953fe6234525b4d3e39addc8d0d531f254c5242499c7c7c51e9fbd3660e7adb6ea2e2263cce714c175b8a3a8f78b1b73d8f6f6ce31deec1d7869eef8554b3407acc0fc43171e849d7e595d456979806306a960277f5a5b6a0d51c0c70ff3ce0ce254ae78af8bef74c26d958382a3c72696a59606e08991ebd40ca3764b3cff8242c19c7b7afc853e11402a3d39dba8389f9008ec04e6edadea99a906a3fa2c728a6b1350822774d81e91857bace6afbfe7f617d90cf93132b363d27e6ccd4c228575562461515775e4eb6d5468def532899c183edc994f4d325eadf547c5a30c1fe2f1da74ed056b70f838dfa4f1289ddf5add1f01b9b4ffb5f97dced6212de94837373e128aaec6490acbc0de22db3913630731f263cf4c2dd4afea9fd3aa776ed86b4c8e657d45a9f59e00aef12eaf6738900508c4e7577dc9be1e77c2a864516cd29f20e39296b59bb24bc67ffd13a57f04975542bce8b600b3d2d70362e467f3c076d1277074da08d540465e909e47292fede2b192db9d976fdd671fa443dcb13b1674909e6bacfadbf3515fcfbe4484c4cda54fcf46c25afbaeaaab8f5edacb645a3073ff0aa6d6aab0a9ce7186bceb27031319be6265a489671e08970ad79e9f981301c628c5f994499e1be5d8bc290fc3e5f98cff6a90cc3e94052ce16ad9d29c866f8ef6bc9a65a527785c256783d798cfcd8721e33e794a0e2a653234b58760e5eaf8d6c2c67a7ebec14e5ff672cdbaaa29d156e988b0e61b85c15d6b8ad1bcb623821640135af7a51b705cb181c554cc2884533cec7a7d9e4938dd7fa344085633a06c3c71ded423d49ee268bfc1c94882d4814047b142f77cf0ee4daae202f66e36e149a922e9c02afafb617f9216c43869b3e3c315f1b169586daac8722c29d882c481961d8a5fc0974157ee15a258a9256c9d57c16654d0d603de318a3ad0d701110abfcc5412a6309cc2802e6bfa71a7d82d178baae9a138fcba6047d91e55fa1089916f290fb1e6ad26baa68155d518ce3db2f2ea689ccaa82be6bc2c13d4f3ba174530a62b523f5219b0171b0f1883f57c01f58db1871b1b949b6cfcfe9f0654d26c515ee757ad2ff30fd94b503000945ee7607a6f6e6dd42351169a310d6e1509445582cdd183b4b4cfd994293f937c410f09633de2965ac49debbe09dcbb8ce641f9751f13fb493d9a6d81868e85e185702a80115caeef5bae1204eda4883856dff0d47cf3ee8c4f74eef0b9c0f9a32be7ef9bc349b92588d837ea8af56900dc7c599968e5dd5f6906fd198a9664afb307dd89b835254a1d11ee62835b6ce4d0845445f885c1127b131c7cb4ae3bd336554b73948a1c567e213574d701837f4989ba67b75165f43e8918a43b1ce62b7d3e477b5b0f6cfd1d9ed87a8899b81fa7fe8eb0a783b8d26d1ba76d0aed48f895ab23075760e03e641407f6d5cd8b13e645a9b522f1aef013958ee405e526369d69db9e3b16903cc94afab4df9ba6228b91d84a2ec4411674b9c2b544e8a103c9fc7cfe9d3d3a8e15df843012f1b3d7f6921aa1b6113f72496ac96211003764d0e7a6e25bb6c5a18f53428c1d320ae8eb31c769c2f92789ce5cdeba092784ce2587c3ad784038ebf36bab1a590d1670a26b7ebc37737bb1217012d25f09af7be57f584ffcec797f3f195637238e006528ac5dc4fabb721943eef52cad4aeab35ed5c990d88fb11582eb0f3ff864f21a5d3ed8209cb920df942ea55bc3db01d91da8029e687f56239b52a192ee8ae5e7c327ada304c7bdf9cc351828f77104413b1b6c62d7af9a65cae3d1eb2c70a0896e7838ad189557f05501aae9430038afe4f8e0846e066c59735b777200372b22378749f106d808c2b5e60ed7a2e390bf4b9e3384b5390510addc140fde4c36aac853dfb41a2d6416264dffa417f3d1aece8a7d536c89c9ed8e1acabe38cc0e4572e638e9ab34de139c542a2da3a8ef8251ae9e719ad8b482d5d9ae1b8dcc26c75eb7856e5c220ae02815d81fec8765aa152cf9db532c9a14349b4717b839fad10c2f7502222f17f6fe3bbaff29a66d980841ea4ccc45d077d5ac6fdf0a70db0884035f4032072590b2c486708c0f06a8a8366d22c0a1b00456fec490a7cea8afc9e9117d0b8c9d332c58caaa44303050cfcb71afaf5a88659b552394d8c18c4569cc6fae121bbf71aaa7d5b62c6310025041e21e2beb1eb95ee97b44ca25a8efcb6f06af572b73d6c92c59b8e0494dd553e4962280f8ac9b382d973b4e062f4899390f4732b2f655cd37be1eeeaa0693ea27f12d91a971cc5e9770e81afe209eb07adbedbbc210a5a6e496058f408e1d8209189f0b248e5f41d6992b8ebc9059a44deff3c7f7b52d9d135dfce87cef473d0e4a468b4d73f206e01fb90462abdda3aeedae2c18d86f8d44c7ea194c9dffe6728d29b19c42f3b06a2eaa86ea5ad08025dd00fffbce27dc2c80c84f701175bce74e5f7b4981301b4a15b1158246d0f31719edd457bf647992358d37f5249cba674ae362bb2497cdbddbb3b796f21eaad82721e01f36c4c8ee44a42adab4d01218ac16d25ae2b0dbd0ef423c5b8a0fe3899ae99a04b7d8416f7d87f6bfff716cffc1d9f5ed6199ca0e389d291ac41803b6236e846f564f9315413e6d7670357fddc69ad44f550025f7dccdf0ee285f7d63cd856a04cf0ad80e2ab3edd49ee6f3f7449a1d1b46d37438e53b4693188dbf3959231698bf0da804aecfd8095a3549ae40fb3d4628ab74c1bd4a5b77182ff3bac303cd1244e84eb9525d8c7c05690244f47a0c6c77d4d1ca3e90ed0894c64680db4b2f7c3a0bab5033944ba6e6b6884022216f16b64eda86d1d14e3ece4e9eba2f324eb5661ea4f860f7f369994a8d1cacf02111fee842156774b71b1f6bd55fc3cee89d4df45f9c871114ca0231689d295b1e89e3c59339f9626211726351a26f957ee4daa443793aaf1afd6637e553d742978b45250ec2e9f6ec500324eef04b5cfb099d6d3d0c2860f380cd22ed062584d17d298d49bceb31f76a5cd3897c905115cb35571b9ecc0036795dea632b4628bbe347b12edd4554a7a1ce3416e0eb1eeae277b8f2794a4fbdc160318f5b7d4b15690e0a83b238e96c1f2648a45565969aca41fbb69c258b6e2b407441327eff6cfc81fef13f17ff561e527d736ee85a758e7d961e1bd2935e3490a752e9fddde5de35b042923af7d550c47276bfbbec91747e84f1bee1aec5c11cd5df64c74c595c7112a935d09a702c7eda8fa51a5bdbfe238c083620fe621223df1a071c69007d8526b8d9eb17a1eec8a41b7894bf38d0ef993b6be10e191f1ccd5a83550ea7da730c04d9d19a876cb4c1d462a32f83080bd5f99743071e4573bb72d5091b5453054c88f52fd4e78ae3c15f76ad75ecfabce2d9a52eaf917ffad51b6364f219b1d90d5b557687bc3320522247f6969e86e9c79afb81c01c59e5b95fde4c4db606ad6f57c52d1f71f1b54f899feb4a8d616903d644c4dd19d41c959133fbf478da7a9a8d6786e99b9031d1aa4290fc659d54223ed4db197970d9f029fd7c1e8f7e7f156750e364d624b9dd7fee551478291e1149cc5d8cc619d551c19f483ecb00465cd4766df1b178b8edec481a1fd0d8e739b696b22f100fdd552eed29ab58404125971b1eea91d30b7cd62bb4657e12fedb7c769e4f506446a1fcb3dc1d8b4fb3afd7ad8dc99e0f6100fe9f100364244b9460c21c6898808db04dfb3a115d1c186c8b4e63013664205cc2249fc60f124abfa170bac2ac5763317e8b303da996f69270c0b07a1a907af658c5a256cb2d58ad07929837ef53fb1904507d6f96478b8d042c4fc0a7cbb189e6ec141240d9f079abfc850380eb1be50a880817d0275403204000dedb186aaa0c0642fab3079ae04b6775417285ae65dea6726f50b09ffaa5595479f4f88dff116f72c842b63887013b749546b916bb849ce0921c71e15287df392f7767cd38ccb15cbf8bc07a55835db674b5cb8f9596db4f3168f3be240e8d49842dbacc30054036f9bfef3cb03bbe3f53ae3971dc6afc46fbbce2c3bad83598245d80567e923c084aa25559a2bdc19abfa15f329a25ab35f2a002ef946687293907214e9858570c6bd4b668d82e3cdaa7b0c4245076b23dcbff0b23e67c0ed4e46d0a82309660a733b93293092fb6cf855662af98513b111bcb2e1af55aba10aff21bc95f49033af8a3e8e73e941403a739382a4b09972a170afb2247c39a8f2fe8073f3c0fc809f76251735508a13b5afff4e2b008348363ad6246f069f4bf389f898e08caa0439d651b5086fd79e43ab743481428562a7d61f495dfd6a2f5513145e647a119baa30d9759292f76a3111efdc0f30a04770f98af9179c330d34875e8d0e595a70f379a9d64db3df12c4162e7507154f2d3608a329ca4277630b64d3ce77bfa7c59fc01bc4f72ed81156f94e3f6508f1c5503ef7f763c4b47e4aa889aed9818007a5b712981954095c23e05fd7482657bd6924789248cd91d5e5ccf90caf545b3c02d2142db35af42e25bd13215b5d1f0c96e8e81c057dd8aedc8afa946c574339e19cc5e7c9734e04303d9aa9bbbca66552763e7f2d3343ac721bc0133ae9ec8aae30edba02b51046228633a807d8d56533425a20f730150237efaae9af38309397613bcb7e615fe472cac744301ab033285f3d50c3632f0f5cac25239346481f25342b86748ff2177df03d52789e2a8921e5942e366f905fc9bac851db8ac16bd11f3ecc24eac5e070325d8d3e6faf0e649aefd152581b9dbc91c32238304b2393a4aa966882e9d1f08b6c739c3d8a539a46984f82fb3a27b3d49a0db995079a4e2f0a5fa4cf797b05f3ae3ca6bd8f8b7a22839c99c01edaaa47bc8ac8600e2e76b05deb6d391baa8a319d18dbece636cd233a9e7888be9ce13a7e770400c06d113eb66b4455b0358a30d61f26e6903b7bbba6a3e505a85a52e37b40d85111afef2a7d4d3ad51a36a1380437cfde2dfea71c877984e70b42cf8330aa85cda821039d516a37be11b72be2dc4457a866093e0422efc2ba1d0bdcf8ad107ce3325b45a0b8329d6a81db97e23983101c8e506389d619238fdec8ca2884f491267cb7578293f825ac7933fd1d65c9977fcd0a9d2f8268274b2bf61d3cb64c77589e6409276da5b50576e69d865f32730aba49ff83a683f451ae1d2dd8e65b613fe948103adbb630851b83c8c8fb13ea25cd4d053ddc1a1a5edef7618713ce63bd03b0641a4e3482fafae9b80153168f6f0b9db8bb7527f989b5efde250950e446a6a1ea1ef58a9b4bd186066448cab05557d0a3dd2fb35bc6344246233699ef7e773d50999dbdbf2a262e399405721d3163b2f0eaf4cbc376cca3666eca05637b694f76f90330844f04b7aaa0f82bbeb36f4f8a12a906bd98bb20435fdf0db9e177d1ab0a36a467d63c5cb4e859ff84aa92d0781d5f4157499354dd87843ec28767d9ea6893a107093ad7f7debe235c613ae5b4b53aad178df7c5d8817190054f8229b385f4468e03b162e2984dcfbeffc30dbbc44fdc5acf3f39f0104ef789bd26b73ce2f9cb7ab03d50c9639a7e0354c9826cbdd23ee78ece1a6f31c768e5e03f8cd8f1e567fb14a20d1aefbba3e299842ed482e19eae91a0c1dd9c749fd9b8787ed57d13ca031d5542ee4eb5e40fe5e0a0a8d66e2858ac06118e08851fb09afbfc0531e5c1e6da95bd5afff780be11c0fc7b1d2225b907ab18ba09e1901dc270e17e50a7c8e459516aaf557e12e3a6945a7b43c292b642b4611ead0be59900a23cd136d14e27f6f8ac1f63d5878b7eb5c5ce39fa8a1301234bea3599da5be3c84bbaa661e30ec3fc3ca04f0079f5675a00ee240d4cfceb3fa0d3199350b4f6412ce4f7993bb2e447f30cbe1ffcf4e43d315d6e7232853062ea67a867b946a94766e3bf80f8bea55b56da6b8b538a3bd629ba04955c8b6a3915ebfbf43603748bd09efa7f39fc78c46067a1cd92efaf7af46a2e5c3f87545cec522b4ee07f09bcf8ab1e8cd2ea47cb289058047f8dbce72e75cde31cc0d3bb543ab42a4b051f1b0b9fabd64b59446bb6f553581aac0e3e51a89373ef7b826bb65d8d465ca8dc0a3527140ecb95b4947eef338b538bf80eda691579511abc9bc504e6404e862c420066a12aba7c27698f3d96d5eed660f9bd63cb168fee2a2b87033beb6d17cd05b1dd6cb02601a3b55e3c564490a037a7bf320d8a92dafa4a032d55d9883bc63e6fab0c06c0df7b5d0585396d71756ec3850e117599556ef21ff3be3b9d32b6ee037459b1171886f33f561a34a66e41a552ad53feac7da5430b300c785218c153a3f030cdbf09904c00562e5bd88810d58cf7a616ffa7de090ac4df1377b0a87103ae13a056cae49099655813e2886b3f82930161759bbe1db70dff73baa24c7c595e323432b2dcb387fb64a31793bc77858f6d22c5ffe43d66fec409a5ad0c80635889cc04713b8dce527168d1b5435a0d8053c90b7516b65d95858f129e1cc6547a3507a0e8b050ccbcf351d482bc7f85b2f2af4e72cd73694c83ae375c0c70a1b0cc4e37fd9365b92539b79cbbe92f1d33a294d6c6485d7ec103c14b15869609fa7699e2bef59e0a41bc360d1d3e93e5cfd6607174c343d018720b31b24b9602666254da3ceec2fe734a9d7b44a662d54df88910c7c0bdea2ccbfd7a35c5e36d2d9402bfe5dbc96ab2216b55f43add80be1312f2cffe9ff8b22f31a5f8901537ddeead786314af6f6cb9d4d7afbac0ee7c4e7280deb93c2196f3fdff98c08b66c117ae3a3f0959aacba488f2baa0462ddf8a53525e478554ecf99b5f39ebffdef1bae87981a4deff79c9e54f22320de1bb6b4453100327b98f209051db98fb4ada7ea54a48d5eb0e7799126b9fe4ef2fad0b1f953089274fef0665c28dedabc5451da9a45f6ab1ef97ab7e9ee8daa8a59ec7395e1500ad90ff78ddcb374411cb44d743d3bf2b28116242fdd48d763ac5b86df88d69bf526c2ab18c31a53c64d755de13a77c8320e71f47bbf1074bc5f8772775a6a826779510acfdb9659a932024c227bd7a47b136deab07237f5bf3d957662db5319681f003b2fdcd332fc0bfdd30712fb80f57e212a0a2ed0d34c0ceb9c7b29364c2356c08418c74f33866efbd9f117fc5ce58ba837d7020d413545e0ddf5c34bd2275a9961d911dd73e68d5292824f5353c2d4abd2ba22de6e7dc890983011f73ef5737d95c58a7c2890415c464609808999c371f435cc0fbe3bc1100b80c2b075dbace162418e4b502d5d69680a4a60dc210af8a08b8a81036cb2a3c0a9e8174913229bf742c699ce7fae4123f8a97fb54089aead78b98e2539d663d0e517a9a2532aa84f30756c699c4ea3c2a702f4e2d453a622d21d40893b198c77fc5c13ab58d3d64f08e2b1c06b0067d709615e1f7905f76df216df8c192b05e83eccf34099aec482ba576297f7e2c5279f5dd439b2ab971be7be74879482267859cf0f6fd5fa94f38d9a160bda40923c115338854223d49510649493f332f88fcfcf849b91adcb1f2d4cc0c91ac2bfd94789e61ac4c5b95975e4888287d4a70cbadf8edf535a2e3e8f66b261652a6ca089067b39c237236ffac1d2e90667faa0aafc834a7fc421551da01c625283feddd73c51169ed6cbcbabb7583ecac0a989c58166afc62b9b4025ff71294b3fdeb2cef71d70187b2b759b222687021e4187a716d11a509db6e935b543b7a56cc391f0129b91c078ff1cc491bad3914bf05bbb3eba6e545f7fbea507e33ac9c83badd58250ff12c567b197bb18820edff4a3b95afad065c53035369d34e718039f8e4b4234961587ed8f566f22a9c27c119e2c9030dabfe63f16a6e5e916737ffab7a61d28789d89783fa12ca54a01b4c8a18973e7f6892578ff8e8b771463a98ec157fb796bb3806818ea4c04ad0d48ec611505631290a2ce375b215ec6d0e2323368a80375f73c9183f219cf0a61c375a6f47e14a48787dde754fb3f34ef12de0ebe7dd92e2d39292be321f2a03fe526c748ee435181a9a6657deb989f117622937967bcd28e8a8992182419d4dfd465f19ac3f10405549371769bec10ad21cdc7cc11ca82d1265ad9392fea718b3020087049ff7bf510b688d24776730022cd823b1ece3b52bf4ad56f6eacc3596e526f840734241a7f25d8432bc265e46ea1a56c4d17a2fad140898672e46444dc3cb3c338e9c02eb55b01df68f2ca8c80c1d104d50111c9a3d6dc33edc172fe4c226c2bcf4cb032a5cfb76e6b8f681ced45acc98e50248ab75d707a6c61682ed8145b01cbeb76557cbf50a9f808014c83c115f664f56d94cead95b8fe4eea6fd7d214fa0a041ac747631834257d3dae6a6430b18980fbac87e84e07db6bf02c1eb299c2a742b9906ee62eeab8d6f8bac0139c54143f529b4de00588de2b90334e72fe15f6f821d42f7beda26b91db3eb7990acb84a9f1fde9f05aeb4d1730df79ae84f444edb5ca170f4bf600ba86ab655cdceec7b8a5f364dd884f8d20519f91067cdd50fd034eddfc85debb46a925154b5400f7b4ae213497af86ff567699ba4d9889cfffa7ab8edbbbc2c777575ab08639fe158bef9944e74b975a71a39fbe262fa41338988265007cd3f997bee74120733e3e689ce63b135f7ad24c88bb24a70ab960e1a61e773d71c157cd7006137d61af3a500cfd7a9928846c3265c90fd2e2f5c46222802d7f3883245d0ea8bee3b6b2f75a84ebbc9be868fabe60bd633bb7cd180946256a8a9eb04d4868fbc7729eb633901378c70a36c7fcd811bb651ed180a67761b4f05690f5f83d526152c457e6e7bb33360ff42824e5f0af9eca4b3f0d1563a4a26de828d7435789d5b6c1ec4adf5940a88e671d12b2d1aa67d682807beb3ca332baa8f1e51f89634f8b255451e5a7bdf6c710db9af232bbe5c7ac162f0bafe8a9095f2a12d7dd6172e9d686407dd0d744785527485e80eb787a89670dba362daea7ace1d711ed9d33ce4bd1a7bd890c8d04235f5f35423b39a5c569fb07a13ba5a7187d7baa3dccb36ab3d7c11c5911e0a8d1cf53ad8fcfd9e412497f9055d6ce6f7a6ccf5d2b13e6be08bbaa5bb7fb5a4af2f5c7efbc7fd14aac693c9622b7676a72cd74ab31877c42353d0ec57a26906e19ed739bf376e1bd2fc04297940a3657740ef1e48647a7543469c682bcc2b2ddcbf6ee9a4c252f5b9d33a3b8840b512937c919955aa0c609e55e7b5fa2d77812bd4e46f1bdb97cc47b58ec4214bf52eaae72ac5c70db5fccd09bfbee2e0d54dc303d94cf1205b470847b4a65f3a88fb32798c224ca4f808a0a7ca1e9c14b6126e19374331d57a87cfea3b2f33e913a110296c43773f7396aa05d77e91403d405be06c497acde7766a499bf735cb33646cb46cb692da9e39acef1d7f98e717d7232b51d4452b274b1e07b86236336242a27f49583a3410b43ae4cb61d7668e266c49f262c657c75d857208385d36bca97da8fa7ddfa6a996f3de20ca07cfc9459f9baa86c259e1c487e2730304015648f1d60a67288226f4661b6d9415db8cb8beab53d3a090f9acc74fe244003fc498e3296493cb43f21e6a53f7247d7f3fcd9093a85a6ef91c4f3d2307c7806d9cf37950ff2e3cfbd72f2277933cc85f357262fab955bb806999cbe7a6604a51fe81cd4c0512f2a16c64f834ec7c2322074fe5cc9a340da603a24d96e284683a90c379962b1f4e98d6c264e8e3077cc0b7547ac74e5cc4a81746739a30168c0ec0558272208ce913d580861ab52fa38f5f81ee435526e990c9175a55566446bfd34c59f4392fa64cdd642c0dbd38b1d53133dd5d8cd0c73aff6dd19e32711fed342a1dd54125eb73f11dece67bc3d1c383413a31ead7763c58f32542634cea1ab857042c5986345ba643fab8ace3af819d990f27a8720572d2c3913bc72b62d2204a15ae3ba4676de8e41f4e135072d30979a1371b2ef0266b9f34c5131207f3655ba1348c1dd1167a8d898db563287d8a79a91bfa7fc7eb0b4cc3e9a9b203797e55a3130fba70d64c1c62a29eb85584177a19be85ed4f49e33020c475990895b31584b43d3222c8e7a2faf8c59d822d35e9cd13c00f0777e0fa1b9f62b22d96efe3ea4cb02d52153db9c0465448f186c374aab15418eee7bb49f50a216785c752c44eece7c5ecc68e902057c02ca05f8d091428d2613a93d53b75c7333d2de1ddfd878669e804cfd624e5f5a470e6c186fcc0037ebf970291b130cac18170e42652be38916722430e56760f9fcbdc946392e3aea0ec519b24ed6761abfa279add33d3541e5b3841245f5c705438cfd3e890b626145fcf7e5e97f077eabbe671a885ffab9d1e6e11ae0328bceb4d82879408df8b1d97ae5b96ad28d754550fde44344e303207e4599020439483d79ac83926196851b0fe87b68d762658767bc38c1e37e4d5deb5b4eaf7f777e59865bc413b7e35d36fcc8adf36000d544380c56ff1ff085d3114c94814ef166354a9cd7856a28b856e57acbf8797abafa993dab82f2577e5b1cddd84b6d1bc9719b17d62a447ffb1cb225dd4961ea7a4a61195c49d1362a31475f9df0ed1180c079a7e6f5391dd5ca81a2fbec8338c1c8aa3fbbadfdc2ff4648a13a065be8ba9c21c0de18cff3eaac8a6fa0499e4e38dd3120ecc84cc6425b042529cc44b68aa4294496f05334d33412f99014d99b2e45d9e7c8c4100c88bac352d117484e12a80cea2688b543a503e8116d16663cf401c6da94e354ffcbb033f470a9d5036a9563a63e9e4600da696365329d42e2d628985a55d608184b76d967183f9fca1b70681f985aa7d5d510eac772fbfda5d8fea91bacf57a1a791fd074614d741010edb48ee8e6ab950bde91e8bda4dd4ffcc39ce54815bb0e7f56e1df019bd198a8118043ab9893622772d6c0ec2be931c2ab14b1e614b7e2e0d13582348f8a099f11a744918f655b696059d688da0251de5f784e70658fadcb71bf0fcab3057d22349f8c402eb2d507a57f43ad179817b5fecf88a162fea6eb1d3e71aa1514ea18626f86890359bdd6068da379a690cbd163a212f732327aac4f3e30abec5ee684c27b8853a536644296704da35463e532a20ff3946a590f7da898ca78cdb2b73713dd79a157a490e9296953505dc7ae3600c9ced18e31e264927d08d6e052f74935dda6e609e993a28666e805eea579e70d0ab65f7aba09df76fa7230800ae144c0bf388ccc8a7fd6112b31d8e516ab89422b4a2fa45e56944bceda2010867aeeac1b697e9f47da628cf92f9a14c7b82e0ebc91f31cf61a60ca0260fe73ce9ed1550555ca3d7ad3a46a121c2449d24bc7b474cb64db953e592fdcad701b555c823b2aabfcc07106c39dfa3ac1865da89a9fb3a17338d47b555e670f726bda282bee76b6e07229222cb0e8f08183b66b8db0612bdd31ade02425fbbca1b5bfb1e07f1b831b01a6391f9ed053b503319abd9cde02d82b151ee4f8da2001f197013d61b28929ec7145ef0c42ca602b85d8d9560dffbd43773c1ce2dc9a42d0d311e4708d0a28581ee25e04fed51613eeac158aa2d6ca02acc83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
