<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd7956c008ee858f9ad1f86f6a618621e18efe2c68dfa591796933cb75efb260798a78d627733a09e79edd36c503b06c0f6b5df9839e2a26dc8f02cf18c979ceb52ffa8574187cc465b255c686573509c70ba35bb208bdade49e811c1f9e6031c37bb9db309c66f430c589aa63edefd95d7aa392f63fd0d75b597a0f24226bd05c1d1ac126bb1f81375c22f5b1d9bafbbc59607ff39f28fad4416eab31546e7dc160048f190c8ec22893d1c3c92e94f025ff9f2a0bdbf4cd2c4939c826275ae7b63dd89539415d795e29c89aa43bb763ad9dbf9e53cabd048cab2dad882551b80e6e8fa10ad3b74f37a559dc97f0f6d68aeebd69e1b052655b6cfa17efb14b56007f3b105e59b876736285cdee749aca4bb8c8d5fd5090e8fbb3dee621685bd9283b1067a4507523109ecda8e7c32fe5d8f9d0a7e39d270fa25268eb8013409dc2d26cbf2b9c712ff2f7859c65c32acb173d5db266d70622e43331b473bdc8d7f1261d5c1b836b8dc1dba3a0f1da658e610991117561a9de748c10e234b8fa3bcf83b9e69e9f9e3b32b6b5cf3cce00881d58e423b21fb321468ad29c38312e6fc1c73b71dbd043105e5ca6174c5a451611069c618dca4971cc41bfe532eb28ce6fcd3fc9d00ebcf75c8be177b07c535e6f4ce1114cc91860a0b7d711d99543e79d772d53532be60d7bcc96917cc2e481f99861e3182071181aaa8f735f4a76821e51ddd6b34ad8159eae4281cb6966d848323014ee7ec2234b6183ca99f0166e2a82963b7357832c672cbbc472be1f359fa0a224f0629639ac9dfd27ba0c0f1f8d3c7ff6915eada1a672b7767b621a239bd32ad949349025609bca40fa1d7bb92bb9cec009a776a2bef9b556907457cc8445920a7872654d93977832354d832294f99a74aeb71f246674edd1e1e0c5cf0e2d993167aedaa748bdd6cf33b2563ce5ab85c21d05d89523fb91280391d24e0747b5901937f6f143c18c2ea49666f5c7839d402de570d5e8576b10e9847ddbdc9fa652a9d1a8254e814b119757b72896c1b439cde74a6a54e0d91aa07e09ba74e3b00fc3d8f7280d4d1d2ca68f5de1a763285d2181e1e4034211d86d8a37b0e89bdf1a7f5426dfcb4193e027c2c3bcde058f2b84b02928a4f9a62f5381826aa6d0d1e8d36efa63a129726df9115408f9c4a8ea1f134a5a0a13befddb0be00b0812a7d1812dcd08293d3f264f62358ede38322aae61b05094359a447354de5406045c37bc446900e351c341f665e0f8a3a42e61dc9547efecee102b9036da5f6ea21beaa64727564532078b2661f908c04a93b751cc1fde3dc51ad557a9704d649882425385d84fd68ff57b4adcffc8c79be1238cd95407f5061652b19418e3e51bf5e8b2857ad3994ee8ca55ae2c329cfcecf3d785bdd29d48b8e960743f87704ddccfd8b505ff4b025487a0ea9950d90f6bb9968dccc61212a3f29271820ac3caa139c38c3e0edc6e23091b19a859eaf7f4f0b7b96a6fa7496c3e72367667c3d887c85a5508e060f8cb3e2622ef94d4b91cbe69c30288efe8b79076803ea15d25ef59b37fe3261fdd8791541607cfd2a8defb30acfccc4bb6023c7b5c49d8af57d140d78b1c9c200ba7f98918ebd7a67de2de4b085b882664d843e1ed7fbc8b3a302fbf72a55de5b4d4570ee86547563e8c875934b56945c76e16b6269ab54c188e21c3d858f6ef243cc55e3539eb707cb93ba45256407f8313e8b0bd41814db388bb3c8176c99885da753488c1ee97c094324d63713e4e0c17ece1354ddb9c160fe7695eadbbe07629fc958edc1ec180ae8a9362bd7c4c3f923c5e80a17fabc07c81fe4607d181b17d5be78e985cfae553c17a887bf0a29f1c5d82fe6f0339531cfaf863b0a417c29b01f1f27c6c833a22f566cdc128b20ac02e40c6c379d8f56f1d947a178b6e7e1e061ef5f356eaf85e37175e54aea750eb15fed2b7937fe5e4685e1424779310eb994df4099550e834f728273486dad7ba5b3d9c77d8c6eabcb65c611c5d334043f52c6b3a8486022c5dd35ca55a255e769712c1de0acc3619470906e526f48f740ca40efe4e865659f71cde3f58152f953ed8951309545d21f2eb0efd7ceb18216fa623e9352a872d06b0affdeb2cefbd6fc7db4754cf22c51a5074853bc8cc4959b8497970117a74fb30fb70771cbae97dd309d088ba21220c99d00a9417fcc7a185495cbdd8f26a43c887ee750940ff521d8851fe09a0d7fb76fa22314ba0b0c384fa230ecf72683ac846664c5e104e85653df81b3d63c719ddedfa6d7e192b98c32dd9ef47993cf8989199790faf8eb2115d5a02379b61962b0eb0f9c09e8fb490559833a8086738402cd19a8fb355e478ded43263a044ea149b96e240fcbbd81dab19f185c77ea62fc6c4842976a19dbd983114abd73206c54de4b7310f3d3e57fbacb0164856049910a45457b904e41e16ac537b0d6aa64b96ec442a3658c52703520c64b22089c2475e57d1185eb62f21f708d42ef498921f5f512fa1cffc3c9e5aa0f934bfacc1c0710b4b9aea6e9c5ca3f29a84161ada70ae9e39ecb31551e0d26a0cd810280efc9a3baf12fe79f4895a0152ae14047f632a53ce891e2f39eef56fe4095e7a2c046162f9c3cbe3296bb3c2c6e74412b36ace52ed1f5413701dfb9375b4262be78f5279e94eab01c67b8043c5dd9654ce49faa2fcf8c168f32a2f0e44253296ee53b0d5cec9e494857eb5c0b1099f83fd2137571e3cf521c2c7a8d811622328d58fdd96dbc5688262506b4e67c013cfbbc7391541f170dea2b217c4b908fae34a91cb5f3c0ae17cc84e83f9fe34901a757333fba4c0af6f742dddb388b8c9d65f31460052ed32c5c2384c0f54c49e86059c9bc9a67220abc867b71bfb039d5c7e00e8a5c8edec7f308f0cbf82610a3cd04323eac784508cfd0712fc67314e19633f4a9af90866b20dcb2e02ce493fee86e3abe65c66e66a2fd10abff1059ed4b77203c36485bc1536efbdde1b1af6267eec1f0c79a8097b38434074c756bdd3193b4077c9c6e2c40291db50940930d3e9bbdc7b9e6a6f17c38565c06276f62542c22167e292bc01d4916deadd5ce4dfd903910484c0ae2caf65f0ab6a830cc17586dc418387723e2ec089cfbcd27b346f33c9893c4a2670fc4578e7563b44c0d529bbe2b4c9c10292d3968edd698238d345c5d3a708f141363562903d29e0e5f6dbfd9cc9767bf915896b7f33a8b3eac3b60d5b2607c09702c1578c50ab39159b4713401f85235b3e8a5ce1d208bf3096fd6706186fdce288646dea02d122810a51f41ed4021d67bf411bbd9abe3f59d3e1961688f96f350e32fabe676ca221f58792c81617146d2208a3fe827f8bfbb414e00edf6cfe0ea66c99a515563fc0648837cf7c39fbdc544fa0771f02dba3a8a5daef3ad0bd2897a2f941c60c8986ec268e8537cbd42e3c37610ca1667cbc40cb0ed7776888855107d4a5ad7b0677a206f7e091be92de31af1566cdfc831800cd879a677df268fcb751dd42dccd5f1bab83b4a96caa983e13e7165eee40221071d697ab3dcd43fab53e022636ee015b58f326d45117f48cf67238f2391779ae5114134fd602adcc684696b23fbbfce842fb880045083b09ff84384285654ebafadb7539e53908a800f7dbe1163d6a617642b8107f7e2e81b0766407c6472290c68da01828b9650527d3ba6e3b6da765210d22fed1573ce5fbfebeab9c68cce89f0e66c7918cba39f199bc5726f7353967fd3166ec9b8c1a8a7deb612b8be27909fa205a19d741ad5de077d6d68d9a67fb39d649bf2523fa1c35408da24bb484283f7e6f4800ef8bca978284e2c50d400eb04bd13911a1bf15cbd74ab8d6fb932fce17b53d99b10e8330e8bdeeb37a35eb872115f7f083332469acf2c523e471e136ac6ef691ef98a851f1a876fcab254adbd48ebac4e426c9f991d7c9018400075583d3825fd3d86e6d006ecbc45055ebc346bb04eb05639afcb1cd061f1060fbecf4825572ebc9df6484e5ee21456331ac48376098a09632ab059f0652581d45e75854c9f2c06d3352ca97be5d8acfa37673155ed4837fc9cf449fb2b78edfe09ef17dd2fef5d951d98a51e270f6eae331bb7e43623102614c0e7db6692ea7334e794f62a749b9ec8b214dc4f098451b29ce1a860a96043bd9d9a0155e8b2bd9f37e703e55d41760a8f9620b9632e69e081332a0ebb45dde25fa4278b33191173235fa2d40b11dfd0b617dc0ef3de99ea13116311c0c9056adc9ed50cde230b50c2a3d47e9082aa4d5e01e084cc74601d4ad814680d62a1689f825eb7e051c81d96e3d222830016bb66b56f9ae5a96909089248c2938088155f70daac3d1b816375713df1d1c11d2be0bb781c2525f25491df7d15e4541549f71d3c781dd3ba1549ff687c95eb11c9fc8263867206aa7a7e16e43254c30567992aba5753f7fbb4c86266be14b8a09b0c851c9d81b5ed347172e1ac68fd13171d78428897ae66e6213d812e1df9524a8143b7ea697fb7a591a61df5b3659723cfb7f70703d90538d9ebb3daa4c6c7b1675e731e8cc3c32cdef8c85d8e1107874d6a132769e694119ccdfcef9a9007e6e2b360fda296edbd33fb7f9070a774bf79a19fb1da83790d3ff29a355c8a4f9728446469bec28405233bb8bc0e33d000c195d147b9fee0ca07af85e4d4e050743c8f709216c07f113e11817015b736fb239dbfaf1ad684d74d4e67ed1531a34180d37c08f9b1b343066b6d49869ebeb40cd1cb18409d4f36df7866c63c4c5cbfe06f9297bdc144d9f7fc5c3b9eb73819fa2c17d079c092994023bdfd8ea9bd4bce8b5eccc8b3d12d347cb0bc8547e88887dd43b4bba44fa3851c02067c9496b28b79d6568c85319bb479d1e7903924aeddfc1b38b47bc20bc6c1498849e7163b6a4027d89c69f591296acbf649614f7e59596537e3861d4daee0e4788d5d13dab8415fd2de79fdc894359912418d0687eefa502b723ba971cd3437f1f927155383610f8021af44a7c1139bc8f167b81427e80af7ff4d26b8d37b31de55028a492168da2a22b0f2ecb45599a6c0735e2b9663d804bbb09074d69e6ebd42939251494a7a199b2d38c893c0875a603d2bf4912b0eb29f16b85a3d2b85a052e70edf8dff3a17981e403079bf5072047939e93c0fee1465bc42ab703d78de69c2781024214fc42b6f47cf68cfde29d94c8a7eb635c6e52c4d96e3f478483e072296fc6760a122f62dd4f5c180acbfe89eee78c0067cc26889b37c6dee60deb41377062797105bc65c147fe5aaf7ebd81e1978d72592a6305e27580e1cf75794278269e320743bb1311dc37c3d6575d1cc170a1ee9d115cf1dc3a0280157f6c071d7346c278d3d247aca80b9104140ccf091598cd7a5d51c945ab37486c2ee55207f36ed7f731aaeb738638326123449580db3eacfd542780e00ca89ca54c0314e6311996736485d1c5af19d8919bff5fa66b76b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
