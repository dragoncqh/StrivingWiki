<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a892df4fa332d0c4b7ece9165fd48d5041c3c630276b678d0340fb6e8e19dc8f124e18d6cd2a47c5c67f8f7dba4022716968299e744e657529fb024218f98a436fe4cd3dce13c1330b97335b37067958a74f8ad01ea33e94b2cd5f726237cf1523cb114132ad0765ee4530f67edd885505e21d1adb7490284d0a67aac22c7061c0639daec0583de29450e29c0b6cb2d2e3f10f70398f1ddcf4f5acc9501af4154aa2e0e70732b5ce914902c95c23ae7d5ad7a370e54c4bf6c5744e25f17e0679fe7e48d2362f898afe88a641e55516af9a7e07480ccd57f2ab9aaff6013facbe34bec467709c3b3264f20de159c04c2e76044e26b12c2d14c87b88736fde2a7b97a3562662110b2dac403a3f784b6321a19a7ce60e06761f87ed986ddafab7e4e6ab188ee8ebaf28f9ff54571ce80e651ad5a397cd1e047cde1f1724878a28233915dd1005c8ea6f6601971447151c90cbbb7200171ddf10fbf8eef664e715793970ff2c7375a99b31e74486f45fcc9255859c48c8d97dc22101f9fc900574e8abc0ec23c078f769dff66efa47385d46e4e3e5a91f032b44efb4864dc28fa9fd20ff5185938b69684f76735e002ad3315d4247c21d21f148a3ee038a35f42a710ffacee1928d3247df164cc1be2ea198b16148ceb5dae55d9d55b7ce54b7fd4cf9aea38601dc0d0880864cb7f6d2921226203aba50f2e2b86ce036b5cfd7a933affed4aa01c7ba40dd94736474699b670e008551e8f479cce13f1a8af8c59e90ce0f1e0666701e2b327a2558a2ab939f3be461cfbd5aa48429384648220cca2c01c5a101661fa9f0f87a028ddc61e4a2711843366771624f1a3a83b3384ecb7010bd8782ad1250c3532e87b10a77df711490130d60cb58f8f94927360febbf821857a480bdf51e4497ba4a504b5c96662ea324ad211988d2bf6b1813ef44222d78bfa067822d1a70adb2ba052aeb56c6750707abbf82accf0f92cf027c743e659cff1c23d9189d14fab2bbf1b49f5ed2404968635955e92a7cac785b4effc5666437993359b723e2029018a870a812a9af5aa5a6be78b70e893654e696bd2a0e4fb93732199c250add4361e12ea63f03a9a4767e34f0402bf42c105c09f0946c3af0681d0bf331a570896f6160925622d2083dbbb4d42ba2e3761596898333d924314c87e6d618c1579c9b95d240f8f82721ab878136f028b8fcab44ad752d988ac4e3e83da13202453dcd5d23a67620b7eb6c7227197f9db1b231fece2b0928c03f0001d80e38a89733ec5c9f6632219b54f21227b8a5e502e100b00737a123d975f0ad8141c353dca52cccba894705c3ce1f4c9174e5f7f7edc1e6bdadb65bfa0b2c2bfd0508d3611920a42003a776fcc657107ea50415f6693ed71854e8753057b178e86d2916fc83bb97ca59f89ef80335f1c4f7ea546f93d3fd182dcd5cd491c1783e6d95f69cf7daac7a1e179d9ae37a074e7954bfb12dcb804efbd663e0f7e98cace40c518d6a36344fc7968caa2150c882d14558df6c6585bb739c1b17932aa163100966a60f46c107c73cf309892851283149941cb9278dabba1834522b0efb580ff418039976e82919b474d815a825d6a8bf9a272f5e7480a89b88961f059ad6fc396229cee81a1fee79559165bed87ab9122bead077ba3e1effee8c18343787127ead5970fbee0608fabf253ec5fcd5c4c43ffcab4e801891b4b05ed36424788ac3de73e8b5ac72b5218efe44d76689b611f9541b487891090a05a1dd147ba10db2d32974275de59bf784b8a7d9fa79d38cc21f8208e388b1ecf1f565e32e7260556b10348e34b3234be70dabfd90356966ef9b3ab436ec3b52d7f2bcd7ea35c3e61b31e451636ceb754a7e7811ad948d1ad442471d46810d7d0811e9c3b041e93aa8924903abc017f62ee588cc3a84b8bc60443343d35996467437100665de3300076a724264859ef5045d7e52b18b1ad2a4e57a0748402202a4b269a11bebba72b57056f66b66e57a5515681e044d4f40ecee58cac832fd612e3523e0b36a3784821fbefcaa88e0c8fde9cef4742d2cf738f142e842b4397cb58295776adf5a5e70501b7b093010e2b959fa541c04e1e065c05d42fdf5b7627db78c74dbccbd346779147f919a7c445babeab3bd0c7fd77689090c93a9af6b1a16836b6b28ccdae663347872f4c76ebf8017e3626a730d793d06421af7aab6693d737331358e7fe92d82fa4abc770237401f623b4f0b1d16480ac7ab56ee73c5a1a42c09d4164ca8554fba821e5a3a87a22ed425bebe077e14a4a5be2d53c76b1f86a37d23acffe9194e80ce38b233ec937a5741bcc207d509b9a4c276040396963794e4a5187deed0ac1750ec058224cc21af97a0d4340dea4a8970acd8611506b33cb126bcd29c56e641c94226bb083f631895cf44696f3cdd63d520234fcc634d111cb6028e602f0f5c4209e2625c5e1fdf28a669440e8fb5f959b826a81e93844530c1c124365335ea366f3a96586a004ecb62244b8b2f61160f289e8c98b0ea22199487b586b82528f4b5d45725ed9364981463d946f5e2c4c4228161e1a68401b1250342fa248b8529e1685fedeb0fab2181171b877268b96b7b4650b828ed154dce094d270bcd14bcd3e18be1b4addde9076605ab2ea195630de3af7fa32030c8db04c4c88a282c0ae53ae7e1c6edcfe2cf6b988ab8ee2841a5bca1a9f145abaa3c18b02a4614bffd99cf3dfe32bce5e4d164477e212fe2ec7eba3fbf6ed2e301de43dbacdf9a054524554c2f090012a442a296216e268a60f66d3d0a83d364da2408694da02895987beba43a33f6489488af33bf3eebb5fa379c361eee3b8b00c1da027c1e09d0321e895d197a8d2abac5be8941e13c61b8ff4176e0e6a5d2a6ee12b60375be7696d795515c695b2db86a0ec590de00e9448792000586f79d094f4f67662fc989ef8a5f14baea0eb45b86abd0bf4642104c88fd687dc6f29a99e973faae2022b96a93dfde1967bff95f421dd5462a2928c7865d0a174347be54337f7dd9ea3e898411229af5db7088266b495fc117242be323029e2b9be6a2dc18cd755f8f5ef67ee34903e0dae24bd294e60e09f702946739005392762c452928771a82bf1cb7e44a7944f0ce58f34d640f9f5e775db71a6d460a6690379cfa7b7764ecd701843d2a2b5c5db2f48be035b497c2eee3b010d78833f956c2c5fdf1d3e8f0b675765b610efb75b8f3dd58a1a4167b181cde07c16a737bfb166f4e7e8b82f729cff208a3cfa705d454ea87c0572876092ec564f45451cb99c712d824c22b9bb365867028d24e6929ec3b22c8f056e4bf59ffbe7605c704d481ab58423ecada395081382a3609b85df432b6e0d9688f30a923408120daffa9ddbb09529f02e311e46f7528e10208286354f4b2f863dca9fb2ddeac155da26666f4a149c3c9beddcd519a4ded6ff6bdff7ff8a8be2b70648d944465ce2b4707fa11de0f8b223c3446b713a5c8ddb6f7219443160ac49e8d39c06be52d0fc4cec151383dd4ca4ed20be2db46ee3cffaa351b20bf2e459828e07d7fd484f7e0c11bb0e8400022b89cea16c8ad3c1b67ed0c3948f74a026baa46f32150bc4d3f2c7813c534b6c3df9397884cef0a76851f55c96336dd4735723aff47f9b99ba68e42c6c6fa37cebb834dcff5f4179a79db5abe67dc56513d7bd676cb0f35d4a8fe73b8b585ad6570d89ff9b2aa93aa39b838504876eb0f5ef3ab7d07de94734c70bdc788eabf2490497eade9819b6882cffc3f6e25798f1c21661fe60ca94fac1dd897b0879c73b1ee2838b979e850c21c9d07c6d72fe34f8fc8166f060693cf6bc673adc56091cd84ebeab6ff5ef0a7e729ee9cb2d3ee18037c25b91a969cc7da8d1e12085a8138cf0c01b2829030600a7d4e840dd47bca82a78982fedb9c182be96132e75a81eb6bbcefb6432bcce0e65a2c1da6bb2eefaf5af7f89a01b97c078ae30c648d0ffdd87e044b45a025476e9bd0d786c964867b90e395cda9e5d6b453473985d6fde5d3b46de858568fb249f91bf291a22e19c0303689b92d0c5153194868851705a2f236ede77477c1023580d53bf350e956b9471a2abfc27f8e84f890863c96a2d6c8d68ea495b398635b913cf264c0256b4f4b2e0e1bc539675b60b483cf724c265ce41c4743d1e3580825450781e7cf90368e8335b2ba974401f23760598a20eb763c28c53d46adc2d412c63c5e3a3c79fd7d1858f9d73c85aabb77bc076912a5ac4906c2a3209ef5cd131f226229fd8b90f6d9f479c4cda4fe41cf5acfea755d03e6dd7be5ad62d94a927d994552864e4772409d1b5d7597b2f9a3d1cf6b755c1f04286763880c5cf9cd7f4fbaf80e352f2a393fb1fe538d0394a16072d6a4ba3fb54c13004855cb0e9b0bbe32bdba0247d882154017bd83ef2b0edbe834956fccee6c9fe7f2e7a9a893bf807bc6b4ba7c9534410b2ad51e583e01f1d674e28a9fcfa426894d60bc6f2df048c607c474bfdf9fbca3966356f83c225a0278a8804cb78845e9b7096973897dd962ce69467a785e73313f9dfc169cdc340fd5107aae5afda23b4d9f7477807349bbafb2f403b7821217c056f2751ce8704edb9ee45dc12495bfac072562e419b1aac4fc6df2011b330b86c096108d6a18a7626fe5bc61cd345cf278bd421452559a0c22cb298189833be754ef29a77f6698fcc789d82317488ab42a8da01cb88b1a87eaafd81276c3a176a52ed2d37ab68fbd2faaab35de18e0c647bae761509566ff77f88e8e96d033a827798f1a3f5adc1c9ee1d625f74979466eac69b41d66b4d7918a103e8765a714c1cd82cebee5cd928342ddd9cb7cb84e93e00dd10e2fab8eb174ea006f47aad3d24d6697039a2308820e88af8ef57f6c0bcd719fbbe00fb510853f67e43e7d582f497cb5a47dcabf4698a41e9d99431e985ed385ba4562e922cda407717e11f1e53aab410e0bc92d08fc1ff3c5ff600c45452f59e84da2b93069934281c2971470986772297a296dbd7e54e34561fbbe7ac6189e89565f8ea87532f6eb4370611ab77c75bbe25af7f5da164e865f2d88cbd03dbfb92aeb91b5a2908a998647954b9d652b80c9eaae65bdfa34152a42fcc7d689930daebbe8bfff68954dbc476d5c2610682e1b184b5ec9e52ad14a25a4d4397543870237ff4c3fc17d61dee859c7be8f4b9c386554b8d3aaf2b29692abe16c069d9850c24a9aa8ad34daaa68b97ac657293420e88db101ea5aa6128a0384dd4f2ff3cd0ed17f38976d387760cff989c224680e5e6f51fd3d4e17a4167149e94759189e62909d7e5e1dfcc8258ae8a1b61ca9338fd732e4fec77048d59b87fc299ae1581a9597ae320b2a7ae9a900dc69630ae0f7b78fb0a61a65e4f7630c86baf5a8a5d3f6a593c6c59ad8bd0744a54d8c66ef033c71f24763d3b2a2310ad67a350d9c83055d65793b9550921e26411c53c6aefa96cd0fca95baeecf652c91ff90c5b74f134c614610cbdde1bb73d584112b8eb849c781b88fe61c6d52c73e64e8cc1aeb1e30bb3df00970b1508177523928b858fa0131ce992e963381eb6a9627ae6096324896d38656251a1276de39914aa7a7efbb80c76d398081a3b9c16356fb8c6f5cdee8d2d06666ad8fee1160f98d39f9c067018a6a7804c3a856826277cd25b1653ce094546f81a6a4192ba50206346f822635b349480eace980498a31d09cbd5854e033dd3eed4aad1f5d635030b0d7aedd78f9105c616dabc3e653dd600bcf6f69669bca29b773ffc9a1c984942852f7583b9c5fa637da0b45c79af8b48c6ac2307d1ffce2575ba50f3ffe13a41502e9ab106f7a14eed10472feff888b21e4fcdc9851c1c2668e16183bc1855dd200ae847a5e276a29762b97c2740b28f7bd7819391df5278f7e6ea089cc22cf7a9e8ebfbf5c7a2cca704032e881585695ab0aee79ff5be0622582ff0c49f152c1fbac54b0964e98d7db24bef5ce9a2cc420a2ecaf0e389947893218a7ab1a266aace0b7e461991332e4c72190b39c7015f0be52df940a4d40d88bfbb31ee615a58471d3fe188304b1659a011faa9bcf870b6977124ab67b55b74a5ca27fb367fa04bea68073db22b85a05bb08bac8f0fcd2a9376082566d284b31edf527c69e3ac0d868d44a226505a097080f77b994edd9cb44439bff67f3f1363e47cba83a68aa3d463aa0c926b143e8944c4d8e7b71c50ae60aadfacc5a1aa04b114a2b3b325366f308183cb6fadbfdb9d758b12dce6deca4a282e77730ec551d85328d0c529e53a05faee1a9acbee36b21670de52bae6e9ba5f890ae109c8241df67634ebd1ef82ae03fecfc1be77d7387ff89becad8007f8b8a2c08fb386b3bb14a23cc7292885409d91587606849b67da044d980d9e74fcdfd7d7231075928b10fa6b18ede478992442af700ef89d93756bc16bbeb1ad2d5252e4c936ef34cc445d447bcccf8246d55a1a89481a62c98c1ecf657f6e611d4b800b78c3b9f9de6a6ce9cdb1f49b65a79aab27d721d1afe6c612963ca5295c9fe2ee415df9022edf03220de2c990e0c4506e9581c8fa9f14ae1403ad6b476974c8df8caf5e41ddfa7196f33a7f2fabe292deaaf958af26c2c5b00889585049f7e59b801ebbd7c6e72e0a69078803d41edd6c64923ef09b2f8a7169ad7a925a1d141412ca39f917b66b0ccdd01595056d788f1f9c144bf047cb76f3e940309b6ef6ddd750ae8ed1d1c30d871a78feaa52d1914faa22a4a25ee6265c9dac042c42bcd271d1bdc0fb45d18ca01920840dff7dca24881593be8fccfc18a4db736a7f58b1d8738b9dfea253b7e8331f6aa8fb6581ed41fc2071b5f69c77295d12863a32926a59f885e15b0bfd48511821796ce6897a6581f618c9f47f80d37d52aa1dc217db70b8169bbbee7e5af8e62b15dca72d76c679a50a488b7158d6eaec7502154593fd774c092898490654ea986bb8bec6ab6dcda533f3b9c0200433c5df5ffa5f82fb62c2ff736c33fbc7ac2816250e41cc2b899f5ae7ea04b5c823364b48d28b66e9e20a3ee8626e1d4b6d68433fe4f670ca99c8f2f359f0321f27e84d8a86cb5d5ed44893c34001d64807a5006ea952413c0aceeb93e012cd6a3f6461ac17d610ea9d6b26bfbc21070739fb98e0b83ccd88008540acbeaa9b6afe2a73d408bb6d331033f0008a649759addb736dc182fcebef7bde5b800f668c0581ede6bc03a1a0351761f27d68341f0cf735fd147c91cb86c574d6a70e1f61177aa92a346d1a2041160591126a7f84266f5bffbaec35f65bbc249a9fee9daefed952d12a364ebb28c7cd6b1df252f6643befa086ae88aafc777c5f24d01f930ceabba48b93a94e7283c2cb516ac5efbc74c146dd3e4d99bc3883fd0074118c4b586548f208534b79de4f7b7239cc68af2c2444c7afbb04c434d61274061da6233617a9bdcdd0f8cb2aed61266fd0094cd852048fb1c6bc7c91c5c1d49163f83619bf8509ceaed0b5e2c6487b91343354aebab1120279952393b8336f9121e4d4f1830fd76a88cbcdef6c00a49f53dbcaf500b3db30ae3b7e955583b3661037f493155831bdcbdd554ac307a384afde2eb172a68496698c5795f689a959aedd2d3246fdc5eb58669334d3f89e5568a71d2795ea738949690e972cf9eac59804e1dc67ff3bc1f9d1a1683c651052ab206cdd44f8bdd44deae46049e6adac197050b0399ad40e44dcd0a47e0fa2efb1a3308bdb98e5184c345934c82a7760dd52056463da757dc1c1f052e6e9c7c484370e041e7b5b4f3ccb96b499b2d3873b0700b7d3227aa6e6887dae2b1013e6aa10deb28c632a2116d24f4377f4526fb423b49d994fb14f97c6d27e096c5181a6c2ad116eedaa083d96152c2d9923b2964e1b3193f0585c8bf565c93610dbf239b335f9eb7a75668daa6e4c3fad8e71216cebb0445d7af3bb45451a608dc1a270d2ec2fe794fde5e7b415dda966066290072a542a4d5705184dbe91a280252420b76de5188188924fa38fe870f9ca87456bbca8cd58795aeb1d22673f11479e0729c73e70bcd05a05fffbe406a8cd6b9fc22a6775fffd6942639691de8ac7e5f98b81584cb694a59603f107431a5d71300e2348217c6a07a2f93b80b0022da1e7de90f80e2433fa3db0eb07007e1a89c3350219ef7331df7a8ccfd2654ae0432d3d11feb0dd696b4abca435dc39521d9cd46291a607eae32b60918b95776dbb2db9c814d2f26520faefc33a4446ebde91842cb07170cd123594989cfd11dc1a20d63d174af4416e6fc668e02689bb0197aa5e5b9c841ef63206c79ad2605be5d0df3c9364c6e1542fde3f37128b71cfe83aaeb7e94a57146e37f653315cc168c2db83c3abd86ddf3040f3a96e66ca87fe8203bf641c11e71ee4aa45907fa3b7bd9ed02d4e846e4afd8e34207cfe951c593fdcd8232d73baa3b170432ce9e2541093ae1ae0de713fff68916c0a10112d2086ca774ff887017263a1e17a1249f240d94067d72e97868756ff3c28c8063c2c8733389e27a135dc59a2e5c2ea0bf752f11815b63ce760dda63c1442420dcbd07f06acab61c40437d78899affae1b22d4128e6d56937d85248c1fd29a71688db606e20a1ebf4c922faf3be4674f99a1da2ff0c8696340a1d820aee438e9f04f7cfb4ca509b8f10f66181f89792d0b5e9d052e170a5256821fa267c93a518e54c78fc37ef55aece132f047fd5269b3650cab24a3b226042b71fbdfc22088dad400d08238643906511be83e32cbfe82e131d8408e85daf2fd3a2158a054ae79dc5b7d4b0f2d41c587ac3902e44386bb5c9408c8f1d6024db48f7213e2d8420aa9d690a92b8e4a05d19eb2f8249ed2d2f1d1066a23dfc0a8dbfead3b18fc3491152e079f738ef67a9d87f1c9b9b5b8c43762e119c0761dfc83a2f1ce3a984fe109dc71b94ca5ddc559e428fb5788a1b48927eb550197cf9bb1bced741ab838edd3e1078836485abcf4ec3663ad7797bd53f5914d40e1c7eeb6347b20561e8e7c1a12f82f0652adc73efa855c70d344194b168721f16989b46bde45b5f7a8199e6a218293909e2b78dfc3524eae9d4d965793b537595bd3ffdaa8c1bd844bf1d7951d2858eaaddfd70d29df1b43ba51de8a121a144e10974666bd4ad146972259b95791134b6f8fa9b172ed5e15c7e3d0c9fdcfb189d2c713686a10a3f978f9fbf4e7ef14dad6f0c76f79b5f26db014fbac5a549766d5567140f989ca437f52b4130cec2fbc9fd0c0add3e7e71eb322554705eed2970d96e43835c3ce9eb9655eae4565df987618619507e5a7b7a312deb8b034300844f5ed729ba58985be98972745191e33fbe2262c4e10d55514c7aba418d9f4cc13c3ab89bfe277ddb1188c3c062f1abb45cc8e24d02632bc42ce55446b550f49b0929d4558cb5dee0769ad166b284bed134eb2af319f920e076b43bbbdf5bd312c860faeb9f4c498e29ab9ff7180ac7739fe4d3b508d2b2aa14fba6065f831553fd8066ded11723fa75d56cc5938e78e24aceeb481a06b94bde45cdad655e81b07b826ea04e3fc77de6db908dadd6a55cdedcf00f7207c77e353f4476c8ecd49f5fdd4b4ba80ea0b136ba43eda2c32d3775e39479fd541dbc6e94b340a216c5b6f29c1254bd22037dcc66c094fee737311ea0a85f7e1524686181664db9fd3911f138cccf3084b7e7a8941c4e9e0901915da3d13b347a88df9f2c0d9076e76cfc3564b3268f4299395e37dacc83d749c0adb537c6ca058b294627f6dd0416e96424e21e5d3b24446a31e0ab1c6c68d98fe0b3cd7b2912f3dd535f340b0e88945fd1f6ea28a6b7a5f522579521b1bf935924dbb469afab05f2ab4fe809dcba599f037fed5fec283fd64c5da0fc8e20989072727f630c8ccab0d4244bd7906e7f20a5a86318e7d9d1a9b0ee39ec0a81f082e87c3c3aea40d9cd84ea84ae07dd4120f3a73cd536c0d5b3743a51ef8032dcee06cc5c52bb29772d7e754f3205548a70c597c6ceaafb70ba12bf140d679934ede969e557d327d1a891231726e814018387464b7e8954a92fc5e5ba1f4ea93ec3deb52b5ef44328f141a0be10b714ceb94f654ffc01a37e8f847abcd590cbf2d4a6b9276df54cf9798aab18b8265e5b70022eac9b24cb8b594789f0280a357fd329842bb54ff3f030ce116013967d1c29f8a1bffa3457ab950cecd257929c9d4685290492eda8004bce30a740891b5e287ab85108acb26a1ca38d3b8618b81cd76af78c1ca8c7fc62efaa0d36d1fdde7de9058e6780cdca739","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
