<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"536504aa4b9af8ca119fb10fdcde5baf9dcc6e180eaed3ecea6e8ccf18442bce77435653d227bd791635de4736f99e95472173e2bd3a9af1cbfec9f0602c13e7423ee4fa53c59bba686e5ea6bcc97f187a61ba1adcabf31c924d905d0f72580fc693b321ffd3e0e1062b1ac8a14e1022dbecb262108a32c019e5f2cdff7e0157d90fa254868c92e80ed175f6ca5a12a679dbc0840d9e338cce28216a2e5b5c4f603f4ccf489d71692832feb9d4a87a261b889bb43678abec5360984421bb02f866d543feb30f1d7f3ba1298b76c47214b18bf13df0fb915c56e60ff25d7100a68230ddfe01fe905bd7e8036d28e28d479684f76f9b0021a1b62317881c32c6a4eb467f9196a14a4ad9330cb7456f8d0e8aec86c2aabdf517138fff28ad286553a890a3337f152eec99fa65c65dc3f6f7eda1dbc82f81f2826eb3ec5aabd7513075d3fd9644b321ab40c2b996446f84b41dd5f4e89252810da35ec9757d6616a4cf04e4423dbd8e3ac7823019b790f44e7fab38f3e9a30425120f457e0b546c743ff382e588b4c32231478c1026d415dcceb4cf3b7eaf7e984a5e2ec851ece7c5476ee2965070b7b3511f5ee54351e913a082e7431afc40b82c948ccd10264eb6e86515a7520b48e70aca6cf86861c13bf12ca1d8c281406dce84e9d5cdeb2cfbf4729f68594b02989a0768f3ddfcb0c882f1625d41ebb6ff1068185ebd48f7e7047490693d8ef0890fb420ea7f6020430e7d39dc054d301d1dc9e0b840838de2b395e30539c07f06979bf5702414855d62853b701db41a97050b64fcaa0b22fdc5aa906d21a4b0fd782f0c960a4d6451ab209d3e5eef558c42392607d6a04129d4dd7158736ab4351b6f4537147e07e1f493e1c2c0408c5bd70e0c028e8e4f0ae635ef15addbfdced8919a1c2d8f6636b242f3c70a2aa2eb0e08301cbf67c1707a8ca6ed175b7f2adb4b6edd5012ebbb587009fbb1079691256bef0696224935da76912072a524a31314b7f7327f5905612a9f5c2a30f7dd2cb0dd7a2496c1fccbc9abcafee0f353f25c30539af8ff9e788ce92664dee57628abcda0f3f80aa133a6883c697c038cc7b2ab6a9abed8a5a1a684ff8ec84be754fe294c2c6b301113f63c856b925cb8b6d61cd48f2579bdece991fe1c519b206e061005eeb78856c68cd7e4c59d5450f2b69c906c2d4c89f8c369e02aaf07897de7ae6eac6b9fb28350267c43a2f3e1d6e2e1368377ca8d8f531c9b2230e3ef8da04b80e82b32699b9e5731118d5376316b9e38039d2af1748894c426e20b146a2086bcb7ca57d655f31c23c78363924b19a96b068e0f3d4571fc51792a3f79993610ee36a03361104f77705acd279168e6a75217471bf0feb3428dcca25b7fd369042e8506274e8c1571cc202b294d11731e72804808af8117b0ebea4ed10743b61f57e183d2deb29db1384a6af437632534fbb943902c47fa9bee978cdb1e6dce91c0f39a60238937c6f068701564929edcf952adf7af2d34e6b00910a693da4f776a4f59f0e249b323213ee82441b6362bf6a66fe9877f6fc38e36c0450b31ec3cc90a0133803d374d63aa34b35d87bebc8754990b046a42dc3fee87b400e9ebf4b2706010c68378f01e2f31d0f61e77535509bdcdd568c810177d3bbf5f40a673a919049e0b7e39873d7488a1f3187c76a6afeceef59d050bd0c50a58ffed8d847d201a64de7c6775f0dce5eb92e1a05e2be1b47dbd8edeb5c170d344c3802cb5ef38b6140e47c406406f9eb2982fc4156979b0e1b8fd1b01bbd9ebba4d9c72dfbc9443653a7cbdd79d9813b52342023fdfbc01d3c53e389e5f1d88299b0fda3ceff974f6eab67f2979e9df68c486169ffe52d84c519e88fdd435f88f379666982e6d4726b112195efd4a2560b9cac2f80e4e771d7b13f07999616bec2f89a0e77c4d63c88b4fbd94d12d6dd70dd9e64c2ea7f9607131055d546493c0797cf6c5c68f2798832085417796467291ec41240d1e611c595370f832af40ed417041c1c198cdc9b60c3ff2e4b36d0ea59a9f5e27826625ff2cebb51953b2f4369a2f8fb4bc2a733d43156f68c3df1e95e84e7f92524387e8a8c264d2bb01fde9ace2e497965d036746b8cefda6844acd467b8cdd57e483cfb3b09987efda1ccdab087f09434cfde158cad7c10f8dc11cb44825a57df699dfeb7ab5fe3305e2927f55aacc4ea2e5571c9b1c966c78e1aadb3f109bc2587dd3746ead8be160416d25c9628b5dceba1457bfd0716de4fdb903fc2854b1d39039b2099cc0d7f064d4d2c3ec507e996031375ea395a054071f769e3648718fd7c133b34fecf5aa145e06991449e8d27175b1252e25fd2a2b5eac20f5117f8090ca8dab533fd13ffd6b3886134495445413331be9713827a2a7747ce4ca71af6b9f714d494022e335731a81864b43762a29ebd0e89ad92bee1906f6fe793e33b943e42e5cf84a7827f62537ac96d70926ca9a276ed931c8c7d0347f7e4ce34b3f2200542d8fdde703dbed3033773868c43c8722a7402cd5d1c8b7167808b503065a8b26c949c7ee458a3ab9946fec265edb219930065b82dabfa82d3ac5d74ecb9ee51af842e0e362d516d8a9ac649d9b7ec71801a79918c2c99729e63021fd1d7df80ba5a8965d1c6ecdc04e04391e40fc748da4ec4f6b49cadce2b604a3d9e6aeb9c1fc0bdc0061b1882c7fa7948d25882c66bb16f60ddd085ba457c6adbcf419f1e4a0c2b38f659b2d7b8a74454c2f4d4017bcc0db60904e76a2f45aa8b2d010fcee8f0fdf2349b22d11f33cf13e39860976382d88764e3f243c2e5bd4b5e5918eb65243ee515ac2bcd6dedb6c944cb3009241fa27dd60db8094c29b936ccdc9a043a3c55cd94eb42f047dd46d3ab34e0411f103f7f2b7d40aa376c19121d73ca98fb13d63b71b16074cd7889c9d8e8eba7f9f5950adcb5472c059c007513dd3888726147538698b2e5bf4562ea7f0d123b6d04757d68244656131d91221a643f21cc9d6d3c7b37104c17cbbc0fb40929c7944293224f0bc56453d168643c9dc0dbd6c556cbf4abc5a5c1c8a465f9c8a4e5065fd8e202b0c5956791207ba982b995d0ebdf5939979543043b5c46b60b56499dc116b73c6f4a356c1913312b99f9e70a58ce21f628c28e0880efda0b9356195e3938b09e1d44865391c6803d725fc55ecf17441aec64993e1bafb9bc9a3cc26e53b254bb29b9d3106a92a60633683e339d5dc3569c211b0022840348c3c78c7a46ecadde6d772fd2a71ec10b11ebea53962339b5c358e8e48dd22a77f910a7d08814f9ae3cbffc0612406e7f09d9ed9acd29156b277ca797478a8bb7ac1189f5834d2705b51017236e98b1bc9ba79f876ec5f753fe2c995027eaafa69307101fec9ac2dfa4cf4d00163730c7e322f7ecc7c5b0374fbc3c65f64f13b2fa4533157c65741614bacb7a47be05bc9510d3536ed2feb563f7cb452d5189a4539af301806238c7f859094d77faf4658486e514a8a1fd32b731b7eb9a55cc8ed9c34212344537d94f76ed5ba3ef411bc10af41681a7d63cc67555d86ba44f9f2a8eb749788c823ff5e1a2ca0920f64ea43fabcc547ff673fad8be1c30d207fdd14721d68ba3fbb39c118b726a093d28d7705cdf3c8bb698b340070a035aaa8281375c999c7916bbd124a614b446d5c93a7fa0cf2ede626802d1b4b87950e009014dc0837c0b44d8f234956e503d68dcb1d67919973133a3bdfad146a6894664a094f9222c8056e65aee0403bc6b2e3b85c33d0466db6c8bf9d8a793203e1e61fca24429f720132444306b3c3e3ef519f605a7a249599756be5633f56d181612b4cc249c777c8de3424644d869d910cfeb3fcf8f8cd9bfb8961425017734ef4c5084ec6c1dc30a39015e48109a6255982454c51902272292860af0974c80a33a4f8195b78e4a8a5b169a8150e8ed2934aefd59e536be221d6a1f874572227fb07fd734d05506b6d4aec02b04e3ddeab8ff247ac3d6a2cf5083d3b7157b3a0b4e688b15bfe6f57919ff53880881950e175dadafef71d935535bc6763b1f599a77852c98c1823bdcb12fec041f7c0d1da07f103ae5536feb7cd0692b84c1184be467c6a7c1d8f8dd91753a6e50a4687f6595839625de569a5a58c64d7e2d4ca8b50e0ec3d3966fc47dda2544ae6e5fd3235728a9586e7fb92a10fdc56309adf8576cac1ef8a5e57059af4c3fcdbd9fbd5970f6d7706ee0b942422b879d6a6771f4a9bf4ed54b00d5dcff09f612e80f10808820ccbb49b92d1e3488eaa7a777245929e6c0f19d2d0e35c6ed30a1cfed2c563857504c66724f4b4839a50fd30021a1ff36f1e0c0694c525a69bc1dcf14b957cc95749ab98b32b5f060c3ff390a1ce55724a202859b875e80343528ab27fd4610cbdf85d8a6e5d5ba9ec7fe9f83eea49cb39ac752afd367c45de47feaee5821576e21abc7036c7fd42ba74f3644749cdf7a6af77c0dfb016d8ad18ce0db9a6fb012e6f9e78c9b213248b115d738ce23339d05a79ab73d6ec36fbe88f85cfdfca7c19fdadddb7e53b641d6bfadc219e70389dc8280a66747ee08a46c61336999428d92776aa3d322cf8addc2b3fdf22635db161b37807a92d349db688f65c80cbee89ca143f907eaddf921d3c1460f80c8efa10eccb1cf66497d4725743a674fb5577b43cd5ccf384942d98667125f274c54f7e7f620cea1d397781aba6239eed2ca3fd307bfc637d6061d25865f1456425671a31f5968518ff7ef57efb494ae7a11580096fb17a69d60a0f2c379753639d4ff9e1293a10b8428e2f6edbc4507195fbec5ef07255a35ac6c1a4c6bf0ed3ba954c3087f65b7c6b7755b501c350cd92568e37180ef099d77333ba5ae11d7a77de83b0e8a6d8e41398853ffd3a6cb34b3063c712fc7337dcc3b9b179e7fe5cde830d376b6301da1c5d76bd06dfdc6eb34553f632e3c4758a01313d24324da963e3b2301e6969fd1c938f19c1cd982a4560c80d2cda34ba75b704d52e50a54a055351c8d7645e3e3b9f8401b86817c4794ad6a6a4ff0e24cf6eb3f3cff622f5cc4bbebd33ea665aee80ac2a54565082ec2d5c4c8a0897e12ecf11e894a5d959cdd7fb20a939f6dc926cc8b6dae1b2582371ef31c000154fd6ea739f434a78d07cfb41e89d6fba3d838682b25352d99ecf3b2de76763b758dd812097c7fa00bc534108b7b27c9007be9ff4723f46126c5861a46c7f95391577e00bed72ddd06d98ecd238f4b94535a946090d232fdbdb4a999763a8ba33bc062e00963362ad73171d72c8c1f791226c7edafb9fc92ffe26c5792fd50ac8f92f2f6a5e84a464a5f880939871da5d09c1925209a3717496c3bd04072ebb44efe3844261fba02b84696ec546db46bf387bdbc69b5ef77f2eb145b4efd2eb4c3b5abcdba1602652527d81e621ef4f44eb5b50d24706047f49b29a6d31f42d7188b5953c9c30bd9e0bf017290127f531f031412ccc8b572760445b7aa00ff2008d43bdd956b8a06cc4b1aee4a0ef77021832b09d7852978e6b5a155cea65f58018c94e965d0f95fcdb150991d39dbc31556c326b60d387a99eb19f461df43814435fdb7ce110a1e5bf898aea766759a3b6b303ea1b0c2f992434735267ca210eac5c6a74d0edb9a558a5ab596f35b631bea7e0508dfad1da2682bd5cca1473f7ac6e4ecf7adb9467841f3ffdc651d44ba14ebc08733de3d5c87177b4d9236543c9f60a546be7071a9bd8bcce0435e1b94d13816daaae4cc2f6067ea9dc93edb02c3e1b998fcc8c8dac20f80fe246b7adec4e5abe4f9da5ee2694d21b400a626775955146d34875e40a019696e854ddabac78df2aaf2cd2c2b0b2a2daa1f0f844dbbf88d0ba78e034837b4614d29ce9b6fa58a728fe14ba8816899776abaa8733040d8ff12e6d06f8eb34243f1cdb776e54e140058100e0917188d69d4d65704e8978bbbd95b707d5e585bcd6c6e09bfaf2b89dcc2ebd1bd4b7756e6646aae1731c80a94767c2357ad96a683b3f5902eadee9e32e0b3e34265d526a716bca473f1f5353a1473e573251f1c102cb8ec0f3014a11493f37b6e0caf65b70342a51f5b2a1ed79a55b52ec89fe7debce65b0fce3f815f635e90583c12fcb9e4175a1fe40adb62d2644cf4c45d5b24fe3453340459d401609b47a0cca40ebbb129bf550c7826b17d0b6813aae55ebbeb4183aa5d9cd1153605db700f23e0e90196cdb6dc0df02778701d1b5be36ba413ba74572bbef4406a8e5a78653a3cbdd2c4cddd3cf4dbfc3d643a78b781b9c12e4cb1d4f14f25a9f18af73153769517f193dadb378e7b17a735c1869f16284e78ee05544451c0d67b9b05337685f93e120adbfbd5822a93f9a5e5fe3fcda96794978e87ad0252e1390341c716be5c684be55d0f57c5baa56b5a6ac6879bfe29d35b2c8104a9dd23cab1d3ac5c753428d80dc1ffd671ac07f3aad1cd05fab5c422c6c3854017746d240fe34fdc1fa664a25078962a9684b2a34b3f9dad54e35f0ad89fa1877975ea3797c9a3261e7d6e71af3c2c0d5d76a4e84f876335905abdf6b31c152127174a03b7ccb33c036530a57d44fdf3d71b31c50524af938fda99891875a6b8e61c5a8de9d33fd2373cdc6cf4b77dee54761ca3b25952490a70519d5696eb2d95e370ee4d12ca6d004b0d4430fb6737c7bd236941fe447567d7a70b6860b8b643c91cd192331813720829ab058a6c062b0422a4c40affd04d0df9241f4d928f4d29bdeefe893d140a81d7ddeddbda1163b477480c2e64da238d7a2c701becc44f842a0e8f353ce103c69b7c528f6fb1971d5831e4fd16f260a33ce0f696758480536ac8d404175b49ec0bd15ec5a219c2a4cad64dfc0a5e5b43724a5909f5cad39aa76c3771cb5cc30025545599faee24ccbbed8fd105aee58fa388e130eec0691bb6aecdc8d6ab0248e68cc40c50a39d6197409d0f8f0b8a66d4ba500b1922be6b98b7008cbfbfa58807d668e368ca51c39e1c236aaf9a8b7bce584e1292cd5d373c699d1f935ce65b72c2451541708382c230bd6ca1c804c326d3a097a5b219c089cda6910bd7963a8bbe7c8d05fe62149ce032b6f2c7755ee3f09399e7b4e27510aa039b370ccc93131c51293f68fcbe9bc1393ac6ad09f15362752fb0e021e5b33030744779801da40e168873a5e124014172038217fa44894c514a03f2830bf53bccf0d17c9de94e22fc370500da7a72a76f244886e38cb9ee288568814640674effb1884fb0e267edb7ccde2bbc96f4029c213c45145662675519197dc46a9fe7988cc0c7e9eb6223317905e45fcbb80e9aab80a9bfee041f2a47d4d4d6c091d41cc64796a3ee6939b9ae84b3eac0e0bc081a40702231b1a6bf415705173cd1adf2c14888f1d6cb24b470b0e9d6859fcd512509dde888093ece14d96c332178ab4afae4e7a2c0f6e8cc588e72af9fc2f5ee17ab2cde023649ceaa199fc132fc350add6e094dd0552fdac3177c87caa8f6feb36edce170b5c6540d9800877c94d279484135313b2af51a4510d289fa804936fb06f747400fc5e5a4a3c9476ed6312250d56702af14bb8b11eb6e1866d12d37282b8b7edcf83ea94883f7d6c4af88d72ee39664ed490a01989252937a2a3777bc2280b5f3fd0fb54d31625b36f8eee5894485b5a450564d1e22e38a48df1a2392accda0db842a03cc293552d72f00e64102250ccadc4d02340aab4f7e3ea28647f2cfa54f962690aedc88fe06dd3a338bd44419654249559a0261f8085e8a423aa7802d66fe089394dd33306adf7a7a16e8bf997f7b6b962a55c0188006e5f7f8f1e107a1dd0a3647c0829dc23216a64925b9a3ff7d79e5123832a685f8c712beba8d052e44fab2b76c522f10513303748228b65e30751655c9cf1a56a35cec7c2b9bcd5e4886dc79eea40715f17d626ab249ab79d75e97e54c1c159bab6e23280a28a63467b394fea24400d4fc732b77dcb31eac374717aba5b327f39a0b27064aedbcb879e6904da30c3d33cdc5c504648d649fedb78cb5450026b448e0e5d13060a10cd349ca3c2ba11339a3df2e69530dd233a8311fe2b6d0d14e700963f03b8f10f9b743e24824cd7299bd1adb8c77f266aae65e924dab0003bd78c3f4c04e32afe36c637ed3876499253e750f864f3267d8558dae533ef722d36b7dd76a2727a383f31f32f642576a8e0ddeed838bbb23bc4276efaa90083bec6801128fbaa4e67d9805704f36fdd731dfe43a31730147976c0c67bf3bfe6106b7254509b4611f41da32b0fead8817eac5ff14f7eea582937553598309e3b15414ddddf8e73df2f7ccd68adb9ce199ca46143a24cc09ff7d5ab28eecf32063d8586a2b0650f8ad4f3d77e7791aac96da5df77086d693431","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
