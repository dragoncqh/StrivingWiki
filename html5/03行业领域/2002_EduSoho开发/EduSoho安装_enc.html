<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cec61c6e482eeb52feaf01f8f6a81df0a4325a45477b105795632805cdcdf4193bcc0ac301c2262936fd4f3f077535a337913bcbb43a9bb827786dc59879d84efa6166ad43db9dfdd8c5cc6e089cbb111c4e06dc0eb4d1751f01d0773411bcfc4ccbb4bf677a574231c0271eac576a6eef1036be86323e012ab27c9d790f1963726ff24e747c0feccb7cf671662d7c7aaa01f24f85399d0c158428975d37ddf2caba16d27d60993a6912d26243864351ef1fd1d47c439b73cb37fff513949e5df65d83a44a7899f17b3bce29563555a0250e19b6f55120f706fcdfd401ce7f1ad07051a6504ace1800af93059d6116d9dccccffdb1b15e113b997850a60ccbdd925e9ac872657e31b0821d271d67b97885d978101fd75f6619a1d13d11c6760f39ee8115a20f4ea2bcd25ac0607a6eae985e80fdd9e3f0121c96d63942b57e4d926ee40033bfcfbaffa39e0134d82721dbf0095b7f73cef546ebe1bd28b3c4d30694d6cca39528ef3af6b69c1ddc8764a4586fe4ac45a6fc050404763ff8e31fde577ed240a0e5f6f30d62bd97ca8375b4dfbde9b03999fb0a03d08dba57936ecc2c6a5eb3b257433697d5a409f9251f3fc2762398cb4614190a82161e242fcdcbb7567081d76c63ebed1370ecd868e9dc01d396bab97b735983e87ef4da45120e9edca9ea58c383a0f73edaa550aa1494ecaeeedc3d405ef23538e0e29b274d8b23f9632fced7d79ed0ae0bffd2266ccd9e3d185d50d9dc3c96f5bd360e49a75c85e447dce4a14e225de95ea0f61e80b56dfe99365f9cc304668be12b7de3d75a8cf1241dd883e9733f6354a7f894ed2fe5989d4674309c12ce81d7a6676353416ab0bef1345d8f57cd2178d8ced515a4117fc5bc06ef8284f760331d75045cf95cd48429c16a79d71c0e56d726c13fc9d910e50d81bdf92f9b5f8d4b9316ac374eb577dfdec863bb3cafedbea4b9fcf4226ccfc14d1f929a2eb5c9905cafa8c94a3f04cb003ff7ba5a4a22b0ddc6d5b3cc352814ac7c6f0d1f233427e82c60aa836abdec4ae591380fb2a7d8a6872f4e7630c596f560c03453c7411e1fc2f222b957623da350de704f1c1a51c15d4bbf09dac2a8628e4d55b10fe63ba350f7c2b953db245d6ed289b8059fe18d8a5564ba7b1d63117b65007e66320b9f00d523c052c21b365e56db7ccca0e7fd4c4511574030146c690157957ab0f1bcb0f5a4a5b20d11ac02603e3db2a245fbe013376fe0bbe0a3e11feedb8463d09884634da2aa0dbc71383b9cf9aceb591a1e535967636d2a5629303d2e55124d3bdb92278250ad96f1be3a29330baeb0eccba3dedd8913f9757539b7faeca8de7fd9a376d08f51b1794a436d70173200088b4f1b8284f6b6fe40f0d14eb3d620f034681cdc1ff41c5e8a77ee4dd91ec76160c5659158fd394cfa142a824518c2a55afecf073fc2396406d6fded9b3d90dfe7677d6c439d4bdd3d5e970ae95b8d9aca551960b1f6e742545ab133d060439309a18bb1f5c5a5dfb141567a9b0e3d8a4d2952c6d5bb986273f0b0830a5e632215026dd790f781bd037e76e29d4857d57eb0b265c765359a0ea5bf970f1c88c589ae9be3948e348a61ba98f3fad41d1ddf5b5e03d0e18a361ba421085012606ac57179bb1ee4e330e7f42e6e00861450f5f6fb3dd883793ca985de761543ab7fd0ccdb86305b2832f7dc2f9b23fdd9dd27f61eff4b24d3d477d5fe8fdf5600a63077d260d4419b65a8451972ddc18bc4ec03059dced96d209ff61cd23ab0c509bdce1a97e2290378fc944edbd6b915391ef321b2fa0c6c9a94bfdfee3ec880ad6bf2c3bf4a5888ae893e00d15717c1090a926f57e2fafae7548b0a8961976a4af8a5bb442b129bc36970d1a21e25fce7fdabe9b940808068e8a34efec3dd64ea511fce8be28c08cece113a87e81fabe41ed117f2cbbb07b8e4eccce4cc1fdf76280efd8bd0415f6663882d93f71cfe6e218c1c1c5e08ba060d6e5275fdb075e02165824090d840abbb1607986d4478c95a055c391b4b20c3f77074b69072612c53cea0780a95ebc2d6fdd8a95bf46a45e65e2857c3914c690558a49b067f670f3c1d22ef2fcb42fb74f4161fd47aa9c818a142997eb8069eb154503667796c436262847163052b3e4e6935ba031ec9a1a48a5698ff62c57b0785eec638bfc645034d64f07fcb9e1a860d923802d270505ff42c16fd479f4a73c152fd247abb4bee3418a9de35eaa785444988454f91a624637d76d8b5fa04057539ff8ffd39f887b071762ef59096e6ae65be004adf8f399692232702ababea2372d0c58ef77c8131675ac1ca3cbb568f4e0eb148a3f3d5df92c2bf0b7f693a6d795fe78c09ad17b607848a4eb020b9583f6fa9461dbd071ce338ad7a2d7defed0c15683704d2614e2a5c34bbd417fe2e78bc6aa53d92a5ed2c3eb71e44cc83cf24a5ff6e987abb64672972e265cc25fbd12d93a31c6923ad9a5fd6e43847f71978c26ae92db1dbecd6c6bf684291315ebc4736436ca022691deb2db74d8595212efbf47c877ffa25e00ed215082c660f3addf23fe2722972fea0b015e2729003ae4309773b6128e1f4d5e989c3d8c0dccfecd0c90c74d8a0d123ddf4fab273c49c064b2bba5c3d424136788e3d2501e880e00b469210316e8910c978d4348523289b76280b7570644e940074d2d67d41002c3bd4a0ee68bbdd9f3d18ccdc0e766e126a0db50d76a2db8a036d3d0287811d84b6c5aca697f22c479f97b9089093c27f3a746e54657431cf3ad366c4c9c8dcd307cf335b806f6976c2be9dbc6df7bc9d8da5be976e1584777facbc9fe84225e968da040d941eb9750d11f62688b1f3611dc4c91e7099a3eeab046d2dac633b97417460685f4a591d1c04b6aec30e4f51ed4be929521f64117624e2adaef2b624640ba9748ea9765a5c80d90c2101947be85dc454f8b3834e03297b3daa2b8673b7bfb1a1842919526021a992e76e6239b464fbf70e1192b744c8d78cb8eb1c2faf489699c0d711ffc1563f51d56c42f8fbd14806b23dc2d7076dcaa2180dc7df4f2b81904ddd7e7a8aed3ca37d32cba2336fc306133b74047f1b222167f04ffb038117de090aae90ed4ca616e12955b60895ffa8dd7294e6d745b0ff098bfa5bde1a12ede8bc3c56e53ffb8d4caeeec1287719ca8b7449d31d3577ee4d9c0b6f8e346398ee16bc463dca78c231fda548495065669a78e8eb267088a57f7d6d6f520674e607f7a42b483b522bb19403ef781fea5037993e733ba79e710a840b8d2a41fc18440c0f14117b49fe852d3307c5281312e84fa92d3c3671cd9fcabec06617eaa7819a6d35b14225f5d24c6d98c8e677fecc061d37bed131c923362a6e923b591551a8be21334196ca476553c71334cf25bf8b19fe69ec0d37f18ced6e699a46a58ecb38e169ccd2e9d7cc25a1d5225be47a3339b82b8b5dda032a55849da5a79252077729100b6f17ebc6c75891a65fff77792c3b1369905420ea879226dc92657276254d74643fb015ac35d46bb9ce0758a6d8bc8c551905fedce1c0e7b49b1c4d2b3191d2801b4e5296187b46fbeae2f72bc7b96497a157df9d709738bd094410d6aebd04de8e763d82516b50172a323a6582c25294d85bcfc95aad754b3769c79b80470b9e8221ba6ad7ee6f56b793e0ec9ef453608f978dcfd69a5e38aac729764656c38714da0ff340b7121f1011bc749cd23a22e0e19b227ab91688b39d69bf9f871b2f73e52fbf799615c89ee5abcacab97991541b312bea6466ffe4aaea6d739a4d9dc5eba0a2dd92f2289888cb3f256c18e8acfaad13afeff523346218e6dade5033193007dae9d95899645b1b2b146e2430025080f96408120cca02b3cf19366414ca48a8b5fe5769066cfac3b96cacebd6008ae755772e890e3ee2e5d8bd8be835c7419e57d06b317a97a13247dd04519e0ea82b78b9371104b850934a5d911406dc99dcaf9a2fcc779f5ec8bf2f2a860bbabec90da42a48afdd7fdb7d5dfe6a7712e9bcbd254f3ec6035d00eeb0f3a9ff188c98bb2d422cad7f7434d4649c898b781381d8561e3be0c77fcfcbb8afb72077f390d98d401cc0f2b75c670f2d65a7137f9565cb233a56cec613e0833fd000b4e7300cc8ad6874c7a48558912c8023b75d3e422cf793ce822224e33683d466b959da13f8f8c2ee0f92c63196be1dd03efe593c23baf0aa21f62163be6839eca71437951bd7bd18a5a6989b34a6f868c439172d98603bf8633cdbcfce6f3b22a590d0e22fd946aa193982b25bf94ae0b7552fef7c46379101a3c4f9436d7a8c24bdc3999b8f61020bbc3423d042e41dbe5274272a81ab5fc5936cff5cc80a09802cd4f729acce71f2d8a8ec8ce2c5bc82829a336244bd9114f15480f133e16518f6254419e198489f3f457d7398c4e04ea94454437ec0b09b197c622bcb701dd304c172522d339982e123ececf2c80f02eb56ddf31c8061a0660dc6804056738cb571ee91b8403c0e8ecc7c2bbd8258b221180866059467a1dfc6e5f8432b6e869064e5971ea1786094e6143e286c37c7f52a024b49aa742060c8de435c5b223e18db507978415fbc7cc1ce25b1e16dd886a2cb297d9f2658d06752fe0c2a13b135355428dd96af8d32942935d7732482ba7dd56744c61213ff8e9e40473063da95c45bbe72bab33df23866fd0609d96146d0e113078678442ad6fd5a6e5ac65ce84d7208da65a728ae72f220a6cc15bbf3323c8deb259298984f46180a74cc807c4d86ab62f51ffbecdaaf0f0a3c8ba51ae0d33dc1ccb82cd02085ba50fb524d8c4a7371762449ade771f9cb77735169638e270001fd2ee2d638d268b068ddbe5d34632dbee7f309547cd64b248f1986a2f2e68b0720b1cac06d9e306e69393ab607c1750c94ad2a40684a7f44eca9c9a1b8efc909e785d6e3ce563ffca98024fd4b2e02a50de6950de048ca390b1f1daa465e065ed834a799569b459ed9556da26f24760b85c494bb645bed60b926620f15e8f07fef9cd4a4fbd057aa221b7d86d61b96ffba5f29c2f3cb483af5f3cd2f0af7b44723ceb9e9c4408535f63467926fe4cbb7b8d158e0c9264aac3049bfe62487fc529c1cfc61a31ed42b8d8b51bc21a21e02fcee72f2912cc6c0dca69690738beb71ea571d3b5d5131d8cfa51c51e69837bd076ce5eb66c6ed5fb83fd93c2a953bcd93338099da6036bc1ea6d08b22ec3a861429bde7dd0b085c889f8fae85aeeb80e1808ee6897a5ab269b45f958ea7a95c451f7a12639c8a89c41550eefd6ef386c76cbb5d7d120d33b4724ced0a30bfc1edbfc2583e900dcf27b3fb6ef2a0dfa24027b612eacec407812b9b5bc4777fb0a19776160d82d98f6185d1152221a17299af46c0408b47b62ecca80d1c657b83d5ba38c60259aaab43c08b12f518009d2aa51289ffd944db62c9d8596b2c90f0894fca25335efc547e031108e3745fd92a7ddec46f8e19029d184221964d667bdcfc429303a8fadc367f5465eaf5998adc04349eabc3c90745a56bc64e15b053e5adc7a4115422a3f00d31ea627a471b54e76e851c6dc59b6c947b3d822e1aed52401a04bfd917423b56f9b338a31e44280fb8685bd042a4116e662584e9d2917f6d2c5daaba294c34b8c5db997391721c915ed1e15882799c635d563cedda97e79c16502912ac4ff44fd2a2c6497aac69c101a643e61d730b9bff4d4908067bc5767ad075420d7aa96119e30456885683a12f10966e558ec35046856080b9245836bb0c80e62c944e133cd9270380dc7b10f696a9a1d5773907a20ef110672f5ee2ba63e8f6c66ac4af012426062ea4ac412c71b9db2ae93283f3309d1cb5fdd84f0be9f884e59107386f04a6fe214460290baf76f453611a3354c7c56a1fbb34183249864174773f369c7a23554f7e2bf6e7f3f935d4ef1ca01a3af0092813d861ab58bbe6160fe0883166094fc16233746ee58243b31784f85e08ec8aa597544b19e247fd15f1acf54cccba7432c5ee0ced0b79620b90b5f725d0a1e69104375b39cebd43c16c0bef7c04cd05c65f9ae08e5b455d7a9aa84177eef2a2e98d27d68d6878dca1c26a3a6668d510c308e801ed7ccb36b63dbbdecd02494051f818ad277787bcef1b19a7013483c8038b815975df79d1e363c978230c1dfd901e90d459478d16546a76e9e73b37da0e5903b782a76ef74315d1641fe125960e6644a0a45b444f0a95fff29e51b3ad517ec1f0d102e194d21a0f3b036194bcf30ba752860a1a02cd433ed1e473fd2b64cea2be450369464790c6a1b93925a6f2ca5658a6312a8578d3786cf980e0ab89e2cd32df27c01327be32e0806b6c51ab924534e5640225017516c79ee582dcf5d0ca7b85a7f31c22ce43bbd8c2df13e66e74382a17294cff870cece9bfe17d95ff728dc8a8b8890e943863466c53762ca1bc74228ee71fa636a785363bd31594d34580198e9491991ba51eccdd671941fcf109c7f1b3336586bc5306397ca8f0dff649abb513149f80e09228e6ea1edad5e91b500e60d279fd3b4a27d2768c390a9fe66cda5208b9f8c3aa7881fe856abdcf507c9551ae945a9595545e4069081f3e569ad1096c13a088c5ffac2074e861ccaf8e7b9f1b8a5135312199582c8e037fd265463e86c17f9515e88691f535ef6c3d0b490795a5306285edcfa787b5c9ad84777dbc8c358021c3f04069eaa751b288cf87287977aa16af9faffb92778f94bac26b8e41918d6dbf8d30a0a08d569764f97b9dd54aa2e9e191bf615b9b936cf98469c86c6130407fff0eb4065c14d0aa64f29b476d88f65c7f6f46b9689e9ef9040a39d8efa64fc7c5e0a2a154d0197d1b69d902dfbcea730e62bdc66a4e1b0e8da2f4efddf461fdee7f32edcc973fb1d07d92a4d68b96c8d0dec6269836a5539b06e7da4a629640133c65436e404d88dc8e37bf1711452428dc255488a3d7191f1e3f8835292e4722b9f9db2613614aa57a4ef34aa9cbbcb65272879b621881147e09ff1ff21ef643990dd6e965984e53c61914b59fa4bded367efcbc4fbdc6de619e20a5b65af14ca049239698d9f2a3d722a4e3125bee8894ef9620ba08dd986da441ef04893bdc93da4b753a4f32d84955e7c669147750f51bf4f65c5a1cff0e0c6e3bb7c61ee75921c639be86738fbda7328fb77a7c892a53d325675c1864664f9b0bbc781a37f26d4cc8440ce5ae01f96730df9881c4d9d181f0918ca7a24789337bbe2bc2e357ff9e743425aac2634b1328c2c99877405168d25992ebd1b02781c069428d0628d7ec4168c1bfc5976ad44a3f2d2dd5ffae9f37279a5e828683ce9cb85e3ece8650040c576adad687212b97ca2fa20b4aaac74884a22a1a4e8454d12e8d6213d606440a4e85272b7c68a33d1ee272a38fc9ab93dd85b291ec5c8ba041cb0a73b0f2d1564f52af6d9ce0b4784ae800899f2aa0350a5a444f34faf1ccef5507ff5991c02b20d8e7dd034f26e72ffa1cc3a5e0ad3f70874d7b717ec1066f6dc7a652858de5afb657ce77a84543150f5dff9fad9656e996bb9594c6ab96aa709c9637f542a3ce1dfb7d1e68a34d6339c8510465f338b03215bd6e37bd1fdb8d572c1dfabaa2d1763ae7e144c3d2a7bfee687db293f34be33fa4c3224492ac8d79b1adf1f44d159b04cbc3c0f998f774fc62d63b87fc5b290086f13b93526ae5ecd177541fa8ea5eb32003bcd5b4507c2633601526d37183dd1f66536c71f3c31245532afe32485bfa72af0c3167687bae333b609af16bf39483c80c66691fcf9c8c5c7ad81b8f68a01c971da30e856d608f13549883357ac7185a4fd67df5471fa267d8d3ff21b7367e81fdb83de258c2461fbd29cd472c47dcc63226d86dcf7c0ff9f5884c870621db6f59af4ce68d1e5fff5ae941c55581b88acff2c9ec19754e1930c3afd6583b49d05b1b44cb0d6822915cfea8db80ec2bd975738326fae2e5b99031dafccd894e3c1c98b4633c5333b5c5053c978565cb32f29e2647c52668cb58e6890a942c02f6b3ee268528622a1087cf35a9ec4d048eab7111b71bed6eb6d39bc4f6c9598dab7a8de2a48efda77682579cee97237547b0c30ec567337cdf78993bc6c725ce40b0dc2eee026837eda1e6c869a5d1c172dc8b27dd35059c464b8ae696b11b87e4083d6a8af364bd6b271bc4ef8caf86d5f876c90d2a15ccecff192726916b216da27d783d70ceeea55fa3d2a556304aa8806770c593d27d5e2f3740e328791769645c9b4f0e0f9f326aa3bb07558a344fd7b38a030c5a43bfc1d602932ae32148f570e09925fc54311fe0e88c5a117a7eb7a820cf24ba9e1b18352c360ebb1df17f3e4606eac8613450e173c3e3629fb64b064f23042a90ebeb258051f3018d0683357cb073e127dcfc96444a56eb62ea66dd235571332a3b9d99af72e0d9dff98e07ae30ced5e6c64777b985792f664091b9b72f30c3336856b2172383a4b4ccb522249ef41dca69803437876c4036a4c60cc85d8ddb1194bca1aa300a89f77582aa21b75926281c5391c9247d6ca18d01e66edad1876f800130a4e1d854b12271d9139a2c6c0a61e0ca0abe9b54c3ae08150fd0e057b776e279cbb105a2474281f709832723073af252bd47303fa7f7ceb3229d5135f48ab17d4dc86cac7eaa18dacf34e39aba7c3ec51a3b919ad2138f9f91ad4dde98eab71ddfe6130f66a78cd419888e759939b931f7700e80f058c4dbe05a472ed78ade812f6c55e0f409f088d4be40db68df9c849632c398b9fe62f9866264ba0acf93997300b3b43fcbb6831519d00dcd26b64026e06df7dc25d01a97cea83b5aa877616af68336a7a2a9268dae14271ead1af02759646a5c977cd6a4362e555f13c83d467cfb81a152394cfa237b6697791d50aaac06559937bcf41b1f87bd2c183c5cea4f0aef66ef99d559870f17049082e4d78bd4c45a7943b1c66645e7a2cf21c54456ebab05f5707640942c861296f6bdc6172a0478838c55613d11d0df48c8f2401adc9c50febfefc28ee93217f8e45a458818dcf47c27bdb5268bfd2fd7ae53ff1b0d41abdb571a7d3bcaa226f94a0c55c15f4254cb23f334a8be7a41c0cdd3a6f339218de563bcfac830081891e640f813a46189e5391c2eeb64a7506921cf5ab131cf5d7941023211cd3d4d75788e50078b2d30f67d7a522bf13cece31eeae9d6e343f5d456eb9d58e99821ecd6b9714bfe744186f49ae0f4805dd8f512824e03746ddf5ad300c9a8c0b8570082969f70525d3603d6c91d655dfae8e60c5164815a8754e54179e6e716a8d5f9e8a7ed0b6df88f9f4861dd17ab786e63e4f0779616c268a30f9f89b466187b7863d9ba3eb0f461af13ab3903493b4d77399c8697211883a8a8605bc4c1f13f7b98683c1c56569b60bdadc3f865fe88b16f45e4eddf351df44d2a7f1f6a41445ac995df518374e2e30b9e1c8c3fb24ebe333e5181c4bdea0b6d647d74ed008b66eae263e5c5305daa1abb799b1e6293e6fa91b8a9038089dba7f1828b820904c7bbf43d0eb665d5056442788649c39bb6d75ff11e0df836d1e3e2169cc29ce0ea495ded0677fc7f2530520e94d48896171dbaf045a94b04fc49f39349740705e2bf629caba131270d1fc78a305ce46ff7c4bba92367a2976ee92402fe69fe3c11108b3decb3a95c98658f8597f46e587fc0b1212120c33ac27cfd55ec893e788b110bbc65aa8bad41b78cb4e90312325ad6d59b20d696b3b30459a9203b34ac8a3ef9e035456739c962853683b7e0f0893c0e4a8781b309c941e77837420ce160d582205970e505d8695c8746d152f3e6fa666a1d8fe804bacffac210e069f1f5c00a21ab93a5fc778b0268300bd3495808121389977a58c3da763bc2c09646b475056d19d655e7bf3a562a40e3d7b6cd6c4d2335c736ba45f394c6ecd11da1507a25bc89440a2c193d3aa442528adef8136fdbc835785be1cef559469d84c7dc469c9c29b763d44dc19ca2221ab5d07cad2dea1e0b2ee313f24040269eee28d39813863eca0d4e8a6597109bd64d683d0d0ed569e1a82407873a7e6fc3bda78f16d057f57a65b8a2c3a09979eefcf4f3db3d191bced765fd42b87387625fba9d5cfa780cdc0ca5ee3f98ff59242675fdd8ba705f64c49b3b943fb63a50d3fdbde7e8866b8ced4688c2d1e8de5b28fe01953c4831678b702ed57c4d23b34b7ba79fba8e2206a66b9b5ca5852a20d27571e718674b09f7f8fa4214a0f641f2386fb9bf298b275764031df85c61cccb437c69d51fdbb9edccf01fb2944b76d8f3a37c8d2101b0048ee22b4cb1eda451de88aaea1782fe74136384bf642983279bd2d8f6fb920535369e3ef0ce6fa3bba92bfa4f800f70b9f2ca68565802a9c941bd091db1d2475f4f6939e6b7ae0f3e54b1d6b20782faea328690ee30790cf7011ef45acbd39ac89eff7778fa1338953fa6c900ba1b6aac0a6610560b96cad34013c8bd85c09760e8b17269660b6fcb8f21178b4e1955fc8dd911b3ac5d08efd417a6faa17c9b27631f8b056abdbf8dc69b7d53de7255c56d2bf06eb202ac190b0d7f68db2d574fe107bf22e0eba1b4bac8a920859dcf8df3ce37e9ed73a8d39ba9ebe1c9ff6a86369be17d957e53d01d9f3c8d62b5387632119aed676a140e68c577158cd97c9775a5dbe1133c97bc7d458861614ac2773353d7421bc1d3bcf4c220b3bc77c57ffbbe907b1c2de63067fcb3637a167718402060e67b7b5a9774691d779f8425d720d1efb9fbfabcee25b3f4963054065303f63935f174f617f81d32526d39f673782131ff4bc48c70e96e64e79bb7843f3ccd967366a282ea7c7c84c2d8e3a674c8377906d96e6c21c45c0505c5bb98a8198d7833186550a3f0186ccad5fc173e5d23168cc33b8c826f7b9a423c73edaee011b53bcdf5c32c5afe6e570af7552d006d4de8e9aa0a20a4196e3eba2515a957391def8e9447c8247c7c97ea737a310c532f6579915688b7fe384e7e6f511e07b796041307cd9fff15c29d5d54f14353de20541453a5591518a45a10a420a05aedbd116ebea1ab7aef3b96216573030862a71f7d2ba849ab9d39fac875387765faf46550193a9df5e2111c1ccd217d5176707af1f0ae28e0b8aa67601f5281f3cd4919ae1e458d1db95d5c341a219e1c7c0adde993fcdb9c5cab4b3a921c8c1d5266f9d6beb4d36cd9a22cdcaa327179d5f58fd2e47ecd0c81e52d9ea6513bd96e42cf6cee7b37b82378132e5cd06539370fa62ab254f234b6d35b5a2fdcc4ecf15f576b38413638ca02a2366e259018e1528543b39c40669430d837306ec63a7ee8a8aca26952c89c02b2e7eb123fefd7b071f278efdf8bd1b37e95ca43f567f04adf985877f345efacb54038c3dfbd738d59171ed1b1224acfe8a5f6eb4d4140ded2cb67440d056112364713274e3df531a84d11bf96c3b371850d8c383d86138550cec46ba9c0ebf85439fc48cea9bf6390bdb3d90cf3ed97d3ae3124aaf57a63d19f4aa3ae06fad0b7ef2b20b8b9ab3ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
