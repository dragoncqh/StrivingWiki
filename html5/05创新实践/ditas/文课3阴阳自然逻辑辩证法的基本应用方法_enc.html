<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6027a4d629a7d02a773096bc4234fba1daca9ee0fd9448dd05a7361037640fe38b726fabcb4cef8acade45a876ef23f9040ea5764b0edf7e7d6696cbd4764c7e512a33ce836545716d838c313dc10b653041cbc390eedfdbb5c98242964fdf707fb1168710a688b6473b042bb1c5da19871a89750438bf5a88d1f3e5bd8089039bda87e46b78b7aacde86d8ae70ce827fd62325d3b9e06d062bedd9652971ee7251d51d3d144cea932918b7ee1f7c87401f46d60913dc44befe2fca450d6d675d7bcfa3806a267adffcc5b17cbaf5f2d3ac3665bd35d32c71c2d04bed17c83746cd5228622396ad603f964ebdef59179c9565fb9070b8c797f5904fdc77827cd9448441cc5ddd0a599dcdd20e6eb57a43fc7bf0f9a893b1e615aa21e2b36149c5029a7213ad5ca34d39872685936049a0686e4d8a3259d9e625a1e284a35b76ea45fbc64c08ef898365eeebacc9db9767a124b4d55bd33ba0e91f68bc13b28a407a1a36c275dbaf40634b7ebcd2df3fe7d0c8e92b7fec0886f771b5d3bd7625b3d896b2ff98cea95f1127d9efa6ecf3ec25e903d2322edf0d0b1aca37958e6ddff40728968ee2eaa3df4e6e7f3badf6df9585215f0c35dcc9ca0a25e24039bafe93aaf3665f9234a09a0be742f1ffeba11b6e0ff1a039fbcedccaaa70efcb90bd910f494aadabb3a31b205e0f69f1ed481ea263bb3479ad0b26069c1c64ec97b7c1ef9f6b7cc81d05e3e9d33f1d4a755e4fab68061426704dbe9c7c78f8fa48790eea61e08d16a9320f3cdf259de9aceb53eb916ecc25a1f14214f1de97ea0eb377bd2a59d390ad99575a1db3f1c025a10840e2b33e952ce6160ca12267deda23a0f2295a288997fcb831c5cdb16cc7a2f0d1b64161515ac65070f152a6239297ebddb699fa9fd611b0dd5dfef0fd9ca869293630639a0d2a7f8a72ba4fc00558a802b614a476d738eb364be54a9b4d4f6d747de8abca7601dfb2a058a0c34774d1d77394d40932ff62a92c2d41dc6d5326669edc4dfedf392fc46c5eb2a55ab727a947994f42f9e3730820bdf7124753cfcd2f964a5581d604b78033a23a3448845133ea04ad9266b8638d73dc36363d7f54de5332dcad9708505ab7aa0e1716426c949e5602cf68c89846d54baeaf705c2f8addfc0edbec9742997887c943a616dcdd56b1dec427ddd1ae042bfc152516a2797e438b107413882de1c228b0225be524a2d640c4861cb6587685b54bb110920efcb46f4b7f829138bb75c8945714cc33a46bf622fb5f224f910afc900ee92e88995237fd4a54e3c4f864b5332e2b03b041e4354041a1c4a27d85c28ad11c6b58ba260aea09eeafafa1ead52a446e587b076099dc1bd7f00e1404ca52055088264f02f9f5c7e38b8248700381dfd1bbd1067f94b3480c8e021b103932c2d0b3baf4dbc9f642c5b2b5b4c7f44974d0423832fb322cc4f5549d2c428624f92c8309642071ea17382e4013eefc3fbde1ca15414ce6fe885c6d398546d216149640bfb7cc11a74ffbc04d224acba64aee457e13ed0226dada302d311a0a75a321ff9424f9a84cc644d15627f1be13764d83be92a7b7ffd9df682486902d7dcbca2cefa059633564c6870f9ad8f0a232554f406848a1d2c3c1a96a3f9bfbc90a2f8c307295069a5619ba43214f62ef4ae8f23b0e587e78c8b389f88d554cc9630670d2e0b7a6fd14c12691eb88f00a24dd17f8a0e33e3aa4ff97c59f3abec96a56763098505ecacb97e977b4b242cffefb63d1a596c7ff209295813f83378199bc719044e4b8baa1b6cf970d88df68b5f329832ec068b1523f68113ca7af22f7ecc56357961fe2fd14d1afc62d4fba74670a1d3261c68774604d4058d1e20069eadbbf99703567e5c25f5d869cfeb435b5f9fb69e65ad2cc428ef212ef49273aeebc2d202295ebc5fb1d7af56cc95f35792affcfc4abd8b1cbf4b458b18bde538935d9945bebbcfac672b0b38fb35c8aaa3f690bef020b4eb1bf5ef49afd5f76898bbb1844b39b2447bc3f50a39cf218b719d4bf61871da66fd5a6b0a4959f437efdfe6e60eb8d9b29599620c17a392ec653b16b0689574be26301144e4eb409954c63f6ebf2ce5e002a6811a151e81258ec6023059c0ec672ed2e6658c48152043eca863be5cebb896c19c505eceff9103e470d6951810021fae0fbc9ca914c07bb1dc6add38e8a4d9c8eddea0e7c4f93a82e8a4b75d3f2ad7131dfa7de337702703708f30e3efdf075937edd4141b18ac556a5fbe8858b276e78da0f6d651b948e45538495639f2f2da176cb14fa45b1223fa7e1f29d1c5a8629c7e4fb077f3669d167347ce7d7f733cc79110b1cbd8316d569ff9a5525196b2cb5e50ebb12c2733f307ced955b3b73af9ab1fb80ce724cbc07a0cc60f1adb2459dbb35e90bd612c63c78f309d53bec0facde1394a97879591a21a4332f32d6e0a11caa49178865f0dabd5f89cc4fd62203a6a92120ca236e2ba806b82527d92e58f195343e4eb05bd7999c9c5b819c21cf9fc4b893b1403e96fa5f9ae64ff49c9c0a2c2255539d74c4613db14cdfdaa243234e15f4fec6f7176857f89319c4510957fa487e2a8363d1212e0579f5542a7801e10c080b4743f74a3279309809db1df665a43c579c3209970756f3dc2d449e2d32a31aa387c411703054367c49dd8cd84ef6a9b98d0063c1b6bcee62f93ed82d9626799dff04e824be478a16be4ab5e5a1a34c6a957dc921185287c73c27fd095ddb3bb434ad5b1058fbb3620f411a25a5df020248f576b26b7332f73771120f806664b4b30521b23edec5037e06bfe272eba01348dcf433a2042852e6168f3ae7afbddfefbd7197b9ae507b3d64fceabff191b6b58062fcdacf9c76bbf471066587971f4aebca7a98bd316d6d1ca1751376f3a80b6f0ef88b15d381bcfad11dd013e8fbed0b107c26f5000c36c55e11ac9c4228b89c16cd67105f676e6ab40db9add92ef77577df70319b1f44301fda19aba8656fac4df2f40325b702ae29c99cf71bd4974ea935dff8beaa34c41bf4ec5dcecd6722db49dec25498a4812f9ee9139781c7af4fbc3e1d780380aa726079b0453741f499b9eec706eba3db476d23900fda4ec9ae9012d6b8e14dbd3375aa74240e5192e41cbb834040e49bf4292ec57b2e4cd4cf9dc8f8b4aab58fbdb7178090983ca1a112fe9232268430e3f9e8ae8d0a3d312e5a80fc39c054acd72d8bfde27d4c6ce5b8e89c0502862a9a04828716edb3edc9baf735e2d44fa67f6ec9440f95b230a5698fd08a92e03c2e78ccf937afa052b3ade4b86c807cd41d61f6daa5195e3d6b45ecd2cd74468da0547acb37227082103c5bb45c296ecdb9f0a3f448489c37f9f8d38437a3637631c1f90e40d8ccb21cd6067f97fa097b1d974208f9625f9627e8ceb49776c896b4946447a38adff71db9ad3b0e7378cf704afbb16f60f500b8030647866966e4b9ae005807e3a74ac52d6e4f37dc530d7f0e50d0d11baf107322ab226c41963e25265e52cc32b81f98760404872fe4e7c1ac1f000c8ab882256b9bc07ee8d2a41db2ea4b40f0e0129376b98c19aae5e8534b4b836716969b98c587be4faeb64aaa5123b5ea8442d5430add1d553014c793c2c6544c53a5beb9b506dd7da5b204ff8d2538c812b47af4ce1ba318e6a85db8b9499c914eb563373558e3789955f8069e0a2aefeefc99d4cea1bad52913607aa3ee6916678b5e31ed189bec346951dc2df840a094009e128ecb069423aa740b3024a32688099040c3301ed2704407334f649b41d24595964a61da8a6494582235c63aeaa32e94ae50bf00d1e167710ca668331df0e7bfedf89635f4e65b2a00b712e17f70a277e89c9aa8838c1e291f3c4d1a4d2096a0e4b04e07203073b81d8b2e74943f9e96dbf391bf31b0a9d8d6ab42342bbcd87dc5e440faa8fe96b546a6ae87eda0a874decfb2bbb2464347ea21e653fa4c999665fb4bb04db3d379d095acc2bd128dcbf348910043911521afa734def5414b032599f616d3b183af918cf0cdb90bc0fa3ceb538f7436b612ae61877cc0a8bf44dc23f2915ead613c3bb6e254d2ddf103a3a3ba3f6f9d301383f44f9917f2be144ed708d6db0ae6e6a10e8246e42c89ff8b2c05af265f4c180ea1eb5d928e0ce40166c33c2b8f8473297e497bfd4b16f7d47343739c98206abc7cbdf42c9a9102782ade69596a7e762689f5a91880baf2527ef15f3af59acfe9f686b0630dcff891701c2e7ab3670030169a85178c8bab9e0b5d7aa286fc60b88ef571e4d91c3f00211c31bdb561148eedc1a5a54ccb6a8a1258118f3b68d0851aa6ef97a86d92b74f85aec463cd043b3bee5ea94c3b5f2618d5bc3a11a182e4d27c6f4fdb92110a56c4b2927cc331210bfe468ca94dca7cdb54958c9644a02c9575497ed20e40fcdd04f0c092e17adca9f2b7cff013166464602814bf83958fa0fb7223119956b022763f5a0fd16a6c5f26d29583f11fabc057beee671a544c8a77899d6e25b63587db8689895019182114a99cc81abc9651b383785bcc53a84585dd501fd5e73a39b237c4f87d94d4bb5e0a06843f4c84b35098f02d1e22878d5410d2c5e65f8c062b07f6d1254f4bc2c91084c8888e6a8e62f2df1e6957a6b96151314dbd8b7ba3a6be1c09653f9bf5e8e0ca819607b973c1e40183492c7d87954a897acc737d790b50d25e88f2dd2e730aefbdf92b07eed889cebe21939618d38d7e495b9f15d4b9924a7c6d2718b1a311ba50749ff128ee5e1d1350b95b8bea365127ab9acef948adfb24d48027158fd7e424d349ba3d0127bd5679713113158a4a6b871fce86da2b57dfb978ea16c3a0c3d7aae9a7a0ad5e81051622279ee10e8804791a32c1fb0620763644512e96e44ebd52b8b1d830d849cd89253d0cf90590df1ee3e77589de784a052184ed949fe4ceac117fee8c5e8d292e132cb7e8f0b4cc68578efd4e82fade8052572a257fc1e34f7600f19cb32b3d0460eca45399a4d975a106a2f757f973cf00a3d796d897d10e5442e097c9e94fd20c0f90dd117e16c194765f4c42d5b24ac0fbc0bc44634c664e1bbdcf6eee6fb8fd76d71656755264d7fd2cc665d415d39c3c1570213795087631a14ee8d3849c9ec3a9a94b13b55abdbc5c7af73e1db174f3ebfc2bbe53ac23819fbffe5370d6a6158fb0918c9c6cd24df6217596c2fcf0985230bed762c2c13c7ac3c2e29803bbffe09f92a193e3a1dbac74c848df46a5c7ec30ac4ba441900ff4dbe508141bb184d6e8cda5b80662e3136bd28593243138c738870931bea9899ca5185bd86079cf926026339bf6ac211b99feff243bd0ba7c118234f995fea8eb7c39843a967f5d3b514987e9f75b5a352ae578021f108d8b844c7ad8182d7671146f71c61f0d9d00e653b7f029132ed434d43f45d5e2a1d258673e353d8a335e828f3e67c8785ffed5704c6bb0c20acba32306aa5a145f765df878671c88013a7566eaaac4ebaeea0e8000a51c19d567770a6998b7ff855ea603f49b51e76020aa6e2d5860cffcde7f58ac5b95f3a0b70c784d42e7dd98805433460c09f02f12c7ca559881f38fb5dba8bf997b34d6b22599c5d66a53a59b578d8a16dcd4c5826df4db84ec0bc527fcb916a41d621c9d0dc70fb5a98637ebc5fb1fa82066d4465ab060fefe69254fc8cb37ff8243827767006dd45d10cab8b78169612440f8f146fdb13ca8009aeb06eac5d58d965689b80234b41ae8617acfd0d27bafcf604d51d35852b103cd1c8d81b69c507c2f6408c944464da43b22e6a8606bedaf9ddf9e8ece14df5697adfaf977a015599cfba6e2c370ddde191c9c6557f0942d9882703052d5309eb13dfa807b6ad73f9a177953eb9218d5a894b547589e8906d0a5dd7176aa6404ff3dcb6c28b4cb043fd5ad008ea3c34735be1bf1df6d03c4c076fffbb8e4fb53d46c94606be6c2bcae487f1ab4d1a5f70263947f54c63822614043cb80b6f61b57727cef7ec8d0afed4bc5a36763e419bfc662b6d95ccba85009dad6e80f7a3b3a96257def75bac876d8c8bcf59ca49dc839bce5548e4d11839bffd5d4bc481fcb75af2821707aa3a735587ed997682915002e224bafc309ae242fc367d03ab86a999018b5ad9ff30df013ea89ce1dff5b51fe6ee998d58c2110d8afe8a91f3731aa3e98f55badff20187c411ff8effe93701f08927dd4cbff4f4e490ea87454a39b7e7dbade2f410a15d44a32a2b2fc08dddb97d95411c78ba44e15a02c9b87e02fc2ffcb9dbf5f1e7ca50b181fab24fad672f83c21fc8939e1c4ce38eca36f597817fff2af782c1d14ad54f899bf86fa9fe87fe68f7587e32952d720820e76489b779fd9a6a2730f0859da2e019f389e868fbfc357ac1f579a0b1d95ed7f4995ff3fb45b8764eb4cf895899d97a7a34d4248d99900908b84b3938806e6ef4f0bf01b1a332dccbd9319873842b9c8af9ba2f79b83802e7b30d5a859111b5c7e939de150e62c7cef25afc5b1d900e14c9615ef73a47c6717920af30a463d03f98996534f5de1cbba54ef56bb1b73d17b78e9f08575434799264bfaed79f7bd135a6d52141a16c4d504394459ccf748c51f925799832bfb32be5b8f997532b41c2d7018f3a28195e2bc77b53d5a5254f931767be4e09c66274586acb27b1540c3183847a38753d1a181c6bb89f295699764ec1b74f3fa5fab15fc5d2146416d98dfd4af1664c918724496fc55110aa3b73c3238ac8911073b8d4a83c714acf83f35bef70828544929d3cdf6ba743912eb0a59df6be0cf57f0400c870a9d7895452b2c5fd76cd0cb10064c1adf348933343a4c1b03f1e75237795d2c0785ff1923aca977f2cefa2a8b4a605ca5e2fc8c7a85659b7f8ccaf36f2c7e5e8104767d373f4681e0fdab5bf8c37f8a6d05c6fc37a8685066797405add63230f1bee123169a6744ea5e2bf11e07c9750cc01336698d75599cfd1d382dba6db9a545de2658d41de3ab9c14f58c7303ec8fdcac1fe9ac31d968686074809170900c569715b0d12a248f6b0ac28c9b768be146d44fd37c9082dd6d70d408d8709cd7e5038d4313107ea501e548297d31ddb3771a1950e3b6c5aa46c435a5dfd6abf61abc1f505079901278d7c3c5f2ef4c3119d7a962fec306c82f401cbb862b5aeeb3d6c293ce6d5d8784797c5ea632b21e22e15309ae2ef755ca43912e4c8a6d6cf8715bc5de52e20deb4be89e8badd867462fe3363f687a682f9238e096225e6a9e692ccee7bd064bf7b60c1c6e233f194ad65cdba704cdcc5983883bbbd01b2a0a5847fc70370b40196fc3b87baff5264efada0d4f38f933a691bf1c3949482317836b4d8c8ace6a2386f9aada538db5288aa44bc7eb6ee868de69e4b3b74f61069b7446328a9a4e7496f931d5708230d291cabeee926fff134136ba00cada64047b94fbab76c20aa63fdab50b20c5f2c2483a315a6c8e1293fc626b2cac464f1886502e84e81fcf1856c3855180f5aee0d0c69fba09f841d5a6d89fa81be404b10ac995fa80aa8f08d57ecef38578e56355050e20205e9858f926411bf678a6c57eb590b6bdd288f7ccd9e579fc8d6552be169d5eb355cd9145ba7417313496834bdad3e0141ecf76cb44855fc3d64ca906193a85ffc7ac07622c7a6690db7f65fb1a176884b924b4f71abb9103f6ff7cdd521c4623dbb970ca3c0c92990f6d86a80563965926ef2a82bc00cac43852cd05bef87d197ba2670ac3319968481bdbeca69bee963a90cd400ad93185cb857dbaf520d99e1bf64c9776031161aa09588039b0aafcb432b3c6ad77bf0a22f0cab7e41dd91afc566b1d516137d5e5e9fe293582beb4eb54d8e141ecff82d222dceefde562ab0dd0b41f0b23df988e60cd1cbba313da6c87a807c75cf5dc6c6235f1c7e7de6177766c0410c73fe8b4b382b334fbd9f4f3fc7808d2e66f6019e7493fca2bf979c47cd857e747f6ee5df58d189f4c62d4c141200fd66f7985385c0069a2b22ff8f045a11449ae2a6c1c2e55791e219db335c3d027c0c1fadd7e50a1f2759d7730b366715b41de898d0b19c01917df5da206f2fba74c8435b3c4c934e274d0655481902507c31b538fc9947ae170bd3efb7baa94fa7ce8916a0d23ed198ab5acdae4dbd6ca01ad6dc27325e32df32f4e607ca256803d53b043c8581070d896d42e2778fe09dcb22cfc5e9c41a0217447c8dc97b8ce8da8900e02e254f492c2f0c0cd54601ede62d69d21c86812c72a5450d20d5c1530ec48bdc51c821842e0e9389167c49e2a2aab7b92f761b51459abc43f43e4194080f7a3353bf43dabaa80421c4097869b7260d7e78336a79b3c247e56a36f42533ba172671436682773ebff4fd4e5aaf4ea451a70443572820f2ee6e52e250869d15283310abf82a11e6cbc59538a1c1ec4f8612a514c523e17bc92080ba0917560afd592b470f431d27f01a0f16616c13f9c963e1c1b20c4995d006ffa555d781d023a8cc333d9f41318c1e5e555df2ed8036f610e85a55873ae5b2a2b104a49056610d7d637a3dfde322e6eec87d5a360ce708b177b6968227924db29255ee19bd19255d638d9490479980b5d82b6d24ef4162e9aca2eae175101252863dc5826a5e0ada721ddd2511d06df487598a1614cf6a99cc856c28f9eb43f84e09bb13880b25a192020c869dacccb99de2ff12d83c268eaf3ba70b24abbc9acc280bf992326efb161c3f372e17541bdf07df5af160a8d5f9156bbf5264bcd25931502c7b0d23f6238a4eb9d54fe55717d43cf7110a94af61d614d7e6464a9ea00ef8bfd59b0b77852e3633c0e3b0c2d8dd1430db8c3fca09cb985675097acd4d86a8b13a8d38310a683f14b3f84afdcd80cc29216e7f35e89603a226b4bacaa89682ff1d445a552c2cc2838bc8c6331193a68125f7d39fa2e88d58c3d8618ca9032d35ef51c1165cc29c2dc7346e0f12a4aa98f80c3f407952d47116be36c5cf4f6aa173ace40c8c01bb02d2b8dd8d569505111516c8e8870170a024b8af038cb76a8d18616a1f12872e0c8f7543f0a84d17f4d8cd29aa52c007acdff0b230d170597f10454eb239ec578adf030f073c6fdb440776653df84eefaba0157163aba5a06adb2194fb0fe309f2951ddf585a78637d81d86fbd919158dae87f7fae4a0332e36570bc13767f5eb63de0163aadc5a58163a658d2f8f780fc73cef637b47f42482c2fbd7b3cc4e1efc53b8de9618cd42116cd45964a1ffb90b24658c9cb3fc1fe8b8f4c25befcd41db5f93eb899c250ea665ad03c60e3a3af3bf384d9b90dcaf94d9cf6a1e5acca3c25be8bb0543afe99113d9e97ce1b4a4cf678bc0ddd9cdc8d5f9498d5b255b03fe7e549309ec3aefa05e0761b37fa4d03315032e16cf356474a3bba7b67c7647f9f9b5e0853e643300f175bda770c70d349dc29d65baeeacd72ccafd9f04daf413ad2914b5c62f8dd44273b4c3af09818eb524397898dbd757949a297c4d5f65b0f410e38afda600b1ffd647ee345e1ddad5a3ef255633260d78bf42dcd7149bdb4511caa813911c05bf882fcc41891df0060470195d4a511d456250f307429e61e03983cba24fabce739a3b64b4a0fa19d80f42ce8dd293c20ee852ec2b7c44df6f50db66931bb0013cc81e986f5884d8dcffcd172155b8e6ae20f2a832b3df7649c71c255eb30cd12f49c78ca2c88fe242a2b27dfe20a9c366c85360e5e7ae07d6b3693181a9957d2a4c9916d6f9c943bf3c54907a2fea9e33d4fb590d4c03c62d8e4eefbf623160550c76c7630bb642f945a0eba47afd95b447932d3ee18e32dfe00f42eb27de77bfae300352d8df81853423feda155ecda6bb96e189dfaaec1da9f80aeaae813974d9f1e4b7ab345113291f13d79ce0b512ae58046dd59b6797372c7b483173822c1c973e81736e6d9f9ecd995aee1fa22913cefff3fe27b56a3d6c4980cccb19969f3204056fa20029f3a4529302a39f98cde801191b911351273732b68869fc8bd7376a0573257f9a1aba13903db1aa99ccda3d08d25fd9fcc0cfe5103a8154d80796faa6b10847840d40870686bf7692987c126011d84b2eff38011db89fdb8b0aecf91c5cdcec3030085c4f9cbcee80944406a8e7cc23e58cf59d28eeff9dc01ba48a39518b7d55609775509cd1f8bc3e5b178c993716fd4da924426885c72ef55671d6a29c256b3500b9f8f7a1f033fee0a3aa87cd94ffa1bfea0785c11ab3341b4ae2fb9b558796348c25bf5baaba624f2752602d2ffa2956d24cef75ce2ecd417d181433b7f394457a263e1675a858c0e68e858f334c25652f07ab0bb084902850b0c2787d89dd7fafea59df6e1e36ff508fa5d291c914534ead2de4baa5d614293ff73d94a8230c12f7fe4929121a1bce64c245ebe006f011006b368f326c2c78786896952d3b8d1970fdf213cc43a98d02892d29da813855352560253c1c2e9e200efb0c3382cdc1f5eca038d9bf54b37838770665ba2b7f643af58a69582eb3077172cd6a953a2037fceb39eb4e0ebcbfaf21b029058e7aef34f72ef4b235031a98c66d48ff977b11b4ac1a9cfb7b4fde83ba5a84d39816cb8f1fb14da3e93012b935cac2eed5c62e48af8de020605f6aa6e8e7321ebc1dfb65184a1125fdf81fb4d6642d9258360ad229d61955ffa0188adc88e597bd001d9c14b9364d9a1905afdb3e6d2bdc4efd46df9d48fdec612d4223981c47bcf233c92793c61c0ae1838bed2bee4527f7cda507797d54327a7e610bb8b3db06cfd8d24c9cbcd8ef0fb84ac2b7a03c53f9aa7f93d54d30dbcd2965fd6bddf94eb2f9bfdb445e86550b1ed1d52125467e4bf15c4320aad809ccfbc92ea2f1ad39366d4f8aab113aaff357dedaa917354e6b20d45b8afe602e0fcc4689fa17e5a7f12cde15b48f1c4921c279aa424b3691627a1271bdfd98c895e1ba1450082a44cbdb27c6b473579599190502d5d9d0f38880c769a8eec74eefda211253133376be2bc78f85021d7d057867bd6c59e592dfdbfe4273051d175e248163dde0f773caa2791fdd54b5748755c07ef378b4c39b219db469025cc1c38d198471c7406b5ef1fe7d5130fe454051f94eb38eb4c06634160fb17e4231ceeb797fc905201168123db1273544cf983fa7cf63ea2ab355fa0f7e1b6cd267b3a625cb4aef44ae2f4c32ca9bcb2ef754730b257d21faeccb49945ae7c5b75199615f38b501b71c0a9c836aac471616f648f5826bc3a0ce84a63a7937fc50f8e32db0de08c23d001701ef7f3f58642a641ec270afa57fd21300899fb2f7633b8a0434ec2f4a8d04cbdc5c374f0639e24b51fbd08bac2d6cc266d4ddc42ea329c6b66cd24d358aaf7487652c298224c5a2e76ce528cead2d03cbdd7d93049d0dfa6af4003879679287037c1bae241cc05be07a41a532dd161ce2b0f0d67f73e43dc034ba91f04b6d783691610abee5d45d879c87a9d84990c83c2670a95c7f32984bb62fc037aff7552a9ca847f91bdb765b2fbbc03145a91b6d66466c97ccfcee070848c2d57ffb874a9bfc18d26a26597bb1861dfa03dd41dc64d7870b18c333ad9a176b5df0d4c303892c1cedde28e6f819c5bab7b2bbacd8c93d4c64246ee2be7f6c9cc360691578f8d8fb8946b7024ba5d3ef0f64134f19e4323a33aa152af8ba4e67988643e57f5729e0102910723f781fe2a7a4b2980b8d7502ad6de6800ca12b667353ed3066fbc4467daad06b0e5711877e6ccb8138f029691d99498077e3be56eed6e77121601471d03711dfe530d4bf425ea89ae58d0426ce999a3bf84a35e60a5fb04e7d82c91cce0cb8603b7b6a6722180b39e364f3de26fa54ca2b22dd3cea36c01828aaca3adee1ca5107003535e271d622f220f84f9ebfbc8029f649a60aae305f10bb56a37b4110fbc96b92444262eeac970375cc56cf90ee6974bd6220e2df5748a90cd4063d54471604eefc8e5438b9c361193346f06b295cc8a82bd04c3bd04c3cf4238e9e8a3c0ccc27524635c421dd36a2232caecfaaaf08d401a521b4c915687785d334d969d1837f71f30248448d97359d043de8c336865b1ba5d0b72e0d03cd569485b00bbbba3ca3f421d639a8fa47f8522fd1cb0f37eedb7389418c8c3726510f7150d73cef279f8127bd7915669de700fcfa669de42b2607ce78b8f311c39b57236c263f86322d608b722b40252b2005b1121c126e33cbc4c0913ccecdc9a34f2b91448cb776f42ddd924ad5cdfd53dfb4618831bd42d965fea1c1fb1687af907ef4ac04329631412533150f869b98f4e80d73dcab8b76366dcc8b4d2aa8795f65a7d3069b05f6bc00bafe9995f0cb900da716ff93923f84133b1dd4b910b8dfc1d83d7bd564e2899dc59f1c2b7cdb5d9dac2f33ad34292a000b540622db92e7de7653106efa6894e2cf0f274d8a4128549d955256b093153cd7c829bb9fe9e6659d0da2fe18082cbfa2a10b4921ac12001b43c777e332d0e2ca69eff0b86097d96646b2fa8c9c6a38b74b16246360299233167e3f48779b13803b89e88a9ad6ec483e8cee1ce695d462c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
