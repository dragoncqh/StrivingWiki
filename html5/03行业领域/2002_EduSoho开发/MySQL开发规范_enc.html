<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54107b92dc7834874cfbd092b06032b5ef243233e32a7e9482233cc101899ca14a15bba1ff13f4283795a542d67505b1ff60799ed1f62114a1e087a9204764eb4645ebab91232864c926a87a91eb7f5a57bc2c3ef62dcd869c99d0740812a797580dd0944763e40484a2be770754bbb0680be2de24a8afe793913d4a8a24aa52194f6b7ca30e3f387c400ea0f92b53e2393822f34526230cffa5c84f7d023239be771c1bba98c67722e4cd893b5a334d48c036576706602deafa36bb76cb7661478db75f0d905790dd4768a9ddf599de22f4d5318adb97a540aa662f5501d5552bfbbf1692a46f539486f4f60e34b50bf06d7357a59e17749b036438f6b8dad597dfae0a8aecfa392492de88414a05de487be2588f774682fb27550a80c6939420a6a10e1e5fc3a9a2f8165b59490a3be7724455042dd1e2435bd48ac1e5ad8a938c95fc0a8edbd6b336a7cbe7aa3fc63de3f831d8879b52a9d1957d945583b987dd5f10abc349cbc6a6459ffacf95279e1353b79801166ebb0b6c13c57f3e1c190412c6d39f92e0c33081023bca1ba56a478a80476924c9adb890953b27c82caa72ef23d629b51d6fa3bfa21dc7f9e462600d4888e486a542848da819fda92da3bc15ba1b553d927151e4b6c877ef1203985944bfa9cf66d5646332b158e0e3d838bd1cc60833db1d6ea1544540b238dcb53d5c38f183865a87f3eb93eae93e652a137de19512bb0c3b75f49d30a567ce98486d251f99dc90625d8f59656e3c3ceca606e7009f168ad90ed3e9760563c20d4491e93d4ad4a3a9571d9988a041b7b56c7f431278f3ad655fd42345500ab9e03d0163cb6f3f593f90db78315700a4f0f9b1d745d3c5547b8cb2eceff58a5627ff2a60182c894c785a7cd65690c7a139240ae015b03f2fcd5e732774a971f3f0d3a1bdbbc6d5db244bb9bd77b58c2c92fbce670442e4e32511c0858aa8cb23a7e3376a31655499e0c5e7980a31405ce7697043ca8e9973e8744c1822a74615ebdc6eb0f28fbccde79b2403e9c5629a588a93ea568ec600560f6758e8e0df4658e1294d0272fc09965f56b822a6bbccc1d6efa527b28b50d91adffdf99b8bf47cc8b458fbc10a8eda8f0383b2ac527843b961c9cd3618151b0c7cbc78a9f3a6b839eaadf4532cdee566f79be2b055b0f738dc56ec4a814f1b1c840cf90ad7922bbca9852cce366949b70459f76fe28a7fb6ff60cbf55746ea8440b4944996dbf4e4e8bb1162d253a5d1c88c22762d846ba7e43cfee0b4c85c45d9e9ddc45f88868d98e55a80b1fc74aad2a737a68b0986147a316b5d9744f91e1ac50dd14bbb57b6730437083898394cca2448cce22da6e931368b3172338d32acb8d602a5dae4baadd7b6ea3581cb1577c52280e8f4d0f0e7b755bf67631afbe01a2a5a4a51a089e5e1eb0f37294dc03bf0960a8dc0751ad1fc1a978b712735d78c86333f1af3f3fbcf4cc9b1adf860fc3142679f44ea08f89e486a096e73dd283a2cead7c3a3d18a09c13afa7b7c0fef68f94c3534ab29f031a539939c80380423f4cdf32e4e2e470d6737c7f8f2b2b345fd0e57541ebcfd3ef5a6afe642ffc5a01c61ad8ce0f747a394ad6db04ddd461affec31540e96edb48edcb5a8838e166db593adc5cf3ab7b75f0a8eabbc7eb9dc68ee1b25b3f168d88e3daeab454a7a985d45fdcf105bd36c4be578a1e486a9e0b6519ec80532a7bb858641c4e3cca7336452412b33cdb29ca660c17fa4eb68cca1ae7c3b9b9c73b127413df463dde3a590cdee3792c290f48be0a56fd3f04a7a633e51973fe6a3e4d3f5bd7363022643eaf0b668367c5cf2cb05ab736f0fd99e3a5f58984796d746f7ee6bd55455c34295ebc6e341768e3ec0642cf1b546fa251ccc7d5e4479d94896bd3a6e9463f6378bc357061f7df7c0fbbae1f75808b51f599cb6a83923220d9a69349f39e627a1e3e6552082d38446be629b2937c6ee86cd8bbceb2c840956b62951cb9cecdef0d97d12741d46a7e7651ef81bcc6e04f70c5b508903cfa4bd16e716c7aaec0cf46ccd6b8b48a2d7a00808ef6d7c5b8d32b652e240161184ff46f35337df98ebb6e0749e2a0efa411a058ef76910e1eb2f566c0ac99034ace3ee2c0c1c8c05b0aa28334985178d2295219101250a82ed94410f575106a0fcb96811efb434ca9dacc6fd2895fa0a1697fe2c884f0d4a949c88e5597d706cfa95cfd984fa0448988c80270345fb19ee920ccb31ef365884d7b77bb3979b3d581c7fcdf91af6736c55ab8300f60ae3b956976fbf07269c13e5a0b0cd342be5507ad4f8e3b918b933ecbf3b01a66c8042eafde25eb553132bec20cc396ed6636379cc3351a10318db850bf2824f5eb32e9e1260935ed768675709dcd79938093d73cbfbfa800ac7a3ef34c9cf0903d3566bc42f50181f9c31653589f44d81642336259de60ab50b0b650df62b065a3dd95976e1fc50d851ad0bb7cf71b2c792c294a479216451e8e7125bc1345be7352aae4f2553bb1dea33a73e94edfe216c998e59bb9729176231c48cfaf62425ec7c1c312ee075ef99945c6038e441cc5db8d5662f0bf684d979ad7caa8098bf205f7f89f38c7bfaedfce54c90a3415a447cd7f5508624b3efb8c3cc36a2f5d96cf26ad2ac0a7a11dc9b8f2045e57cd7b80c40dd357977c9fd5fa1d798f92c3b88d30ed7b46154e49b06b35b98fb8bb891c016722783139bee1786eb88a3c1c2f4dbca2e8b529a142ee06b51b2ca95ff36ff9588d1649e89c33fce6ec6278398bc3c717fae7e18980f551919e04b08744d372b0bce50fc6664baaab3a8537b3b2f1429725fc1502cb496b6103353dc3a7b03972ad7120c9766b198a24bd2d701d7cfe42de171478ca7c7ce593f449efd380b56c1921e49b171ea79bf6f1eb01156b3113c9f3c7a9b52f25ebdd507046ec171b6283b54327a5f6dea7ff3733c0d9070b091dac3a2ef21935499fe9009d8cd0568a25dd68c08c4254f44d5c1dd0809cb383bd3a3d321893c3581b12818b3f82826f5b9984a78972d59f28fbc8c10916876b85b57dc9f9a87cb841314d0a1a11673052c540e7a44d2f83dd5cb3cb6dc38f0a2273b30288bfeaf9c700285c539267510873e74204a228a3b05053cadbbead69189cb2ef87951b97e3c41378dc1c2e608dccc52260707743af11b07774dcc6af8968f1e569de2cd00b5f1916698390aa7f941e57050d6592cc69ad50205a50c35a7219b4819b3b6f1c4a8559104115ef9969c304c2676c0dd3ed3dc2e3bee6479c9037288fcc6c832cc03da02f64c4d61cbce2c712cdc95d464097ac8af21b736b43a4a60fc00bef8b559a4d1ca30f0f92762dc5cd109db8da2260e1ffece133f77e98ab5932b30db5191470aeee56afcbaca48973c088accdd5ae0f346c67e1ccf9e71ecec0b9e8f1b3c082f3cf6786ad2c0b992f029510d47c010f44dfd4eb462af493759b0d54df4baa1ababc8fb4932801f847e23af66af327f1bf220d98582c0fea1efc14db95e262c15d219f35ba849742cc12aaa217a5ddb9a0979213b945f48fbe83dc946d4b5ac6ce6c2564558c47f3daab73979945fc721a16c620e3a89426449662c8582697e129699d4b0a5cd0ade04b1836385d3500ea01a248098862419f7e33d45b2b97ebcd6a1cffccc5daab5da21af7411badfb3ed847f94686061bcc19365bce885a087abdf03d2703600d84ffc5d980f1300e94bc451c23d83428e75a27c9b2484626fe54a363496e2ea919e6b88810e79d4d7dc61a51f9535fdf223ad45bf77ee5b2411304faa682460258a93061816f7952d82b2f4013b68765b5d8da99455f3a15c20448b52bbba3005081b89239cc254aa0271831b2da4cf7f936b60855d5a1e5de865c753e709de8532858ef2f684f44fe7e4993da4d409fed5243b966a91aa75fb2614054178222b5ac21248eb14b012535ad5b045949c56d4bd53868760eb8d4f033693339b7b61fba027b56625ce47d2ac23ca6efb9cffe8fd7467a6839e003fc6803fab36419006312d537fd578b7d7bf08b568528d3488c78a9cd324ccc99a7790e4df86ab08759289321d5b5d6d2d0a27195d5503c0cd1d8387843df007cbf9de6090f283370addfff47b9e1e5d5c561c4be15c73366407edd67f8a2d8ddeefc2ccb96cf0358b1d5833623727188fbb9e9cddf3c4ab3cf6432dd4efa4ebdd345a852206c45ba68c08da8bce65a2028109d632ca97883b65870821e5986c8852f0b027854d18d07a1e8c57596b4b81571297986b47ab9679a8f38ae4133cdf9d1797bad6dd168fbc02314cf2fe95bae266858537de9ecffad3fac0f2ab57e7b89d2a70cde70b6c1678a29a4c0515f88bedd4fd605a4a50f57fc838b4a63e5089c8ad08acfb29e14edbe5a562e9ed03ab37bcf62be7d476b2b78d4c358ccd3b433430e3518695ff2306efa106b65a0520114e4b26ae445f904778b10617f861502dff529656aed4d1a5ad109aa0f931b96ed03f67f1abbfd8a1937c355ee950802074b2d8b0855d3ab5dc3a220c9d1661def08788dc0d97e99e54f06dfb8d59c487abd5550b0d9a60f0898de3ddd943fc0c63f218294105ff47f0055d6c876eb95af9304d8aae8d6bbbe15ec7fccb188c530c267204ae50ceb49e16dd25d415b2cbb7e4fa86c042da5bd9cb2b191c5712be7cbf14ed117b2c84c309ba10d207155f2530672090e655651f3fe9d9d29e06b602c2d4c326010b95589b8f50bfc2bcbf396d4d495083bac934fc7881473bbc4d4c5d88a366bea411814eb665d6e57ae9f7588896c3dba527042df8877fec14e1f3fc26f9479ac307a358c43ab52d816ca01bcc84818fb128e3739ba71e60cf09f990a009c3665e5eacf8ea750d021afce5d196bb5e6696c99deef7a27a4946d5044799741e3b95d767af60ba56778b44093fdadbdd650ea745d4a1a095e68519dccaa259c8be7544315aaf001d622dc9171d1d634842c30871274ad743c808f9e025793acad6ee2ab0789260f1abbd2d00f2e97edea909289b1a65122b27b15c3cd7a05752710cb41ea24597e9077826028e8cea7b23d28c05eeeeae88daaea137d8b7072ad829b74886353b650cdc766c8513390b5b8b9009b8adff0788bec7316003469cfbf8e11d5c35a8af880b0447d743502f60bb728d31d0858cd1acb4c53e268a88e61a9429add1301e4782be8d8da9dc6435723b329a90a914a866f155c7943f75065a8c44c035f89c4ffcb4e5b26cd434b943b1aa9ebed4b806a58d6d9ab5b450ea4bdfb4e243d92c1b06864171cab203a8f211d3580577840e4a7eb1d0767e3429a2320eee77922e80b117156123148aec54953ef46af8921a5234a60b70e1bdef9a31cc70c8a468aceefd8f54c5f32ccc7aa1825970b30f69f4b4633c998a9c5e92d39c627b9800d703a6905c9da9d3117361d5454fc6df741e3b692518c6001c94941955fd1877e0e3f0a647bedfd661724fabd4a0504d72229d3dcc11f924a9cd9a64d7eeead8ce72f48dddfe5749a07ed35d841eb87caed2ef6b9c6617134a984b7d84293ff89289222050cbd45576267dbb3189f7c6a8d58d9a5013f371ed97b4923649fbe064df025cafcf06c41a56908e4b027db4557daddf95c5b279f2b7d5884afb889423788bbe38b1806373eab01eba880605341c9f392fca7f63ef6fabb8ade5a71a30b833108259662301219a4898c6909a652153589d20ca4f7f0efd90fbbb2bf500c3206cce31f801cc57de33871cb85829bca434c9894212b4ee4749fd76c5ad166b2bb2c627870c6d83b4ac57143610b512a4efd20d4e88319f03d7434ef25862f2eda0cf65eaa323677e2f83a7e119231885b6729cdd88e2965cc0e48d5f44cb016093f55eaa226ef754f3dc94579a817a958919dff58eac9f39b1c6ae1fc33e7880ed2e4415b645f818bca71742d1c4f79112f9e1527313eabb3dc5420e1a77d4debdee996c7f46189ce19b9d3fc63f59e4dc7c5c68d7ec082aa14a9b862eee378f801e0d956ac8f889313faf564d8eb0e1efaf97a66e3282963be08eb3e48f831e856d1e3f75a03a3f2879fa740147518b068118437aa8c7446a8b3ac511c759de4460b0c13735a8eb4582fd6b41565699969d6061ca17e05bf2b864cd9bf4628a4d1e45aaf9c815098d26a7af859af584554ac75c754ce92e8e091bfe5949933095d1b92fd36b1e06991bd876a680a4ef7c8e578cf0f2d9f7375dc195e53c72641f092678e4635fbde015f9af4d22bcbf6b2714d4d79984e337660c7ed313105ef97308cbfa3a108bbaf49e10566004bf243d5799ac4f2bc68c432c00dc15dd17218187d3b6cdfa4a40cba887b8318970a81eb308f2cd22562f7e9adbe35987d19687bc6b643d34f4d10a865431bd8b82b781e2fbd7e26e767f6c2dbb871c8868986b91ba1d769eb61975197d71ad4c29987da3c18b5d71f74b03d6b8523b1f5ca1e3bd3a572bc0bf1e7dfbcc68b2c0e84131044c369171f7fae6eaf577f80dd8e551ab4d57414b297b7c2cd1c17e8259a56ba62ccd579c37721153490fd8c379d5cc0ac5e6d2cd5561b4137bd6740011ea72d9da3d85f551b99fc6a3878f836a843887317dcb2f4bc4e0d3cbe0439721467c626b0e768319d321c379a31446183b252cbd7126963cc447ac87b34e32f1a3b00e27733367d161c4ea47c5b4ee809ee53922673da1a5af53c0b2d8eec1fc86f93cc31cb38199e7b458a19ba5106d3beb291040aa76ebb543d57524da3c5708d1c788f7e1a54da50c590ecbcd5a35cb4ea8354416e29534051eab11223b9de37b5d97eb17dd0385b0a14cda151b135deee33057a0b641569ade046adce020d5ec198994111828f80fa825e2af16c5e308c471ddc1e5e394d30d1ad01895ac8958d524b6af1c6cb6a56d04a3d852f764ae189aba5952ff8fd73a90441f99b21ba1c23b556a049835356dddd993303cb77926fadfd3cc78ad657613d4ca161a71ac97d7c9966f0c1d886cb9160041b47868912c723033c567f024ca555b5e1c1c98c2b6679ac18e08269d4c40dc3b54eb592501cb04232cee9894e8b2cfcd36fba39b2143cb176e7a2a0ddacf87f0d5490e6bbc21fa104714d04c0d2d2d18d9afd2c43201a4d9da537878ed0f3db610d42cdb6829c5f4f26ce7610b5b096f4be5ef7aadb5c8f7d3e01d518e19f08419da5444f17678d3d9e4df8fb63739a18711d09ffd5736c4104d82134bd8ab816c29fd0bede85a124a3c08865981d78836ac62e813d62aa78d3b5a5fe4b148f24273b7c1444b8508aba1d5c1492da97f3818354a8a19f1be9ac191955331a1bff3e661f1fa62afbf654f5e8b62360fcfaa6a70e3e0cf04beb8a1d871b442eba0f761b43c1311dec75f3175be2ed97800bc888bac7bc360c7d49d82f70e05c8b8614beb7cdfef559ddc6ee345d609f3e483380c1b8c7ac3091e1209cd72c9538a89ef518ce9bbba5dbd0baad54b6566c9c52614807c4fdfab6c34c6b13630f3937268ae2344177be49bd520faa1fdf34e5216cb48f08b5307a70330aaf38b44681c05f5ea5b532783154d3b759b5b58e67bc3f3d52c1c1352ff3da4118ff53d790941fd20bd8b2560e3f2b487e5b1fa3f59d503bda33f24d7fd872bda6f37a85344bcbed2f641c95b37d2f5cdf71319b326b38300a1edd6a4ed6c7991055ac12542539f113a06e43410919e7e242d64dfc9f511b7c19edf5764ba1ad72b1404bbb9658e4849af3e7bd03149cc53d655caedf325f8ed60e02733ab7ada69df8704b2bd909683629c9ab8727b5b1461f6190d78b973692b781931ca377f1d0eaed3d7150c633d6e732772b929a452550a62ce23875b7f0197cf68abfa6dfe6b2bdc85b2ffca322ac96e23ee4637d5b25f59d8b472374fb770ddfe0861545611c2f0d6eb6b8749366c5cc0433da24967b6eafdb7b20a957986f61275019fc8946815314b1820541f2b45c2027bf2e9bb8f6ac9961968ca99fca7ce9c4a25a6f370de50a0e57569cb68ad718ddb8673b5798d92686cd02d7f0aad33d460df900cb483fd1cd41f9a8d5139f2a4cbb4e91ed9340ebbb67e0afc63fdb8f92a2ab2687c2ece5ee15a8ae781eecb255ccf28c2866b5483814dcd393fd43276c762adb74e5ee5e934a2946096b15d6d64be94e1ebc01159ca17422e7484fc348147d511cd3ae992bd47e91312d870f782f4d38f786a90e8aff8d063fbee75a0e3bb4cebc8a32b015880735f209883bd17ff540fec002976689223d37bbb4f3ec1469f95365e07386b0a968fa6af52a57fa71dba20ecf722735220861f10cca9b7ff6316f625da3446cb7c096d878b0f39636831e91b24bc2f6362386ca70cfa2d0178c9a5837511b68a81f905b894a7d7ad494c425df79c7b893b749a708deb08abd3a447ee61ea2bf3f4e5befbe962a3eb3b7bd35a612c48d8337ee3907dfaf2e783b12f8e0c4d2ef9669b116b343bfa7f8d7deb3260d104fd8da5e1be690d783c9ab20980cfae0393a445ac87b82d86a6e70e4a54bca9039b039b339881cdf9d1afe9598feb8f1fd6e3291d6e1d7790456234b6b1cc5fcc030a99757db44e0fbefc26f95a2e00da4270124b9d7640960c32b3712480be17d57ab4db49898a47fca91621b5395502c63280c2bbc4b961496d51a289fcfb4cfcbf6630404ab8fd44d4ec7fdee6725e543ff7ca66c1071c657c857579a7efcb2d4a7f3432aae38f85e2697136023d78cc3e3d4a5266d3e1a4252adc7929a270517a25ff6061b800425180f0809f3e536eb31a0c70eafbf7df73d3a08e9559d5d8a743c1c8b97a626a2bc9798e0fac4148d1b58ae9ec2d53af907174507bac956c4396b6cb3fa8eb2a384faa2e6c4f9cadb298c6ba9e122d45783b0675856df4c397679948241d03158c9cc0d098d0ad89e80a24ea38aaf8752f4226a0746ab59a07c555e3931cb026cd90bc844eac90097c903da7a750417620a9c064e61cf7e49df5f12f1828177872601d350e37e2b246f30a772a6340677c38333f80e56ddeff7714b9be481a4ae5ba2e338fdb19d237c50e1907714726169cedadca17b8f021ec26297045a62fe6e605e91507a3b08397ed80d10040ad8e5f4b2c64759874a51623e0a1acd51db3b62426815eda0aac1531f39b3673a47b42a448cfc567b1f0e69f9229cbe6e401fe3d0587fa3a6088f6dc3a5451e4ae63a84bbac3d3308fc46fc80c4d527a494b26dbc26f9d21b4df1f774091b9a3aaebb6289dcfe3079b66d58d4ff76b0a19fa3bf12608f4fe8d7ab089476ee9d3d93bbd59c3db2c4fc3b93a794f7db639433285ef503cec04a61fed9eba742e1d2c571fb5cb34112f0bca1d3b73b494606d501452da936a0786bcba254f1ebd78c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
