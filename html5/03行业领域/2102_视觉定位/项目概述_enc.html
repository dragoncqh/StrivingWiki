<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed8e2bb3033a01c6c30b0b298843e1a76daae442e3bb8cab9eb3046ac217e2b1b0e036a44b00861e8b7e47922e391ac6ec9e856336405c003e2db024a61a61baf6b32d5e33a0cc16104386da1d2d48646cb300971249d1c9ef90cdd428ef865cdf85d6dd3970b5c6ef8e8777f8c093c9ce01f9a3052b489a82fda888f0c3f0b1829590945bb002079b904f00b9c40ec4237758ebfeeb5c7e70f43f33d0688508dbd845628915781c135f95072695e9cb61edc33fadb88f5f49ba537e49cbab8a5fa540620623634105fdf5b8a749d2d089e8678c5c7e0c0dbcfcc6bacfcd5feb8accb220362b8370de8292bff95eea449e60d3f85d78a3f86749af306f0dccbc77624d96b9bbda06e4d0458ca51d167ee3cbded5694f33c9ce83c29ef60835709848a4ac6f8cb51b57f6aa1e8b3e78739d1a7c8e06e9cdd3bdebbdfcfd6eb7120dcb215dde3a9add7f2becca7d1bced7938560e426c821aff21f0116ad7afaf3eef51dc09024251aa39135291551894aa4e13ac8112990bdf951a0d9bbf28e6faff07c0cfa9640e64b0c114e24b00952eef3a8f29e1aeb11ded8e49d6b533f48fefc7ebf94df1d8bee6269400c3d37f0b4dcf1141195c0c20ab8e3c873cb12d6baf839faf7602a692b919f69cad0325ffa4dfa2e1c64993410786ffc67348524f4084c3ba532452dc8fec8fbab8831ac3f193b1c58f95b0282d2c42fe429951fbfaedc34362c2032a2a6f9dae198604be2582daa527b587c75a240aded809fdc4aa365898b376ae4ba4612965af56be0e3a0def5210ecafe72bac133c073361cfdaa5f47dd3f7c9bcbbc4820b2d57cf44e1ceed90651502ef5fc90b71c53069e8d8c90df291ee1348b56fd0504c36b1f8bd2b81371db8963f893af7171710c2c3df30171bf3f8bf27caaf744a0c40e54f65dfe90da86f18c308a3409e5db171c088066de57e0fe672461243d36179002fb5efd3523e88d4027f949abe13d2716919239a7d42e9dffe0becb33c1adf9d8edff95d9740fddda721c79e07c6b24abf22fd70e14a73653bcc040dc63eb944b6429548bb8884d31e65df19886635f88249e81e33a2622b75c21b4e63cd2ddc7c865588596c3d2c8ba9b4b08bf346e3f0544719ef6287bbb822884abae831dd6bf90c82be8b27d311884fe14a6d622d71eb2e40b2dfad7593fce1cda38daa07b15795d1c936b6921825bdd0f04ab995a205ba4c526049b551bca8b60905705040b3c4d4abe7c024bfd9baf8c95cf94529ed0b912aadb98a26a346f56acbab06e215e173a1bde455a74c286cea56d6b4f6a199d797f5b33875cfd08199a206bb9fe4004ecfdf2f76de9ed6854af0d7210fd3c20a08e2f8d302c8ee6843e79bcbb4ec99703ff78e95abb6d18a18c01f9077ecc0c8f31c9d7ddd869ea57b85a453f8583f7d676b2537608c9b681cc3602eabb1d7e2caf30e158252ef712c8d2a3809062fb4ed03071c2420b8fc8b9353f15e01eeb0f8b61d3502a2b6efcab71884f3197d798363f5ea4a5c4ff05baddd0c65e4d832877eae478db72dbc838f4ab5876eb5d7b932b43ba14abedec9a935ec069a607b3f04b53785b8bdfa09508a0d69e78473b480794ad01f02e9467d6c6710c7726be6fde81ad3c8a4152d06b70f067234acbb66f7aa253e5721bc6650352adc612557fb00663899d83d5f91294295c9d7f8bb8f6a08efd06a98bb7778a75af4bd842510b4eea329cbe3f5d2e871812375ccbd8940b3b95352b5d4f39e87b299224f7cf4ed0b26d7ea2d02305b73b472a25c57263a7b94fca612f929f037a341fb6e148849775107320cb89026111bb92b979ba07182a4635eee921a76e6c49b44213b1c92fd339cb3b30c0ef4608c10c90acf5f484f18dc37d5b35a515214cca194705a41ec9dcf6667f62f10259db6ef105f70829dddda147ded849a56fa9b4ac4726505977070a6181da469f45c6e7033402de31f759209ef181fd1b908ef6fc6f8f3bed1a26c41e9f9f8716d315d4113f3cfbf24c4fcdf43147d55f030951d8cf3cfc366d85581241a79cbeab328ffdd2926d172d4dec4c7860e907b34e932d7205ef56bebf39cd94d320d50178a84bc3444a5343edd9f9915738ee0707577b86e185546f9b6800689b13e880aa14dc203d34e0cc148b255e31296de213e6bd3b760da9e15be2df8b57c6ef0438993f6a28d0fe1254a04ab3f55a79029a66c431876f2a3edfd53d7409ed753d50e1d8a04af1b1b4eaaabd8c6bd0526e82642a1d2ebf289035f05bb6ede26da911c73a9ef0c14bcb5870a17895f501c5354cd485fd2913d37055528a30624ee02887a879d3dc9bf341eb7de1feb80d1a004eaca903aa1a24a26c5afec9f95f55ef0709fa1872381789f6fe72d57ff0974495828431468af52ab92a55611d585cac734da74d814888df7a5661b48e983f5a3f43e384d28fdcb13b9a0652b78f6372e1b68041a0a352bbdefb1ea77d7c4c1fd99898158efca0c79dd06dca9b1186aa0d2e4c2b591fd7de9121ac130b50dc32332458c9c6a8e4b149b9f49293e37c4c0cbdd7abaeba1ab92a599d48c3a0bfdb4b1405139a53d319b9797fc534022279918771b8fda13720c5c88bf786563feea0fd149eb81ac378087f6280e1572a478c8bae69be1094ffabca6d14d153d54746ca4f79afca5008534d002b9f398d52dc67549e117f6fe2548be070d7e994edd3620efb3b3448d3e415b513bf6d3cb9baee43d85cddff33a22140f6ba67556e8cc272c2477ecebb7c85058ad9eedc14aa65e76cf07d935477fb2a94f233c0fbd6b9acd0933762c2970a637528547bf6384591d1209df6cd80d09ea3bf9baed5070ebaa48977d75391876f815099d1bb0b0904225dfb8b83888913c21b16a94f798bfb910ca438252b47eac73a48ce95cff322f6128890a685195ec0cfca8cdf2e661e9643458270271da240256de69f463e15c3f56b13691c8ac15854295cee8c663bcc9afa6800c98675d7db86453a94747fb218b00e24f52ab4eede0553ed53117609204b0f8bb70006db65393fe21157bcd4bb0bb34ef787a3ca4ec998da28897b634cd5a978df5ab5e77b2d05bd7f98dada801b6e7ed7f3af4313cedc44eb5c0bfaba906b15c121a2c95c74f4a2b335f59be9383234b28fc429ef74ddedd82bb3e307092bb86b2d8ad5579d546da1d2b63e4fe25ce1f8b59d956b4bff96eaa3c1dec9df3d8637ef25e0f56a96a9a57b78f5f505e9abaaa5fc26132efd034707ea7a8e150be4efea1d25e408e2920d669a636324a19359c2ef50f0fbfc9428ebd6e330bcb5a0099c386fa3220fdd5220f5f48620ce431f4b5d14a91e13cff473f324776dffe447610e84311b33f28d2d21161b3b9145084f3b5f2957bb1a63b12ef186f5c29b2d6a5eca80d65cffd4bebd4b1266c570fac95b47036798d4ea34fc24730456cf57c828b633b984dfbbbed52b775a8d400765317672c126884a72b3aa2cbfb9d56d2df3e8abb31fa0513d7af8b42df0779811e509dadc2c77ea54b627b0ae0039c85c447fb7cb43ba377308943b8fc92f67cc13486f79b26a7a39ef0185b2c1117ac3b4101fa45c7431f9f6e31ecf36949d00f5eb3653d85b31a4b29cd188917df4325bd122f7a9e350707fb8093c3374f5610be209ae8e177cb3f6d5f0db5d46cadd0fbbcfd610772792d3cc521c248e7c80855ca89aec1a8617de52f891b77440101a7f255c3b47052af512c556519b8b6d7004e9ef29075faff9634c5a7e5df988e1158bdf198e6435c91f0f697c5b618892b1121888b9499bf9a41da2bf0cf30b54b447a406cc80c0f71dfe6f229f9d063fc2f429576e9737356287b9c82c026cbaba7ee434fba34ebfc9cd1ca7664f9df7b774f6478694f7296614223fe4a0b0f2ea3360441325ef8974383577bded63f7b76fa2b17f9276161dc1019a1801956a9e671bc9279b16d5dab257e6775eaa378f86224fea6de161aabf0be786b6b0fb33cfcac2e7440eaf597ed74017154ec98bed2248a0c87b58c6635211adb4d3e0a98325229038db59a9422d1428a9e14bac34703bf2bafba667812115b4dad7cad4b47c254e5bdd46fd574f070b967983a97aa193d22baa800245624b303832689ba91085986d7c458c02af5b55cd38d8fb5ef3aef474eb32a930b4582921351db6422740f24428be43e1070020cb7083cb928343a5575f3eb5151bd64c8d642485bf909b5f53ffbc2309041fa856748a419b3dbd3a9db1982be8a48892e564af9d23d98d3b03bdd7b0ed89b41431cfeebf160c00aa460063ac6d212de55c6efc7f19963e6f24ce332159f27db7667505b8f72bd398bb4eb54dfcaaf6695be6a1724b94916f79967a05e40989a40d417587cc7723982937cf735fdbaa13afbefb212c3a2daa53226240aad133294700f93e84e9fe72957d5d1ccc72e971a8fc9472deb9f8105efe4ea77e712e14356c57814900e8453f963e66c0f89a23af7568fd4cd5198c5e82670c94a37bc5547f1faa21969a198b3624e5fb097d8365632e6ab3fa87c1404b1f231969ed702aa7002f64137f3dcc0198a0dfc80cc2d200dbc46f02bcb47d824b393ffe22513ea4c79179667b14f72866a7362706d077e2be11d2306ce0c7dc70c3c31a3c9d489ad4ca81e984d7d2a9dc3e14fb30354869ffac3d3fedbdfef84ab43a0c35044fa03e644040b5db850e3744ef1125c65691e6ae6d2b4032dbd6afdbb1bf01537d2202e263d58cd73eddb6c2eef17791e724b2da63c2e41d254eb8f5a569f266cf5070a6824496a4bda21f9432f4ac40dcd5018077fab6bfb12aae3ee9eacb3785490b688830379423f13b2410c937469e81c638d44bddd0328636f0bb7ca425e18fc4cf1c4a2a63bea213940530012cae957dbc89209312136da5e029c72bfa10f2340aabb0178ca12434d30c089b1a41166dc5ee2cecce20aa8b5d52b8f50b8c57d0a70dc770f58fd6be955e79be4c090affbef0bb7bd2727ab808d48ee50c0f0142b5a6b48de5c918ce36f211da9708b9e73f81da7364ed60fd9d3ba6a8cc8ef19f59053246d62b972dc072af1ee3e88b9a3d39485606dca07cce256de4cc9afefc44572f7d3e8b33a84ff03ddde7beab2144cbd20a610e16203701a9ef1e22b2fb48a386aa3ed5f6a8812ff956e069af5ffe4ae04e96268c49dde085eb64f1e0c883a6540f69699ca90809035d6b1f876eccac80c174206d31fbe5611bebb3f345a54eb6adf76c561f3f5bc0bc7d22effbfd3f018b608c3ae14c3cd3940b0d959c31f84cb966aa6eefa6299c1468e7a9a185fca2cd88a6db303bcc7d981fe8cf392cc420f59c0fed9b66e11510226c0674723b17a2167be3f5a6f427c3d5898593c0bdf4afbba533df0872f71f2b74d99e60c497e3abd014d4042aa2b90946f9c8405c317db500250137f0a3a1aaffb6aa8e55ffacd46a6f8077849d7c8877d7925bbddaddf44efff7e47df802d8b44be6ea5dc0b2cf4dfac9085363ce93af97e0e86b22e7ecc214a30088151489043eb070ef6d831a51fc2879745bf69d2ead706c8c4d70210f755c55bf9d7a2464eb13446e9a0a8d36e790684b59b024131b93e2a83579e4e45d98646dfa7742ec05fdbba6017adfcd15258412906b92b6a85233db257aaccd9c10a8d4cd5cd9ff4eb4f970299585b039069b0d26ae417da40a2f94db5692372df2423c7bcb91b14e3b0178a1918677ac3cbe1fb5cce2186279d3e3ad4344052d2fd3dc91bc234ffd241bde3a1b57ee7737e8a4fc493b0515676d0534e178384b3b666a71f103de042bdcd28eaca47122aa780acf831e4f903f4ca58115abfeffa9880ca16a2ac8df5fd071ae86f4e2ea26a35690fd64689d8e3c60ca7a4034cd74f7647926e4b089d99164e2bb122f719bc12cd627b7989e87954e3da3ba35f0cd85f71f944fb8d349dbcf829b23d86b9c98e9980cbd037f4ba4a186aa3e626cded4baf84df2b1602e4f46d92727c84876582526c6109efc2c1d0835c88431f9d4d996925de1cf978e4bd3cd3784a38476a188342cee91afd20af7317be180da784ea03904a1206bde2840ee8c8e41073207f299e4df8496660861e60f9ec0c2e3bab6a6edcb88ddaf6ba518a6ddd0d1888a689e8eca19bef4121ede52dfe724ec693b835425d72ba7aed9dc2525479ba3739a0cbc60d0306daf40c27e803e1efaf6c27be809cdbbec3b293372b2c8f336ad5145efcbef12419c5d4ee7cdf22fa2aa643876d169fca5c8faa5ff2ebf3687e1f68219f66d5fc22867de1cc3dd647c238e6fa1bf3021139990a0719adae3cbc52f5fd5314e0c4f1f6e2cf988ae00c36f0bf59199bc2607ce6c5140d0c155cdb282e2870d2561f38bbf9b40dcd811162409b77e190bc4943deb341b21de660ec844e7127a03db8022004a9e512f77895bebed4a71b348166cc3a25eee606180314db3e25d2057aad57bff3ac25416f44c853fc6dae712babfb43394c79fe8343c638436a5fe23e7e6c24adce9ebd8ffce8922554475470e1cd14d2f471ceb65b1258362ab0c94b2a5b72c5de0263d08de3c915f5fb198bc13be4bfefd2f8574e622ca0b07a25ea6a67e4c787bc6167092069e9e753a561d309abf47e729e07ff6c8ad24ded4998a3f082b5b980106571e0730c27277d0670a0ae10f310fe7c474625a195fd04192b27c406761ea23f9a9a2354c417518475b0ac75aa05f7f7fa69c0de1ab7f378aa596c68a98a551eb37e6e89fcb644b27a273848156a6e177a9dbdd36eb505f53e849d269646dad916c42f27f111b878d5b9894b9100f1fe716f6eefefe2adb0686a2180a50bfc64dc43c2c48c5497fca3a335dc7cda87978ddd0f32e009fde8d166215692aeee07dcda7aac55845928e79c8fef7f1ec89615dc1777f7103f8a68c5b3b59dc35246822e98c2a776c2b6a58528aab85c01aab7f9218dbd68cb433daeb6dd1a6ebc00ad921e49832dd8997b372472727f56ef9e3d99c9b9c0e586fb4bd989642819a4f8fe1202719e406bbf1bf32bbb0714be4b4f40f73a878a2bed218ee45f5c7b5da6f9f708968a18a4aaa853437243362a46462de744d05f918d57769673678732fba3fcc3cbadd410795b94bcc5995951545578ce605d501cd3d7174831cb0e113cda24b74c681a02485b1df969f4ecb923660be006f0f79db5a03069c6676f2319ad13a88ceb7fc4fbcd22f7149528bd296c832cdbe8505e6bd27e9504513212c4b9db9f5355ccc99f19872f369f507ae1d86d5a2a354c3afb9228cb35849a8d1c04692daa2e36f22aadd4c0e34d1f0cad33c4ca3db637d02cc81d0f3999ad3d2437b063db86447b4982be51fbfb7069c694e4544d79da94ec007997a87dc3f97fe49d5ec6de67d0aac13a792fff6c59be3882af0e965ffe694673432731294f71b576944400a64e3152a6b3da38b080bad0f276cccd9aab0fe0869810dd991826e484f8c09b252e75d9517269c330c784ef922a6ca206a34f173028a39a2e4cefcdce1ef2c7ccdc986f716c507d9a449ebd3b98c4f4f008a8df140d88e2c39500716de33d5f4b4f11e29b03e38d7ffde0fbc972f75be782d91df6f2ed2753420a2932f8848c596d2aea545baf73f43e3c46966759c6274e7201341d7b1cdb3cbf75c1d16c5f4793136ac5d7f3fb73c03fe355404cfd53619eb13374c7fe48be584a7bc130385de38719e82746c1109ec7986b92be0a4c5745c578ecd2fef59aac1e26edd24e1471fffe834aa86af88a8d5c99aa46f180d120b9be7fe85f9eed07fe95f6323e7aacb3c22afeab71e82a87bf9a0b96aa87965aa5f8d799ec29465db26df6b8c17c5147c6aec214c431fcb8dc872cfcfe70dca589b159a76128ec60e737c150f02c7a4adf01676cc658c74aafd382b0f1717dbca29cc7d7bfc4f5f8df834a9de0481695cf00989427b6fc32fcb1fe98c4140b822452e47086d0f9a32dc12cf68aa701b46e86b176add8c355c2454e779ba025f29fe980589605df6db053b5713ff808849ce5ab52c3629e088931303d2321a746ccc1511f5c8a055cbc6d04f68905860a807349249943634ffc7bd5e842bdd3715da6ccf2efaa979f9366307416b6e765b61e57f690eef31fbffb08da98ba585ccee27560a9af67d711fc0891e8053d950214bffa83f1846ceae96c5efbeb721991ae4cf35abcbcaef4784b65495d4691ccfb2e2668f3c260566c8b3f19bafa67f510fd9f0b06140cb691b651c607a217e6e87b576bf06bb4335367d8196ac091f66e2472c2dc5020981bb7d4cc648509070771cf331cb09ffe401efd0a2e16b41e82040b816aedfaad526743a3812b83816e64c8b1e9ad6687c86f560cb5a361da8f238123094d2ce9b541b52c5e184450729b997f4c84a0f22f18f8aee430d6d88f0e563afbd75bd010ce34ce6acf299f93a557cb11c5c91ea009d3f9699a174fefc1ffa7e1bbb9ef36c92bd255c96d04c0dbbacfed57047dad24a2c7773413a517b33e7ea935257702f03fb5b13744819fc0c929916e8420c08d1544f90bacb5f29ea15a6d055824bbd0bd3b2baf56c567c415b1aed85c941643f6fa8d5cafca3c4778d433d4f207fd114e25d87ce5eeeb0391433332693066713a0862f85ff50b6dc6b14623a287fb7209f697c89f67f78f4e7dfabffb354ba5c4a578b656041b92f0785ab8791096e4c53a0c6ce992496d049c2ca6cfe75e677dda47056c50e78431fc815aa4d27505a84880819fbecab734e71e9b5d1ec3584fb16d04126583c28ffb01b10959a6866848803672df10e10f1bb8ca4b35406090476710879a96ef971cde0f680c09037172c6e6702dc3b55fa018435704b7d9a2a370a419cfdd28240af6d3e0cfa7a8fac5f5c6d4da32451b130d5be1fcacb317c85f2ad8bcfae98a110d3db04f476c9a69581bacab4f4704e40fe9766c538117bf854e2bdc3561d684510df0f20bd94502a1e5144733f558aa346ea7843a0feeb0d62cfed91655c5d67e4a0247077aaed21b36987ad50203aa9a81e79ed65811f464337ec3757fb0a52b24bc2f736784a389bbb71f470a724461322af0183c8d64d32a4ebc7432ec671a16ab1503ce0bc4fac085af28681442473453762663d5a697230aa9a923f6314d84d718428bf937ead0f48140cfb966f74b8bc405df3c231b284edb41780a8f5a718b966c544cd1275a9a30a5cfa5b11092b2b5a619dc07dc2b000089c1da8ccc3b6af7237f42802da1c7a9bfd235099b46a2e5edc0dee8f3c8b41e0f1fb294855ca5c98f587bdcd3a33acce6d8b2f6c2c034093da142e04e491a4af5658d47d13dbdd5c4421e84f870e4d73c02defee2f3e86d5c6505ab445b68669b2b040d96dfa6ae839ff769951b223cba6b0d12b0ed9f8d19516af640c1323d8f43ae6f140f8c038bc7914fb26cfc40ce0cd44fabfa8b23afdeb1944e6dcb0fc2335486a8be9a1bf2d51f0253eb81ca784cf09fd43614eefd45b6c1fd367e5f3a1bea610bbe2ff4e85c8aaf0d02a239320298ba98a85de4434cd58c7703ce771ea9c51a4ad6d5819821d570666a6720d647d449aebaf408dd0bef8b42dc0987ac61804bdca7b6ad96cf7220977d3ed7f1f14e14710cee19b683c9158dc6ffbd13a83881c3ac8c80ea8457afe28e5325b5950ac9b3f412e781d9c0ee2693082e6d6f19b8793502ddee8559c9cf7a091c159dde9e8da8800f51376c9b040a34f12016706bf5200d5e02b0f7897c8883452251de1471a962cc97d3dadf4cc0a2c7ef4a2304b039661154fa74b23070b9ad67abe90a891a6fc08d42b9a2fdf5026c0283dbafdcdbc823acfc0ef8acc9970bb0d8cbb0dd96355aa6545a27582a8d93bd6ddd9a722be8d60bb41f9c8abf144d640b93ff534cb01cbf611ee4557aa8c7f7b8ee4ec773cf022bae1698316ed07017fcfda94fb0bcb71f09b6a14f3cbf9c716014e1b3a78651ff3bd2779aee87b519a16de51a9a0a7d3efc0dc1070d91073ab66b0da6ff72cb2d6926814e425385350d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
