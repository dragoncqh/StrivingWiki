<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ec29f26a3fab936c6628498f8d8e83fffbb68cb791e0d7423bcf0fef9d96b71d0d2ce0e399adeb387f30aa21a8fa7e264e1a9f3df0ccb05f75e1180aa030b850ccdc828e3236edb20f5e6e2ac2148689e825247de70837ac400fafcfaf8d55b85ad22c60aeaf9b4453d6785badfe24846b4eeb44bfd4e4f5f208dcc0a97f74a2c9b339d27d696605a707c1f9b606677ca3edb6d7d21cda0d415aeaea4ecddb6a356f02b3c3d7ea64f782628dbaa9d8ea633c3b2d72fccc9360c2780f48d5198f45a20d4a5fe442dc7f038147e9fc10c7049a34b13d509e6bb496d89567e3abdf72a5afb64cff3ee8814b6ca9170460e14fc58d40aebf858738e7b5570b89c609afd93db29ca1a761574e4cec3984e273c6e1df49fbcdc829fa5d54f15391e648d91e8ba5b2d6a4b3a56ae8053dd0000ffed38a2d233c7e5389554a8a08cc6459bb19884dcc6b8c018e95902e8e4018c7effc5fa533428bfef0760cb929a8ad5e9c53baaff8daaaae6d4f67fa3d4f6a62cd90feb7ae8b9e4397863e9e1ed5177503a7c658d135f5de541de3f656a02160140e5eab86c4319c5ae2d063d8274e8f68065e467cef1b6a2b0f469e096062b4a5d5f5c2b2158f1f6f1f27202664bdb6581ab4fb1c74eb9b92de7ac9f9f69c739d9a99c73b028e2f40a3d5989544a648475ff150ef3a868b2fc65d00ceabfb90606eb6f79e5ac63af7702377e5c6592850da86f84b7214ac3892a1829ccbf31d682de71096200bed12c00868bedefbee7099267c5ba809281ad3940849a9b24ebe562965b76087279e8b2b099e7682f5baf884bb0c39726b1fc9aa84e00d2cc644a30c69dfcb220ffed3303a4c5fce82685a5e107cf602c9191559ee7133a1eb0151014a93715367b857a7ab6d4ac535c4c3556024370d1c7b16f48fb98267f9c1c587520ed71defbb213d2e4532964dc15abd048d5537d7e651ca9e293beeb75d8d7eac47d88ea149f1089656d91b30a66d0a2008bd0e2bb4aa6839abdcc879982c1672200b8bfce812ab78a41685728b3ccbcfc121b8266ec30f752cbee77b9fda13b6aab1c7e05d612b6688175963c8b60356792f80dc6655bfd477d7fee406616bc16c7c5e445c3a7bcdf31c920c15e57b7e1620281ca2036085bd115961d10f1f67a8d16c57db84236aa4a35630e2cc851dfc78bf626849fb75858a77258d8b5a2447334cda21a9482ec90794acc0071847e2b72c8e4102e43d12acf73fcf2acc3cf84f7b0f6ac9f42da525ad3ee6f3bce8a38c15e0cc85309b1d9937b651f4d2ac4d6949570497f12ec65f39bdb9bbd255ba9e95d9f93217ad7ed9263c7394cbe33c42e7511682b5d6c7b28c64878fd4fcd7d6eb1892e43b98c67ba406ccd0173496d76f992a1307e3c8c4bf963b00cbfc6b6fca323a4850b859fb24482eaeb9b604b5caf5f55e7ffd44e210cfac70f76480b55ac9ac5d69b7b58a9b0d19d37c83234f5f4ccaae126d30c7bd0bd46a6b9e07a660341bb996f651835dcc65d08704892ee43dedbb22c8c4cbb9b7d88d9d36a786c98a554d8002bfebe644e07199b06fcfa816ca32a33b5e4df94a8959b14c2c8ab3f7834617d00abae7b3501b225e08790905ae9d9753b0d06b89bfb39b30a88bc1552c83c3d0c3c7da0453f4f5c22937ac2f361271bf957f44a59fcda28fb812ca9335a7a44632fecf1e78157590d20e2593f3bfa02198fb9a266b96cc6485e19c881e6772178a8cb0deb2eaf9b16356a3d909b27e15352abdaa794d62225a70b4bd77ca48a9f83719e524a320eda9f509a4993981aed41ecda584b22a21715927fba310fc3f480cfee597674f2aa1d0f00f105c8f73d67188c7a49b2d2baf801f02dc316261225a11fc09217c27355ee649da737dcff4b55c68c29971b5cc5d2c04e08522d6495c8ea976a2b9581466d6e2d53caf6d66f53ff694d5ef19cc9a0030e9f5767a1ad97f9697f3c29f84e45ea9ae712c23bfe6c30061a1461f509f4b7f46cba92c9f2fbdc76a5f4167f381c6ee9b93700669c186ce1f42af3eeb83dbea2d59e7aaa10ab39c2c05555747aa951019b397f51dac51cad9fc5acfd3138ef8044f0310fb83f488120d69b69e74a5029eb306f040c07d4bc87ec73aea9602f2657e6cb279fb1d8aac8786a8cef5e89de147a7d053fb7a4c4370ecd1743504f6d0bc741a7eaf0b4c8e0a0a509bd679dd23b928b66c57096a4a7ba24a8268b04a3aa52c3975d82fa2e2c6e1bdfa19394eb769d23729a74216873700aaf047e000b1c7676236fbbd02cf8194b963c0caa8caa33eb70c445be585f298bc2a662fe41bc919bbe1327f97f4c2b075d940322b0f522870eaa468f91f9f65762978acb6963b428d587bd364ae131c90aa772b509eb40c1fabf1ee6d209a9585cbe53bc2774fcffa80b12542b5d1899bb4bd45fa1f0deb9410e1e3e92903fe6d678bfb603dae02cc4a36ab305532b620a1fb7023c0b7ad702da2c754aa0fc2134501d34c80ea0f5d4f4502e951c886f4b23a1395e0ee3dc81f661169c034066374a527c5bcb3806dfcc92d75b9c4b294c773e7060aa371be318234757922b34dd2d05932786029477a7a2891eb026b253a4e021825292ee5838f6a85a4e2f296d5909e1a6fe704eac1cd2122e34253d76e8a380637523c9022684254cde239ec91354639ef11859e44ad5054f0a6ef8ac3c4bef24226246afaf649470929444280224b6b3e6c82816488bcda037a873ccb99396cf4a637183760678c97b58df8c70f81fc96b209ac6691e56592ce67ab29ce9f5e0379eeb3219409035210bdf0294dd9be483b9ca6a43fcf525575af909cd559e7a666308d3a1258771db4b3164a91b3272858127dd564bead2ebe0fee0d43282f8ab8dfd9fd8fc14e3cd3c047c067fbfe0290d0ef1058a18547420501c54597a87577b5dd4abd881b3d5db489d8b55437923743d129598e4d9ca80bc55ef11a37d6e8c933c05bd73a202c3beb2d553e20e7e5f5734b82d870be7a5ec4117d13e745af85d3da441f4bd7ec448a896fe31df590f025a8d75ad81de35e8882db4014d374bc1604593536166cb61ed942394113de395b3cfbe1fb4fed3f4fb7116f09d15677d4f85f0ac4effe8082eec13db5eca97dffa0f3dbfe366b8b5c0eccb150db0d67d37f089ce62b7870ba638f2147ac6efaceab93aae9824327f8dce7982cb96119e8c5a5d5ef01fc47539d08b55e72fc84d4fa853eedd1260b7aa9ee5aa3e2b140c6a674e2f71f617d91fb047d98000e1ae2b015c7f15718af19b8f27953ed09c13b423ec11848a6027281840be4464d1d73ecea46a064ca686637d99ce50791de54fcca8df0606415b0c074e17aa18c0232b52cbff23c8fab821004c3e69d9d22a6cd70a47fad95bc97a2d3cc37e466254d09434cd0f8e0b76c9897942560c8f5f2de71db9ad3420abb07cc02324386b494ce7b3c64c8a160edd3a4f92ea3f0bef74fcc00847314b4218db365e1ef399f4c242cbd2554d90fbf0b6ebe1c578de3ac2ac916c79fa96f6020037e1a6523d7bf4228014b620d94b2f2b8b24890058f8b6fe8b625cf58889e43e9575f6bbbf575563e97f015956a1a74158ed2c854fbe12b51df59fc1abc28c85ae3574c7cdd5516b0b9ddd3d95d84cfd123dc50ebc6eeb7a0d1183fcfecb040bd6fa74da9aafcd296326a3f02f9e8510706b821aaa00ca408c6d8b8f9fb1b724eb05e0626c378f5c14066e68067ef2425900e45944ba96a7ef1f60d7aa570d8f57ba54cfe770759906930a78c15887a5f8531879c115825ee63d5cb7a887de35430746b1714f1efae9addf720a74ccc5561efd9e33f086c8138e17a9eefd2c0bd888a1980bc47dcb5d55229d03c5d4f568b5e68ced4200f99bc02d41084b50eb4c7d4f182a41c5b501a95d947d248e35a37f3ca42e832665c714b544ef08ca78651eff92ff05d786740f0be336daa2cd3e3ae7feebc8507d1c07697f32c70f61dcea0aa9726cd2fd8299521533f2d2a04a8560913adeb3685cc5d5c67c7931000d7776dc9042a70abb4d6643ae2232ef72a6912751f8421d3b2eea2d75fcc034d499925798bd859e075f12f164a3178074fff542bf942b3a810de39b75c58b194fee7d86c84e68e0efd184eb1acef83d72d9ebe0b32a0f69c1a0f458d2311cc35f59bbb056e7c7474de14d3d0958aea4bd8acf9dba58e0201561ad7405b9b1084b3add49af0008895d92b5e154a09afa65334b7be03d96499a50dbc4505c02c2215d437ed05d67ef99fe8755c172cb75b0d6641902177e22da779a544dfc1af9f8819c46d4cfbfa75e572462c38cf850380f19b1dabfd0adfaed6f8e433d10a523ae0743bd9b8ec09d03d9eb2a157cd8ee29d7ba35399879d6d3c6ae68515ba6b1f4f68ff0eb1864be932621671a53862c10e540591f509efed23d2d4c235990982872cf1a11ce4858cc4b5a2789f8114ccb84bb2aa4fc70089d3b39a73fd3174f9172cdff4da8d35904b5bebcaba5773c13d1d62eb80c813db3c0504b54882e189297e05fc7bb9878361a62cd14327eead72bb11d5aaca9fa7920e14e22a99c1ac15b7847b94fc493b9c8da94382dbc0c95524c3e76a825435d476fd80696d56c313a25333caf0bd1230354ca4a6b733542793f630175464e863f2b239630144a65f383a97e38904f0b6d79143e611a05598d3d740b6bbca4992e91365268531ef4d894c1f0c8a8f7d5bf5746bd9187480c355d73f1344c4f04dff646b60d3691d524f6bc8cf3284762c1c7dd06d660065560d0d5349edf31f6598d30dc648f25ffeb6c04e852744f2b48e0d2f9513d61c44496f459c937cb781d56a86059745fe38888abdfeab112eab85bcf9334ae2bd59ddec1b740cb38427b4991b34d5345e619e9a62fcd0a55f08fbb0ab2dfdb671970c44dbe42a01f70e23307425af0f890d6c7ea50b17308fc77eee898ffd34f6d90c649cca4328a6e575d2b2b6de6f895a9f8a140b1311401e734f800384cfb226f91c867f412981909ad74f2810d8a4c54140a03070a40360bc23cda28a575e9f9e5bca59559c78187fce2c097c3eeabe381cb00ee4f2a124a70168044db5f02e4ecc042bbe86938e913203ecfe04ad612e2da07af741f1daa377c73f2c1e613a539a3675f06cd62cdaf84659af021d27e107dc45c8c90930de57d14b53b236149945df1baea6431b815baa9e963fd15cf93bf669be060d01bf249b100443abc87dfc6eba219ddd2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
