<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cab0c97bcb1d531e7254518821af9473d8f80bb99025c54485f12d7221f822ebfc6db015c79ea296604f1841e62dbdcc9eaab384ec82e7a4ee8bda5923d64aa13c3a389a5d86a7f31299b19ac93a3ab15206bc5f5cb63dc131e76a0242a399603100126439025052c3cca0b57b894a0e92dae52858ed48b5e26f0c0baa77b2b2c15f3405ab70a83f0c6e6fda32186f233c1eadd87d3e3a51c1dec9604e1acaea249834401ab51a6f1e737268807e6f31cb3cec615d073a5972723743bc7f2b178889a4fc670d1520704a1dcd4f8bddbdabc7d947a019ac30b3b6e262759254db7183b8c7765fd75162217bcf2fafd5e70bf5ace36e95cd2f47c01b7012c1f656cdef21654e74a4f1858697258140708777300ca4bea3ddbda78239d5f200dc9ba3e18654e62a6e69d1c571172c9820f5a3f5506a05b20b10268a290a4161f2f21518a840e40641c8e57a5d74eac76434d281e91b3bcff0b754fb8ec8e0e1e5fc655312984b5e9573df66868fe42252447f3b2ca281560cd78129329f9fad7e30f699c65599ab51c2f42e6ed543cebd08d6dcd9d79d8ce7d97cac8f12dda3f80b3105c541e144d15473d136d15721b79aee0bc14bf383cf4022ee801bed1ca652492ab25fbe110fe6eb0a9f650e58fba397e0eaabbee6305d5b9bbc33bd6ca3e9c8745fc4eebdff7910982f84860d2566e969ff9edf59c48293a311ecb3dbb43da86569c71d1fff801060b39aa332d011b5f8f53d2a20be7a70ab93366c9b74ddd8c8a6d116d27f22b977cd9053b08339be0b393a072b7d7e70c307cf9d2fd15e031801448a561b1426d199fd37af19f7a4ea6f89a3524c77bb8ce25cadc7f474b1af713942fb174018e79cb4c085e836880164af9b00e2ea56f97233d688d87ac7cc952badb4b2b66dae39adce3df4ef1d70d3c87a832ba497c4f31ae664f9567a98ee8f3ae4f70059aa1a513a3d8117a4dfa126b8abf777fd9363c81863a0ac4bde8101306d48108fa5827eddc5da0c286f1f367e253d8f63333d995f0d6abde01cd19383a274c603b82a255025e7fafc6d63d419944aa83182048597cc1fcf1446d721cbec26bf33bc906b97b16dcb2ca1a253da6f94f52034f694944929fe2bbe2888edc7e533007ecc831fb1044210b7b43815bc00fb62eab11d6f8a80c17febde8d1ed7b61cec5e53df7b440cf335f0c144289b0c7c461c1433570036124436983b51ec858f0e45558a80c0ca1c809541db7b200afe0b76645c40f86b0a11152496a70ac50393c64454f9b91ad8b48349471aa11063beba15ee378a7ad012e2f4de88b482c0a48d0280726df75fd0993f42a86ef28cd3bb671a9ffe94a901ec7b8a1b039f17dfc3c3061e5ccee78fb2210ac35efa3a54ee9540e7d8eb53df31e0e1af699c53d77dd3bbc3125d82ec1b29e2188e7f696dd51de97ed66115cc3c2674faf11fe5a833930e7bf3c2d6bda2618f0673de4cd72f7a85631d9edfb98fd1b37f0f2f59b7cc8c83a586335c06b1bd993e2518b42773d06c188767b29cdb61f44aa7ec30b301664449d55bf66920426678d8234fe6d6eeeae4aade69af0ceb0a48617e320bfdbab5bc07ee69fee12f932129ae76749fd8efa1e33e89d4ccf4677e2975f3eb7094c32005fd5cd452efaeab5123ec4b54d4c57ffcf613f4aa3efb234ff84188260b232ea5dd22e9a75faafc30d0c20a6a7dba16a9e8c84e24e5c7b27f81e9a964b81dc207abbac372aab52df05205e5cd501678897abd19ea7fa8c5ff2582855a992fd8c50099d237f5e636d916632893eb4280dca13f29824084181bad10500390c11564f17566b2abc2f11e8c00eb00495c90b5bc322cddff76e0577921572b751f33b29e985404343d394334f76650e01ae6957140dd18ec4fa5d5680e07facae2759093c5cc5a4fe5305bd73fa3897ee528ddcba99f10e7a69830e7942e7cd3ad1e154193842e1bd9ca1da23395aef54a7fdd75c51f0061384b4bfb86541284bdc45a5946f3a1fce0057f9436e7ac4848e36b24f2db7fecc53a9a588a62dc563876d2f0a82629a7b8edea01fa3f53728f2ccc8b18654e3754e091fb0ff8185f68dda260b4b21bc60455928c6a7732c99eecf24664a4db38055e2379a0eee5cca175a34fab68223b23bb328cbbb42bafd1e214d9df3edad1ec5d50ab159495aaa07646c1cc10b4ba78e646414f32359f634872ba9b9c868484b072519a0899783fd5fb1339639668bbc20387aafbf2b365ee934216032b98db3f335629a7b672b8461d4aa3ea87b50afba8411bdbd1fa7a7c1fe19a3c6f39d8882ed5e5ce976af13aadbb4ca9a2cea17ce38c2e42786b55a355a144e1587ad6243e9f8ff90784466eb6a50ab84634597d753237eff6bd1ce06f19b1189dcf25ba3853cca6b3d2321e3a441560e121707b0d58866665db85bc2bc15c96ffbe99d86b13159cccc1c2413291388a3acd0f32668459209c6d655b39c8c4f08191c06fe3c10c36bd045d7fa637b5c74dea7189c287716c021d1f847df01e6a5cab9160641c665817954ee8a8308f1c4c759fb23d5778230ba8d407b761a865b0ec84095823a9de9781684e07eb75103cff0f3a2cf6983d52911d07fd8a07a22f7a77d5307198805aa59206dd07820bb279aa21d8153207539869514261db6e75708bf910b989e82a080931b862aed39bcd4144762451ca730ef1715aec477f385285f7e9a5d7e1ffff068ea9b3d7c9c2d592f1cc9c75b130f9ac1c10c8ba4cdf9ac0aae6a48bd0bb3cb1803168b09fcd935e11d673ecd154491cc5791d71a39d95ffdb9023c0951316dcb6455dd41dab8b2c31343c5a89a9fb06c9c0a0592ac7dfce8d340276b9d5f2f978e534617f02fe6c110e891ab4ccaa0da5f9278c20b5eae842dd8550a7ace4167c77a8bec6f70af52cec9c3864b493621da00af2c83e63292eda97a59e984d825310c25295e0c58aa616e56edd6c2911e2558a6a9d553be8ab7bbd3877c2a5516c6d58a6866c4c3f9d7c1b39799b66cbe96c1ef9020331b3431d6fd86c85141c5e0f101ec7d617bc5cd5f03abd79c9382d8081ba2f5c35bc3948e3fd42303f6cdda54c24b567fbda44888883e68c6becae9188e4f63b48cc9d9a69a6c7e6be5e3f43bdabcab0d689dcbe83dcd2fe7e12613f3bdb1df788ac7722991a1e52aaccaaec13bcc83846b7e087b9942ae23c16a5cc0c6e2393bf55741a36ae16ebb611ff26dcf6f87dcb519f6677d557d0371e6522e5ff858abbfaa2c27e09e1b95818eacef2f34750832741adf606ebe683ecee614df392f2ab487cb4b726279fd4af7e0d9e4a3a0c1ff865bed6a1333d4d1bfff69bc8c0df8eeec72e4e530800764f5e6b8076003bfa89c9b845405dea7012d9aa67c5851ccbf96b2bf46b8cf09f37090330e0d7715ede70c99311f848c3acc602b2c2cf4a6ea47886355973fa2e49c91aafacd87b8ea94e2819203b356ac95f22f61b5353603065fdb8942335382e36580756cd39204c91d0c986f3947827706b82d113e238f18c48c19c2c58009b5c891b1420a87a72f453c03fdd9591bce33ef04bc280e0a1ef04a7e58a443f32233151a0a8d41827c69b16f6220e621c529e7239e12f305c10c8183c545d396107ecedb17af962fe2891512821f341ce6d9e7e7ec42d22d8b03018b2840fd436396a02164eaeee7ef2d0f4f64093a7800856e1bb7c0eabd1202ea56eb888877b0226549626a32db244a6ecbf502e3e92117150c113cb43b10e1af11b7fccd37f11e399a2f9743ec780af7f09a377b79fafbabb9a03461a9afb37b205ea7a0726ad3ebf96697ad993b58d4fce7c2d9b9388b8e3b2e7cb9b252008d43cef0b9c4f14dd551760c39b7a7965f35bde24d2b280a0be1b158a669226e0d7f6cb655e4ef3ee59e4f8aa21f17f562c290300041257af0c4a0660d8752f6155ac54e6cf23436514139eb5f1a5be73fa99bc3bd343e3502ecf6679a58f0c3c2d4a78a171bab62f6828f7a0694b81894b389c3cc1c97239d77ca1eef57fc27bfed825c7549347108e42ac9df52e3874d769fbf1d5d0f7c4a66305e2f1ac2a8cc7c1f046e0dded54da4b288ebbb4d2fcc5793ac603291089734eb3cfdf820f55e756f899e9835d6aebe39282ccd34a93a500311d5b5c9c0a939d1bf522c548060ab5a64e658ebaacc490c010cc64f00e040161321180c3e253c9ef69d417840c9e764652d093d20ca502eb191a6f6f1c3d618a15dfc9d83d1c36deb96b2c594a13bbec27171b191a4492e8eed10a9fe02161c004e600eaa5bb8d6b7c6026bff7d6848ff6431b220f37dc413a0e6d79580e63d0fc35c36d03dbc1f6f7c058c3ae79ccd0b9fda7397bdee667d9ccabf7daee5062e5beed02cb6d9f7deed144362dbadf7c55bd2eb61b825490d87c0df6c1442a9a39f442ff9d5fcf74270c318e2a2770c1fcfd3b7ead4670df347470096bf6dbd6bc4d530c6064d8913c032babaf4bee9e6502d8978d1c0e22cb596df48da407888e403fee144fd7d0eea37ef524722f9509e8cfc9a412ddfb64bff4e409095685d2b16aadfd3962828f876c907a7743ea77ce5b61c064d30e045eff6f0ce346f69393782ace8b3e77bebedabe2fff40060743dd4d4b59aa9aa1bd6ccb76e823a492ce9d8ca7a71681f0d189eb69cad19307abf1ee7e8f0987f4a33c853565b8965991b0538cdf9e075e4d3d426781cde37d952586ff0a924eee4c81bb5e4b32143f46dd1c056a538ae1afec1fa887814dab47be71a8d21f7f628c0394795bc9993a8af757a680456e4c98ed1df2dd75d0a7bdd230a4ef641dccc95ba19f2584e1feda41275bab48a558e16f3a6444ee7ef76e7d628ca220e70d897c109871d8fe9564e0f4e6b6be9028af821eee5bd27b4d4d50712cc70cd7737b9be04cb8f14e1ac45ba3b8b079dad5cc0ca3d5d7f87d34fa9f81914398fc528e66fe36ed08ec1fcea015df04949e22539f7dcfb3e7789e1d271ce0f056347bb797348815bfc213589b50c13eac33316d29919443b8b475e1f2bcc5cade5153f6cef5a120dc4637353974a2716db82dc704005524529fd83638aed247d5d76be7f65296e9c6210c6050b768964c6123db515113791fe39ef67631e3d3a26af6b78e1ff845a99fbb2292f4c5f7f5d478155a27aa897f3efdf8139fb5b910e40ccb910e476f2983faf7aa4677cab908835e271052d42379e5d2df7e3d34becab51d972dc4afa28f5e6e4382165424b0b55cafb970793d569e7fc9d7d5c0fad92bae6259beda370c577f7913c5959d19124f431b52b4556942356b4483756edde2b2ba179822e267a51e64040974701a983ee6b8b8aae39769fdc35e0252dc669d3920ec048fe45ec44f20d80a4c96943c330b4a3bbb7a478bacee59305a3ddcfc84f7929ff2ded11d2e236c557de1766ff84b5e32c964cd4430a6e9470763d4e9fcc907431c3165d4903c2823f6d3c7d28a3b2780748e6d569a93305129897cf2245b35287193a0b52252592ebcc69d0a97a79cf1f3b03f95ca4e3338b378187cd136c6d88af96424774eecc05d8b919b75030fcd81ec746533b696763b1c32acf4ff43fa55d8dfe64648cc4a309395dc2bff21807a60d5bd9ff3e40fd9ce9592a7c6bbe6823fe4cca6e7aa29d42184a506743af2f85cfdb3ebc9d66042ac03a8e80c31adc61e1eb47587240815a22d81d0d460677669255f9a2ae398b00b71b697c8416f6fae96adca86bbb13c9fe2cd96e314bc42f04694bd1f4e38dc0c01a107bbd124f6658848b6ed0daf0f81873f4371fb658858d72a2b72b961dbe33ecf98edd833d954db98bfd2963e9b7cc8135ebf6a6dfadd85c0046b7697bcb0346985e1e79bfd94970b9984ac23b3e8d0f9164f31e21bb034a2a5fbe5f27a83d591c5e00b4aed326fc52db0303bcb633571a29d7e7cfb89d3baa4a61256db4207fd787a2daafd19e4aa1785880c9aecfc521cd486d62acde72e2fc7b292fb8626277fc8d9dd30e6d134e8023829026781775ae9d5237b960e60ebfb245c42abab294be68a29058f9e24b02832e17ce3198c0b3dcfbcad52819e855f719f106de840cdc8e2c48aa675445b4904f8716fe6567792055678353cfcbfcfc56bab06445bdc0dbcbf0012507787d237433ee916e88b7a60d627a58ba4fc3a7641b0aa3ffbe8160dbf73760d4f8a614bd27151350556feab67d03af83b148532ffcc4a40c68e88970db8306c7d9524f9c3c6744596ea255002a5ade6c194c94a1736c60f9713c232da0d631ec3a99368926521fb979880eb0fafacb5ab7dee62fa8d0431a31a4ebb297bdb41b0a5c0045266c00d1ede1c9a05550f904660c049d9b74773a0a9f73cdbbf9518ac0ff6ebd148e1d579225b599cf83740500a5e7b5905f979e90e8fb07779b8da93ce956961bbfb1a80c12c2912eeb5adfd1cf330c860c68d028fa683015037ebcc122c56110b42badbd458bf44daf0474b0aac4cf874b7192fcfaf6afff844b73f22ad8249c9772fb7f3fb0561674aecba4df3f14aaf85d9218d4d67367056c361d2a93193dfa967f87861f627ca03910045a54c296da975ec23c5142a4488a56cde777266c6c4ce1c6967d331f3db3e88a4f82a46fcc4c387d8ead4b779d87c5eed59dcdd33f63304a5589738a06583449bb4a05d1082998be8a20fc512da3db2b40b3583e6090d5d5697dc32059b507e7d3fa91eace7bdea46c2d4726e38f61be2441cfa24b7d970e8fb750e0dd525021b161b9e2a581653e115a69b649477c64605597bb17e888dd1827a957e84b1ea84e219904210e8fd066ee7ae40674bc841123d3e9ac2d3c941bb5dfc7c8f6298eaf0b58de40c8b377063c9d2a57627e547e4c3d21d6c13b4485046df2fa402c921d9de911054adddc1902c78b5d5df8d2801a13067d0b748f588738dab1df4015b2be9db2941fb07e1af39b2bb94e7899c73eba6936b2807493a91aeb461c762c4f9060b713e18217f266a8f59d58cb1bb187f89267821dab4692c8d8a5d5205a8ddcb2f3b4e8c02ae0a07d7d1fcfe2a5e18485e391c005e9dd3d26dbdf748ecedbec431611f9fe1ab571a6846b6fa62039b4f92c4af68cc5128c3082e46b3f89007916631f70f4c75cdb0ebc0cc4c5f7495ab09272ff257da8c2d8f61b0d758aad450eb055007375e10ec0c8dec37f7f994f035489444a566c4a458cdb4622e9558dcff124b874cf32693c74b44f2f01253b96f10ca2af615e819305c5c9cf969c4cf47df26a1d6baa41d16778446c5fd0d00bdd351c497b73cbe382acc730984bbd56a49f014c6727392f407b1df94208c45292895ac3524f6ef4878d8da975318c20e8b81a79179123d737272ab570edaaa271be4e8e25e3b531ec05cc880f9643f35b27502651342d318bb58c50cbf29b3c559fb901b204e22b3ba241fe84901e89c4070cdf8c9d01e4bbca8be6c14a7b77c4da86dca7cdec449509f7d2ec3864a3e6a3fa52f2b6d8148dd5acf3005ab4872ff0f84605714b71041bf87d7ca539b0ac2ead3074cfd16cb5133837245bb17ae7dc23f75f5ea16f4ee5ffaddb3c7e7de7461199cff7ff352fa8c6ba9f566c0d77ba2ef49ee5619d16a90fdeb24b3661372262476260b441ff1ca37e435122f3105fc0c502b92ee51d099dd58ff0b4f063b36f591c91406804c3039565d670a56f141895a5a1fef5587648029065d4b385b8485276b74c84c183f85a4e8e502120def7c9ca6724694907557f28da36b6825b391facc80859bc2f5fc8a28e1f9e091aecb6b69c7472554e4aa99b5d592ad1bbcd4d1ca0afde2d64aa2846d9bde4b14086a5bce31d3634f0c28887adc919c15455b436ea692b40959e1e4604b16bd6e0630ec33b361ad09595b049366dcf771cfca8cb604a21cb7aa8675ad43ee7ab62ad69ee3d21a9ec95a448223d23b6e5ed2e7ce6df05d8a5ae355d43ad110b69db03143191cacdd8ea4bb11eca1652ad1713f0950998776fa31be0dd1e45ca39e28ef2b5e8419232f648b662304b2a90384679fad5e615ef8d9f8b9cb39024016335d9368af4739ba3da5314e24821ca184a01800ae3b448cc2995a280a1fa942e97abc8f3f33ebcaf466a6d4700b1320c41b8adf3608f5fe6b8ae672ac7723b022cd5e142772c5169c8bb55f75250fddb59e0dad72fbc183de0a3a20f1784039e81f1b320a7ffbd934997c372d2f2877aab8ca7aad4997066d3817e8897a5c3a4b3dbb05ca0aeffcfb1a41aa4c14169787383d68bda639b64ad7d6046a03040d9aac62eaf9aced3cbeac17a591c686dad694a5f211ee26d100ea477f8053fca1f0fcd022a47e110e2ceec9177e80faffe5c955d0716849a3fbcd341d503eb0c4e341189f408021afedfe15af63784b61063b849e8267e4d37a02675bab4cca777a5fdd9d502f9d677c81a07dede60a272f42959857933e08d21e992473c5db62bb4f7a07d406beb0a2f4b6758af9044a21b4b46ba6db3598c89a9a0b743302049d42113bf283a5a0492877fe22e0eb7d10d1d00b67ac8bf558b8307dea978f36a5025c134cfc21805e513728fe19e0bdc638b27bfd81707858e867b9e3255d66f56ed83cede3bd3e195bfb5f9080582bfd7cca55bc46ebea6748102e80d61b9cdf6d86deef5bae756be95344b93c4f52931907433a017fe2b1e4bf8d821a568a7caba12f70309cfea314f430ef66559d555c9859848d290ced25e7fc0d41356f0b8c78421beddc5d2a907045bab447e169e596e6f223a197b16018eed41438aa98c70cd3ac255cb6a905ca19b07f67dd779194f3665b5b2c0f0383402069ee698c9d515b2c6b5caec3f92d06c9b0a9be02c55abe02db9804b695c34c729701bd53c261e335003aaec83e27cc232b23d69603c7179aee42a13e82264c413bc13fae67e16ba3580ff96d5ac1cf9182c4798a65003d8b2764349b54106629c721a3add5ce6cb22172a7c22c6735640d3d70d9df2bfd5e4d36683a6b814159c0f0148069012abe43cec7ef55f92e93e09778f7f36b669878dc09ca17e0e229d85fcf02862f54b2b4bfd05987b073597fac09f13eaa145812bf20c4ab155b09f633b6fa4fe0d8586eeaebd546771b994f1be616c6797185360548e3dfe50280b71d6f78e1e91988211294d81e382173a4c8339aa026f096fcadc76cf0872f66f5c40e533172293eb36c999a07243a85c6e632fb03f50952c5d588fa50904e9d48cc11adc504d2667b02d30ecd69459d3685c3475f8fa2dcdc3555b6cba4da158af2deb6d4b3e65e33fe30ae12707e3cfb001f418680435cbb842edcb05f4b2082d9b8d9bdcaa3d30efa449ea48ee859a44108100f2b2c8643c441f2fc13f1b72a039fbfb9beeddd3723edcfe26de50b10e534fa42ee76c874c69add19e397def33e18f095e6d893dfb247c70cfe5a571e63066a47b7372bbb9b65e4ecda960efa4f7cd05ade38cfff8cfbd1d5f202ed522c6c69f64e5a6bfe68eb67d75a7fd6bdaa90414392569ea02a3e2c3d0a0d2b2bf01c1e184f1f9151b9cb629765b23fcc0099f30da64d5fcf5bfcd3fcb4ce01dc124bd77b2acd6c5ae617be0975728599a6d63f5bbdd6418b60f8e036950c9dc62c6f4b5c22ef3c2e0a3aabcfe324d4cbf0dd176bd10118cb243c59ad06aa1849796243c78336d888d5a68c6a9e869fd0e0ed36dd5844f3006406fa9908b8768929af80e396a0e7157ffabf4245cf151e2b6975a8d187ea1ae1c2b44dc2e72247df95a132fbd17ed97c9f69a28c90942bd287987e502bb69b5b3fce660233755b11eb06edc7bb611e1dced0a7cf7140d4274dd11da02143e1e4175f797adf081f7e95d2df3d6e740b8911c43b271fb5347e7000b8fe5183b370b2f1176509e71f5d2798c195701d59897b612478cde354713ede80b1abb5b7a34e1f64f8d2ed5ac1879b2e26c9ee4ecd6c84883123272676908de37e4312d5f878dd89f3faaa28638e22e0fb54c8b502bed2f83877a29f35bf172d1d9bdd09447e79a1e76cd420d5747ea4ffa9a16ad3ceb1b881b2c558ec7e8fa520302b4fbf7e4ccbe000e0ce6736a6b9d4a6b01126c47a1d006c6017e2dcfa1402b6721b09fb486dfad718f4becdf7d2efea58b594fd2d6b18ef93e4bc8d35dbf15d3833ab94f81e7a54c030156c2858cbc687526bb3fb5e5300c43aaa890ab9bcc581d71dc6fdf48d8b2aec25963efce6878b37839620f6cd9eb498bd3a85adf6c7061f3157d6c9462e5b970bf07592c21425fdb8f8368848b23704ab3c1f8d4515628d01f7703ccdabc39f3cedfc39505d3d06053ff176681c47197da4cd3d4a47dfd52ec73d4af56569673a6a8551ed0a8d7019a1d3f11a2e47fd38e921a60e17f9f9c0cdff6be764027ccc97635184fb8454d39dbc2b4eca6c318eed9d945d2d4b56d75c0f1d5bdac6eb945b843328b15f09b9069dcf25caf3ad5253610a80325b610d5813ad4102c11304e518a92eec0236bdaa6b2b16e7007ca4ff47565aff871e31ce51f666c7101964c45f3f44950a1b0747b81f43ecddacbd0b9dd744d796c3c5a8dd49d49dc963da4780e2fadedbda0b40de9adbfca0a9b2c3fec48ca5f6c129244affd05febfbb9fa901275e52faecefe6d0babdc4f189cc4c2731fe84a582a06a026c7a96379635f03e1abd15032d8795d3504418fc21659345d86f2441095c0cfeeee1588798a39292fbf09b7c9c2220891bf3ae30cbef55d8fb17ef6607ec87c164110e088629f365341fb02c285a7f3b67796c5548b9835b25c72837e20bed96bb307fb9efa5731479ec190c82e99e7a321b4d8505cb51fdf3d8c9600b67ebd662932c7b7d603bbeebd70a18f4e3fae276ee9124530b851018de6b1bec7f92422f0d7182ec8438610d5f570c42091f9c57251b92971a995bcab95ca6c67c5c3abe96493a71d1ef659e95b0754d6c7dd830cb76b8305f92c1e38e2f0f9bec119162e640b020752c89a65cc13c219b6b38b6f8d66ea42db84ed874709366764f5937d4d3a2f9305d36855f0f288c8138fb28535ec112b3e9ca6ffb3c1b1712606bcabecb2f0d73c6787997362dacea4562710ea3304279aa062ace510c75ab5cf1c5379e96b0c92a43084b3d5bbb1b98fa7dd585a45a31a8499fb0c9453fac7204ca903d1fa4dd53186ba48162544fe703c2ffa1bb0c4a13161639cb2cebf677620b43e6fafce98dc0a686097c5382cc29ef68a3796562a65a1829c866b82e6892269e815f977cdffafa1c843b13c5dfcfee872edc6bc32cda13b6eeb4a733ad3cf96d682b5e781d2d190ce03ff8374ce6eb2ca8f3f0725a0c076dd4b5721fda138591359464d85bf1afe2f93f04d967f7622f159fbf2f9d554af1b7df5c4036958472d50908de09a4ab9c5d79ed32979069836d86214449e5d78c58b509107bb3a74dc015c940942463fb081a6726c2712f7b646711b81f513a87a3781e55ccb9df8d366c4122804f88d3391163234dff326a764253abba2fe71fd27950600c607cb93630e8a8aefb296172276a60e5816ac57d4a2b3bba9387f93b035238c30af3c87e82953d31b2f22d89d370004a794e724b56746569c036bbde86b9766d5a02a4bbf5a36988b28b71a55fdc07ad72899878b40aadb56623056332f7bbf621922d8dc02dc933c53977c30527b4e2eb71f7d2169d7bdbefc96e97125e2346b91e7fda31773db229aa6e02c87cb11dc6fe052f53810c1fa78bfb1d40cdd7844a1f2ddf82db2c39d4c419f94b87c7cc002f19e884e094c28ca86bd12f5e23eca94b6ed3f0df068c8c8485473feed38b9f2b5c0d9de1669133eafb8322ab16de17cee0eabdb30823c4e366f77290c74307229abb9b4b7c2e186312468024899794f3c4887c0b636b7eda1e3d7294fc8083d58801c8efa9e36f9f78fa4b292e145634ebf57cfb5e26f1c36c7e6f74fbe7c88a2a87cb0ed1d7048a8a5eec23c595a67c8fe89755674211c790566ae0e36ff8307471cbff7fe8fb6fbd7eab8b934576e1a9fb2fea8eaa684bf3ea29c56643f3055d0ddd1abc180916ccb53d44bc571921d3b56f46a01a127237af16b5ba528360c7d214458111d1d51fb62eb1a678edc52a2597b071e447750a9e294eeaf927fdaf891f0a31b6add46e048dfc0cca0cc825c8edae1912dc802797df7020112ba9ec22fc2216cc5c36afac2287f92aa653e6fa2093787c027dd6ed7b02e11cd48f6c15300dbdcc7f02b1df81330b7e4145c851694761344425702fa63391e37ab59271a70c853b6a2e8f510af8dd65b9077cb9d5331caa56fb0b2e8805297e6f3ff8fff66170d6339cc535c7165bfa5feafe9fbf6833424152c529982210de071d571076ceacf8270253b375fc7af4c3405a4cafbb2a607883ef706e19c9c2b35b4dddfc45d6d5df82fbdd7303313dd50064219f5c847eb35012c4a19fa8743a12d4fa2fa54ea7003ac239b2e076a653f6668eb99c7d9daa7d0026dc3e88b9dcb4d38290833874fb2f76208ea33c9683a34c2639a48b400276305a9e686c4057f04a43ff4b328cef34fa601ea0c2e84025ae3b8d95d7a65c582db2a1bc259c4f2b5b359705770fc9366267fbc3eb5357440fbd027836d78dd37381cdcab6fa9638c58cbc6a7c8d8e4fb89917f8ee24ce57d158054a661bc57ce12cd26a6357f62aa3ec477d83f4afec145c63a621b3bf93f583409b9503e485d9824fda6d71f4071c8bfcbe09efee6c7e2fdb04f8655179145248a5700fbe25204698963278ab2c43184ad69dec654e38063368a4b97f9950147ec323625b841f89e676ed9caded50e2fa561f3ac7dc44c614634597ae0294a42d88c665a03e72feb6ec096d06654ccb2ea787681ea40c1cc8d98802dae091ee0fcba02f25a23b25b9a1bbf561e66d080625aaa23958d31e77f11dc027178bb6f697f11594dfeed3341a1f33afefd13a41c364961acd208b9409f6bd8ee89c3ecd4b2d46325bd1be9047bf6956c1f7bb4cdf8bea2f7f5887495ad30444a7aee79aa8a57364e174cdaef5596ab55fbb0dc8c6762954ddfdd154a7128d06045dd728abbd24e72727e4828b0191b525af90a58faaaf47b611e15d5f481836e0349070ee8fcb0fe9bd6cff99c1d81fef6222784a6d2ff7cfb1bdeccaa5fd8d3f08ba9cb7bc5b2d13649c7841798b48e0708489018dc0aba9e1e19f6f451d153c5f0b031e6eb7dfd0376b0b5030d5ce7a409d0fc186677bd5aa0380488e7fe95537469a89f4a0a416dec2269b7d9ec9ba1e51724d08be2425cb5a150dba41da89dba43131986025ee51acfe27d8b7c2eb6d44962fd2a88e9b44aa16f46cbaff693a3f736ece41b0365386822beba409f9ea969884e22b1e19e7f248e3b925fbcd43e0dac94985dbd198f3abb86eaf744f339db21da3f7d62c7bca2041d214d31cef8fe1ca18744cd396acc02c9317f3d0372d2faf5c419","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
