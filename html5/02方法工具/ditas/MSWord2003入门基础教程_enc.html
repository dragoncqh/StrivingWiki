<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f9ff1f941428047a2abfd875356e7283314603808926af960f0638fad6242ebb3ebf56b23e6101a05e2cfb17b2db420cef2747b166fe44ad36d31fe29c31b3bbab057a2ba6ee9d071afe6aca4239340a6ead424f60292942b6f0bc3034493077343dc42125143b23643fb5260c35ccc7a0bd0ae51b30f6c3033fbcca329861bbd3c56402537f5c913144970a664836f0e3129bda21004d71bf04817dd1f73a0aea269af219f0bab82e1155b80126a7b18aa59097bc72df2eb2d25c6acf3f8af660cade92aa6dee6f65a9995067f894ba225958cfa5fa3d6ed4d8ab20222e140273ae103d92d5344f64e34f1423ba6e5d78074d2b32f2fd06cf1517028898aed9eff1474d73630d5d58be3c4291cec8fd2533056c3ba18952aabc6912b279adcea7ebf6c2029362732a94b63e28ffe803fc425257850172296025b1607e820726c7cc98655192b51ea3001ead7d78243bae5980eb5c9fe578d533ece399aec49d2f1a4827c83506ea415c9747fdb068df9c995aae0f3c6b9425d3d498b09d582d01e899e6371c197843985e0f27bede3bc94303d2b8ca515dcae00c70b3040bd1619079c97b84a3ba7b0a464f353346bdc28b40df651e36436f38241a8ab04f11d92648988bd18747b66da63738588baa86432710428011289ba926ae1d2a0de0039c0060d8c24ce757476fdc0ebe260543b1c7cf66553e58700a0b3e2468b11eac3028a61592480388836fcf56eb52c1dfbb9a77f20f6bbf6151f2e21460e96bf1bafc3a6828b224253033d7ef39ec86a32d7879237231c0cdc49392690951c1201e7fd84c606bb8ec6c4310a39675686bb3d4e230dfd9a50cf686f8e08cc3de4674274713ad71589f1612434f45c2347832e344d30bea6d9d32c5cabf8b4092c06dbbd8a9dd544786ae261400a6a90fa49b62e222523c2fdb4db1f9ec236aa391bcf8d6e2015af8e2c41891470b425119456e710bf628201426409f9e38d84bee419260f0124c0bcbd78985b2e299d11b5e3f50cbf32f66b66e508c3c76eafef740a8a91c317ece000f17f9a4ffe23ff97f5d5776a1acc9706958d342f62340276cef696aaa4d6ae90f5a47c4af04ff1b3281e9f715bc2daa88311da86a41ed932ea898188873861f4554b2dc519a36f6d3bdde95c52433b2045fb6c5fb0099952b00fadc83c36b6a2e74fdd53c7ed66550d2fcb4d1904bed298c23f6270f840852128b3dad99c218d6d71fcd0371466a9f77724c67add64ffcc36b2bb171cc5ae599f852acb1ff1bed73ea5fc6c2015eb5a1cfed66e3d2d9dff796a4ddee098a85276bafe3974733752ed8257c1373b03e96673a7dd8cfb934d3348ac778279068cbb7ab53a146a747d0794a943f54ec6fe1be8f6e5cd6db3ef4c5b9bafe54cbdb9b5957352020b7addc376697a4e62723d68e1c65971518d911719ac7a6600eb9eede64b7f133877e726f41466ca0242fa188e5744cfbde79bf6fffd1a15396514607eec644f45a4a596b2e43e846dd1fe36fcc94c8ce2c8ee2a695a966c82a07614ecc08b5fcaf21fcf03a7cafb95e46f905a4a47c960c3d1e1d205b82fbe2051f1b1879a6b76de6995d808d9d8b43e48325bc3c89b0fcf0962a39c4616a01199828cb71bb0f61dcf5113dd422568e0298bee1ec8a0166a9967a9aa61af07ffcded277eb40474ac283f8ca9600a814561d0208f25aa667548a2c78a2f2335ed823c446f2c90c5bfebda6fa40533fcbfce0f6d8a6c85dfcc6daafbc5cdc94c3939f73e510b7c99d6927b82336945292646aa3e72aeaa71bd19f49ec4a755745783c0b8d25f8f9d316963b475adfcb04979058728b055c1235ed10a70d46f98f111ed1b2c4ddb10482bbc1caab9485310fbde50dff3c4d0382b89a1fbc7169fc8c037331f5ad02e5bff4d13e1619148adda8b42a15aaa7187665c77882d94efe4b969eb8d8a3e6bb7588f27db0ae9aba9344776f483dd22178fed781b921da61ba95ec536c785ea3b2c0387f1ae0b080f492c232ed43581f7be743a4711c75634f5b9e6af5d4ecb2beeec131ae69e63d315c2a570116f5bb206ce6e5f917afe48cc24658464aa8e247bcf0496a03225a4be44e446c6fa819d9d8f9a6103ec8614441407261ba9fe9fde2bbe40df0d73142a1c7e60e5c20366b05fb9c94326f48a72d4b9af0bbff998ac2d4e3a630fec7eeb78c04bc2ef40c279bd53193e9f376753a4d6c661fc6715abd9dd1f1288c65e2004bd528234e96f20b8e5d8920721879245cb687ab0b00cf197acb5f8ec60cd375d0421cf43530c3fd43dfb46e36a91ab6a3c3f65b1c1303fd22f06f3f96df1a4ceb6a5692bb7d6d37fadf9c4898b19e4803c270fc15e7b33528be60bf8ed9605f7c1c4518b7c5ee4397df2a82542cd190fbb547bc64fb244620851d7cca895457516cd063381588e687176d86e5b994d472b31a4c43d2af28ac79a4b6bb5da3082e68a5bc75cbffdce8cb70d53db12e8a24c47455cbc7d06d73f7b8d7c60f5cf52b35ea41f0c75496867bbcbd7115ce8fe2c60192f792a8040ba500ae0af4866e589066f87b6498cd55e0d9590c9afe077b88ac9c79faa2e34cbbe7726b6b131a976544af539d964bd006c7eb9bd4c9a30ee618dfa21a890912fdcc65d764f81eb6fb5e887a9f51395375dfc79fc208891ff1699d5a1346d6788af21f17e4ccc070c613e7292b61dfe7714d3b7da740f76b50f4e20a5e31e39852481cd738c35c4ce840f9fb9572994ff66d170eb48b99c91f3b2956838fdcc3899a095b36d40d11e5ff33c3d154823311d0b0bb4ffc5d503444e0552e739e31c26f3d50722090c0a87d2a73309300178bfe0c1841897c08e8499be9c401abfa74c6d6a7b91fa135b1a9ed34275f7bbda999c9c650ece0b9554da536a25e792625521abeeb44b97c013f11daa055a4fb27630e5f123891dd7e4159c4a6395e161876b693bc2b2148ef4205c733721a6aac9aaee6ed82d77f99678dc65a935fa1995a1d69b947630f621d9f1ee8dbd19e0d24df33a1b4f5e63c76851981405646d5f546c15a873f39cfe5312c95fc0e3f774b34a2fb9175dfcccf3020180d9a52bad16438b7f1e148e3560adf2b9b8091f9d5fac7ea550f96306715aabcc9a2c7a476ebbbf74adbea91ec7453aa64595ac3160ad722f93af4203905638566319905754903e228002d9cb85540d8bdbae8187fbba9a9c40a5bf5a304380b7d3511b2ae574de111330f592d3c93923bab261d2e32311fdedc890a21db364a2f0f9b7066f8d6b340c1eb836a1d58fb54a7f2aee2ed6d8880dc306742766ebfccb3d49a3de4f58cc7d83d2419f0025e6eab43c7e836807ee453e74f476c713042f9b7a4f5788d9a2a790907188ad30e8d74c1734e8b354764ce73827b2f835406d31474a7e37d50f7c0b28a59c685a50c6fae7cc6a6f6e79f7e0db6fff8f369b894e1267d38b5c33f32ba841b70840745d913ed475b7fd587fc78062694f71c5b1f6ee5909e6c9c2a997e5c0348db8ac49e1a7dc9ce14b578664c000bcd8a330f0e62e306a787845c11118a4a4c56edfe9c0d657a5b5a886af4f1596769f77cf320dfae482d982c7bb2445963f2d21a70bf9cf33e2cda317bb3d5c82b31c531879a8495fc091effeece4ca04782d53a057c29b45e138c6fbb3d6f9be5cc0041d884bca8419bc72de154dec3f7f8ef1296f979ec7f14cfd30a6ce34abfb6c2c12cc606ea3b2dfaa6040f5b1cb487712a170f8dd3ed293cd891a65271da2569a329596a75943506b2c4e3509c05236f9f90c2a78d9243cb0b2059100f1c995d17a4f5199ef8f4e0dc49b6f85d7aa6edbb50a990be1ea9323b2d0883a19f4c65f0f5b9779b7063c49378018298e1f7307af8614c73cd570cdef82b885a899106bfb65ac244daa9b290eb5c016fdf2a767426a817c5f04e02f4505ba926af5eebbc7daca8ddc5bfa4bd26662629d0b45e113251f8230c0f1ece46eca776dcfe4dae99573e8091736122dbb9ac3bb889ba3f59be3f99a13b1d20e8170f2a18a4792d9ba6f7995ee459cd27f6a9a39bafc00c150c7030f38e87a794a7eac9d62af5287a87c5215ceb960e751b081a2d91e1b25bec6be784843f12518ac50ae8ea899581858b30b836fa12d3de576f4ecbb37a7bbb67b0cf0de28f1a2f96c26d0e1b3b77b0d2e575aa97fb4a539351278d32ec945e4525a1f544d846b81a3098dc138e50ff2c946538e2aef7fae9af281b8d886220eaffaef91d67d0f1fa4345302b34b08bca5a997d32221385e63c2358321c38002f178e3aa35c9a1c2ca43931833a4478069e513f7abbce348c976709b2f4fdebc95079d1cacb9a38963dbb155478059d5079b3a1e26f5fab5bbfbfc5d66a5a1d78da86ba172b8dea397c32f73bb28a911a3ec9b6c078f686561e2419ec8200709fb810a8a78c9c51f26e1ea57b20e6198f329d296056428dde367b8bcab113ff2d02ae7e64bce7c4e7064f9b9d47d3a2abc204d20064886231ef5b7adba4573ad38daa0d9231f95f79907ba7f5fdf7b87e70457f14d255de0a327748df871a7417710826356577bda939ac634c21a180cb6889f923df3c3741167e538b4c79ccc72d8f8cc1f7b8e6757cf9285780cb0e0ce2c86d6f6d480c9ccccd916a2e0b5e98bff602f21f74500a412907ac123e4c1bfdc7533787714c6463147fa1a252aaf7bee4ecc983f72ab4c73d74ca00e0d76ebd95ba5068110d19339d210b9763c31219dea3c773d4090e8985cdf74a58719f3d7b312e4a4060893d2855af8073d9026c5d2c327eed837d8b9bc64430c05335863f851b0d9e919bbaf4e3e1df79375a4c5185fd148cc08e7ff8fd1cd2318f139cd481aca609f9997fec81acd4423da52da6bf954503a0ed5005c3ce33b02957d4b1cf3d079d1cdb58a8baf157449a3ba2978f13a6fa7254743b05446b3c1e5cf07f720ebf639ada26cb576993597e9d57e40e8f378d2e4230a8ce88f688822c08d03dc9b04b76b9972503fdb23d74774c31a809d1d525870cc65c126c1bd551533a9c57bada37d9adbf845095e9464a3f25faf1074c2eed0b0b937ea3869b1a7c3c43ffeba4145cbb2a3fdc103950e5511d9c8bfae4298cf6b2ed1e9a7d5255eabe42b7f57a536804f7b115cb3aea54794f5b1f62d987ad01ee11c2708c07cf6ec744bd0f12d7e29e6fa51988200a80703bc967e0f81c1010dc1413c234fd91dbde44c3e40fb8fcef8bb283ddbfc463b9056acf5c6f3a569bc9752bcd0f71222935781666d5beb1d0d7f7bab7a2e31cb3eca2b3fcb7368af5b9ed4178205de42a82c58ce02ad3fc43d78a0d4d8779281dc071b13106c0ce7b1ce7e4c551c1a39a0d8e47d4b9c0ed5271a6143089583209ecb7448e2cb402b2211912b04c38561f2857e279003ac2b32a5565d52a676d066a9aa045662e172c354de6394eaa29764ac368937fb06cbcacfba89a41a77fdf82a86b9eddece903a5f78965ebc0630cb6bb483d055af51eae565b0553f6755721694eaae7ffa6c6d8bbe314d450604b95ffb670023e45800b9b951503b9a4547be6dff98afa274a9456e80b87209bc9f07b15ebb5d0b64d12733c329acc38ae6a3e35e7f5e0811ff3c618745be5045a6df5ece139bb04df30325a2b7c0323387bb61be08adf0345d6c1c24b096c32d706bd82f6c3a1b4d9fa2d5c29d1f738b86796fd2338e1edb0403f32ae2f49df5d2fe13bb4ae87bd315579dcb3d70b53318f30267ad4f2bfb1a1d17842f999e54349efcfb4c31076b244029f12b0bd394d249c0377e8b0dd08786ced101170f36ca0dc2a895c30fd785228912d70378d1896c7082876f2afc894c13d90a750d7b63ff7bcc4d48a4d7a1c99e25676d9d50ce5a3811695378393c0c21763341248dd38b5b1d2973953d984e995292890899616204625aad4124652b0a2fb94e3472e29a98ba7a6ecf7d442e32a5d9a961b63609ebfba7a87286012f5a89d0f1e0248583ccd67a3ab26658f76fe58126153c1a9cf5e515010f2677e1df8accba72f12cd1216327d794709f35ecc1d2793a81ed22aa082f580eb0ddd2d0041ba4013ef94574ab22091b6db50206b4a744146d704491cdee34bbbe29e27927fc78e8d8ab829215237984752d3ec8f8d184465c93d5b8104ad10af34320e079424b0c306391687b9d0963f5043fc608050b45255971a08018cb368f42e26ed46fd1a8d93d04013e297c7cf6e10fde658a0a2031d18450be37c5291c8a1e83aadf13b6369e56329725678bd38f3c7df5d8f6a6207dd8332b2dd2a57982f4013e918e81bea6ca0177dad13f9504e6f552dd00b0886e49c7d1d6fdbd40582359f178cc0672afb0ccb4d3d67432b27f5d2635f3141b664d72cd684af6d45824a5ad7ba23d8438956ebb7513c2c8a88114e0360c260a4e589fb95a13144886a5a007f071e083700450cd91a0724d3dd1830fcb97db361eec5304e4d515213820f0e83b7c90baf39e3a9b4dc387da67a17f5997824ff1f58b6e00edb099bc4f4e017b052217e2ca9de1b9ae5da684f9e3e67125e13c5939a0a97e6abccc54cece1c099c8d007abdd922e0c97627989666d9a57102bf16fcfb94754742f436c875aaf24d693724fdee83552a57f6b547f151445e530e33d5d78bac9576d6ada016cb00f539d396de832ade3954f1f70dd06421a5d711616610b8c21d4c02bfc93880d4d82bb01732a6e65676c6b890bbf7c0596b5e629ea8fd59ec666136a66ab96bfc01016394a157344d688d774eb3a4b96e722abaa403e02022187665e3b11f3a78780ccd819aa1a1906b6d1c879ccc43e6fbf407a066e7e6fff89b7147063a0081cb10df77c1ac40217758dd706fa0fd8a3f14f2f64b5603b60ae49624458e37e6b3fca7eba8fa4f931b62a693be9979ebf10a931c09db127460c336efa06c983c198c7cec62e3d7379e0e0d2e5a11d585d5db30182d1b8423ea8a39e6e60b890d555c9bcf2c723fc3a646b9280f7e38b16d80fc255d4d226b32d08eee1b42f6ff869204630f1f8816a688e2edff0d3b08f782359f0ad3f546ac6361789340cab02df7d1b72a09c1b5b3166164f16ca51a267561b49f21cbdc9ad3eb319d73c3c74d47e23005b02bb1dc17f0850f19e0bb0f1fd30a1d98c611d21c8f1118b6f70a2ef882108ae11ddb069629286c88e7b7666da87d916df1eebc1ef445fd3291ea8a4740071666aec4b7d5a85c236fdd58f8278dc938d2d4f67143fb992ba56b81b4e4b365a4ec32fd221a04a491fb70122e2d73bed033b953d125be61a15d198f0df7ea011f28eb9a3a46bf7df4af79b18d03653f73b6bfcb0047f3168673e5239f57fa780eae7af4b307c69808a4d32e862dc448396dd16011139708d3403def79106c1e36d50b6be0f100ad1accc891cf2927f61f466055bde950e3cf145ab34743d98ece54e14b9cb598e35b2d33e2e8dbdd499ec0c5de19bcc2bc72f0d8024cd88dcb954fabe111ce3bec976c530ea8b1411ed217230d07684830d7d827473f7ed7323edc7353fb4240f89392fedc659d60e1affd8e450aee5644d275391afea6468c6bd4ea65915d83a08f36f2a30bd3f1fec4c902c26e50db98ffc655a36e8088ee6a150c409dd61cfd5b8b011497c35d4e4c87f783efdaba3359540520a3f4223ed401765f1d492899fa67dea9e0d18f8eec08c2de6cca3d5eea2596540f309e57658d54e28a43ab76c18ae4fef807b3341469eb86cb46fd9ac24602f052ffae36f529c7e7ef1977606560cda339bac6638a5fb43c4192b3351ed58f608a5be4e5a1669b920a0a73fb164f629ad8afa3065527d1a42015dde7249c51e47b8d797927bd616da5d6160987b1f59db05d14ba0fb9b393cda2e4a7d185bf947f56f73d81b3db9238d2f5ed91c220168e9ca0d1c96f309371972b6b19b8156195b78b837c10addc2e8cc59db7978d2120f92b6d0e7f47e4fb9371072d5a4cda5ce32d44914989ecc0aba4a55a779059c61551d6a0b219bb7b88821bff076f0a72cc26c4779493c572c5fa03911a88559b555e5b1f7881baed424bb9f875d8872bff74cd83bb38c163acdc1f4842c15ddf33ca5a65ae381d1d0f44cbee1d82445d7ce09739ba7a5c15a808f7db4e6dafc482b2774730ef7cdf8b622383105a78262eefecb09f104458d250f55312c2369302681320078bdff58e5b6669b27d6d3c38f71fa4afd368747bbb6dbe7ba4194e0dba22e54d0d5e710ea0d6d35e7676e44e7e0942db710895a219a890fdc37e509c78c9652502bc9a0d4743d07adcebc87c9fb36aee52dfbb6686fa0adfc88633e24a1d7c563fd2d4b2978570ba17f62df31bebbdbccd7690294e5cfbe723d100fd55423e113655272bb93b040d0eb0913a9690c2e515cba39d9b8c288ee4f03a2aacc9ea3618710597db686f6b30bdb0882b34e51334329cae59044fbe7318f439a09410233db0ab325cea1a766145fc3ec3c63e646c471f1b3307e28e4c7db57714bb7fa01aa2054bc2725bb094d5f9eff4c51861570b7a1a2a5c12db2dc7d240df0ec88c30f871c7a54c658c1e03feaec362741e55f1eb395b7dfeeb267ce96b6617e0a70875b81982dfc8fb642753c36cbfce430e0c66be982ab1fa8a49e73d8cdff56b23a66e199533b0141d35b295c873605b83bb5cc5c0c2e6bf4464ff2e2018c20f1f93df8550216cc23af1ee53a786b74c4d16e5afed90e00b5f38a4933c2e0552613e0b00d6b3441df0b177eaec3657470f2af79f535ff7a09790a442adeb90bbe159be7cf09301e4a3f79e6e4f1412b6d64c11a245ec2402e908d9375ab7d8d649b4cc593f66f02e28cb4aae1baaac2b4fd455a24406ee67305c821f24f843ced76a0ca62a9851087fe59bb1292b4164feed6b25521dfa61754de5840bceb97daff9f4820dded2c867b99b0e06fbacbf66fef133410de400f8012c340486e31a0b8bf4858a6017c3ff9ba67d552d4cb866213493d6410c26411397d87de190f3bbdf4248b723d4492a2a2387d275520045d13642946d7ff33dc29d8905073b86e9a02df390bc0c569781145011a9ded8388e707e25d479937328818391d0cbcfd36923802bf78fe584a9b11f357447e5f50915efc06d6f757482c187726d4fd904f641a1039f0bdd75f7690b757fe88b5cb8d98cbcd7f6c348166764067175ad3e42a40e72eba9346a8c43f6103a61dfdd470a1b1a038b8215a9ed419562028544e760cf2f13b7933f9c5d5a6b666dfcf10e711997ad151109ff0fc3342a4c72d311b29c1c3e4f0ae3543c82cfab7682e743bd5a606d07a841243935361521accb93ef26a446637b113e94e4713812a4cafcb91ba9ce0f829d6431cdbfe1b796045aacd65c1dfa390fdcca200ee5ff90b39d73cafe5dc1dfc87d7cf5065bf92b0d9a3ce2e8bb3de999e4f566db8118d6777da1f668f256d985153974c58309f2809f19bee1e729c1f0a8f58505b065573caa94806bd752cd34773c0dfb4cd7a478c8632d72b0d7bf9a60ec11585dbe72aa39645b61b5822fc484a18ac38ec6baa0598523c83eae4792e312f5ef0aa52d599a0b7e8926ab9f226b0f92696255f1e3e649902c4e959cbf71a952c3776b0feec187dfac56b745c4fc3685178f61cb3cc4164a3bf40770af3ac84d8e54a12e7dbd937624b37f52428a85225ea89cee9609afb2b741131b7155c3b88b935d47c639bb78862c1b7f930a00b469f32c54695d7d0ca6e8710b18c985409d4a11d5e2b2aedc2b2dc2cd65852f86c5655efd2241b2766fc467a4be20db4c11a04fa263187456a6e1c97ec00a876519ea147200f3c6bdf690c16d9ad89ad4dfa04cd7faf43452bf0ec164d139e5f8134062d4ac105e71a7bad67a17a774333851929f440369ae55eb3d350b9cd879d5c34ab4eac14befe22c7f411d058e5898241380454a811436cdd0ad35a01e515f5d0364ae2cf91261df4283388409495a72792e4c3a40fc557c2d524a8f51f2d6e9f332e2d8da3694c93611bc12545f4f5da75f2d1bdcaf8f75b2f964708ed2238e0d60ac02f139be6edfa25ca7125aee292fef9453e976be3529a2a22ac72dd09c458fe6d503513a8a0d03538ec2ef9718567ac38d4d2a8bcbfd884cef677b25713c85c28c150f113385af424561e8bf3ec60ccbedda3f9a69da730a797682092464a09862db8fdbbb3a75adfcebd9fe785c16d9d70d658b36a506d483811828e2789052a80368f8059056da6b1629fc4b749c9be1002c8cdb2f4aadcf1feafbf45deda672d821c26d6151b49ff7e88cd36c6b4b84b85003bfccd86593db214b032b5933c3d2a7678e853d7011906ba2eceecd008f13a8693e2e4d1139ea9bedcbc6056afed801b211203c5cfa1b56616263a7caff8d296d0a221d4a18f2f2a0db7b5e15222cbf565c2ca6a534f5eb8df06c4c6c7953755a10c6ac768538c8d57ba89a4c03c9534c5d5d8377d68d09d142d35985cbc66151d1cf0cbf1d8cfddc0217534d8aee97024fcdd6781e943a9212a39c0ca0674bf1a96f3f112be83ca8144f968b186707182a4af3dfbbec77fcb485be49d20846eb0e091e53f25b496a1dbf92df69cbcf85bbcec97fcf81b733aa53ac579f40474d4c635a87f73cd47830410bd33ce77e46fcc9c4ac844bf365d88cae4443032f0634ca9105866f5118e70d8d94aabbad3f2f7b6f7c8b1210a14a3c39478811f2a5a96310b50af099dca5f679439bdc8ff9195c6717058e5e39e4906276db2a88c42b572f60af21dbba5682b7629e48e50f305c8722dc7c847d447370604cb09411d315abaf804824ea882dfe74ada0d2f243a7b94bceb3d119113eff5ddd2d72b0e427b83a44efee0c07bec649861b71bf79098df3269c0e5bf847474d71a5146adedb50ee753c9c05ce22c2ceade830be24c5231ceecd990ee7bbaded643c2a2a385ce70a0af3a3da82d92a0d7a9e3ea86bd30e845e17d44eb0b5998dbac89b10d3685171051b5a298139d5978f9a8bb872470b4a55fb06dab602a339609ac1c5b733ec28d98db5b918ed20fadb6c820138cca1bb6d665007ee43fc2be2071160ea9f93a108cc34042fca3f42c2dd30046b579618faa12821e8366487de47358615da5271100eb7ea1282b756e4694f93a305c53af44d1065418645e6969afd4a0bf6ef35a860ff9642f5c51586795c40770c6ffe57bd7515c05d5159e89ec56ea23f6b32fdb7846ff52bc59b41935d568eb05b4bd22d0926ae0edfc2124df4b9925a063d9fc3a0448ab345bc12aaca8f7e275843b393ba5b32407abeb7f565ee5df9afa8f824c3a43e4e16bcab0c757725cd8181a0f35bd58aa235f04711a527099ad8f493e96bf3fd1647805315cf03184b5964fff3ba1892b7bbfe1343e0f100f4f0c6bc7210c0e62b3fe6877a9539fe19d350ad6e41070cce8261b3b754ad3ba5a04ff77092be1765df93e2b75d8854bd7ec4354c901a1dacd4a12d3c00ff35a1988277926b1837e6be9441d276af77664c5947392c92aa5dfb31a9c06fbb8d6ee9641088d85be0da6ffba8d0de9f4c7a613ad7c03db6974fd10b3078a14ed03473b5f75bd90a5b611dcc6cbf3f6642e953e34f12aa3d5d2e7f8511c35012e3ca07f48a4207a87f2bdf18c286dbbf9a9bc4dd7f5067552ce20150c9bc23590a378584ddd1b23537c81ca19d4526582861b0073d97d2a2d14c4e96f41a3b24a6d4989003d820bf9fc2a417f74cb0b718d6df436d98e411abc59091b26738e08b84a6f4e43a9337e60de1f64fe67335a60718aec30c5a3a9b4a7883793d40795773945069571b4ef1587a036ef6ac269c5dd41c95940ca4aae911f577edababc0e00f5d3ed4b0ea313448d340cc75da9268074f796d3370a1ea85610bd52ca7776e031deefa827a0cc59bd33d6f1c0182760c14adfceeca329415de402de99004344cea78b4c3cc0a7aa1b684c94f711d87b01de31d7f9e0602653a7bc5b990e0b4c26a85ae62d1edd0044df1c50eb679e07279e827b83b878ee04cbb43ead3e1bfe4e7639765238dc98aa55f6882b7ae334d2edb489ebb9841f9196a7a1417a619cb244dd828217620f4979022faa3cb580aa8bb7be58886a042de985efc6d3f9300cd1492e9b5083351d7bccf9b092bdb5e74a755e2d06364832e2188097a5281a9bad8ec7b3251a6913490a8f73e48a98a783132104abe12d583bd741757cc6a6ce7b3354dfd3a4e2cf02b546648aa56c271c6374b978a4b6732f7f8eae3a583478a882aff902865d618c01c849597be3ece57c2508dcf65087842ead406767cc047e806126b748103143c40c6dab21108012855c7ecb896254f08e86ca10a91cfacad88db5dbc11b7ba199d7d33032926865d768c4e9bf5fc603d6c78ed346a8dcc643fe9e8d095d6d953f15be8478b38d6f3fcff6f2c808f0ea3768e3726feb966343a3ffe6bd9026429331cb1a3d028cae23cd1a87fc1f8c08c311270d0905ddfda2a6c987e75b4d3522f1a1e0d8ca5e9c2b20f74a4f14c428bee4e9dc224f3477aa283faba40e0b3b5ef1d80db866d7a6bdbd9590bc178d2dc8822b1f7ccab3ca4101559a7ec7dc6aa11d5a4db9a1d47cf02cae91387eb47ecb0741e1464a9b1f668a913011fce894661f6af25369b0418a4704db5b8a1501344d136832f72af7382d43a2ea3ea8ba9450514c10660a0ea510f4e7357d4a11e03d75741402d3c5df0b6287bc437158fde917dd14ce48102bfd3dc25e51d0f570b5aea7b66e08b02479fbbb5bc5040c3df813325ea814d49ea1926ffdcfabafdf54a47d5e105e3a328e221d1f32f0bc7fd81ca3ab7be814bc886f5585b5169d019791f08c36626901c49306849929eedefa55426f6a79bb01bedc5b60098d0a673f966c6c17e9d8efc9161253b1b7c36542ae0c6f6a9b5442af0034e08b3d7874bfc3eb1d25595d70178e8eb8dd745501e8383c2695603af31d17b5e09567359e739252bbda28787116821a7b3bf431859199beb4eef76ae15cf143f267cb20e5540230732076fc84650d4abd1767a65cbefa57b4e03d9a34da790f73063537312cc95997fb80fb62f6214e17babf6296cf78ca629e78a73c0b1b8cb8c561671e46a8ebecab6534ec70611ed8204d218089496e1b900bb99a829b743dc4261632946353657bd9743fab6f0300eb86141b93b28ae26aa9e8ce6251363e9c4c46178cbfac9c520709f4792b64cfae24070161f81ecaa215159c7a3364c4fa04e24432c6846e1ae5f57b1e87a5978451ad458b290a01102847e776cc3a61b9d06c03142aba1a912366d81262a6c11dc04d6f943b85179e9212f6da4b961d6caad405683861f5064af42bdb63ce2330cb4998ea25cc0ff686bc7da1580fc7aaeeb41051d59e22a7286e12de8e857ec998ff8bd0429c6c337d32038b49af0fb0a579a9526ea42ac01db4edf566ed939aa59f6e3c3ad9538a09e26d6c7adf0fd5c3b7233b3ef6184b1ab570b62b44958ea6be51dd202fe9c9f811d6bee1fc591c150bf68c4b0113d974d4c30b5aa3bbfc9afb875803f6124c487455f6d9519d5a6146deb2f70fceeabf6ff49dfcf7b7e572e15b4fd3d43c5531ff7a9dc618e3761c9527e7e32a3fa74002fbf60ed34718b8c55f440e07ecada38f893fa91b9cc3fba75df3f2d50b977ec543165efb5d928feabb171f72037aa76ea77f38a8fa87f04b88d7307d935cb0dea796552da8ea2eae98f4a21ce5bde56c23e3a05a2ceaac527e86573c95698a91e45e02b11ea34f1901fb66f987b1a3f19a80be27cc54988fbb28afd10fa26afe1eb2ee4f55217c31bd7c4e8150ff3d81fcb0237cacff978642707394c6856b777ed4f6136df4f3298ce5c79f048c87f89e3c8f82b412f6b223e423f8c5fe92a082308ba9643b1777fd2c6c1248f2dc1881e1c49d01899f6a11081ca4e963193957e4d9efe37c2d20dd749278b85c61bcb59b5b514b092d8ace6b5d01247d81c6b97f1890c8c35f0dfe33407c874b83a8331f87654be423ab4b352973ca3aac2c70bf539df043a37204089051fec65ae9b626d0014a4a6c9bbea6262ae11746a85b591fd93b79dd94686aaa87da2a57df692731f1abe93b288ec7c57313865da0270fd53d0399d1688ce1527b7177d2fb93b415ce5c9aae564db124fd7c85c454969d3f10f50b278947d246ee888960dd7854b81f805e66569897e79ce47d9d64de16f41865fbbb073ca09c82c38d5b70229efb4fd66edaf2986e11b67b6afffa94a957a53a48afeccca35e0e5b87d6802cebbef7c2a0578a832036bb549aec8798e998a2ee335f70841441a8fb64af77482642a575b0247f5672b6662bba781cc32073714d630b3aacc6f04a8c3df79dcc008f79e3d6c24161b8416838ad04316bb86ab8b88a3c7bbd6004b1d60accea98e774bc9cbc7e076b53247a3ef40d19472fbd15db788ef2e687c0b04cf8077491fa1bdb9e406f76a203f9cd642bba87ff4c98d90f70ba1812fc8d2a1710ed68f3296d9b4d06874afe12abe15f55ffe80600f2a28a8960234b657ac171023e48913272e754df41a235ba3305d850748fc52d5ba83eb7d148662d91c2b4b3618f5d350f478c3d066156032ffd594030241f4a1f3ca4d1b8298ed5dcc4e6b8250ff061237e6a10ccf22f4c27eb6201114bbc6b9e0fdd3195fd5517594908f94fe1a30841ba704a06bd98d809860a5b5dba8e88664d2c028be8b603a239d9bacb2fd07d6d0b09650879720d2b7745f3edd42a9bd060a5bb779781048134a3150a50758afb0ae87388ab9bd38d8c51c79885ed9ee072d3287879a5e7e0109b259651245da4df45c70f4bdaedfbe9a63bbdd32bd4a98395a5f4595d6b0978ad91d7c06a05a23d6e2feeecb204dde490aab94522bb320edc82bcab477d762efc50501c63fe8434549cbd3656cf7f5f96adc92ea63bff372870dbcded2d8393be9ef830c45d38e51e28fc596734c360c3f0dff41981d88dfe6ae5df606cf2c96f94729f41728b6baa1e17a92d6d5a98a3d8e2b9707691f1a80514567e09d1c75b0e0ed0e0a75ba0622b5a731ab511ef0d51dc88731ca5c60c2abb9bf304c67dcc2437b44876bb81a203c2ec6313ee2297dc45a0d89ae46a6dd803aaf7c9e512277f91b55ffd3149d40456c5972adc2a74c760b1164c65e0a2329e27781d45641f0dacbc53e167f35eebf480e4e35a12dae5b15ca5b67a060f5de28e58dec9ecab747a13d59fc3b28167f5e27ce893e430768f15b3a5db43b9e30d2538d184d0beec721f9e255c5e4a3fe7897589bd451705248921380fe6f44b70b31f4b81629bacd0db8e8b46f33e44ae566d9d2091a09f483b8a2f03c20829c83389891f15fdfecd077cf6b6a8534d0230bb4c016cf49e16f4ccd0bb945c2707ee5e17d0a8e597a9a88e44e5f887d860e50ee3bb69ff42cba8d332ca8fff37f7465466d72ba683a74d9bb5e8b2266c0149f79257bb0fee610f125246e4fb095590eab26cb94995c34f9c3fefc50dd8c89b199b30ecba516dba0616904d534c67aee0adc93ffd7f48b7d4005a3a23a4aacf4b51490b8a2ded56e3d1f939f2aef175c9bfcdf76db2349a0387728214be643210ff7a2f1a284ecb32fcd649a7d2ebc15eca59e7ab8456094fb9ce5c805e4daf21d9db7532b13c7310569ad26f688c2bfac5e8963014ef150ac7adbd8f95ae5b71f82840e86906fa53d4f0a8f1e56d89111978ad6237b44dcf856078dc2f90a9798ab816059204e115dfee0ac85131b33baf1662e0ba870f75193a83e888a381f9f199360bbd9e28143efb8f2b687a453f6ecf168be2ccb105b2908a12f9bd150a2c351545de1e096eb9212abbefa6a5719fe38ae02ad0e86868c41b7cda5105c7c5cdfbd7c83db0c06663f7f9a7615cdc2533343c0954f2ce862551faa9781e74f622d5a56729a724e8617d561534c612e62646fc4405b328f8f1bb572f6e2eb9ee0677f03a28af5a4bf5a72e4512acc3b596002d7d910f75b9cf7b1b0806ce1b1bd0cbd0b03e6cc2f152b8b1e02f9c68287768d396f96108b8c491e2c666e0d978aa79bca4787392e0676b0c76ade24e8041431ee4aaf419f7840db7cc7e5af9dc602b67ae627fe6074382e806d4c27f9fe8762b3f691923218ba704ab2c4f281ef03b1750e7b01fb1485cd5a36370136974104bbcbe07e7e741f12c362644cb3438ee1428d4b8b9a6316b195b9c432a159146264b3dfdf097fd7f3bb1cb9bcc97cdf666949422391560474f0eb912e0da35206d586ec67d834d293bc779ba59219fe887ff386eaf27f4752cfe741e5c45091cf3304586616b338ca6f4dd527bdace61c7e14b3731dfaa05d422e9e6b492d5fb56d80530e841461f1e742fcb2be3955dd8de95c798275d2553906d30519d046fa0ce871499b11925849c92166316cc4d6d2628bec4377239ce15d88c95605254adb745e93491998a011cfd506f387825178366335f38882f2980df765b72d9a2f47db0970e97bb3ad444890b45fee038c46b6a598539258e05ddab7f0abb18dc7c67090e87066f6de5acba78745d714c2b130c666b467433373f8bafc8783afed764ffc18dfff347eaf88c5bbe0681f3daf7f56f2bb459a22ab7604cd9b757a8062a12c37d71e98453b56a16b76bcb762b2c9098daac3c6ea648db54fbf8ede07ff82af5021260b86714b14d6032e8f78d47999179e522fdcaaaacea5b49c00d0e65c4b68aff215ea8de555d61197bec2d34677ce7fad4b26cd7ca7581f319e363c3f822c74c17e391efd9fe212e6688fd39c47e519f78d8c511f365d580a4d46b42b67874e1522a4d1c69b83241dea2d0da76573c5ddc1c54b57a05fd0c31c0401720f46727e45de84e5177b387939813ea3117c6fb67986658b9f8787a0e37a2684e54a728fc9d879fae77baf56b8588168afde08c9afb1a84324508855ed54e8dce360ce6f862be1110c6560642353d24a7e7bae3d584f07010196ceeaf1d3cd50b4cd0287d5dad4db44dd1aaf89a34667fe521bff1d6fd4a8b46fe7ad71e4c5c30c8fd4b4513dfbcc382b0006b8f75996427aec828b74f9a230bc27291dafcc60e28cac068394f7b30e088784c5f9ed6e694aa01a5b19a82fcb28541d7267732783183de30bf5ac1d015cbf44643a5a68f6cd949e64af822656ef0e36692031fc75986f1169672edc74632d94c53b7b128bb651d9c7e6c1befdbc97d81cd6f3b741191cc844d345dc82a879a5d14c36207c53aadf89ce5f42a89ca565837029feafe607e3ef08588c36a0d666959b293e044d1edc5810a1b69abf7844ef2985a72da0d69c5d794a287ec182c4ce886e5137af07056107089c2e06b4a3f543b3a25137a299fabb41883b12b98c9218d2cf5cb5d354e824901ea5f415c74ae31726b1fbbfc2cc7e2da175576c734d82fd62b9a8c10f4ef979543e9ce1d58fc8be7e2828ba9dc8a1e9640b433a2d0003f52763d53832fbe29ce5c428889cd761dece60c415a375f40c62be4519f491b00cfa7171a49996efa58fd8adcc5711d5b327b06638b85259fd16c176a101304704e352dac602e870fe3a015b8f63f6612594b30ebabc240bbcfd9c365730d10d2e13806d1ed72da8540fd357665ab47371f54a7bd40008d3b7f0adb2a7aca93b9f5e80d7d3df1bbb709e5b62f4f533337042ecca91a5de0d6b7c99bec770c5af7ce927d8fc5065a7123416393b61ef85085caa77d75fa086b2eae60d8fbfce6d4db6b1ae8fe8c7ef8558bd0eb448b05a2b3226e595606eb3c7e4127f6e52f234618582ca649154162d4bf6ac1b99a514012d36ed56c5e2fd5c90c9da552ccd113b1d34e807fdfe4c43854bae76947f564a37c9ee4d386524ceaa6815bc1c3f71cf34c0701847e4a947f658cfdf1e3beab60695b0f3906ded6358ed898731321be288d5a83e6d308797fa07f55ef1635bbeb44e6fec1ff625cc520582fc2152949cbfb871d573c9d0a30a6085df1372ca2d43959f708e749029f36538973da093906aa751a30d5f9b75f58144b7354dff8b98d49b9a816b1613b3bef70e93b6eec0704c8a63c00bde995cd8eac6df84e31f282d8643a7a71337882f2072708f63965ea870a4dd41c2a6ba8ba645678bd36d334b448bb112496dd20cbd9f2359c167f67f29278302c262d82ecb70f204f78c17b32a637e70d4ea09b8abb36ab22a97410ee79210498041b0f312964fe186b68933a6d1fa9d8de59a8047b4be6f7887b1b125c204e6396723b8257f92a02713e2684a4471bdddf6e47546aee05d83565c1481c9abd1907b02bc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
