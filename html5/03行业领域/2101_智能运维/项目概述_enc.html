<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18c5e300681fdb7ebf94fcdae9881eafa8a3969d05154bb4e82224604801d452c3d4bbaa3f8bad42741588b62ce96b5a98d072d61c2c438fecf5c1bbb4dbd73541fe003ccb8bb1245d46434deeddc0aa430f591f8d0d569888453e5dbc5aa1bc8fdd0903a336761870f9d95bf64e50d7ce13b7e699e734d5ed9a7a8537f2128a8d3166aeea2474ac4e8daa04ef9ccd2741ebc8d966743ae14cd0c55d328b8f4bbe19efed0bf5fe72633d927bd12b81f27d838f16d1a1b6ed9f3f9ff479f986c6dafa2069abe4a251926f5284a23373ec2c14d25b963d4b50db4348169261da57582cec24fe430913bf60043dad67631d8fc2d4de0c3f389e9fe1e581ced01247758802ad840af1e3b0924417895748be258d49c74bd3a9d65a9e49832a8ae62402edd640b6c030316321bf73730de08a481932232696aa3fddfe10a306e49b354f8a6dda44223172d2730cf959bcb082185b620922e4f465fb7107c34c1addb57a8e6c8198bdf78196b203bb07a0ab83f5e07ece85a100f7952fbbaab9305c1b3d20f9b8602b50dcabc2ff4cd31330423582eaee7fcc32d705dfb5cd0093bd3b49897386fcd6d6d6e9b8c895799bfb5a21521d0f5a858017e52bbdc7e8916433da5add1ec57a3cc125d2c8f6092f5773740eb5e4a84663f8dfcc4a9041ed719f3aacea13091475cca3293ce23405cd9e54aed7bd2c2a313c95fb30f1754ed3d5e39cbae48f4e9b2294911a674fafad82a93cec9b043b0e1896d96eb0a28a30056eddefecd0019139024efa5acf8ee4365c69a8f8de8079d14da60097453bb6bc5c92428926d26014626b24841247e0fe7fc5de68384c41806fdd7c5e6e238ed8f5fba1c6b3baaad546a628f09b9a37b45da3bff24423cc86315b2f4fdc626e3db190e10921528aed1690c82ae19ba93581e65544982b070632bee2a368010bb353283e6080c036d500bcf072049f9ec020e3027276faa5c40c0138e14a10b0033fc1ecaeea4e147a656f280b0f68cc47cf8789c8bbd0d8e936a58c5e4a0a5eed0f2def12418ba277ccd7c51eaf2b52e58a69c94645aa165d75ae8acde27a9bd2e6b78fc2593e0e97d1cb9ae6262262d3c4e6f98ed4404e614a1ea18f62e672647cebbfe1e77199564704f403532f35473d479ef46c8ca3fa8a5dd9a0bd541e609183a64767c8f321687fd7d57d5f16202c039d81486718e0c76d42587c0908d29c3fe13f3da1cdfd2d7a23404bfd4357c0a54839eb4c2ac8e344326e6d62e33d9d053f9ebe8be3792339380c3a26e63563b4c4eae0b00a2a0efb2db96d243522808c51dda1f8105a5599bb8345750f389863642345e2a122231dcd9d9044cdc0a1277166579802704bb035b3e360a1f4ae581aa59c1b36574045359976b4afa67f992bd78d4b9a4bc0535637a9a228164f60ec4190ad988713071deacc205faa6b3912fbe6fa46c925bc3ff1d1b3085fd4d842c3f7a8f47127f04ea5ecc44b5869bdfe407b856cfbb253051c15077d501da62ece31f0ea213ff92b7a2039875cfa26ed6aa265fe5591fd5898da2cc93dcb26a8004cb284a09252d2a78501fd66f273d6fb2f0e0700e7e0c5586f9f8524b4179baf77fd6cc3a111d7a546953a0caa0747293ada50c5f64400b35c50754599a0296ba84c6d77d868de786b0e3eaa52097dcbf0ab5bcbbd3460450c821965c5e70cdd52cf6fd6853b64e9dc8b0ffa04c6d56f6b251789be0e6a038bcde03fd6c77a1db1d06fd89ac2088cc3880e3865893d76ac93d88e86989e3b7aea4423e0a94cfbf901b41bad38966fdcd28e2ebb4f0216714fe68fb19b48553e2134aa166587475ce564715c7e4814f1d83fd2ccfc2ee2e1c93ba8efb089fe2c9da1a16d7b85591e1eb6b6601e3e8a9774e516aea77c444a3dd49a58067061952af189330a21e0272696b2df1f63ad98c2440d8cc60c50f8995e292e31db312008e11f8c388387510b935d113e612acbd617e2f2c8624f3e53731663383025618d92efb8910150d8de1c2ff2de7344fa0dcd1030f3f54727c63b888b6b9847828b4f1574267ec1fd4451445cb554c74b16073297875d44ac86cee3781a778a27d1776c2b33f482629c3a0932bb77a79725b0d424b40d146ea69ae996060c54e9afa0bb1b2039730757105d3dc02d7dd464f0203075bebb083c4f4bb2e3594113e8f2fc014e9656ad967452b086977d2fbb65d865bbb35d4590958a3cc864f03db2fc9a5e010b9cab2b11caa6a52c6af9100192ed770a4bb124d21493680127b1cb8b922f7c540df017275bde6fe784492df1ee7aaf92fa09439b8dea8fe75733734297b54d2fe7af427aa534a2b855e71ca0d97e8985ab68129e6130febc485770f663b318d53959ceacc4da2596e20a4bd1edd51ff7aaea81be72e25877562a39f24573608f09f857ea02d557c33205e6ebae944c251e313d4013387ce0c499ad575868bb153c8a7f7f7a29687e9f226e6fcb597d563187fc11ed0a65d237e4d33a09150e4cc35f22d04e133a6e6a5f0fe7b82bf2c722d56edf6e643621837efc17d45b58bd5833076c723220169b14a48f6a5273304f5d1ac3beff627e53a8d20cea52780b950fa2fd7495e36d644dec01923cd0cc6e9d51dfd8601893ab96cc1d506ab965f9e529088d7b996346a830595a51e92f918efe5ec16920c42879e2833e6155767c1b03faa31b99d680ba82010de5dc9fd5cb50200c2b851697d83a11873b878a504fa19892b66336ab60f837ad2c6797412bf8d8feaca884e6587dd47645e20d8d74415b181c11fde2d3ae7a04342ec3240ab9331adf98e832e28ee3b25818ba894d51a6bdec1b5658ebb7172d8c3a67721e1e3eab853f61311eb3f2301e7bda32d541201ad611741534418f6040e794071512bb4bbc90204eaa0dd30114193467667c38bc8a649be67485cf281909cd55b78fce2ab20890996309b1c0e902a0403fec1635aa4390d240b1e653784c9061f91b9c0cde61d498b7a10a4f3e5da0f6b28d0e20c1f935e7ded0207073acfee0ba045ebe140eb99b27dc6d808b95218a65aa3bf6f1ecd9a3bdc06db8f9e2fcb63f7f3b8915f1bfc5b57c8d6407f5834a952b56acae8094ef107f09479fdf2342b20ae6439a7a8030258762e469e8c7cd2051c1411f8f7ba2ef413f69aab9fa4616f70dc07b37e79697e8a6943efda0af10ef46fc62dfdd41d8cc92691d1397442cb54d2a9c9c9e8e66bb226a9f5b4f9728d4c408db8a6761a6ba16a424b1f6c62295cedfa5b04f6232afbd66314c2785612a1f699a702d0f280bc83690dfce0bce8f207313018bea30825b5daea82e8403565bcab53b0a32c2da1c3dbe613e91e6cca365c6a83ec581c3e2ddb1dcfa1b3c4180e023321b43f81af7528541e8906d65ca4b3b341a8939fac4bb2a704647edbcaef1acf5c4d1bb68ca3fa8dcddf33d16a64568f65b121753e114132711ae1b42ab7fa67e296742fd2e2bd36c685c00495aadd9e7e9a9d62aedaddd25d202a8230cacb865b030b372ca5468a42dae16ea74c088e5e7a06b9beac7622606c3da655e3e34387f44cfa955f7888153f6d3ed8fd8d99e92f70b6f314f094202347649b2585602666fbb2f191439aebbca0af1e84c590133cacffdbfdbd3993fdbb2889886ca07588b62ad0a13f4786d9fef7ed834675fceb4cad823659a536f8be4c4f2de229570fe0ff7f90c3e74cca556b707eccf4251526c2d511bf6ca11da2f36bcd970a94e81194175649c10b8ddd57291d502d32e00becba81a9839df6e7348d45a429d2b02caf74796b38fbb11a8888be804afa359f6ff80b748b9a03bb371e5facc701061cf7bb5579f23feb6115bc614dd0bcffd907b96a908d0603c1ebe0a25cefb7c4888790f9d0313907f820b13afb2dc397ce33ea3f56c84cf297486512ddf2d1b88758e4d615f6ded9643603bdc244b1f650d88e9fea55d735476d3767dd75d22cbd40249a0979ac2dde735af0209f5db098d80dff710a4086556835e3f8d8955b86eab5207403cae712a9190fff041cbd308a6b165ca0d3146aa4ed3db4f6fa98fd46333d3338e63e97118abd5cd641a63dcaa37981800dbe50b67f920725020ef360e394e7487da1b358d3477388bbc4c43751021e1c0cf53a3d647dde31fa4ffb09885dfe2dae9071b7c356fd762474e82d7091beb3858be65ed023c9f46c7581758a8d7162215519655127591f5ec4fd6c5afde235b4ae7ac788d58c7415ab40a0f97bb4fbefc0c4e28fc160404124e7558ad91ad6e4f9d5a7c88f12a65bf20360d9e088191a3eb36b0cdd4e89230530bb32ee00d8d656fa92e2e21aef66e137de8e92aa2cc2f98ef31a159d6fccf7e39fd6eb5c98424f31b6dc436066f5c2e1c810faceb345e94a0e1579951d511d8c1730b3d408c1b9f5608075f604ee435ddcacf3baed727fd281cce47c72219cc4c03d815dc2f9b001fde9ea358932208b74d6eab2537bb1bc93d33e7be9c6addcf309e040305d4f529c94dcad83afe53f28c1728a13d2aa5fdca972261bdadc77a72d7e47a621d8a741887c27f5817f2fde9837f811d56b57a0e3c853c6e7dec97fb64febf624837ec4d6f61474166510f3c2fc68056f7212c29d6e56ecde4bbbc522ee3ed56e4d5407f2e9b27f89a9a785467946d783ad8b135b4d1b85602340ce5ffa70c18eadbf94d9a6e85658ae68d3facc1473ef60f83bcae7557b307cd83affbe942c26b252b77ab9864280f3ec2da62aae74a795fb0c0594c85c7b571e31700c08685353ba6aeb2a89c1feba60c32bab315ced600e7657988971bdb43a1dc16231e495700d8499375dd5c0ced6348258a408b9035f536907930dcb7d9ba6b266e5ccc228d70e7935bbae8d0abe820e060889e44dd8a3ea4ab17957bd7fb1a39d64afadf467fa36fa19c59289dab7ba08678cb48be2075b25b7be83a3b953a8be7993554e98ba73e672d447ea74f3c38475b179b7e5f78acb408b2f4f6117c4dade23b57a4906234697ec2910b3999c95bdcd6f5335369feaa1d4b5cf0322d0d1b775de872b5365ad85038caa596ea168934c28c659cedd5076fd88592d06533f87d4955df250ed24977c2b9a94e03699bce0f26432b86c808a7631e3fee6525fa9c7904a6f0a1d582963af966413693277c52adc0c8f7c43c546d8f52a788746d3f1cb9ebfad3c59a92892568dd4d1dac45c966a452dd76834ba2577649c588dc32df81cb4f68b1f84414659e728f139e92cc6629b7dca692a165d0aecb6d8895f687bb7b7823b93bfb9df00788616980616fe9e2c0bad2bc7a5354ccde670a3899f6818e1a1d5c63aa52bf4d58565724e3331608de481ae273eab97c31f6a152bf1250756c5392e488e42f6ebb46780e310f227bd608d87b73d872c512d4cf837bd200ba295928bf60135f71ea4e5af48c36ac43e7a5e93a1d00c4160904056bc0a1db143d3f12ca7ca72b4c75288fd9c9bd1618fef5a5152df38c6c76d6c5ec6c33989d354964d7c0f9ddddbc43140068481d6f666cee7a7f2b690f5d8b6d3295806940c9e6fe85e8ac8541c5656668658877a98da743ad94042e7f4ac447bada3391fb20fe00682cbd95a63e68d5acb64c1ad497c81543c4afc25c475a86ad94d50309839494d21488f0d8617560e372124bac96d288e8cffc322315429f4bffed074010d2f5362a88eca448675bbed14107a1572570a619016492f6455145dbeb79fcc5c730b3e78bb27bb64df37755c247693f03dfcdd337569bc0a91923095e03f90ebad3071243987fe946230c837c50154c6e1c8e2349369ffbe4b0828b2d813e5d97696b87de1d7b8ef81a918035205e5756cc46acfc664768ccf76364cc9adfa05e36de1cfe6b9e275b330505122ed0f76c4c199369dad7b0ef7835f958e0c28ad1a02c1f250d214c68eb5d19bf3204dea7dfe8e00a085e0f5eb85438a705f04934ea31a44e2f2eaf0f1c84ebf2429457c8f5c28030c4b66b27d758dad45f39817c50edc1511d0e3c6f6e87e3c6579a07076df72d0abfb38e54bf1daeb873848e697d74f6d24cbb2b2ca5e6ca3cc07676bbdb488da16981db7c52ad0cc4cb5753c60ffa45ffaeb51144ae0b69ff909337125211e2606c3981b931847f7af2093b9f44b1a433e7b8b1de257074a7b97cb3a8dcd9a61f2d677040e0c7c36d891c5eede1c039ed3d1ab302e7a761430adae452023218f79c3c63749c4d5b811f9be4584a6310693ad84b509b74407d57193f91dc6af45dc548207c4a1d59145b603c9e94ebeb6f5462ebd315fe70ca8de06930b30621901640f348dcada162dc5cfa02a3c03bccfb2fd4af58605d1c6d7483cb3eeb75e97f4ec7b5f3f01004527904b0127119c028717df71e9a96ca67fad9fa6219f275ef8136f49ed1cd40d70b648590edce692af72f5059f82fd48087099a0badda9ff61b7f6a2f813a0a2a2debbee314ca3bf0e5fc70bf6ddc2b7e5c118dd53118ee46877f1a786b14885c55c9df394c805945a8f5b2aa4eb581e7d4a956bc84263fc6d892e935906cafaf60ea0ed688b83b283f334a0e16cd1a75c5c0d1fb4f5aae0ca30742aa9973835a1c8591137a844dff2fdbabe2c2494182e7f40d1f7f161d0b704ff2c4d7e75aba72c8a5a6f1822964c4cc06bac23d65f574bfdae24c297d3c075a698412de605927f4978c495c0c1bf11a228dec135efc1b76dcd54b0c96a11b22341c87e40e0f6006e4585b4577704bce898528d3d086674aac5f920f61d4c303dfcbfbbabc43c65919be564f4678f073f63235165db0cb6c5c78074036a3de15475511400bf8f95888a6a144292166ba9479ce93d0c17cf678e8cf0bfdb28ecf159ea3f35aea4abbabbed4216241373ccf1536e6eb6d92ce4702b9d58b3835b7e7c2517b6414208ecfca9aca64183d783d707c41d27b170c17c6577c31973e34529ebdd7eb78b7db28671277d96745453562b48fda30aa0f76c8c70967098eaf62c33754bb52674e6493c77c176d8f055fc73a2f301aa10a8e18a4bfcb474c584772ee19550fc24be8c2f9cda5b72e3e8f3b3ffa33ba6e24642da204b34402db2e3ae945916f994c16092ec245213799b007129267e286c71959b6cd8c95cedc91443c7699e31c9ab3502af131796ef0a5c0adc3f15f5d57a48434d35486942a43720530fbdba0bd5f8f139baac226a439205e64b23f0cb457aa0329a9fbb19f2aa49bc93babc6dd999391aa584307df4230ea845812cc42722ffcfbdff375338edee12dd366f4010a12aa8b71092cce8f1a0cd486ea006f565a46f846c8f8295cea2cd21dfd1e0634d89a3d70df44bdfdb9420ce53219c946ccbf3b1ce66f52e2899b184357e32af9e083e12ceae4bb81a0ef4b2ce6d66910ed21713991cb6086cd4c4ea784f740404fb69e7897f31c4cfe8f7c309b9a8f1ede9a2d3fe6c9bcc8d340b384761ea63f833d4fb15d5443c59b43d0abc110a79413c9582983cc038ff3c9746128dbc0b9d0923d66ce090cdbba4f3ae3ee74817b575ec5b00356be663c422cbadd02cef8a96f0a23d448c87aba02abe6b1491fd4ededa5684cc688de116a0c75bb788ffaebf42bd1f5f21a524fc26339bc51bec025a63e4c1be53ddf1fd3785a5c8fb05b450129c3510b202e49bef35a6c07079c88032be20f6c746a34ad1809036b82f55f23109477668bf47052288d7abfb667a930ede75d25c9166b3cb2f866b5009f4a2f35e39b3f45042f8ce3e9df759fa38e79257240ad4446f1d6f2713126b3add8c8fac9ca60bbdb5e6c35757b51217ddb1c8c5ce64bb71b38ad693504f71272fe26eeb2fd6b5898b44d46bfbb04649ef116dee44e85e146a422780f9c6369667244fcf07bb1dfcf0347f0cbfa917ee9f948b138af9280a6083699cf929fb2c068e0a626c164dba98737ddea22f456635e0e3275ca01b36771d7a5a83f264c92925d47a848ffe9a3e07e3b9d4cde40fcb8dbf58c1a4f2265c6d885c2fb999a2ca59ae827f662d95fb66ec11431be93e28338815291b365df220135e3b841d306899e59f84e80a2be889f71249b1cad75981c3c30d8001a0909f23c8d5932933c8fc4e5f907094500cc19709f384a501ae3e7e608b8cc1fc14539bc8051fb57b63a65b5dde1ef916357a409043f2452a9fe86dbb26e3c9581ed181f70a8949a9e0d2b511c2a9ea02ab999839862a109207e4a423af76bb165487f8d89de0a709198a3dd4b327c0620775dc1c6e0ef112c8655484e64e8dbfd9234457fb0f79e342e706763965174fd061909e8f9e2f4c3a7da53da66ec01e56c4fcf59e6d046cb709065b9beea51803e5d6bf7fe732ed504d7c6ae02b82ece75de87f8127fd083c1bb85714ca41334090076ff9ff85d12fc1cd8e278d77c711b041b5fe73f02dd97ca3138e711a2b50be0aa874e085911145d5d19551b68d7c21429975e8a460375c5011c12074aafd2b25c6eceb2ce3f11978dacb229832e973867d9b144e1276e68541d288c7980b0155903b39f176cf90b7a9b3c36da295b722d148a3f5a87b894a8ad95cbed9699c9b39e95d23c80921f144cba7edfa1adda7905299366deecc1363ac37b579ad80d1bfacc542da060b7e8d8c7654596bf92747115b66d4a27a9bd29dab2ac1dae590929ebbde82249c998a6ea6db4b018614c3f1d1194ce19e7d32879366c0a21d27443064931f02f643711d0e6c28f3af13dd969826a9f66560c99e5ba96f8edbe846849da6e46239fc567cd4e0af46952596aac2ec4ff4a3ef2009d7dd4b1ca3c3245e1205796d5c511e8d4d977caa71bf63a53faa3e0f1fcd73067b14b315b51e9bd85057011107f72ed17bd36cc0c22c8cf9ed9d308d33f7ae8033411906e48402f6953b63affc9a73603909c1991a212c386fe36f5591a9fcf2a3bb7da3f02f8eedf2b34d45cb727e11593af67a1790e3272a0121d450571964ef1958fdb8c84cb4c13ee80ecfbd82e832572a7f55e17e7b277861f6a7cef4a5db679a256c715a9ae362363cf0613f87c401b1aa37eb923e256525d518675e9b5e6f3db9c9acf8c846240f1a397635c66d3888e0068dc959f7144902ce84935c61d3684e28f535cf4c24e9d40b0baeb6041ec23a0a9797b6cca8475c615b64f72a7e791e6cbe0bb99a90f41dc13a7542c50a0e08f527525fde6f12124ad3a3856d85cdaff07bc6b51556e94d1c1bea1ef061160649d45fb87127727f621aa31c60ac19511ad762c75b9cd729b1e7a07a00d919ad156717d6abb6f5f91811659686329d8f4fbaf22e44b9dbc511ed662759fe864b1c16e181ca45dd1692e3433b325b14de463453aedf0ce9ca9179170093b6907615a8cec76dd6885998d6f2ba5b49274876f11cde110b993dda56d33c1802b5629de4adaf90e5c28389234d53ffc2026b0007e2178c8642bc2d63d4ea05b46425e5a35f90c20f149dd947a5df9a4865fb550f4a8dc8e2153948b0fe2203a4ad14c39b27fc2d6f20ed5e56c2e7b0f049f8c7e6042fa2343a328addcc13d8f738a04a0dd8a3717ba8c1eccfc34b8c86c13b8e62976a5b49fbd50b1b15adc81eda256e585fd2a02fb3b3ccc4ecd0b0fe5c1c7636afa13c37c95f733cd2957e3823e5bcad10a0e460b72ce21a6a09af5b2877d8a4af60ee8f3b3c7f8017d860a392ee13c6197a4a6aff0bc967af5b203e4324bef20d0617878684a90f2d4d555d97ac2f4bfe562f4a8b9d6b7645f704dd311fffb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
