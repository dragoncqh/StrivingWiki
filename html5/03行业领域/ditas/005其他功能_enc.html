<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81ba181f65676bf1dccdc7bc62fb936c0b7ed5d4504d0969a6e6a4baeabf6e0b3ae9f7ec40d24971a6fe6a44da7d93502008d6ea920a4dc95aab8de419bfdb4f2ac1df951a68b03e98bfa7845861d7b48cf623997a773000952fc8271a54380138591fffa84679e7058f84fdb3aded942aa2886557d77be41b81da4a32e9b3c2024a1bcbb065dcabb252e1d96b887c272b9ee292fc929b71c2dfa479d3e01c60872a7964e584a62158e02bc7e723cd16322ec31c4fab2cf0e532ddd64c3235b77e2a11ea4b0f479f967e4bb3bc75b70b7d5511229bd65d05dd7cba0adb0560802f263811c6c05f0e250640854bf09cf66924b2dc50e54b7a77592507d366da83697fecbdf26d02150048833d3ab62d1a7c29c6b32e5b667250eab4acde141bbc3852f72de35d301f0046ac04151ad6832e7b8e78f6c81afddde92fb314127f9309d63ae4e40ea99bd25c8ced59d11ddfe4558f75b059d8bb6366ebf88cd2ff96910a3f763275183250cfb10aed64935cab03fa39f32680a81cfa55dcb93b18955a0832ad8dabf6ab92fd743eebb76cc139367f78f925aaf8ca0d863f23b107f45ca3ae0a2b246302d92c70fa706cb62e4991047796d351e4e3f54bca756fccf650acec827eefe8a855b6c999b65232cd8c0b53e74ee5d373579e9614dbcbab44d66b7545a4c860eac81892d386390008ad9710fd557ad9c6b8499fbb0e3301cca9f8f9fa69e2a8b34e174a6360f39dc920fdddb512834cc4285a3c4f682774f04bd1b9924cdd95e6525749121dd82dd33f2ac580a2faae3b8461faf38b6c9f9d5598120bb67f95eccc8333a7131b13e191856771f06733798ea1aa42145a4faef3feb9434b57b130a25e2f3eb3ecf6f904ac000431723b5f77eef9fc578a1fee8e41af262908925c95c9639b9cb93ddb1d51d9f573e37c9d4380e9209bcbf0bd89d24ffca30cedfad2adf778ef89528e2e75b781b5a5f57c4354f5f1515e6df583ce9f21b0f9b34945a72af9822ba13cd61162468610289f1e910c809adaa316072721e61dab05be27c68c48214a9c892ab0b46f22cbe999bf62485c791fac64bd0196d28d819aea045016378f4de36826a5d5f55bc1d93e80d3f9da3e212aa6aac182eeebb23dc4a542a7b3e6b2bc24f64ad089d5ef845d6310a6e0db08e84c8a0727a602637eca954865bb66fe0566de7cbd558901e785120595a316e991c230bd551d5bc925cb0a296acd50aadb42e09c718f43b67072e22293376312ea773c36797f00b27069e9815120581dd0d7416272d8ae4a2bf28aa407643fbea67a525d565604959dee56ba552bd016f85ef1ad0e62275200e1d289cefb4213be30dc6dd74f2142666c0501b4b2ee54298136057d8679560c7bf16245e0eefda07cbc9fde16008e71bd2223872c6b08d2a82499233c0edaa4e7051055fb7dfcaf05cd24734cc63b3df1733e76c795ffc4707def2e1810547576f3f2c01a4ae45bcf126678d0d5f7527b8f08e20d4a641705c1cffe7f90fde472821b233a1b0f771134d7b5550fcf3a871bfafb3d514fc9f8c57a1af101bb44fe2a6ef6f5b4d30a6a63ceb7b4fd1ac3e14b2939bc932e42ee2e957c9e261819ea1cb012f56840d80cdc4b5e0752f48869076e1d86e944cd35b25297360d572049a60badffd73beff1d6f33a5c22b28ec3bde36c127f5c93ac29e9670e895524a4c3a98ebc78ca7b44625b9ae78becb0d8dff685c8535801c1c32d21773416fb7df2eac2a48d91afcbe7d447041249efda1a583d2b4f40a79411391e95ade26b86b1fa27c7fc0d065adfce712797ab4785b8efb31b8ad1993f52bee5443f17640d447ccd00d5c5391238327a4fbf2d44ae68f4497322dfc13a5ac1a81718e01b809d5dfeb4ae2e76c98fd7e36b05fc752566d917068ee04180b22766c3ba981984bd97f3de2806e5e32086ca8e35eeaeada481c8257b5ba2da0dd0647243fde2f5f195de16865b007ebeca9ebab66fb616b139e2a90de0b3cd887042c9df9c18836a8468c23a167a2b1038f2d6e902b36c00984f8277efd01610988c23f997aa24ac80316e1fbe7dd609c77d1f150fd0acac0caf857904f97d43b1ded805c1e2a86e70cccc359ff29f286cffaad7d2151351a65ee0ff28f3dd9f35ea076c70e5014dabb16559d479c93f8b18cf6d1c7a78d5846abb308de7a5d5f7422163ff0060d35ccfd506d2ac3abd7890f5c75495ebe5227f69e5be9f2a044876a1f364fd7de6b4bf990c48969c7642f1510144471f85de43ef22def0ed68b292ce062cb3b457ec39667abd4605caf1f7fc626f3411827cd4e7da21d4fd991d003a978cd7411ea984d69f3e9d82a4e1d2a8c4c2a5d0b86eb2abcf15bf54d064cc5dafcba0d4e25fbefaef013da3ef7952e7e10c2ab2c70f2d6101af6a014e68f91895c7ca8a26bedd7efd9f51324fda07a65372a84e398110255145a43fc3980a0b7309e101ec9c814b0d444230bbf93211755549efe5df841700fe3dcb074c66e5c7cd85be3093407a057aba6df2c8ce6beebcfd7940af827f29211e552a15c5d97f4dfe0b03d5d8fe6c43d7f8becb14863f76502ce229c8e6a343288314d77fb58c9a01afa34435ff2451ffa17ee9b25838969a32f9f219c94b5769507beaf934cab979b6bece486611676a6d758a73b0cf09d04398fda89cc531217211323bf17f6cecc3aeac8cd2109c65572566d4abead6a89e7c5f7c2199f1f15afd9dfbb68478c668969403b56a2407a55953ad6cf6b28b9678a65317309179a60a96904c749899a90c24fd131849d45203e2c7b5c989326ebc16fa141a5528beaf2b3152428500729713556902de8f13a5df61984c8623a02e103c8fb0fe1814558f0120f0fd5feab4c453f113ff1a40d306477a1c600b022330282faf19fd59770dd7841c904a29746cb6ca8b883b02bb83587f62d01cabb5ac10d6eefdb08047f65cda86f788b8d54714f27fa8905af62125a27cf2fdcd10f02ba96aae9b568067c9321cf22d00dce2ddbf10bf489b03ce7da09e0f94c563ad3dbf2b33bc94aa9d811a87557636d75df220c13276bc8b660f20fff487fda9552d78b115b43b1d4ddb9ca3e08de84158632fa3376609d4531c473a47e1a81cbde791c2e63d16c75b7527590ef3618e675890d2fc4e9018743f4460f6b7659d0eee2a61491be765849fa4d2136d1671970fd05da154c669702b9732c1812978ccd19e705597cbbf7d784ed8dafc1a81d26f6b9cc6aef3baa3e2b32f1b26f16672642e4a351a7aa0b98a8373055313c588171ca97a98447ff7386805a3017c7cb6db7a3353e31ea791a87a4b27306275b3ba03708efdbf1cedf4ef41938bb3aa3db2494f95cac50d2cd47691912658b977d088bc04539da68e0c02c6009ce47b697360a655962ad8f2ca3978dcf3a171c4515d2241701625dbde0268c33a7cf6dd83c82dc2de05fc3bff3037894a2a10169f3ad209996b3cddfabbc34cb27e30d06515ae8952675b8d3667e7e4c4b61f5a4918db7047263f49c00fb2b7f8a920054003c08dcc284db2735ac653b07c4824e498d1f02cb7321af8d3b10343c8707f8e71c621ca7a20196ceaf03d940aa3b30be94b9bd3fa18cc483e0239d0f78ae7a0fd75a1474cb213fb51cb44573421f0c46fa5acf2b8fca1d0ccb3ddf209bbe51bd720e2459b5ca223a04685c500aec7d1f9e4857274257c9c32fe0a424a763c3d50bec5f6340160d92a5baf786d6fc8aab5427cdb5299b28512f82e9b0dc9a5591498acd6926b72cbac2746a06f607fc2b3971c441e0c815d51055d5b32ec4ad3b6254d95396799d9f59c1deec7310a4a756be9bf95f13119035365e92ce97c0eb90047c2c6a8a9f5867c1744cf7b9f97e1501e30374bd6109917597f10a434b941eb0968b49c3ad00b9f14653c9562b72a75442994ec0ec21288527020998b4e13ec06f5c9f9b26944a5b2524a192d19d106145a9ced72167790f02f4a3a3fbd1ffcbe6cf9c974b2bb08c0767945bd01c9d2cfe9dc20328f30c1f821bb532bd46cf309de7bc788317050a4ea7d25e4cd42aeca9d81b0f8e6db01807598a41a0165209dc2f72ec1c8b1b465a7af363497ca213fee7c220eacfe971056ee6f63640c576e4244ef4ddbd45ed9528c8067a972d4c0e302e11e1d2d00da48d6aa1e5d4f2700fb7560ca8e453c262490ffe881d05528cdc0b48cffd4a4e50c8f6615a6012932edcbadfd61a2461c386b0b7b314ecb233d8b60ed81b43881b1442d08c464fcd16b32fad09a9c29c9bae9be536ec064e9039a601859c3e64b29dc80bcf2e4bc2efb394241df6082c7b7fe5021448010b596dbb816be5fc3b5c2c725021770185d73585062c61f989bcff4e8d1511f6a8552120d0c0ba169df6a51ad267a180f41069125d6ff6111b22388e6328a7604e5131a3b26f1ab7f5dc57b2ff9ba79b5e5898aa646771a993de575e84b323a67ec6520c62835467934f6855d97eaecd05f9725707142b6f8ec582bbd6cf0026220af7bb508734cdac9f378d0a1d2bee2b92c589582fd643da55246591bf77527be4b131ad820081627974c2226b65ab6dcea984bd6dfb7f863fa5eb893c02de88c41e2728d7d081829b326c1ea8accc941fe2afd188837e417755bea8680aa42542298cba4ade65d5a29056fdeca6f66dd64406729a084f58b2d11739a5fe79a06402fb06faa875553f9f585974a2c0ba8cc29887018b2c2e186194113a1db9d6a693f6fdfdc225307b7cfde2c3dd63a729391efdf193ee6b3a7b89a6148bb6e83c220f57b8fbc7ba07cec9905b3e1d38b701f63b9f4481c1e531c0f5922800f720317511f51827ab1681560b078b85de9fc16b16e5c0dfcaa686d6eac672d11cee0040a583d29f68d9a91a677d5574193d6460f5a596a49baaa982275ebaf19babcd97850788638097828c32e88dbd197c14a52abb9fd9c3d8c9d932bb3da035f8754dbd90276166000f3d03bbc827d7cbd4aaa8287d9f6425a8cd644a23263e34dc591cb75bf2868ac8af64286a026f2c263ef9b9ba2af827a76fa63f201a2ff37311ea99d6ff32cb1a6c0b8ff859c9d2c01fcc0a9a57a2ca4a11fe7933fec487df3b4bafe86b0fc2fc4d4a6ac64fbcfcd5ae547f7f929af99ac1393db2bd43ac2b9f909ecb5b7bd8ef0b50eeb7a5d27f096da62e3194f1af899a28a287779566d9a3da4241c5834e4e0bedcf8a505c709954acea0d50929edbec1982290cc42a14198348ca4f2b046ef02bbf414d6feb511651a648b62a07d5acf98418364dd9002040799d60c5ad26f908e92dc610d551f769ef1270ada9828d7995f64185b11db7efa5ce4fa6e5f076151e48ea69ad2c77f63589201b084968918b9bac4ab12d397be0a8d8d0246d02667b5d44bdee99898223f1df0cefeeb196b66c972a036023f0ac3b034e76237723fac16f8c2a9b2cfbce468bd2dc798d37ae6a49c54f74612faddaf9bcb4e310004e759bd70b72c5a09956d3b072066369ec36c916d5eb78046c7fd5bb51c52b588ff953b6d6b817a1595f64596879273a3cd15fe195084bff7270c8dded2e8f9d0d95c97e52d24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
