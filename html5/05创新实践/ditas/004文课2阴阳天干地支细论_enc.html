<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96d3a9989444c0421c22ede729040e097289f9022dd2efa88e87f654834896b1a9e855e9a6397b7bed1fc9efcdff788a697bc4a45daac84309c70cdd45042190a2232e7b25caec496a8ff8b6632529ac7519bc7f9e2705840647ec9ec7bf978d99d98fc908d0798939607d823877befb6b977cd4d290e038291212fb41f6dd830f3742252c416c150ae263bdcc2f07ff2c32558156f885e15cebc211c9e817a975024b30a8e81cbb1b2cae82edfda270a174f9d0775892a0cd4351999bcf7b3ca092cfdad4398df6fe611e84fb6ce32b70737a53f9cce680bf60e677a089d92f12ca7b6c98229296542c2f61d90cd6c0076eb90b34561d32434ee8eba85175d3a06970cb7b7739bcb32e3fcdc22cbafe33e76505145564c541bf0df0a8d6efc021fa56c1ca198d77662ea76b3c29801d2c3c6593a3c118a0caeec001a2d077c7f9720d2b6e86965ceae901ba93839e0947d914a482bced660bf2c24ab3fbf0057d9d6d237df5667489709b2162e99103d2f0b4aff3fb28fe982e4f1fbe1ae629b8ddcefd0d728e8cc79d1faada6e6a888ef4c4e569d66caadb75a0c9d6e7dc6ba0858a9fff9b8aa529a22533fd4499c1bf301cbc02f938e0b212ce96b50e989a9342632711937f452b8635c141e8204592565b3ebe658fc46230353070d4b176971d62810c248dfcca2c11ae0121a98b058061c4b8e14c9e346c4b7a52b629df5d8df69a01ba76d5b4cbc86a608867a952723e57679633d9bb06805250038baacd2e9e2fdda4bc899cfc61370303038609363f43939f8645d7aeade809c2a45901044d75473480e16fe964985ab8db0c8b4e5955dc6a38e2acc8737b9dafcd162c73211c20915712b6683f586285b812fc4b5e37a7c1940a58d8e3a43817f78daca41f1de88858f0edc2428def88e986d51bf0e352805769ece0a2e5e4e6b8364decc6a01d697a4dd9001f80f9664f041a6e13432d83b8916439a35ab51167357b55ff67892eb7916188fa5ff5dd419d4e771bf2a28a2c05ac754213529cb60efa626164b1e3c8d0f5826afc82c1dbb0ad2c1996ca7aa2e1913b0cb5b62e6ee7c250a18516f6a6619a8689a638c8d5a605bbcf232ca5dff2f61eb6ab14a899fc95690eeb62f600d24500d0d32ae21b7021622c651ec43a8109ff5c7e43ae8fe8d088698e3f2365bc26f32f21df1de0ffebe95b9b0521786c795d9f12c5e1a0ebd2b84a84381903af2c9ff568638ff3c0739d1ab93ed10595d81c6e32fe5052cbb07d2bd91958aa3566185c2de01c0346983b82224c1a888161493ab982069d2d80d36c771c0443a476943ae95c4bc8ef2b344f698dd643d96359d6826acd373f6a3236663d4fc362afcf94c8b37a32b7fbea6372cceb99cf1ce25317433e64054c9dd3c49c800486b22ac43bf815ac45e818bef5a626f7d8526d3f8342ad9f6a33979b942edc4c464f60e7bc066cb025b11cd3fd82e14e5c3bc60ee47a808c89bd540b5a69693837861f0a27fa482d3eb71b7611586430108dc75dd49dff4901c05836f95471bb9481f8ddc9105f3ca7ae4221f4d303a7b467887448a7e197b21a067480e25f4bfbcda728a7874706dc14ff523ff591b82ebbc7b21af0d803f466c359f986bbb0f43656483924f6fd92999a3e24959c582a785cdb3b363aa18a07a02294cedc3e2ddb5610197854137590b4bd90326585b581dc1f5006d491278deb2a3473727441ed7c2f77969b37c49fee3a2a0acbf91a5b30c0553b7ec85f267a962ed18c9a630f0b0305feaf3236405b7a902985083a030d83e54406f0a34941c00c58e0106406e8ebb2868bf3119d3b3378be907aabc702a480eff63855a1576acf58688b78d6fb135547f248e7ecccb5b3a64a53c07c116a32b5d0d3cfbdff89e1fe9ee0db65a7294ccb69ec1b90b69b256873adb0d81f8b4ab0ed60ff24b6254984e3500517307a852223e269b868e4a38f423f3b0a6af7b77d5fcf959444da8a25b8b0f237cce70291b22824e8a77d17057263444c750b84c4330ec4b2d1011da837e05e6ebbd2553b19bbabd24ede44537af6936f51f098a7954caba2a09f22efd426066ada1e467b28636d80edaaed5751a58f7326c8cadb083a3ebd2319f37522a3f46de9288ec2a0eff3a8d0178b11213934c075e444ffd0e17fad1d32b02d34b6e844fde27ecc2e42ce840fd5876b1098d4241c850036200c4ead65dc9e10f231b0b6e92784616739ec0d11575c6165ec039bce0cfa5f45d56465f18bf346a9afdd1f2b69913dd5d08e20527fa9ab8a81159f9fadec44f8a4a673d8900b99ea1e41a38f6c7821442cf0fae1202a9fcf227dc967ea55b76eaaa20cbaae653513fc999926a942b10f77e7924aa09f354701e22449ec34aa1acb032fbbbbea4665c5572cb3d05f15c01b22e8db41f1ba5b361c26eb8c991692899958406862cb5eec8d5f8c6b77f8f321908345c93ba077992a785d64971d76b8d4617e39ea99aaff7fbc98c15a5af91b471af3348ab5f546b9809d50fa9a4c8ed70f255248104343d42f59d2cacc1871749478eef60047a4f7fd9331f2240d221d4e669a658f410223b10f01463730043b4f9a511d5f34313e5b69f7a62051ba8a68b4d9ea4ab0089b29f10d05848feea4052f55c2bde0c6879070ae86bdc64ff1be1e2155d7952cc3d2a8875e5946b2c02c5858523df3c9bb3f128333b8fa80ec1e81ea85983e11f87b7e721700f5e6ee842666bd4ea4290f47c5f2e129309cd27e9234d960c66839b31a1d66f69b20d476ce590b6635ae9765000de44ef9a8c3d2b1ea53f2727adf58570338b1ad8c1741c32170d3399e28b859e3383a74aac172bd6da795904e26bb3bb95bb7bbf00c5a23f6728998475210cb3ab02849a3f66e2beb4fbc7ff0e4dd21775f1adc2c24da061ab27b202ffceb23842bebe4f43e7cf4e8c8c2cbc6c6fd3f526d0ee5628abbb9b35225d4db409ded721013199a9037c0e574a12daf4077183616423e17849249c69978fbe4ff19826b9b9159df2b15d369c6a38b88651d2f50972c492cbb18fb1f2c80ad4846283c0b5a8499f716bdd635f8279dbbf2fbf29172a285f4f6cf74e83e78a045ed248994f2b6a70102eff8389b5ce831392d1b1cf1754fad3e2cc4cee47b9c51d4f8211f303c091b12db5d6b2416575c53973f56c49c2d52fcb2f3dbca59a9e1f55d80587391385c9f0d16c1a9c09c3b8dbc9297db8653955cfbd9d0e168660b1c413da7736550a2d44f596f572d9719f5e12341885acf0111f3998fbbce6e9eaef4a3b953d19af0a556322d763f210f8c887656e0313caf82504ba3ab1605129f9eb7fe82fcf0b34af6c321150961c0a8bb292d6a5c75cada8df58e4f3327ed7c37bacc2e3a7d017a60bd8d25d3af3fa19aa448b32743202e47a134deed3c291eefc22a3eb28c2cc271c513d705c70f691e5a78e5995b429efdb96d1a788221d19fe05586bda0d4443cb85f4db5701593901a51d5e58ccdedc2665b7088ade48e590014c9d5a3eb844bcd2e5570b11f3cc1c6a9ccda58086221adb3879de3122ccae3be047e9ebe2e4a7d100ef2d302c710fa16ae2b177d7dabfaafb17a8bd2e994937131fdd4fd60f53cbadf1067c5c2e69ed862679f11cb8e389cd34fdf6474b122020449af978c6b09feba44f275bc7b22b19300ce0753013cce00c621b830032a881abf9480890776482535472dc67b5b2bff669d3fb280e299d77e1045b2115748c4dc31bee1ce190c56a14b7ec76826ad81c72fb3a51f76bf1a0726599f42cb88087d199079b977ef6b8346ed50ed73b662052ba939260a55b7bf3b07de45d7a23f5b63d20d5328efb5524208cc21d7a1da620129328910ac3c947e01b659d80fd19f2a0b42f01fa06e9decff899ffbba5ae97fe3772fd42a0875b879cee52af3ea3e41924143b61eb81155ce5bf390b0dca8452e105d05ed843fcfa67fcdbc1d6c70a8c5e51b659c9c298426840bd4a85d28f1191839781f91c5728c6038c1b1d26ae97923e1e48c6e44f59483f86ae02c45aeaffe33a5d8fad183cb5ee9e3195cc0fcb3bc4ebe3fd59bff11e451913313f448a6d2e93d86c9829a79eb03dfe40b73c58e7777e3d3c4eeefc032d795dbae4ff5c21dbf32ca355d42ebafe9bbca87763097a9eaddbb17dbd9ca43a34ed1b28a0162293e29b34c575c5c6fe25e5747f05330f5e8818fccb168c0ed9c906332f6b4c02b9bfd42c3bdbbe1acf0b141fbedef39606ee24a605ef43aa7af80c61deb698a30dc9eff4e6a177f20f920ec5afd5c85f37ae616e9da339668f71b79972d742554bd8ca363b881507853f3386791381ac05afd2fe69d0fae20e6029a9ef6056507a3a5590c5d693c8841704b153eae0565c9b0414d6df5b3bcbe15b491d42073dd1a18b4530d13264511d0e8acc9b592eb3845821db0f5418aedfe83959dafc6eb2eb4299f8c6371e8cd4b1b5023345c94cf2f3f5ce4452a4b9bd3ac612b7bc9c700e092c261e85f06725d72c38aea2b85c483513f1afbfefadbf66524a731213541836cfd5a0b6482629854b482813d199c82b7e1b6da2295d51b01077c85655d4e8cb5342e116ea506e07db405621f67865fe65c630cad444e55128dd8b18e600539dd833abbd2e1bc6380c7e9e9ea184bc7cc2789ab8cf076f27a6aa22ab149298e3cfca7342c5ba63fa110b1a238786e88626b0b671774e6f5711ced0f782a5398cb8d48d18f2fcca0c883576fc43fa6d7da1fc0ef64130888ee72a362cc96cd15c7fbb456206a7bc0c70266065ab571e90884f35db387ac8e3295f13b4a297e4539477432142ce7f89a689768dabae4f90eb8837cda29eb4cff4c80f360564e70dac2b87245cf655f1c4b648eddd9153fb363262bb2a95596d4552baf574e3c25f154ad0c5e472c07305a457e42c318cc770b81abb4298ad067d2da198f81b5358289ba24ee1ec812f84b50317f859d64457bc4a83b3db115899e6f70935fd21805b964d895987102411b604c35c88b76162c063b450d9536db3248dea74176d6d086ae64e56952719566f57f32ad0efdeccb4a0cddee63b0abc38266b75f3cc32b73541a960b453e7bff70d1c3516d935fd5c2bb2f877d0c3dc75a37e3191032e33e48a1d94f7e518ed355c4bfb687ece0f26ba41e1e14da469772dc6024a6812327aaa3d0d0d5a457dc78d9831ffb6be88ce39ccb48375c008b35b3654f1c2331f0730a090a9366542ae4ab9f9a3502446ebcb0d31490322e380005b5d4a2702e6826ec8070ff3a41aba64f1cfe61880c165addbe3025de06234d99c2a2d05392549b3a3e77668b93dcb529ac87cb008c4d1e455686132dd6b6124a6e31ef109e0015f95f90a3a6751955ba3ce67c1590b9e49d4447ece0a517eddf00be964c9e3ec16647edba6054140ddb3f66647bf1ddf5f3ae3f8b19c4df1a17cf9f65b6801436f1d4787a8b690280e2a1dffe758cf2a1db0cbcf33d1206d01aa8cf4b2f36f7f5dafeb02dccca585bf2cd34b6e1e161adc8153a90ec7b103095bb17ca19d379ae3a9345a09824096d4dc1de3ad8dc1c0d739965ea0aad87109692edbb767222ac365b4c0f867c2b001103a2cad3db0811933479db63f6d9a4a2348ab2de8cac8c224f3dc6cb5becdca872618bd67a5b9e432858a82cd0a6b6cf9e02801ebad4dfeda1e928168e594a7f66186e435b1d0c3adecefc783e1f65edc9e7006485f7949f2d929bd6ab8d66ef588262f75f23a0195b2d5e80b8f4e3710f71002c2c235b43c357e26057731f9becae75706c6638eb58b9d16869b7fa8bd3ef1419004b4c6e09863df2e5c464ba8f2ac5f3981ea47cc10e06c0caac6b0d5ecbac0cc89f80fb3dd73028fa09a26e4ce5ade3554275f55971a201f5af7f28eb609c2b6350f23814d3f41f889c7ca0ec46350663d8f250c29bdbe4526df80647ccc128da988bf05b68596719b316002f35f8e69c9c01e6c4744247e0a83750d603a396ebb065a7c6b283ce478622f955a7e11bdf06614a38cc61eabf4cc12e232f63ddb0633eaf506e6dd6f2ec843088ba1fd5864e8bc26f0318214f6613a0693da919b9ef8cd572172377e0501d0a13d4d2a7cd0fd3180259f83b8f9eae3710c5465baadaa38c77ae4ddc18a4027e5bbda0de4d497865d65b522d6af70b40186121e16f0638d2589d3aa06167e63c7f07dadf4c8d61243ec6bef971edabf5f9b3996f0d311c9d8243b10b32f86495ea44163bf2822abd521e49762c3744ccadab4dfb115f9283b608b9eb9c6c37a390a3e72540d4f6c96437068bb08fa4740291bd4ca475e2ae0656487611fe57013f6cc985d3c70459557884594ce9ce3a207bbbc011408dd9e9067d6c9036e062f2a2af03eff623c9ab3f2787b038cb1c2816d68422e38bfa40dbbe4ab4f88a6e690e9087c989a7969f41777a4302ce78e2799315791ea84d278174d33a57c573d9bb40f50e0e6851092d8686d30fcddb692873696c0a24dac66a8fbf051e009acfffff888b2c4a1e8879213ba510e3e462ebd4bc4fabcd06ff094e5a85fd1faf3c3b99e93e9f2e731a846234cc6cdeeb89c8887e6bb587c9ee15cd90ca7946a36a57a0ac27a3e441a072acb4ad6c9a96320e3e0b37b1c50f119c53b3b9b6b7a958db383b7acf0466ef8c89ae71cc45e8b99ce9b9377344152050b32e34bb75ba20cc4960876b774ccd085a3e77f266a457ad2e0a7eae4db9db4f35d0401b7fcf5269348c04cf29da36f09c7870f241cee3fdfa73ae730efdb54c3afb331175eb35f9e6b9f36aa3d451e9bf880c8223c8234fe82bcba03dfb300b27c9f2e8c1613ee050268de5d87feb0be00466a7a2121f7476edcd7ab9fd1df737be0993bebca26520ecae73d8b3d1b46d6b5438377510e96b32625ac1046175af9b213d4003d88e1b5cc1d361357dbc63a51c39b86e8a2e1f9cad64f40b2f9edfe4ca616c8c3fe4baef322c11e3a3355ea9536622ef4f8c7dab1300d56cdac6f4d5a23005b73bd2181470bb6b0c7414c42dd1cf7c43fcaac1c89916d9c0d1d2219839a4d14a021b1068a700886754dcf5d031266717005a95381fed8468a9440cbe623266d950914e804bef42ce2bf2e7120fb01a15b7c03d194914f3b7df3926251b3f4a8f069a759ead62149b78a5a6ba7cc845df0b9ede4900b98a3684119df054b492cd99867c8f594b76f3ccef6229a5f2ad6b8d43eb023e2f3f885bba61da13cd05f61ffd41d4cc458e1de74f4d6192ed6dccdb23b8f333768a5200e33d13eaa9aef6dd035af495caf84b1e4a12eaeb78e22c6dc934ed10edd2072c5276fc17131ca112cd63dd1aed61393ec6c76a42eccbb06541fad836d95e3ba98eefad6d9ff08e58bfc50c983338484fed2ec88a29c1b54135956b57ab243188f616013a27bc6d773de83443286bad0ff60d2844ea2e224472d81a3bb125cb67c1eac3b590d560cd1fade151437edfb1d77f14a7cfb9cb4e9796d4314600b7aa10f364fc3b4399bb39697ef6ae2c55b22986c13b382f23fc8e10347a0eb1989eb36dcda9dc86540b9b72592ffab214e0af2fb44a80bce681d399fa352c5c1268f0deab17656e69d8ec8b3f8cfc2be47a1171becd6c47d35628b4a62dca7ef83f7ba45acca91bb217cab7b2a26a7cc4ce1f0226ddd4657fa49c848252b35345e4ac128198ff8e1f4b15bda1c863db532ca3cf188278f3d45d11c86044e109e720fe823cd6f3257e0055fbd98819672136b2898681b5a5c8ab2afa0bf2256721651a12f3b94c1de3981fb77c1058e899829d8926916091775904725091af1dd3009132693494b58f60806b167ad4b26762a4daee4bc37a14158c912f34cc6c2cc8f262840919af25c1d66a17102115e393b884926a175f4eae70607e4251a20356d908ff13569fc876b4037836ff0dcf01f1a8400c686bca6d97bacfc32677b0b6e72ed158991eb84323df209f19629145c6cdca9a6d7902a2e56a72ecc8b1f61dad135fb3276f0e25ca4c691b3f43785c2f7f93a98dab6107efbcffaf3216a24ea186f1d2acbde4b24c34ebff31d35edeacb1feb212fdd3059a416f50c5c60fd79193b33c84c1e2972a10c6bb26f06dd8a88773344820e2c0b13eccbd52c440f93e4bc7f4cdbf8d84dbbd0df11c649d2875d1f35da3be8382503ab12589ceac66be1a4a64503b06149f69a142929dacd8dbbf2f28de7ba86cbbffec4006f1eb8b1bf63ee1c41c406c2bb88c40a33237ab68d2814fcc8e410622afef6d96f10379df0b2c9efe492cf8ebcf8665ce52f9bb0ba5215229dd06c87cd7151281bce45d63a508eb7576ba05886d9c1b6358afd617fc20df2ffb3bb331920662720ab1d6f7c4aedeed16d9e3e12082a6036239edfb322acb98ed5f2c2d4cdd94f0bc07b89322bc4b2d65fef682666aed101b2e232983bfc6b2d3a1639423011d57447bb224b8cc03a4d587bc5848cdf6208c45d0c2a188026ce326ab159ad6def1aae9ff30e4f8fc4841f0a021bb5659a01071d8a89cead0ae4c49a0d8643a0c8b4c25e34815633337e12d54868d8fdf19fc518aac161d156a76ffba056469f583394f15047718289353f4d4ff95107f243509e247a28cd5bb6f9c5da8c959ef3480e7d5dbf0944e61a66b0b8ab3a0fec0fd4e1c08bd9c83808c7b5ebf8891a7cea7e63808846c0af7e28015ad4123c93126dc533f216eb8897869091c8985ab70616c4ef02868bf68d6c0192ca835942fd0f4751b54b7ccf776448300ba1a33936ffa7f8b16348335e68037b11be395a953b07d17a57c57a737488101b57a00ad72be717586bf1b6a78e7cd9d8e8e554ad7478bb6fb758d87ba4920365df0a8ae902923a057066140bbac9665e57b76393bf41b49d04bb421d252fdb7a3e69ad70b76a948d9c02c70ec7e93ab081c43f681d5b370caab3006c4cc045d12a54ac5d84ed14bcd9ab0136787b9c9ad743b6aa91f0bad370f3077782cd4383e2947a61aeffedae22ad51ac1c501adeafca31cf8146d631502d44973d83f56cf1841f37c716e4b6a6763b17e333e84cff5670872ff173e9421bc818e5cf459ea55201910d366d60030e3b65553baacc0b05ac5fc50da20c6705f6d62ccbe02e3a185637266abec10fe25dc81aa3ae2ef5bf0e3de890fb8713c9786677423eab708a58d95fd08ffaa95cab4f18dd24107b89ae4ce9fc497823a4f4f3c127c847f562c6f7d6f90ce3649e95d2819602d2ce4157d1486ba9a841525b875ac16f77ba356a777f370d2a6bec91784074a761b77b03d8e1b46f0670865d20ee40c9cdf2826fd3a788407f5bf025a4f17037eb52cb78a9e7854a2b7f7f1ec5b5f26cfb73ce1827160d3a2cc233e40ad8798e3d3d4dbf0a6a77baae74f4b3602bf9b326ed6fede128380e7cacaf995664eb3ad9e9530f446a83c09f1700749b8bf0c58b0a8b7eb241682833541fa27668510607f1ef408b328be72820c37520e002814353e811ffd87a6413f420cc1309f4af7f66231ed09db0d705e306381533e93196bb0a6ce79c60a6b7092c2399e37b4617c287272290d3a201a41d15e2494b9f44bcb3e5ced0408fd1210df2b4cf51ce5c703a70460b767e53f782947c959b683b5bd22f5dc4983717eaa1bc7036f0ed69e6f77f2dac243a7b767f42f0dc77f86770d62741db432863abda8460840600026532703f184d77a6fcc905b641a9c3e791c775eaac6c064c29487550187c69a6fa2230a0357d918014dd17b79d3f2fc1bc86a38d047e32b7d8420a0bc980f26765d7b171f34cd3f1a597e94723537e00a10009d7706bb60ea4c3cf98d2434ce7b79640f08a2fc5673ab73a97a1861d7f237434b15b5c4733927f91f00967e699c3a323214069cbc344fc7620528bdab21f9305a65a034a64e60c1d10776ab217065cabc5af0f8dbe5614e732d7402e18bbe0e3a65acd5c47f54abc957ec19005972521842c852ab8352a0039d34d461572dd4a48f03ad1841c1fd6230f1ba7789dbf2dcc9291230f0c6a37f881efdb633f64ae40863d2d1819731a95eb7a0333602d845c41ebe4c61401d5d89116175f1375ae129d33627adb3baf7d033a8d9f81f8fce97c8e23d310b456524df1ace5aca9f684f69587cc8a503f853021b366b38a4035ecc0ec521b7c2376b9971f16e19e1a0cdcf3b45b53dc4ebcbf7bc3369a1f8458d72c89a48c4ae55e876dc29eea1f55317c6e8820b558a4f1ff2422788d0cf8667cc22d32633701f202cae4ecdaae07b5b828e9101ba9ad7633d3ce688e19b11d6585073b8f69b85b33a4ffcca38833e3c4badd1f59c657bbb049179b85ab86eec87a4426e5a169ecb5889a9b033a4907f79883e8d7999db650386c91870143bc80b6124c7b11ed458af307fca250fd9f0f6a5dfafef5e5b6d7ae0f7424fc3c4fb947f8974aae08535edfd4511b4b2be100c5cdf7476003c06c026619753ae7c1805631200bb0fff2ff0cff784de028fb94f0b6be853462a581f80bc5811b946f6632e490c1343603f83212d463458fd99af694e8c95a11cfce1f144a988266f85f76bf427618b1a2b58a0df9879eb4c5f2bbc2957649a9ef47d7762a861fe1554ed56860e8a542c21abee2f1bcf70ee81e65ce122e192e36f5197cec15e0b45d6a7e075535486639fe5136a8ca35e18790743b24d49818a5bddd14a9631a33f2decd073287fa54887139b0c6ab9fd8e2a4080db64a12fff2a655a4898e70194e6059243831ba8c41bbaf1980f242d0db908263cf2f09f2880fa4a3a17a970cec04f0efafbc482eee49a540c2c36a3618ac3af61626871d040a6240c705a6b195077e52b42a041f9ddf839878ce90075f76894d2ab3c2b7b5d75be9851aa0af9cf790cc9edd8f73a6854acc7f399fa6a420ee888889975f0781eadfe584c327699bb2599bc3474625eca84ddc133f5abc7b6992b04ec1cc71401ec8e76776bc20485cb8d44e418132094510f370668173567bbe9a1ad1d85cc8e37027c3b303b1c8ecfcc8e46a162c4d11f51dce8cf9a0a95b055d8df15b5feca2d3942fe3107993aa678ce00e8d896f91e09044a39fa5a2797f3ef687bb4f22909c7cf8fb95578c9850dec920659454a3eab5c9347e9b4b3930504529320797d01019a182a06d8e53d5ea93709e8bfcf2cd50e00488c26bfd6f049d9f9977815f78fd9e3a0ec0693800217afe359c53d18dbfe97ce3a78426989c77f9e5d62d3b45accbcdabe1ca5c0e6c505ce8a5430bf7096e6af8f96ab926c3005c206a253b81015c7b1046c1879bff69158f6d743baa5c6ee8c57aecc69c5584a644555304f2e0ca39c21d26acf7d89e04161922f41389d49a2ebea243c00fa9941e310734b82a7fe34644f67ed11c04bd0d695784fc7b88dda96ac1ce78118c0899644bca894945c009d6583e923261f134b2e7cc2acd5d9a12e43e902a994d721238093f06a8f6d58d801dc7206226745807cda768df11a6239fd48e68eb8a2b62c98c4b4ad67ba946c5d62aa2d2273cf537c131c56e47e939f0234bd0d9c83fbc2b6bb371c0db1696200f91ebf13fbb586f5df2f562d24fe70b6ee7aea599ab672cadeec7df38b922bd53178eb3aa2c8b43d44bad28524f6797b12f5fdac559f9e2f85d3eccc561bf9da0268e44cdbd3d5b96d33fb805033c72c50fe174f0ddf32c5c27e2174c240e62c8059fb0a428299f4de14141ae0d5f8beac51e845c3b9a461a7c1057d6b5b670100170f5b503716a8339adc93b44bff4762396641c6a6093d766587968310ec4004626253a8b341e4384001df41a8a47ced6c9f67eec1b4efa56f4908c26bb36a164d41b6118ba9da999b88f9d98f18a3ea65331c889d9cec9eca187578544de8681499bcf9c59e96009788b62b3ffcda1e3d10a6d52c37248ccf5de75ebc16a7abe34145b12ef00e343c47b7cb39b18c951cbdd3280d0d353bc20dc50239cd23200599ef150898d84ab580037ba72802ca104bff2dfb46decf3d5386f10e0ddb7199d46626b3ba4657659c566530f0f07bac64fa0ce28f5774e6ab10e491173398be3963880d86fb84ea3507cca8dc223aa5c5e18e9d41d267b2d7e1b6dd1bb38ba36b4339297f8bdcc6e5bc114aebcb3bfd3d03db53ce5080565ca41144e0de714dc303ed6ca8f5949be85a6889020741f8deb417a0f19ab9ef1233b93229009afff6adba1080882f12c13d57fbd84afbc17fac72e084a59c5da9e1949e15574e5c0311c3575f897a8dfe5ba207cf95ae5d25ab3be58dc4b8fd9eb36d3253a5961c224902467fa01446a5d974f3da7b5851822692efe2d4255cfb28582547f609e6eeaa78b8c916da6e34d17affc197999ed3dd02c4d9bdab27060e2d98f733004f76b8a560f4f4f428b72acf589a0ef0c6ed5314a986bc8dfb90bc3d0f8781742cf717b3f28a3efd71b449aa53a4f3d17bb9777b698f33044f7616eb3b480dbddc1bfb0781c3dd4ca52c1c3a40829261070d961cf101917ab35392eed6cae1b4f13de67326ffa411dd698e720946a1eb804710860d65978f849b882b3d5ba58f12e7ff33d51dcab8f62e6632b648c484322f8217fc0cbc1bde9e13a980de990019e3d641af06eb94e7d46cd323f6a92c919d0e355e433596147c38395a9be2d4e6b3f8b5fe77df476a6912a8c79bc92236a6598d75dfaa67ad7cc3c88d437ffb662d6f1bfbc263b2741100d806e7fd95e78493ff28e797659c039f096733fd167c1764b510e97f662eda3e55ad4e432e86a92ed6b398ced06f7a0531eea9a65558883d911f23163fa11a48be680b049848b34a2bd8283218bac0cdd9b359a326afe53411c373d970947d1903b4439aa2de77a19529573b440c784940b3bc3321b99672a93befc9b6f6e9878837444c895dacbe647c474a3ddc7b0c35aa6527232b015aff29e473de393ab3db5093472a23a3f5b732bccff68a8c6c0e7777e97fcc0500a520c6bb9b166aa974ee2be803a219bba19374c5dddcd393b1d08514a567a019b3d4981d6ee419708f82ab95f57b6a80d7ec6ec92e67848ce663f0f27aa7244fafcdfed1ccf9706a346c991406818b4f759dde50898f3fe07b7bdfd7eec371c801b978784e7c544f6f70d5fc8668a3cb60b3a0da481e0e5b9343c5ea51c236f8e73619e150b927aa3180d26ed879f470c8efd4743d16742605e29f01cf0e075e68426a2adb7a45bea3c97273089593a795dfea4d7673a17d37792812ac48adf3f96bcd33e8ba20af938e1d62a1e44f34bcb2292371085384a4a697ba122b00706e7d71d5aa41f4b51cb3a9518a6f439a882bf1bbc994a2eee03fe241e5cec557152e28da1249b95d31af3ab9365ea274ce5400ef95582b757891d4c80c532e4ab724f4a30eaf59c6cb527418cf992579eed19a2a29661a9e1033f4c9937159219110de4b53702174d3094fb2859ed00b75328161b61ed98069c40a45d5f05ca48911ca701b237540d7c21ac6a3e2a625be752032eb7f1caeb01dc97819fea786cb51f0b715cff347a57cb11feacd3948e8d2a4b8359614c3a8c6eb277cbe0f456e53f1d7c18b8006881889975643dfbb1cd65b64d5750272a3d21f0c261eb1082c8c884dddc30f2249f5cf1f1dc5d799b127462cbc589dd69e73a27678557905813433c8d737b69089c8cb9b560c7d3b8cb09230a4266fcc796d8c3454d6bb6ae0dba50224a38428f40dd79f5c617e994f2a9ad47c129ed504ab31a468da44c1c334d6bdb711e4f6d94488e8e54d655a3f1479af712c3d450ca08f8c1ea037411bb6c0c3b4d4391f2366fe006042c8f3ca4f359608f86d97564443126f4fa907d05cfef48210ea24174c21b2e111f9190adc08930205ad9d7ea8572654c93e4114bbd304b04dfb0d5c6d76152957bb7b5c5b223ce2f683c7f977393b068f64934d1212fed947c48a5d3f03b30690329916ea8def51fe80d20f3d6fe4bb1ab5ef0b7bac21ac67de1369f144c8c1b79feb335b72fa54cea9a9ec7650dee5a53e1cab97118914827f5e5ad21fadbbad35039d10fd882cebbc3a7f229db56969b75ab709865a5623f85580650cbf9d3da9520b77ac5642160a76a9f0fea124ed5cb8e1c46b9a208d172c5a3716fa38a988a2dfb13357eede6b34f4a40f1f90cef7a9f79f6c29ab7cf09fc2f9259faa4e3267b75eacc114781e3e9f63f30b2a7d761b199253ffee6e3d0b7692ef7c238f746225bef062706fe0eaaff141ae401530dd0be664418632b7e6383d585e3ebac2c7561929adfb60ea28a0c42d99e21140eafed6382171291ed961a061ff3d7ec9c107cec0d9f8285da4962be337b1357ebd8575e63090eca0b4141aa4ebc3a24480efbb1bc0ed6cfb38f179ef1173471aa3fe4c7dea029ff5b93d7e5d9bb045a0d5b7e96fe3d30006a46ee433c4ef005cb8efa9e7d715c944b8e183fede72d02f0585f3355248acfa9507b59077ed7ea94b8fc2357e0df46ab08cb87d113d6b84790f2286964eaae9716c71584167e3b28655d4b07a5f041672ff1e12af38eba1ad8fcff152c36792dfaba8de794f09fe60f5a3cc686473ebaf2e8ab9cd1308c4099a2db01cdf21684b007cbfa425b6b8f4eceec04a969e362ac7cb966b7f031805474fd61168deb345eb5678a71f04f1a94ee493d978477e890c804c5a61e01fe76d3795cb5205409aa9d72843dbc7ef84775c785e3ff367ad1e6e8ffac4312a9d0a79de6bc4e4d309a8984462520ccf45c3a4b955ac62d3fe8c50d23d5f0be7198913efebb4ada6f23604a889655c6d77f960218d4b1bb46e2e50f1411f6ecb2506058a8bb87dbc56abe98acbfe87b019fe9becae21d0b42d1684191f56b5bb0e824d040f1bacee53a28a21f04d333aaafca6d8a826a2fceab754fb3f00ebff2cd862624139edec09bf219298e6dec95c8bed23e19f69317ccaa4fed00866ff84dcdafda27a7224d8a4539318846fc9990402f9db713a8e03d8834ffa5de3e492f6fa0832a51dba9f88b825960b913bb7e279ef53e9557f3908513056455bf82f6aee1f9b14bb6daebb1e1a8c729573532ba11e7e8459014580f185cd46fbd22fa23b16d1f9b2d48973b5a5bc53d2cdfec248d7d5a209a1974b2a5f426742f65541a347571e36afd9f44d345bb2df54a42e663a97ff4cae1e5f3d600c3dfc2bf98f1596d6e5bf9807a88ced619e38943f6d09f79cfa1009a1246c9c1f5c6957dd134384bfa705d362d91e43073448666986b7da5ee9b5c4f140c58681468abce0e737025f99be151f965b30bc324fc55a49c9e973d592fc62a2b28c067bc74670db7f339a590cc6755a02b33e01af2731f8a0c773a6286166461a4c52fdd9f9d9522e4ec9dbf598a256a4ba90b7f26bc060b0b715983d7383fd01561dd5cac0bab696a0d1e965c223700c8684f37674390c19d750722f262e03d1b5c820ff127a9f507e2dbaf92d36b9008d22d3a19f1855918cd71ede08f7721bf6efd099eb375d47a2eef5de4fe0e6a457205d5d99d4a5d8c09fc006df59331de53ceb284b336602f7fe63bab073c65c189f5d57a6bdfd0fe775cd382427f054fd9df6483e8a56dd265695335c8ab538059bc4b73e88dd1b43e311abeb889b420705951676993f1f4bb2c8e3799e79971c9e0666119d328eefef4bd9e58e9dc9a368439cd1bb4282f4fa01a7f3281721df2a0cbc87522e3de599bf8224f0ae954bd9408ab1f35ebf8d0eba353dde82808ea403631ace52bc074d7152c0b8e3196899e7bf087e4791bcff00c1f89d1588bd39b69562945871b4de15ffccec2ed70248a31c40a8cdf97d25ee85a88d2856f359c8122dcda6f5e401412dc88429bfa2e1c58c8e5f2545e05a5a518896f117b44b13ab1f750813c7fbf58b830ddc46ce9e1fa06c1255c5f57102037844d3ac941e2863e7569b2e6bc1a2153b6f07a22446552522eb3ad2569b233fde5f7786220759cc1552d7562ca28f71cd6f7a03b9d93ee7b35c8c66ea64b5fc345f0b3ae9ec4cb5a29fa276fab8120858d3fdaaa47be1d429232600cea6b8c5ef4e2bba7951f4a094df88a761fee685538c234ff568f0934eb70b27c2ef7e261797bd021363c40961fb28c841bae4bc32f61c55192fb413aaff748ebfc74182f897afc75a37d10be5adae48d6fb133172a2ae351fdaf8bc37fb5f14bb1f278fb14edb64c4670d2ee064c424bf98402a5a38960e3fc273d83fac1aea2b15894106f76be4896bcae38de49bd595a2d1dbd71315ecd30284e6c272f9c5c018cc96db359af096c31344f67047a356a11656d0bbe4d68b51f944b38934a90ae4437bd767030c6adabed26967fa092cf5f4420f1411f2bcd86689be3f33192e44c031c49886a5b6a247041c28fd1458a0500ed68fb603c952aaee9c69d85b9fe199690d7b0541f4787a6e8bd4ffdf402b9769337ccf5bfc00a31287b788e7087f89b443b507ca9668fed363ca5d3390583d815889c6ae0f6529490927bfb3eb33c5274f2f6ee263cb7579870df7f6c331a1fad76e0c63643d975598965e2323e3c3f7eb4cd4a3c93b6567320dc106309bb27e09b4845e0ab7dfc0647402381d8ba27797b824a5bd7348649319383965ccee25da300d0a842b1a874869f876d3ce2658893464279fdefc60493887010a80bfb33ff7c2f635c3827b2d9a88c64bb0c6644456fa4d616726af3d7a52d8fbc191a7d016d6884d6a181f3a24ff678d2a8b6658d3aa5d0a863aa9d7daee5908d35c8cd7a579f68294d37003014eb561f9da3dc021e53e3d2d04101a463d3489a0ad952fd94219b55b99b9003a0d59f751dc9469b198ac15811298197dc7cd91233eb0312653a347adf28d67f7bd53f1f7808dbfa2a36dbc25aadbd8f3a290f4d5e66c187c1bcd171991f5fb3b1a09dede0e0b2e85517f78a10a6d14337f3d0cb29d3c6f7a78b6760bb547227d4c6d1084c5d1d735f89a4b2f9265394075148cf85b861af8319bb090d1446e298e473b251ddc2a04c2555c1a73be91cb6b3271e5a9f861decd3fbf2174a6d9067ffbae1932751ee0bc0cb40a50d3f075d7eff2fcfc6f31575e32e84f4b1c2b85e438ac3f66217269598657da667d4787a10ece80da9e2a531eacf7240617c4ddf508a8c6de8aac823bef776d645997f305131be3f9a0d9330b7f838c9dba472eaa1ffb16d6f82025af8bb67477a56d5e899676bf479fff41677901ecd31622e550a4c51b04e9a5baba43f471dd07b11a0c611937ab8914e89351332157f2c9cc01bee752579f6c81895a3dcbe24525f3f713929e6ac60aaf8c7f7976630058add9aa68808af98e20861d7e0c2466a99b827bae2252592c062bc6372bf8dedfff2adca01084b833e7f29cf84a8ad1e142ef93f89e5789aa7deda24b46b8ffd5d016ca180edaf8b25bb959a7a83e858f753a658414bc6e5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
