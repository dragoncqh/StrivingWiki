<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"133d47fb1c5cab96010920043335262e95379d8754f723d38f3fa117b3384039e458fe8eb27f9cfb7c8a072826dfaa6951105c8bf4dca682fc8e444b154a1f011a448ab6999c437cfae27df43c263d66bbfe8c9b49a13ea3bc74689e79c3beb35efd86eb037c443769623dad15457741f18394d7909c8a8dab041162f3380b83c25f3a2b80117d03c05022ccd8a7644c2c90470c361c7b8670b3c3d057e2503636d321d8df5a809d0f0b84b344601b77ad5652f7dd3240dfee4b9c0611cb83a25ebf397c5bb32c1362596071f99126c39afbb2dace36fa92f66711e64734f3939967b708c113db7c403970165f2a5d247ff4476755cdd7523a8196e2d00071851741d12fdf9d368c7fc0f4ec299490db5808bb2c2b0b0f2e9e930e0afd4dd7299263ebbef993cfb9b14afc13039d552058ddb996ca1069ee07173a84dc6c341e9b614dd82fbefd45f12a42f7d4eee6da127a6d298728e955825c8f96bcf3fc4efd6848fb7a42b2b26f04e4869f965f6fa2ae3637ac1a7af6715954ad01b73a9be8e35f9402ccaaf9a7c30e60026b5420b80c2344f73e6ede6bc1447e3e8925b0cfea3d5aa2860162fdbc9ed742303dfef48ffdad775034b52bf6e999c2d392b992f42be5da57f3935e92c51bf6bc864a0d6d0ca0c6ea730632786792529a7d1e2c32024e28c554355f78dcba5aef88baa73195abf1ae756fc0c622654afda55c285b810332ab6a037b41b6129dfcc7741af82191f9e2ef2a226810a01268193e48ecdac09c235e7de5797c33bed6ad9e5a50b143a2d26603a836d6a1251b0968238908d681ad7dd55250552d1d98a352e15047497e98d4a896f03d22bc7f3d7256639e6fbb0d12584d5174e6caa2423944bd1256d4ed5ab21d15717a97461e6a85243ec93f8cd012f7a7a46c1c7d86f34739e6c0581957a97559cb30c3233eba42cff14df1bea4939114c75dd0d4cf4a33853da883969f122405c8c1de1f8389bda7ba72bc42ee74e47e84d3c6a55d119f5f1011d235df03e2d1dd89942589b4efedbb9fe146daebcf1b4d7fafe2aa576392c2a197faeba2fc1648c732f1f505aa34d787bb0177dea4a0b76fd23f0566c1147b902739dd5b5095e69e22ce62a0800739130e2ff39450b8128d6b2d9242c62c54e339c767c7ef211ef1c5839b79f793baf66b02adf3c665ac2e54d21e23e35dd827d1d94128a978a95935b2922a51ea5caf98bf2d867df4eed278634a9535141edf005e36ab83b9e2dac14b70c28ed6cde40ad90541751b70310d80324265454958015d31ed745a5d25ce193fed2fb8cc48a1de80bf99640f2b2781b0f7c7134363a448a14ba11f606543a189402962514b72c6f97c0133908e541827a045e19eda3e11e8a999a538903178efd4634e38ec996c56d95075ab6db6228993c848d94904ae686dfdc5ce32fdc4ca895fcc8aa3332fbf17f52c7f2d464aafb5c0e8ba163bffc5fe265d3d0ce516b621ab0243d2327264771c1ac86620518390578dcb67bd536ab7fc781461d9a7402fb071a57dd8387b93f71124e41ff0cc259b5413e9202444191621836cbf7d3eaf95de29a4fac08f95522be7055f4d8dd0e2645ddc5711a812955f579b3f55bd4b4abb51ec2493a6723193c2f2504715b34017fdafadb62476bc44b36050d570f2dca47ac299d343c2871e51d91ab5b61758fb37d4125a285215668942688a677d946dbd6444070cfd8d4626b0933ce376a0f961b6138ecfd38e6d822885d8c4c78baead0625f20a740aebbbaa86e040fc5f62d4e171d757d0a34ddc2aed3338fff4ae43bfc62d0f3399a316735fc21889f41ac2ddeb9610859b3043b9bb941a93a83ff7bab270979d7f5bf28b1130db01b4e488af285641b57f83fc6167e87887ae4bfd2fdc271bc40e7f4ef17c35818368a5c167a3954f07f6fce41d4e69def2060dab10c66b171697df9ce65817f85be4179a5ca76aaf6464aaf4f9dd1453b5bcc207a827048811bb33275a7af9d76934f7bea319defe010b9b4b1ee5bec4f7526b5be72d4d25292b2eed22cff68906b4b47183536de9a45871dab34f5d5449914a840c855f978fa69e3ea818c74e642a42f354cf8f643ba894952e6c0fe1cb60e626010c3a80abff6022180d4890a0239425b596eb489c8ed0a9792ff5e1e0140089fb9850b0d192e0338f42790a5a31418059083c01e567fabce075ed1b2476da9fb846261e4872f47c7a59328784d2303c25bb2ff67472b3bd335629345cbec295eca47364fbd42304e5fe765de93e0a1d74f817993a6ff58b7db40ce00e1832d8b44416e1e4771351d315e1a8420609ec4b1d2f1579ea0c99516f3d5a5a031d52c99254868c10b3731929a99ecec0dd329a74682d06af3fbb7ce0d47d7bde970d2a29f6775f6c34bb39f335251ceec11ec59cd9227a52fcc74d785c9fc3f32b51dff84ce3313974866e61254eecfeb6b6ad58e4880e9ea43393fc07844b4ce15b61ec83d5eaf5e1ae4f717a35091605fb71e906db77c20ca4e265720a6a7bef53124b82d4e33bdbcb5ee24cfb723c355960e9a68515a11132724ba3d7dbbe829caa10345829f7143219d901941ae506e69cc7d3729bb95415e69edaf71d9f50970de3a149b022500207b4a20688cd907a87be3609e6fc28e2fd78ca2f8d14f19eb85f4b9e70015209006de6bf5bd5a914e29dd4b85f6880ce101d722c6e2ee0fb71b21cc588f87c0277c0206b66c1fd4f499e59dd5f2b89cc144504dd701fa49fe17bbe38d51108974c9fb5c51c98553113afd681e3c79a5e77a2d1ff93391a5ecef0e6946476c0bb00564f62c1ac3b061f302a735088c783601946171ff8f36d0edddc70c5c09031b1851e39a938d6fd5f2751078a1534924976d0536b39bf98243b730ba00ba6e709484346ae932002a68f596085ca3340f2ce6554f39b349c75b44587da4777755376c0bc49f30a3381994fa4e469b61625cb7f1fd8ec33ad9845c85173f35d6a0039ce040f58eb62b973db684f3439b85cf3204c50964acebcfef4b222e9b0cd9ed0c7cbabf0f61574dbab11db6c29cc8fb3d7cc5faa6329916b33ff6d1e1f02c0787184f4c34e3b4e23a9d0e8682c7bfa68375350ff7146357995cbde81952e149cb661dcd7a6c7838e1fb518efad7d00d6e60ece3469e7092ac40c3b513fb0108d479522d871696403b155aae82680e59982586583385f36b243a2632f400e6104aa342e249bd3cc2c3905c422ee49ea51d50cb5262977ca14e28dc7dedab5dfd14ea7104be8a1c10c741341a851a504bcd17928b67c66b67e5f97c1ef9a513a193e807a3cac402343b24153ed59334c919b939ec4f7ac06c7ca56fbe5906a5c0a42746db588e0fabd16537ba604f6ff9cd35029b6660bc46f82705bdca93403e81143f079798f9bf362567504e75666ec909d07d2c554e9b0c2ab141a58016a77821c37fd5d94fcd6178d345cdba39599351eb4e3fa65da9ec420109a884ad325f096342b405b168f6c17638bd2ee51337897d38a75333113e11a703be8a526d45eccf8f930476d0b3e763a03098d0c65d761ed43eb2ebc64c94dbabb18368ba6d033beab06be8f7b73b3e9caf7b5fc7c6eba5ec5913765dabaee142de62827c5a26b06335d40e6dd93acfc6a24e13cb90d30ac0489e51e7a0f549d1d56d09872c49d95f047aa97ff5c2e5115a4c05582170232e681a42f7a960d74a4113f5ffbec7d7825af37466b216760998bdcd216840a9ef1b0f369ea1a0dbb47195431bc0ee6b590237fded93b760d24a7ebee265f2fcc834a4c7d2e0aad0bc17528a2d87df6a7dfd8f93a8290b227ea46f0ed0a97e3523ef456d78577dfce732d3ea6e268b49272359abf83d17e7eda4d63221c3a046f89d142dbc3fc1a57a2ef0918c9acde47af0d16e1db37ea2ef21c9e8846fa0bca39d4cfbc0a2ed2efbedee84ac54515304becb408652e3eb2da4c628156e2aa9504d1e26e913530dec94428572d6b8784bfdfe8579e422fbc8dd131787b2f725fd55cc2d3ff1218ff34f11184506517703b3b895a28b7f43152ae1dca1ff861644361c6442b4ddb7da451786fd1e770acd4b9c67d1f8c58d247e5896c9f1bb9edc90fd82a524fe4a708dd13f5d8f83528746731c3c640e868523407009a6bb5a5a226688261f8e7a5b3570f3ee5973039f7dfaf505777d401215ce0b87dad7ecbe82ee5998274dcc9ea4e7d486ead851bf4384c81f4a9f29ffee5b15692174871c8824bfa26ec4e08afbbc74e3561c5af017b61abc1a3ccef795c173fecd2d9d84e3df0f6bc31bff8b35ec206faf3735332d061de644e2831a923e7f8335f996d21774b1d15212a6eee8ee5503de35dc0cc7ccce234fe3f65df05413ff38a154ccc5678964abb1a44d85e4f84280c2f0bd059b69a99fcb0dd6e442e8b45913244e3a951b404c1eb29ae2e65e93c71eee5c973fe627720cbd41a160f9c8504704f56ad90710bd6133847997bbdab56b3a608f4481358ea064955ff79c0b7ba957c440ca5a0dbf965e8179a0415f63c857ab93fed94b3fc181390b28fdb60c16e5ee8f2f2dc160e8d4320ea183a7c130f20fcfce76e12381ff21cc397193284207bbf46675fcbaf24ddc3c682b45c75c950604f3e47d4e6065a43477a2e75ef04ee81cdf756d2b85325234cb0f67891a5d37d4d8fd667c8e0edb32012ff1880c2bbfe7e72d4c052149b4dce57cd14845482a3ab1f7c202ef23f6b21113a7eb8a3206091d76c93cd96ab48f23973eaba3df7b9c97bbafe42bfd8793d9961fb669bb908d612b2176cf2150c160dfb72d472d47677ff7657fc69bdd09b8ee8ca9558d27bc56058d06b1cef1354da1a44afb1f5e751248197050cd9605b0f76fe9b6ba62ce36243bce3bf47b794d6f9e52852bd63e7066dc07745136f601b63b472a8d620724d2d7e84a5bf3526a979f6b32c8f633271fb4c99970fdf7c564d570252ade06923de3c435bed0be42ab31dfec07b26844ea1eaf9c8383686a016c8df89b937238504aac25aca392b18cc7620ecf7e4e0c9858b2359f810b8a0345a80298ec994cfa832b1ed31abd0dbf75397ee824aa8e95d79aade1a7abd4f135e6522264019cced020d8eda196562c12833673a99d2d956c12ce724071a7546afef12d455ea6d454e47fd93be3cc649e8ce594eb1609103401c88928ca77cb5fb7843ea893e63b0cb8d2a95a19289fc9a61f1758d5deacad20fcd1eb76a7dfa89f96fba36e7fcbcffc1be17e92c16e9d68e5930e26ef12aa200e56ff6bc5c1904a998818ebe48a2c434d44538940e423e017f6f2df885d12239d01f5f67b0c139d0c77e638616b7a61fd57011b9e59b0ba747b6347d743c6613f35b1ca00aed00c75a64782e5e0beebf50584ecabd42e49869245346cd9a1ad7c8955f70b5d3bf1d3d3cc9930d3f4064c64524c656b6683b98de1840c101c45c27307f5f3839f1a19575c59c75cc9857e1b793ec4a44eb1d84b1d8c0b3eb721f75d2a7b8544c493c08690bf74a927f23d2038cb0c7539af48f3084ce2fd469510f1976621201da3c1eb3155f4eb468b3ce47478401323acc11275e78c1fb4a8353ee5fe46e987270e62109e2d18441d752e36536be6f97513e3b2f22eed05c09426c22aba61ab618214a7de3b2d61c92c8fd4b1acd92a5c92e87c8665d89f7d1747c4536213a3cab65507fb1cfd2c31b0fcb83e32a470d5e1a6571de7223e4d334ce124437cd99a386b7e8b9d0e9bfd791a42c9a9980503572708e532daab05d91fa9d68830bba6f71d4f0b9c9fef316fdafef8674803e177f4c6e07fc833979d5ea88dea15bd58649e44fdbb4943daf0a7a2477141ac8acfffde73b6d1a831fcd81904c854944f7a52844eb65fdd2ae6c36bfcd5eda9fa53c1c14520ab5df470d603645807176abc09d79c518beae828d0e4f644f4ae92bc6207eaf32b6dca058085df9d79a00fa66af11312f1418e54134be7db941fd0b546a0079f7a9e5ae848b870d05adb49e4838791d595a6252942f9cf43a0c49cdc9ce702e05697875d27675c35dcb08c80176c6d0ef3f86f8c5ad80ce7b1d5cf62a62bda0a17a3addfa6eea56bff9c660544f22c1b32737f1b0028ff569eda3a8c497aa632767893943cebdeaea0951468522905e68a1004faa6ad03026c1c22f3a4fefd4781567eb986e8fe13eb3c03a03d8626314536f61967c7f92534815ccf141d7d73ceea55543afef1e4bec531bba4576914ca568c70387997bd20e0b935e043332d37dd498a0a34876f7548adf822ab1092b4f6f690524f4a42817d34c0505fe1edc6ae96621d7e47d608f733a5eb00f58ea3646b0666be1e15a4804bbc3a4ec48f16736f1a850929d96898b615f9adb8911f8110bd8b32d85c2c830e0ed9e8d09225e48b6dbdde2ba16f8d95b73b30209457dd19cefadb84a2ea5c9b1e7770054ac426de585e5dcf86b7efe25d8a176ea2d5d335adc81f582369d1a66be5f8c770b8d88cae6d231e9aa43c110fa6e5d0803824e8189149f234399a763bfbf98880f3b4d3518f48e9a0e2227c1d8d297ad57cc20721fcdb09cff3dcec2093a07b62bdf17d0d22960fb3544302407a762275e066d206803135649dbb9fe1a6b50a5e748eef0af131de7535dead7125718b22be4c603ccfa26790477dbbe4f3817514fc01bea5dd7e798743f9efd70f579c9701390674a14410aff145c05dd798302a1523999a7d7e98f55de3596dc63f6b1fb346080b4a93805b0450d44711f74a2a8184afd96220a579cf1e56a49be79deb924e17b87aa88b57274116d37e43eb7b0eabf88b118d3fdb66356088ffa920e332e3448a10b49792495303d27e1f5e486f4bdd5f632ef8df22d95ec12890c6df382cc5bc49d6ff345fcab41e58997c56090371b754986af7424a7a90f9e8ff2fc6ed50b60f87b5658f7a980251021420bfd6b89b275ac098a069ea9f7fdb5c9a3e058c95564dc1637f5b3f3188ded8fcc277a778c927c7adfa223c66aab100bdaea47d14edf95098ae0e771c5101ca40353e186928f46a0cf0bbb26678d8b31406214c3c8efdc8dd2a383330c00629955cae2d0cdc1ff5c47aef79bbf23970e23efbec444673ed3941e6b4ffc55ee6cde27c544f0a922606862992baebe51fa45146ed929be6956f6d4957dab57f923dd6bddb703e683fa655fd00a488dc0fc747803132e85fa77b4d2b001f95db9feb25140f886c629de378511e01bd65fcff8bb8576f4158e4080707d2620ecf8b78af61bb6529706f9299fb5d7fa8b0c741c5d570a661ac36a142e8bace0d5a114fa4da90fe6bf89a12bed17aa9397f2d2dc412dfe152067dc52cb01680363bc47219986a5dcfa2c5b1bac3b5e1d0eda5c9a464c959b72192a992c0a25c4f7170a866ee3fa28dbd8d66212de82f0fef629ce05972941d212a50958b37f5bb8960ae807db9f323909dda00ffb1e68e711ba638eb0847a8b922e1e1223a50c5c1190308473752b9cff62bb72792b1d15ded69f8aa014e6e541fe026a8b6e8c4c7bbf4ebecddab8b2597a2887da5b424169cff8d1c4a14ca52e975a7b651bce9ceccf0587f56a2d73b5a54bdfdf4bd8be169d843e56f1d1494c74d970a1a37da253f67a563d1892ed9a24b9289c39435a24a578a9a2d7d1ac667470d0bcc06350531e6b6f8e0b7ace87037e030d5f56392ccd1c0e34e9e598bde8e57a2dc2544716293db2fb4ed5a2cc26f6a74056ccc54552366f4a6d6957c36e3031f820ee2169abbb2e27184a752a037b622ef559486398744486cbd561cdd5b106c8846d4286dc623d21df83ddf8f2fa1189118fc643f1be2a3b520a25154f95a8aa2dab64e5d83581d62acb532ceb97a5d01bd6862f39639c88c28024b1e7d50113ef3c696d4aea050497ae474470a4e2aa4899ae3d2382acd59a06fe6b919f096b0369e102f85c030e36b1f1a1768d61c6403c147b5537f94c2734b662f0abc65aa3b7444c3fe7c96a8aa826df9cfb3f3b1db8a8560742745fe8dcb66a6b995eb8a72b733d8ebaf7dfda6d9c9f5606c3fd338664f88db931d2989e50526efe954cc935d4cdcdfa3c54b363240275f60cee882bae632492bbb4a4c707d9808e45c30c074d123eba166b3a1b7078432fe8b7b9cb962ea8ad29ee0f93177ab7b8c6366fa5ce0849ab837fa7ac4c1364c53b117f596784a25659a13a4b7a235836352575d18e2c59d367473f7fabc18cf99f59faac0d48957eec56273a324bff4c9dab7fbdd45483f4f87ae50ab90b32fca1abf7fb815bb91fec04f4548b46a639b3d4265d5fca4bc850735824a6ccc36adcba8109c61ca8aa5453725916247286af33d190ee017410b9d258e170090e20998e9e896750266cc720c5738384645f3dd2140bb980c3897fb5fb8414dc21a66b8c5c7c45fd1314a3918f30100998de66f5c2207c72b287ddd643a75501525cb5ea865b22588ec3f8b3dd6eddebe8e45780c13efd4bf6982df9462f8a3f9cc2dabc9152e6e338931df1aa1e35d2a77d8daf1deb50a0fbeeefde063830ab08eec98fe118770b7f01e5b2e782d8d44acd2d452db75ef32af68e88ff45d543b92de13f646eaf4dd24000f3201347ff1dd3a5eb740ec71e2c0f5f600435f730361f4b541f400eeb99e3d853f1dbcc6e68c93c82d25ee33ee071f58b20ba7e52816484e26cec9c3adca9412ace92c3d9e9f964ac10c7d78d18eed74a123630200b8a098fc02460ddb75e75b858ce9b2389807cb003e260ba7df3f7f3862b763c998389327cca67e980d13de58af98abacae6d7916ff111a286f06dce9c1c7abd6c2a05f174731d24be482ce8276037d4c201b7011a17aeacd30dde10e83da11b72088e42de4dc93a33d24b7fb558a4f039970ebfa8169abd6ab7071dde3dd92c3114560a754516b9af72ae980fdd11de762dcfc0bf45b0e6f72062309d3bef528b947912286b1d88293f0a0af0315f442552b8aa0cec58213cc98b1cb3d6e91090cd136ce2a680aded87af85f7cb207115400756f3043468f1f125023b34f10e7ad0b9c2ce1ff054271bddb08fa5d7687e15bc4b25254679128d9f89a98f0ac1c92904e478cdb9247e0739ffb1c5f8748d389294f0a4868d1dc6b1557ce4d656697744ab3d0d3468522686f1134effdb6fd6cd15532a76237cf85def7f655621ebfa2093888bf28d4ac444ef9b6dc7b66713b20c5d98aa44473a16a537863dd0f406aae853c70fa69059b503ed24e0628e9a758579cfb15e8eda88bc2bb77bc5decfd59c44ada69fcd9122e55cf2cb6ee906f21488e6c9a75db4f20e9ff4e74e3ae3c3c2d1b2ea2b43ada23abb57dfbf08b4aefa1a8a8bd85d01559db1b59fa3eb2a15208cc8042123a2bd346254fe59d8a2b2a1f3d6df4a5c4918b0a502c5e6a38c533eafba92b9488ae6dfd96484f5eb0be7c44b468281b420a7eeb6355c7c4e5ed8fb79cd9d734db4b080943c647d7ac68100c7193057f6656aff2c8a10b15c0ebcf7dc2fd17d0f4b8fd648cd1f5aa34806d33dcc394744fac0e9003ce45b9eaac9b894cfab2869458b2db649d5c8ac2632b8cf40742d834d266782774eb2fa2ad0e56e260aa983956239d93fbb7068847219594d024b85df524d85579985bf45fc3b1d00a2804d1d7177c86a134fad84b6f38c2e1794570806d616eff991979a11f7b5234c297c589517fed2161cb0aab558bf36ad6316f8bb73e84a539ba38e3696971a18f72c9b48da3dd3a16af72e30f4b92372b3d081caaa301d6aa6c0e0adbe6ff4d5520ce56f53356468bcc7196bbcee8687a1710de42a9e8c2e4dfb9c91462c0ca144da7dc108c5cc0943e636db1c7a29c0e75e3f08b20b25021a324d4bf176edf748a5e974277ad9b5d0bf4e06d632c1eed98ae5bb351e191cc5bc61b7e7e8723595c52f4413128f47fe1829f23e154b954f17c6266ef9c2e48fd5f9cbe279ea8714bdcd6aa8944b21e312299e83f3ff05fbd69162a8af974d48fcf6d5dc911d8ec8c4bdc588a8ae910d7195e4069dd0da0de82115b431aa6243ac061a1be16580ce1853885f73f66bdfe75fb370ad13e08b18c014d0ae500628f0a0389b731b56eb4e3a0cdb6d55261914126a4c75207c38409a2a61f7820f518f44e21016018425441ba2a4a1b724d657202c4fdb4ab4e70dd6d02302c535ef15f1ff2fdee882c96e07a9dc68bb93e0e67fcb3aecdf5f2efee4b14a6e693a94ff6ca9f656d2b85c1b07271e605e4e94ceb51e7d08e1967002dee0b7b18e0e0fb0eb2e25ba38d536cfd0f35cad33cce7b6ad66ef0f86d675cb8d656c91f600a14b0c27bcd67a25fc76e698388a2200e74caaafb49aa3bec6e32d310a54f675c8718b0cdf6754b65e7ef4316e4b9be087edb6bb4df760ec58071f2d8015fc8c19b2b1a6de5a508cbb25eb9381408e893d7d3940aad253be8e09ab4a049e5ab5460d42a87ed457ce65cdd3b81eae57de5e832e630bf68ef76985a008b036fd7d446ca8f7f929f5a239c6c3f94cb30cc49c8116d162857dedcdf9820e1cbff8efb2f4d3df7137f38edc09be3d56c0410fb351b5c0e008dd9aea1dbf072a2f9107d8451ad54593a012b38fec7e630bda9335a513609ae0599b64faac56a4a1eeb9d2aca9516e80a7b0a68e9495d865e8abf15d16d3d967dabe1d5e9e0cb4e22b634ddf5692829b9c96c1b08aa02ca6797282dfb6296b6c1949c263ea74455c15cfc7f98c2537b0a41f6e61765c89283135910f9feaff11c799245879b18d480a2d0abdfc131ceabae2337455f927951d9edc3a52794a4744b38304235150f4dbc22af4845f7efbf58546b61dd496e1dad3b1d13d52df66bcd2b6089a06a86f987d13b71a825efc526f58f06e03f018ff1c2115038d0520fca731063ad4c60f8c4bffbd4923c3f1083cb403b9ba252146a21e9015f492e4d237fe66a5b5a517fa08359c8ba9865b801aa55d549a4b8229561fcda03ab8c52ed9d08e7bdfdf08808db48e585e88008acd3569df2c674ae6fc71f5b5170e9250f0002623ff4850c74f44e1d79cf56962fbf402374228c7c0a4a1431bf401cd821f847e6de0bc7a955cb032d9a95694bfe451a02f9dff9764c0a59156d054343f1c5f5ed1bcefb8760091403561761c3418b3cc82b1a8737b3eafab85f0f464d261a561fa5075db2e98155d539645717e0125424308dc0dc2ecf0801a7fe9f0dfbb1d08cc92821edce66e600c0e5d7aa5033db058469496feb9dcf485d90b6474c548238b660954eb4f2aaf4407f82fa29ffd4aec4a29a659745b3efb50312781d07ee4bc317857c2c1995ba72948d4945f16157a98892a7169dcc1b73b81249a2913e9280d2cf5903c2e577ca1578ba56f57ff8d07e6c712320c03fd6a30160e0012dd610743e7825ea394d10f855d39ee4908f5c9e6e24d893e5a573fe4a180f0765fa9606a9baefd1353b43b144a2aaa2ce542273aa1e7c1b6cf847102d90fb9b8823613b26711ef1e7019aff9f0a2f4fd8d8af95856d2c33ebb6a1de577980baefedaaebeb67469216a4fbd22aecdd011628bc24ff02a319d17391209a870d00de5387d5b346d738b2c2812b5b23925aa5d5bc92e7d00b75fbcdd7efa170aa88ff2bdc351baf626a99b86e2cb1aa8ad049e9750c33f139da2bb3dc39e705d4e00851b35e79eaa4c924e4fbbbfe02dae6ca6ce834038326b8169c4e1a75011383490a03d27ea21ba08959509cbca1e237934e22ff0a413ce568b792bb9733b5f8536c7690332012adbd19cd372590c96987619e3da9d3d2ca30d1068de4cd7bfb3b135ff69dad18df7c030a4dcaba1064ea253b59088ccb2d0e56e77018350ab9c584b982f2607de7ac847b234eaaf32aad5fe0821e37b2e8108fd1c64025bd6ed52cc612facfe856c8dad7b5467acc97a3efa304c903d77de320000bb577f2e43389ae7b47b06956b5e9ad5b93213416fa8b79863b4a01572453f282e68e24d5a66f180181ae8762d8038f70af3afd49e4a4b2bf00ba75391a2b09bfd917bcf674bfa91cf8fbe8b1144033fab3314e2be14039a8d15ea62ea2daabe68c862fcd303ca0ee1ef4faec09f4cdef7dfdafbdff402102e0366e9e28801a6d2d2ac2c78cca8411b7c2019c402bc6ab4840f2c85c039118b20df2e00aca7169b921a7d6e70076a7057be897ec47c9f71229e50a0f2d2c3d6eccb0a7109c63247a4ab7e51c0e78d902a749c2dac210e74461ee3611a41de1971ddacdb4ae27b895dad42f59794b3e6e6661654988a382a305245b5a0e4cf45efa506bb0b420d2bdcf0402f0920823fdc49641f3be61f2197af6002e2df896b73f25d761d07a9a5d1b205f0929500e9d22ee0c255864e2b15c5228046ce90cf10c1c3bf96040482b38a842b250977adbfcd85449e659d43ba3a1facb291dc3169e2cae3dbe5a620dd0ef5d396ffb373d78de74161662e8278d91b643b908eadc01f9b6a2917a605c6fc3240a3c8372e0594d9d2b35723edadbb7d94b3072303b25a5dbf17ab6a7d0050bb7bed53c8ebdd55339b9f1c283b4bd81fa8ebc0d93a1aaa77008f2974f40984d5f05fa580266882e34dda3606146cad1fa288bd4ae3cf4afe2fc563014030711e4dd5b41940861d74c7037658a12510957c48d3ad164708e5c9a3a63a37b5aaa526a75c96db691a4143e03d3d5c9e628faa0509a8d9a6193bdb2149e75981ce9c2fb817f80d15389f81b9c364c87d392c96584d7747e10b166371f8aee6808f4d7c1b07ecc4eeb1edcfe21ac167c8938db1d0d2909a4c13d50c9390450616d918ace55bcb5a702add8ad9080428596308646b0e79ec982560e756efae0188fa9884c11646cffe86ec40077ebac3ed7d7b4ee902540d345a98e1042313b6af3a3f8146ab1d98e2485d27bb443ad94e6109384901f9d8ff34c61955f7ad633014030a07366b99e41d62b322c32f5248cf79cd7ae2dcab5129c19f84c98e74ab2703bee94f38c8cb016ce810f1f760a152b12c30d3cafcc8b46c0c12e11e17ae26c83a7417d0db59a19212f499041349aefcee9747ea7fc6db42065eedaf923be06b392c957495ba80b405fd20fb3b95dcf850eb366e5fd9007a01e05b25a32a1369cff15dab65b13d5764c076454d88bf81ce34adeff1d94d3bfccbff63ecfbecaa847b5255f6d51acd044bcc5ded11dce8e767e87aa65d7648f1900b35170da02ed9cd068448809e8e64ea37251e1055c6b78d020075336e9eaae64cc39679cc874630f87a0788b4235bd5b2d20f0b628c435c8044f54800fea3bd97ae1b7dad1833e5da4cd0c27438cb484cbaac97e0684f9c6bbbc7af9b80d0d3d29d336d1195f68ab74dab32d786ec3d514ac5f847ec593354bbba3344743fa45288ef80584a6f07d622aee4f6f28fc939c34ecbc90206157ed4c65db7281219eac93bf3596c446b3b0d20ca4d92ed352fdc019f2b152e2379551cb91c172b0cdf3ddc99775355eff908495a5a0ceeda83502ea19068ff4c279bad20ef9a583b6cc24ece422511653b35c121397ffe697ce8ff73ac995d3bb1ba3b180467a9514e606fbc167fd5497f3ca734816100ecf49570ba841de736f8f450aab6c9b5cf1f0ea0282d27431627ae73d1280291f8f59f440e7b7dd87e9007a5d2a83e9057c6bce32c51efe8f425499daf04b3a39856d4e08027f31e72fd7768248d4d50176b1548fe33fc345cbf5ede311b30b76076ffef1c28c13c2a78b584816a6c038206f94ee56ee35edc5f46c5c3ab01819ffacf34139f4864004e9cd1fd050340bd30dd3077b434dcd1a296c6a87a067107e0ff26c330a668742a54f60849b901270eec4ae7fed7e9b32ac130380e1e859da84cb11ba64a4bcc078a1872cdf0b8a586894b852e024787eee864792b99644c09e37d9705006085622e0990dc89a2561a01c8acba3deaa6b436ef4543ecb0eec130a4586990b2059ea03b3f0a32f43f1533a5a986873ff87f11d1a432be0c5982f92954ad5c038db97524b0aa3f3ae20e67a0218e3bc3a4e8a49a4095e7e98e64fd69be7fc0ad7a71a16e90156d6c7259dafad21d7e1a3e8dd8f53b40ba2cf980c087c987c0fed8467a9139a2f2f9d1d1d25288f7c16da64c88393c1a04387b8611a1468232a2d9bc3c4948aa658f747bad3914c421eb1ea9a166e86e587b475750e881b5b9edff6fd6fff684b8828cd6e4df74293ce5c591bdd6a98fe8064cc0ead847e32dd9320c995f94e3b62eea027d2992297cf4421d6a304e940e0ef2d7a4cfa84da0bc67dcd4e89c789681b330d4fae41e050b04824054594483898c0bb2c76e7eb8aab9ad4d4271d47e16660031ca73a1e057ffed1a99b6fcfed7369f925c74f583a0fa2688887dae03c1386bcd0fded21550bd07e5ef1749405571a01e74e52d5856b5fd553a3e46560cff32e8ed95b287f0c87250f346d4eb6148ae324767437812d6ef19b894cb4b4f9c064c91bc83f72a87b1991cbdbf93d2066e83451adfcf2a6e19561283bb28f514c25a325d16224d4dbddcd0cad9af042cb1af3f243ce07c965dd0bfa07982f1008d2bb6b4c94249896f990571b12e67fac12f4f62a239bd94468ae26455182646e282a95992fe221c1fa5e55137269d751cfe1a14134f7e4879709f67bc6543780f2f4835c96b7cdfe8849fc85f1c2f1ba0a5a6a784b6467a459c3f87008666d62985b003bd82edb10985fdbaa63d508a67b2f07b52f0100536cbcb666f3451173eebe3dbb9c9437fbecadc97c032a32dfdcf8152e4283195ce0b8c916e80a91eb98c3a40b5d358dc6ecd1fcc7b8fb2e4332787fed9a2e499b99792a664a9e95ef706d278c9a1bf3ed8aba91bd00ee83d2032500251760b2801c58f8b86cdcd6944a27251d85aa754c7bc4915b5cbade325b9b8bccac4d9d3979be46810dcd1a496d0557f2a9a88ee25ce146f91e5067baf8e8c630addfd12bcce9cace746490a0f607e742ef325006f8e23d2a41712892c094e044aa290bd7ac3325a029770e5a833ef4c1d44c856dae2a52bfa49744d4d6b80ac2dfac0c2b39395bf70826ef5dd01e0ba52def7ff8eebe2a8ea4d5a8d6cb65cbc8ae9d80a391291b97f5ab60845f1075c2f12ec99b6f2fd2a6bcfb5e4ed6dfd73f99dc1effc29701d0046891a3cbd865c3a6bcee0a1ea555fa1f76f2ed1171231be28698da12c9d9e79febe5085334ebf56110f0d552cba07dcaf5c892e5fbd999b4ece7de6c05896b2bf19d970055ff6aca130ede1f81c6128ca08086b2cfa22e10c17379828a0a8dad1553902586c722810ddf49410be5f1e2a55bcd2e9fcc41a00684a3af41beb34ed541b3b18f5f37d098e10c3fd302d25c74eaaca8da00efb4646d42529dc55aaec59d216c80fa31fc056d29e9f85f9874e8745df47bc95cb4fe15d038f94e8d326b263935e823ab54a3bfbc3892b5b92e7b52efcfe986941a6ca0274d5ef8b404f03b6fe8b362ce958a2069ae1e5f0ab7d5e9acde4f9b9f0be5a9741618458294210a3a91a6e258a6ef99a0c1e20c086a545f4f670e1354d70946e4ac41b5bda5a2eb12098b55c64727d530295f4bd1045b0e40ed2edb553aee5cdd106dcf5b1198c1d802cd5640c3ffc23d4db216678a3ee62cf190519eb1e1b6e055a84dc7b3e542d9f518e5a5a97ce81aa7b94813df5e8581b9320b10c28d8b7d3024e566feb99886e288811bddcf830df20d72cfb485ff9d363d8b4ef6cc90ebeec686420c20e0c9b0deb9b707deb007b7992700446295423ed346447be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
