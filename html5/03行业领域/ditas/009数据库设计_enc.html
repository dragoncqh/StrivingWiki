<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2e12ce140fbe6cc0dba5b3409aa9fa698314b184f03ec1c6014e19ede2757d3de48b7cfe557f8b5c1f974342c8c64c4d39006909d5493236af866cd8e42737706802552ce4b0cd547cfcf86580f81f14ecbd930688b56dbd9c6fc0e01bc1767eea63a007a37b7d0b41db438f34c79b82a6495c7ac6f8ed4a23195fa0ba0d48352142a3e3b3ade5314b9a7d461631d894a84c61ac80397bb9173fae8b16c639375b6f28d4a614d54e9ceea21fff4bd4c68c8e43bae30f01f75bf5b65e180ea3677cfc2619348f977cdb286b6b30cba8c646dd9773831f52838a6963fde95fd8cb28513f5753aeee4a2c493c9b1e479d5a4a491661d85a8ab0d30c29f2ebf9c2f08fc1469f70e77d2ee87d50f954b57cee9c1fcc2b1cda76b05bca33f2795cc316f6d94ed20d25f5253b1e624270684f12e31e45f81c7676d10cc4a7856d476f36e8834fe31945b62aee97b444f704a9d67e3c1ee28fa2d5d4981bf646eae789372dee14e769b75ab4d2df938eb48868ee27590085432850234d6b973ef029e767e729e4fcdaa6ae5c84dcd7658cc70e93e10adf70da3b5702c19566089a617b5d405e06f36a41adfbadbafe7725506f0aeecd05b9ef1dbcf8ef8e115ab9b2dd2af274a9c53164f11458f08c137179250d39440135cf3fc536e14df6fdf9eb173b63fd9c4eac46485e811ca9b136dfc457133f6190b6c24f605ff388636980efee70893a7a6659955719786e14dab32a399da58611ed1b260df8a5a9bb1400d3b90a51e90573e026ad4fab5e4f0c8216044b9405e486d8d9ea013e49584e360607eead0cab042f49770eb7f6c65f9df48a4cbecd4373c378c381de4dda00dd8021b3a52360e4a06783146c0e51803a5881589b5fe5ea0733a37fb0e0f7f861e2c68a029e2515df61b87331e4a2fc3d175c668daafa37acbc3eef180f20d0a1516a84951e1cd11268a22634f9ccee5d37aba0be04146e247333c94707d0816cb4be18cff75ea8d19919fe538995823015fa017bda07136a4df4aa8367df7848eb9ea95525b02821cec65e632a2005f6901a715732ebccf53fb6486d55a61a73d711f42e874bdedc52215e482beb833becd449e270c99949715a4fdd32b09f9e77078d1f232c22f937011028da0e97e0e20b46d20799e4c3beaf6f380eba4ecba67a6d2897aa0bcefa207cf0eb6c654a352fda5c2c3ec9c2f7691b0d708e769fa4847adb63ee57c7e831d47562d83ae3e24fb04b77f71e30c172cf283a72351dd6fba90ca12e296c7c6a9014cbde92ad527b0c3eeb58f5f69c2d02083d8571ca53d5aec982d6bf6fe7e9799d50626dd6027a0638af9a8066a7022b4c340ae00c1132cd1ba2d676d242bb8e9d0fbfa05219108949d3fc5581253652cef8fe9f64a40c82b8fb6134ad7b91160f1e0a50ec96876143380e636af67fb1548ef985e3e467e452ee9e11cca4bfaaff5857eae06df0f836e768701e32a195666b44849432cb471296c3cfb45d0c31151eb132360d397d45c834b8c4172a7566f4f67fb595e9c8e84c97e03018d27ed6a811cf2156a49442679417927c0c907358e91f2c787209bc949a4cc3d397990151855c231aa0dc26966a2726f3be3e44aee116352bbf073af785e53a423689fb64160f605fd8c0ec220180fa69bc520692186d3d93ea32dac2b1d0a27aec4512d62457df220c8a7863fe0c510d5e03ad72e074d97ed65dd54fc6f53f03ca002d3e0b114f19ff02d0476435fb1b839723e59f23819def523e5e6efb6b85b56c5ed6bfc90d20a0eb2a6b8445b490b0efd0c5446e35d861caeddfcd8daafd05cb94652bed9ac474bbcc9c1109eb70da276252961380ede153d799daf66fb047a7698bccf7f04b3887352e2eed8e2e68efeeb7f8d951f089129422e96867a34d46f4a7a9b7a6f78ba15956e1759a75a44c2920fb65ef36fdc008242b8a01284dcb67d84bee7f7bf39f4b3f26a11c547814bc41494bb081955400f6c072f16268813119c60120ddf28671aa803d6ebea2ee20d0722dc2ec09bf2150be55446aa750178dd169e5e1770fa38a90f84fb226202d5512c1ffe5eaa76a8cdd62efdd6836986597378f701c42ed0d8a42fb6fd09d8dddc7dc5e2d1e9b80698be006c5988b6ff8a8ba5a070d0f2a385e036d181bc0e9a6bd0b868de839a6d6eb0534979592b24dab5bd4492602abf57649b1365a2e87a78c06a5e8a231c9431f7d7165770f7a0fb4c6821ee6e59fdbce3069a5a6ba1f93fe65ca50724302ac2377b2cf5454925d61475ed751be00b98de7c3f0d78b30995489f069d1c98e7ba6854170a415a22e5a28d1c983991fc00f08c447dc94c1b910ea9b85db251741ca42447a3167c3f033d92fcd7027740bf6c66036fbe28c7c037c6eb79f65558ab055a731aab912b873f8abd59a1b1ba28de3dc39b69da4efd12eb18e9d8ef864ace4e989ca2144b70967d64fc5027a16fa930e838fad768cdc7e7fd7e3764e856568a1f9ff121eefae880c05e3b488b864b2aa75dbfec0f5d0c76b0f7134d060343fc6def3953b2c4a12eff334a34b32d86163a13ad54c138b2d845bc6db4d14588beb2a2a1c98afba4c98981a3666f16717b5ebe8c6437c0ab5d9db5a97e035a6f8079c09d57e2b90113a910aaa26806f5071854c9359ef24c20e41ce89f4aa5bbd2bd4e5f618dd709eac6398ea548ff3b2540aad7dc20886c7ed92afae5142833ed768b6e77d87aae898d9d8f0371b67fa0ea5843eb80625367c0e74e229f2c8fcf49e13eed5a99898e74baa6fa1324dc3a9fdff45c3cd33aa00bbb4f5044295921a9415f6aadadc578baf0256204e6930c8ab22f31f2d4602d72bcf1450b67032b9d2d6a193f285ed906f7fa957ac1ff0e633507fe6736ac0f47c7f8286a87833dc86b2413cd2ae10d868bc01508b8a5de69a909d9e6d779a4b01b603d5409e8f6679745fa278af5a94d4adcd05412ba53bcc632da4788eb2f0f4a8b707e09d72e194d1e43ab142412751e31201fd88623a732c76b6982d96d6e8b4f2263140dc69f9cefb515b1454fb301ebaba43da58c63240b0d3291a43f21d3c5b74a8bf540963aad580737a2df97965a1df26dd31489cb6e86f066e283bdbf2a647ad9052c9c019c35ef1f177f54e9028ed518f3ae3ededd0d0558922d0feef49fc1908b2571a5de0a092f3467fc4ab32958018dcadb2fa7c8b29aec9cc11650eb1d6a56837fe445389a04a18881e8866c911da3d8d16dc2ea1f6d159a9e01ccfa15850570b735f6cd4b9736d49d0448aaf2171069b8e5653e4ac7e687f1401e41cadf914d2f090815b263a04c36c072595769aaa7f6944fb718ab1a5edcda5c4f00f69724032c634b4138daababf3d1579824b87d55a44e473a330e6367a0c84972f1952253a0265e1309d0311a53ee6b3d66d29e0be968b3cb9455870d7732ee8a13a05e2d604b68f5570cfa0ccb2aa1c5292beb9c30ab34d113177bbe3c5496ea31372d12808f7c5c2a743dbcd5467a5844960eb1711989846afda3402465ecd20f76d95e25049958f1e5057837b284bea499e6ba0d5db203c1cf54c5d340537977a9233a3c0819de28c6a1e0c8f78b234bfb2c14200261a07cdada0784f5093562e15b812d7aabdc909a02260aee98912cf71884c168c9caa48ffc3511ddc8a0d85088bd581005115f785597c4905b2928e28e9af41417f8c8c46753d2f817519f6878dd892e25106433733eb2b4ad55d2d7cec9a484f17e8d11110799aad7181e1c9948e119e22d7624a32ac43a30c5afbee8418ad0c65513eaf13772ee27d4bc3d1f19ee5f4ed0b63b683dd3a35196970cf25c56bd5a86dbdb4c65689a4dd9e3fd80de5b724472ce30cbad82ce530f60297f24d3e35fbd66c37105d44ed7fb72055fb54f72dc18f67005605a974f4d2d37a4deaa94073e2d12f440c92266754bb349992e672a56a01cad7e11269340397474501a21f0cfd784be923ec420c4c92c0535101476e6ae8ec773bb2629867aeaad8f2f950aa3a434886167f0eb360293321b078733c29ad8b366fe7d3734c2d44174b6d9b84d3cbb0e750abd25af5626ed93c38a39119640b7a37e13bb72ca51839700eca9043cbf5dd9f2ac52d7a14a0725fa5d34fc12b16a0684b54f3bec0efa84dee40133c3f9906eefe4ef7d0add0c38ec9ed697db8fb3d0cb79e1fc8d174fce6a4d307f283ab56794a6df8f28fa27d174eba6fbeaf3274c0a8bfb8841fc68e76da711b9fbaa16e21a6d269d145f0b4df322b47b779eedad85d1fddb0fba8e891404d7dcf3d0c7e3817dc90b7bdb3963d0ceffea07f74e794e68ba85aa2989bc64621ae5515643ff9ab3d48c141803f3cdee77239563a7918b0f08662556d7aaf548e27577a3986db9fa80937ab6f921e8da0f83ed96b090d6f44fb920828db0a27b89ebcf09192b014091b52617c1d8548892dbcda168f7783b5756207fc7b6981b043807ee2b34dfb19b88adc982d1106ba1d8c3f4ae7e4a17c1485703b99bb8794fd3e34a4297c53b8e4e2d0390d5c0eefdf266ef7d5b50b915febe6963b965074f4172be9215cca47040bcf52515b845057f0b09a9322bc01ef477074544f9ced467a2495043a1fbf9725fc93de222de1b96d0fd6d55bbeab0cf50ec6cd19f84ff2e49e4b2d7de22dbcc0ad07541b830bf632207fc341ac9b41b47eb3f59e12195b8104ca25d771fda86aa3812aaccb72b3a585b2782a7961f2d3c8d9fd365af5866b26b93d7679c2c0c234f3e562b94e04bb1e0b9c2754cd2f515816f4460211e6acb9cf5726ef3e69b3953139b22a5ba940b8fd335da6860093e9dd2bdcb2482ee9130494a8e52b50d7faa712762454b69b68b204800ecac125de24041c67d8c627cb09a7e1c5d94d50fd077ee89316862a91bac0401339963d8f0d5ba4e95926f20d9967de5e5fa111611885a2b47d262b17ab5757473442f4d349c711bf6248cb0072a8ef80053c3fae99dc68b37a6c3a1f027dbe860abc0197817b236e607c9aa6bd204894be373e1163f8d262bee542590a5b62f56b53dfa20598b9e25248058f72938d204ad85bb3c0f4a1759015f96d73d8cdb702e6bd3b0c084c4801178efb2418be4e67e8e1564159bb588a083a8edfe0e9fcc20c6475117b64d24fd65409077fd51cbbfa9aeb02a7af40c45af6c963492b59526a7c76fcdd7c4dcd0af7ce78b2b5d7a15661e8d03200eac5dc72e06924e2c6687824de24642baa9ce6733e6c3259083b0504e2f8d64660139ccf3a166bef1b7ee721e0302627bcd63b58d6738ca72280218234b69756cfe21cb6849af2b6c6a2416f6a9080d95cc061a0872ac643355501ba8567bad27cd2948aafa6a01973b9b59cdcf1cfc31bb7759250ebb2703fe3e7f27c8974486afd4a08ca72112c81fa8ed12ad38e60952b18d927fb251e3c25fcfbfbb7020bed89a8588144d0fffb23828be4f9b80e2d1dbef7cdd8a0c578a069341a58d647470b7b5e22aa897fe91d39cf16e37bb0c4c720575e815a3f61b843f289cffc798b3323c788275f425820a41b50dc1752c0888b056d72666af61e9a0d2a7907216f1f83303ea7a9f4038690618f427433c32628798e8bc4b1c51ae4c883171701fe351b3804008759e683a5b84817190efc5ca957261ea3ead6f268e307cc5fb6855116733f9538b1bf09468100697e5fff7415dd3a360678d9dbd57c75ce78f7ab999f72119c06ec55c8eeabd6f7e27e61a17a85c139aa63b1713c11dd924736a33bbe67c0889a588250567b816191837c705ae1ecdc7b4aaa4c72b03fb06fa6eed5e5601bce8e8677dac447b5e841544400dcf74d6c4c8180f0fe919f14dfdef3f8a2c3921ca80c72bc2b394c4faeb47168c729b555efd780d217c6c716f9567a98479db22796f206a92f093bd9100c2f2d1481c156e601045b4c21bed514af75dae44edfcfd1a05c6ef407c59d078fb1cbb96f024835c6a4a46b788f182c71fa944b19de22b737a427c4e704855a8ba6712a313694868acea66ebf72e953b429d21ebc79e0f4537857c19c54c938bc929a5838cce06949366718ef4e7b4cb76b862f305fe9024096e08acbc3dd28bd68b38515fd3c8faadb0e67e20fd0a3d61f8ef2c8fd512c937870919bd06f992c05f0b556ebf02728bf8bc7b5c8f8dd5bbe6f35f62455709728d8ff987f95cf20b409e275fc7fe86c9ac4260165e15b307f1ffa77c0755efcf5e4bc476bcc14fe8515e1ef6a38339a55ce7084250aa67e3e16a072e8ab9ce4cddc8f557b4abda34760340b8b94a058459be0b2ab468aabcf97c6c378425991b0a06e87a562f95b676d516df4e33b270982cc6cc8b5b0e2b1ceba8d7da3000f503a0dd9138e3bb5b87ee0e9ef8f74de416b6335604c612dd0baa10fb610201ffabd9d0a6184d3fbf17b71d614babce09b653cd94f9e8c55c1d17397651f255f72798d43b201d22d4223f9134bea069a481255f6857fa418a026d42ffea1f11be0f25d44695798b390eb526369b214f755c27f62fcfd5d7611d2dcb2bb876c239d836abcf192d03d9b0fe64c95014bb578cdcb9e81c5ed44c989c4e9562f6401d9c8a97f0e5ce012c1864a09200981cc38cdd7706165a87ad132bdc860df592c6bcde0a8a2798eb6c5fba262563de3b6e3dbb43ae0ef099fd4b3e01f3f5eaee6ad8dc2e727bd484badb8097b6fddf372e242b9ae817736e0b1d14f4290058b97768caa59cf9eb6800ec07ff2882756bb10d04a6788755316e9926b9ae0b5cb3dc5ce61425a310aaa8221e3d4500456ccb800f3cef20d8c9a926f9a4b3c8fe1cda9fb4041a9af86f35d3a7e02c4a06fc127cc742782187c0113bdf2d723fa6d57738e5e9cefe06aa7fe4ba01c275e7ed9d30e101dab1a27c555b68e98d1434a332536be4e121839dcf7fbefcf3f347e32a391f900641b61d3f23f959ec890a076cbf933b1cf3ec7a83bfc7aae8d3f1c4d7d3a9e4bd3d19dfcb53b6b5e91c0004183e72b7c199f957d7c8514de811aead95abfa634f00eb023d5f2d44c95021c854c5a7eae5ed4e2b332bbc871282a506e3f5d7b61cdf627ee9d6d6e9ed4b76cb64ec34ad5e3070447dab7d2870140f14a498f83b7bf96a5d0bbea98d070d88392aca286352cd07b71dd8f4b71067be0ca277618d8f2bd1739926b74dc0b0f81d06f7ddc52642bcb2f536cdc7b9cc79a581c599ffda33a7cd9888850c49285feb15e6375328e350d0d5c832b60f63cfed3b141f562b8b9245a106bb83de007205782cf5b5995b8a506e5a177870d3e3857559b7ccbefb7915b2f92104b1b40354697badd9f46778568c5f4be51c912e4c2b7ef455102d0c2a505574669e4cb868d14ca1e1c0715626ab958cd440b080782ecbf378216a3eb930391428e64b5a04e716b0695302072e89968bcfb5ccfed03a83a832617bee5114a29bc8bf9d1073cc8d169d257ee04d4bbe7d6ad0be1d6b25674a5402230ac25beb0673d5e143d9db3c62ac99a970f52c1fb1a59e6c834b4fe907323e7339aa09f31aa4a82ee694d64ee46916eca6e5d2f1928a6f2b496b52ff5940ea3e129cbfdb31afc5c49426a6c108b09b10ee4880c2a87553fc434a1ea9a8a46c210379db8aad071c19e54df18e140a83d8f826eaad205fc81bafd3d55dd7e25b21b8a22c160a5995c29fa32bb91a0120f42dd2e41f7700ca0f051ac44a9960c3b4fb7b40905758920093ba961e4c92f0d1ef60c7c1fc10cb47c3e01bdbffde00abd2606da23db715996d5e8eb101d61dd8e0d84bd0acf2739808292d392fff4ee8e61b9a7809331fe43a9963fdcb1b8db9a391e26a1c274da1bc70ec0fdefa0dd8701c2c284ca78007c7373e3c9d1d3cef67cf874f4fe43101bd7042f8e31f843b830a8cd4bf2df3ff637f1004d1c35530ad0e8e0d117d4d52ca623b4c550e66a9a33bca0972ecc47a7956e1e749b83a70939b59048eb3a002b4e3cf63364340d7fc5190bf596e1f35b1225f62384a9cbf01ff1d86f517232d8f7141776f4f3a2ff70225c9d0f86b79601fc0b5d43898e5047826c6ff4fc041a4265aba4ce8541da0af55b6a8fb605e484de6d4e110b88a3b5b25db4bed6dc9bbf829e987eac1d205197d651ec01b9d251b8e25c80a15e5b8d287d3a76b76e0f04d63da777a43f6a9a7bfde5949bfa1b6a0a915c543ea26167025c89a4f32ac0ac150ca2c554793df9d0bc6c662105114234bd0bbf0805a505e92a9db6b53b8d24aaaf8a31beefb35a57d8fd63e7c97a1ef365a02fcf2f4b15bd48346c5751cfcccae6b71c96bf6c186096bdcbd2170faf9a8f7a0fac09c73dff943989f754666726625c83ed96b4567518c3750f60302210cd68886f0c94e5566ec9d59708236198567036fe2bbedd6d032300cc4c9a773a46e8a813089c1a126bb416cbd1140275290fa28c06ea8b60173248a7042b2b6e28d735a5b47cf4781457977e3a617fc7937f8c8a7f377685b2a7257c845cfab634639c46948605b7178f52e50b0b534613ac162e6b7d06d9017b24fcc106c9cf864fa15c195e6b2dacbc30c01ffda62fd6035ef70678a2908698134e7485275379e082f9da6b69e24ba2476215d6bd66fef164c0a5e2376310f570f4554ce17e430ce7efc9167a7a50f1fd7fb314786a9f5daf728649b7cac4019c94f0ecd5c2e0d7ed55e1a2dd237cc5e806a2705f6fad3d06cd5dab47e1a1e1ae0b477a074bd713bdd37f667ce92477e32acd3ac3f8f768243d155988524942bb8d02b73fb4fb00d24ced9515318d64ec85faef2d74c261a016b3112576bf44e236a96b0ed0e641f23b0c78a66f87f5fa9525a94f29acf7ae20cd285d7ed011ee5ea0329ede9ec0a3a60114ea412ade2b0a9c8b52d883c9133174d449503bd12cf2dc18b619ce4e407b41a1a2785ca36bbbbac2fd58b5108c1e378cc7b2d573726071dab2d775f569838a7137768cd0f0840d3d14d3d56633e07c21e301856e5ea1f972ac73b11223884ab2d56803923d5295246d145a846d48afd5ec1419052402bda349fa35279a4f1ea6fb18390fd18aca7163a3f5fb11b59a85d534c8b10fccdcd59df452b512e55e9efe44afe327f2482979822413414c6f764a2627914973ebde7db095e445d8a165710ddeca023864fb7dbba27355f70df84454024d815e120ccfb90c080a8d33774c5253aa4479862868bd432feff6714d4b9bc85cf4aa0e85834f2094719105f4644965090496b160e673ec7e2bf9e20e76c7c9779b280c88b742ce6db111102777ef9bd5b21840a1be21f6ffcb20996ea9a0c7060f47f1941c76af1267c6e58ae8a971507f4107b345aaba911649b53dbe56f4a5ba2b01ad15999907eb0094b8c79504f12b3dc70a0cf2ba47bf5d8c345ed1322baa06a0fe2c4ce605e663c962210c87df34c0fffddb08ad36e3abd8ed522e3952415610a97bb84baa2180ff9e2a946d33e80a3ec29178b96c6b70130897813c845fc7e1e16f5a52f84961fbdbb6dc8475992cdf41f7fbda56652d347571d6157e7943f6f42bac7a8a883e48b972f902b479c81af394a954448c049bff647ee1a6382fb5de3bdbb57622a17f14159f4a624370562cd77fe9eff1453074aa905a3fa3ec3486ef9331cf570708557426ba4aca8bb3ece157b9a560a54f556aa33106d6f55cacaad921f95cc704fd8dfa36f7d0249ddb5a2cb08bba78482b31ede2844e1f92aa5af35234c2f75f7654b2ac721660f7ae00a6348fdb4637095810c8ae60f25c7dc02c77ee22c10d5bedc03708358c416d28873285ae44fc79a6977e8b915bbba25c6b891cad196331801503f5d0931ec2084fd8b0ce15f57000b24f904e221a7396c7657fa5d86d389803d13cc40ded3c8bc0273a542c22d42ef43e68b3b2fcf75b8bf6589d2af62757568007c82ea187fc995073fdb0d039894591b9b5f366def435f46fc182d14f7e28f9599298ae1b8d1af97484979ee072640980ad6f0b577cc8e8d5deb780b6a7bf12da9f0f7a1610f794570fcc31cd7573484861dd13573b459186546571632bd0864ab3d8f658757f3e45ead152ca51f5161a6b0f9070d6639a469fbc90bb9a598a7e66b0663d08c7dd2c7c345e5893d6521cdbe8d4e79e0eab978ab7a2a2ce8901689c58677a79e58087ae2d73d125d5783cba309d2af09ee2f272083db462464135ecaeba53f43d5d3fb8ad0910212d4a49d1679b79ab73f9fbf6cb6612303b005e11270737f3bda3119dc42439ec0c7a4bc2d6a303f6cc813c0da9f02d7307c942687f7fa4fd609bac804921273c8d32ddcb61d2ba519491c16e47bdf8452b2f2bf563e8ee553d7b87b89356ad95cad84b312eb98d1d82c322559d30fb781fe24fcb30bd83e43f8a67b52677571ba05eb18b9eda78bbab703bdaaa184db01d76d96574c62209203c745f8d3d57e51ebd02b3ec6e845f594e1ec71873dce8ec2ed68d7e2056570c3e2c6457ccba9ec1461ac2a9abbc5798bb8204af25a2f647bd6b4c2c80d3c49f3418ded0c98b381b6ad8f46dcbf73bbeb856ea7f5d2ea893078c33bd6360144636bb59f1c977c92fa58105ab83d3c5f415d8fb9d274cf87be54da0b3e5c988695c42c693dd53a79d7eece10113020b1a21b0cfb482c9581c33fd7f67a215754f2a34d37c10f0842387061a2a90c41110bb41047c89a16883e5db79f365ae914d6a7a883389df2c0368436431709bf9d0eeeefb2b9baf94e4108cd4f48bbf8f757928c31687392c61c0c8178daa90ad5971882bfd8244f6751f8f5f19c3d7fdc26a4358271f59f20770b561f1a9fe2a5bfdf427d48af09674405858ab20fa182bf32de7e5411d0b547ef15c5b5732749a301f1e1f747dc85f7041edcf2f30ffde25d6f17ab7bc6bfda6558b03cca8a6314800322141febf340b1c5439e3bd4174bc107afb1c7186a01508edf5cd956f973032bcf499117b5868894ed193c2d4283948eb76858834e74986b01c9e33e9f0bf81733f7721a383736a69684f8f8a757484f09d754b0c0467d3d6f4b348e1b6c17b411a76e8c234cbc6e83ff0295315b83a37ad9d469929db68eeafbb98ac27ce7d3dce0d460ce68334855237dbf8c9871de13b28c0ef91e4146657be2f9add5850ec1d70905a25bb1f142df4928fb7c80252352e731fb46d576f9f36265639082ba153ea870a704c48e4a6d8db2c0aab97ea56b09722ef14b9aa93da5cb500dfd4c7532bba936791f65deb1d838098c41f38e39b5b2dbb7d4d941fa7dc07b9a9b46b40a73cb77199ae1ba26d2230a27ef9e69c0baaaf4d63e157d0edd6c4a01453dfbf8ae88fb9b8a84f966c1654c3db1213482c752eac76318979a5cd8c68923b6ff690f2db32e90d509ccba409b5b9d1e966d1af62b0899b0741bbec2ffff7ff1576a894d4c1a84003503f0a99f0c3c486cc85363039bdeefd7635ef084de0e1239bcc256e20fc36a0823d1e42cb004bfddfd6ce5499f5f49811bd8ca0f63d53352da5114c31ad5adc91c73b5afc32cb1b96c9e43c8cbd605c7dacc844f338d78ba10908815e3adacb69cf6bd18c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
