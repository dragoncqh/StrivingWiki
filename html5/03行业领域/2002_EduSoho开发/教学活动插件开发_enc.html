<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a3b41e4fc0504f3dba6a9e6a0e9db3112f9cb5efaf47a69f4e9327fec8b3ae170abcdc3e6565e6486e8091b8a65d638fc209bde158138fdc799bc89988a95c905f167fc8bab8c9900105c9644a7c39f71cde34ab94df764b0c9a05a35bad391cb849eff63033bcf11428f4a4f2b9f5d3005a9e0b955e8a5ade2f5ccfcc2e5029deec3bf333b89e1c6bb979b8704fa2d29be2893f984d30875ee9a1e3e829aacaf9678a32f291f5a0abbea7f9861729cf8ad170cfaeeda3e721200c420002a87813ea25468210d9d7e9a89c6d78a697cb4ded55f44102130ef7b31ba3ad6063138e09c84e91910cab33a13a50a5da6a6569f0d8b3d6344f2fb5f35c0d28aed3bccc5356319f86f92f50c0a4da6b04d31c5f1ed57eee7f9b4f269b306bb8ae4eb2208e5593f1a62ef50a1ba2bcf511ade433ca43d9167ad88a3cb50502b7c1b8796107fbc2f67c41fe3c750b35fa4d25bcb90d89202100bfa8ea8117a1553c11ee45c5f35aa4f04dcda812096c9d1b263fa95575ade7c74ffc4853484119b9ffc154fd6da7d8176794e15b64f6040931ff3bb3a02624dd24bc6f79d34d75d99e94b78e58977397d8357c5d54bc2278d6333d6cadb5aa263c9850c98ac3b96339964301f0697b6ab57630df6432f821f6ee0745ca6c605854d78abb46ac2030b987eb177cc8d5692691bb517abdbf77d746d380782f4954efa77ccdf17bea5ad1bc82834d06e7de06c0c6373e0cd246cd16babd32ff335e87d60de67b35acc1c6127b4eee618c212fd22a5d97e5af680e21c4bd5f61687480cfbb1c5bae605accd88a358bdb9ce3ac006002a6ca2c3b563c4f935dc98f0af4f2e6fc5b8b8082b424a69efe20bba092c66d43b75cedbccb714fae2cc2ca8d57e7bd6fa1ae2397f4bf01ff435aca15effe6fc29d41c7a1aa9ee8574852f0403a6cd50cb63c4fc2326c8b8fe1c7e42f4b3b743f942b0cb0dd34ec17bec7799e0d1868ca2397900f408f1672ee9c76f1e4002e7a5bafe13dfad78fa6cf1e05b0e9c4ba268c545984cd9dd69807ac94a1f09bf7515be4ed49f637209dff0a4b176a0830c3589cc4ea5bea3f1e6be75e4a1ddafd5be2bed2805877347c00229b0364944120361a1c9b140b94796208de9fc57b20062d218934f6138872e936a42ef8da8c918a03934c31faca95826e351dc489d72fc7ca314ec703f9d726838c8472d2972113146a332d9c927cb554a34440d232ae02613e28a3f9273cf9c95bb278a5832fb5dd33d76e3a219502e4c3bc67dfd2979f52f293b20d482302d0d13764b7f4766901090353edd57384cca6424710e16a4a82a9287e50dbc550f3242d99f7b5499f0a37cb830d17c3edb7591de346cef910b3dfbcdc0f865217ac4ddc691b0a148c7255774f97b5516cbd40756a26f11b07007aa11dba7d2240b6ce96da9f7617133711fe56182761ea818bfd855d8b0a2339455bb23ca336a6ccc6bcf4bd5dc2b6cf069488839d335eb9870c4365643713c5400a8eac0375b26e7878b2e107c56eb851df000e2e9d5cf132c3f8fd2a28ff437849445f9e34b45cff4d3a9cff9d649237d55cd576dc51461b58a0538cdbc64bb3719916d9e54327ec6ce6616903cf173979fd5fe8f207fc505950c8a4996b9f0b26be518a9189191e70467e10d7517a21e69982218bc46a3bef161e2ee245e6ae9bed612715d4578091507a0dc46e187110709ea1f2af0dbffddb792739204a2b55a7f87a98245cea4f725c3d8c6e8bd4fd9eb39936a61b820c4af62c7780ecb4011564716ab13056cc7d46e11bd85ae7b72de772ece093b9c0167d42114f7115d13d08958419613d2bc5615b8c2a54d23ebbe3897731905d65aed080657943ef0dda8ca1f28fbfef5de1c2bfb19295b989d4500b31c6780b7a25c6cfb7366d1c6d131fbeca41ee862f2963900c95adeeb92e52e21c5fdee333256ca5ce3cbc2bf2d70f15d8405d0340920c5ac44a49b4499b2e5df5002b113cde559d0289dfeaddc61cc18a201882f43033925bb9bb044f60b407bbf6721137260485bd0bcfdcf901da76e2daaa629780d463e4e0155626a1c09f3d89c9d7aaa509387d53fe736545816e5299b6ca6a03e1449b7759e2d70a4c67a64762d03fb4278e90edc9cd0888b371c56a8cd248f3439f2a3c561044be3eee1f4829f5af3b8b3a1136eafc019e819ef22139e8ecf9b5ac7ff7ad2033e056e046986429b8d82129f856abd0569cdcfb76e5511b635121b3932be41de7bc88369f6d0c514a22f9f2055b3993370724da5a584e847e42691e344f896a96ec6ad3d21b9f60cc95ab7428b238c16b0a7ebabb3bf7b5f639e360922954abc9e49aded0872eff2f9302278e4baa185652ab528e3934cad00bfe605b3bc3609bf35f22cda99faf6f3bb42f3c0a9b419f76f24c40d170651d6d9478d3445eb901e73fd312622b831868aad3e4edee038e966de07c2c03635f8c7610da2d05b004d76ea442e9f3ff11e02a38a619a6cdd4e3d1ec53b63699d2855c044d9403324aaca6d53312596ab069c42d28d2a7067edb26d61c8dfd0e8d05328e1c3b5c3a6475ac1108a4af39b50b1b43b7544299edfe42f94562aa72aa813556356a247d76c6eea2f80de1d42a492c7dfd3ef61dfaa70651c7f7ca771aa42a01d891536700d05e6649b556cfb457ce373c9fccf5612729df4938f0404661b14cdd5c226194c933b106cb866547612d2e8022caaab7d047a72b9ad023a883fb697cf1c181d3d5c934d003f1008fde5d84a7d01a201d6b66b1badb9f22004a513f878ae412d99739cc951eb9ba5b8af79db712eea16f9eec276cb9685d43975c1c1779d0266f537df36d37bebdfe31108dcc60d2a8d2159970c7d4cc682fe7e89152b3a986e4895eb3e7aee92f24c6efdf96cd723e4e304cd1056fea24c99e6b98774f503ee6ac78c59e099b0929cb73781e9f175bd2aff9efd39703f10e9b046d830b5a6873deb9d160108eb8f19f541b5757c2dad18846710e1b22765cd4995a46feae1f980d5a00b051b06117a6f38b1f4246d5f29786b7590822dae86b9615e219222babf848f582ba8b2ba24fbe326bddd41ecf5425d3f43766ba57412d217823b77c8e0b5b2da9602a38dd176fdfaa8a78ce8ce42f8ab8b46f980cac26584a515abfdb50b49a879127cc449ffff404433fdb40676409741891c4c07c5cc1ac98dc4634daa3da26ae666bf6151f6f2fbd07d6588f0de386962d3cd0772585d452093c713e3491f01fb2c26e4917b4283a36c8c6071a67e9f3f3a5200afd027b10a2b3a3652b7ca35c126f08012a1bd79f8d319e644e587fc99f9b6f1c67eb487174d3054abbfe9538ee6b4709cf08d908a703ffe6c550454f19f09d6c6c8bf69bbac7292ffa5eb17464768348b420e703fb4c8a4a9a6421322ae54920eca18f059420c3fb339aad95459721c84bbfaa1413ad16d45db8b1e8cf127438f63cce6300bd476e4653f3e1bf3bbf31e6d1547c41cbc3119872241603b236b4df7cd2cf62a84b8dfb1ee3398ef13ca9491dd83c69651c46ab353b7087b2a88ba7a5022ab0e0e12be342545cd96b9982f09467fe7da93acde0934a94a94b8b9c754fde762ea2fb624b2f807f040b89544a952d02e1d0038b4ce55e696750612e06d0afdb92ad948a5fad8f0d7791ee0888d3e0bb15f0a1ee51a592e626f5ba1d4663a26292f16558c816435264d09a7223e334f95464bd7e2876f0feedc86836ea47240f10ce72389139e08e95480681a5162fad21580a78652ba32d802e73dba35b9d3719f19c3815b8b91a203eced1a4f8b997af45dbc4b94cb6d3b4fa3d820e0ad551cddcdcdf47e52c4d6e16930a37ebe5c998ca192ca8c367c9e5b927a5280b7b2ac534dc4049e61ea495c5da4307ff37f0fa9175e5116f4368f40c3a6cc5c3858cdd208efc7b3bee36d075ff9ebd9e935416b4d185695881fa0c2026001aa690356823fc49dfe37c6ff28b7e8df1c2c1ce78078b6d967d7445b0d1baab2f2fcbbccf2cbf3bac0e80aaa96da2a41fd6860872e2c968a85cee8e8fc8778f87114fabedb0501d8c951a609658c0a19591c48b4a99012ebe7ae9c80c2fa3ecaec2a277bb8cb279e43a7709c660bccf84561262f00b3489e4de968ec04f0a8bf8ee9a37dfa2390fb7c142716a5503d493662dbb2f4ed64b6fd843445c7b27e24024e802707195a2bb19429ab6a18a62df56c130c0e8c4564456b73ff7863bc49f496604ed2646f5cac961b13fbdebdf6681cfdc9916c6655fb2c7e1b789343bb7e95723a8dfac56ccf1f61f14eaf4f76a9e91c97135d7bb7a4d292d709bc9aaa9b5b7a87192cc7962cca768fd1be1f9ae59b0d99ba27896ec4ac03fe04f08e8c39ca3dd3ad8a9e33b673c82663756f2bd21f8020b439004fea55497279f38a3e42981f318a04447621f11c8a64914794941bb3b333c318b367d15afef616ef911490e1c6352ba8a1a945a3d7f2a1deac8455b3e38c91a4220297488d953f9d73bec6cca18da511b5b1809888facaf3168ddc56e5bfe567402a829850544a28564d1aa87a89b50a1ed2b23eed650c54c63314692983ba93e52743a8ddb4979049d38e95c805db1e98cedb7b86e52c8b86b97b14f3cebe57ae0c3f3aa2415a293b28d92b16aa292834c75ca658348a1747f145cc96ba9a403f569fa174c6d942c010cf4bb5424c5cbc1046de539120005991fac84e47d3b6f2f6ce6a42f53126f3c6e01f82da59197e1b27028183f4a65c25a0a4c2387c0a5ffecea9a14046d3b8d953c2f357131aa52970489c0bcfafb851b1c37ebbfd7f00cf73b54fa6779bdab4d6ffc375e57337e58fd856ca57f9f8423bfb7bc4b51dc0ab5f5c0cf2d52e3532be4fa7d7c5354477b14c7b4effee15f8167c65995fd28b775a94930b884c428320f352ec633d2376fe81467b3e44f1908882da36c544f5346d8614547232e9ab1666bde4aa272d15d0e9b7d921b2935c80b9f698e7839e3ff2e0c1b982c27235bf95e7bc3b3d2990cb0f1184bfca548d710292b2c126a94edb07be370267281ab891bc3277431ec122e4db6dd048879b5e2a4e79f8df107330a080b6c91f5999166e956e84d1a4e6070c33f3e6f3a9b14bd0bbdbf572b3d0c1b8dbb17380d7b75a1e9c17cc7347d8123fb4cb492ee7214a2e5bc8c460fd1cc128c0526d1a62b0140112e3460b0ec482da4c4e4f3a5e679216e900b38a3d535fab11068526acc5ee4f9f9ddc70cd8aa1c91c828c370effb574943ae0309da79abe52ab880dde379629000576d0692c21400ee04fc2733d5bf84e66b23268aa6ac4aa839352b918237ae5fa7abc5643231315a29494ce0771b9ebc39c9c5c6ec350cd2e2cb9e7f045214d68a1db6f4e9dc609d1f757ec2185bd376b233a67ca8fe6a22af4d1367d854fd5e551c3a2885ede14e6b0feb40a59925fcffaee36592cec609fa3cfba9a714bac20bd6e95c0654b4f8f5c7d2c9cb83b9287a7cfa291a06df6ada2fdfcb9d39e7fee78f582d6b95aaaefa9cfcd14b786b09690ca239f7e38c312c78ee854875aceb92b648b249e3d9ba6c8573091aafa1bca95a2ba25d29b03b0e082f3de21b9ab5526a3a346bfe680529cdcb01359825aafa545afe442e0a3839727b555f570a25ced2c298d8b6684b74e36b4d15736da8f5541de86248a714a5f41d5d464ae34b746ef10a174825ec2ef2458d53e2b927693914b3b2743ac0cefd6aabfe540909a01e5035158ed938ceebf22e372a9d210602a5fc3005c5c97393c85c13e32a054b198206ff1eea6f38ef89c4216cef24b529588f183141e51efc43962dd149d54b5d2c2abfdbfc69f15569e6b0d9c2818da0b466bbcfd3857973bd218a0af08fb38e065eb1b6025e79d86d855e080eda92aa61b08120c3519ed6a8e1b2872f2fd0dbb4177fbca8718e0dd0991e014f360a793af049496a1ce3d814dcc9fbdde62b7595da58bd3cbd7c99a33827263269fc73df689c1f423dc147919f274ca7d5c9c0f3d7281f7929521e641b21c02abc25982c8f8ee5a317807ef5929aa2f7ebd95087721e9cd985313a781f14b13868134d9e4f5311f2136c179ec1cf481d6413602d7d0c6a2bd643179100aff290ccfdd3dbf7885bf19cf6aa716b69af81a6876fc26255c21810f71a2ab4c40184bc4fd3482de37bdcb9eb7b6e9277133fb52c95f7e818bd888c0a89de3c8e3e7b301f5312334788c363e0b7feea741a8b5bcbca4df92e51acca80cbaa6bca7163294859d23acc707a4eef75891734230e4a5a6a7bdbdb4f19595b79abf5e7e36bc0112589cbdc40905ce577fe895abdba8be8e03c376ca734abad863f2bc834389e761c4aa1fd21c7f87ad4c636df85cae7e98bb5d4423b5e2ab8ecef39447e5e9a974b2622e79289720f41002172851b04ddf6fa09453898208ccbf761c5487463bb368b6e06fad1deb7aa872392c52524290c08885da12a70ef7f4391efc52e9cca7c34ed2ecc06adde3f01d7430e6b9032b75da8178640a351519c59c9f5853cce024b1e99d837d55f002b2a1d5704086cd44514a82cebc441d2eba879c2e0919912a130ca5b29da8ee76f9357764fae30b8504d021f049c1c4eeeed1a3f26388a42daeb1f90710cc3e11321255315695cefdccb7e76aeebc5d98eb822133e71ee540624e71cf77612bdc1878ddae447d928ac91dd96e353d8186cfc45ace3d917b21cc01e577ae8ba2e67627ac06039ea4389f528fafda3c56a200625f91e0bde07ab1246ea1f7a81794fb4cb4317e6751634a3a813485006fb3ae8d8d69d25eddacfd2633c851f313d70b425491d5b9d73480bd7766a344e67541ac40b2990a5b71a46453a6314ea15b092faa029443ff349a436ecedb807d958f085daf4351a7aa7ef23c0cf4fb015aca1ec9a263236ab0440c2e482a68db5fc2e421e5aea52788af23b6f8ad15c5e69fa6421e269266741d25307400f54a9b97a8384d0e142a2740b2e6caa2c320f365e75b58bd3b6cbfe09e2f0dcdb72e00a3f43a2141ee510eee979c44b6be0002d09fdbfe3795c960e672c6d41c5db93cecbb7391a8677bb221d5042b7ca34a55ec5f1a8f5d3a55e92da3ad2083fb6471c453448e5f7504dd5cbc16f128a5a3eebc01706dbe88790d5781cec510c67ac8a452e2cbc08af84ab5b3ecb3276e18e845e40079893665400a6f3296fc6276d4992a4f44b97b5c768385922a422cb3d1df770d47c16fd5ff9f70bc92a4780b533fd408f91553019baf1bcff6f2819b0ddbf7c011f3a7079283932b1b6a7589517afa953134bd616f6bdea5b64677288ffe0668f4d8ff9f5adca21f4df949c8f31461a10e9c9f59c4d608162cd449253c96bd63727ac26f764673118981beee125a40ee0452da1943e24807b4ea67e7baf6a29445db41891ceddbb59bfc852fb78d4ba77a28da673292730649f9e6a60101b8d07b8db3fe9db0ff570f55cfbcd8b743f817c72c23f032f34b45921b8ae8409d98f0d7d211393d9690d160c6fd516f981a39b3da3405ca3a435de0dab3ae971ee8fea9ab7fd03358d26134edca2c8424d53889fa23794db6450259d8845f9911aa822d4de2a2bdfebecc993a6dabb1022789119e4eedca2b7158b2dc9deae704deacc0b6491913438381b74f1cf21e70de5bd5e870c252d24334e59c73428a7e915d77ed9076b005e06d7253d5f7c95a2ef03250190648ed727c1086bcbf713a9c6ecfe8a1f0e51ceeb53ca19819fa37224abb5b148d964bd64fdc9f41f062e1282697f929f2f9e6bdeee609fa035921112284329f4953f8c497e602dfc4af439c029cc34fafe3285c65f139356427b8298ce7672b06e155a950cbbe20c314b46da2833853b27d1f0ce1d859aae025699ff494710cb7b669181c9cff20429f5fa54463afc61f76a2b6c1f42677498240b664a10b50aa16c79b449c3a45349c572a620a054b2d73e9b092076ab8966439b56ddf8d28d042d9c04678ab4da03e8cceb1c3a8c7b797e8a4d25a8a6da305c3965a70a2732de0245b36bba958b258275af10eac84fc6693b9c0725192df13445d96c0c676149f1199a3621920f51b775ae413a1e12c9c7ea26cc3cce4cfc6204fbc3e7a766c8e0b6bd8e33c910eb8c395bf0a8a6ec7f3e39b9f86c560487bc3902a187a2bdd73a8b46fee858d206f68e712e266669f545c782b7423dc3fc52f6a4e527a78e83c29e751fc008319d4694cf982d12b0b4128b0ebe5472f836e03242bf0a7f80e5834ed587b3cf6ad2f0738abce511106b697f97fd940013e9f0929db7e305b48d37581e34300135b99cd520e54fb41802abcc56681c2226dd25143c89988821fb3f129629dec4318cac6dae1e4a3263123b9ea5d0be711556f9ee17a59d169a7e4b7f2871977bddf721b3e962583fca4dce50ba823e5add12eae79a2de6c1a09adb0aba9a1b061b541aa80b8e3a26bd2c6f3b5c9bf987955abed69bf662fa19ed2f77254a45df9eeda5bcfd001c2c2a7aa0e2e04c58093f2f3998160cca331467ca84fb0e625e064555ecfc4c7465924306ed2045cd1b55178f392335a661454f5388267a83293fbc4887f6cd9325354cb051776dec80ce73677d97f3f6f0c199f9ec9bc4a5a42d5a36b5765b00031c2dea8f027ff5317b9aa6864ee6b5c40621818d975fa42f9029cbd896c7bb5d84099c80c10d43e87f5875a52237ad3c278c4258633bf4c6f07f2ce0e32c1251094a9b12bedb373b4170ff0fcfa074166d303c7a3da291b020c6dbd87d4a69c8d3fa60a1d7eff28819e06d345c2f5d924001d6a85db5afcfbf40f88e18f81a1a8f4b2a1186340bde46df82a9dc649de705613d0a0e7772e4a92782377ea5c3603b5b8fe510533e087019a7cbbcef150495d721752f6f539b2214a90f42ce47651fcb8b97eb91500f7153701189624c6f6edb50ea5daffa9bff7e7ff94476e607a7b9d0ad594b99fd695b77d959eeb4f52ea3d95ba83b4dcc1d5abd3272840efa6b45d50f182489f3350c017e6471c60e3f23297754d534e90ab7d5d639732042ab03049ef587b23252a16d825606774651c35aeba459973b5d0929ac5e91c0786a3d1031f397f36a2a6904c9dc11b1fc999350c634eea63cfdc0ccf715d4b0debfdcbd98d21d4fedf169cb7b4bdb5ed0983f8620b6846af1a37a2d0ea5de02e11fb69b90e49c40ec47a1776e6231c52ff59108f94f11d542f9cbd2f117bf6dd618e2e721d57a3cc7eee94ffa46a28e53a305510d96d77205c3fedbddda264460afd06c95f7dc76bd1c0068a96808c98be2b83d4a7d88dea504ade8cabc8ca0d35a278aa802b1e2e4e7941a45a99c83e696fa2fd1cddef328874de0fdd45fde1dab5a43c3b84fbbc1d6c30b10d7f6ef4c4a7c44f0bdf7d1cc350d609856cb255789fff196eef525dfef94869d70af1a47268c816208d8dfaf13417450a5c59e941c7768a2a5d22bf548eff8034e922771ca736328ddb6f9ca9585711fe640cf900d214dc3d193514d7aea4c713d9f28fa95918afece5acf51830b564bf5883be02f0db13972cca86cf4c5b54a175d34e3fae07b2c7d572d4ff55c206044d3129a4ffce7eea8c0e8664929c997d77997ad93b001d730ba41831912cfa6e22ac49d19adabaa0407ba1c91c8e6080123f7a4e27b79c5148a95488237e47216e36be31e0ec60361a94ab1db89ba9b0be11ae4b35df00c0197b75cc293a5933334727455691ac1cfdd366f3b2bf1a182791e03340a432382192d576dfb65ac53207170730ac406f3fe40ee8828b8521b7b85387444aba9d5002a8f5b0159c0991408f3b5389b7ea69b27e4d43195ec6df33a07e665a12974e371510d50ef6065b17bafd47bde0c57a2e491a2caf9896e7e8d7d14a62bcf2feb54d640e6f166c40bfbe44dad976f87e8b6424bc4033bc09677af7c7304ba57106a0b970467d1a39d752a80ee3c08ed263688895136dedb81e0453e62edda4bc547dc5b65c1354c1eaf7a6cd8a585f517bd3af6fce902a197c3fb72c593e171a96542a41e8a79a1e5fe8e52f1029960342dbdf3709db61e324c2f5ccdbe84a44d24cd7716bbd7f1b1e9ce4a34dbbd1bf123a2bfd2dae3996cb2b5467e224e67c4320b5e10da9225733272b98aa26106a44d3e480e8d546cfabcf79a13b9db8f9c8fcaaad2205f190855c043a263c5a408c653338cf8139c65e0177d0d08ff450532a3447b40f5c9da7af042a839f3f6df4d5ee855fd01f885f77397b34ac7878a78fd4ed692b490843141088f935bb63b26648e78e131c0fd433d9678c36eaf3a24c5d16c905c33ceb9b4715aaa11cbe47840afe89deff29c9686d6550b340f4724e96622b835203364eae113f6bc62b2c377ea1257f8161cee3cfbfcd99b2c658065192721a7481d45313cdf21706c76c4d22355c5380bf218c0641c99579ff06aaaf43f1e24897f9be9c7ca3e3de190a713b06afb2d8775a4d7c76ec02511e5e5dfe18ccbd8fa9cf01c0e383f3766a694206c0a6012a287d375378cd4befaeb816af5a7aeb864d9bb7d1f3756187d7fcc254681a7c77d8bd7fdae31ba91620667f8cd24b72b5cb4b8a8e9be4521bf0b448283844490f391554dc389309518c169484103fc703190c6c085f5cb31a9dc48f4ef53aa4c5a50ddf52db63f0d4036489625f3fde51f0f06ba3bb18502f4e27d03bf3948f488387f5242899866a2568e2c20c4812ff5db920af104f033c22c72fdf7b943627b7a24ca35d7d7de558e4b5dea3d213b25e4f0d630e0266a0d9ca7e34d4979729d1b06086fa3812c476350e6c464233cb53195084eb92d8829344a253819add2c31df23ab149b867a7b34360d8b524924b782f664405b75eed61356e84e4f175d0d29863f8a4862115b5fa50b40fa81a9c74f863cbf36d7a57907f91644a4e7500bcd331bd7fcbf65e7307f473e7bea4c550bc79cc29535f559668ad901bba8c0d60e02bc34477b66ce6f44b33266efcbe32d28e262af29742b550a502ef240c7ae18d65e1905a649364ffa4a97b0e7f3566fd9e24519e2ad25d99c8736ad2639035f827afe1a73282102663307f62749c659048c45db1f76e594ad3277743b9e700abdc71f4d8d6b153a7ba417c172cd31ce1cd6dff975ea96954ebd2d24768a161d917d6dca6cabd2f2b59fc12c372f1772b6661c456392c06c9930492e50015be19aec23bc8fde96c7831af1ea13f12eb98818986b45d413178017dd495794604b0cd4823e7b55d4e89a4f63c6de71a60cb663983409adde3e08dc208ed9c2ec7fd1c398c27f1af27cf276597d07523be6b7bbffa274b68a177756adcf3d759d0cc0c1222235b2fc042cbb0dd5c46e0118767926c0facd71b63f31bc9fffa6987432a868fec12b860ad27d6c18774d6ba314af2ec78559001c9b5724aae504a2ef35f5288ec3cc91e6efc3930166d43a41b9cea2e2ddccbd2b16d5f524addb11bdabc75458bb341234ed5137afb03344e8e047046b2878b0540896684c3c77fb2e6f547bd11bd4be7bebefc5db560eecded3a407faa25562bf0bd940f5d217edba345711db78144fc49587a41c89d65b4b875bc73341c577db58fa11e50809d8c297492785865ace5914d451309e3cf9223d65b3e5110c6ec6d41c9b0a6bc24cd5c5c03f9fe75a7adae16879bb5416b9d3ad55e41849e2937aafc71eb1e5738af1da7a167628c5fc4618c3af23643b311fdede4d423debda713a704192180b2f2b14d3ac42f90f0ee87420efc86f95d7fab52e77dd1d8c8aff44033cf5ba7b3164766ea04a0113b702333575fc494f3eefd00baf8e2c8467f2a8b7e8558677f81b34f48a4ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
