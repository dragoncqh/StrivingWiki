<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fb6c8daecc256c8b842f83e98e0da23529755ff35b8ab1adcab85d17d4309a5a3f6206d44283fe54614246904fe7bb7dfeac74d97a97eb48c326644e903613c501782cc974b91533f9b688cd34d86b3c0ca62cc163f190005ada50a30f5706e5c32b4ae3a60aabefbfe8b2e84878c7bab602833a01fb0fcf73bba8abdcf4b73cae9df1c3a9f84e365df9cc8a9c9c55f1b1eaa935b0420eb594555c66ef83fdb6b32eb09e6a50dbf25e292ff73a36cbae1fbcf7807461d64cc53c258b16831f743286dc4f403862d70e15e01b7c345202985703cf4236cf1aa872b1e5ab430b379211dc817c5b4c5067e7cf2fec5fc506b2a41f576138da9b32c728761df560aa6cb63ae963ebf7e0bebc5e23b92d10a7a79964630a6630aaa33f941486d5aba615c0006217550c90d9b1633ec6322af7b3c796c2edc57af93a76cc13cee2c4854bf9b822acdd7c3979e3b2c7fa9947697dadfb3ac5de8bfe1ecd50811b7d8be61bf2dbec21cd2526b2b810ef9764ed880ec16575611235c2c089c09b3c80b098421497de8dbbe0cd948151c712e1d12d169efdb42fc2b9f9b2e98c369ea37fd22fda3c5c60d9b6d4bb22b15b922a64e511c0cfe76d8b47a2460569b6b6a30d6c7546b9c0b960625f7822f5f0b3e96c1c8f8c8d8303cc20c85ff5a14bbfcbaadc6a50f8a5043633571ad3ebc1009d557fde3afc0c2d2217d2e50caf24d2468493f779638a92102bf7d4710b62091d83c13390f22a85b74f5f86f966f3f6bdde753d35d5c3b3c55de187779a3eb299a926cea6738f0f7ff707fcbdadceb52e26d0aedf86f16ebc71b1029df1eba0007ba0c255102c6d8c3c3e3aefe76aca0b46dc1b2f5654ced922cd32e4762a6340deb8e9fa48f1df222cb64db526c6e2e4dcd563b3e134af3d61c2605330e52034a17ea7d8448f1d96e731ba729252b2dd4711ffa8b85f54ca1be79de3161086c1c2a5ba943018ca8ea0d0096f8092dcbfbd5ede74d6c042ea3b319e2229e200917f5b204cf666efabb5ae3b258e9fd873fc83633b442c6caf2df255ba095f408a3c570a1414b15d93a95d6d5bfe2df6370b8bcd3fc123c291269f978c25a2b14c031d01220b2ac141fb85f91f9cc15a42f88f5e248c1f27111fdc73741a63101de43864d881903d163cee3276642c9736d84b77f6af929d51f06e5bccc2625b509b97973fe57685464501118d571f6bfc3cb38932ca558ba5192c90393df80d8e6d2038852ef7e2129640c954a1f5a9fb85a39ed6453c811f5919e73da3451bdc5f142de4a1fadcbc0b7cae91185d7ac471f1d070e935e498d492da9b54823a9f7094e195e7d8ef0af4b30b09f3d8d3a8d98e0520ab3ca4d0186768bde0e7a279598eca0f3ce2be3aaf6223f996fcf5f0ae19a92aec4ec0f01671e47b4e4164ad7863798d078d76f0996959e41440474e69113f983baf15a2f95d50cb2371e604cc6d38ecc446e7589d21849cc30eb878e14dbf5d58e3961a8bb62369e76dfcc9ed22685e4b6c2b0b99e48a85c631ab07c9bef95a4e0ced19a1b55abad13e1ffd676a633471d3fbd01404a7348efcb09927ee60e72c749082f6a017572ecbc058a9019c2805b9eb78c54ba5b8ce8a0f3d898af451adcd6e48a8364a46b24afb5f94e5e2762bd028b9a5d9c3b2d8ff70fd3764fc96c34408f86d6f1c774848240c23b17c5deb9d9898d52cc7911cb4ae95f5ed0506180f492899b000e715c1dce63ee64d39078eb01130806d0e0a3292cece8b9db83188a77ce59b891171fe29c8cc8dc081f9cc2d1faf31cfec9f7321e8dc3d74b07b2a8265f61905cfefbe794d97f9f1882bbbbe4229e43b24aa53559cd95f8f6f2e995aa98747d92bfced728d15b67775a116387fbebd1c0cce1da1bdbdba2f1f59a73993d399e18fc99953076acb81620dd1d5de43a93524a81ff40413502dea407b3529942ac1ac18b5b171b33087d2689a7b5dd33daba512e44eff887aef935e22f968273895d21ddbf9a6289b52f88e1c17516a6efd6a25cc8fc97ac74646e3b08eb6436b2d3f31aac02ce08cb20844b7f8d66f11c0802e46c4e4054c7d76e30829f541458ac358deb4031bfccb1766d3126ecbbe474f7255ae9ffa5713e4722b1c73c989502382086057df244ac2d493622bc286f8ae57786de1acf53517a4862755851353d10320694f18141eb544f461bbeb3a811b801c893d2a86cd6af61583de092db31dfe9b9a5f1a66509a9d061d5fbe922884247d5605d2d9a7947aa28d2063fc84401830f98745b604d320ba9afd12b97ea1ff2c6a431944e10461a553706527a9dc0584bdbfb6076eae046ca4afcdb76088446183ccc988aac283febe15eeefe09c4fd192cebd5d6f39caac01ab03292148e7f6434752a288e08ba05035d288367687c2495af5df9c696dc56a8efc3f15b5274601e116af3e23044343e15d3a858ef942c443b49229d93e125a1d353fa62fd21db0d04aedbecd490a40f64e624a0a0d8202fd8b54535e4636ad1e432d029fd05e5cf762e3b299c4afea3b2f8ae0ed7e89514659203bd1a1704549ad860aef742ea6d99a100567e6d01bf4491a4c40d72e5d4c9a5ad845fd7d01651947754f972167262acda1f80e9a5010dea906d09af6cc3adfe1c0549ab6de83a2e0462891f1720e873af70c4267c91a3f9456a5be1a29061f3e48158a99d29e470a33bfe4c7432818802d5448131a5f9e9961243637e2d156f9270edae1ca7f2211f845b68da2b27963fed6689e5bd48c080ec27caa43b93e98ef99f92a00cd39229508f8e54ec43f549bc2fec6330950e10c7366c94ba6c3eea309f7459681bcc81d89ed90038672f42d49bae3520ad51c82d220ce1f0bc19171e6d1aa7d8aca6dc755904fe36d11def34503beac9e158b9d74b5c9315f535d8ce71ffca34566a24744f3be7c97df52a80e3cd321a08bee159850fdd30843e4a51fb50cfe2b45901f7cce187a81e829f7d215d7caa3f23404ca1037e07c3c01945d0d0f417290fa42e4cd62e412dd00bc97bf997795f7333eb65f054084ae966a272aaec70352c778b2eb43a9f5d16bb03b884da9e56d7b1f2592275e91a0c5699322e356c12d61f212b38ab2b6cdb1cbd2d163218dcef484d97c32ad03754d7117ece51890643ebac285c0df93de409e781536f1a74091c26334776339ed8ac78a9870cfc3b624f95aa66ef664801f24ec4bef5d865ebe3f2888a389dc03a3a58902b704d1436dd9f3b314ecadf3bce03628eb00be0b61076ac7904625d252a8e36ea9a1993af106b3be4c1eedd517c80d99aa79fc8f349adeb628921225083ff0b99dc0a936bc5f50565e92170ee1fdaa13ebe84dc06f0bc370ba5ec5e6f54c1b2fdb43d4b6a12340d25453ad50905214f365ec073718b43e65db2da165cf60788254637ac4d502b6d0a8c7324da59efbcf8dce919187738f0dd4ab618fae305168943a41de719cd036cee52348dfcc46fd44bb7016e518696e7139c51eaa1ac7afa367f86b98839659c617be30ef714a61da64519b0ee2af29ea0a05b779b2c90add912357eee1966caa0bbfe1fa44117ecab4755900a155f56cf30aeaffd422726c5f89980b29b08134540e850c2368d8d32e85fdb8dbcdcef243fed6cd1bb26c1674653e670a4b3b3e635d8c823232e7bbe5fe7d8f8086eaed416a56e6230a1063ba0016289a127a10a2ba3bd721cfe1f3999da9d9d8bdbfa21c841bd610fc9cdeff4a23012fc723c9d687f33090d3d123b1692205023010e27a87c48fbe0ad7e3caf3f392ca690d344d17c16dfa0cf1d7cf6cbb406bd7f8e40a7d0ca3d51787a96cf7c7a346242142b884c199d5fbd0dccc48f60a40d2d84384c275961a5979cd1d0e31fe3585ed57d3fa2cd288f05c9c0095e7b34dca3811be8a5e22e463f1a1167786f2abd57de37375b40c2efd370fb4aebd4f30d200a6b7f41399ef215c92be9eec93cb8e560390620722c781eb7d572c6e985c73977c204d4310997dbdc395f6c7349c816aa79c8c99f53ad55273de2fc6bcb0a35118b1a3cd8d08680059bbd2216a79605a02a202ac07141e1d3234dc8f4b3b246b5b11dc28823ea3795cd384f82bb4c3229feada0a09e0fb0ab1ddd77851fbbe3be58dcda417c2410c645902c37b3c4be7caca9d16a7f5c1ffa5cc39e2c45aa99fa82dd8c1e6b86d0e1f8a7d93e454a42c8930e1ea3f19405cf61d326614d4bfa88d88bb22bbd64e38e143fb8947d198bd53e8879c93468c89b13b2545aeb96437edf47e4b521bf9e80a98ac7e27ba32581d9653841fe98363352b87cbdd42978b7fdea47c2df4e0ad6bb83d9b4b5265aa8e5bdf653898ecd48d9305dbebd4ebb7be17d9124a9a9658ab8788b9ba96317ec26cc2bb1c3d39228ccc7c36d11b730099ff29e1b3a2fbc223f949de67f6fe41dc601758659ee8aa5ba4e97658557dfcd47df6b76150761d1ae81a7999e5232aa351129147b2e9986dcc48b08746dbc1e7aaaab05f5c5ee188ef742dd776a8669edfbbb4318cae65d1af558e3b0823654ae3529a5c7337515d45c8ebcf0803aa170327314fa89648f306452b3f649de28cdc4a1abd3c4fcc14635474b2f91b37bafef96f0b44f94314ac95b9d80bc3a5b8a1a61fe460464789c0907cfb61452a9b7a480b0b0c5557b31fba6b1e84ad3f37179172be82396786fd96d850a0f60387270b3af5a0c29527200ddc5e0efec94d346904d0c5a7920b58b8069628eafedcdf8b063798de8ed04edc785f3202d2df78a6a072b78018b57f6b5b005f78ee99f41aa05c78740e01cdf87366d847f99858f8d69488833588b32e2f6b622cacba2712b702be6f500d3080dfc18cc22e88d65dff442adaa7003b89771d7af3a7d618cb9f4f9f9a0301815e4fff3da9a1338f3dd37938c2963bab0cd46b5db0123327dd454e676137f2050e23f67a2465c8be09bdad84e518466d52c17cb8cc036b3fcf9aabd8a0b28e03cdeb0f9ee3c8033a031976b02a80ca3b6f437adba64d4c881477d5dbf9909ba2d1cca4691b7ef6dab2c796818f5c5069fcad8cab83bf7774832c560e65a6a0448f6252bc9298df8cc07b8a20ee05011eed65414c623ba6640b534fdeed7cfa58053ea53029201cbd613e82c406045ef39a9e45763bb771e1e5572b24989b8a3b18d2fb778289d0fabce67a23cf1631978ffb2601ecaa68010990d8347debd565201b4044dff181a4e12dbc9b783e19bf0bca3e6d19c5a8afa1534979ac7f196b9a6ac7f454582b3316d87c762dbe594d9c607eb80a39ef2be316221e25bcdf17b3661cb78e0d15df21962790e20aee94e27670fa88cfceb8a8ae34a6d5ac5e78c55715285e0edff8044b55491745277c091d39780c02a223980ef4e512f6423c7b40f4dc1477ca7875e26b579972cca3c3ad9f55d6b52643bf1d4c21a8b09ce72223724446bc9d746893a1ea3c03b8b2991a126c1e54365dcd150f631fdc09b5be9487b953a27e04fd4a38699b070d7a8ca7e57fe2a35797b573cd963e4b9c6c21662299d525c80419bf689f439e55e5093416198db548d34bd6939354fd924b3a8eddd44bd48767ff162f1e8b800ef51c1ce473a8901eba13ffb07505d86d2bca1379f6943ecbd7209b2efc282d61c7b09cc2afc735a901adfab6009283045b06b15ba2675c8f46f5c3ede0ff0bd3ad294487ddd0f1a01ab429843f571a68afba800448e904a224ec4e2754a1ec3151e4a8817c4432b3381f66ada334339c57a47d7a8c954183d2785b7b6b48c620172a38a5073ce0a6cedf82843b265d2f29eab43965407da1c092346a17accb62756216250b942d78084e06f12de52df312b27f1062eba0b3c2e1bda86662ee3b807badb28737be3c77bce48e891b8aa3361087a645a30720e7fbddc9beaef55fda2d967bc98e244849bb2ba7bc04b744f796185f9e8ea3f3309f42604ca6138df4fa0b87cb9aa41dd250809e96d54a09249461b1c85a733d23d0c96be1185b9c853f574d64638322df073c57890876ca6efae97100dd259e4f85be1a7d81e4a5ae2b3b1e33d401903e4ea911000a8b42fdcc59d3d62aa8247ef6d0ab312750a0402f7a0cd074db5714c4cec176f6953168b3044fcec95407a28c09e88bb30d98019d799e9f9d2346694819799737e999daa674f70da3caa1cdf674d96624f5f21ed3261455ff3a3815a884db52f06cc3c9bede39309190df9f170378f5736dde99bdfd0e5bf5fa596ac8a1bca10224eb4911a4e1ba5bf941d0260a916e6e4520b5bc6fbfb5b801dd814ddb0ed3ee718ca8ddac94f506d6d41f4b0eddc6c42c8fe4de5c8ef403692db2c1b9e293c5d4c2d918a5f060fb02c8a65cf92edf1659735c9b5c1260d96fab8160099873f5e55282f3702f4cdaed6f4b11a91b07b22c06d63488ee0fd5467d199014ba87a01ee32dc690c1bef2bb952b26b69edb1ef9e5439875866b0c913c88157ed13fc75da18634848ee1c8af2f0604973abe69c72864ce8f49f9360f5b0885632fb2e349bb1e08daf37b68052acc8c3dcd3f1feaf85b7734c95700f41d1159dc502390ddca9e94d01ef0e867f0804932172ca6e4c00983210dfa7bda412649808c19e2f157bdb0c9c2a38ed0c1c17dd4f48c129f0f1af226974e05d5cdcbbaf6ae445d47c81ddefeb44949cce3f70ee2b362a1cefb3f7afc40811b820891d22979216f7a5f33a58456a6d87f53a977a4092584f1f52045c67271e7a56fb786a422da706317d7c7736d47c4313c818623400fcd9f3e502efc17488d903834c0e0d6a12232dc88a4d75a4959f32eeabf9beaf3ffe2502ee39f5f516005223ff52cbe29e54a763bf10f653e9d307118409f52d25d2677bf5c5f070a6f0fa23296f627e57ad7293948336fc4268c4ae1a664aa234c5a09f82bd2e995a9089b84cf14b32617686649c54a4fc9227077b382177fae4f4121bb06eac7cf343c5a28effe2551563261ec12088aa7fca728324c09b9899cc2eda45efdaab7425bf825808cb6df5c5b19c6549c3910707d6e76e7fb9052ed07de0fd6ca78dbc616e7f05075a6c0725edd3bfce3d46138deb9de01b357df9074b3a73f2cc2d45c12af64becee922715f364ae22c0084f18d608986664370999966fe4538145382c8d654cee43978b789d9904bb053296008e7ceed3031da6e0a36a0470b85c169dcb236f2e51351d10547a1ee66a3a3b1ad8784ccad1b0cd9ca26b88d5d6d064b2ee5419042e1540cf2d61ef791b3174f03a626302b085dfd7f5db5478d034b2663ce1366ce13ae4306f46889e59843b1b853648d000997d18cef36989c4ef45fda70aed5ed759691b62e2e236f3055ab3c48fea3626faab929149730abdd28656865d041c8d1dcbce669a39e2bb764765c220d435a4747e122e10f495182f13f61f74e36beaf23aa08320652b8dc2693cdba3c1cb85bedc21672c88bda44d8e7be516cb81fd7e90aaaebf903826b267197c8cb8f5b3d7ad44cb9e00b7958569dde8a0628e5346fc25e537661bc7d1086d1c6785b0f67ca50b506a69d038cd185fad51865a5d587818d4312aad06a494c797a1f623bc01dafccc03ccd7b0a66854a16ca74b41fd4aa5c3a46d80bbee454ba90470c563309e8159962c8080ee6020d5b0a271e98493893313e2b437bd3354bb9d5ebc6c98ad26524903e3d2ff60b8e96d62f6223294d7f5e9c7ebef281a3d8bd59892ea9576d387f8c19fb08b27a530c07bdd29bbaa8bc38c2e09ca5849f66516a2c4f15c1be51ff8ff64a8ed8e72a7e970481403501628c3d347187a3669cdc2de7b8c243a8011de426de52a55b714ea7ccdf26b2d88f71742830d9c1635b77faf270db93eb4895c34f6c15d38bc0a13c49df1c046b3b9cdd3b688e3256e21ffa78c6a7f597f6d4f95e24583b8d2674387457f07b980e117bd8ad1107159a88beef5d549da1ce29b2c2909e0eeff2cbd12ae49c46edc48f463a85007734d692d8c88f8839ef32f1cb07adccc1077f15527fec9b8d575555f5e769645bbab157f12080152a5784cc6bd9df9448daf2fac45c4da0406f9372e17127b4137c88c0259f125c181c97d7e296130c32a919c377bea2670704f81af4c695d374bf4212f9579208dfe940f1d6e43e8d914e508a592805148c8d44ff0eadd1c80e6879232bb4af633606ebb094e5bd2006c48dbe25498b95fda056195ab1a34b93e6fc7f00e109775bd89a7dcd434b51f3350b375ab5fea05e8c377e75affd849ba8d26efc65a2d747a7e49c1428e60cbf5548c3ae9d14551919a946b4b7c6f925dc4e4ce8a94e52c2dbc3629dca14694d95b8707a220f7faaaf220a38229cbcf3c4659ae771b59f67754c28b8b72b43dc8810b9638724b442d8740b6eb8f71bd5d4fcbf016b13f538359d7487bec1ba8c928419285a9f09f1ff32a210a874c85d75f7993e7767d295b38bbb28533868e570a1eb6dd8b10ca0007d5c04c70b73fa73357b5b05d4e14530f07642121afcac9dcd16684fe55639297c8617d90c3f9d0a6553689fc2ace2961b944ce621d1f6659eb034743b296da13104ccf5c140e0848d3edb7dbf30e33b673efbd736a2439620ad159f627ef7f00f82617c423f7f9600af1e1f3d44a1d71b2f9a4406e8d2e82b9ce7b0ad468e31e7d05d080eec43d67a3d2039926188517e510245518dcdc6807c4344a42387dc192a6e8aab427b7e661da70677100325bbb89b9542b434c872b5efbca1f4cc80703157567c3b46a8d76011230aa1a0257b62c9441f708550acd55e87be3d9eeb49fc8a5d37ce87b462374fbec1633ff69802b1c806598b164c4e1f4ed01170be1b118c6c88067640ab01c6daa75fc2484e049f1e7571ecf1b5355cefd4f33423e1976139f240fb4111501621b666623bcb19d0da7259e59286c1e9d46d7e73cb3dc43a635416e7e51460c370a740d14d96fa49faccba3a0e07f0346062b99aa8a4ebed337bed2af5b122162d86ee0d53dab7a03221ba8414582c70d29634eba26e7d8ed7bc0d50c3a29edfd0263a9487cfa7eee024e7a982a50b4fb37cd837ff5852f4235fa3ff1dc43a9f4584d6d73dda94e61176ad510bfba505d91ff327c5345f38aab3b6744a36832c7b9180582469f69da6a414aba1c5151f103f16901e505599e829df2046c7e09bc0f698a03bbe1101483620dab0bcbdef5f8d139c30b56921513122d071c61a3c5a875a0ff928c062c2ddcac81cdcfcac6abcd42d97176a07934439364b3679885d7bf43438e7902206d02687e3c2f8be8672ac713a4754b98e816c19bd5fa1b69daa8ff1aec8a0943f0ffd24b19aa7150b3046c0d838d2af697e9ba300a5428f04d04ffa84883eeaebeb9a5053761dd001b935f5e542f35e7daad0583992e9590f7c27869c91bd9e8bf79608a2717a2386d9d1e60bf7f08e24c488319820ac9728ee715c92834b1e305632ff119a93c2e485abc1839ea33c3d69fe0d1ba3a8b87bd3230faaaec4573ff8fe2d14b29b436a562d2f8709e2c86fa6fafc0dee108b755fbfa050873572c1107a0582ee191707df733b496fc0b92fccb6986b623e9758f82f8cc0134e811f52983145f0bbf268066efa3e8fd036550862c72059fc6960f220b9aeb158785df1be4d05977ebedebfc9e2c00f276f22ed3c980b01a4417aafa790848fe45c1b39134e75502aa7e6b8184169066cf3757072a4088db6e7a18339555f71d7af85c8a563074526562f001cbd065d8c14a1a7e7310f122ae4a49ec6c26439d2a4a64ca7ed9e68f610f7580e538373600663b8ab828d1c98c3bb745bd19593883c383b9112418325be81f039a9cd0fbc8791e2b7594d63b09b5261c03b0af8bdab0bce7247f13f0d3c795af917e55a8a22b052b192ea38434abc3da87a95407bb473d0d0571f7cb9ac7522e1410d9de70820329e5c517d5fd7813cd7782645076ac3c8352f87a0895e421e88dff720e89c8db3279e138375fea09ad4a5f59f957312af5bc62c7802fd8645398856e47cc3eb06b8d2582937b15b17fd03ccd84d185e52adf397cdcceaf9dcef4f538ff82e1c8739a1a631b1f31caaa165c65e17f98366f30bdc51b83808ce9bc6ade0508cb6a4d2e37ed2ac2fea58872146c935b87e985621527b99ee3f75883d255a1ccb89372f15dcd260f7e3ccd5fff363ac502c591d92e87bf8c3e34e8547874236f17860ec312f61edebcd2b4fef56d0fa33743db3e459303105ad48021abaa8f6b0b4fbdcd4bb553a772ecb880cebade191b39185200081a67a975cc1ea7f41d18deab469934a9349c2e1b9bc5e81f7791840c3c2ddff498ce1f80995f247f8f7ad03d53465e94362a91c2a7462db3f8b08fcba09373063be6c9c9a4c6c9b8b4fb929fecdd01d0e2dcec603b3131fc60665471fb7921efdfbcf88235ab217d743842ef0da923873528ec35e5ba929addd931b614e4f2e720fde52926ee0d59628fd1b4b141e028fa601c65200c5387b53495ece523b383d69212deecdef162a3c0bbc998cc4f8f50c62d50b582b080e5188c503371e0a71ec8b4921356c72d3a803e1d66892359868c75852f3db3f305e1e182d3a90bebb1900ba413e39d3bea5ac8496b5294cf0d41f4e185ecbfa86eda910ae3c73f5c949641a3e62eb18b2b1fb8ab9c77701e6029113f3d1e12a88f3f5e785a4bf5951cd1eb3618d06120bf1853148de56572c900ca4978feafefd5b4776fa2d727c2752353e8aa7f8a0815e446030fd94276460a0e82096da4faade3ffd31ead8599b1f2560ee99cad89743d1800454249cc44289fbf51defa469a5810f363e8f38a3965f8c78d0fc775aa9a579843417d3562537c079be48161dbefe2f70db3ce017c52dbc54fcd5b338e1472e92e99a4f337e07861fbdad0674c353954faaa50c28a254a39c0bf8b238edbaab503300512769cd164c28f2859ef608f8c2db100a0a7456308509f3a37b772c8ef528baacb5ca59a484037172ef7047bbd6dde1529a692163c8e9d4d1030aed1ce671629961c20f83ab42e2206673de7d840ac2c05cd1a510022299b4ad97db70f326bf250fab08216c2d92db8f05cda295a6d451465be57088dc7acff7ab20a28f4d96cdfb21df8e1045457969d94f080619db92da0461dfb4887b53dbe09ad9510680beb0b4523b282c4392a0636ecacda57432e3d5bbb6670fbcf64ea436c22349adbd907d87dcc6e57f080def59666cbb47697588c79f64c490b9aa9668fe071b9b3c212efa7ee5bdb9c25218b824e8ae09a521447a72c03a0c71cea338919573d565d7aa323fd6316c29045a9780cf4ccda35b13f076d428b096bb93124a07c91ca4134a4706db04b3f1d519d735c67ecb16551fac5d49b587aabccd6db55d93447434405003538ada696ba0d1c62ab5a50d824cea47ae05617575748368dc1e5fa140213637fc93950cf7dd231bb489cf01eaa9c1db2fea238e29b7c48d3578cbb9d7f5b950b989acdbcfe505b3f834264a20e2a89ef05a1276f6a435a83105842b8917f192e542093c9c267967de79d25ba3260685a63f06758b2df1452f6d2660adace1f6ac1284ee21439da95e282a0ac54e34aa4defcbe86cbbe0a63d17cf6ac10cb423ce8332780f70dbad11df4212ef45338d7ddcaef8f54a57b34bbe0fa4a9c87cfff3ebabab177525b92d24e99b5698a3fd95d3c62cc191083fc197a4c0f2510b193514ab387e73adb4b7cdccdbbebf70399667e5811f7c0002e286638061bdb9593e628151a262dfbb8873029b2a1a7f5c1fe6c273a41278b390eaa8db5e77a188b77693c353140958d8b77dacc82fd49be15cdeb400b66887933b7294af49f738f92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
