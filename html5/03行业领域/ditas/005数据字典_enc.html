<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8b693f1b964f0d6fa2b23203c52231446370c24f2e9c5d09b76992cdadf97ecb332ae470f3041638b466f84198bb078aa0446ff9f8fe4eafb5e74f783623bb83e2088710d1a53303850458ca54a69176d5e97d87e602dc37cec2d956a520a479fde17e8acbd248126ed5f7d353fd7ce66a9f1c8d49d483648377b2cc1d1cd5254338caa78771ed70642dea1ab0eab081946721b9cdf94d6ed5ac4cd2904767cea029ab9ad6c13bd5ffce75f14672ba0fbf26733d1bc75cc7aca7d2610d8f81058ac73b7fd08a2cbaedf36ac5e6ae37f32a423d1795f58272097232905022ce669f9dcc2d1f5be887d298186767427b6641adf81c7529736b14156ee4d1eb03f841e161ded3a7eab68298f49684386909d4fe5bb54a0d5c4b4ce4ce2b26d35e463d88576a48b1a11dca893bc5045748240625df46a5a2e143d74cbaf0c7532e605c8fd8d4e212c7f5b800ad62744282956e21d7bb1afef7bcc07647eced73dad9174248e52119f0c3d981b722bc960f417d0e46f5f37e6fc3705800381417b7118abed77a3d9e6a89f2060b36cccbf529d5fab9e5962401d73bb7f686379205d1c4a233d871fbb09cc2752a95e26a55cad589ea8c145203cd02e4de0ed7b7128020be1766c574d801f8a58f8a719345e5ed13ad4856d31306d95063849483562b2822e44b312e6a8a8d52984fa9abb559595ec882fac6ee8479ed31f9770c3d700cd0fd186c44fb7c5372b523614157f501b3d4c3eefc65d0fc5e97babcb809542f5e23719fc0effe31d5dcf63cc758d85a8c62fec14170989a5bf02be6d72202880c7020f91748d6aff0b1e1cf70ade704f2495eec43dfab1b1380d5e48e8f94ca11b8cea55c6f12530dd0f715bbe4340d747ac47de547cb665777deb97fe77062618f4b5f1b5af7d1c8e99b701430c2ca9891fe598275a6f4d7ec12831f4b41e762b0c47584877f639a17db60ba19f1154e8294206b4d41c4e02761f70e0417777edb3deef1f2113f84964898edd3cc05f46a82f5ee810e3747d0a69bdb69e89f68fdbb09f2feffc544080da5f504cfc6ede3b89b6b3500cbf926ed703b66e89aa60a5b023e508961cc3d10c75fc24dc3692c23cccd38dae885f33df9e1f1158a7987be14807409c4b09b1505112289090e9c9e8ec21db21a29084cee6832734c83f92afbd97ad9c4189f846454b5b9699c0f49d8a4b05752a9d89e6318563b4bd7f5b3eadc744c5b331eb6385be7b4098e98dd0d46a183c5e3d257585881f29cadba6a21a1c46f8668d9ac6a23ab9e13538dcdabeb76add693cc978f6a03c3232657b16e93e16662586d47a00595c7f61b4641b67d3589507105b834a422cb77917b6c8a28c6dfdb2b2c878ef73c88c5483d293b3fd9a8f73dec0c99cda1eba666661ef7902c9a96fab83c842e803d350a1c91fb99dff4d8957aee6fdb212d9c881e821ca158d29dec57ee0af50ec28867ab49142ebe26819b8bca8d98d7d133a60ea81a77a57de82ee7c01e70d08e247fdb8c389cda9a815d4a79bb84fbd211b1443c39db5b618cc91d28cb63d955223b0ae35662e04dc61bef75e3c9c91cb7a600b21ab399f598788949d8bff0795e9227c496a4d93b4a3452b42fd7bbb373ab3b3f78d8a81e9bd1c6c4f4adaea30748efc684cec7362d18091b26f6b3cf322f49ff4a5b18c197f583c0290840c5dc9b94a9b8d1c67b4a73702ff2373337504a5f021d3ae24e894c7e62e5c0136efd29feda0b9f82080d284771ecd85a4fccc96d32bf62b64f976600ee59536f7e0fa8dd5afb4d45bcbd7a9dfccec14602edfb4ce9a6e824c7939bedb373497885fc60f5ddba79c54adc89f443713c1ea1e084f937790948b67eb24bcaaa98179920704d9eeceecf022fb17ede1ed2a07a9febfadf1070ab08c60c1eb40bf277bf469f755aae4afb9b17a398f87b6348ccbf6798f518ce15ad1217c21fe2693cac981af53a7c3afd310e7f509f44ca70e3074a4687f7458ecdaf58b37f631f22ab6f84aa44ccb6fc462a0eecf55185dd41309c082459471d06639929f9b0b8914c2b2b22051fd9c6fe4af6ade2f4bdba86ebff26519488420dd0717e7cb686823e59123984bc916b780199cf816bcfde5df314b28ff03452a690273a4f6fdf54e8d1fba6825a29a361c4500266733de0fcc136c40f34c681b318b20b8e6b0a1d055bb7c02a0e98c66d38e003bc0433a0bde48deaf4d68ca080137b155870248feac345b65466fcbe185e13dcbca139ae0ffcbb252013179fae799e854cffd150edba82b9885270f55c03f5eca37c5fc292273bdb536dd3707de050ad7959534c024acc4aee21643fa79a3e564289f56d52811938f048a678f48743c5d169e36987f085f45876ef401256662e9ab8f0728f268b0f50ee8611f0b431c21a0b1ef9fe7cfcbd2b840aae8d4f6ce6cb0c23a311ff0613e3ddb7b586cb25143431bb97cac79f373161e8f3a3cd44d7ad3d220c5a3c7295da706da41e371a1917974c3dea74bbe387185fbe0f01186e50ede981825d9057f24daaac9e3aaa57349455efc2c8e8f3d8d9a08db5b8ad5ba7892c05639fa07074b758f34ac7998c751f336375d292c6cb148197a8ca6105bf7bb203a5672b546d599829be41620205ea1b90ad5e776f255e5ff075ffe4d0b716aea574ceb5389a3d60e8f8535366fca62f191307c879ea92f51cbae5fb4dbaaceb9a5347db6da69fe5be13ef6e8fb2eaaed1765aeecb1449afe742962d9d3233ef9022831b22d8558a11dcacb4f0f3f47ddae1a8df9bb84d71e7f4dab65b6a9ef8c459cb2bbd595eb213d1ee902736ca78c3609d735735cb197fde82ec253eb9d33fcb14630eacd8db5c944de9a97710e3b5ddf30ac7ca7cfe09271089d689e5564d20c00a978a7f5327130dd3ac4f4ec90831a7dd562dd6c793a5be10eb2a7ab4aa231c42b130dbc23eeba3ff34189c5db3fc4ed0f9884656eb3b1b672ca67a63d0d9c4fb47a469c0c9fec32096cb61e7853d717833446ae79f4ef7d8ac3d5cf7fd95820b8a01fb48a362475faa73afaf9eb3d5c7580f6b2929770f31b65d07bee4af1fa80a287bc62954fa87f34fc2f93e9b6f9f6d98ec6cc360c845c42e68e6cac6c39837977347e98dffc0c9ee5aa0571d9c2297d9bff3c0e88d11648bd9301bf7eb60aff47d464e608dde1aec8e8cdcb29a9b9716da776466bb3e71771d22d6a982befb3d6575194ad8ed6f48ff1de18f44760b87cdf8c31c305215af3553b15f058b2decb3421d51caa0b7a577ed74cf22bb29a726f6f9585bc071b8ac1d40119100bc9abc50eca7afb5afb695e33542373b4f01066a3557dfca7c3eb307096376f0d5db400234394396f7bf9bee907f94029e91a0db59b4aa124f1937c104c142b230336589cfce902e2ff4d33e42fd95f571887520b21a26aa0f4b7d9ee00697dcad9513c2d53d0d6c03b055affa37a5f08301558e90833e27a77ddd4c362d8ded3de89b7c701d6bfcc91c00005128e577bb44499ea604dd8a7af8d77dbbf284fcadb4984811213aef08d9d57a400c6c58e913c2cc188859d43fe3ca6a3496ef0aa1c6d00addf6d72ead56a33bdfeb7dd9066ce8bf3366e473f0145e46e568f723b7cb7401aa0d3b464ae36319d6d476bac24e66e1d3d6ea3f5d4af6ff3ec302eed6ce5d14c0432946069d87aba8c0e5d0ae0e016dd41a43fe12b7ca7cf3ac9f8f4d098b406a79a13354f7b3677fdeec088c51a07eb5fa2d1015b12949b93d87eede2a77e3644975e376f8a4646d68e057e8e0245e33b78cf35b0b33ebe9cd92f3b94a7ab3e3f4a7693f9efa6c4fbb23a7147e06f303967931879744035dfccdb4a1be95a09a46bddc7e696894618f7208f9de1346030fe78fbdb70d1defe55ed404e72536350b567cf2b06c426ddbb30cf2b8055643e8031e2eadb875634d354417be47b01a776cacd693a4852e9984251605c154ab02004b415d15e70eb8a8999ce699f70ef15b2ee54fb28decc409557ab0b86eff40de3e92f7a72f6c682e70124af7f5a2f527e0bbe63b73e913b87f7875df5535ce6269717bc71755f83159bc6f7bc2df16cb63be6cd65dbd1cd9f9c3deab643846afc4b391c3f106d320937d079f3d00faeb8757a009cee5397cdb860c84305196a21f189d0e68490cd3e00f7b33d6ca485d08df8fe29205804e83d746f0631af3dd35bc4aeee008c4cfae5901de1948a0c52b2abf157a49232fffd96a1739d2be6e3ba628df2ee8d71220f18c1d59bc59ea10f8868447f0d2c16df0de431199a39dbf6fce7ac92e4167e953314dbda2159576ed6d39afc28af85cfda8506272ed6c48e7eabd5d495d315ab29783cfef46d339ea0f62b83536be687fd14ea5af26a696a2acded44eeb0320aae7c6e9b5c1fa467696c526fc69a890e5b30f633a357decd4d263cfd43302a795ac154da8f2b2c3ce2f75a60f08f3257d6afd88327ad23ae4f116b7acca8e99458407a3a1aea6b7807a99be3cbc0df749e68f1934f9406c4b1286fb98327b8aa9e8250630360b096b4819924470789681525cf88a863bd725092d77f9708a6a33b3e6554c484ac69f8ba15d9d00446477f56876963e0b77f5d8f85267a26c2363bcbbcf26d5b186813525af7f0bd1a491c6494fa233f5100549f34e4e080ee17b6f938fd66a76bab088ba17111f2caf0bc94cbd7cfdc33a4f86258566672d0a6dc746aaea85c6fa8338b2ee2aa6ee64242be27df04cf4786cb4d118b1f58f55eb4baed79e47c664ef78f9c1f1533f4d538328798693a6c5849756b5947bf488d41dd554b662c33a3262142eeba520fbd8dfdd0b83f610f5d859c528945678113413ce7b0de023a3d2e248ed30c43f7ce8119e983d633095c0b51912d340a0337cd6e27e6212d00a0de3b0235b48b3a877abc424b54b1fff3d3ca6d161831bacf3ad12d6d9ded8361f771fdf1b3189645eba0a8c745258de3a6d5f276d43890c83f08546634b2ac5ecadec5547b200dda60c3e25efc7e206bb87732c9c06a773382ff452ba36ac42679a89f726078c51e79e0d3a726e9a942b733b2a8d1875d922820f3604b4030b3843892bb7ddb20e3d6ef362eb3cbe7fcb3b9a0dda35fec1b38c483b6c13fab945cf52899eab3568917ddd974025958d57fc47f1035bcb502c79469701c6d6248adebc68c808c4c02bf37275b3f6cbcf39283d1bd71b35e9f95a6cee9d27b8c97c6db08eed2e3483c2f9f85f0e1796838449b6a2931d99e54a9fa31ebcb668f2c843356384c7a53c3042f8364cb5d1965811d63a6b30b415fd37b7856f7cb6f8bebc6ddcaaaeda197a3820b2ab7c12d602d84b9e95070a00a82c7c937dcd39e0b3b75650e93f2e21d8adb51caedf63610520e099bb079dc21cf633717c9e7d977663179f50b0112d84060dc569c60f0761653a6065945f7b5908f2fa1374e6e3102f13d24c50c07ce18cd048e6c6761b0da34fced7f5c13f1dfc423884d80f88895ba5544732a1db6590839bee8b18c60dcd147acdbe26142dd3e6f4abffd3c7e6b2667ff0e295114c3dc7e9be12e191597ec7586828680a7c676de42002b18acf796f313f6c293431224619f2cd93ad9e83a7d60967027fe23ab7061b02e8fdbb8d3dca350bcbe1097ba383fbcce954763d23711be9c30d71a872015f249eeb3143680dfb915ba23b8086c60c6fcedc119808981f1a2c6945e86757e3d64a7473c9773e184a7c9d318bc83c82bc4da0f73c40452944b9f2117c2eed00c6316b80ee30cf7eae9d8ff0d47b0145be1dc276c97162a0e2c2da0da402b5360afd48cfd5739b0dd372a6b9e0464e633d779057bdb62eec72372cfe9ffade5f067f932eba8fedeccf5d95df8a5d191f616ced718d832726a7be18f29375b4c0c4b8a2e0afb1920c7624c3e0c61259e375aa9b6209fd874d4590255d2ec64a8ee2a9b8b0adb2396c04321c47ffb2bc95b6a3cc472d477487f3d41b76faf8efe0dcb89b208ff627a5c391abef67f11ed649858461cb287da5a06cea844548fcbbd1c3f77107f2ff95bf2526e5b97b5b7f3594b066f89a937aee0b7431cf8b841e15109dac8f1efc6770d6ef1c033e51ea26dfd218c3e62c61f432b013ac46dace0c1fac10de0bd7e538ed44c51063feb6b6bbd5eb350f9283f1d93809271f173058b766480bdad907e15bfd99c9463f7504f9687d1bdcf05f419313036e880d15b5c2b93d1f38cce2c43b41c526a40ef0536daa341e999ff450fc696a33df7290e1548538e7e6b0a03e270caa5208c0df7cab6d34ec90803598b6293dcc9cabd6e249235832ff31123353cc0be3714929f6e7ef8286831c0e7f9397a62587f51df23d6f5b35747ee96ca3b5c379d58db90fa6e96cfc7b86befac3c36b86abd6fe0ad9d0ee623feebff98113ee0b552c7347b2147711aa7db19412b7aa679691c437b43b25fc86f05e638a02fc0f8bcee4ee54abd6b0aef1b26d11bf17e72cf726654124be60b12a99afd04a19f514ea872bdb402613d57251fae693505eec623a5d86f20bab37cdd7f794697cd4e8d63f4327f0dd5a851b93b19bd4256bd4063310a094d0601f4bf59a790de9d075decd0643b6129d1f9ef6509c6762e8b1ab993570c178204bf74e6a263421d0992ec11b82160751d765c4d4f141b7f4af020792f943597d4e4c2b0568aa192360e89dff92bf6b1f092a9a8b75d73c0790da4cf8433dc135dbd9c2f65240f4e043ab16545554125196e75838e14280fe7a3a5077b966eced978bde3cbca33bc65264ebb27547d462ebb038a98a3a7a85d59a6f71dc20e770f8978483a6983a8514681a1815fa8b3b887a7e9c9ad2e9212a51b3e4344e958c88e0cdf781c07dff7dee6aaaca591dbf53aea258608be807486148d7acf067339189b04f6aaafc5502efb9c046f234f018a4095ea8378c7ab87448bb9f6e4770bcbe1d9aa0e7e00a1e835bb659814262faa218f7987874030d5cc54afe11635f31dcb3d8db3e54534295d34ba44b5377701ea63a86c1b3cb10e67b5a8710ba1a9af865dd999631fbe778b8de01a8982f82e1c8f465aa02d6b9c746a8f2bb5df62adff4428680a81fcdbcf6dbc04010959c8e8658fee04c5d438824de0f3a40291a706ed59b56a1a7337357776fb7a77c5ad950b8dd3c93397ef5e766d3305ce36463ee9b03d94570f734cd4dc264cb45b377a8c4f5b97b49052ebd0b0ca7d30a3a2619558078efdb0fcf286352f05a4c9bcb94d89b78b02d76206407cff736a75774dfda4c91276c5f46be8a32fc658fd67abb5ba100210f7b9926959692069cacbda7b87c70c448ab3b43ddf3a373bd0bdd70194c85c3346c9b8434c3b9e44bb092c09a8171fa9e789c7e1dac1723685ff496df2a8a8b41f7f95268f346c6ba3370bf91a0b0772e5ab625a46d4b720c0a35c439b422048611065391af42d446cbd045d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
