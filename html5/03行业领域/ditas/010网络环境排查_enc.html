<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c3b72103fc6256e02161e6803094c14c37062ad88f37d71c4e94bfce9b0b671eedefdc42924c67c2b9530b2118be7daa59ddfd0934fc737c502f0e4923c3c05794d0f9f680eaf8e46a1e8f6be66679f12eaded9f16193a6d1141703d8ce07e7ca766e4db8677831a5512cdaa76edeffdcbe03211859f84cd3bf92e540c797268e2c93b71ea4f13978c4b59d3720c48ed9406ecd45fbb7392c31fc10d6a65e2029611e7ef004a792b3d17da6ef0059af89c83af2eae3c5556c58aaa4acc4090ea83cf7a31ae46b57030db5dade6614510851a99881be60534aa860ebde16771bd65bd449e86423e98a6c9bdd5b357141bc7e7b1de01d665fd4b6c804cbe188e13de3febb12e99bb1371e0157aceb7a5ea3079a18073ed8d227c400308b7281497de7525f4cef942355beb831e889151e5ddb316bb80311c91a1665bd279af117f7cca115fa3c2a46bf4ebcad9f0942ecf2447dac8d069a8d7c3d0f51dc2cb5ad12c0a962559d38e9e584874a4bbcf18ff5e559babfb86be297a5d52f1cfdf643ea2fe1c4523ab2d3fe20d9914296d7e55a77feaca23912a0fd43a0e0ef5469a7cd9e28a70da8ce106f3b1cbea2d46842426c21f57ad850e329b96c5f993befce920ce77839a93c70017e95a62bc8001f393838959d669ef615f1b17158aa55e0c03d5f0b65a01ff78e09fc57c3edc0f2473c0a63a3799e2ea5bd63346b36e3a0b745034dcd587412e9b70f7a9657dfa55c3e2d67209b9f1b8b6607489bcf378e89293427364dd5ad0fbcc78af2107361017b7b5507e58696f09bddab411e10ac8731103e7f77afa14cef7759e25f723364d81ca2a65db08034a5c5e3e3f23026dcbbe5cc685f9508770df6c15c80b4980f2ade1161419548a214dd07a8e32c49ff9092672623c64fbc18169331130ec24fa63c33472e25f7b72476a786185dba13881a78cbe1300ed03a37bd3762a58b3136a36b0383bd45061d33fb48bb7df5ce0ad46e8bc61d858825c9183acb2d7e89eb2a29f1fe8851b995a439cc0c2a72d907d6de50786ae788538c9c3bdd6fe899c82f51e743f2a37e7d8f251cddbb2b5a5a3d8dc23c324f058aefe287043eddd35731a8b81e45508f693dbbb2bc3d2b61d90fecb9967d751c7b37b799e5e3d31d56af74bea8e30faea0f7e09e48149b541a721d0fda68eb7e5ef6c58b01ae302f84a9ed7949b5cc00b8d90f27012e1d08b8aa1e43340e24d422bda320782512478218f5eab614c212de0bd7a0bb8a9470eb921feee09df2d9a309452275704ddd4d1edd6d4eb5ddd391f31633f84efbdc20fbe8285de93662b69e652ccc35e25cfe82105792cca75120b4b1455a15a64adcaec98d419e029ac739e3c344983a40f1be5b38b147b6fb449554ab06a204608090a31f5b8c98fe8eaf7a47f35b346dfe3f3c083059c0b018ca709fed2a7a3eb4615287bcac33768a8e675997cd10f9d3b6234febfb17d3a6f5fdb85a66905e8fe410717e578b47e291e9787a90c136a0428f4bf8b5de210e978f68aec930a35a26f0832bcb66bb96ca36d0b6c0c6c53a2892497c4ea14d14a1f7a08adb7c675d0cae554eb69841925186510155512040506bd9a0a50bf6964eb3bfc68528cda806ce7a829272997ec23ef05160c1126e07c82cfef6ef9d43acf1375b82fb3ca850fedcb2c397c33f90519d1d3841f5bd0f1df59ed4512517d8c9be96ca309682b621d73787f90f2caada596fca63f9b4bd8268fa9edfe4348e187e423069522c8acc8a3c45415270b18f2900270bd1748e2bbdb5c9d414a6acd8e6700e3455559336d188028278e1073e9a8bcda4350101ed30c03d53414b4d2dce58f5527d5bf22d857b45b52bfe89f67427ed3e941e17190bdd6e43cda2d985ce6b9074742ca22061c1d880ba9a4bbd45fdced2ed64dba1ae76bd14005f6a969e0870b15f2037d1688dc141e498fdf5331c40fb22be63611fa492e445ae08fe70e942847bf84ffeb3513326235f91f0a0fdf1ec5083e5a9bf83f9281ab8a698423af9f0a87941afa41644b00f97222c2f1aa330144bf42c27e0ede43a7e146275d4379dfe97963503c51f5abce5d8235a4ac1f804d98f4219f2d674783f987f627385ed1c4b7bcc9560bb598fdd9072f1b85b38aabd1712af90f4629fea00c2929fce3b7f71687e2e5bd13c9a436cd207368f3179377a416ff8cf57de5bfe7edb469f07c6a30a10bb1950b1bea066acebad1abfcfe6bad3dff03068e1849eed397ff3a7ec466d3f7e97774c8f17691b80625ffcd3991cfaa37a42f36adf5d78f1da1b4cca6d1c03a4ff6b3acc6df4c603399c2b6fca09b0b0ee357f3edb989ce3869c0c0a9d568ba3ae565ca5e403f7f14bf3241f44d21c2f0e6602af55a953f160c9807c6d5f6a504cd95d4131cb434c2a03e4dcae18ac44a921b27f1fa0e8e10ac7e4f3b5d71e4eec8da0c99169ea827b05d4f4181466df133e841f99323f6e508481d78111f7ee8467e2a8c9544ac908afa5a9a835486999c5c8256d9c072721e923a22ebc02d2e043bce69016076c5dd39401066c29219c33cc32771c38d22dd8696f92c135cbfeb586685f72e95a8d00e46556050cbfefcccc1eaffca9309eaf182e0d0e667b595960f8eadde722c287d5e1fb95103020c8c09a639d0707ade1a606a18a3f4dad965f2f489af57fda9832188906a65c85955775067155b5a1fda812d41a508f39a7db97074f34c64069a0983d90d371ddb78453737ec7d5b3658d57e7e7aad3aaf6996e81428bf37daf0f93533fa73b4a1a2fa47cbff5faafff69cda12fdad30149af589787fb41642668eff289ef3fc9c3886874d0c105526b466761ae27d1ed0b9ed8d896b7236ff6bee0505b616f63ad5a2f462430893086152c6102342d7a8deebccd25cf868f5573b2e8f24cbcbfb688c40acfbbb09c5daf2eed985d034a4f608cb205fadc1826dab13fe7369d6bf79b66a40bda33af444b01df895b9005b09f19f08e4112e9f3e869cbc7cefc4df062eb5579496640ba2db69f2c1f4f77eca5ebd36f9402eeaaca14f6768438b842654ce45b2ce6012ebc20043bfb23ee78c9791a3d96d5cb195b5cfc85ab529b41d6b3bb666789adf74de9ea28114b354699e24fe793248214ec02dc6f60706266deca73e79772f68441af7d938df8507d999114424cfa09175a10eeb91a42a9364747266848e2201255f619af19665163cf4d64dedba3976a09cde25608856db4b7256b2d553295b36c068ff49008c15d535c8be138ffccaeb6a3f52dfc149220b230abcc427117f5605d76e0678b8ec30041a6dd09b7e22161f721a2979be607c0b07a7f5118ffb404bd2620e50cc484ea3869f22a24f797158666720ed70c8b882f9027b60e515ad2e5867d9f63ac226a22d1152723b766504995d8bbebe8d2af11e29b83ec157df416789a93a51b885eea7c0b45d05ee366240f8929670e51a9138e17b13d34f20d2026594f6ec7371a7883c63ac51f1ee2e7b5aa106a6ca93714f336739b0f544325512f56b8d1f0c58b984b543d3a983cdc93b20b4e7ab081ddb8d2adf090f001936dbd7554cb7118190e232c1dcf556796c937ba3364132896586e170f1c27551fd66e65cb3b6ecb3affb711d6ac6723415e78873d4fb3904f74e32f578b366f2a0e0f2e97ac650ac57b3beeda1839c0c1c44883af727804a5f1e15af49c4950ac3d72a19a8e4131dff498bb9c79b4db90918b511a62528f86ad1532a7abd9311de22448fda75fc90d99c92b41d157d11160f457bb5eda6790363b9f8480d4a7b570c73a8454442c1004e3b5c60f01514f3f04b7823d50da5f2d85ba6e3d350c234bbeaa9f87511b5d7b4acfd6e3f3ca69283838646c70496ea5c052da91cffe762693dbba214304136adab6eaa827163de56d9db59d91a130022dc82b7e2e06b207f9b89db1b663cf5ba4d814ded2a2689acaa8689b52c30425a029e66bb281beb7ad1250bf7ea56f855729f067cc016aace4238b325e4feb66b56032158a5c4a88b518aba19d9aa6a2dc2df083a841282edcad28ea6ad38221d184d29a04caf5ed62bdb9814e08147114aa12cbb0d25337aa8262827ab046e071c8bba452bbc0d196b1157640388a5045875c2946428e28d07a8f15c75c3df2a6951485fbb3909db54d3600ccfdb66578856d89ffcc9cf9f46c14d7424dee9be9c91a3084e8556742eb60171d577c9bcf3f308f34a23936a022006551f6048e799a014fb910d0ea57284e311bb509929d2797775752c1956dfc0ab135b37789566f8d6d3982aca07391f0e1ed8d1911cc4e33cb31c5f4009813149253bb426d149de261aaff9def512321c2c843d67fc3f7cebc1bc246b63a2454306c66ebbd98142199f98ce828f92e70b5ee01aa6322e00fcd8ef0ed688a7c546aa11399445eb2245fb73926fc08c0a9c2b83746bb8776d8f41a3bb4520076b9204cdcc16980995fcdc3c3ee3d906678149e49a7be8539ed327fa1b8aafaf880bd9801e7b99a6b9c2cd7f2cb3e3af2e9930001d3400bf5d6d48bf6f7febce729bbe887a6591bb05175ebc50b1ce327f6bab1324eb474eb815d7da7492160919bc059c4d25903dcee7012a6bc02fef0efe50d426e8fe76c4af290217148ca9a887006fc45c77f844ff69bcaccf9d783c1ab3ab78e4cc19d2811cef65f090298502c46fac93b16e73b0100a34f19db9086e19b1f32a2adf09738025bc9ed0133a3c9b652145d3f9b27ecc8694c2c91625f8f15f68ac593b7354a67aea43d82c49173938cc423fdc0da6418dc42250e1eff70c50addbc82cd369df53122d2c960fc5f9c909be30abc9f63a9e3ea2514adaa03f5bcedd556bc8a962c5c51a4bba3f8b1e649015945f8a5eae8d0db00c37be1054e1431633a127a2d585908625e5ebfb1ba39097f5cc6ba2589ef576d83fa53211744fb2a4147b4ac93039a2f5b53cff1dc461d20d415200380b420e44939e1a490c0db446e39bb2066bee979b59ac30f80fdcb906d25a8f054c39a8dfc4454ad61287aab2d6ad63abbab66930674de9b7c7acdd14451f4fba1e9b5b7ff293ca525274b0f814a70f492efdb7d51b421a5577bd275d5449a9fe1753e7c2f7241ee86d79bf0a60ee22352c0c76ce7d4b7df59833a95c0483f1c7ad7e5a15467a3c8ca66cd3cf2633be070da28b8465c2aa055ceda3f7d8ead8d3876e36e57767309b8d7b6e0ba5d54fc06de7d3664d860c856dd9b4d98b958203910b8f7297c668d56f9d3a9ff5418b466de7d7d90618f10b707561e8cc3a6b23f02c2169671faf1481741cfaca1e6fb3dc37c1e66e78af3461c59496dbe57a1e9dcebf46885f116a2cac63e4b046a21cee3ada33b27802f355dae9338754fe81032f740b402c458ed9d0c7bf7e6446e5d2a7753f974600b2983c1645b99d99d88be5dc4050b17571ac67da2daa7006c3338a428c85ad902748ec24209cb27266ad9069bb2487f74e63d8e81d2510415461865115e78f07d820dab5d4f4971fa7a63625a066fd811bdb0458ff5376e13a4670dfe9e5a4472f111ff7b229f66b128d18624d68149ff23b002dda4a99e8a8ff616342070770eb675f99c4220c7a24af88a75444cd9372e0fd3575f6570605f49eca26e6cfd7ba4048aaa41dd3076575345309d7de2ea5fd176492246ca4ca3bae83a77b9592bb34b73a2153dfb4e3bfb19424063b6200416aba72ab36cf22b55ae675843ea67cf2e2e6e005383b25c8126b50f4358b08a9fd32a75a9cae1e43f4f54c3fcaf672794f90f8d4ef60ccae9df9e470d2f1a077eba4638a62866798eacbcbdf2c1f6774ba66977ebed69ff6c168069c35fabe679cb137b5a38cc0b0cb9d3e65292f73e720b8972075c633787154cb6b4189a66a96b20866f27a270e1f73e533dbd892166e73e438b2a9fafed6dd5bd8a0ed1859ea281bb7ed6b984cb20129b4a08f637a12c4a16e1db44feda4cf8f0ee60a1669a33dd91ecbd059ecf12e18eb5b9aee3446e335d59c983d3af4eba241c03f2cf38539ce377b8e4d5f354c0995bcabe12657fb1a07e66ccbda646e90a2f32acb07c7679095e18b9cab55fdf7158fddb93e9ef50ae20a8e4f548a12829a174b123d1ac677542329977d39ca826f9ef3105a7bb3787712596938a95b1442a660eda831d5a138e9838186310e12ccfae72c2344043bba67871394f66fa3b803e743b16e0d3201cb39650680daf25b2cfe75a177f947003ffd112e497403889db0585846acc8bcc977b9fb29a5960a0e059cca6de08db9b68a5096eeb60fb0f71f74cf53a66eafd596be481c0236881a6d52ca342cb84d81e1d10204ab4d5cd184b50f0370c7e6df11d7ba467f829cf7f23713eaa6609dc11ec1923d1e642a235c637e780e21cf7002ebcaf745cd4c47f968829eb170bd6a0215dc6b717d82a440391d27005d5a013143fa6e49d3f1d15bf4a0090b6286e241b807645051d0fd023f21ea45912d2e5ac9e2caa8f6c973fb1fea92e5e477bb20fbf4b32cc8987dd42a6c210904eb94ed31748e7a764a36ae1979d12ad01e86fa215da94e7eba6b093e3ceba52c5a64aa66b71ae47cf459aa28f0f4a160b0bf0a2d3d9e76ba49647d7d90c22c7bb068f99311fd44dfb956704e8a790a348e56c3ded415cc3e93b15bd93a5b88e33c32d31603bee20e0e1d5439258cc20a5d5d8e9bed0763312f69ae09a5b09c9d288501c952ad7a024c60e8eb814c548beaec66d3778db316c6d03121a2820f060cd717ddad94e154cdda36d7539b0d4fc42f746844a361121add4aa101681e9d3afc3ac5c17daa10b02e0ea6083b542ceac6c550f17c96679ded5a62bc9fa443ea78be3500c4cadce24679bb1f33fc5a3fdb5c0376a26a11282060e63f20f8d945543359974a115306493b6846c551ac4ab17fe984698df80eb7bb651ffdad4cbcb7cad2fa3af4173a6cab3aa7a0f7fab3a80325aa3964310cb55cde30bfac8d714a9d4ecdb0b5901e8f40f15525397b6b90e75bd2d685cb39ed5cfb615e32e9e9506e4749596d1d7b619c81558c520b97587e3181609f6dfdb178114b30abb83622a03bac99f8ef7e08c4ad5a4e803ff0bb7a15b76666db2542a45384216701a47ee55d03182168b71d3014ebdc03c7037cd477f663837448ccbe7dcd31ebe9cbf1007718ea2d08035ca98ac7f997de00ba5e728b2ef669d8e54df82cdc321af46ac9ff359da65cad45ef34e0980771c9c626ac7f4806b689ec0fb0bc24aa6b2406c95864e843771847d174adbf574c61f96fc9d9500b211218350eefd0f4e8693b5f75fa776af1408e1abcf0f815af0cef00be1a43eb3863c1ac43093e3d637afbdddbe7f82f382973e3f616dd26f2c6e4a3971d9d6be10c0ba47c81f1ac84576a96be202b505fe530a27299090ecd7a1eb5d7f06f33b0fc6183b091b3811b65e7b29df195efb6afb48444f4ecc491547caca9bc0d952bc98dafa6c0082d6d805bcdb2fed41d55e74aca4ab2453f0e7ae12992b756034bc40542f3ac19cde1c14327dcc20c1c13fc4198566daa6f9b66b9504d7e3f783c7bf9d948e160f5010c451ba3db537cd5438bb9de32e54929baf303868f994b797bbf7e1deb4480ce2ee8b0e13e11d6bee2a699600ad9950fc70ade4125ac582d49e8d4d3bb6828c969d211bc453f75d28f2e16becc0b4e964e1d8624855e128844137aa216ef5c7918aebe8a8f13ff6b72aad534193fe97c7d3745005845dd1ab31cd6c0bc23dfb9ff891aeae4a433872f9372ad35116d46820ed0f4a5c255dd66442494c494c09e08d0424b9906d4ca28bff7ed1967afb5b8548111aac2db9ef02379f5dad87a70621ca9e31deee61fa0a35593387c296308655bcdad756a9728463f13ed92932dce0cd616549d5139f7bcd11f09566b28fc7084468108b3657f7929038a975ba0106ca27dfe2b6f1e24250c65d10751e89ae136d212e046966c83f5e87e6382982f0ff5af601b85c882c39f9b45d72ceaa9e10dc59ce225ad67df454e90ca0079615801bc4da145eab288243345b4728f4893b1fae925acfcdef2191a862624f5db4d4d1922c62c11fa75f9e105f919795de8aada61c67b3044a76f4d3c501e0b453554c4f9d9c8e7c994b20e632c324cfd994553e89fd77f25660ad6a283cc034b831dbb45d7003763971b216eb26a50493fe2826381a75596e5f3a09d91ef263b5b1b8e01fc1a1975dd795300c4193a39cbeeae21184687b91aed6278da5e79690240681b535d9a65dab51bf0f426a4d8d3bd7a99de455d1ec2bf3c393e1418121d373d18f8e662234ff0ba8676aedecdc3c0433c7ae4f9bc8f64a3228a6da873c6cb747e13098cb09a550dcf47fe8d248e61bb48725dbd6cb9c972899ed94c37b9b929fb2c33da2d03ae77c0d0c3b27f18d28fd5bba7b8819e6141c156705da2891d633620e7c2865aa5427e2e8777dde8b2f98698b6cfac954483ef5f25a1fbcd952ddb552c0f64902f38178912c6c75bfe7280807c902a2de0d6d55cb90377810455ffccddb69d3f9b4ba34726e6040355b43481fc3b549aa9781ce4f66c3308fb498414b9f883619a2a476ca66d008099e31dc10d730f961b93ca9751d1d21a119d938536467adc94747f46daab72d7c3990a525406cdd0e6d6d52cec2ba77a393c63718839ffe9f80cfe748556ab66385b15675744cf07504cf75ced8e81cad4eb7212969ad76a5aef4cb5defaceaa012c16b14c2a0ac428df2a08b2b14c86159992964b7b970afc175c77ad03fbe752bc3f8c448b06d72c53030f2b7dcb2fc4b5c2a8bb0c389aba83c83f3a748de7667f31ffaf56dc5fe9c0e4f9fbf04d0af7e1a6c45b0f2ebf2bdc62504cce3793764877147e440134f17633c7a496089f03ec26f68249aa03f2b6fd247090fdb71782082890eda6335f155d4326b51d8aae794f3ef6b598e16f2f41cb6c822268ce3b007875a5cbab4c8e168b11c408910a2c2eb18734ecca97f1e2c23151cc412f8c16df7699c21cab0ec45fabd8951d753ff896d2578c49cd1176cd71b0319d428efca13b96046ebf9ee7eec4debffe295c14c9b4e26b93548a81464a830ac14fd9a1d5b98a42cbdc3b199493ba083a7c305a025517e2bf3d36d1e747463878d538ef6de13fc95cee4b46c244c9307ed4b9423dcea7dd0273df54aac582949c279478c5be0d74333dfe3d9d85c8ab24f5e7263ea15b29565c6f49babf5be428f91f1dc6993d7254219d9be5a003d121937ea8ff209dd7f4ae8578a4a6053781235c707f82da9cd5302bcc6e16b9ac4a3f3140e67b835cd6b1232ee5b5ffa7da1b864f20a88e3e99bcb0274281c19617625df2f91dda8ea193c630d1c9a0c13675304dfdbdedab3ddb418e1b65d3d8e5e43bfe93a13c8501f820dfe1338eca726952b04cca1808eb5acffbd8379a28618fd2506f90fe627376f4b99e9ca04138cde5ff9ff214005313bd4db2bea6e902952691b1c801444a04877d3056409438999a5c587020258c6a422ff5c6cd7229433016eed8da97ba5076e9fd0e7fff6637da881bd9aed518b14502e6781e1b123071881837702d7f2952c767fa28ef9b793712860152c1550072c5d0489d46d95c78b41dba666fb4d63ad907c64278952230cbec122c0dde1a916f162a62d23d635d94cbcb9ad26b896897afd48e500b720b69e1b02aa0ee82f51e19a5c2a7683e46d63c2e97276ef1d0957f264bc34d85eabfa13fdde66fbf3f211abf23b5f3bab4caf4c4cbf449ab776cd600ef31471af4982df1368d6261dd48f73a7fdcf51b6512841cc92d36be08a82ec07681f265ff0fb640b66374d9f195fab26db186f456d924d4e1f98a659a69e5a1c40a046a018d58dbc9201ae8d6c6733bd002833a64b74941b728f5f18ce0fe146ce526aec32e514d40e4af041d5d3db0338cc6a3a745eb9b8b7569243bf9aa30555b3733b004ad7828768157d24fcde426b9e7f8434a0ed903aa898b78b950bad110535a8634105f7f32530d28eb8f1842d992d6d49b10d10f9691dca77dd6811932c9d32ae2412fc1f967b2d9f3dea4b9b40d15672e8c691d1dc77167a47ac02cae9f178612a6fe2411cf0ef495a77aa0bd553d389c2eb6ec137547f10dcff4c1e7752fb24a8971648f9d323b29b17c7a7479a6de4326c677f1076eb45aaba3f9da0bfcf39effb3f4ad566ad79ec21d4de3f47126572509ed869ce7543dc40297cd77fab183c3eb22724cae69e3dcaafe04cbf493eba77423a9c89107e460c170cefe74119d47bae1181946c972b94c1438c3f7687db1c8f4164aa203f355af1e984ace9a99d86ecb3df5ca99401a99600b7225f643ce95f9fc87ad6d946f54c2be6e30be7e772fbe99a90608f2cb3f3e7cf5561e4ab60075427f7b7f74666e52af5d01abb2b7f2060d64c50fa922c8d0bda1677b8989bc807d39363912a9f73289b86b74fec9e85d0bba1861ba433610b6f43737d904a603b9018c6efd5bbceace06560d6f40dac7ad1e69dcfb0a42275aeced28cca597329eec03108386ba7c16e95d77b6b6ce1b81ddf1b01fe31c12f365e8141c43b3a7c158a39a314ba49827efc45d9e04b80a068c1a016a1fad90ff81c7f3a53629272c1c614fedbdbb64af4a6f9a35697cdd234141b01a3d54cc4bece00ac03186b5b6dc87a75104f3dff7d0772b549fd3ff06c1873b233cf7829ed6b295363161253a0ecfa64106e3f816404564cd387dafad6631dfe64d6a88bee20e2435e89e6aad5df6b109d4632b633dbec25999c2ba2454a40fe40f075e3ac1b25e08d35965bd2a8501cb612fd90fb7c57f7a6f42fb3352d4c64f01523e06eba01dbc41fbce393fa5e2785bf52c5a4a4cac29b59745321cc79a626f7fe4b8568bf439a35a2a4e001c3f765ec5e6b29825afe4bada8795a077c5999348cf2e0f80e3525e130b587c223671ac05b202bcb354be6c017c90caae881f315fb6a108b7295f4c9ca784bfc81a8835188c8f48805f46bf1293c5451ed8b86842169d628da5079bce3924185d10997bce1432a2bf012d8bdd5d901c45b1cdf7ed5dcb20355d96d3511171d3ba0e411a69863805f486d5a250ad136c258dfd318d0462245ce7ecb8c536de9929e3841a536a5c0bf900ae862af8487862238afa50b19ba60978c2b37e13bc92f2a09510a7852a4d3a1d14571d6ea43b5b1750edae3213af5cb74fe9775da2fbef018bfee9c8fae23a0e1141bbf1881de1d6b16c694c094177217ae5d840e5857c4badcfdf7ab2a3385dcdfeefd6a0bb1c0d3f27afa83adad0ed6d3755cfa38fc2816d11ad705c13b3cbf3155e2858606168a7b7dc38fa3f988a9bafe729102270499677ba3643c65144edea377ad133faf7b497f6f9aadcced96ba07b4cd815d17da6213a316bd3a78ee1a66e4b7ec713f4f0c8b6cafa141afe627fd328b42056ca81ebc00098d9b6d08b50dd3df06cafa01e9cefac4ca2aa7fdda3e572c910e15b8e81c14e70dffc3fcd006de9fd96ad4bd1fb113487016a7815bb39755becd8b8396a496cd46500c3415e0b58aa021a686b40abd98286f9fb80c947fafe1f37d2baf89509be852fe67142","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
