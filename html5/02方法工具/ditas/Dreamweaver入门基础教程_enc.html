<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e04a0d46a1a8b21904838cf17603fdf12d5db434cd4b9728a23d0e2a0dc2b76b8fc4c888d2a40497cc54fce1264b5ec09755ce4bfcc3a4c15434f7d7d44aaf096f94d4f50c8ce1c6d1df979bee5477ec05f08d1e5cd2bfe71a376d107df4e44a59f258b2bfec1e61f9c0fadf04514fd46366f4be54e8158eada11d243551426d71b5960654874f85ce6798ccb843360a01a8e7c9de791ab647f8295e060d5ab33197813a4f11f5ed5defbd9d186161e1909c93886d92c48e546a3729a075818e9017b0f8979bba482f5de526b788de73cab6c907b85aa4075cf43fd03a68407b6332f7b7d44bb7560256a8bdd1dcd4ac8f3df978e25971472cca4274b75904aa87f822f147e1fad4c521bde89005b96f10da85b287f0147b676e6b9059db15083d1c0f308d56ba1cc6b1c1427480d3404996da4a9e357cce453aadf0769301ee5a2526c0e3b6fce17ca5ea668f652a8cfa1c076a39b65033182a545e8f3c1f4a0476ff2aec9f972bea81f466dbb88ab849efb10d57bb625fda999122fb92235529b101f5b00929db042e951c9ee221467968443ce83c6814fdd8ddf219d6914c02ab195d086046101fa2f609dfc017637a0174dac5680128859db6284392b281de21099f85cd0c5512e893df412b4d350a7506261cb155bf329e0bf40aa299c978272c5b5df88affc2f592333c593722bcc25fbde076b1ba712d7630f62f097fd139438e004fadc91da7111641af4adb45ec7d724e818e8914ac3338a110400cbec6eee1876964e82a3556e12a9b4ef19b21e6ac93070d1fb8415cd53b2626824d8a870f1d4b1d3991eaf5b4e797c03c34cb569ea81935155c06f34d108ddf9643056983d37b073b29e909c8bbbfb1b11783c2b84cc1c95f5e2bc6828c79bc6fa3d093bb5fcdb889cdba9e75c0ea72e7e07925d86cd5371cc87764c143da904430753b5627c7fffc3f8fc11beac3576f361c92b89574ea6f333623ea3a8bbf690ba7a9b2476518dfe006e297c6b4dc2858694dde881736392f2f944c385a94da7637681f9ebaf6d718675bd59dbbad8e28132c0f888a01b53b5db528dab70c06023444b723c22f650e38dbbbe19382bb15c08310dfe48c75914700aa5d04acd14c4db031019623b6693edb383914ddd754416a093fd8106c8feef85151df045e174742d47a34517d975c7cf6b0884aeb6c50da07b786593d77932a9e01cff4cee84625c333e50a927fe5cc6c42881641c7043f1332dfc43fe8753e8859194c3f53120c9ea6c73cbb56e1d8bb4b2d9ab7b64fb387489e56e98a41fdf65ee78e1c53ccf08be307ee17ed2acc2a8965062e3d253c2f93199ca7f04d09a47f2befb60ddd276c9c3cebc44a8c532ad4140bc97f4be8fe2e65db81b19f6ac93bce3b16acf7dc6e6adce8035689cd14914665ae95ca6a3d8e34cd663e80e1b8c2b80639e429ec58b54991dc2fddff350a2025dc0935f4a161cee4144e672048892736bd78ac5fabf74f43b8cbd18bc40fc08f33eb7e4edb04d39acd61320732eceec929dee3d59edf15652dfd2595e595d61719f249d0f0ea87bf7283b3101ed37159730f80567edf8026b39095e5fcc21ef361fdf825ac942a21068f4da713b6d449d628f0145566f7aaf27cc34d75135b2c71ed52d6dc43f9737bc1c43d4ecd141c74d84f4979cb5a8efc5859d1bdd2c24c376724a6b222e202f5a379492432f0fd68832ebc82cdb53dcbfe4e8a5384e1949e0501877448141a5ca6e29283c744f3d9821ebc2d68c6ea238cea0f3959cf46684903553dfd5706866feead0dd8cea5fa10d2b2406487dc2d766966347500db18b8da8d8f4344f3e73289a61a4fa657f55e6227401afba2cffdf74de7259dc36422aa4be6729eaf77727dc057f51818882d525e90af2961cc8560b8b68f9f47cbd1ca3275a14e1880961473d028b1d1e109ee855f07834bab4d0158a49ccf2d34067889fd3a82dcdc8a5b8affa23848d76c76de1a1b9311389fc6a0016fc200e096bbba9117d6ab7a13d2173c64ea0811f3e70476b48eb7150fc170c2cd3aca57d4372c965cdb486ca5cf4572e27be43ea8d63f50ec2271e9224c101bc6338ffd1deb9bf1766e2310c8267ad5152704e240bb356a3575f79b1d4bc22f1604431fe3fa14d80c5170b3155b24f506d5f6997c007aad2a404ec689f2406fa430e6932ad4d91aa5a518a6877a11ac55963a0d2ea2d9c5fc5dc8b4399eebd91ce1032015c5759df4296dc74dc06847257c36c505a4bf8fe7d1ccdf2034edcaf3ae43e825f825dbf2f806f955b9c4eae018980f5902b6b8538e131bd0a17b2cc61c9112c4843b15908213284e7fcee591c35a66786486be12bf150af96a291da4780444c7650081561381e8f54d325515b4ae54f94de32344051d926d0aeeb14ebaffc732f11de3c41b0e2b74e6b01540b32ec2374fdc0c997162f0660019c8a57188623da5b18fddeda3f99e5a44725781fd9832caf167296356361df9a41749cde524b2baf7b6c775e753201c12796d7adf50447bbbcc3742440157b55b20cfea2d7a3ad0727bfe23ac89565dcc84e8c12ae5f6280bd73a0a3cc03956914202d4d58d7d0b6cd2fd79d8e0dd38b1572e79c05f835515ca9035f4b29cb8776bf985a47aad189486ccd1666e4b6a96a987df4f5f2ddcdd7fc8e0ae7d1f5772f0204c18b14ac265d6f62a633890da0062ce959ed01b70e2e2e8825cfd6728e97610fb851e1da73b545472358bef144819819e5a7734de1a362f470da8e4fdc34edb3d6cb354e36ceb8a2a4c99be16c6e1c198cba785de20235c90e0f9d1b06c6a4c79aed2039133260a6f0620535fe2dfc05a80206bf987ff8a2b6c76e180980cef0d53208fdbd62c0920114d31d24eac66046a24282bc2b8ad34ad8aacb0c424ea11a97b1e83d177a3d8c896e5d82e92b423a0b572fa1661ff85597a28d6c931fe4b2317bbd5a965db1699c28d3b4e5ec05f26c820bddbec94dcd3b8bb05e825d78342869ccced04e58923d2b622a49c3dab951c0ca5d05111927a2bc079b6affce59396e7e082a10835af277a0daf61cad58890f141d3c9e519bd47491cd1e9029ca4526f5fb51c0244a4de4f0f17d748cfbd2df6df0789f929f59bde2405425a9583ae6679ad6b1b87659735853c488c5601cff19ad8118f21e2929ff872476c01bcc3613979f4bca687c82aa6c7e575260b600aed0d2f2cd6b777e8b86e36b8530662bbff8908f22789069b1b6c36306ad0bde5fa8ce92b7410d0b689fa28848c4b28c2db255f5c7e1c235c3e93a532729b87a7393d8ab1739472e6fb83f1452f9ae42fcc50a9dbb09d27ec270ff21e0442d4f69708e2625b57cd53f492a19888f8f897e19c40df7d2334c578c008509cb74ae88ff3b0835eb9a59ecde20200a0048f687abba546e791ea072abbb02b68a355b90142df54e5156d0173ee138ba6497fbf8778bc57642570bd4fe48126bb4bdc1e99fc31b6dc6047061e283fe8d9a9bbdbde81da0255143d18707d9e2daa7e78ffc46ee236126a2a2286e267c698e30f95ab7b6345eb7a422e678c6cde0282ad8e03044d3acf14cf526ae8f6ed29d33c915536dbffa43f92c6e7db21252ba36f40ce6b29d5d2a948dc7e6da139985eb393dc754fa885149a3b3b8edc5cd6f4bef38ec9216fe53125e0b1b6c7e720762a3f27feb943e832cfd8c5793aaeb30c0fd4ac82091040baac69cdc6d1e9215b0e84b0948414bc536dd8619e97e47795b5c2b421bef25e09516ac384ecb8f388fe8dfdcd4798c4770551ced980790fd95b926110a611e35c7ec2a44ec334a9da80936a2ebcdcc62046d9910d766f43ea11dbef3a36f02ec103a1645dfba0507feebc24e278fe902228d4880e29823fc3ae0cda478e390c2aa1f3d6af7846ab34c61fb89a44b90b6ea2460bb95eb5d324ea93d0bce3b497731ab273de8fc8990eeb4a43a7144e95c0e54ab0d40884faf5fa43d7da497ea7bb0f0e4b3216f5b17b9fac01f45049d95a211ce158d3a9ad6f942313b2b3399e595f8b15b030c16b707c1472bdab895353a9fbaf9292113b6c7ede8220c80fdb08816954a125b84b08c87607f0d0c8f73a4bb2dc99daf883c4311d510c46b542724cf7bec770b1fa19cd169d3331b8f33c772db7957aec349c821c9cc30fe0907ed9f95c1926b1b987fae2d028d1ac575bd4ce951bb163b6afe44694aecf3beb4a8d3a51de26544c968a841c1ac3f7aafd8a2a52f0daa5abae31e2ec1ab81a7c5ee5051af1a988b45b63c636fda9c15ef040c1fbe2c941d5f5601223aa39f517bf58d19444df4f6add95a0f638fe3559a10610badc3a2032bbd47ec6c3644755c2ff505be2eb7123e229d6eaf867ece5d32af28198d9ff4807887e1d623fb7ca2712af91c94e777cb3c6f9c4312b4520edd6624d115ddf164b786898146876cfa2892e5f4f6218e961f88ed4e48c082cbb18b26819f057e88286ae9c84a4adcd410fdf514f3bf4712c0965e7eb40805343e0743dae45aa352b1cec2d0f4fbfeed7cce5608cdf16870b9b76b3d811a5d9ab7396dc3e5a62032102990517952877c81872b66d419fd3e3aff8cfdfbb3d84d36ec301d4f9c302d9cf2742a9597b89b2dcb9d4d653fb809fd670315b7bbd308f2f13223a0821c21cc3a0ceaf6d3ab90ecba46c8d6e79ad8adbc5a9270b352c0dd2c39b95cc18b41b61c9b5052482ee7d18f9c8b55899b867ba86af4dc21b88a8dcab16679b26a04332131396328447898dbabff14db78a2735f31f41c8bb12527fd930bc16f247a3d8e688df27457c5746f4a1d4b93c05bbd0f56c764de45f66ee6f4916b781e7b69a0040b328646271746578764fa726ed0b28c0fb78d07762f03cc9df6783f1d7d4c0cf7a075db0799a27a64c15ad1a0d9bcb8a36c875c79338f2449a61a94315b996df6755004d2bcdadeb910929b8e8fbd9a1cdd6a7e0abb59ce597ceedee94da2981ef2606d7092192b6f32b65062bd9c8cf145380658ee8ff2468149d7d1129bfb1d7bcf2f034126eab0efec2f989f5cda47f461a0e5d250eec817e1c0a18451d9dd08e25c67c0f3fe0bc9bd17c000c1d69a344fbabf94ea9632d728b0276553cfc46209be8742b8dcd82eda70228df8f6a2d2609a229816bed1cc117f1fa499e71e76c067aa5c41f85f32d8545623539754837fb386d437c50097205886d87305eff124af2b7071374ea64eb0b8993d4225bb000dbc76526f787772cd6ba15d30ec4b2cff173e53421a1c38725327f35eda9a6191d47a7d8de5f59ebd60363b183e4611c6bc2097057f60affa99c10d1257c7f8d6a1470384b349625673f42835a0fa36fd286bdcf65a859623706f369a3709fbebc654d10a1ef758b10e38ee922714f89e9bd3a1f92875ee45b938dcbfd3b8c7e58ccd0506a520924b8d7ae8e55e8eabd5adb451e6518e54f18db3c3da71c7248860c05566620fbfe9a6a3345194b434c5aa4aabd46aa42a7d42e513a5fddd39a4229be7ad5731888f8224770479b5fbb96284e87ed4f7661e053a741f578f2bc5957181704efabadbf63b86b44811530d5410812d0e199996ddbd9f70e034136bb4eac207b795026b4516e3d13b2a08ce654bc6e4304369fdfde4f3f2d56c296d7ba5c60420321f0f776f2715e084225b40f82183e05486e736ccb441c6b79aa4f41b848c6ec65557d1e4c3267e0b461704afb73ea08b892e890a81e7282793c73ee1c28a467a35c1dd1b44d88f845b339f91f037c581021e141e8319aed23eb39f1cc9d3787b735bd5f11d7295f2af4f16599914c146d025be32f98ae4df77fd425080bf939627d055cfc6620bd65ce504a988354259849f7f045130eac4ee728c3f694b3954c48bd3b702b3008dba9f03587d2884daca5076698db250baf8311397aac4393bbeba68ea1f08a179b4bf9bda1c973c46442b0625e1bb09d932d95a97ba3e3bb0de65aa6bc0f39a8a307dde2d2370c94aef8157f4fb916b1d18d1da2e063e38187371c60b79cb342b84a0ecf02c8becb07b8872b2eaf46b43e9f022021158ad1b314dcdf016a692cfe457eb16422a46fbb6131cdc81dd9a4f412adab1986225c0566b86e670e4b33c353878332b66e4cf216cf7b803667799c70ae0d4c9b61f82a0d69e44a7c40d61d5c47382bf74912396fee4add0e78fa0b9bd60a96ac9d604dcef136b071e5b56587ccc19da7934dd5abb54b349111a2cbced04925c2cd2a2a6bfa79fbcb8004261fa72feec8dea71f914f9490a2669a099845565efc5f6c2ef3510b336e6e4c7aa19d880aaf2f1ddfcafc07dd37fc137a0e0f071cd62db1ee7db850c140c856ceb6a8db850c49335c57ee780712531d86d366577f8801c0668517419f638289869efcac90a000fbb38d6394df2c9dd11e8cc107cd90564789e44f7867756a7e0036c6f2276823076ab12117d749e2d2a9e40524b3697dffa9e392977f0bd33b046038bbafb24d7bc7fbe608c90d074486a43af7efe043a63d9a9804f207858702316416333cb3cbe9447a64cd0a2a93ac2f85bb3cd483a2ac02746f342161c72e4b2b9b46c0738b5ec106c4e6f6cd6ab2b3807838cebec150dbac2b7ec4edee8d1ede96f5ef7b3df8d62858956bb54861c3c0e27871805942dec9d55fcbcb5909ead897ef23c610b96abfb278a3bdde2cf160d4ca1a5629e020f0ab5a326931661b251f14ee0eb72159f73e50948884f6dd8106d822bf4efc0795b81fd043eb05227f876df213b83a0d1001e1e14d84a13cd0370b0f610e12433459fc4c21159499d6495f390a19aecc1335de768148a7748128556fe3c9ddffad0c0c01630d091e4b2b39e976e3bfd6847f7ef9205de86959b214308bcd4ead0a3fcc8ad0cf8fe0f83e0418dd560ab09972a0302ee60d07f52a586643f7928b8e9f9984f4243203854cbb742ebda8d52f1df14f56f55575e7ed81c97e8bb9d3c61bd1c5822dc319a03128d2c116d2d07361c93b1b6abd3761f32fe290c4ab9bbeda01c85f2d86e3aa4ef55d37c67bdd3af7d473ddc20c4416a10cc200d40170c6a24dfa3150918a5f8d3ff306cf63420e17f3775196326004cd0e58ffeace937d5747cd7b8489fae4cd4a3d521854b7f031c9d875ce2e0cc5100d8929253b48023a5e451d67b5165570d9e846ee481709ed3aec5e7c0fe90f6c9af85ce163f571051183d536c6728ce6d905e24c1b2a8fa5f0cab718a2a72917363436424d20b06a084c9d11e97195bb1e7f53e20da4a0bbc7b5cebd023c41c318c46ff847fd72a7dacad80cd14698fdc41a7bb13328f27c789cb7cd27df0a80068a71d0017590476f78756ca8f898214db2fee3524e5a056dae7b8c619966139b9f03750d31c8355d55b6aaede3e8aaec5a8ca0383a81f2ade382d9d1c445ea4429313250ab6c0078dcbfe9aa565e0c50e4bacd206bf181b55279d7166c441f8339ebecfc28c980036f02853b00fc9fc3af65c54aa2704317d46f90f3c3cc125d8710e96942fc3c9af8ae29906a1e9094b71063627f6402d1e471383929da2d9dbb9e20fb216b9cba48cdae6757c7b9ff604fe16a3ac725ffe45b3352de693ebbaa9d0c05d67bc817e87a18f4ce4b23b5d2c0eec352d41f42f1c4c34f5fd790f3aec0a36365126fb1b325c81690caaff64b8161b0ffe9e0cea3569af38fd458fb24b154f4f2b31eb2882551ee479a823f1a9758c198e4d3633f7bb9d4a31c06a9a0f5b3f7e4ac94ec49e25a71e8abf0dbaf71600cd9e8b50e357b8aab33b3660e7e8f289d1f7b82a48554ae986283bea60fa3671499a2fd554c0bda16fe8ae51411793a1a1e6a87b86d19e8e2daa46eaa7b131db519048b5709086fc47810dc51ef1c50a5e988ed2420e1b0fa9031f75412bd295bffdfdd7acf446592e32db5507e37cb8775c230ccd85e39e1987552aa6ef6560691ca218e870f58b1473ed9b865a52f9c345e1296c4c3d1498498a0e4eb4867442ee0a3e62fd5edf23e3a48650f6280c322b6c4d021ef7ed5881831882576d90f24073ac7ac0f98a6d4f4a04ae43b97004f630559194896e0c5e4c731d6ba2109cff2cc4885370a342007610eb85010a08b9a1d5a8ece5dee6cce5af7636afaf959ce974d7747b9fb5962bec009f9ebd16cfa521b66f3d7190f5ea6a0d62cf1256f24cc8d7d85c2c64307dca08dd147164f97655110e14a66a6858988ebee18cd0f64deadaaecbc18d25c6c34904b1719bb2c0dac9c20411e93f7e2afca5104d2e2f9282290f9585ef1e191bf353f7aa9d124eca6fd0c3abb9e1ddfeeeb794378a75441b7af74ba76d0577af494df6b0525209c3236f9f38a2db9612a5a41b1d68e37663e762d5b542d2ce79521dd3e9c9816e8003504efaa23b27b4724be05ed74678194cedadf63684dea6d53984452da442da8d7ed4c290d3312cda763a62dad5940c64fd10b050c7b322e6ff7621629de9da0dd95becb975a699ad61693bceec74fdd845bba9f2c8faaa4d3ea8f459ed073f46ac6d17e8137259783f22256729065f6f7cf93a01a2b04fc917c2780347245d252418756f024f6f506aa98498299b1f8229bcc7f220c9fd2ff46ed2acddb6a78286ebdf6211073f5c0ffd9a800719701977d0471269587e27971df4d3ad2c24eff5f24761131dcdee7266895970cd2e10fe65447f9bba2df3515cc9ad8de800ab37fd8be84286a36a300fe942d5d4e838f1e546f6c5f1d657e9bd4656dc05e17612fa771f0528866cd02d16537ed35e81edc49e3d43dc234b7cc015d3127b07cd714c1491693b2726f2a13dd95138c046cdfce30886fe416f4c9686157be328113d6f21bbfdc49ccce81a3b2cdaa6124145a7ec64833af5839c0ecaa21d1f2e38d607c505f53c6b57a952e761e07174872233b24e36b7e1f6b2e54ab7ccc96f11023a39ae9a09cd25e9888d3534bf7fdb76b71f610ed43d85f80a20af8da218ecafb8909116575cc2052f3764dccb7daa0185fe2549aa43385a923f7eb84decb6b31dc5bf5e6485ccc194aab3cd1e4226de41ad88b8f42c9d05269322c7a57ae0e49b7a5b0e291032f9b281a8fea5b742712af00e26e10868f25d8726610a680e86d50b7e9932ef2e5d6a564c066f68771cdb84d63ab782066c7482b342782f21b4b3db2eb08a3b3dfb7d0a5f89d983a8e0d3e9677dd5c7e751b2fcd8c302d14ba71459d4270b96237c03520a1173c0aad7cfbe413d1a51dad2a8f678016109584c4d5626c99eb0adb62b495218cd0ef7ab76212ded7abaae042d3c825355364ddba5aab54f3e7a7f8f2df621226b70dd00a68a683f45eab73f338687c61282c8a193ba3c3cb494cd59e42562b09092310554305f673b95f0bac423eb9a52848a5f92abbfa5b5a2cd6220022ac854fc10acc46851757861a424a39a120abcb6c780c51f14ea3080692f41c97ac7de6c4b24c0d792a31175be8bc7a41f03ced4813435d95a4b066f655ce49c7b5b3443c0d26af6319a25aef3234af1f018c55d86a44afbb1ba22333347bfb4f562290a360ec79b31cc18eabafb5e605917f44342db5644c26e667358d6bbd6058c4c82783e60f6f5b663f07f6de828d84e56686e0cd9363a90fef1a1e146ec0fee8d3d45aec424c4b1010978aa5e7375869f9aa34f4158f9422d6e7194cd809f4302c8dfe8ccf3a1f2906ab9cdc01c7a5502b65d06a196e481efb91b3c018379874b8eab3e2f50845e1e62f41f5a7da79dc3e2b6e7446654bec13041071ccaff4da63355a73ece461fd8e035be94e198ce3dad205bcfad36dd78135498374db2809405b476bf2f223758a770de43b61fd8e2660e127bfe2ab132eea121c575084c24cfc4525b2fdac1e608542e66600ec7c1174836d51d6b289d6d264a0684104b434920589106a44c3b3dae51bd0a6930891f81e06cdf34718040f0a8a9e7bb66b5634b46203aff7d87eb70309ba2b30b933fdd8c6f67b7e8fd18deca243036878de54a8024747812f5ddbf4fd3122cb66fa6f3b59f4ee295f536dc7ef21e8943fc2f9b1f62fe9ebf1cbdcefdfa33e9865006355610b21966ec59eda0875da29ba10c78132b6c670a2da67a41badea61502b4a3f489c9ac3e2a4da9cf4c0dbc3e6be7f351da63f8f74ce1be9a3ba6983d18985b87910e898f720e6aea4113f8c74d8934dee7b540a7afae593ddff9efd512e87e2c3756ba190b146495a19333cc3c13420c070defda558a58e5bfe10780341f8a29bb22a8acb05632937ff3655b5763b88c3f4f06dc9bf91e95c21fff1f2c0f50ce25d7697073ea4299ec04c1be9bb0f95ad8a5b3e0a668d7b76aa8edc8115465ec714bfa85be259a8efb886ea90adebaad26cb81a27194b660de6d68c458e1ecbbeed0ca17948293ecd4aea08c66e52867350c25cf150cfd89cf2fe70d2b4a0380d25c9fadac69562736a2b7e34f629b6589dff105565aeb5c7246be658fbcf190f6d568fd2fc03c2a73cf90d36aec77597998876d6b70a50ae4dd594321f082a1248f1a825e41d4a7d1bde0b259fde4215e67a374794f2d8031de7666b91ab44f2f9568be9e75bfdb3e30664b48602049c0244299e469e70a1a06f785061d675e65cae23ee3d30e7702553a25223efd0bf7dfd38d66237c0ff0addc64f25593d6185c5b97448d8330b0bff6e3acfd50ed363f89e7925c813fd3895fa6239f6e78fa6536024c7464aabcf2351816960168e9f405e3738e6755aa02683cbe64799f560f10f2ddcbab02f13248ba580838bd564482d3fbd9ef3e18a5e745b8757097d6f70831189e98785e1f7d63feee9de65756f12d1cfa82ad88c3fe7409950d54665b3a9d50080aad059b97ce42420d3d0da8acffe1e4f1e2b33ccd21a4348d13a85285b74f098b2d2db5ebbe3df79cceb8cd991ad44ac4b77d6835aa2b68f11177a7bc482e4334d76c3d6d02bb4299b5691b9eacd144ae7caf9d0e455cd2a5b5126e4e723675efea8aa9f178248d32bfe24be3e4667f88256503f02993048ee9d879d694cd76d76300062563f117bcc590400132222758a51cf4eb4e160ad2a9c61ed7c14a669680c448527d3a77e8aca6a91e6f4e1183897fbe6b272eaec4fd10497c2a081ae66ef465ffa21ce826fe5065b137698e07811b4f0e638a6e7205555b99ec5712bab59889217919f2899308a7ab272a4f5230d0c6d1a338403f83a628dff20eaed00531291ce61fc5124f7403a88182576598a6dbf2c19baafd782b9722b5a59d9e70f5a53dbf0c05e8d23ed56d5254a56d8c4c9398e981feb22be5b5a16977a705bf35b52d2a94fd01db0b39295efcc475d11b1465e3503d1bf4300ee7e1a53f3fc792d284ac8e030afee048c1be987b99edfee69ecb1a56eec184920e3e5079eb30520a8684ef4491d4170f4c038bdd479421c9292e25a4fc78f581a906fc12821bc21dc48dc64b0ad30c803e875dd1fad9820aff906a98251718d47917f8432cd409ea786bbf2397c56544c0d0e07e935ee72fa3e453991f8f7133052cac52669b77cec2e68bb08f2a0b301f916dcc4d95abfba2511137b0e669daca514a8eb8fa765cb41607ddba54f4b40a4599c582d91c8c6d7ab3bccaa40de0548e95bdb0f15bb0fbe4a302439792caeb81f7427b28ea5c32b0d55899030c8bb872e70b07157cf73f8a8f167d117797e22fb5bd8e22f02f1a60192954847c823cbe38e9240a951a5218ebdab0317ca8db3688df71eface4776ea3bb28288d5bc3fbdc674e4bf94a7a4df60040d3913563838f8da1d92e6f5efc572963b28934536657ed83a13f0569fbe3229e73ee91fd20c5df792b3d2435c69c2b33dac9bfe4df58c5819f6ec9fe224a4c76961aa2727a56db90ba5ef7ed42bd830124115820f28c3b4fd82e08aae6f30b1c460bfaec4596b151b1b65fc8f0fa6330d9077658b99fd8a3b8da4b128e72ff64195efa6eebe4ff9e4628098e5e41ec3896da328ce117cf9562c4e30fb55d9409f912149c8579c15355e9854dc0d38de422a6a2137950469b604e03069ccf390bf638ef6335909703831f51cd6c8ee91d96792837c2ff2658dcddced0eea543b1f5dc4eff6a42ccb49d0cf641ef15387187fa5452503960cf67ed03c9a9e86cf53b161fa3cd542b39e726316a8cd79bd0e2c5e8f7fc8ab8b33d7b2f55fc5ffc6ceca5fffc66c90cec52d35ebf5e7b06601b58ff49192e717d3c562c38096443621d0204ed9133f07693f70ce27698a0094daa9ce0e8de212466f4f823a2e545882c5e9b835536ff2ccd448b774fcdb489529fcd87ec02adf64564f58e59a18adf18d02631d96445280cc6736a02ec79c6278c2cd3804e886e8d675655d7b75123ee99644df6c0a290ae724cc47a86afa161dfe53f073ce15517c4cc94eaa45360da5d5f0c1282280fd74bb01525b93d1a61115fe7b503f7a8b8b74efc50f07a0e6295ccc2de5e7ba4918e51b6161c5305f3e3c1409b86ac72f7713e567ed4164eb300c26396e3ba44cf8729ccfd23ff18c7744a519f961568fc6e797999bb9aef39d0e7c6c70b0804672b2a4b1f6b227b76043a6fa04ccd8cc092d260d5db4be67788bd47ef1570cc5dce0144d54b06cfd8504f6e917cbbcdf1d0a956ac5df3ab2b9d40ab8ff20d359e78605ca67f3e66e26a769bade60e2af16c2210a982e5ce1d88d3c5a870b9f901bc621755bc8748f37f7bf8035fa39d8561b7b38d24781dd52e9a71aed3318321acde6dabda3bb16785bfaa80d4eceb632847b7d6b331d785ce5dda266f7c7835850c5a02b620afed2097d8fa8ab7f86f0d33a7213501435ff3b303f69a0e51a56e16bb9dd5de393f56b44e48a31924ef5c6abe45f8a4496dbfdeb78b9f9fc332550d2748f4450cdf4098fc6f0c39d6e1e502bd2781d7aad24ac24024f754df2da204ac55def17de65e3eded9d20b2e2359d956378c3f7110dae5ab7d906f12901f15c2ada6dcf20f06fa67b57c4b2dbf08d8c09eb9e28f47dbc804623a4b862ba5cd4b70fb666ba48f27cb50901fd61ec54f2fa16a94d410b42141934bed285bfd052e3db67edc7062c056d1cc35b018454cc06f6e92f1920657f4f53ef00761c46ae2e5a5c1aa55c8227f34589a7079a196fee815c2394339489cc796cd2f7a4c154c6b6e20c9f57aff33f36cceebb0cd354431e4f11f18ea0e20bec89e6732a1592f007393f4a46b31627255fe078514c9b4e5e88dd0f3c1008e4acf9d1efd1d8140e642d1341b10f36317e7247b1539f1934c012878097e0a303b44a6c2d954468aa0a0e910a5bcefe0bb7f789ffa6e6b6798b0e1646045d20c1c465cf642985692bdc517b1ddd36abfe43d1529d3a329d6d2caa0b0d9c121cd02ee3d99744a585c421d12203bea244c14d8b5cece205f0d52419064a3f046cb94f9d597815116844d28648bf4ceb66a232331fd87f34910efed35c8bcf5f97ce2deb60372e79753bfe2946d8944d1c382b8d8a7bb62565479ee8f9b628b1520ffff876fbb7ab489223c6b79dce92857f65a82772b21e414bf58fae0a38c1c3ad7aae6e69565ef79a4cfae8c81451b6f73d120a8a153aa5f68bfd4fe76376345c50a0eff739c352e1c2efa766bb721fa076f98b5b29d78331abcde5a9e64079caf19a1657900ffbd424f9d87bd9bada0c356369e0be88de6889548","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
