<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8689a8d4215e685eb2e9f6cd9fc7fa961a7984870e1224d5fd93d16d75b996f62d3dabe60a6d5514df08af124c2dd1d702388e68bf9886b79d61481b5755d54cfeeae9831af4936cbb8a2d61d1f4679db3fc2446ce70c66af721f7dc7dd91d246fbc17433f9c5ef3f92f33a9c49791fac82f4250a5efd603ff57892fa6859542c79c1a4a9653e1f8cc844f8124546d66b88f4e2877b4d4ce4cc7f6907e253257c97d0fcb21c58def101ca6821404ff837ba2d8c7f6f6a5fb8ee5b01636f63e0b485b9d00743d8a648cb70c0e34b4242610dab94094fe8f1d7975d89e1974442f7c66a37ecea6847d50ddc9983b67c4451c0a203bb13ee2b9e77056fd2336e41132bc5d3ca67fe4ded1bd3246ea2f523cbbb343ea14b6534d1f8804aee0e871eab2b881f4b5a240949451b2bd0282f42ceac6dfeac88bdf4ea112e033b12d2ea1d015d8a14523f72f01a9051260b737b5cfc890e8207074bcca3d75646470a34c6f1bca5dfb8f93ffd1127218110b987bf0efa6b5e536c12e44584b72469e4d8b05c988e84d95f095693ee635875d07231ae712b2e28a308f0690b5a9d0b88a30bdc0b830250b2670b6e0264ecfc5b73269b194f10be30f1871edc2e3df652951eed709c2c5a86720e35c27041e057bd46e0201f98c1e3f824896f684d161f9ca75079c5c3552e20b0a8c056c4738d4287def6945e970c2f5657e4fe7d051efb4fd4cf50effd9ff6fd0192cf9b84f4bc6146f463be4b2c042e9e9416eeb32e9b2b8684be558adb7fe88046bcf572d72ba0943b24c5cad0316089dfd5a9313861770eae99a674b88d1dc7c0f1956862c569ae13a98154d79a5e5edf2174d8dcb40aa0b73bb322e8a2250d55dbc791d7800ff57506355eaed2d31745ef7a173871eb81820cb2699a14e81cbdef88809445fa05dc924af3986ea5bfbb716c75cc1fcff251dd60d86e4a4c27645bba413770fd811c19a4a84f129e19bc53e5b844509e3e8cab7f90c36ad9f1574fafbb9d3b0befb32626c98e3fd14ae8a5d402f4beeed3e30df517914be081787e1c18cb2fc7e4fd4a689319b25c6aa1a5c75d39d8e1823eddf597718c61839e2e921d9b5af8808027749e8a84b701177e6bc56758cd58b9a1047a6d7050aa40402cf752ec2d21412a47a31ea4eead62de4ff98946964dc64616c1a0fe3196fbc4327f1873769ac1f7850e869eeff600ae0842e9c3ca1f3d00f5909da8ae3e372a948719514ffbd6331b16fee60b98e6d6b6eeec76e266d19dd37ff194e04090da8c4a4caa1ea13bbcd2f26dfdea2690b40674baaba41b870ee1aa15525e508e10b76e18c819ace75bcfbe1d40bfc3cc0825b9e75a08c2cb168821faeb4d3e1c2be2e415bd8eca9321a8072e245621ecb1190b189ac56a427806312e8ea89a900f311bce7dc7a1025cc7f707c3e0da386aadf600b572ea4d3ee85fc8b4a23f7fc6a77e7a723e45998eea89c788dff4f79bbadac93d2a10f45f68b78d9b2f182e78b732419177cfa595db38b007a5204d2cdd05138dcc63ae3f71e4bf66339d21da5b2c86961ebe44377fd1d5a69def9ac45074bc348d4e3d290e7faa3b1494737741dcb50b2c418c28018e1718acc4b326b6f55a174f794bc1b06e1e08cb203d487b4a981e48a777e0607a27fbe926a1377b0d9e55b30ae178f82605b62cca710ee788c1262f0ff41abf1c1c35f1da459cec0fce8ba7c2b7b79c83ba38b0dfc923c2571424b90fa0b3dd63d0b06db9b583cd4fe2f353579601b2aa1baa8985cced64e6809b4445340e9083a3493c148e8455e15ef705681cbc7739e74c99cf7b989712f382fc7dcb6affd49ad78fb246b875e0485762671b4afd8394c0f22918b976bfbff6b687bc6b9112968106fe4f7370f8c91f9aa148604b3e314bc30d5df21e20448415524c8576e69b78bc5f134e9145e8d67760d34ef404f7cb04549492c764061024e4b28af98f21bba5126af203fb870610187a30b1f24942c86febddb5cd937cac2120df93745fd3713a5ba19a00111520c70f7951cd25a38e8d555700c0b705285e8c1436a194ed56f796d0b11671bd5af98dda8af1da267edb8349bed6bcba6b2ff062849adc210ed341965ab5b5447b6ef11e5c294593a26db89460c99e208e9eb0749cf9827249aac477ed09eea4858c7fbbd78bc8bdd91247b43603bd75abe49295ce79a46491c4b6812663c24d8d745bdcc43737a2b07b07dc44769a7ee0c48910a4728d7450cb647956b30138bc040256bb69c7fe69c81c174e7bb6e054ccc2b4500e9ca8216d5ad6f6e6aa2a6ac519c0ec2aaca7a74a6c6f73ec569ce1badfea379953574a707a0e2b448b4a9797855ee7335b54b76679c7d891f8a58b37d167250d526b763966ce5c155979792755fb161dec2f6935a0e595bd17260d205c30c76fefc5aa965dbba58d9c800a00f9a5639b5652e9ac7c363950c0c132aa583043e1ca450bdfbcafc31073409137d796fbab5889a990540453ec4839c4d9f68f4e07d41ad2dbe0c7dd24fd12d6e4f7d076ed348f0678d2d5e47d063e06d2c0b69abd336bd987e85f631678937bd49e371ee07619d741dae5ff6ddfa4222c4ea07f0ab4337f32b66f2f1cb9ed2c78f53b2fea43b040dcf202d5f14f7894453b21c9a885aa14bf5b4ad8ad4f547d4957908b5a744a18c2f1d297f9298035eb83270c5d45e9c4e56c06ec4ddbb699fa8e3f4b8d5c8437730b5498240f0ba93e04655c3c504bf7049906d48ac52051819e042579575ce8eaddc54c485241952eb84e9f47d7ba5f8389df0c048748e1273c9f01c8c463eba58a127f2527acea3d6568d4e80107ee7d2fdca150bf2503ccd4bd5f3dc55824779aaf56eed716ca82aba1f2c31724354a6241d00a886b385a6c82fa6d9ebf98b4d43c95267b4c3529352a66b7fd7de07ff2fc391eb6ecac0d6dd861fceec883ef784e03f6d989de381dbc671c52e2dc8fa470c3c4f5fb6f02b438b049d4a250dddb9f30f27674ab38a4feb038f1a1789e11d60393125a7e2a3792f0e27f77a47c5753df0fa61f03dca2ea4c629d0e7f0d8985277d7d81986a52abbf9cdebc028ee195c38bc3c06fb58c9616190e8def794eeef1503ee57c280c9be993e32dbc7fe26ba433fda52433abcdeb19df1475e299ef2b688f8ba92c6582b981deffd56c5c26d67730ed2b23d277f4d01f2b69da7e4357c8af340944fa74bc40d422c270b211735f47dd4af7f4ed89dd6c7d4e9485f5a643460ee4bc60073348444a97bbb54189486c30257a7d8fd9692f941af3c23ae90a59e240a0a6b6e302ef6d8a85e4d7cf65ba04503d4bac9ba49b583c4ea818d7cb03aa127f4230b06c3069a90f972beb32b25701b09d04659f9b987169402aaac43e00dadfa616acb2ccbaa0c8c688ff6298bb9e6febd1ba492cb777a469b4b03c766e0e3adc7de787343dafc6cc93f825a10f0298b5a61a411d984cb17b542fbdb26818833a3d678dbe9a0708d484397fda5d0196f822a6aacf26b6a912a7eae43bd96817fbbffab381ea6220e1f26afbb8de0aacba0c12207d541e2fa6461ee9ac4e67034dd0b64f72a5471a36b8d74ddd42feaf2358c7e1a6d0bc72d9b3ec2465661bc98926ee6ade7d6f5d15cc31be2fe6450f983e775370e47a214dd3c92a8a94e56c8ee6f6cb438dcae978b0ff93e11058ca179f85e7f8804cc0f1dcb74d543a3b41e06be2faf69233f1607287dc782a917fd4acbedcd64de215faaa89b6bda640a24d33d97d83f6906556ce496798e186e41f5c3a5151d467ad4fec94dc1301f354111fda8e5eb060f6e622a9c009d3880ef12f94de3b7d95cbe5000413697ecf817065c103c718c332d6545bf0d1ccbc1be0fb3718ee016418c7e83031c8b9613c5728c8c9e45ac9584853e173efa73918da3790442a165005ddda2a26e2816db5eb77cafcb818e2090fdf5a1f3b82b7374bae996fbebc06342a903da477a6050bc5906801b61b9df06d9959db987a62445a5013da29d1972d7929e9c0575784d0238906afe2978bda89b0fc1a3b101a4b0afdabe19e9d7ae2643a1b0a769b1b568c0f4b9e31284d68b7f037085ac33115ab7fcd7a5f6ccb31366a6627fbd52db9d38b0e1646281c4e9e7a3d46b6a902fa98084c764df7ce004c747a7ba7a877a6252d715945c8606d948d369325d8259394232f212214dd1bd776bdd2bda4505fec35ca1c620de281432d00090e067e3ee87e1b1f18bd3d4aa2de71c312d2f678376e3fe802d8a3c92de269e514dc81b40d41ce46bfd08e5d3d21c33d8d75c9ba98cce3b3829186ef3c69b082013a4d57c60c716eebe59c9f4a4705bcd5b5e6adcb203c8915d983a78cb344d0f9f3cb0dedadebc1bc3fb03d6f6f4f2b7ce2632cd52ca0f0a3cb06f2afa57c012e18d5f2e20cbd4ad55d7c9f1f8873c0abf4cba442381ca8bd0bb0dbc3d54ca6a72f75f273cd79df26f2d7c0d0c057977f2f0f10cdacb9b24eb7766390ea99cd4c1f66dbf17070ddbc192a3447669495a6d57f4476a15af0ca53f164a0394dbc3e638044ec82548def31ccc646b2ec0c2467b05a1084ad93e2b1d77deaccbac6232c721812f4bd901884387845ee17c05d4a573f2f3fb0168d5d3e11c9e0c9763432571cd10d52c21722e95898cb33b7591c2efbc954a7cfc36d7b3bffe3a12f201dc347555513805981812211630c33c7f154ad39f09c581704c675372731e6c1ff3d99db1980d94b4d49164f6e7d8e02cff96e75b5d3a5c79ba7bd446c7f8a85a8fb3bcc218abb7fda1c3761dad284a08c318e7e62baa944e67b8ddd315b6e4f8426288ee3ded02fb9de2983a3a4f05994e8be11a6db2bc46737ff3e161301272dd484750e2e128889ff7db35a046fbd3f6f39776945a49a4059032cc8d5374a8c86293ef7d1b62375144d0aee8023c8a2e0fa15f4c287754ef148b646f81826d37ab0a24d8c0f8d0114f9ea896762186439a2a285951a111c519ff2d2bc32efd3edc63a5b937ac0bb14a8f3aa1d390b46fcf21fbb95c6cbf31da6bdf9f686892decb3c36175e86e4ee3d28c6fc8036fae75d32750e1f2fe42f6f8631390f745a63f55fa36676d84f42cbf44c82f4b4662ba42e4f781d3eed5a5135f5bea6f1e792ccb7a7f239494640ffa14d8b0eb2dfc34cd40a8e58c326b7de54ef2d652c65131f540b72b9288e8e40a25095142d93f663cd875e3f20c31dc5e551fad7374ce5a91ee9a9f20b8e501adffbb5c98facb4fe455a85c5d7649fee77fa308817354c54c982b3dae97ba77e5008bc5fbef9260dafa2482525f43f809c8a65bd63193cd6b55752e6b167b8b9d448cad33e195171cf5f410bd85460c1d4843c3cf5f6b518e5ee40790cc02f8411a158f450ce0c625914bcffadbeeb59a4c26f3222bf2fc0561a66c4cb5ee978f4d8a3d37e0965c5b4d351070861a53750f9b67cdf84a72eb8148a303e705ae27d942170328e88be053d25bf7dc0ffcb80c06ecedb4ec1e311f147ac53be38e71aab5585657a07b57200f2303ae06d46efd71a8fb4611ae6326b4243fc5f9867e3c00d233787ca67a708cdf75a5a591fb006f66eaaf7d7e050df2a6594c82580e2c442ab796bba11e0fde0875aa8d6955899b5f401a3546db050497d069cab246f88b924aa567cbd20868395ece3c805b97f7baee653a9435227448cfd36289b391c451dc96ada9781f53a18bcc3dfae5e6b4073597623f0e297ffe660f3f9689ea1998cb6ef37cc123cb9c732747e7fdb3c3ffd77075a3b35ea920c612cd180ba67e848588735adff001ab7f6afa9ec610e20f6aeca1a53bb323c86e1e5bc9ff2e87ad79589424e3f51d7355d957eabaa676e14fde5aa159a52f4e4996151f74ac7509e8d460728be28159214f768fc9a6a94f33cc9b80c795e0c3b55dc40e89f4b4d71a5dcbaf8c18ad6d8e52693cc8ffcbd8869b334c2d64801dd13ff85c6035e06c1ada045355c8e20b48cfd6e56550f16b872cadd58ea9a40baf44f00c82ff12362c95cdeec010dd5a2984364c8f8575952b8d47369085bbc94d09379cf3373556963004dc33ede12fc1c4257aa9a92afec63244dbdeb112e7d2462ccb11c3745c03dca5d1ed2c9fc9aeb1df44bcc52575af0a2474c18f3b00220719cf6909edefd702aab1bfe7c622425decee0525934e6a841682e4a48e856520c32482184685148e58445827e6dd2c6f55c6d86de6f8714b2c966c25aa6e062799a15b5033d365deed3f4591a373fcf8761304fdb5381e67800407166104369960a42f874e78c498ad24596d20b2e60ee70813c5ffae1e080e3b3192b998a2f5f6a9c65b460615a6b54c62503aa956c467372b70727cb557d15bc0db944fbf2e0a9730a292d17c7d0c1072b49c7d2151261158ebf376a83383a9f834408a0bef84d20504e576305a6cc964005f6b8fccab41b1356de4467fedad8ed99def9477c12e515fcc817ed834f34b271df3412265e0d16fe96631ed1be958dbc6f339214092a719c4546a440725f7dbe48acbd44a119225be00422ff911a1a8f321eb064d246373d242243734231310096f135e2108656166acb8199bbca5d02259038fb6d1abd3207eaad04537d12282c0011a34760301daac7389591a6a497c2406c6109d64abce16256c073ea40c17cff404f77849e7e2e501ecc8d7939286fe9c348ed36b7302cb66dd7119348f7a87208adffbc0ff1da3854cdcc7ad76ebddcf0d1e9deabcf772e378ce60dd524c8e76249a412841851efac136655ec1604fc71a0d6d046a0a40822c96890f1b7215171f0dba24682a8500e82cfc9a8073584dd13f413c8d67576e9954f34e788066ab33d62d3af03f9e1cde38c28a5039086fadd86c2fd59e41dac4e242e0a04f53aca209b4606d22b61aca3349efad84f2da061dac203b14cd0501a45649e360d325564066686cb928486a70488431fb261c42a4fc7c5b79b7ecf906a9bf8e90cdbf69f55d84eeb77cdc0c647a06f07ce2b9f05921658330a0ddac5727b9c0770dac259d4aac275387b0d82447493339ae1508e7540926854969105e723f89192a9d7d7bb7f74b6adfd613ea1d48f15c23e4540c63fb2d78eb5cab405060451501b02563eb84426da559e4e68405681ef4b1806bbcbb6ee2dbb331de9e84e9509ce7feeff5613bf97e93a9082de5db9e1ac61c1b0f6caac678c56b5deb95fadfc977d070a31d45ab6b0dc37917e76aa270b69d8d7e46ca2c90c51397e6bbeb88fdb746ea96ddd7c6eb9eddde3780b9d49806ea524faf527b8b9cd9cbe90e89da1c7ad6f6ec0113c72cb0c4b1034712f4da8fe12426f6ca1e0c7f781c96a337ef1f36a39e883d7aa113341503655aeb19cdb0415527ec434355dc2a5b081ff21e6b24484b32698804e41dcadc1c54fbf49f5ff2b266643b5d3b41c919e08fd079a63d7e2d2574db614737775630dc48a8d5080f7a81a0f063524a19745a18cf6971eac0de8d3c64a5891f404017663b1f772a52bfe0538a47b3dac3bfa84ba10faf167a2664bf89cc48c3f5ea6ed9cf0e6770beab8129ff5d92cebdecab74b12ee981cea4f504491f87f79180e22ddd9b64278a421c32b85136f3aff392df706e89e5193809109eb06e5087aa75ff5a26d4fc040316bdd8ae2256382c1b902dc95df94a97aa065ad60414d720ff67f86f3cb1505ff511181ccbe1f1eca103101b984baa0aecd56f2d4f6e971f49753dd5078a0911fa1933a21cf016c5e9e8d023e260695e237f644e2243ed8342c9d5bd6b5be4bdf9f090c84c9d31a7492193483d5af94373b7960dd016181ed16d6d03c4daea19a0b05b245ef2537f9ef981444f4003f55055ec512aa7877e3ef7f8f4a34dd1a4f76cdeeda2a97d092b8e963a1ec5aff39e478105962cb06cb5d0a57d3768730b9e5870cae7b9cc7a04c0396c53fa509d7803caa9d36e16d15dfc8967ae4cbbcbcb0bf0fa77ef6c040c104fbf33a0b4aa6f8c8de61d58a27220f932fff11261c5363583ad192da430c29a1eca9013b03257c81d97a7bcda168a3497815cc80018b3cb7abe9267b4b5157e3ca9c607f039760ef8a996a5ebafddf162a5687aa024014b970a1021264dced107b03f8d0e73e6364dcedd2d947fc76fa43466d4eadd6902bc9d21f3c70f78913be503ac17021fc84179edc4b0b8bce61893919f475142db021328c715c38dcdbaa150ca9950051d17135d9e93123c3b4bf2531b3a7207fa151ef3a9a4bb42a438d7299ffef5d38a6f09a8fa5c82e4282b2ec8c0980cdbb2e241996480c2c3404618888b4b9a695a326ddf9deb871ce3bd9d3fccc8f07c7bee52cdf99e77deb16f3edc1a8864e7e9c96472cc061bb1050ba3b37bcdbca921a3e10f54957c041acddb093f4146ab9e1331cfbe0a3161311f2b9b321bae0af5609d46cf5b5470dcde2154a1d223b61e515973bcce2f6be25657b94351a642507bccdbf7563164bfacde2d6c78040ecc2ee2e10bf9d103cb15c9d83ab944cc868e323f05c4c2c21c9b4c99c24019371a9c72fffb28fd63650353c27aacae68e41d879046a89f62c8726de7a155d2c80662e4443b92dd6884b7ee7923a750b4f388e1220fac91f96034311dd287eca7f6c0009a304c39887ab2c5f5d18fe836904a803e1ec526dfc798042332d362fd7c6cbe03d5765ca17b0e5808b2fb963a8b53eaa734d59656963dcab1fc4e7764f97c241d391d8f446c43438f798083e24ee60b37c39087579b2f7d56a281588d6931d3763e0e4114c359957510e6696c8edd0c69da4416d12ecf4cea381e9d6422025c51e92ce8d4c3b5d8f5496b9269edde1d1f1213edcfac32ef672992d0ecfb58efb6b50152dbe26bb3220672907ed85a81a887f048d86e82b6c33b5d9609ad94067b094d8066cddce727266aa2d6ee0b2e36078c4d255d77a54c2e75f4c4cc1236479cab8abe0a9b61b7c5a67e7b660c2d7e0e5b9268c7b27086282d958b597ff3750375082c4f7fca93d2a588d91da66901e231f612b2a59bbacd8cd12c98fd29b65339ebc6733fbf71718ce669f3a7ad5c32376c3a1d7c24cea1cdd69601d9159214804737e78e9e2c7ecdae726177c90368d49c9fdb4f65c7e3bbfce57cb9bd9efdac34276b9cadc7fe4d0e805e506cbfb255ac3b7d33ee645d9949cfa4fd41d9edff43965b1dd3203981449541ff0a1a3de5a9b6eab2b48c7f219f4f5b081d8388452918de7c3b61e3cfbecf0ee072af3ceaa38fad187388d8edcb176ca204eadf4d6a1c3a38f5163ba174763ad00b5a2818ceedd90ba8c1c8a7028cf405625fd15db08d7e2aa820bdcdd518c424384a7088b5bfbf0a994b9d0a725ebf88e614987e48d59bf77ecc66fef5fd5a6745fc2083aa9594ff99cf027876924bab6b57f7c55766aebd7208f640bbc13d97930305b89a7be0dcaa3b6fc206362942c17b411a6adcc31d4f6d887f26a1fca8e4ec64a09e66a1ff7299feeb0db40d5df1c19213d735052b91a3b9bc82a70356d9e049a9e1ba53427964cde02284a7f8b7bfca742f14e4378dd1047599bbc12787a1086ccc20a703549a44827e170e777bd8063205348494031cb8583a5e57fb6b0933c1b62e88b7c6380e59f7073e2ac19262bef110e46f0432682c99812cc5c2031a026667ba44cbd7de2a31bb3bc957624d3d5b5092a5a475836f18b1590075134f908e278fced6afeb783a3dc14910e80b9e682c164ff86c6fdceef27322277cf05a24bc501d9b951b93d8db5bca561d8e70c1ce4d31d37bc62152c86021e04aef2ebe39fb39c1e6e02a18c6e7cabbacb9d249596b6a093bce9489b26b336e894fd21d244df9927e07e39333228d2a4ef78d49b41473f26a651f8478a826a3817cc1f78224fd3073de865beb7a7de0b98d91b522ab7dfeb3d85c3e52e7f9322fdc28e8a6a5f1d0af99500240034db9a859b6186a213d0d9db519a04470b009eb0bc8d883f3f4beca733660519e71b1aa690f3537134bb190083d4ed5d022fd3f971bcc71c7c50c0c03e0348bf96d1cc69e05f0e78f82b15738d9fea31b4b0a010fd8d232df6c9f913126ad2655df416e1e9a180884ce8c13a14ba4c086b17e3b20987de93e0008c248147c5759e74aab1b3c22537f69d01a5072e7026944b26130b451edc0ed226d98e580826bb1cf3151077af28d369bc3bc2eb3d07fd66af864c6cf30b1755af01bdf8501c31be4a80dd9cdfea67fce6d06c1e4f916e191c9eac5dc20984063941367973b7aad60943403782ceb3d4f0c5bcf1f42b69baebb94a3f15c09a10cac984b921c66280c0818b8ddc9febc0ed7addf3ec4e01b10f1e9f0005cb95dc501efac703deb2b915d034f3ed76e49bd99b7c523da80a8c2664b6c0cc88bffccc6df3c2f1f08926bf64106e8f04b3681f6040a5bd1c44a6aff816c5ef1846f66fe3cb50b2120913bfbe577e6dfae0a5f4ff079dd1a8ffd29d3d4cb5f345bf25386ece0ddbbe3ae80a25baf2f3f7cb91d00a68a2b008a8729d8acf0dda6653f29bd7f069e65b73c346ac7430bc30611eecf212232359d7e7c29ed82fa8039f6a4f5536cf2485dc697f8726ed82669387f1bd851995f8d83b47df4c3321afe9862f41d245b210a0388009b08046893a78c328c10b129c071fae7ca0674fda15d7a377c576d0be620322c476b854adda7dfa6d5fc9b379a5f91a4e70ed3d493cf8d24eab2bce798a7caf78aab83e996bd318c1c28a8eb3fc150ec321e11981f5d731f386e56d86543bae76946f4dddaa210e87925d3446aa4862f505da247526c03a55a480d17b3791a31a1f23bf3d27fee443420a33480b565d852901d656372c65f96212d21cd33adb0ebcb7a03901efaf4f0f4a62e748a201708d49f5c8a07e187e5fbdbdbec6de495e408143025c69a4ff83bfbfe0edda377a31717c55f85c98b20c6500890100cd4894acd283d1749c83f1d9ba654f7db87b165c65be0257468fda75ab20a734a2b5cc378f2a0a2ae24fb6f47bbc8f27bd45e5c437cc23cb06a64e9b90205a8574e31ffcdb5703a2821f0643c16bafdc1d955a8c9484c1cebfaf13635dc1c3f0c87810bf6ccd64279f7068a78e2a9b40ddcef1012958f63af23c9a93e709b980f18d47f69197137582b6405e0840182015883d859dc4ed5680469fb87672288eecb09df656604a163221d5d3145397100f3a9e488943353bce8f9082d2fb0583e3d83b748611f52f1f9ea0b7ddede224b5e3d8c3f9a082f3894fb4038c3cede19af3897b6b1c59832c434e7558bd012547793c136feb96cfcc419e3c91772311721f379d91f543f2b22f671a0c5311f7601d1e334cbbbda3c1f493fcaf6f7ee611cb56b1e518cfea8545dd5143c0bc1b418f8fd42f3a304ae724282e3c664c0b1c4bfbfd746fe3b5e7943047abce9644e39868f1fadddf83990f4aedc251ec60f52fc6a277629c57693c99be12a9226b41bd09ea325764628640eb353f16f35727acac40030d65117fc6079bc714c6ff48d688bb6b4434ec23849ffc983631f26e1b73d6fa30c96efa3f49695d15f52e6df9f9696db1f9e7f37bb72b7d58cd0ac811de74d2b7aff9ae52a41d73f002931a4f59bd2aabaf1c4dd4ea868789c1959e3187ce0c08e7b78b96d77488d13f158bfbbd7d7df459f7ca000748369697264cc258e60d7d21df1b97ba26a2d9278aa2e4744eec8e66dbca3da2650f461f1e2bd45e6f9c4c41f0da696321071592f4d0b1e777fc66e4f7e406abf40caaddba9303c296f518d30bb6089401e388f1ab3a1d167a64f0ea2fa4b4466202bf669570be197bb75b87bf9589ee94c7d7ee9babd909f693204e8e3b138a5165644b929bbe077e28b5d6ea5aa19d81abe6354361bbb504960665a6230655b57946ce4869a512383022def4f5c4b7289714894c478474ac4db0d15cc704eb256ad988e9f29c217b809262fa580bc6fe13d54e9831519e3e1fafd9df4b33ada983fd54c78fe89ccf46d94ae046805b272246278f54a078ec61a96c2dd7629cb120ea51f1cad65cacd91fc0ebb7b7cd0a25537f238dfd229d8674db94247da60955cee3f46c2abc41f9bc21691fa4a2c10036ec1f06b7b5a8cc673ab4aba3e1f2b68506b7b4a4180b3795ecae384dc44092e9577e52ceb6b34aac66f06ddd54a3b2444ae42142324af0f601fabb81d17e41351d78ea019446144889b0415284ba0cf6f09f5b8dd087947041f2af2e2856e86578c4117b377ec4d3af0b80dce523c144b287a68d2478bc2ffdc2a838651f1e677693a990aafc35e501a2a3be260be97f62cfbd077498c9a75029cdae00080374819e69828548c9158739956a7fd08d34cbf5509a6c5512c8a95783af3f3a0dea66151655cd7283fe0d7050909681c9f3113fc8d893258c2452f738f43e7e12e6e64e8ddeff98e2a0f711d026ee2c202e9499d3158851e297a2f89b041b39c0e2a2898218c7df6f7cfe82f526113659a45c5975811d287a82382f60b49421e523929b89b298c7a14d395a3b019f2146466858fcb1e39677810e4bca1d7670f194f1a1bb5bffbfa9262dc74325edfe482ce41d45868c93d359c5f641dbe98f9ab6cac685b8f5cfb92388d329dfcee79a12737b039ef2e6c3556768b9590fc0ba796e22030e56ea623dbab9bfbecbda687428589ee1719cef91c995925408e0a2c968947c55e3d31c11bb7349eea614aa42848c0b8673d2849da79bf21de7250c3b49d86b475c2f17547c9f3e1d0d5e61434f7f056f8610a2d6503ac211a3534732a2c127733b73d0c62a07c573d9f2ea39deb0afe049b71824782dfa00c7817e550173442b3b1814d7f52f1133f79a727b808f914d6122845aef6ff34e935b66a3ba7b923b4b72b1a99dac0595559fb0d9f4b3801a05ee9d0a3129ce1c989ec6c9eed25f01ad6bced1a9310f665691a3b817dd3f7ac74b69cf8965cd0e8cb10b08cde1606520f3d55f8de49184a066dd01de7e13f961a629c668af8b029481a1a0ebe4e5d0f38615287cfcff375d3d28e4cb320bd1e3693976808463e619bf5212753925d564a0a3edfea065cd75f261504b1313a2018e5254d5418c23c32c6db0ab348d5f527c722c2689fff35024d468cf877f73989e7dae34d415d5ca134117357acb7362d3b0a162d92bdbc7669d203079025e355e6da8a27b166d8df28ec0231e971f519be1582b3b53c2f7fe2e38f485c84dfe3a55e5200dba0a160e71840eab958ea7011a9b90a80cdccd3ce1250952e5531794715ff43edd56580fa0f0ccb365f16e057bda7ecf60a6b71788a751a8472a1de29f65a27e7f56692118a54075809d228f698b061fd4bb9e922d84b090868b777e6fa8a432cb0833069e0931308cb71e5bd7fb53036db49f93e52b9584b77cf945b2b9ed4fced4452cd51ab3b6961a75b9c30cfe6d1d2ddd23388df3511420812e31160ed41baacce73f5e0ece6e3e4813b7f179734e5357fba3446c5415e5f857d1208aa114255075ff2db50b95c5ee9ba58fb75793f2e0e3a3502c919f7ca177ee508942e9f9d18de7def349b956dc6ded961dd9b6f69799b3dd73b5c71a916af1e024f2b238f5424fe03db62552ccb7c684fd9a1143a1ad57c7a1590c3ef46da9f4e28126a49d0bf35560b56df21cd55b8092050f1e27301ad9ee2a6cd749fbd990302c7ebb0b15657ec56a3473c2db676ad45d6b5087edd0fdb44f58592870a576318b30cfa5fe9be278727e0c64441105b17d62d6dade5c188886e55e6d7bd9af01618f60e61dbd9d1ef205310b304795d63d231c922bfcd413bae068cf6d23546d231704972e8295d305745aacabb847f6804e6ab8bd7d02c4a4fa6169df4f8001b1835a6ff2134f981e4189e95970031ecc80b47e58284db7a81dc171b97155ab86337324e8f74afe0d5ec96800d3cdf3b9096f751305b39da9e0eb2b8bfec55f054b55921314c917d20184ecdbb9837505586c6631bc89994bfa6364cf9c57393863ff9afb4721820eac6d8feea51fa15b6c4538ed675909c1b6b9bbd8a670d78425c33cbc34c37796c76e0d917da7bbdd910efd8b3e1d9522aa1ec1dd114f2cb8bd8903036f91c0844d89bcea5026d18a334950742ab7db0f52691253c7bbed8fdc06ca34db4ac7c1a0b1af48e6e722ff3b4709e9904fcf4a3e5a4ea421d39d24ce25da759e5c765729014c140fcdc3fade35f6ef5c6150fb2573f37159661e3f6d2a58ca93e5865de1dc10672a60599b89c9ab0e5fc1681c79659ca9778982203f98e9b0c993bc1c2de264d446da9df2be3529099e7a75a4c4f130beb8c3448ef604eb28a37c7a4c83ca4e3f8da0f6749b980de19fe04ec224553f6824a4e0817d20e2f9f731e4df8dc65cc7178c241db5ae9b1354f0fe88bd6cfa70e0e216e3970b6529ec72576d235f22b31e6cf548e47ec8f279c68c0db2285e786ded5d45205500bd01276c485e2f3f9fec5ada062c24f4ec4bf227e1ba90a8bc40b915658af08ee53c0e1e29cd8a6023359a3eb7150500ec5719d47247df8eaf20fb577fef4fe764656c51a53ec486c50649ac93dca58e3cb6c5241c6d689791a86ce148aeb21c0a38cfc79d31a8693f4a50a74f5e92b84c3d884f459d46f2886a2ac4a5c7656c18aa7996b3a718ddfacd1cd1abd3d79a5a7d38e2c5b877e3c927c4c7b586b756e3dd10d93539b9326a95746142248b571303f9fc1fc114366edebf812c399962255e96228efef4d34986c6fe511952b706dcaf0ab82ee2928ba62df7adf79297cf78be8e693295d4e62fc73ddf9c4bdcdb49feeb51181c96ffaddd781aa8fa38e31c129ba0d33ede2752d0e21c579c4c5d269ca5a7f0409bc43a9145642e8f184ab86fd9b05a658967655e0de9f0d2c0fd5f8856c03c5761585af9823edd63d50738290888a1f21077d487400b28a12e7449922be3d2731bbad86ad3a7d230596dd44f192b7e438e0579938f802ade38b94a951cedd157d9812d14c5a40e291be05bd34d374e525a475b90a782380529db55145875b945c6c5c84ed10639b65c2138db96cc810f0863aba50abc2881d73f3938038ef19585de338dcbe9a6d991445a9a893558062be5a40c4fcf9fba6b063ddb3c4800a6db0b6ce4aa0add239e6fd71e9a80819dd23f95fccaf10aa0e1da458c3aad1fb48e420cb83565367de9ed7c6705f8e7426716935bf85800f94c6551f1d3a425b4784392a15a0d698b43bb869bd822b0f8b256beea42266b46225c77acbb59ad694d3d45d579bf9a8fd29e5b9bf0756e3b9b7c305f01048121af4ba7e303272a5dee1f78fc4196272fb55f9d4d7db5289008e255b008b58104c124998feaeb79dc572d4b002782589baa7efb1dd584b26abe132c33e2472b8b426e94566bcf2ead8f2bcfa3fb8bb6d7f25386b2ef501ba73a482b9892888e375e92de7bd06c3f37dc0741ef74827565318266858fed1ca8f721ceb4f4d02435cd5496d6618947b6068606999aa9a822dd2198568a5c9b09bb3609127d2020953c45d91948e37a45ab625a8649c29fec60ae3342003273e90359bcb0769d8477a83499eb68516476dc6b095b7e538dc0c3eccc086ff7f315925589223996b9acb532fa7a2193f2ae3f4bf4ba81b8ce86cf51b12f20bafc90838f87d38d9d85278d5977d4345f9e45ed609a588215160a8a7b3de04d554832b78418c03c2221bd6f19692df2daa765a59643d0e6d592036ed3edb8339d31efccd560f8aed771dc29339149d471e72635ce1454904a60254113878ce25cea8494068703c2d3d7d15bc9d37b931891c0495192b972acfd6c3c6d8ade42ff541ddef1355baaf4d5b5fc44e98eb2ab02bcc7e9f8fea75b96f54f0aa3e0cd6d3757860eb776ca0b9fd049ce7887aed3898f1aeb0e0155764eda9088f6fc477d92eb935fa1bc771efcec508efeb704ef958a37930f297f198efbbf83efad79e16298503a2067bfb7c3a9ec6c778b98da46af90c688e5ab5ed646355d0f8b178040f8d67d074f95632c9cee50bf0d36c00838925967c75ed84cdaba49f873afcb139f4c0cd9ef01a10bc60fe817cb09f0be6896cea40a2ee6f3f0f5ce4f401c9ac341a938814bbc49303d833f53f5407060fea3f9b8eb38be5952f16a260caabe93e2d023ee9b1cb6a495e80e5457d39452a83df5e3685a271b31cb6f0b4ddf2b0f4584ba327c419dcec655a5591401656667b93070c10921cd09fe25b86e62c7e203c63a0e507eac402b5c1fb97415e6a383fde59390ce23dcc9984d3b08b4e68356e94fbd90ab1b3a873d4f0c062e0666f12168aeb31f2ee5226ace0baea3b790312d9b78dd9fa3d3ca0c720fa1f989f01bb5d29f7a5f897c136de9729dd9d8e2dc0d2e50344aaaad080549ae2ad060a14e6963128d03c92f868ed44a31896a3544fb7f3cb66bd3b3bfb3ea9834e8420fbbb96c07bc494043541bd3ba75a0aaa80a4e83a3d9dbcacaa9a21b55ed6dfa1a0ff6584911ecd37d8d708b2501d58e219b3996e88c5339454dd08d38501fe1903e0901be701af0e5fc276d3f24bce7551eac05ea03de285d5f966b728a7320ae4c8902960d3ed188cbc53e79b4e6a55e6512b8860779c228ea2fac49f8f43806e1aea7575ae61b59fc864ef9e249f680753cb1975ae2d60dd6bdb5f0f8c1d7eee880c1c95117d572da316764dcb90455ab02b361d3d3f0d2c6b09f4490556c5e6751b650b180da9da1b0f3a759aad87961b92db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
