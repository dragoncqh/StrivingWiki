<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f1e8217132d53814abd89e5ddaca8adf085598d65152077254232f9993aa59f33842f5fce30ea00639b49cb0e4911d2b83ffa8ace3c8dbd94b8ad455d8c251a6b94d766ce03f27a06f3164a0fa32fe39d25bee1b02a53af9485b4c267b43f6833f165b38858b783f95ceca294f86aca4fa4350a188fa44b26a9b05079ae53e861b65299a21825189cad77d20295afd887edfbd4253884d6fe07d148875ecef29e2c3654d8fcf3de1f92a8ecbe64882b980cb7dbcecc7344982c09653108039bcd9b1f9c0a87efd6b25e97e90cd955c0250d49ed7d6ec0ea61157beaff44b1918a7a2155783f2a8958bf3332c5363fcf74a7ec7ca2cc379a47d4460ac38aee303e53462b0ebbaea4b5f607fb18abf78722d283057ead4a3fbf83b818ee37fc5fad1dd1e9d4525f36650400121a474760a0086a492013ab7374dc32d1eab074b3c619b4cdb00ec4b00e12c9dd260519e62a780c9abc31c86494bfde45d1855866282fa731d2aeadb23c27cd1ec7d51f173050b50cd6b210e917949f8f807da886fbfc1d2d7e9b08c08fcea809ea7b73ef11099f545876940ecca556368e0ff4538fd663d08f5613478b769d25655a972a655dadb1926cbc135f946bbfedb961b9ed8572ed065f57aa4f2556df32d234b21dded74487e7d0582dbc47fff967890e00c6bb1b0bbba68248a8e01086ba1f56e7b6d3c89f9a1f995544210c597fcb6e2e28e14cb117b27e72ebb7ce6202974b51e106a8c84153f34bc8b8e6159fe8c3150ef8e4572a3f826f8166cf157796bfad877cf3e2517d4f6b326313902cf92df111656d6fb9b0d4f756bedb152816be2bb904ce53ddbf2943518351daa6f46e87ad1ca04094df12d328d48831f71688c7e1d5b97a0c84627e7d396edc1c190adb556cf07c61f69742dba8ca76a2bfece1f36481f278e0e7d0b614281d12582ba32b5d40ae600304f069c86b49bb2a3e569994371bb023b37b804f73a1d1fc2d2621bd19efeedabca7d3a67499dd62196d4dc9e948b09f4f6a4f5a1eec1795e17e8e9e2f71ecd64bd7b2c20456d3dd28098b39151bb26c3388d0faaf7c26a9bc1a422d713ce6318bd56477908f41c36ec042815385444eeef9ddbfd3c16236a404bc175f8f85d59bb7c52896c966db5424ed0ed4961444b404b704628b84cfea76bd75ea5169f8538767c9b6f00547d4f7a9f75f2e19a48c75e5e1f50a4d5b7e1d23857210d79a2deaa0e8c8c51b743bf1409f067f4c8933d484f778ee953210689ba6348989dffac3ffca094ab0d34ada503b878a276e03fdbb9280429d5657249d55bbacea12085297039e21052f16203f055bd3fa42a83283eac016b6a67a4779fdc8d8ad2438b425dae5a81125b7260a45b9834cc6fde83728dd5f09fb0dcb16d64500a94b4b14bb57cf04a8714910025a98338d497d20d6d0cd31e11a6e59c14436c4668657eb1804c590c3a32dc1c95761b0e23542447e46d8af0810e48ab382599cf179631396e5d0e583724993ac2dacfc406a2f39ab999c5ed301e51c086a1047f844612a34f35cdd9715c7b947bfc5319683e68cb83799b2443d52d43b4cbcde6546ab91e0e0075b03276e164d64d5dd9cd9022affcaa124bb30d07f291ce3400df72c5c391aad5fff23de1dd3f4a1b9765d26ac73d4cec0156e048f37682a0307537cbae6b1b4a7cac54517ca7e0ffae4dfa6821914b40d05393f48a0dd75febdfe524e3a63a8e80058d976e018294d3765a477eddae31b613f0efa6b1bb224ec0a48994ef5dd6bedac6b2e453b79f0b348e4599d8d0ad6aa43bcdef6b73962a4c476bb5e43e19293c9714d466fbce9bee85780f74f38f9eaae97c3633a665c7cb224b9e563a5957dc971c4b21809b2759a546032831a5d8fba01a639d9233bcc199582cc5fd1ef07903190439c15f51693d59b020fbee32a408acf84407d1f87221a47e5b47e8837d9c2bb5658dd95b4f402480a572ebe0e8678e9e7f0557c7503d7f3deea117d4e848cd9699d94f69410e5a8a9a55f0f619c4a4451a1fcfb01b867a413369eaf7bf6acbb8618c00056874cc2c07827778422f806da635f66114e0d3253348bb960d2d76ac7720e747dbf0cd47016343c1b3372acae18630aa485ca2986aa38219cb22eec099bdd4d372165d5568c1813b565b0c43c349aeb1c48b573a111a2bb90626fc679343412c87d7b5257720b7f8e8dbc0295cbe09afede88ee8b1fad17ea7167d2c4e215a48ba9866236c82ef5198782d2ea8e4bea58a8b14f04fa73e44ac559398f68712f3ab386332c7be0baf7af553c59d9e90621ff9db9b9cab1a755c2f9796aa253448e4309b093ef00cf00e5f8d8470fea64a5138a4349baf5862d417f429df0b9d82db8db4d76040512d954eb73f723b7216e8c64c4c8be9f15fa2ed3dcc4ed1d18168c6e08f50c24d51c340b31fc9c7a7b658bbfa5a86eb4b71f833ad6a985ddc1f2cbf1af25bd2cae73281fe6b99730fce2ed1db38a8fbae22239f1bc0c6fcac0cee0c91a54f256e02b2c2df31425f72fed0a2598263e679556d70b3716a0939e9d79cdd525bba1a77f83701b88615de2bc4cf0592824fe0105c2ecbc8c7a949dfaad11303de007a74e8b7f180aaa6a189dd0b0eafea1f3e21ac63706456f94b90abef8117475191ad88730636e705ea43ba4236ae3e87b7a29aa8d9bfe9b3ae288c312a0832d0b32d80a4d4b6d3d426919ece3b6e64852f22198734dc0aee74cf8b634688d07a950d4eb8f04eb29eba5464394d53d4bdd75b793549ff8235152d43c6cf2b260c0d9c32fa2a61f4adcb6882e1e3786f9f5d7beb8d9e880a9f470409c82885fe428f2f9b02afa354d5f3cbb993086e0596fae35d9a2934f00ffe516c1933e074c51e90ef86c05fa61e45be9c2162bed0a7d6f0bd457fd5e56d785917f8f9150e85184bc0d9a6c427ac14ab3c9b6b7ba4067cd11e32f789a615151515521348a8a7953d810dea5debf6a47649ccab62532353d40ad9b1a30c13d866bfd872fb1de1e631a8ec5d8f0daf845ca485d56b42482e8ba354b7867a9ade3c94122498b83eca2246d6a61682764766111ab0dc8e71b932b6fd9809e2eca0eb3971776be9a7364a4716f395dc4329b1c61eba4e387a070c8bf35e61d4cd1ad7946ff1e5aaababa7375b37e884379b5fe9c302fc324bc11e4641f2d7b46899e0b8923adf09e20998b2aaa6e8968d54553efea9d7123f80125e25bc0ebae2ccc4b5bf737b49880997edd4d532423046b9214f3c9e0595797b126180ff099a05836d852a3ff934fcd51471bfbe4557bfee1bb244cf9714af1bcbb57bee8b14e6942dee7765daf0c57aa8547c741ae3be697046b11bbbfabecea839eff4646e64126f564ed651748a412a4d6e63c2352da06516d014f8d22818228be4300eed4c7b17c1aa29597caca665c9ac5bae74264188eed43af8ff74b07262f6d7d7844a489499d739bb06b42b5ff98457833326e655c4151242eaf7db7a1735faa49ae0ddc6f3ee975326fd466c1819764782ac6d24ca3f1adc426ac74770fcacf9fad9468bc1ec32e094b3bba34c2b1cd794d79f58ba048de33d7dd2b24e2ce0e93824485eb671b5101c06271d220a1952aaab6d3ebb77500476453f73ecada0de3805fa3f2d7d15fbbe04120c339dbf5e6f455fdf1f1e80c8fb6a771aeed5f61d76d5ae48e7220b1e65b41f62ce0301119385648f96addd29e44240ac836853a03908f86066965b2ad2c472b732dd1a06e08d4d33d56ab471041fe75e30fa9c4959bf1985ed74c958e9167f514cd8a5ae6fcd65ef5d72c9d7cb2ec8f33027f0b43e757a4a4002c5e938857f8ca8b435bd72591dbdc0e15bab702da46613c7c3e10819f5218a88d603a2f015d6e56a95faf4839cf175eaec8e247f9031d1d02ac8963df737d74b8cdda6a3c84bf21443c2fcfa9988f5c32923a4744943628a4337c8f5da9babcf14b2809fdcf27aba546f608bbd234b43eafded2246f8019206da6e761e5aab10a2f6d149083b524b9b27efc832ee68a1d2ceae36230fe2b06df13647be6fa66bb9362dbc956069f08213c2c5edf3dc9db8c21407d3039a4d135f99dea54cf260ec92491342a2d39eba45e4ce9b5c87955a68362df69ad3e638d60b8c41ecaf134d930d21e355f9f491238d5eaefb1607c550a9b086adfbef0d74d71fa94a14cbe7a193c44a279e47420250693693c18b198d070a46150bcfa37ba0227c9f0a01d235df2c1d71f77ef428f132c6ed70fae0c6610e9d0d46e5df27ccf1e410563d58b9cd50e763acde69bb60b50cfc833709c3cf0c4a4004922e2168d0315323125f741219f6f3c8aeba28347e6ab76f98966fe16ff341e0c412c6b3f97b90f56f4be07f9420312a98edf6a5837857bae0c5523454309e1423c7bd64c4413e2bd3b9f89b9629a3f98e7e200eb66bee5f70c877c1452522f44dbc40c31a789bf8d95dc3e62f2c909a5186087944cbe6fbea33edf5b73fb4118644272995fd404720e074ea5184926239074b02ed53b43385979bd2db33b1edc545b302fc1cff7000185bd5082f80ad85d0df31e4727a650271de87f93370b14fdaf24587640cedc5e4a1d9a44d5d3277dbab71d2bffdd0beaa2fb87872a0e51809900ab7323c956a5f243d77266f783711624a1513ce9eebef0d1824149b98c19c9fc5fc3bd36cfb0d209c17668cc835de850a05b8885736f2dcdcd5b07b9e91351d72c1693f1af6c049a2d0d09e0afe33b094df6787d6125f17f00d4aad8b07c39e0bb72e9fec8abb3a423c62f899696b923963cd1067505a4a47bc1462b58b502114bcdfef085df814c02bcdee21b35e1b38a32f45a2c0be0d4c69010d127b1788b676acd64c11d824d29db319777a01c4b471c261d792a575a339c1129611e8de09b4e6315741f9530e58509d4bf5fad6b41fe01e0fc9fc0bcd2210691b4b4e9229698ab3d89e733a2e92be99476d75bcd86217c48794aedc6b35fbd36cb4de1acd1ba3c20c10f0a6b572d665ef13e4af84954cb90a134f7fe6659ddef2f0770a4ec81ab78448d038cccb95a0dcc3b39d934709d0db9cdcb895e0afffd6953f9ffb0fdc9c03554ffb9438781e65f86b7cbe0a77d1b902edefa5a566086cb98cfc62ea6aec18cc7f7fbd19ffea786054be9f4a3479e857821070e4d7951fafa33a9c5625ce65adf1447c62ce1a424051136b9bd7cd35f65e262d160dad38c7b3aa3e8614cc696458f3bd2a3e1d3f511af4d77e39d55cce3eeefb926e8bbfebe2d6fa5cc3d85717c097c86a6aacd45d50783f4378573fcfecf20002cd68eae436dc627f79df9c1b827946490e2c4463ef07ec626494d905b69819a14749cfdf2639245a86124d1ad7aaf0a91a0a4d997dad7b2262df91ff89014e543a0ea2a24043b2e661b96c12a4a8a69bf937b7f5f6e0d31893fcdfebfffc884dd0422e7d82d4579e8bd42bc350a18aa0924c3ec232b03b278c7d33c61d6dcbc640e55142662be98a6e55cfbd9b43340d0596fe1aa94e509ae626c1d135f31948fe66d886500b56a27cd434ed15902ab76fe574c072447c849d20e6fa5383eaf8be52a2b7047d05dc8c642f3f92f5e616267e2f97ca68d06569dd40a3624206ed441649b68c9e53e83cdc726ac5d9afc280b0b1b95ed86ae231ff09e5885ac34150125703e1bfff7913b7c1c3ada0b53dbe75cb0a660c439c482d83793f2e06ec5ad4b7ac3607025dddd8efd6ad13ff22782de4ade08a8bc117acc47541702203124d8aecf39f785786ebc92c1e4d6e9ace35e22611254a445c0ee94d85cfc555314c5193d17c12b1cc2010b60cc6971fb45b13fb7c073296e21d95e7404e31b901c44b5dd7704bf56739310caf1403d1ae5a1b73c3382f651b299e9e8cba16f4a150aa0126baf68f99d427789138949219c6cbb9fe0244ea579ba6694e43f78d236edbfd49ceb145eb5aa1c84a70b1a496438ee4911c94e023f867956c68901d3d80b1ab0c4cd8b4341d34af44c40a84f1a0506a735fa590c1f7826a69bbb1be5cea8efc8172bbe50ae52649ab5a1e5fdd22643b66cf72d01523699903a55d8ab8391f8cb4caac31c2d66ee477774bea58d3762ff0ca06b71c6c174e23636f95ed08bd38d92d3c7e4bae21277fb7ecc9eb261fd6135fd3a6571d1b3a0226187c33f0eeed9ee038f4ab3faffd2b51c9ec490a688f63a96cbc74042aa45d2222084f14b2c367eb0cc3007b2993b2233eac9555713a7635496035d9ba76542a3f180450ca5c1b47ae644119be862faa95ddd4408df757e59532cad45698bab74755028fba4fb7b26a06209f5929adfe0036ce26a702d9aef72392318c5dd0529ac142b8a91991f427f012888b70521a2ee9794a1504bc06a3351f7f25bd8b6f12bc93b20f23cd45c820b62fbdf425448efba430a5a6c7be4178e9778bc6679739b29f462c26ae704d8d54e16de712c70d47914b45284f41577731c01510b92f4cd47188e94bb316c5c1a8bb7518bf12eb71c17813cd4220ef4a29a5b769e0753927ef2614a1e7588fa1dd231f117b4ae807a1a01dd099dea36533bfee3089e143e28cd1162ba3c02a75465b44bb61cc6485850898c1896c1f3e4cfdd48af9bd9e06640247a517c66bc682348e6469e4ad5367738c541daa526234556ea1aa8a209b9da9cd4cbb9dcf6d1d5661c7b5691bb9dc468e1923604ec02db1ab630edb93c2e7c2d1b0d7381c4ca519f5f70f157e7e3552bb69333145ca6759eacdd3ab44dd3c0e937a68e02e4db7f0dcd3f461a5f395f70e987fe87ba0924a138b2ee4737228e79880b1d0684b1121d4fced13302c8c687ec96e580faaa90a1d54e13f1ce282fed6eac60b5cda0f4cc50beb220a416407dc41241cc2ba8f82dd479bd964776070641713020484220dab0664ce30175824f3f01c1f15f42362d2f866cabafdfb53bdae8747c054f96e528ff6e99bfd9e43b0ce6439a89c0d58463c0189c78546de859ddca6c0ef5e3aeab8c35aac0fc29d85c2be94f885456dfe240ad2b00d53b5a8f97fe939b5b68ed1027e79e4782dca72697c891c690369d07bcf920d3c0706f6560b451f92c801962aba92d18e66edaeba8029364b9a62779e7dd41abc3a4f638b17524f2c45767152b7af8f5887e53346e13369f1f309e05648915a19e44d80607bf7f86e8d988dd06fca0945b7d46210cddd60a91565b8658ce29bd3208106d886ce615ea52875767f013c6124eb961794fe63ea77deefb5ca9ce0bb7d5799050caa38047a9798c7bde4db96bcf136601a6d6cc09eb73b67b9f0f73a9328318d64120d6440d627a860c21d8b354eab4fefc4c4a2b1e62fcc8bad96efad59a15b76058943fc1132d09c063f5fc18a65150442726548e3485a3c59fd135548f402a973f26a71c99771df69abfc363f0483a2283b1d9bccea4a3d8a7782d4331ed5905ad17c42b9a0d4d7f65c80641293e04ec2423eb695a8161f1c3a50c6a644d4dee43fe5fffad85e33ccff6f3456ece1ca54d89af4b28cd9b6b50d4744b10df27ae6d2880c490da63fdfeb365a917469e33a0b67383b2468ee601c198eebe8aad76584898824c3b1e967911175cd98c8dbb8c48c7413a3f358b105f176b6a471faf27e003b92fe0a1f440e76c79d33f8d6fb4c11aa59507b4f8e5f0c6a8810dd76a9e9cfd0cbb34fc7c91b4b411ac63d6ade6b85679bf2d14bed88e42b3c0f5ed98a1e6689d5e292cf4ef1ceb932874a22d3ee309da1b042866dd14a48879e28b906dbdf16f22c7844dc742580a422ba78de294326426a84be5614e51f46f1b36d6429014f6572bd73deeea274375e3a3cd71ef684507c80e99e384d8cf1ccb24d8297329c26e8a0ec5b9d6186b2e8924ef05e08416debf8d42b51e2d20dba8f368eb288c91fe0dbe1a6044b98c1f5050203a68a1cbaccb6da8de4fc24419053200e811d073b19ba3436177dee56663e42b043510b75628791061739abbf2776e523c147899ff135a1e83fd3f3ad85520f02c9405c7c8202432e4ebcb0d057bf1161e5f54e20dbaf8857e7b885b6211c0b88d32d5c585ef1f7e455f586b9d9c78f69290e5b049777749e7fae24800533eb56304178e1f09975f308578228d02644f0b13034d440dc7a0671566dbe1564e6d1b2c7addfb2b3f684b82fe38fd6fb730d01e94f3d21eba5fc37c82258fab412db62fa8c64dde0016583f1ef9f1e6f0d067efc81335ae92ddb50ad144f8adbb27cf079db602a0791b6a6d1853e276aba31599028a37cd7f20ca872bc61a42fa12bb495f84c4dc25d2eb8929d6401417cba05826bdef81f4a9b84b6fe0979dddbd175b1bf38b4a7e80762fb638ee3788243e46290e76a8df092f82f5ba0cf2fcd58d0fd95af802ec88f150f4bafea9d40ccf2a19ca9a5f09f6daa3df857d7e702f97b16d7645f51776a64418a7852449b7d051c59ffc7b2786b89ec97cf9fb65d60071b79942b8869cf3e32ac53c85769e027eb75116693a480305a6f3ab45e709917944101d445801ba983ba323a580004f122df2f6b5e4921e189d0cd73443930af9b5a6bd69b2f5c66d0fdb6afcf8070084baa631be7fbf5e7e027bc58dfcb2819449bac9a21e141adb931121d492307511398456382cea77fa2507a2ff7ef0d0be707906f8e7bf8c4bbf7a9859045c7d138fc219b6a9e6871edc2846779383bbdcfefc50213fdd2ed4a6611a8ef2368cc6f4f2c00c5293fd25b4391f5c17a7b2faeaa36e11f5df74cca008f4022dadc4aa6ddeec8f00359b8b0c1c91c8f3c115ab11b4ee2a8247ec493b9b6326344ae77bbece53292b7019e22164eca765dbfb27b1e147abb6573af2dfffdab78352e048e33704424aa45ed91bb082a2bab6e7b8967ed74bee077a4e78c22cdf09f0ba60c35e0ae23c367d7ae8b9c6fb7c8bfb7e9030e2ac13283a7e1cb6b1a4a075c40a2fb3916294062294818e1dfb2e414f1ffcdecab0853c98215c33184be9481f70cf4a35d3e877467eeb341aab09253b1b37702988a1df5607c591e6d113c5de9ffc3ae733f80a741ced56c85733a9b3738a86a0a1a230bdb2ddc3d5ab7a107caa0b8974b915abbd58406f29cd42d42228e334cd7d2c22ca0cd445b973df5ffef80a21d337ba435618457686f636a2c60058c99390e1af715769bab5dde982d9dca2b04e6c4896601831555c4a9a5159299ce6a8fe173ac54c39a3defc32bb647ace2fe02b8a944b22db73220f38acd2732fdfcdf019b094e38958367bd34351740602b1d4702e16fc57b3b1a0d1093119e15081d90435d1f67e19a4c7e0b3a1fa40451cc19f3be1e0b113592f9a1c6a1f95ac6a6fae7e940e0c6082ac2ff70284accc335dead1bfcc83aec3981e8ed6fa3b21700c858daf82ace277d4db9ee9c58eb95c78ecd3e941b2b265ba515d258070c679b5e2ffc0380d6c2dfceaa15567a6cf1d9b5533e793503f142eb25d74f1fc532fc45fd586bda19a4d78e207611119572b668dd387e13de33b8736228a6e51a6640643e53d482c0efab5f5aa362fe407d38617476ccce2b606ab017614489c84a0f138e4c69113ac06f5c298b9dab6246a6f64302a0f0fd54f2ed3cbc833bd6929b94be45109ec8cf7965eb2e4c913ec9dde647c43b729411a5707ad9c4aa3c4066b3d30fee0a1a675082c3946c7037dd76f3db51643f52d028b1ef89950d17d5c60c0616a94277dc8187abdae2c4904c94dfd0a7c54831c1338943ca4a7dc87458604aa8dacaff11dc9b794d3d3aca42fa937f7b1c9ad35c04b07409d73a9d505a47d852fbe283bb9726d0467164b488ae8b1b181eabcdaeb40fdc1a2543004c4fc31de2cc7a24e53205b98ec9246f51ed750512a7678816f1345e17c4c7ed837473c73187df0b4ce8a5592dc8a8e4936d2db2520a3677e49832fc483837c34652d0d257483b565a8d374af85206ea2efee0ed55dfc3645db5de0d6ac18e7e65963f9752bbc37ebaba825d3021f609b5093b192f4125d3e0e6a03507b6cc3915c3d5096b271417e97131c3916857bb836ea9bf7ccab56f138d311e5433be691b2ecbfd35e3d3c51c0923ef9ddbadfeb0b97f1a9491f99beab8bada0f59f9a6b5dd9387b6778066b9256d0943a2f76187fbba42209cdd8f26ec0e906d29251fbb66ceeecaaa36141128661a9b7f43c7d02055d66e53036ddf05348dbbff7c16c106f43d100ebba8a48cf8537a8b1eafdc2afe77cfb11e0024cc6d1842b3748cae4de6a20c4a2cc71b2cd8074de785c5eb6c8d761112e99e44bb3534e4bbdf8beb3bbe3827a794ba3db13769d2047b6e12e12c7cd107d68060ff7fa463396e8c7d1e18afe6ba5a273868984131dab23b3ecb0e2b97fb722b1d1ec0f6620b2c6a80b194097ef8869b80bd4dc331869905512bd2fcea3dfd6aa00fbb360f0a4e0eb7ee01e6c0229975e833cd05dbf093bbbdd824251678301124489","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
