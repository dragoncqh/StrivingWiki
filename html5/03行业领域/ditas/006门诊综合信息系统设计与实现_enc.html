<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2220c589cf8755fe89dd2dd9634ad7be957c156b1fce02b1d36e879dc4708e4d8c4ba95e14746ae5512991ff2f99edf242f5eb63b1acf19149eb76c7fd257dd3d87dcb9c4683e69fa2d08ddce8176fb129e74735b2e457357bba9f4b04f4c284811efcabecb2b52c4df34f5e1db63239ec5c868bbcf522544b6057c089ef919cc73094ab79918efebb1043cfa1b1541ad518ffdc681e2cbea28b9cb1943ae23be0aa961d11442f186bd5818f903bb222f67b0dd93d4cfb2da83aff7739f3fc9a533de33987f623e8482303956402d9121d7f83a9683d2123e34ba2b0261ed1a5516223339d89d9ab26530c6a415ce85e78b92c2c6f67283706ad32729fc08b5f7d5b74208467e9108e1e179d2f9f235160bca6ad9223c2f9e9978690f1389927a03c22a657719c199c80b5235bfc4b67e1cc37ec162a13838c173c7c43bd7eb9fc285d47ba27083e919ce5325581c638f7c482fcee048ac9ed9fd3067f77fdff285bf17679bca32339362dd31ce4286264661d535b978495c1c498a4e2bba6885100206b129e9034c53dba4208790089dc17a34803575f829169f80c0f138855cb8c7d165a1fe6fa0182d5e8a1a69638befcb9548d48d8cbc1f47894201aa0bb2df9c387a2f99bab51e2f49ff6f9b9ecd2dd7bf7dfc7cc3bacdea1a46a095dafcb3119bcfcec60add49d52e35f97226525a4cebc38ae6b60cc1f6f255e3f8ed1af1c11e0e86d2fdda87aec95767623a1b89fd68cc0bd5ca6cab134e922eb60f4d533e23fffb64f41e059032447982a586369f9b3d30b7fc01ab75c761e26c7f14f83815880644f0fce46573eebdc028c44165b5c6d71e9a5f0fe0d7ae810cb9b03a0d25e426ff84cbeab1a81e9b585e55cb18e7d724f4c199fadc90ca1e336b823118f83113edcccd7e1b3b2684e2a4414e353892d349a2b67d2348aedceaa9b653634cc5d069801ee4515b5263b8d5abe47e3e28e5252af77fe36b53a1de1acc19c6150e14ecc2dc4f548a35ef9b895711d617dd39e3e9aa596988bc80e9942bbf332eb028c6e34d907896f0e1eed0870124aaf2fe09d991fb3327bbd21a634d8091509f25f9ce311b0aec34912c236166be3c4de8eade89489c355a440b1d51a2a909aa02ee53a37cb7025c03c5bb5f43f5a7b0e36748558f22a26014f4b6f94acf6f1f33922f894a7cebba759c7a9e56022a99ad72cd54ca670bdfe6506837e607aeaf17bda7eddff9e21d3759c0eeba654798722ab2f768c016b53c5aff50b0ed0cf766b347d2243d6ea359c3bcb82747119ea88f348d9a3941050d75f29623dce903404c8bc996ba6b0f118b4ea8fceb02674846623041fcd89c5d44ea42d1fdcec70fbf9284b200bbe7f79aca8c1a9e93c298725c697798d8cfecc2342d508b3428c4b4171b40b3980ff4274aad65bc386d0dac3a82105874fa9692bfb0d969f48ce00e1311356c02b9ff8f3265c0f266d8013bb19a647784812d0dfd8d85b5f5da59fa8ab3d370745597421b28e7d73e95e1fa38c87f70cf75faa792f980158d5141cd7b07e7efe1bb1f27eaf9e5fcb3de19f5b1978aaeb65f780fc8a98cdec93ab2a6a6643b9e7b6e2500a2a3577e7b8b6fccdb51223a1aca79b51ee0256c9d578e8065a200df0cc655edd108a65e364a240344080e771293777336d0dd855ab577789d8f71ff7c8b2eb0c82dabb9e54275036ddc65c8213031778abe9bd43cbf3b7a673093c6a283538c18c5d7ec33e2a2360d7a91435a8b7bf2ccfb39a02249a4806565a75aa99419430af3b6e09e238e9a155c6d6164f13cff55389bbcc3a15ba4e45ac43289325fe108970f2f888ae881e2f4bd94e7e64b1752c0c5522dffeed2e1248cf0b384e8a066770b876481e3ac7674a96c682339742cef536db5400b0f99c377687ba950505ae38e871030c90a7f20aa75ec1d5c21fa1f95bb0314e7847dc5d9ef6187c7d1996386d0cad856309371934a3b2976a9da83b256ba82193db4628194fd9908b052c86dda713d79e62c8775b4da69ee6cdbd9a3256f6bb41a890508a29706918947c1948933df8e17b0589036adbb4f6efe74d3eed834cfe7c8f17cadc811a6eaada692934a26263701c84dae027e6238ac0258301acc02ab1cfa20906cc2f6ce3522e78ee98db8204f2bb6b9ee791b3d01ca99cc4ef9b22ecda6a7821e166cfd663b932d39b7224dbec69f78775c621e55d795107f0557390fba0aeb2d178d08dc5e91f2026669e5bc03e9d2c0c8ca462a82c5439f1cb9fba154547d2daed9a719cb6bd36d498ff26a3ab7d9831f41105374f4eec544c8f55f03b9962decd1695d9a41e258f99b931acee1c1ba333c40e2d69db68e63d4a058f088bcf035dc010c10f7f671ae4e7b4c9e536dad4b4b374cf2546b5a5ba54518229b52bfe812a05e6d0a65f97a5abdff013ea690c656b0b818679766736b32f0c312df95af75db78c7f135e4ed956aef68ca55d02e6f3488e1ccfea14d175a07c6afbf81b6e25c67ed9e5911f58fe943255891c08c11a021b57b2f351a64d38e0c1bc8d25622e92ae4e5feeeffeb1f77bd9cab8c6b64641ee0ce61a2c211f408e574cbcce0b5ba6681b060f0a28a1613d4b2d5e11149d2ce8c73b1661a31c9b7c412fb118349b6f43271588b0d4eda6bdd9c94ee8fb2a0900425a4ae2572fd52f44b776b44da27bfc9f9ec0a8e5195ec0b03fbf9059707783d6801c7c706e9680119ed32c23898bceec408157681743ff27edefd967ae69165da23c4a68ff5242e3db149c42bf40104c370e7c0d3e8f209f87278bc78c23c3f3b890a0da0ceddf43e85198513cba9f266137da6059193db2223cee690d02d8e24a42d12b810672440a9d2dc007feed9e460c7a0bb425c6712093be7dbea8ca352cccbbc0542d69fd1cde9803a8a41cd4e943cb168f90220205c888b6b4c510e8252ab0660d8a76bd92b6fea5c3db52ebf48da9b18ab1207ebe2d3d2846cfca57db34f60a36eb06214828299c844f6b2f675225222f8442719cdcaaaa65621cbd36d143023cc2a0014aeda1f380d6ca2a786a29ac6f22bf1ae23a4e155ba80f4b64c50e78f64b887341b0449acde993e67bc4fbb95431ac451c803bbd062445924cc2a53121e6f4fad3b5fca285cb6d99c8328a5fc21d6a8747cfd2ea7d6affa16b5d333c379db1a3c130e62a2d5c28b008ffd08233a96899c547bf93f7b1dd18ec5b9ba2808302534c8d6d3f1f5842917e6ef3b1ae82bab4837bab315742d686e7f4bcf3e875ff63a35cbda188bfe15f834eab09dc351440f9f7602378c7717bba4768c3dae339e82c8abbcab5d6deaeefcd2bb22abbc0832f9423e0eb6bd3de09f959ff2e7bebc2520a3d7f04144a13f4203c3b9590ae999306e3e3546eee147122bfc9195215832c78f16532b854af7b0484159b31cf9033a75dd537dbf129538c837cb2fdf2f29e7cafc8ce1df89b6df9158411f4b58d30e5b0a88676551c8c490a1d907416d573b97135195721fcc0d295e1a0450f959595190c758be01269ae1ec8b5e49b3697c9e645e50d9d83d5c82c056fd7e57733abdd36ae7adefa3bed2fe1516d4d641419c26d0b19da0f305496b855088743844310b5c19eb124d9ac12893a58897ffbc0296429fa5ca2f9dc368bc7b422ebe7842969f657ec3bc0652caeeac4ac08df639a8643a8a306c9a12827151c65aaa89dc34f2c576ef65378a458c15d2a264162c1b4644d52db0d00b9b3166c2aeb40502f9fc3d35444c80deeb688c6fcc043bc747b28034d853626aabee0cb049ab69d086ec800fc8373e0d1a1e2fe939a86cb2c9dada494b4a450831d2c4e9f442649ab5e579f2753261275bedaddcce665ce7d0478d9a4c6a6f7ae5fbc2fef6aff36b96a0c71ee545f8112e203b8b2259dd2cdbe9488e92f235df82fee7eafb4e7f0f9d8162886547813b2f193e8ea6ebdc89a2a0a5a6e468d9658a04a349c0600d07b9601103f909c9adec1941529040b74da08b5727e4c8d4a77d7c7b3c6f51f84c7a5ab498a0b59ecc3b2cb0b53f293c528b08ac73efb768278f2c8d645537fb5f142541e291a07dfa8c4aae8f071fe496b05755b1e77f2b88051fc6d5bfe6984bbbea058d8cf01a13cbf20d1262b1a4d536af103961f4b83ed46e18a94ea423757a249b88e552375aed9be1ac5d1782dc10d7dc582a10ff4b5ecbf7b726c5b7f8f31f93bb65ed9ef6bada86fd2bbe611a206e4a6f8e5d8edfc9414d109262816b624c3714424b988c86f752b0b354d5fdc0088a5a73e0d8aa7f3c2d8b4a11ea19d44e01780f54c37982c98c7b4d9737ef480d284d4e9897baa7d57d0b8fe03e9fe62a9c5560d5d490b872747f1848910421d34144aa3bfb0b86a7bed9e4307c3fa526cf15890db83791be57d2d95ee149ded59a07139bafb2640ac9e4229b817b75a3d8b654aa22349d8eaecf9606a142c237196639d3ced65fcd84628503a6427cc19dad98431dc2bac4baddaf8d22182e42528be228742960dc3589ee48f9cd197a8fed0523edc0bc1cc39443d5a1b7eb3252457d749c1e4f46001aae2c25beb410aae6ad8d7d31462f5df11b38d4bcd198a367a7993c7e36c4499c1c5e8d5fb457d854996696f4356ca5793063804c8c2532e6ae5fbd50744f275f91c6119576830b30c5c6810fa21f373328578ce042254df37f98d58d893055152da29a31c6c6851601282afd5110b9ad43212b4fa3716bba37bf42212c564e98298c54a70f925d10fdc6d4d1289d81a522192eb7223b1f7ca770d3b573c5dda6a2e050fd87f2cf92563c8a80427880175dd160c374bd8a3f4ec375301d6747d4d01c49495715708eb82b31f6917d8fd8d27bef7bd7a8ad9d293cea215e22acfd2319777f3cd7c4a7b6130847bb656c4989ee5b520ce96267981b6f82d82c92d01360a01ac1b4a2519662f77228aab4f66020e39fe08e36351c0cb18706add57c76dde94b8e1d240beda8ee6bac20681ababcd4a92d5501f1b9fc4a85ddbf0d3d87ec4d410e5f5d0cb81629318737205b9e7738e79424215a83ffcf808b3d2960fff8b74d117763ffc42c4428fa9c0cd8bd9987074d9522060c9019340b92ba1c9ef7485021b82d7b38aeeaf30d1d58f1d56fa24d2d67a27945dc7bd61777c196217a14968682dd240fa436bfb3481652232e2f4485046e76456e1597739854432d7e21429bed055861f3e6ae5651f20bd19b5ca75f0b3d1df5898092769bde1ab8e13bb6bcea3c7a347770a4c19adbc47089d4de4b5f108a9c945cf54e82c8ec0d40583bbcd19ac76133768a406cb532cc5f5085a0b55e0906149d59638f92f4e0b14ea22ff4abdeddf1e7b276de1a342426711e32a6557f59aec797868ef3c092913bc3b8c6ad64731793a60f0b7f563b13953b78fff7858cc4baaa5eb03d7f4b380a7b55a6847d4a4d3220686e974b9c185865c15265bcb0b2c0c6c1f101eaec0cb13a63d6d088f83d5841dfaaf1a7c503547e6bb40758daf4f45fdb654406c7f3ef1f04bb5dd78645bfaf8cd6c3387e41cb89796d9ae8bd96232240f4a25d35a6a7f0b7ecbee73560edcbd4831c939097869e5464f1d04e21106e995d43e260fa95597148107e11e6c1694b5e6d7c23d28e77f44ea8111c1bcc11fd206414ee0b40daa08c36812f25acc778e12d0b8abde9b0a6164f292cebc022e905630a25a2fa542fb1410d58c5d6a852389d2bfb87453f415e80f6199aadffbcc44a9a197a88e4d241f4e200b0aaf30a86aef76930d02edc8ea26d355bceb2f77e21adca5f8ad465f9cb3bf449f210059648a32078dd49e2260a4c25762b94d224e3e5e8e7ec6f5310cf209fb2c82b115a5cb105e33123620fb62a934a891a229ad67927f2bbb094eadb3fd4b32d1b38c47cee78b94d84458484f3047b23b4720b761f038fe1a079dabd477132866828e8c6b6b2725f83a566c03b1da42b4bda10b06e0ef7d8a6b9ab7bcd562bd200c8a971a6802dcc87f2dc797be5f5c17a92c42128bbf12b386e04e025de1a55b63cda6d5685d906b70bfd0d4c4150c80825b0a7e423bcd3cca866b73f57b3e2e716e6f2bdcfd06bfe448e78373cf05c5d56b136d07f1de28743efda342da3f12886b626c9d6254cf31ba9c69323434d4976bcad4e853627b7b745c374c40462f5714a2ba0d45b0b0a5593cbb4c3ef3b669c81e64be45dbc69bd06b6d0af7e761bc449c501deb46165dfd81f16c4df19fd63d5fef9d175c89a9f81d30cb731233e4a0708fa933d3272a704b8312713208e1a7c989472c646d68a23a0ca4aa5a054f86ad1915eebb037dfc1d14ca90574e0b7dfa46f66bf8f280a4d2bc06723181a074d779610695b379705a7c55097d3ba4d63cd469109c35a02e74b7893daef60fffbe7d418fa4cc10c117868ef03b3de97116d31a4ec7432a953f6aa83f590ae92c641f9f14e77748cc7977664c538d9b0a6aaa83bd4d92359ec926fbfb6b85b5c6ff02c7fc16fc6525319a238f2f093bb5b181648a46277cda52a59cedfd2cc9504e8fedaf5652092f000b584d36f101fefdeebe527597bcc72d157bf1ee688ee2d0168b314daf5aba9262a094aa62b1be8760d58f27dba61284880a817363477ecc31a6de05a82f6f1042d9d8471cc41f78a7c2c2fc2b53e29cefca3b83467147f7307b6bc44e1eb0fc8c3c62cba84b14810fc8c6d78dd10fe95023011e645e0144fb67d6e1048fde88c9f488ed993bf0c373ad50fe4a00cb9de91b55207a4519dcdba8ea915e914152c0626343c378250d4dacc3abf6f1d55807415f7452d5af171c984ed39cb9f944e6c5432837363494297a6007a451431855b7c6e885d4a42de5553fe11966cf2f4ed833d423afd21bb27ad2245f3cd94a061695bfd3841abcafbf54138c89398149d1deeb0cc3bd2569fc8b1cb878af023e2cbf77b4daa1c1d0cff30779e6bb5e14e830f67057f4c6866928ddb36f4e5ff8c4cc35d2557c3b9ba11cf763c8c3b03fcc1fe3a490f6e77c173c18b11cc270a2fd19f74889f6dd94da2ee8e40f0e783c6fe43db8445ca69f29671bf8c723985504736917715bd17a2616b7d37a6d5b1d5355d57482a7576fe423e20b53da64cacd85558c924ee67f12f7620655f7331ba276773ed51c7ab3b70de660852d5c514846b77f6c96f078f31295fddbfa609ed7109ba8bd7253ec0f31fff5c215167d5ad646546dca3f5892bcd6a9016b6c50a5b4bda39a9b0fb003b43d67a367ed417cc70a2fffa6ac0a426ba42c9e79366faafdeb546be5780477e80aa7180869bb2b93c17da141c9268384a40e03ba7a5bf8ab88569ac51be777043b1d235463af1b690b0a2b4c0f94bde3ffe9a2d13d5b9cef100f8b8a4a78904b52e5640f7e2e32da87836f6c84d9dbcd0d1e6c0e92ddbc205c2c8b85fd54201790a57e87ecf89c9d3bb6cfbafe2cb0a2c0e12d52fab8fce3f27dea081db81d78ff6b6f11aa3c56a70cf01d1e31fa5d71eccefe386949b7a4d5fcf1fb0a1153a2b9cabe637e04117e1934a7998a00c0ef11123f38b662edc005f7572b2c16408fed065fe6bdc151e582514d04dcea5cfd295c30c686d6532dece25d1683471aa8591edef440ef900a0cba1bdc0052466e580df7771690eae66d25bb1cc22182c0b773a968792ba290157333c49874047362bfb2d257c1462a7893374724885498d11f58033fdb029aea0ea0099181a71ee58a9c0773e081df09823a78379c7434672819032bb74c748659c31da0a1f0483fc31450f53b5d1b672943e2b47d7178be0ff66b3841235ad89027f3cdb75abe6bbd295959ee092583a59bed71a774d76a5ae69fbd4117a6efd4e601d61d7a8d149df2458f7837a17db97ff23db257be63b8bdd3f6da1ab61db142d5bb7ba6047837179e7be6a3ce2506fb625b230da14e87142893b848029f6f9d7cfa8c860a4366390ba6d42b540e244056240159e75441256f19766b086cb53dec6a16920d7182d73b8950f7a89844c789b2bd0c2348336a8ab3fd7ca4acc8c048b79a3ebbee7131d55cb3c0ea42dad27efb31867e7bf8a7c19a1eccdb3f47ff4c1862c075e01b3e4d42e40d957c07f2a3480de31f02a024cf9fb13ee45ecfb61751cd2976c20d6a2ffa4d3ee71cf286d091d8c227bd78e33403e45b1dc27653385d5c6908dc0275172a2a33c1a33feaa83e983c89c48d74ccca4504664e187a9744881dc9d15d8e576cc43d1371eb7a8d96b56c29608784c09db39c2791abfe902a5dd1b59f46315ce5adbdd9841ef9c6402d2aa4ae88317bb02592d28a0d20bca0e4c4528c3c96b070c50fd08450b5cacf73d7aa353e5d6c0a0a8f782ad4b7addac03b8601fbc03e342ad609fc9028b1a3046cd414036a9e9dc3eb9260d2021743e4c0c769d3b75393b195ea746ebec3bfdde4f248843f59c5b9f8beca4d47f6d6cea541655fc90ca452bd22d058a583ef58474d215e326ce11ed818786ab79aaca4d1408de07026b2507d610cc7222381802da908f2c39abbf50bd2594abccf09879780ae8f73c82c5a8478f4c126d7af20d262e60c7793b2130791ba2237a5760baaa1c10b64397a756be4054e843df1135e2e895e68c084d946fd9e13fdbb975d65f5f48298f257dcf96a2f6aa77f6dd7b905acf2dd3063057f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
