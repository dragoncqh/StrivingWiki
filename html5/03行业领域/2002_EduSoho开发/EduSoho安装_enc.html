<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6184e069d150d02721ee651144a3c6d9c3b59d9a7984518b5690547cb31f1b00a9d3d5515c6746a942cd7b546c65dbfa9f0f57e39e10b44aa12b58849601742bd8498a7c5b5b539d3d053ac2857e23214ae35a6c38bec52b33255cdc042f65f3049e3fa29cde1ee463b1bfb9ee7c34b81c4646e748f290d05c2c4921310082e1ee3ca0e5895d372f590fd1d88287ae2ac4e309c3253ed53e31ae3f8a9872858c4927e69fe912cdec15677989b1a5c7420ad1c6d454b1e57592e846ae4836142946265951e2843ab53987eb000e38761a9fd6bb49773de26bbbee3372f29b821af1aa2ec07a0667c4c9b6eca0792fb43f69df7196399d774129b7adb86e100667bd6f0033b3a10b9502f18b7876bc4158da905642b99b9b3ed1a302c0df8577899ea5ca284088c8820279e6f5c53372404d81ba07e65af6c069cfed93daccaf0eba2dd2c7213c78f46df1dbd5f8a15e4641d00190cc56b615a8d3b336de578a24093beec2a38b31205f9a124862648dfc2c60d8c9e322a43296258b83eb724ad4a58d7082021bc7a4bbfefcdbe5a65144ad4c9b5b5e1f71f83ae23ff10a0f9cdb38d923fe50c336ece7e18b4be9a3139317c651b6cf4b81c7bc0008357a10cbb029b19881aea08224f3c593dcd677d31f2a7acd27f2c5a8fb12074b165ba149a3f4a801150f8a14f8f4a32dd448f20205dbd98de2175df48ff5ff93dd6a5a33ec6720301f7c14c130f92f41af9750d71a887909c9e934ef8203f6ce16f0f50ed7db5d6471f7dd86b2acca9dfe1bcf0dde21e532cb1c1c3413b315fc71368b0cf71fb45502f66489ca2a1198f4ac8e41ae7947ec91090c3afc7e2123f06d0cf5b36dc0ad09a87beb1d5067bd5f70664269b3fb62bccecc0d8e76efcd1010d610475d4686e3a47b6e60f2686e4cc598a14e420a8d41fbe14b45c7f72189a9c096d9fab44daf905b42494350c8c101f8e508d86deb2708c90764182e8189ec7f06a9c3804dc05158411c2c66f53e0aa64aa629631ac64f1df86148ddc74a1a3bdb904639e99d74ce32e0418981eb3bbba75864b406a55d849f1ec6d6ccd83ac7d3680408839226c946d9727d9bc5c1cdb0c852d6f39d7e2acb9956cd2cce5438390feb281433617a1e929d6ca74c583e440cea03713546bf427f2ae319895a441970a65e2ca3b8e47c35f399aa1d01241395bd3236cc05ab9cbd203b7c5d8ea497113cee8d83ebdda89345ec6f1cfcbccccb126697df0504f127b6fdf294317970d5c4f309f57872e19d4c2e06d2522f07105b0be72eab02e726f33b040fffd2320706de70d48194b5cad4db759fc1ce7482ac236392284fd3f00d6a5944c9ee9301018937e5744fe7643e266ca8928913215a05d48fdc190224a27c7094738996330bc3dd98587e3b6a39cc1014257006e27f7b5a8cf4669a8689ec471c786706bdcec7b9e2f83147ed242f17e705f2dd45bfcab4238b793469d3d1939bd0cb665bb4c3b3e21cc23844c7086857641d00911f5d71bb1d632b2f6c4b2223c56c3b82162393d451d1ad8520e56b75dc939a3daede7bfaf0b7584367a4b51303ac1a65adcb52263589b9bd7effec6fed7900e075e9174bab33bc085068cb2d95bcac42915be0476a2bb7256f58d804e3b958c6cd30f02ab8f880803e8bf64018ee489391877667c4e0335be36161c3cd0e47677f8ead983b8a9fe7add296fdf18c2979c09325cdde5d9f272b93352c251646d67d845077c2bab8dd82bf823bb191e3f028e7fd02b3ce3953091bcbaff7c48e66aab632f925fe6f2bc29d8e49c176df329ba1c3cf9b2d2d2dc539ff2700273da6435fb75becba0f70146c0d38ba981f668e2ed6715b7ab6f68e74d2e9cb39fce14ffcf2f6a73bf5b2ec7070012d496a62d2b0f981794f3924ac8b144576452e7dc6e3d9acc084d4f624587924b34d2bf3e1fa71f15c47856eb998b33648747a3a4134d32a8434aecaf4c00f8c7a3510a7fe9c013d2def9a24ea4e411a7604ce66c8fc53c752b25adbfd68e0bccc351cd190fef55ba6bb43a3195aab2b61c6c4a8fcdd26d170ed59692a02b19bb1812f7c3193cdc582c35460ab812897b3decfa289558a6b2b6e91a0a2440a335c02cd373f02ed1ec55f6bcc4bad890ef112b50cbf5f2fd548885739d9f49151d72485a00e59bb08ed205c28c39505116f1b19c51f55286abe7ca38b5aec74f42de54e09706a19efe1471be26e8259aed9b4edcb17be1fb6a85d335b1269ee1684f4dc10a79d349e69e4590d523cf3a4a70722b9bcd96ef29b7f2d089c16a314d8a3e534aa872f4faa3b1687cfb629031d78dc110db918d12f65a56d505ddde164953ab91fc28961f2f74b668158a305f8494d9d668d40cb49d283483f78ee4d0041e3ebe98a5ccb368c90a8198c42ad0b80e67215338dd2dc55623b96961c37dfcecbc0d4636fbbd2b4ff7b5bcc0b8c22c332a6949c654f2b4003590bcf41a1af6dc1aeefec9b95e88f977c8a35d62f91a2502d622d6626de74ddd21ca211610f75cf5d3f7a48cdddb8198236ee987e84b699772037ef493d0bbcd0bc7d2010ef1eb88bd5231b021b36ff4929c496f213069221f48bbdcb6726c4e247500557d865782d4d42183584f7d76206c622b35f9ad7ab306efa3196dddaee1c16971f3b3ba66a025f467d649fc143d12e7d19199bbb7a9570ff61fd84ae6f8a366c558c196125fbd4b3aff327692b1b7b8f37c330c2b8a518c3cbd06d09f94aef8d298a586d2f0229f06dd01257defafbaaff09ad7151c0f96eaab358f8bc6fdeb1ca2c74d2eec99dac9b6b5e29b134aa3f6c5b6bfdd2aa09817935306555ed0c547b46f239eb303d31229af4fd580675276553414542838196c2da090dbaf8e4bc4bf1530ebe435538e88149c6c1e929458b68e380e23248a8b04fc0347496d5e42d7f98e1f4d11a5e811b5b7804992ff4d108625b4aae0fce09679160fe3af27292929d491f32a404335c07cd5d4035708a643a0da1e51a985515b6e226f8ae113a1b062e43df0755e9f646b522ffc864c3dd969b83e75987d2942d2cc2b0c4532e9ccf001b858d7e3408f6b000ece70830240c299eb8b0010be9d5288ce613feb41becea9a6e91f23ddb122ba55b70a0260c3d51679ae68129c5ed6de98828d49130652a7afcb637531a6301445d5b08ee6ed067fc9e26abe9c2cd8751b347b95860239bdc088c60bed662cd73c43386803de45e8fddc97d1f6c84cd71f1a31115d1b84e5d4cce3c4b5ccfff71fb0dff080b59e8ad6db617694996d4088e85d28faaa2c017d544b08fc8f0e58f0d8081ede559541f481e3588105641803f562628e3539f90d28af3580399c97640f8dd3db7b0e15f576d0a313483dcb4bdb6a861fd7803894429dc677bab8b590859bbfcad1c23a9f5dc65f53a324f0ec4956d3925cf4cfa4a127c85a4eec29678e689206d606f1dd7a195d615ebd32ec7f85a9e65be52addeb4159b5f1eeb12f6c037d735d4b8a5c3f409309e0d5fdbc0f9756c882f63959d08813b28a72a478c3b65114ffbeb34f4ebf056155872128658b490628a4765832fd45bc61211ca4b697e6e8fff69ec62dae4cdd76272be6daaf32727688e34d9275dea5cc2f8387c90d69a29d385e50bed6e46f62fb373728ec892938801760de10aa1551d2ecb1082b1416afa0e2a1c61998f37d63e1c3b9650d5b2d251b66b8ff62fc5d71893602afc7324760d0a89a3819128242efb39ac4342d8cf35a27c8e5875dec594c41f9b571d874e2078f72cad9cf76242619516146ce2b1c19374a7127c53fccdf972093cc660c9323d9c275e2d9ba350d7989f8f50db84e70cc45f103efd969fe060084dfc06022c086fdd0e8ed0acac28f5de8ae23bcdc729b3855b8e25cfdc43ed48ce0ffca487adc37edb774d13d294e815b56ce5052cfae1a5f0aaf919399a7dc8d5c2e22c6dc0014c67c98008b995c63f51187bbd94ab1d47d9cd036f18e3c601b3725dc832a97e8bdc91a2c70397ccaa8bba483de7b41b2241dffc3e3eb5e7709102fda502ed4fe3bbb10bb7f450c04bbb4e366ad19ff082011d96fb8758408052f0d6263309e60dda8513f41b6a6c2f97fb571a0d0009ff3d1ea7a212f1ef08571b402c5f23bd8384acbba9f2004a54263653fc2cdad741d4f9348275d6dcbc7ded6ab8ac0af8c7e81bb25379e34e59d2e540ac7bafc721dc9fcf042bb2b97abac8b92dbcf1821c9dccad7536f3649a73ed7ded9f2aca7b02b153a0ef8d363f914e631e795b6d6f7c3bdd7ad15927aa8b886b2ae30d7529f99e3762a5d92d0fe1edf462eaaf749c72900c85a8721da9ca48f7cc2358a555b02dc017a290ae8266d4de90fe43a9c843666f0404196f7aee23ed1f7416081c97afc9401b4a1e7fe2ede7d5840d41735ea4f2cfc0ecc90d9fe4ecb05d1b7886a950a9af49943d40724a0911dccaa33430256e811e0e869a7d63b3f4bd2b7e54dcf17f1c4e25f08122c373925c548ee0538562f2ad6194f6acc2879525918bbd74a7cf581ada16d3a7f401997722ef9e6cbc3173fb723138a988375852c345f390eea48838a6bc6a2b445778ff418d7ce6cba971f650c45e33f26301146b354a12f0fb6f4f95e9ade48a38449182de4be23427c9a756c74f378dde3a430bd3e4d16ff46a1969b80d8f625c6963dabd516f51ea80ee99f93314d012f4572a81c04e8b75f01d46c7e3d085ba17a954bd1d6786ed5d350c2862a6b2fecb7ed32c09e7aa6a3b6db9e9a1192267998fe4e56b64d2dddd0a5a9879984d0ed198db678cb5225cf111a1fb233e35c38002ea7098b7f0421e50f9bf67a76af73702b8d7b14026f649c784a3765c67ab06128467b8080a6ab68999bbd78187c36834bfa4ff188b609c1b0ce3da19017feb2416caf0015e8f0a6d5d18c59f055efd2c2619f51d5195c09971a2b59126c21a34405b92552b146a648300a7b96e358fe596933470be327986a26cc787051e779fcf98595bcdde5e8a72f2dd2cf2cf03ad563ec395e5497ebb22da7e517bf0c298921d4577367d9654b29f6bf0fd6a40444e2c2e0e376177ccc8f9214bbab0539e5b09571276140960024b064801fb85af5051d09137d11d35f99621f0929fe81be60521eb3589849d1456ae76c4c2cb7bb620b18eda4a78b761c9a84916adf15b598be50dc85554e4b10977bfde2312a4c28627e17ede609a7716518479bcd73b5be2bd838af50759ffa1d5b6224bdaa609e284303ed50f80928246ab3eaa4ee6254ba68f5a67fcda19e3b39dda7992411f45ab3bb19a49993779b40626c072d9d6929b0e101a9f68ed7ba2e6def00a6923c3d4d25e382bf8b500283ad0ff95aef9bdb9c8204116b760c1a4690dabd0156361237dbed25a7f09fd9679803bae27b2cf60325f6e96b935bc77e3a082de90451b45deb4d8ab641804398b4016ad2aae49ea5f79d60dfccb1c4f6620158a41c3f8973b394f3cfef7020a5d619dd25fa50e80dbfffa30ef73af1d8b37b9568bda23e376f78a3a7f3eed39e1580624bb7b261ab3f6464bc5a7934bd93ad1dac8893335a9a02de604f0f7211e690568986a019e1ef970797180e026965d631961a05facea179bca479b90e734cdc6d48dbdc2bbdb909df82f6204b5f734ec0036f3170388fde8ebb900fd4264bd08e15c391a4e334063d1532f44bc6ebd916248bb180e8a88d91bc39ae9f6f403a3dac4d43d52e91831fb8bbaa815a04ba8fe006e5bd7a37fd9ca0bdbc3ac83a186f2340f8348bcdeabcb525029b75d9aa68854aa9d407e12451c88292c08469486b76c4d11085c2c8f90c3593e52296476db2c0ffec66af8138a8f66cba10a42200887d5284979566b80922deb870981b873d2c7fee8bc4597e47e0b80fa148b9154d9a71a710bd6afd39e5ab69bd9fc2905da4a785b1ae316347424539af039175c528109a500d55f923cdb9dc73a5b50b4286870ba50e2a2b77155ed2207ecbccfa3475b70337e0e616bcd0a4eaaea4bc5d05efb683b8826c3eee80f1f4306f94a069c98d9ebc2776d1c4254d9c2cfd97b8c6ecd146c690f6fd55824a085597a3f277a1df1fc415324e5b3fb4ab0f2810ec638fcaa44303ef0e8031f160412896d01220e19aa9146d21790a012bda70a0bf0c1c5c25030e44195bf8b664e83f99c21b31e64fc93350fa0f68223f81e171f48c7a50e4097aff40df1d1a2c0d318be9feae0229baa8e1b9c17d47f00606ca6a7eae3070f1258c1b94d558db5cb87054700cafb86d9ee97a8320d04a5d5a8a2c4f4e57a949872c2940c7a70dfa6c5bae0e0bcfd5612e3035eb3d4776f25ccaf39dc843b997bf1bfe8ea8cccd96bd7b154d448d97ee4a063511b65f7efcd032a20a103273ee8712576705e965c8bf0efa7dcb6c1935479109f7d4fb3322c8c1ee7724c0862c957a7cca9fbf2c63b33d45a52e8eee2f9795d6948eaf0078ab940ab0b854b07d8dedb939ce160ed534ba95e6378cd20844fb8d312a7da1251df96ebd0506bf87d9caf40bf04b311f399057e2ddc9936d357f061f833961df7f3ba1a0987675222715eb3637de7248854419dbe636080cc516a4cc6ed9ab7a8dc3ed16a8ed5f2f6785d7aa53677be1f598177e7fb7a092f4c5714555f7d1ef90974ceebc7d6fb8a0177bb402c52cba6e19890ceec2ec54be016601111f48645b41b8d834249f983d10710b3c15cfd1f6459ab790a740d9196349285bc8fb0e99481425fc0569bae1ce3b105f8ef1e3c25d03cc630f829dafc1cb6a97d592215708b39b9c3a0a09fd988ab22067ca57b05696b840a424ac3974e10f7f4780cc2a8d3b50a0c18d040e49cb70396f2c47da7962c48acd81671cc02fad111ef9c79571f5d9119f5e352ee68bb9faf4c60cd7b7091dc129b3a04c4c9bf82c8ef04a094eec2dc36095b15880ba9998947fa609d03675f44dcd30b6979c016dfe964591c621009bcb9d90a4ffb2438eb270eef8eb8f1cbe204512645574b3a7cee0bb8fe84d7497c20b01a8c539a3d8456bbc9e987a653afb3479f960f3149fd4e178f6391299f4e89eed6f4ee9e28dbaacb138cfc10a12f2e922d87be8d272f6544accdb53b2c8ec486385f4d080a47ec7a063a1461e1c6d55f4f42ab1b51f51db90b2ea94f03278ccc40158c0d6c0b2850fea66afb0201de13aa2f3f1b498f71a180c1224252c87d7906ce911e02d6ac928c5927877e74ae058189b47fd966858d0cb9df9d5dbe6f62253d228dd348ea4afa1b6a3bf0dd8fcca523fa4883547dbe677b15e9c138ac9986fe640e1a5a474778a62b7e5ff70c61a64f9646d0a02740c14ff5e6549bd4f068cf61cbd23171ea2508ff3549d192baa035f7fba498ffc80dedb73e9f41d80953589fc4c29ec7605866219f48e1c7136aa3457ec7afd373aa9594105e025f0bc3fe3434dff0916bee37313af9444ecc96afb4a2f4ffcdcda9aa6319dd0d024d9ed753a60c29b8e46267cc3b6d4f43a125a3b35345779a58b92e1e7ae66c805bec7d0d37fda0960abc1bf4dea404300ab2e86a7c79a21427d12060a50497a7dde9445b7c8010e9dbf91172bc32e7fd53608c9a42648b61db353acba71fdc8e94d41477f6b8a11881bf22b718ed464e4eacca65ae5831b05bb7f548d9a1ef837052f0dbba072d9d5e3f17fe0c6aa3ceebccfb8af394ba059b9f7424b4ef9967e22d53efcd64ae42d903d1f693e5f73aaea4a67cf605be832c46b47935c7517fcc849fc90cbc52ca9e52ce9f7f45629bd02f4eff0d8710b6dfcb44bb2c800afdda382ad6896b8c4ec75f6fd416b46f656f135ba9153ffff15a91588084ad3184e1f0d8a79402e7709e06bfe70adda40460ff32e73b340d4a38ed6d8b661eb6ac556899910fc6e1e92dfcb65ebaa413e6d17d46ed2e39c816d631c260223ac84533c86fc95e3784b63f42cafd3208ebc15abbc717870e81ea14c0e329e821ef9f340a54ab5eb8054856b87f9679d49e52ff1fe6e7f7923dcbd88a844b119ee2c5e1e855939aab3d781fe6d85ef4f83af552b2ee385d6a1355518154ee2372c8a0d3519cf68fb13308e469b4361570f70bdffde8f527e7aa50c4e8a58a86d31ab69057902c0476b2354b2ff1cf7d851076500eca0394d3a7a4b3715e5d14af0bcf5e4d93faff4e2afca92b48128aac16ef87458825b020023f260883343bf5aa39be40d2a90b83c8118e7da2ad5126132f21584430b46dc42d6cbc27d1826316614227e19549d3f58de7071e86e17b8b08d5e6d303036c4dbd4a9c4197969599757a3a04ab9d0091b4af501c6f4f1635e6b4dd9d4c283438ee560f4327d51a3b94744bf796da237acfefad386a8882d8a2d454c99d08b5f55240a92bd814389ba6532b2056c5cf423b05807db1594e7c0fb4952b143ac4fa30d18f2639e4ad75054a40b66804051cfce8ba9874372e78c6c2ca829b214a89ed9258f49cb88778e8b9b456fd3012f9ad36fd04fbf3da020d5a104c796f93846173fe5adb3a08e7e2ef56adc062a404b537344b0adc976c8967ec4ec4151ce3bfdd24b3bda2e9344a361c43a2aea170dca2ea12daf3911c4361d52c67171f3e97f7dccfb8a20f0f08aa978dbab49c7b794f734bf1f5183a0c74ce505387f2ad75191ff18ac559e2da6f79ba25d56b44fb536aa4c0e0fe411683dc6cf66ec68199f10e18a388f052ffcd7242b9f144ef063211bfe3135f01e657188f5cd15aa679fca3ab7c71c0d213cc9cfc401c483ff03ce632fc1b751b48b25d86776470c2478291e59327e3678c87f5c016933057b953ac756554fa0586828f255eb686c67de4030bfbf2d01c7269871d1c1dbd762dad99a4e4f713e590495fcf370f6c5663cd7b98e1c01b7a1f7e8a8ed78ce0148895727c55faf6d6880884d9056cabca8b4919ddec148fcfe18878f86fe6c3f48b16e9c69a1b158bbce088b9fc8a2e220310bbe0ed4c0940625809a45d6e5463e86c144f1ea8fd351d835b3f42eb1b83294187a8e354cc21821ce94cda11e5a315364c1e03f6e57d187aed0d32abbb9ccdc05e73dfaac048195d74e0e3e7ab34b792ee2bb452dfffd729745d69ccaa67e6611cb2ec8b7a564923e912d0ccfe87ee95270ca2930d834e36f5c4d084d6e6781c9a1e6f861b381e6f188c2988a1cb6c9870ff6f3be53458e527841a75a316128ef3d5a96e8aa70e1c8a756b35b6011ca5351b92a11cac55104670505c9a4a2d7fc94ceae4f6ad107d3746a85cd1618c6a5070817be3b1f42878838e5ef775702b91a348a536b39744693b865c41bd8702e598abb74eb8a23f60bccc5231f7451dacd8149696cbdc18e9cd1e310308d17235a3497461507010d0260714034dc7db27609454842669e5e9a9506824e73bd2640af948824b7ff48eec9064fbf9f8728937baafc4cf6f6b01b419678330c0109c4cc909c0e4a75a58a130a80bc5dd7e068dfe885fb2d1387570ad610987f814322e7afdd23bfcf70a2861a6a7f619de96f2c1851e20e962e7bc82f1df23967751df41a20d7d368d269cc1170111fc75ade4bd00cb1173f7dc0c9a92ffe39c96cef8bb475810bdfcf017e2aa3d21aae625a96a3766e60856cb605c5caccc33ab27c67d2ae0ac7dfb4bf510a3f7c281e26c5a603480ede212367e295151415ce343fb56b4fde4fcf396743aae19ad82ad2187470b7f366005f3a1b5f2337717846e8acdae9cab04c5bf0585be405b2ad6d090d4502353f0710627f9da2d7b62769ee862a6c896907a2eaebffcc39e1b2e1ad8638c2b54568d48aea3e6184e517632713a6e299961ab1f9fe8401838924122869f83f232b89c30e2ae0ccf7f9221d57f9fc28fd0cec5792f184d585b6b6c80e93ef21448e898acb33324170f2254e472e253dae10f9e9c531051b06698287e0e7221bbaa1eea199503e26c7dd7139da8f3804791f8566f14de555279d656483d4c98607b1d14dea5853e590e5c8a625ea4a6617d2906f85c8a47da76ad25a351570636cfb0f208e6d32540efcd98f48807ce91d4a4839b7fb0d2b9680609f0497db1316461a2c09b340b813bd6885c588f3e8f7d29666103f0e73b34a82dab53a6e6304df6230f26161d49fd129cab5619494255006f432e7478950f25bdcf774e27dc4568b917ea8b629f7401382788b51664f98980938bb958f4b98ae799461aa7b30098feb57f840a310dc17898b8c8f339efdd07133ffa296720663d5286b871dec8cfb588a3476f3fadee4aeedde10b14ebee3d7545ce5b2cd23ce7ae678302a08f2e7529e859273b543c591ec2d8086218778f154598fb3e99ed6cc856e857c74060c08eba224a2a953a62d078d63527fc7828384e2186463983b5ee0ca257fe2ff7782e7a369e7763d496828799374e6aa8dfcd2e5ada26a7178f2c6955001bb60b4010cc7e24583cbdcc0dd7a48044107b6b21547b36da03880f7371f9fa8b38c1e482d802146dc3eb42d8000109da6ae1427acb4da604b789d52c88581040bef69789aa6df5b41e477f181031e44de649812c8c171bd887c08ff0321714a1e5e2e204bd7a9143eb56d791e76a770d8ab652dae78751f91417776804fcabcc8497ae4adba2cf61c9f788710b12a76380e7acb9acceca7aa18bcccd284d4cbccc76dc519199975f2689905d9c0293b0c5913239d1e650e779f49931847d8cb901d4010279f95d1f74e4181f3c10bb44bc2c416cf898948504adddac0901c77fd8b566f5d0ab67f857a6cc6cf02acceb78eed7b2af7699a9eb1e591a635d8e940054c1d41e65bb718a58c622589b7d7518108c4fda54f3b1c6805558c8ad76f87b3ee8f88894916cda5727cbac2f4891e281c0dc56466b994b9941b98346a519b2ac42737744e6fc1f296d155bd05d783c9b41163ba4164d45d98ebd98c04fea24de87821367012df16095ee79c29d9382ea8fe88c8e85426df314925a54716a711a5068486dbf556937dcf5080fcbfdd68a9a61bcf70b909bb744d885caa7c88589957b12350bfacf2d9a0f47a4d2479abe324de57467efb113d43dff7466edab28ee9ef5a3d929422dca7909c19d8ca6cc12c754195f7c5abef604aa0e215677468bc991299d922f9925616ba182ef16a751ed46f7437a1246a62e084caa20082aa4eb99cf8ef7c24e35d93bc04fb0d3b7522d76cdfbcb6b00aeb81d0f4f1ae33365ffd111e2eb90a062e09d7bdcaf54b8fd84bca86b3277cc19206205ef5c0df5e1413e6865fe2f4330180318ef893cb951cb1cdc311b7b2c40f7f295a063c98713dba4c5315bd4764a47611ba78076bce8679a25cf98b468c1a2b0177b2e13bb327eacb68457598e519ff74059d4fa301275e94b60693188c6d778de474cdc16d8978578d0fec28efca09dceebd1460555dd1ef6fb31c88290d14d701e093b8c65ee8f77210ab32f5493ced57abb42e5e3de2b8e16f05db9607f2e0924f6c1bb572af2b7a120137bf7e9ca4b68cddd53602ed5f0a6737fc6f971b442063940710b06a86e4a177da064f5fc9b615f2f30f6f32e2c6b490fcac7a357df64aa3308b2925c8b9290738c0650ade6304","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
