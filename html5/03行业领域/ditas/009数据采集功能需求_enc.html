<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5792566ab289e7fb0888bbb8f1e1e4ddf9b97b9b54ca4fcdde0453c1c0daea5f279c7ba5eeda6e49e1e8dad3355d6bd92d8b2add6896c753014ffe43e51ec55ab51f9b9a07e7489ec49ad1fc6fcc5bb9bb700082c77130aa05174f562b03fc1308604843cc944206565cf6b3ffda384e35e729d2abf38c41410849364098d4ab8eb048869f23fb92a0beba0683d4bf1b22ff946eaa84b6fe4f391609acae2bee8fca683ffe9820f75c37f71662c124183db406428261fdef6a39e49e6ae0fd8de66c0fe851e9e42a534d25eb844781a981f2550af64d1eafdaac6ea612bb3ef10d35f6027a68d5472b6a69bb888dd1abeb883e489486ff3ebecc2d8b1ff8d1766783482df86e6ba79196ff857218d76f481a51a6d0f77874ad1daf0382602fffbad5b8edb64926001483f3d0beaee6c4fb8173159069ba56350d4204858615e2719a8f058891bc2476e61da6ec58bb0adb42d7baab9c4bed792b96872b308801e920a132d3620f35b26dbe7fffe7a28d95251ee8233b743a70515b8ca71e246c1fabdc4d2e8599d7a9de422665b060ed9240a82ced457a7f37f9d90688c3b0dc81ca2df7c37add41647f6baadf51861f98711090e5090d499131b4240645554072f95bc8de8af4432d958cdb12161abf0ffa24a8bdb438b95b8621fdef0a26adbfa901119f6fa025f4ef103e9eaeaa63b93a7ffecb53de45825fe94ea2f4dd2191e461bb916dd6f9fe11306268eceb9e1286a3f74f1bbb61d2f90dd7b5920aafc651f95edfe8bb69ab874d17a271a3b60033a88c3b90c139f572b8de3d01f2e34ca60ac0d184247389df80aeea6ff19ff93b27aaf30d924930ba2fafa1582fbe9edb3a5579d28df39216b9dbea4ff8bf772a4b7e8ba608805ae248e54cf6f0e1e4ba484d7016929e0efd397cd1671157c10edd2200ac23f1682e6a1d94bef07be983924a1be07cde57f3605d32eb0f0f46a70c1574340e58f76d6646d38bdbdc0ad1078627158652343c5ff51211646e7967869f95aa3024601aa8a6ac200896fc3e707038ebb0f0f62e593d3891dc28522ef4b3bde4989c3b6ede2445ce7efc5b41ccd20406ceb9e3f73eaf0756e50e7e34d7a89de3c9994aa589091bb8981572f2d89e0d71ceef08d62762908042b31650ca38d623b9105eac8c2873a596040b1667aa2f6d8740f0958446506a178f6c54e8870affdec298e7e508f5d169075e6ceea792f39b06bb5cb65e400be282aa12a73ca80f1455b4139c2a5f8326f3223e570bc944e1cca45d744629bdad4062d5bc062925d1954b34dabd2497180d3e74e860d342e25b9abd4e56bfa9b7bd68e526826dfb4d8b18cd1b93b1618c36baec771c995e8b6250ae276ff93a0d4c52b977cb58af51102b6f0e735e64e33fa191f9d94b87dcb2d6198b89d2dbac0cfccffe08df463725aa5aa46547315d1ac58e625b2784036c3d2a312a16be660f779f5719eb9d58ed5a0cbf8ef9edca383adf05f97447e17268d75db1719ed5a1067ddd8c38ffcc4a379ff1aafc369c329b1117e4234af0bab5a2255f5cec0774bb20c98337d7797f6ede104704e312b2293042efb48ad1663536764d65dd2a39eb3e6022741dfbbc4313a2e8bea588ada69fcf08d33f3133308c9933decbda21c7df854e941d7a77a1c6b7c826784f5ff58e7466acb602b519fbb343d33a9fb0cde9728140ffecc48eac584aaaa171f087424b199f9439ea00b3b605f64b9801a270579db518b450887484cbbe124112470c96583978ce22342644ea29f13ca9df59aa0c1f571007d6e14595302586328e6ee2a875162925b1311eae84fc4ad37773eb9fc4b561e6dced4c292058a177340f0d018a0c7046d06cc127fd51e241d284e60c1f24d6472ecabdff9b52acfd4b0a38bdcb6429e6e7de540057447994baabc4d5cbe28b609edc5278acc15dd28bf3f3acdf252533c7c0fe50a54a7e997500c2fde5d8da122c2f944984d33f8de3e83c85c39959dc4ae0957542f6c6df41d32986832749b32e22f2f3819936ade3f97ba77c9aca9a366d3490d0fac54a1150880afd3067667cc9b7c9766cd39e0f86a29f41cb7413c3cbe84d0aa421ac490de338ec787cfd41b3f8936337a796b020ec2f038e6994c7645e6b1b710781fc5afd17d84d994214be1e4fa993a937d586386b0a295b67b77db8ce535ba1a949cf316e7d226f1d539655fef7e4997ec9de527f48627d96a22f0aa96d3ec7847b81a998089ca78ae39eade46b87ef827d383e3a8dbb5c3c10427f9bfb73e97f33499a2c84b27a5bfe3b6d2c4c76cd9f81addabed0c751edd3a14a772eab50b7050ef1603ea343f4689f53928fd8d7918ba95c74d5fe27349c251721210e97158cc4aae55bb4db6f391cd26bc919e41e124e84c5cfb71aa53411d855bc229ed6fe640e7dd5fa0be709cb6d7e05929c3f98021a687fcf01ff503a53bc6945dd9dffcbd656f0302dfa288f66f31b0d5fdb80eeeaee3d798cf88ff8ed75b7cdd5b03055a385f442665d3026eec7e08a4784b20b3825ed9c222aee8f8262a57aa73e9954121cead81a5ea41165b452ccd5ca32d9e34456e8ba03685e89ee3bb18beeb257f82e5bbaa9a4e69fcbde5dd33e7470adc6c32522f51738c4dc8384a99242646fdf410e350c4bf0cc86bacdec142465df2ff4fd6a52c7fd7cef34f42a4f93957f311862b46dc599f2de6d280ef24c1f4f877c18b7eedb49fea94dafe5cdc3401d3e47ca95e525008ffa8f4a715536300ae6af8dcc0979a1bfdf4ab529cd2fad363ce2f74785908537ac6a8cf50917730a737951e37762445ba8e30b78e2ceb2f16fb520f7010170863f97aad62dc52b901c7f62ae45c84b854afab1b46139680c5c021fc1f013ba92ba06efccb5548c9ebd6676c9f80baf7e1068f734d252c7f31b0bf8114a2895b2313a35bbde21f597b9e13970b1cdc4e48f7e8646249ec074239b1df2962d604216e45647495569bd6d9462666d73526cdb56c058601cd8184e1bcb2571c04ce5552ae0010367e154fcea00174e1d8a782d4b2ec9ec0a1e1c9d8e19d052ef683ef03ae94874d35d91e6c26bcaa045ecfed2fe973b785da047d009d07f5c9ea05e2e5700da259fc0239d08b1c248bf4098526d8ff6c6d71097b9ee8bcfe7a085f51174c895ffcda7b803c1238c126502ea69eb17a34a660a13ea51e42a8371956bc53c6291a4e9bee8a80e40acac61e0160b663a09717c6532b17db151b0427326723d8e3444ed7220ef75219cae404653266abb45fc50487937ca28e1f3680ba4264706a473b8f8160cd6545c7c0de35fecbf09f70357ca525db4f4073bad8bce48e94ed53a229a34978a588e25c6663101fe6ef4117d5e0b8c49068f557f7e16609d1e87a074b5f6c9a482784f21960cb9182827bcb5554c6242f4100494a378c5fc55e3330f5788ae4ac8870e2ae2afb95b313de1e10308a3230da9414322a69066f4ef60ff108f4eecee4a3ba613754f5526bf7833048753242b7eaafcf94b9d8ca4d29bc6cf0abb2d0aca9e7c3268602ba63815beb4774405dfa087377b8718ace1c8adf44e041678f37157581eb74f3670ee9e1fc9ea575b5f772e6ba09442ea289ae613c82f671feac4c5ea6184d9646a29c00ab9f1f54dc957e29970d1b1ff09907f999516ee361d6921b9e1a8c498b9b58849cc29ed9755e15451e35b8ff0b2d8f0d3e6274f839ab12d5bdd3a35cf038cff0f687afd3deba00a247fa1471726d2334144077bcfbb178609b7a8cfbdc282286d81dd8047dbb5ed2f1694d329500c1a5cdd919c4f84d5cd1dfd50be4e69e8eb6da31eaa91075f94355f270675e528eefb21f92fa00457c34612a082f205867549f5f25076461ae366294a94293efe564e54cef00633d0c552638cc36896565076de7c0d43746c9184a8a383597553f7f93c6c1adfcb2836a7493ba16c149d0f058a5ceed108b75620ad750bc72003984851316676740242ce671d47a562cabcb57c43df061b1ee59340d7a2cf72619307ebc1b5b7bb9c137d19bb38ef65bae23defed76797ce04991958e5c9b764521bfd00f095dc5d24ad08925e24b357aa9c5fe4a3456afba923ebfa62bfc6d16617b05fb88e150aaddffccbe288e458bc0833bbed0d4fefcd5ab20df0a32843c1cc6036de113e713dcffa9a65350fcb420a5c42037ef68c523ec7d513b9178f656da2d9f2d385d1f6685466ac933a67dae28a689186e88caa6cb1700a23defb8efcfceacdcbcefb3965cb13f635cf3ca6452fc19deb2626de2e7c9414018581cd21c3ba27cbc6fe7986814c15cbe5a43107003f39b7e8a898748eccec6336de7fb8e292d1abf0774e88585295758e0756c55c9c6eeb1d8794d6ee1d93698835b6f4ef2e028b4eb6bb8022874c417a124658394a59b4145fa814005b07de508954f297d4b2ada008b243bae3153742d15b254d641336423f532586eb639efa645b6d6cbab59dd74291343f179926203b35bd1e2437cb7c1571c85e0aa9e9ee136274578b8702a46a46baced1b7620ba38a527c6a9644cfadba08b7057e67ae009f6bc5c8eced6065be42b7dc342c714098d2292e4828a0c22adc567a03af64d0739bfb01caced0fcd4dd6707e5bd4d5d31252169644b35b0960504522a226cc848402afbd7d74186256a34ee42042caad12b542fa4a5bb4319686c162ae7d2a9a5866d89be7c7477603d2bc4ddf95a57ccf421ba25b7b69aa9c3221000d1c20ca1f3d9f456564c4a03bd7ac0efeddc223a2a4ee039a11a6542f9fd736ae5150c1a041e8f6a6b0408edb19b73e83fbaded69ebdd8f122fca4a0afc039438636375d5d46b5936894dc30ea5f94ffb1a5125244aecf5dc1bf6fcbc64dc70714f082f1d02b83af92155763240dc35a9ca669bbc5a176f044b838fdf2e1f3271796178ce06d9081aa8a4be1c735bed8243a84bd04c119a7fe1a57abd0b50061253a3e9e855f2118555b7ac93aa7911e2f1da13e595e6feae321636f21b2e155c94fee229645b744e428df7c0b432e6b250b018ae5f724bbdeddd558028605a4f242ead7a86c30c8b801a9c1cc3df176e3882b26f397951f8cc0d88a40ace50b3baf9ee373d5107bc433c12521b8f3cb7accc091b6aa7b4b96651c7705e720d77a29f353fafd19dab963dd022a8a4f40a35de0c4d31841a62fd80f74e99a8dd66a908e04eb8a45ae441102654ee7b2e188170e6cd991c6a9618331075c3abafd894bda906fdc968280c2f36dfbee6af3609e2d9523cb6e54cbec2f82f5e21d474de0fb298fd4d8aadc7ca27d330d12b947d62a0ef6875d439563ba56a92efbad7b22c970421cfcb6ab0bf94c889b566e2358433b574b6889eb896562fddcc9f246e54968f83c77e4629eae8070814b0220ea8e970956fb23f3d0ef07ba011fd83ea8869bb266afd945596a1f898051c316c2f631395e509911a036848c48d2b5bbaaa00ed55b2fcb0dc9b7cb9d3b2257bd69787af536242c43ee4c0ee1a5c3196ded06ac31ac68ebe19c4c1076b6490501b39eeccf0cafc7e9bb1c52170e56687620f346467dc99a2eeb1e5fdba2e0398d22bd83a2323e91f6549e3f38c0ef196e8370b5b63d8b2f8304a513e691675ba72d69cb64d33723e8994b4bb895362680f4e0a407828aeed8ef4107b8d6aa0841f00edd3524f0a8ba092b48c5ff67c96b9867c941138f4ae1da05ea4d292bf065a54f26cc6db77076c4a0c1b892825e8226b29dcd58be00b8c9e2c468103f69c0c78b2cfde389f7b3bfa6007299406741076a560fdd5c9d3ef92cc2a21945ac2e19b3ede2147e36d0fc488c9e6b61a2f0160a2f4d80c780a233db3af486ed727bb1665ab1fb34d1fb72109ab96548e2994c4d622a27012bf944183f1eb2baed46c3a577e52dd96b802f1388dd0b3ee7cfd1fb4a1551f83bec5772a49988de2941ab76fb103c025aa9b0ee00c06b03425303ad0ce4b6a877f0a7a7524ebed67e738cbd9e2319f25929ebc0f366fdfb645bbb951b867e32635fdd8e0b59c4ceca5d143355cd529b204779e53e3139d9371a3eb41ea5c1f6299313ea3a9aaaddbea9144a54c8f4d10b37d2266d97c8c77e8440948ff4db2aa1c2a4c7d6d6fe94bf99ba378a7ed91d5ba92d46cedad8e674006f0449822ccb10563d135ce710ebcbf90661c04b722ba0031fc8acdc8178ad1a7671909e0c7a536f9e1a4ea54d584776a06d2a94dcfc21f3a25abcb8db8041d861fe2df3bbb60dab20f4c1d4b39c98a1966d2706f77e2bcd2c34ea18d07acc3aa511d024172137e03b0c4de8ea1ffdd4e8d5e62922459c4a60361f7d96fb0df188a8c2e320355e9ef483bef85f1fa1a9ef733645c15107fffacf328b55bb04a9eb09f44f234c95d62a5b38ccea65a052cdca3167d60d24814d7e4b7a294eff6fd73654f66316918dedc999acf8d054eff3cb200de84b5bff176d82ab997d1101ff1f66fc39a332d9e32eb21955f08310a50ad8aae3ec48e3bfa9b06757f088d504997f4a61f406bbbebb6f9f405c515e5baa924555f1592314837f37ac1eac0ee1df2b278bb0d3a814f45f06a04addd17268aeebaf361b4f8d502ac5e1761d53a6936db0ca8d518e90eed496eab5145e0f1efa19fac64b35b5d816fa41807eb79ee70d4da82e0eda1a63f7688f0a9799823af187d55ebf851370fe5bd78300be2aef1c7fdf5d96ef1e613f9192096f7c9d7623cabe09ef73e070213f888a4367f90cb57696ed28db9a4d76db15afb384f8804f9706d63494fbbfe49e90b3a4194846bd62c109abe266e78150facd5332637ac42d26e48076b345f91bf3bffb9d6edc8afc5ffdf474f041b10b6f67d4415b25cc244c7dad70c9bb53729d110d8c7081181e8f850e78c1ff6f7124a9efe6861618ead38a4c8ed59fa80103c35a818f6e12dc5e78cd08da44c88e53b49b79059ea16674fbffd44dea84f06e77098178daacfac643166996475ddf18e78d78f6d5a840df9fb3fd564786ea73ac99a9859ba47249295a6a0434a85274167b4abb901a5f6955354251536562124a00dbefc30a893d46a085048ba7a14e948b0053fb860960c4ec2eea51458aba03df1f29b98bf029e8c554f00d1329e5a0a10bd5d6add6974a6578d25d737b44c26893a8f8ceb6fd3a44712b0696796d5185ea1485338f56724991ea18ef322c650b79685a206abd1ef02176a330a52bd65d51769ed0e6a999ddb75476a816413a67a1fb76869912bf530ce9c964fec16026628a491b6dda2a55ee820bcaa65c5b71541d3115701c08c411fa2c8bd36b47b6d39ec1858a969c4fdac7bf3db5eb8d2ddcb8ec93c8d7cfd44879da3869f39867ca221e155d9e5ff0361585a4276ed9fb54cbc4cc11504c7b2d8966389b9a2e219279ad3f4ec2acb7635aa5238da5ca36f878f5b186fdc73bb62b7b754a9150a41b86eab0a48d1e5e5b992133093538351a220db3246db622880b5cf49660c40bb05055bf36a8c85421c9aa6a9e1cd89324975d9c3e013607d4c5e5caeff8d1c68cb76b5cb58396cee3c81c5a5172c12c6c7c312585f9180e2d5b80c9f14a1650d1f2be6e095970c6228a8f4841c31a86d74a9c4c7e52155c33edabb96a979f57e13655a1772b60e24a5aeb727d0230d65ed81bf5b3f07f71b6e4491cd318b17fcbc3e0d64e59a5a98c24deddb15409036417f58ac5670f032017cf18c799a82659e0d4d9ba69a4ad44bc89816d8eb22365ab3b213ca3cea8267c0be567b16be766b09e750831510a6e2e3840d304731e5cc29d016d505492b276d30e48428ef750659d6eae4a2eed3487321c3b5c58fd803feda2cc4af709a289c1bb54c6ce2b055f4edf379893f396324b8fb020f7d75c4c3d67fe9e0220af93846d3757ea898ccdeb9ef0add22e8ae8c1f27522d07385570015c70d1d8321f731dedbe2c29d2661f54717900ea7c7adcd9c1171a36b41e06e27c86ac588d0e2f9795e683bf25b716f6c816586b9a2dd6dfe27fcca15619efa25bbd95c96dc04d4a5336fa20f1a48a2d949a13f34197a7e7ed07cb14b60573ccffb11f5815084e0fd80f66307d3fc52615d81216feed1e51201d5bccd9da4aec9f0ffd6bf3b44422bbefbaed9b7e99ba2003c4184d4e83693df8ad999e7ee2800442fd3daa6e5d4bc04ad6df7ad64471acf2db08b5072c92195fad644f254a8f486b2cbc45530aba7920394094a243f401c9d09ff6a66a7e2046a789c61da13a631d4d7828923d14a2858771530fb3d71d2959d33eb2d094872bc68d833869d06c56bb338398e072d3488188b43cb0e3348cb30d9c26b48638f97a87fcc7617bb138fa2731b2898c0fc217cb5f650d3900f7d4045f46bfda68d7539a5bcbefc5a70769b5b31cf79be5b7cbaa778088ca17b43e003c78fe21f51324042b9fe7b9aa342d8b3c1c3c20c1b4d19b668295b65764d66fe92f94493572ee9087af732778f5bad8e7bfdb98e9263f09add3b3c6f806282daea910f9c38b35a3606ae64301b82a0ee0e94cabfa1c2b5882cf861614dd84c58ed07c0d48bb792e67cc26851a2384dafede9d601340ab97bcd155396e4a01e0317c6c430fe1b537371ede47fc30167a154a525b4f78209ab2048e79e9047bae05820189c2729f71623a8a641551cc79a1204f317fa51c65e8b1f448f2e6faad274214c6b0f498c00ab0b65d2e499106b3dbb48cad945eb22b6e710ffbdcdfa10fa568d388af5e9adcd0118f638bb25d8852a1355491a8021c2f1f86b05a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
