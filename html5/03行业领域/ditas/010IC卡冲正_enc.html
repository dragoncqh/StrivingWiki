<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79039e4bf2e711e25444ff3e4cf3b1aeb1b0a130383911b1e2d63a00caf8e945054adb6e2de1e98640fe40c3bea9ca3d7bb7235f938d31431757548dc56c8bd5e5e7a07d1959fbeca49e00d1a75b6045a74896247f213be3572e5c3c90635fa539ee47d1787f8b7c15fbac39bac1b32e792d808bc3621af8ae66e37f7670950cb73dcc52e47c82d8e2a7f4bb0740c57e56d9a5a0b60d3c00986fdbb146beaf59ddf6470efdced74ea5ef9e478011c5f0cc966c285424a474a0e62e772fe6a8d47c5e33fce517039a34d09b9b8875228e9988e87fb8a8299e35dc345334df875ab19b87d28ffbf42a113d3059396a03fa0c86cfb2f8a348102d1749e3d11df65d5b1a338651e9c0672feb804dc357a4ce8585d48f52865a9a8083bbdb042bb90a0054b03fac5c535348107373dfb8eac8a9558e97b09d48c2a4dd98538f9fe685e3b5318e264094faeb4f5c9db4c677dae150cdb68b57a1c273c43fc8c49224534689bad6a6985f7b3a68ca6f3a4b0cf1a49e783cce6c3712a4f950982c01a5a37df0dcd22595c16b8b72de43c709705cdf9144b8d62955c12ecf492de29e0a2922192ad389c2acff0bf7dfbb0488d9577b5a38f333a5e1deb6aef4622d4f9dd226dfac67e3cb9737435513fe3d1b624a13ac6eeb664161bacb203effd5d7d54477fa29b85bfda69079e1790cc78c8bacf40fee73c74ffa505f463344e5e049342c3f4ea66c2215d3fc1f46adc61a2eda7cc44b5f8dcbe153d2e6f4dfb80b8cdbe5f7fd62a93e569a272e31aa1fcc8a2dd624e88b1e3392c712e3837e83157b22f911051f2a28573a35c312b15b46e7fb5d80b733d56361890ff71033a1dfc5463edb8bc8ceb6f71e0e8e58e07cec0d2cb159f4d7c639d1bac78d0cd86dd8d939b25a51d69fdaf53c65e9f967d871b185e0abe9589fd2b2edb2f4dfa21609f5d0c380c3657814e17cce722340d1f5d1fa2a1c8a7e9c21587ac1b24ac7872fbddc764576f4e95ae8ced2d442d38e8c360c3bb6b3088a0713d247f5d2b5b07a3e1b0329b5f8e3644e701e2ddb11bdee7d3f5098bb7e36b1540c9b5bb53fc84d3f329767aa3060be8e19cee4c98f3fe7babad2989a1b7903371eb4dfe3b950288f3cfe8001d1ff059585ae9e9148e5c08463dc617eb5842eda64502efa13719c312cf3b023ae3530f8592a759f90ef0de8bab59d08b87c7f3fbd1ae81ec27d5a3dc6cbf1c4bc7985964cacf8f671f7c26d287f02bdf067ee717e11df7c78e87ce6a076db78ea2298f2cf3096055239b0a5f2681432aa7b3b266ba20aa0aa961a2bf051a6fefdd1a29cb26a86a8027b085b26be02c593037bc1ae115a182df9fdab43faef87a1e0cd1b78d46350ff16ca1e622d6a4413d55606d356a8e07e0d06a0c7f4a2cf1beddbfa7d98a34e7c40ef65e36012d30d28a39f95be1aeec2d7efe627757307b0f4a4b718a0de4f91ed95f587f4938f851bb46d45e7dc9b64dc6a05565abfbefafffd6bf2508736ac937012cc0766245afe705b8a57306eb1e5d12e6f2a58966c635803aa0c81b893d37952488a5152e1e8a3c8dcf5fa0709f307823956c3c4928eeb4eaaa919559d842520833ccda8513aaaecb2b487e7dc87af2d145124d035d29b8289f74c9c8bf3c426eb1a49d5686f40812edf84dac5e934ef74f23bf582db3f2b45565c1b651b161a63e948c7d0f442a8b2b1669cbc5c23e3381f0a49ad82bab798874aa30e6a889b16ee73d14d724382cac1b8758357257c7fdf9255fe213b462846be43bc17fc20c2c3fb2a595e4e30f5363215ca2c379ecea60a3f5c4b1b7219ba5be497ec85516e10ad9e2abcb97f5b5db2a3b0dc21fb82c838a5df222c37bd720f35157f611f3a2138660517c0755a6137378d7c5359f358e92c896f86557afb229ec4a6c3e19f745fb2f1077c33ffc3197c4308fada962ab57bda83b0f2a058495e6588c1a693370a31ad67e74393c176cc06e39a91b3e04acc4971fd8dd04bdff6c7467a364de70034bbcfcb0f1d63d31db51b563a41860578e4f036b3580751b4cd3771d0ddd2c23376998da4ab31eeadf882ff90aa7c9f95d54e57f42a814a967e44c96f1ace9d1067c832b0b99a1aaa5b8dd34242cff939cc1dfc222d2e6128e0501e33829c0662788a4cddce408e19d898fe2bb519182fe5fd47c5285e86fd2befdedad66d03f53d6725e22bd5b4b7aad7078d290f1d3327116fe612c1bff240ee56e1eb72900c6c7bdb86297835f8e2a6985899a2567d915e69e0f08deb01c3667662a37d3a3c42ba47d9bc9963d5e51f71d9b16c4969f774036b8191a57c9393f0ba833dcd6151f1dbb2bc2c8059715e50927663405b323ad439063e1a9037f2df0a9ac9e73f370107638cbb34ce77d6ff0f37e7faaefa77cf51eefc356ad8cc43604a0ef2b840ab74cf58beb54f522f985bee388425716dedf873a44b59c851cf02cadb2713a3c96a34d0a5fa995492475fd3a901ac3bbe88bd46013c0639a16a34cd2a6e3602d7ef51cfc651b776b1d7eb1c7e6e113433e207c213ca13a864caa4a6aa1b75a32d6862d11715502c908195736346fe22e419364354b0b23634060f1f21c09579aaa15a9a2307725639984d042b5d60382be9bb7a847e1fe8a8a47e216c3c16e7611a510d686bdd032cf46703480c09f3fae39e9ac1f71bf264b5cca82e0a73d77002ec4f924ae7da4a217b3d42bf62a5fea0ba58bd93b9291c968e7de0c04bebaccc037d0880156afd9ceefdd6ee315d6809eed92415858895a483c0292e87baf28580e0b67bc33442d2bcf751312b6d604e4cfde214abfb7336acf579be715ad7531e938384d16f8c3d923814ee56db59661d4d0a64cc24206113db6b3727cc4609bf926113e90695485928ca41ce644e8ef21cdc1477d692b1830b3b028399ea7d0b18111bd5b1cf6d14e7b0eb6b8a38488def6969b754d56230bc82d66c63db5fcc6f06b57e2771e8dc2cffb121276d32259c301a5a83781b18720b0be0141dc5ce3e6a3619e222069a3b14445abe420e84d847ebfa09fd615e46e7d3ddf11bfb26e2f2a45c58a98bc7dc5ae6c3e5a893ba22b449f564c38dc8a1d65eba0b2d337b6b1d7f5ab5aeff9b633dbb8dfbea781429a924b1fb8a9115f574cff079ceb5582f8ff094b4f320bc7c2f59f4c818b5951f843d8b7186866449339a7432d88ec162fd7d3586173cbe1a8b1c8aec65bf63839e1a1180e29cd86dce736e2f36893221281d073335bc543310934776f0a37b463be66786165be7c388722ddc31ea620288da0f33e17276ffd2b5c29cb1fc92bf1dfb96b562d7828c6c06b295e5608f253f7daf5fd5186f550d0e63b22f1cce56858ac892e938f8a9e533e5d1cf51751657a604901b28b664abe164b00b97c29ea1edce3978708b45431ca67be5655ca630c9d441be40788b0bbdb9e3ecba0bdea4059f66c79200d3c970cb799ab95d008078ba9fdbd556421611d54526bdef1f59c71204905edd09d4065d54345fc2d30153c411b480b023fc566dcebceab4f184913a02fedcddb6491b69560a3f792cfc6a80fcd9f85d91887bd89364187129448dbeb3a69e3d6026e500006f13786234c7731588b7ec51ada617b2c61a66d1773c0b33a654bb8f99a36713125c5abef05f823003dd7b2b1908d365f82cb72450c1df1ac0e6f31fe5d997f5f62fe557d0afb2658d1b992d8d6d2537223e546492ecf16c44d69265dc4618992df9fd30d354b4b0cda93afe32f3c9c56adea521de13c299b30acb1fc9dad188e309256e9a143411f1c685a252d9dea15d12eac1f6c8a0d4faba8bec3c86247d25f6a024f85e1746cbd67b2d3d806de720efdef132230ac004a1cbfb2d92ddb37510592c2237fedc6b4a70f6e0ea0b0bb600e4b1bbd321edb857e031868fd0a691f676bbf2118da4524098a56a4b233579224232b62bd7fc06fe0b2352101cb92968eab1b388966d577f9ba4b664ea641b81283dfee04a816f2c02b22d18c3f6e8ba9f25670543161a91186087f4b86c30fa2ea7ebb3be7f493c1b9fa62b994385a1cf36eebc0dc7872c4029db9114ad7e8cc5f5a8c631fd5f1881defe20a899f70abdb1b4172ca555a60e4b5d8db7cf68d3a426b72183488667307c0d71e1f7fd16e418a0b13cf6927d0c8ed18eeffc1d7beb028250c1184b63c8f57bc41bb790a94755abed23137332699e45c990d323a69236b7f040304034673d1667f31a280289d730a0ad9a48cd30ecbef8a6a5231f846cfe4901ebba209b81500f6c8c7b51ea64a1a253a8e8c6f5390a76b8bcd9adfcb611b254230441f13366258280ce83a5813ae58146a310b4be618354870bea8eb9dfc96c2cc2d28a20628a96812c63d80b5ddfb966086abbacce84eebe1a371ab12f4eef0b9381b4761a74f0d1ef0408c52bfa40300ee8aac3d5c4ae9c172c595e7099905ed98c2a169234726f8ea9758f4aacc41aabd573f587d03126c0f9dd90208c7ad16bda67e9177dd789a64f9ac165d44faf8eda8c4fd423cb83f95a6e8b7bf5cda90c10a3141c0633bbda8e707c6db617b921fce80135ba57ca1bb9d684d8ce64dc26b048c18fccf6fc4a8e463b76dbb9968e4f7bfbc909168f572141270f6b001aa600c726c9f94ac9d1f344eafb0d44a2434bc146860b56f4e43cd4e6edb6ebcab359cb35cfe72349af310802b82ca60f1161ea909aee5382764c0d78bec942c8224db0dd1f89642f94bcf0841dce9cfba1f75fefdbbf9ceb6b5c78f6d9674bd3c81f2e7582c6eec5fbb77169a11e78d83403e13ef645c5606769e386a9a2391cd556c9d29d0d4de4b9c1a32342a86b18e6278fa85199bb881dcaae03909822382231d5fda49d73eed642fa5475c17dc5fa269b14363dc945848d28fd518e6eb8171372936b868c009471ed468455fe3b5927c2b3e57e90c3136f1440ca2aa17a58b4f7663e0477628840b06d932aedddc33d2eb94bf2cff2dee8f2d1cce446baf0a6a00267ecff155a0c161036de9c2e974d14b649f48a95d7fd81860a6471fa7a890b35eea48a64e1744c661a990520e2590523fbcd4f602e693844eb113a4e8ea6fcc511ebed5b25339a3a632ccb154e1f4dcfc025f59fe211bc210fcf526b6a4c849efc32098a842661eac47990fffaa27068a932866a85875d69744c2278f34e1f186cd9215e130b1a9e752ed71df36a4e296de6802d07eeec7c5ee444548a1b99327728012de764a3bf7f5ee8ca0fbdbaabf3a5dd496ee740df43cbbbd8084112ba21e41379bf6f699688b5db341d38b3ab82f65c32abd9889dc95d2f8bab75526eaac16537e6d3b825ebe2b19cc84aba61ed433666a643cfbeb508d83adcbc3c28120ced41a8aba561a427cab768dee9dcee3ca946b105b03029d668e994734e45fb1e3daac0fc7bdc974cbfc6fa11efa9d0f5b4a3892c93f167c996d1b01a6813523bce0199779702365343a65e3b62b3acca408eac66e4de5e87463fae9851d8018ec759a7e9040660e68e46c70b8edfa8c754579860be4bb07012e091caee48d0a9c89f77ef93e2bf3170980b3a79145e1750c0b749187a15e575c02a57f3aa4085e072ef0c72b8f03e43ab8dab5ad40f463dde60215c14bba96a2f729192ea8aaeb89c9c0efea6885ce391a1c2cf70d14616ee74a3d76a4b35e1c9a8937690a3dbcf0deb5fe6d5cfe6ec27bf092e909279c3977e0b2d1f931ab2d06e01b3b39656509f20534e790a08b6ce7f6c0d9f7a0c18aad7fe999621ffefc7f18de4e8239351a533ade584b9396bd9de80e4919a216ab17189208eabfbb84337f44ec174d3ea280d899de14e766cd6cf11e8d5928ec52b1757ca7aeb56b3107bc2a47382c16dca299c367f7ecb42f41db97e35bddb17d6b90b3949dc4dafad7aa22b3b697f49763c5c11aa2ee1d7b2b99507e4dcdf3d644dd0f62420c0407fce33484c7403a99727ad9015b9244028753aba9c41e00d082aaf6cf39efafa3af12e1053f3d04ac87f1f200e19508128255a373567f45d5ed694d3335b46d40b86b1e7de1c9afcc0f7e16b10de6a63d24f32a49f064ccbeb4e3a950baf00b4f74c2ba39b9e82543b5180fd15ac4ca8d6fa15ce3a6feebe3e2b258e2eeca1e4bc0453232997a8d3de37389b49bab8e6f2e2a58b87cbbf1b92e0cddd92dbe44ce73bfe8617b40890a8e4c67bb01f241bc13b752c8e55ef16dcb8720a3662353edd216f3813ad009a985fb5bd6e281a9e32e534b0362ba28544d1a5188f3987149d1deea0e2fc5044b9998e81ffdc7408c706075b31cba9beffb033a24721148a719556f3a5c250301b9c08203043f750b26184735df6127773cc7b299b75b29c69f303cb4df4d36886494940c832dddc22482b5f19547e1da3fedca1df0986fed46a3d395cb2be873398825b588fe60db611de18f37d339b0deef7b03d6be50463d4f76fcef0c452799d8b8af715fb601b08a8b92774a3960d3f7f09fbbec1251bc2d5edda52ca973142f8d1ed6c573ae80eebe30c180c0a7d5ee736d375335767e496e38b972c60ef10fea6964fe004bd25e1ba02527fb1c08f27ed002c5b2cfe04cf690d7441a663e828688eeb622d60861247b82a0fdf5d5e1fe8a49740c4f5a137d2657aae41dd3d98d4163335125bdbf27b68a847c0bbe367bcd3513a717b434d47c8383ac20e9625851098e9493e2f00af5d05d6983fd6b4620e124d57e9644ce1d0a41015eeceb996a6d0c529a4bd2e26780dc742419d7cfad2e15182830ae287da481dec8cb86ecb92325b81341afb8e209bc2b95b8fe9af4bcec988fa23be455e33f1c44136fd18cbee3716842a4fbc24cc7c4690fe846b1b3e4ab4fe18cda6f205aa0dc679905233d4df5b7b0003da2e725a2a58337048884038194f35ea79ca6306bc5a68fc942faccacbb05485294e35106e45955b2015906ee3b36d241d74e6409468d14127e06932744eca804dfa22b21ac025090140b0bb46779e5219a75eca179cdf4c8e9075cd0eab149214ca962e22e5f429c48a5657482a5dcef4ea8e3ecd547268d73e726155a0eab43d5fe4b35bc890f707a1996a5aba9f568daa0e19bb59639c1096cb8c840838afcd07b58f7a839b733d501e897bc9b5c6cf6988dd4771642358ae6d3d91dfd85b6e88226b7967fe1067d24e3772d2a35cd2131582b3b300e444486ad75543904d96d0b30c74f8327dddaf1f7c6b72846722c23c08b7b14eb46f31bda43c792ecea03a02741fa76b88748bfae01e6391608bfebad391df7180d6d1a13a29cb719b9aee0fc01cab2aa5e1955509e20bc76f9f140ad9ad5795487b39df8c4c5d2a62f43345d565cad7d1f65093d37b2e36b2d8e7a540f4d79f8fd9b9da111472b592420a3bc1688a7507698702913f5fe6134a3d79f34e9286dad6246ded6465c588fb06f960dfbbdfeac916e2e39d2bc1c6a604b2158878fee9fd4b8ec82a4b32cbdbdc60fd271a5ec7308bdf975b39b3fe140147a84d5b996806b69dcf9db88dcc9b41cd38c762aed8b30aa7464cf4673d400af23be03a8d9a4c444b01bed259840c6af42b422d44d3a1ca227064b74b8070f534d9e8482e9be96049548e7fd6027e1770f5ef062fbdf84d2ec9cb13caa02c697e8c696cce17b4353053cb28de525e7fa5df900cef5026675aacc585bba804dde7972f85c39be288c60a3ea82840fd31812a7edb901a475a158096838fda5542acf0f3773cede56c792dc49984c191ad89e1f59cfa6472707c6524a1329c9440b9f31b155d4d8415a99819a2559111060b5425cd8156712f665beb39bcda0db5e64ebbb29bd35b564cadafe89d16a341bddfc7d72dfbd31f1a27a4aece6c1e3d6aa9ba0e99d0cfd8770ea857a19b546efec34c33d812cdc8a559cd1098812989a5b33d72df9b75642db73e7e7681bf226656e96ca68398bafced12a26962343dab881eea1f3ebabb2697a88df0bf0821663b733d238b49c7d08b1d4cf78ed71712eec0807c2f8917e3deb906e95beaafd53a3a3c5c4882656e76931805b15f4645b45dd6f4adb2af504382474a06f6d3f134cca84fb21a1f95ddd4b4fe99bff10c48ed9c85c9e13c9589cfa56319ccb2faff8303000f24480217f4c0bfd6866b065db467f815a494ffdb5586d2b5779be1191a9c2b14f1c61f62cca4a3cfa366c11641597e34a8360035418c0fa1faeae0a94d2902f1a2053173958fdf51ee02b6d08553db05de75245783264a9556e64932452a367c588210489a85e4ebfaf4d9b510ba785332d6c50787388443ec19d8db1376938e12767664bf5899abfc88458c5563842f246df861d622946a343fe2fe2e4a48c7698a966bc7e3ade991f70e8b650f2ee2b766ec06192084c9694c40fa1dad78695c7e527768f27aeb3f631f7606c16c26b605fdeabe95a685d468662c176c1b866adc1dbd6389b7167e818e116ab70ff523b8b4770168b2709e3ea6d61597488bf0aba727d1f8e890e3ccc4bd96f6209173ff571ec41933002703140d41d654841e9edc685f2f4e9059c005d5abbad8cc99526825d3c54424369fc85b8c1b55985c5818145ebb0ddf0fdc0f19e3a4bf50eef5442ce4c43eeb2943a01b8bf861e7d44715d5729a41dd0bf68d39f0daa82a3e8993b363c6ee14e7b7d9d5937f81d17a2eeec245683003d6044bf678da579feb26b6c0dbe05a2f3e0e0ea50c51088c55f5c30fe3d3e6292ed8631003b316a8dffad98e62378a171d77029e71d17b9782c905c83a0a660255a8fde4ea1586cedf1bb644ab290550a428a8d33ebae121b318bd2cd51177504ec1ff91ea1592b867e36d27756f8df58bb3361dc7ae174687a959b48468172d603b7dd3f81fe36f49c5be52f5d746e91546219848cc83ec97f8977fa9c928e28bcfc907771dcfa561646b22ce2b9a8a7d750af02959e025d53361e5009fd911754f99332a9d2b40c3d781a15a47186afd95960b1a05bd76c8a69b6bbd978bee0c9e33db65b2e3d1f4ec2e9bdb0fa3c4fa92cd31edcbf7073bdc6ed7dcf63b56ed9426dbbec491e5c36ccdbdd18d33f7fea5a5999378a1f121c05d90e11f59726fb152b34150ff4dd32297a08ee68544654ba120c5b22d4561a101ab781c2e3fe5c7de1deec8d86b964d317325ce6fc596cc63c84bf92c391759917d846b2e21a2c99c0af5af6eddb7dc65d31c2658a980736583580874bd6e2b8856e8761ac45b7b3e57fb3f0817141ab3231faa00dc5a20fafe7573afb5ceccfb991894907e013c7a11b376c2aba879f0f75941216bd456f9fb68c0c4f85a70cf09d18c1f2f295b3f41587fab1acd9bec9042860d4bccabc7349c0f48912b5d21ceee2f0bba17e14dc84893597b759ef8c4339c999f30d37999eb002210c14439cf11714819dc4f39834308245ee90c29dee3fb918567e48fa1b1bb198e517987aafadd5cfbf8ff74622b0c93180d41003c9f9a8165186e1b33b98b4654085734eec1aa0d9b0ce3423c69a4bb9a9be60549404a7a1e5d279c69d2a4714fb1407a0ebf7f372450d5de93b31960d376f36c0bf1fdc14031ab77f7654d868d9ec88c43564751277773b37889440cd25dd473ff98140ecee580cfa83f4b701b4ec27461d38db4adbbe0e0bcd09d20c2f78ce228d281a165b181d26eccbfa57ea7f007bbf56fc8d2fca90d00ad121d05db71b3a174da7f05beedd26743e111d931ba9fab0784b9efae286a7d74c12adaa8e9f12578d8f1a750cfd247e836e2294ac20d3e1d9ea02a54611f59e9fe1f19876b08c2c82fe0985777a276b600145e5b20113614a99325ca7a8453a1b3728abc9458b6d2ff31e72f3650e2f6d88c025f6d3786c209f388c73d3dba12c22dd6c1522eb95cf7a342dfc7ecefd4caf41154644069814c2164da5f52b5bebb5fde5e0f9336eca657567aeca1c9251062ecdd41513eac7ee39ae9bbead6761c2b27dbae29b32a21b3ea1a1edb14e8f703ca8c630c38d5e950afdcb9e5ee9461b8c4b8b3a07fb4dd0fa9f00aa3cd929315bf06f21d247e88edf9ab7b188f42820137fa5672bb90a1121fbd0a7da528da044923f721e1afd47f847741c706e23f6ecc8627fb90f275f90bb1d65c4e353dcd9e77711bf1fcf7d0665982f6c4b9eb14553da9449acfc73d4b7183ac2f77abe4b0e80763b6b42598f126e317a5fab7820e5ea13013416719fbdb1880eef780a8ecc1ac194ac8c9f396e32f60f0914012f485f8568ded9784d0719fcdd768e44837e60cbcb7031ce884a2b789a0052ee25aaeb22e194a91a07b4a41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
