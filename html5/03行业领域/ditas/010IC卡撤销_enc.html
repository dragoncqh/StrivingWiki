<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a807ab20354865cd51c6697f2aca12ee12b4e3369b56095c3f03fd27ae9ec22145348e54e8c507bad75adc9e69904b9dd5eb469cb57fde2b4f0cdbe433abc32a1710d23a1a0f3fa4f3e8fb09ff831c16ee0b58a53c270640dff59cfab85f057227ce8f2e9a7f291b75e2a083a57ec8038d677b5e596b99e5cd9c305ea34528e18093ad336e344230dfa83191536b0271ab92ebc4e25cdf5ec138236dd09069c1cace4a09edcaa59ebc52f2db6d6340e5ad7b92e377b1bf59375beaf31a2be00d261d53703d05a464aafe78b058c29eea31387f3f5ce34a4a18337803ef931916b00c78ca4aa5b578637a5d62851f7d906ef000a076d4010e17459d371d7965ee16da40eebf3b0f45211e470fb05936772d50b96cfc373fccf3c455011808d78b47b979b4732df8380d6e602a38218abce18c92c934ad50e0c9ba9a2946d69236e4fe45d440de25cd903fc1d825f6d3e3a42622aee5f633c8aa35ab5627a38125e89121d2e656277ed06d2bf9bc5ae7be45cc10b2f011c1fda6d81174a2162e32976157bed0583f2a46cb8f50a21a105f8d0dea516e203542b1449f25573a09816920da6f37c1d541a9f4371c0270c99d1f1214ee321c390ae8f82f21dbcad2a44ef7a13c51adb498899d10d32fdb6f7c6b63848ca9ddd8ab141f6f38ffff58550fe9047b6e32ceb6f449bba6a36450a5783d6660573c40e12e6d2d99c0f17769eebba11e667a312e1e91be829e24b96d817e8e587f230ac10d3570f939cf4ae78b2084295fb428bd47266505c28f8c23e6ea6095bb2369f6f2fac8ab36580be01f6229ab1fe8c11f918c8507ae04c650df87b5e11e6c4239db6078949558aa20b58e76f90c77792c3340437c38f3c36aa40dc60ce7ec8d8b5824cf7e6ff7272bc83466b326f5a5e78d5c0a2291e7f602eda591b79dcfe129c7670f80bffdf2ebf62a76a5e312975eef64646fcb0dcbb72f0354f4a229fc89fce63a51590622753c85ac51675bb8552ec2b91f3519eb71ce3fc3810b40402ecf57f135696bad408e366b59c0bc82ec490774f8f5b22d2c4b8606c7e1a16e928a79052cd8e5ba24b44d38c57bcf991dc897e59a2c69cdf29c49518c37798963506fb70b535b20cd590f98cfd92b0caab0369af063f0948cf3281dd6a59e0f773ff8bfab7052fff0904d4a35edee744c32438a4b57663b938e9abb69e1b985be81f1fd6e9a423d602defb5a59606b9525d86469580c6562c64b7b72a5d50ddb98d6dbd59c634559b1e7a271725b16bec2b7a773a129e3b8c88b978b81d323a97b4f0262228bf6a369b7ed60e47eb547a2a69f2d1d1dfb160f7246455963a08beeacc682ebd04a99f35407477de4d5b238cc92ec846b9224a4afb35b6ad1c21397678a861ca64fd1c0c9e8a3c9a37b58b836848bfeec8cfbe3ebfb90f86c331ee2804e78ddc0c8ecd0c90dfcbb19850eb0a8cd9734de75cc23b4c382cd47134e080897ebefe9450d75e82255f666bc3327638fb6105b655d4ac2302d150e7f88f06a85ca8b0e92ad242e6c2b958efcbc51749b128c34710f7be449016bcb84c64fc76ab99a1cbceb8bca966853675bf616b381de39008243096d104196349cf5339be9701cd97efc6236e8dbd5b5b28b8986cefd870b2fa2bda07a6e1d7e0f921320a206c0cfd8c9fa488959a701bcba5dba2367664faa0fa9f23004cc3ec49655f607d79041f411b6fd3e498f60abe42e2876e8467c2a019fcb8a33f6c65635c562fb8e8f97ff79a2873c9c68b72d44a2c9a4dfc35b7530d30e7e0e0f0fcdacc01da385c5b8598f08c4c6ad06d69d78e620ed5055edf0bfb80f2e4a8aeb4cc1d6038921207411f203d429eb4b2df8ac246789b3ef6cfafdd43f2db19155fc97768bc686a5830cc9e6d990f563903f24b7b94f3dd6a89c45a8feee10c1e4608ec044a300b05802bd05fee53c8872525139b154dcf02824415f4482de4bc0a73567909d53dfeb8897b85c64d26f51fa55c322c48db52326d5c199a5b1f3cf4292eb18eaa659aae07b5859ff3097abc85f39b94993469cb39e16c29d5b5b5b61f6b7a0f8b23197f28d076a8d53b9de6a75646ae66eb775b534c016c03375d17405bb54626b2fd4e305bcd0ec62a3a7849b1f240e284c3cc8e9a4087a24f48e3bb80c90ee6613da544f9c5713f74128c9a42184b917da60f94f71e196c32f0eaf3268ed296e7c8fb4a1283f83a2f333d695181997554e6b7c31ed7116787b3274898a733c0cc7912ab3b6fccda140c049c5975e236c40c7ca3edd05652f2acc3cc7bb7ffc522cad90cfb8c0b172e0b35370af4cbfe32e1e4cb9a77376e2c59625bd81171df95c2b0f20d436e2e02ca25a59691d2021f638de86ffd094113ed3d014ac829777105e5b3e5ca3cd6f1aad943575b7fca9863551bca6a4b8d4ad679a4c317a38c732af8b9b62954edb281c6f603fd34ac01dd391bfdd9f6309e0c858407eddbe8c073d3847688b8aa979ab8dc0872bef2d081851bbbd6fb75bfe994449deefc5e0769c47f4c7b4ab8ed560be847f8ebc84df84be862c8804d520b92032cd9dd4c3bba8975bd64b1d209a457f33365b3155d418b0eb8667e8916e24222081469e897fbc6c0ec6f6fc8e19f62df97b9ad4877cc416b77f8efd1f7f7515dd58550a99decf2ed13ebac83984f6062859b2be96ac186b05b62c57966e028b7faf2c03de02708bacec10c03d95e129c0aea954320d29fc24597bde7ed1ecb48d433aee62001152a0ede17eaf9116c3d902053ee85429fa95b69b75b0047df6c5c8446422ce2f76fe2df5bf26d2bc87366d521bb712cb74086c9bdec703941f46b94b22a4cb1113ea60bb62a14d4ca31a2fdd50d2d0b42dfa5b782d77d08b0b4b998a2dc5fb0c9ebdd92938a4163281dd8b87225c70acdfb44ff7c52cdbdbd515bf9d02254624dbe69880166ae683cb36ae9b98215f40329cfaa8a672c17cde9840e86a92539ea3f4b87c3e86ecffa56b64b5294c8989b4754f40aa16001eabe019be66116bc7051eac103fe4c7ede41cdfe522cdacb00497393a7c6105618545b383cf5f3fdb88d161e68cb10a18fa9513c09c78b173bfd216ad33cc1af39e34587aeb81c39741658e0804770cc8b41562ba1952edbcaaa3531a00855b686032982af7ada4914e617fe434a57239f96d8f27a0d0193c5c4cb03e08a61f2d325e52c839ae141c52fc13868bbbdf81921f2d04ce39c8410fac9fa446f8708e42fc07828836ca0cbd3148074e77228102cf9b99ff73f915536272c48aef988e76aca0c4063b34befdc18ab8abd95175410ad417e0c1a6c7f54f53c1b14839297063f30ebfd705c34e31cf8d966f8332849165de36242c5a8a9a92b47ec4cbc11927f65aaa0477d665d4c711962a10a31c8e5fa993a60c1b7324f30c12d74c86d72115408a6f17999220571417821929ecd867f6384dc58c090529253136443463cde2c2c07f9845a4add6bf64cbc4f7007e9479dacacd53a692603304176d19dffa9314e718e56115265d912ca93829a422575656017085f4207cef590c798700eeb805f7a9f57a572703aa126b8d86d128c4fe07ffa612753f0e1c5507bf7ecdef24729d4a347ef6707d6860a7265e6339d0e2aa70f07f878f26b31e38990c6fa1636b9310661a904bff76fca936b6cb2e4ba0ad0c77ce76dfc3181fdb342cf455f888597c9826ddb0658d69c8ed2cf47417cbee87a21a8ef1b7bc99fa8aa8a33c3edb4d6a53bcdc7c31c4432bb8ea5428060564007e1079420d023f20837c7a7f9b4c3a816dfad10e13ceb095d0d7b0a6fc7195bedc66e52f54b94c434cac3abb404d606b54f24ac6ad5afce7d5657db61c160e9a17454800fc6d2c37d8a312cea42220b289e852065f37207c15d5eec6711e86c816e50b1c35449911af3e4d1426d81a1a4e66749a2b4495ae748e4582634f076c4d4d4a73687acf136e62bfe68e700338dd30474ac13938b4042687bf86b9669c956b1696cfd1ede77550d905f42e368fd4a72084b5bd06ed65625f0ff624286ddc5c3b29142896591f52fa1a0ac3a9124f15cd441bdd455d5f7f1d0dd87287a8b766b02af45f2ddd368a87e768eeecec6ddcd891a660bf469ad64ad24fa566f9dc68baee2e73b1d1f67e8ffd0db9711e62098a4ccc87a04879380fc212d572959bc9282e810cb8e988ce802a37d25499e387e11ce052be4940e4e48a1dda5130fa8f95b97aec334e878763c9a8dffd5ea992097c07a43e909aaf48af61c4d15ec7bd579e33b4d9ab588518709622d6ed5c6112d340ce7b634cb67b3a2ec438ac9773b9caceed903753248eceb68c309c01a478fd986faa0a6eec63a6d5d0af70ec2a1e37c888249264dc8d8a67d56f7b9a2ed915d321f03d45d884d9f09c031a9c65dd76676e16297b43bcaedfae82481b77d59d93739bd654fb059f4c9c1663f0448966d0b2389c5d78255c7f847aa61da8d905c56174e973ee608d635a2dee5c0049fb456fd357bb3651bb220cb2de65cbbf9f735848b5fa6dc7a9fa5b3fb5d21755223ae7a9266a79d05d8b469e30acb41c6a8fd093297ceaa77e99662ae58eb29b964e73ab08f2febfba370b31539b8cd22ae34eeddbbd2903806965120c3e8f1f2ee4b097ae90d6bf642112e21e5c79bb152152ae906c6632815c39cd08a3265033c0273239de4e84dd6397b43f5310037b3c2ef69b83eae31a9f31896ecdd00d239f109e3b7205370db7bc2f210a323f4fc9a05ac591ffaf2c53b64be3c9fd87646d1f8a9279ba857b9b38eb3a492aec2a337fd5c5ad04f91cbda85ee5c10dd76d1e392652fdc49fc4c0aa4e763f863505f3e1490c23c81584ca4196cc5919dd14a25dc9364a3fecdbef780c29a3fefd09c935c38f23af7c89beec7078a983787483d3aebcab1868de4c752a8999bd82dd8e7d3ff4ee290b40a6e7a769f80645a20127e3be453b3261a5439e2f15527b41534a1abfec9993791646448aa86bdd681e73f6358223c422ab9c6fd5fd313c9a6bed778423c00fbc2ca39a0d631133363b2297b65e50b53d0b77edd85499cff2a879e709eb223d49897548eac82ffb060b0bc9b40e761cbe7203310ce9a2900ddb5d80425b897583693088a0c31934ec4f2fab6bffdd407397bdb16f97543ac7a26d0d882a5c637640ba8a6c844bf8fc5a55089729e460313f5c8d3a792f2f924a65d66533d888a5b1a6ab32ad26ead6733ac98dd4f55dd083b7cb0f7efbeccfeae89fce6d5ecc6efb66a462e9ce27adad1db49b20bdbf2d9edf471ab105ebe9c28e81cfb7c523715ad71ac72f63ba35433c54f6c246c7bcab57c24950f4f8a5c720a3c8c20281bb65e7aeb4cfd6164fde1f3a8469de70f1af46550860779d9aa5a2f65a9d80d82913bfb0118e8335b4ae22fdc4b0a7cf573367a6e17f33c5db8e5d98974f0132c1121a59210537c145765e7a8409a318e1309bbee8a114cb7e768601e8a37a82f182e86ff8c0f1cdc63f26308dd39a0cb2a4cb4f1daa27f07a9059faccf823263c38168312c3c11ba5f8b5df1f47fafd28f1a9e28eea6399b9074e2ff56eb4eb0a7bebc6bf6604c1eca6f4db16b535269660bcd4a16a7c6a5c39b1c9c88a2683a1da6479c6e2b47029660f921fc6d0da8c366fec7f59e303d4517489fc16a9f581f6c70419491885100e85de9b0a5327d2269ae5b7227862f2c8733c20609b8702a6df196d22bd8b5bbf295e8845ddd2b7aa63d00fa4d5f7b0ce1b94eacd9917e4aaa2d4fc2856c7aa99eb71e32ee91019dbc99f3820d399701ddfa6518fc108722a9920775cee60210471a2758867f7629c604eb76ccf7cbe040c991eabe5b607c7e71e044dda394713bb954e407d19d0971d55bcdcb1219b2e16b2dbdfbd3699c3b31a69ec127524b265330e114b021ec60d287b974dd712b51e959fa39549e992033ca6cc7f9053825419ddcc8e5c32469d9c5676ad50dc553578341d8cc5f461c24793f2fa58ebed9a2005f66de1c84188d67293594ef07d5fc6ce5ddfda3db740d26d56229e6d07200042d07a20fe5a9b86b1432a89dea6dd109ccfa626a92b70c94b1a29d46d6b29553c9deed08eca6225ebd4ec816c174ab1ba346c42f84c7369cbd984e7f37d76a12495757e3ee85254440cb2e2eb945904f699a2fa5cad97c7bb30c21dfa6865477ec5b8a049abb404835ff320cc057a4dbc199894cdbae098830584493967ad0c788a4a8e214f31bdaedddeb7fe448cded46341e497375145b19456eb360b303a25a3952b972fd46165ea88fa67d7b307f65cf38d25da0a784927267a844a0e97396a1e427013a6b0f53a1100578f1384b9b9c94cc5a2cfcfd4393bab95c3f94a6ddb3e2c1b52945e600a13d0b578f38a717a8044715be2910c78fd23092535cf1c59f98caae66d64753940c7ab143a38ce11be04f0f4eeb93435352849a7fddde8ba48d84014900998cb3a75d7fbd3c9ccd53bcc0f6e52bdb1f47e1a110316a5843103b555baf27ef9b473bb9a83c248cfef032cadfb65ac4f96dc97cf39bc29f7f2882ee63c4acf9da1e881057952f84043a91da463c12b8f3e8d2ead9a1c1b64e46da4e78a9638d78295c2ff79c492b1776840c29b9bef4d9d3fc7979000675cbd1398090c4d95878e715ae7b6e87429b36ebcbc35655ba415551197f37b825f5f4789c72026c33214a4425b9b4af3c40a95835005e53a0bfc2ac79e88034701fc0a6bad7ef17673b86d303c3992cd3b819cf989b2757675f8f31f07dd5876bd702a599f2da2297fc1a20b974cedf8c013974852b95512c466da49b9b4554b9bab5e895699aa3abfb1baf769e5c4a4e3b12acf40caac74c7ecf76111099679805241a786f8f762fb458cede2de5d9c7ef26aad9c9abf248607fea6cdb3c3ad08b6574470a3df991033b9f587ceff0ad79d88a0b85f6babbd437be89e14e7c39d2d61abb0aaec295c51b1c671ba4e61f4ca214d5eaa7736b3a3f04107f0664ff40997c242f1722564a719b70b10de1f314b030e9ecce0f250a99033c176b594acd8c8cd51c08e99476371f129e9a622caa51e04a24240ed79d8ab89cb1aa5fae30fa9bf37df4ffdb7292c9c105997d655c8866fe535befb34a47af9fffab305fdf5522a82886b15fcb172840b4e4e1d2065834750dfd58cced9302a0175f3ba22df51c887011edc92056e86b263b801548767545297f23dd5aac531effe721441f7acb79454f9015ba1a1a85a5ac6d90ceb0f1ecd19726cfbbfe2ef493728821a91048c88a0e5ad9b076d26be5b55cd937ec91a292dcbc13d8d921f2bb9a8fddeae837e724e507ad89946c4b75aa1461df7ab7527de8f9f47a9e48f181db4b7e3540326ad5996c8392ecc1b41521f0d7bec3cc4215999af991b4027cc35c53e9ac3d3d8ae304d877b7a9411adbd7880d4cd4e6d24d774d9cdfe097d8ed2d103dbeac5fd9fbab55e4d2cb52126629591eaffec664c2a5a0ff3e31842c53921f4ec5c1c07e177ed0bccbf7e93edd5b4c53021ff1b97409b0205f3c60c1fe01a4fd813ad7431798672201b336a295491921a86f5f04a0777625937bb9845040fc638782058bb3ee7229f9c8c1e5dda7053dccc04ce5748490aab8ad843cd88443de9e7c6a581ce49c5f4d0c4af3cb840d726f1467f1f94966b75a1c4238edd11341ee8f702f5bf96b40f528ab06ca8d566cfbbd6d2c3fb49433e4826b1ab6d41e93cfb43d152f897afe009af88013ebe79a6f36795db075977af2d8d0f82da066608e32cf6faefe507488bd090dc121063ec1b83318941092a5c48d1683c4d95b363f8a5014d31a472548d9898970efdc591c5bd99f11c3d9feb712d5dd4335574a6b765ea0d1c0962eb47120547d1c571121a366bad7afecad60c94caf16b926f68c5b9e265ebbb5481b8ecc62490656c995931c69454e7611b365b36168bd05c7bdb2c64cf466d549090443508fb9d0a8a8d7fd6ac290e4bea795852de27d182830698682e5702fa0dee35bf8d26fb1524329d4c7e9a7b60f8a97c2281f0ae2ac1720c57df033a1226eed368877afd23bebeb6ddf7e3be3a9e41f2bd1a75bff0c1fd4bbcbaf247fa68679441c244495fcc29168b3b4ada3824794efdf94a4233b5cfae4c3b198b7945ceb2d739c6b9bc02f592122f16b35cf18fadf53642cdbb1faf002e1f14dc3020d8b73495ed2a0b1ae6b290ab7a307de3faca2ab616ca9f8a6ddc45aa8c6dcf9afc021c96fe25f50ce44d26447dc77213b39f5d60ffba88fe79f12dd2298f790306da91c1ea766bcf99a154b2af54ed45ec3ccd2715a725ae8ca21ef777af20d3779813e77ad72c65030ed640ff192a53c67bbd24585bef6061cc2d6838111709ba2293537059b40ce6abbae3c77de156e028321b22c695ed52382e042b56112bd8db51845eb748fe776a904cc82aa5302c59ac9335a3f3c167eed8f5580433299d95bcbe23727281c78bdeb33c7f94158db8c696172de9873f67595e1205e3b047f79a32912eb4c0ccec3385a31c9c27c12e9ce0ad0dea56f2f1cd9b23823af7b74c52d7a0c7c84be243594805aec2b3cd40e26cfbaaed566f1c7cfd9ab0cc4b447742cb7f980ecc577778c5cb8db11ca3a0a361d5b0e3d11fdf63e9fa385c82bdb926e72519ad722dea40c6d0dcf4f9fe697d328c3b28c5e7ac33f3db97b6e4cafb831361d52bb6a583307b926bc8efe6a2eb6390913bfd65268b7457fbf7c538fdc6a09c0f8b520db2619fd1d48e21f2caf4e72b6a52094df1a819131c0c2070f8fbde3b20bcbaede3992584e486e587dc33a22b78d1daeb673be1e1178233d1347a5eab390f76688ffaaf7f7216cba37d3fdce0417f8aeb679e248456e619fd96731bacc721f2a8036776b40ff6d81d9d93151bbe0b7d037972627d102f55afb3652fac316be432fedae08eb6b0f8eb505bb73ae302c41cebb2dcd511b9358bc6bc068eace63151aa180d8ae477e99777d01dfb639f67482c22a8719b6063989a7687fc913b5c32248cc5ed6d2ee63548902b8ebc6310b092a5cd0181520b1867842e85efb5d883bd3eeedc28ae18f7504fdde8f253c137fc850cfa2f0593274a354bb520ffb5f60f6d3f749c17338fa113d1c42667786f6673c5ad5cf3779a1d517e8260c9210394edd9b2e8a307c61d97e5a97db8013933be034418eb29843b7d3406003e3c7207b4de2499879a77a31bef9e63fad27c2fe8eb7d43931729731cccf1ba3136b0f82c8194403a95f73353865472f328f1313e5699f7b591355f867e3cea2b97589dec351bb0915673b6a5acfbd89b6e47af055a6f2fbf7097dce439c9dfdc91bea669e03f4a48084ae769806f209b3c6a9e282f0b56fb4933e70f404d238683e7b1b57b62487448fb8fba26cdc18fedc7dde47426da7cf15900fd9e4484d28dcd0a240ea1ade695df796f4dddd24636151621205ff27c6893fc9c49ae46d081f3e334aff9cb3f4916d12142cc4a1e02e5aec2d38a096e90451e7db74533829488614449b68c9c51f20d14cf003b06deb09aa4a6617d68659831ee5ea0b7d1862e67ef67a6bafb9eb5b3b73e0871a4773fa34cd95a44ecf15c19fb947c58156d79134a90e19ad931ce7d8d9774f983dcba1707a22c5beaafdaef9bf5da97dd6167fe1ab709680234d1c69569e17c5949f6bfb24bb9f97b071f32f92f868b451d0464878d38438d35705643c7c13e2798fc94733abfde388053fdb43ae0906f5c57f763c5d45b6536c704fd99c43552136226e67df24a991fe4fd714f22f2af43fbdb56010a06b7065362af4ed49aa08bf0b7dab1a495a10fe91f83474e40a05b290f7b87fc436de850c7c2d4f5021c24ce8d7427fe4798f34cfcf9a9b4917282374dd3b129cc8123f824f6f6b548f17eeb5299c34a1ae0ac7b6529261be958d81f4a67a1988bb2448225b5f8ffbf709dda6f2dc8416642e1153184d2c47e065d0dd8ac2bff814113048fbb4094cb88a16397dc0a6c8fe06c63d41b5f7bf061230b3de918ff128be9c6ec1c2f1d38bbeaccaab2cbb703a9187920c1e6f8115dd7892630df4841c20e2193520e63f671baa03743f06cb34e98efd5dd70e29035c50de0ecad64538e65c4e78c5ccb4c588fbe55b660406a3d58f6ab8776d5220a4e9460c1d396597d67ecee3390a70c58d3d47119af1c552447e95d15ad061d31acc7e5d29227c750f5fd91a4ca4c2c4f970a04756dd3c40c671588d16da0a8b6ab2b7b625ddeb7b4402e2f27e9b6531004d16e080be7f989d046a68e52e51c58022f47e04ef5902b412ecad01c44cc0c3a3fb6ee305ff13ca32e1b1429f16bc40ddd4ce8970a3e80ea8021d786f591d8be5fb6ce3804c0ce6a1062199cac86d4afc372cfa6ec9ac2e13e16d32f6408f65a576f66414af0654c6afd7fb47d102b15e0c31970d6721eaac6af3b19137d03d005bfd09a58f1c6185c99d85f2135ed39d134c538ff091a09553a9f68cc2ad988a7d4ffacc147d3cc88ec7af878e2d5e010ed9b3bd959d914ac755bdbd319d18a913255876bc0670cb1bd610359299611cf160458925339ff9185a7028249b077050d81c4fad8a76ed896744a7f5ffb4011bd988ac2202431a4db5b1688c78b0069e279c0617e15f1be1ba4fc51878d5baece64d592a118211853bfd3147446fca5e76c8de238c872a016c74c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
