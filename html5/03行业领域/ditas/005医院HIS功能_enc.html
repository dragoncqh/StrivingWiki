<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43e84c2815fc3e283a46b901da06c9196ca52cab62dcbcc5a14e90f6f7b0226834314c1561836ab395691dc10280d8e1725a761fab13dc374a48e5b9d0218a3a39804900ceda9ceeb63329a78e78bb6aa80a51b139cd44ac4bd929a7b40c46fc4109f469456544ac0e6e7ece75a9dbf41c55059a276156511cc6a05900bf7e2330265d56816be2bbfecf40d78f0652754d3578512c518ee292596c604323eafe7118b4502abf91d1c54ab6a46020840b124aff162dc849ccf5c0d0dda75834dbb82b6107c82dbba816b0f792560df35c09285479f81fe08b9e8eaaa9ce903c8631df7f134b39226cdc67c599de8e490e21bc50fbe5227e827c5ba77b100b988b1aae24ffd4722e0e3b8223e7e7c8f7daf46004aa1581a3e598a189b83c3fc84d3c218774382d7b62b3b67efa5946c1bf985952e2b1cc41daf00c66a491d22591fbb8672f86b3787e66c22d511a410f242b65730607c72760ac9284f3c88727f911756bcbf15976f93bc36237d151770bd940c56fa00e207c1eaaa5813064b83262fd3a1e77130769d20e7141b51dd05b25fd671885f0e0023773825fee0b702996f7ec6430ccd1ae611da8ab6d589a2836f2058e7e0a4675b28c88edfc5bc0b30527478a516e3937d7cef20e20f3cfdef891e6ece3fe868b9145b312a5e41cbc4bb09efe07c5988d422c0e86a88debba54dabe20e8c3ca5891378e0f73c7bc79a8a2ad47d276de4af7c0afe7538cae8c48abb89ecfa1f58ee372fc9f15ad21ed0b4465c2b0bbe2fb36f0daaf90fe80a677e280e5c76b3f36bae4f151a43831aacd5463ab8dfa9297e12931c60a306e48f7f70fc78a47cfa61f707dfe77d5f1c22456aaad9c2cf2b65103dd1a55bc1bf53ae4f5edc88be09e4e622f087bfa59f19e2f3830ad58ac9c50f2b5955c6ebfc0cd779291ca17907b9edeee7fa925dd036b36a3b978573cbc1619373d12f378e75ee52e89c9322b2fd18502e1196425a38364085420249f140f410cd8b175c6635b3405b744ffa261981abe952c00a084edc0fc01d38ea2d23ebfb4978b19df577016191c2bb89abc593c7dc388fe3d7c49c413d533f40ce2df62f7640bc104a83e36be65c63d36b7cd7740e0b4606838c241077c8cf2c31971bab2a52a2b2602c76c770f52546a1f06e986d3c1e3887630aa9cd2555d3a7a6e270c376430bc6522c0be0ab4d1f96defc2f45a28fa1c4c7abe38bee075f5b5d66f623945daffbc386b74c9b6f5643901a5d0f6039094dbe0c9e75d498817d25e20d89d2ff0c3e307fa7c423b3eab4667fe299511744f8e7fdde45c6d6e7ee88f36772ab19130f65ea0cf0af56286ceedfa29b54ad7a817bedd4e4735e75363acf0206683b531675e50bf7714cd670aa560af4ef876c7c6d282bf52430634fb2bccb271129659e35ba41b9a44a079522d8cc74886faf854ec22a45c675227a3ded93b68d7889f60c71f57283071935501b79fdf33214eebb90e44a274123f993a395614edd7297ed523c3bfca59811e5a9876997caa5d3a1d4d6aaeb1a822010f7de71a47bd5f081bdb0f6ce9ca8cd7867bff79b82265554699c532d7b9162fde3085b58f8c3239758668390cf6890ab915fca47efd1ecb88626c1c9e50016daf7ed8c210656631d40ca1f7af42ad780a168c13abcee5c2e9de40b32e1646dd3b217238889a732ce682dc3cfdadf92a65509a387dadcbd8eacca67e5495cf48eb3f694b98de584af11ba3a1ba4a046768e6829249b690986bfde6bfbfc9b20d9315c5d2575140b28fd8610c9fd000d6f5823cb2700970479246d70ce67b8221d35769814592aac9ae28ed1040dd522a04e0c000f3903f96c030c41192876a23f110dc438a58a3b8c2b51c424a83daefefe878d3f394061d7e480f7724e97a409e1ac2977ede22a66213ee679c04e7e5b1518a4b24ded6350b0bb462cd92c9df46e44e58a40803b15f79b9605d8e53908855a1bd9d859fc38355c6f6a7590fe9237c4aceb9bcc1726f8b4dffa45ff8c89173caaf70824442286dfc912ae5750a29faf7d7ccc7c8fd9e02e0a6db97e891ae6f731025817436bc27865c6d99867a0b7ec4861565d0580e74b58307b20909d7de8b9cd2a718a31de5cabe034e429b2408b181e1cb8f9e1d2e76ffc0a6314c2654107da18815499dcae32433c7a58664c7f55f6499d7bd175f713a80ab0a33d2e4599f2d4fea3ba52aa818a43aa2b381c158c51169613593ff0ba2c47b3bb76d66820e08fbde1cc9b1057238d50b83e88321564c292e86363fd06cdb458c4e116bcbbeb99816cfb4cb994718b8471e738b1bc8d4c3d24db67f53b99edce3e31f64e1dc50047f6ad6a484b4f6c2137398c4a07f4c22ce8151513053e247bc355070093c927d1df400d220d9a9716fd4e08c42334436442b243178f0d21a836e36960cefffcd548b8d71249164464bd8b89fa7adfeeb50b8d42e769df255a97c32253f9569f97e11370d462c0591e729f68ac07d4455c3fe08a1b22b7795ff5c871f0deaef5c0af397cd29655d9886b8e322abc14c3e28767096ac5d82f3d5f997ccdf0fc59a20fce94d88f9d9e702ad3de26105f8a6d8f1622849db2c3da0b202b59ff52302148a137f0ff808fe75fd0c6a3bb7a3dfaed43fa35be3f8638c49278f6a3f0020d9973a4addf44cb2184b6447cda2b17b1af6b212b81a51e92cf179715bbfcdb761f44196ec3692fb73259ebf872b9aa3d6d5a4b142c58430941f13007f68af53cf626eb26ad2e436a91ae83d0b2fb349333b451567e6f7b14369d60043b58c889b9a28eb488e0356cc3c8b5c231d7e83be36d2744e0fc86ae5a0755925e830c733d1070bc135884f76a9156f9dbf6ddbaa1eaab01c20eed81c9e2eb3aa0b94046513acfd0f1d04c2cb229cc13e3eb1f66d454529858087ee582d5d019459f34b0ff3646c2b42e89c950c551946f7564b16aa0807d87a5152362f6ce11cd775336fee7c6391e3b25d40a38336575a73659a91e1fed885d3a2163bc0920fc39f7092cac99c0f85f334fbfa8f42474d99c064d29a48748478bb48a62b3b529fda065455b809ecfb1196cb2e014d0e7a3e62af4b48b5e383c2c4d7fd2f8b690a57f43370c1afcee5f7b5aeec52d9d93d92c8acd051bc34fe36f16f7c59a30ada21257e94ef260a49156b837c5ebe8cb59b24839efb654a987bb1408a0ae9361b9594a4222a51b99910437c906fe160d6b97b1e6776ea1046f06eb9dc90a55b9c39c8e6b10260c8ee25a7ac93bdcf92ba8900ccbda92f85ca7069a4661913116a60f55d4a02d2e34745b8af988ed110f7a75faafdc4f63f5c16704ef2ca6f449aba230acf3871fae0a4fbe77abca923cc67dfcd2c26d8b6eee88abf134f2464dcb54e4d2194e9ceafe34726c6a7ff82c83d1215577cc448f6301203ebaf999eae4a4b4b08952bc7f0ef290975dfa3c40dbefef9c5494b823c956790762d2687df4b93ea05eadcd23f1ab9fbec9265af43d9aafde614a5d7b08d54c4eb8b9f96682dc0a853b9e8f1baa52c2fd2590aeea045d079bea041ddd699a11fa80c1df51c126065791a93f42b1a72f95c9f24372001f98655e4199c9394c75a187ec93e2e3c2d99c9f58c66c3efb7eaf4304bd7e9c6072c2cacb975d38996c567dcc5bd32f8699b4275fd52cad644b3cefb5415336109afc28524d21c1d502816b247c5246cc4ad262903cd59059dcbb5e3ae3a4d4d053fd8c2f2623af26fcd341a92d8eb72d3326f9df4701b973f99aba066bb8e3f43bc505765a2f65be001ac46aa634ff0389a3ee4662ea024646c2e6e15f2b208ee529a7bd09befda28a1f32d1dd56a09979db2e12ad3bed305103373442d4b415e14518c72d82c0ee86e8c4ab4cf1aa91e729bd52202e35a9a1e406bf79e7fe08a263107db38a5a6d7810a50d59fdb2367cc8a304b7461f096009b0a2af7b8154ae2b75fe3052a689a44aee443715a897d54b7f937760e54a0198bdfaa3c58885f6b375c17f3a8a53b3294836fe25c84026fa555d8916527e384e61b36db80d344352ecc643abbbab35047f84ac9e0bc6c459e1dcac7d185c26b6cef592dac74b9ff686cab860792f03ba0320e628beeeb50b25abcdf3aff49cf8b24e1b8a6896468a35c7a43ef1d37a4bcedea77748a056e2d03789dda2b58392114aaf2f83490d8ea5c22627cb75581b8d6ed499717a5eac3156d9cd8c16421f9332de521e465c0d405ecdddeb2513e53db4e662478d576e73ae10452127d4cdc73c1f3884ac7f6a2cf7b45d9fc6ce09c86b5bc51c2e90128d65b5eed4db0ac9081c6af800eef4d131378c729f19388f021895f125e79c81d3205565d48a1afc85d12013d0ecd5ef631770dd0cd8c1db51725f5c070576747cfb38671125767ba5b9d14c7b3e070184423a15ca471d9a57af7b0887b3692b9b0d9ae3e62291c7c84a0b5949f6b51775f1f26ad843a31b33aceb18bfa88ba5a14f86c69fb5cbcbf64f158ad802eb4ecf1f4d9e93c36b6015118b93a5ffe6e7c35bebfaabec3b3a84471c9d2f0043b49af0441fe566e463f7029274bde0f501fc51d903a7836dc78e80fa3abfb06e3487c0acdb6a0c23d17ef9971fddeb72b0990cb8357c3773466e4a3439e44b1f8095882256468478610888673e9a9f7aeb82d2652f3334ade73660d506c62254dd7b673783737bc00a0470d1d8377d05c1b5e8c042fd9b182aeb3854c259a4361d221941fe3838dcacd9ddddc4cf123040fa17ee9f8d249cdba48ffb71159c278fab7181024876a4ad44950dc20537c212e73c80a8efcbff44840695868f935ad8647451596392227b19474cce411f0125a7dec9524af11f5866671a709c76249e6b4abf3e19b1c7b93abbad603b2e833a331614b632430aae0a511f711fd43306706ec9406cf29ded4f52152c77571cc6285f7eb0b93dc9a3c796bdef5f1dbec38286eb52a64c057b8a0d0891995534244b8e2e0ea76ac5116a1421e5567592f6cdadd464daf71721d508bfba40eee3e546c9c25a976272a62167d248054c29be257a0c398a2ce25bf8c4d902c0c7f173513c6aa750344502d03f2b02e2d291b034efb49a074bf50187ac9dbadec91bf7eb18aa29e274a84355adfe4dc622931c0677c24f9fa09fc6662a59501cc6f42e75eb08efd82282349f9ea83bd9271cc02741de229427c4b636be460ed2739776c63abb7e4e5e4b6a45afc0ef2cbf220df2a0e5e070c8130edf412ed873685fbb2ab287b84289d311e68580e86323804e62fff1024f1251cdcddc26c0cff728641d89bfb4b5d40998ff47e0786fb6b6bcadeaa052a84ad1b3ab40b2fc9cc67297e754e1eee939c01926ca3e80a88fca3f7ad7e55ad2f20b994397a67826557f132886258ca78212a4a582ddf798da5c83f40f39df979018255a4a7692e729b35b69d99db7fb848d0e356feb921490b6868aa34d01fb33cc26d1f57d56b48c0fa07c5a5ee92b9e684ba55f91a04dcd41fed719ec88115fa1d3318e815d1b7abd3c9f95d98a14357b04c46b11135773dad9226e90e130c5c69bc9129d73842020a4705718558554d32c9cb6cf150e87e1aada516d22c8b4ca3e037db6745030003fd42892e6129d08deac1b5f7bab774bcfd409d0b2ab353936d487a597abc069add2e1b5722ff6f643c70886e8beb881376f45c2b555a6aed58438ccc9909f8ea72db11e933faff70bddb30fd1a0b138e834136ddbe837fde49634625aefc08c380a296bbcd9d83af48c0491efde156aff63d9888a3a6914fbebe4a63086f1b73860bfea4362006808d107ca939bee9e03455a39fd801b6cac385e05fb4df61f05d47bd563003b8f3ef9c7fb3d48b5c174a32150faa225332ffe9dee14968362757ff40887a8786bee46687828670b034b76dfb33b8027bf5bb27c1e7688eaed49a948681993619dfc8bfc538205c461bdd76f335a4d8969439eeeb64d10fb48744b373a3b031c4f48f2a8481fa40c7f90bc99e7d8e3aea9efdd0199cee355d39a141871a5884d3751f62eb5a3a0f56f7d6c2379603cbc03bf487a05f6a9e7e765fe6e9f7823232342a09233ed5aae449325cb00198f9c74867ed5fb6bdea0c545f17813e53b9f139da3af5d5ac7936022063623dc4303e9e3d3b675776bf2a2590eaa737d5d11bb8aa194c7ae739c5feb02b2f5e433429208e5d473163fac393855cfbb84157c9484fe9fd8b6949b8053dd07ecb802dbfc43e59a95786b58145c8ce40b5c949d2c1ab344d03b956566d30d196f01e1998bb935327f310bc841f1772155b42d8b7a62e29efd8613eb218857e102207a40d9b8b5655ee5120c254afb2a2414164a0d3bc34196429fe15514827ccbd6a0b94f75d8dc3b60c2935bc7bc3b9e7813443610b2c01119fc6ce212734e3f11f94a1f1e07d8822be04c3374cc09c135627b4b6974dbad3e22e1d2d177b8a628a2bd2d21fceb71f92f9fd5ba59d1c5303fe95a9d20306e74d2d7f269539ddf6ec738389a150fb3addbb1b88aa1c0eb6124b70d34a8d12e8804bfdf76df195a5f62b0c8eb1bf9f46800d2f14b21272052e4bef19e5876f36b8541cb58efb4b1fc2d3de0046b98500ed098b0ee4054b829916fbf36ad4e2221c08fbd3d7ce00e1062afe71665bcaaf4dd9f9430cda9e8df2c574f3ad646f2c9eb152f4e104c6640b12863c1fab97e26b0a7a0a4d3ea2abc6cd33f66d49b5d1b06df845fa7b6f4cd697c5a4308b4360320878e65db89057c74e3927211c079451890e6c8a71cde149225a792278c7d7697e42dc8a196e6447bc7cfb9b40aff1c40839a36566f68dd802838bf2b56eedbe2abf1a2d5e535cab563f5285a9448303e353ef297e099c3eae1946ce9b8d906ac887a404151b566f3babd5235fdbb2071f04276fa8548022e02c6f571ba56673c90927d842a2071ba0aee59612fafc3633055fc7c43a0508b76a74df7afd680227b2e1ad706e708a54b6fa40008090dc204d0fe90a86cc81355fd4280f6973db9756b5171650beea2e5bcc2b21853b7ce6e76ae64d1f2aecef7340b94f79ef9943303bef12646c7a6e6d215cbdaee6aefce6d7536a21cfa92030e26c72d9d547e886adf998bd9562885e6b55d9085f21440129504935d8c5b05867bee876dc9140fc38b5b9d51b3167ffaa7ae59344af818f42135578cec7c6d29449520342e0ef1a79e0031323a4d27eace1bc36daba8b3096f33797f0245e8a861f486ae49a35bec59b964043e9c4a0d7b2ccf8fde48bd9cb13c0a48c1f4c8704e980943c69cc863abb93b6a4a2344bde8f7c44f3db1ab6a30f59f826f853a57deaadec229a0be746f5bf0d0d1929e237657e609c74a4f653a2e748f047776fabcaca1936e161fb34553d814c725f74885f0d4f655f7b4783f7891ad83a874f6b2e7ca420dc1c84ca19d6692b7996efa6a8e4dd6fcb3ab9a315951725086adea57f94c85cf85f5cc46479d51f9b1244c35a2e08530b288e9aa5eb25690e399d839289b42f4675514d3390035f843f6ac39e7c8a3899246eee93a2d850c13980b16b76d407d270df17da627877b325489c6eb082fca7f82e44f2bf82b2ce9b02d05f1b6722429f2c5d2b28bfc7f88e9db94a00445a930f5e4bad3aff1ef4de9e6e806cdb88c8a2e169cdb16c0d7eef2e90c347aab613cf45df517a46d2cbf649de2d9eeb6ebb5cb63a2c02d3079ab11a9294eaddc2a3e11b3b0112e1d0bb1fd4d414f67577be143c4f8d9410d4418a723273bc04969dab66755cb902f89c421c4ebcc0aaa6bbd153c82476a1361df2a9f8c42ce4db459b54db39bb3a566e368d8918aa0ec3a3615a84a2afc81f7d8b782ffa15a9119671e4ad6bb75cf4c43378bf52ff543573552637f035400d02457e76cfa1c5e265f7b935b866dbe72b59d0b595a0487e6675637a609956e4e3dd155d50378b27bfeffee32cbffb1e436245dcfae119eb46b4689c2a91c60958489422bc3132185516af1d8759a54d5096b8d90c6cee36d236fdf9799a71dcd7a8337b08de69271ec9cfbc0254c08e45ad84d13f1c2f31e582032381415fce7d3e328f06bf0e8b8137c3aafb0d0e95ab7bbab0c652d7b34fd31a423e817329c164b40988839075fe45b2c3f7d534ed056b03faac7293823eb3753229551fdc00e601f96c6c2e0ba1fa32b82c2ee9ded5866f13e46cfc9c21be0eaa1a50ef2182783a1b316bb166f25296232b6bae0966823c3fde97216c960b758cbb597fdecd48c70db58ce2b9986585f125048e5d10788a062f7279208a3bdf9f82e94607a9bae50940caa81405f559d917ce770bd522a6300fd363a8115bb72edf1495b641612ad6e82a3a6b06ede31fec957019ea6e3f683757ee3291f87fe29ee0cb71143a4989880f41379dab20963668d45d037f52d874ec615e2b42eb586083da329d28f7f9893886f49b22a0a197ffbaa9fabad1943cf86784064e5ddd0345d211cf07f5083490c17671db42ecd7f038d5079a9b7ed217a14ddff94ae6452e5a6fcacdc732f6d6c96030adbae332e9529298af4a0ed0c55e57a6de722d8961900e5453702654e1470ffcfcf9dd0fc30a1f55c78a8c4e98cca50c48d67ed9bc81d6ce85038a9062545db606e963886bc5e94b6228e69484a16127d578ab13d934f200e8a03fbc393baac3235e39ccdc2c17fa708a95738d9d1cabd6877938f5ddcd6a4b23449ad293079eb51a57e4aa3404ca93d260e85d15fb1ea00ee50a72fc086e802a707854c5219a4d6ccc018b2ab68c806441b04f05d0f1af4214e63dc371661ed0518b938977fed1e8680b315459221d1cf274593edafe8301928ed60a4f5e933459bbfd42498e6443acd4aef88a557238297702cac8869ff85993de788b5733942050ad6ed854cd025403411a8b04a7cb4c277368434c9c65eb9a9c7d72a77bc9e00a377c9c89707398f018c0bc6d618fa049273b08bdca72673e0fd2b7ae52320e0d5f372d78b9c5c3c3619ab7071df39e312747f9c8d0f12cfb1b3a9de360da9481808957cdaf4b4c58a3c0d359cf67f99a4da2c41e06497300026325339d8939582703fde7c680d94b3a58b58fb65fee5356c5345d368126b7c29ec003faa4ec94caa9e9839956e0c306cc86f6aff57cd9199e3f40c6b211f5ec4c0932b219ec9bc20ba6c53352532408fca23d1f1bc190712bea0949bfe8cfbce163f78e746d5e2466447b6ddce0a69367207026381685bf40563a138bfa62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
