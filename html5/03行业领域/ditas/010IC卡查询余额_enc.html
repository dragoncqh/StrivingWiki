<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"753a65ed43af733f7da22656f3548adeaad909d43fc866219238c7f37c840881dfa21ce6cb94fdac0da96bc5ab4d8cadb3e89d233ba13c92fcb3284d70c0b389c13d363f650a512310996b279a950177245f2ce6eb8651a14690d0bdc5b81afea2aa86b4f72042c428a99221155cf4a0469b6ca5cebb13e0ac24813f06f2379b65a001e3dd410f0fd61907d07e467ced59e5f7c615ee681a32b64fe6ce1a36a0fd3374b96895be24e275266f025a94ec001b7fc7c8a404a0b98bd5da90ab9b1f21c66a7fb84134f232d812cdc8861a314174632351fdd60553a04ec6cf679245b94f165c5b459a05758aff8b64b5af68164442b0c8d836a70a220eb39d2b25a0abad77a9d8d435536e046100d2c607b38f36647b0b5e87470e64199856ee6e371bb3ca04ec16961f62799e7691ec2be707d3e7414c84f60626ce9fda0b161a2f45fd4f375d38aae83459c3c928f817ca981d70a890a12e51895ec50eafedd9dc155d34c00cbb9bfda13928cadb7df47e5c6336dfcefd640c5a07bc034042549c0e9c14352c3057f78696cc1e192a20bd766689b9cad7ecd9fde99839aa39a81b60603e52b05e1a8c91b4a5d64a21c896c0c14d062ad1edea8c8351940b78fac9fc9e31fa9bbc5d5f05b028105cdad660f2247a9d297c7a90bb306e2ec3c130f4a14980477d64bb45037f9bb89898de94ca60d4adf35b1a732b8f952ff199008548d0ba2e2c192eb65e3a053b7fcaa4a36aded3ecc657b3b9e14eb343e062c3dad0c776a576a3745bf38a4af899164d1b7d0f4b75f8e78a9829686b63353954b82a9f673b6e865a38ccaac483562fc0410c67f9081f77253f43a8a84db11ef73a8470b26db91d78c70b10cdfc485c1bdd78ec0e40010618a63c225523896d8a051bb374abbad6262b2414d8ca308ebc69e00409d96f3150aaeb8047424ce7eb0cbc2e4a26a7dcd89fcc43f907a0de5ebd62d4f5cc321a9cfe35978d368dc4af94b32ed3319993c3522b4e8d6b221cce7c7a8d5e5f694a1e4168c5573a6cb9bab9f54ffee3fdc6c4176b28100bbaceef1741d7dea14c7cabeee427ebcfda9c634a4c30d977bc0cf60ffae05fa064bfbf122a9fb45e872921d1f79db290b593ca54f94386cef6f92feb293d5beec6be55c73382c5841d93d0041b5577fdfc536b8437197845bd6426ad0506628e4539a9d81349fc968938990f7b07463869a41e3859f8281b73eba45f65c9a834d4275a2b8978d62a5f31c5913919bd67fbc60e85420696259fe4403abf67f9dbeac3858dbd079e28959a4cff18e868d240e5dae9e9b7025ff7cd2ec2a2d0e8135364422e61d5baa3ff07fb8cac3c7a8339d3bfaaecd433dd55501b7bc2d1e8a04b6c5245becd160905fb9d66fb19b937efbf8e3ec6196f325aa97adbed794f1814592932f1a12583a084b97896b18f61939320e19f31999953f46c0ee095f3478750eaaa1819cc2ff5c9ec8edc611cfeabf201433d89961ec7b454220082a85278845fc2d18d7cc6214b5af8d07b6552c7a2771da71c5370925243e767cb9edd14a3d7f4ddb2b0693882ed7d2a3469de4cd2423fdb53fdc31de0c5f7c5c000035da61d656ef2458ea4718d273fcb0e76bb4be56c4e8c5346eb812a856776a1ed35ae6464881d03c9b8159f578128ec3d097ee359253b4952610bdc86a7b1c2d6616da8aa66f370c488c365e3067d1523e13657190c75a9a760b131c73a420c1e14174271b88882492c2dddd1b87cee72ccb0be0c3254303e48fabcc308cecd0bbc03ef4b26ff3a19e803467c2b22df1796464465302a77472e0781963e9e87fc3f3e51622ac5aa78acdf0331aaa76f462d2c010ef6d3ba1d80d5fdfcce071007ccf99d96a8cfe30addafa199aef10f0a51b172a7339b78622c3c710ef5626c040df220db1a9d2a7d4b968eabd78bee88a5d55d32b0cc438ad41c8468f130c9b47234e8cd937e02c47795127cfb4d0c47fcdcc770f8a7bac8283d60aa32c496e7025917abb80681555b40ffd261064211723f2f173eed6a4537074f2de27b25722e8d7b48347e5740c036c43d5ff261b1ff995b6f01656e28cffedf1f10354957db797649f03cbdf44e2f34ef5934eb9333456da4ea568509f1ef9ba32f0708c5110b5c40e9ccdc30ff104fe9a544eee2115cf989e6ae2036ea0c890a8f11c2341675d97d6fc4c744cadf7d5a1d2ef43def0b2c80cf50153cbbfc1eb15d18f70e58c3d8e774069d313dd18092b0454bde780807afff717aff305b1caa63be32fc23dd53bd036e054fc0282db5686a6f9593cc30ad5c4f35c10ec39162698d00547e026c766c66f8e2b58c375b037d4370bedc2a0c9cddd5b048af1c4c92a698991cb21fc766a19a84437f7b1b24c837e9b8dc7598279ef4d8bc6625b43fd4bd1bd6c9ff612261c3aa67773b4d02a210b42bceadb0d474b513685a8113f835aa0b4ea1097641a383529eb011df6eb999c31120b9b27c9a5ffd1ea06e8df14842d0882cde02ea9a6b3e961cc000e5b54dea9a4c376869c72a8fcb96537db70efcaa662522bf2091713fd7a31376ab869cd073e7f1ad3266e25dd521e940bfbdcb886fcdd931f894b135004e204f223b99a73ec85728f23226149908e483669847af4954f6b85ed07485ce112391b7924e69b097ff06f66718a953a16e76d4d9f085eb30351bd461e1dc94a4c50558b509920adc217626bde04a2736d3524a81eaff122df7bc71265e2627c574c5102fc96e4ecd90a37320db361e5784f408346ba9f7f8d105146c446a91eb731813f133b1e050a90ad51d03d77247cf591763a7a80c9e23c4c416690a0fbbc77e231832cbb072dc82ec955c321940aa7dd8347cd6eec6cebd361a9900f330ec7dfc942d2a9063a125b591140c73d57fd2975c6e4f633fd8ad6497c8f96900cdad9825b8c95c04eede16245e7df256def838c8209ad4b1022270cbfb5bb6bdd6abf0430e58c9291890bfd4e698dded5e255e1efa300010af437725baa352c5ad98ad3159a4b8cbc632ea53cb426309801c97e9b8e4c0feba2d02434b3aaa073506f032d557422fef4e422f57e1049292284ceb0e8bf39a93fca986cbe8196f850ff6e20a2bd651c633307785d8a4805f0bc2866e1b17d6c006c3a333c642dff3d06433c94c1622f8c1fe7be6f53efc92634faf5da42790dbcf56837f4028daeeb30aba2b61c82071d292a4408bca2fc770ff522ac89df70a7c9ab16ebd7f7665bc1cdcbb0bde95119d398ebe92b040356faf404c73434bf2cac825e01a7b562452c63e72b65e6a6f905d43bcbe66658e7cadbcb9ff9a8dc9f1cdfe4b4b10cd87ca29b0b469707e077c51bbc2d9956408a41f094e1215a79b43831ced0dea96b4773918e1fc863752bde38438d2c980e9f1c74f6aaa09a0a72f9236954590c485e05b770965d17d357cf84cd3a8323f3c51734d5fbd2cb48e8d10a0c1c456f4b8fb0e3dafc5162c0937788cd442eff9c8ff6f4df3f997e73a64f7e12ed84fec54367c3981c0a29282061a8d4543f91ba1f4caac802a95baa5cb9b1bab5f1fe332af7826ec086e63a7a527b4a074f8a3153eaae2493f8bfbf3ed339595e5ac655f6bb06bffa37e84663e2c43280e91e8d50fedac3fe475ae410ba73773269415502d03ff4d11c022bd795b76f75b06cde2eb2af47daf169162d7b610df5c8ffb2f51c22a940e315ac10a966e2a1aef94d18a5c2f48c3d866a7b5433a811554de56de30d9ae8b83484e614333d34ae9ada1ff4f81dddb521e2e0159cd27369bea28da510a2555d70aab5aa49e89313fdbb0183fbd7fa724590990777e29ab02935015dc392b0492f4277a90037dc668434d1312c361eac439df8aa6b1e9aaab36c4aec71bdbbcf2d729502370913ae675093e01ea60be2aa23778e0e62bcfaca2f4b63d00edc33f3fa9abe8e690bfded771d5d92e9a7e7bbd16a4423f710f1d094e0b8b95fca9e774e4e9c836aa1b8204f520fbe05c9ef14ec88e35d7d0fcccf091ade1c0aa6883cb15550f8d98aa5b7e6a6ef878be70d94e0e9ae4ba9a79448067179b4ac3fc6268fba227f492ff9d87a9e03321ceb1e8fb42d054b0c128a320b2dcb4697c5e2ec1951958e419ace08af812cca3a1b6c9ffcd809d9316b82fc31e36417cd60ebe3d3042cf2d66406f5bfcc7ae322fe1fa2e780943cc55b61faac97af2003a0df2c120cf6700ecc5feb64f77301bcc97626bbc2c143df8109380820e2e3158e497667d9228b888c899b2df0493bc02cc7d0a4d68b593a3e22aae960663f6727ca090b428dd831bfd3e0cf7fc749d095ab676d9edc27376def34ab9bd15c75caf835bc903e64e5216ea37b58a9c3ee13f66fa672892c8b455bd59b000f2fe02d8d94e1a1b25655d877083060741a6eb1804cd270898f2ea07b7154e846f1ef8ae8e0e2adba6cd61b03d181832cc14b9cc952f4316f3023829fcfcd534dd59526790b06f7e5f4e80f8185e8b8ad62b0e65c9d03a630ec0f09151efc2bcb72005939120b10b47aba2b9e4cb0825176c1863dee25ea340c4a8d1b903922f46ee25a1b88680fb82ee1aed748ea44e4cb2b7c1b5ebaa15ed44f010c37d1eb9687c4ebbaef6e16bb5c65488c2eca3566f285b07907bdc107f1e946f3e60ace54cf89ed7622d0c3e1d6279cb0b3a1739fbc6a14cc7e2bd0a942a1fce8c72c4fb901f0071c61aad46ff9c6d2cec3300e05eac0d8d5878c42b9491e25e29f1f7ec271f8d4efab33fbae9b70b636322040177c1a33ce600f407011dde5c922824a73bf3157b28b5b0a4caf363fdc7162d801e5fb0186563cad8e237ca24ef94ab4f6f2da9e7455d34a7a83843bd3b582682430e0e1847e1aaa3d396c73c12822e0b0d6b0a2c025f6ba1406b87712e25d6d852ef0a73902db2546171b2bf3a52e8690e643f782dcbec5e7a5e933ce41d21629d4e2f8cbc9667839d946b1e03af4ac04cac519845028bee96bc72b24c7d818fc24999b3eb3f75270fba1654c10113806a17b5905963f8cbae82a0397a3398b8577c108b32a4a67f3f29cc8df2f3124903921e2c6af0d7186e9ab2c585c66fcaaf4da72e155a9e5c2d72e67ed72d519e41185b0bcc316c92d89f0f18b3a536ae937a62416f36dbf398e9a157c369130dff0bd090280306ec898f38c65c0bef5a1649a7de4a96cd3378bf6af10ac58fc802415ef3d5cf794ee98843c5cf20ecc96a6a5c36a8cb83d641dd2551eebcbe3124e8714548a57f75ad1cadc556161a29ea19eacf245ca69572df34c596644a9b30c4c8d23560769456f2f96340ce64e8c33bd70867a1fa4a0355ccaa916eb23a6c8d87293c02f26ed1668f68098998ee6619aaaa7236b3bc704e2f000b5e50987b870bc615484a967be5c071adb9ae3bb39f726c7f2cad82e5905623d220687a65bf6ab82dc7ae569d43a41a01dbc634a3007de8cc3807451fe1c20837d86dfad5ffb3a239bc444ca160fa376b0e98c28d28c4ec90f913b62dd3025e895c8aeb32d01b2117df530cf41ddcc4184481dcb8e3ad44e02d31964734968fb8a3f4f0f6cd997b7067d861f4d9fdf3dda26e6eb6e02bbc83ec580293c04fb767e63f609a9af355033ae63196112441795540271824c3c54a124e8a7faa57ab9ba372ec4262a930f2d24042e1e7121885fd7f87b473698cea0c19d0d33bcdfad8413feea575bb2d2ceda2a06c9b60ccc664043c52aed4a312842736bf2fd94352ffea1481f303b99e3764bcb66ad2b009bc8e7dd70f8f0e1752bd483a5fd0f35e588a81f6d9ae8fb435673c279c8f9e9a39475a1ac17d04776b27520233ee0c40310cb62c9808e802786ca9a9b7b5e1b5089382d904a67597d9b62c693f06a7fd548a7ab40889ca79ad46fcc4931b0f42e86c7d46bc600eca532d2ffac70b7d97b892147151a9f4d2055cf646910db067cc8ff5f1afaea069f130d5da142ad0196b138c035f43e1e852d59bf65c57026d23f66171960aa684e5895efc754ca7c5545349ed2f2ac8983bcedc6be0e40d2a0c48568b352b92a3debad5f0970a1e721632461ff7a0c003b883a6b0da3e56764876ee877edb114bd554ede0733545f2778b563a13995017e60e9e601510e1694358307bd20a6336639542b3e08312e53dec9f8064f8573cbea0cbe9ac1a1e0d22f0143f3df02e039a922f19b395aa80c1f637b05bce4508cea64342e677a38fb9e7b36bd54133f9385429ae643a1d388cf35cef8dc803c906ceec01cd8c6dffe4c30170df5a1e8846f87b78ab6fbf835eb8ffef959c6c8d48ac24a38f487652656673c05290a7eaff5103f4e744ac65c3d77e280bb6fe270c0ecf8e3771facedf3e91cc8ee1a55466585d30523fc66ce304ce7945331cdd1760ac5236d123c7ace72be05975bb9447ecfd8f2d2c45c7b5c218b3d42f4ebb361bb3919d327698a185e7d25847d4a854966cfb51e77d084a1758f424b99164202c9d0cbac67737d65753c87de32e42dc5b3181dafae2b6a11aa856472aaaec7f139abe7a613314d6b1e6eea49c86d1c2ef6c923b5974e8d4107df103cbbbf51039d2ad32e253f34e5d524cc55a7d2367bd742f3ef4087c92730930eec19f578028872134afb9b4e98bbce2c69096eff65e9d27566918cae367d9a3134812c9e281cf5bf8c222b80c0ed1af6c43e56fd876d2870127085eb1601150d9f141aac6454eeb391cde13365756cfcdc3e1a5527ec5eef5e972ffb6bde01e83cb77045dd10eb190e0979a2e36004414fa18ab456e5374b2db26f09dc0ce34bdcf91a2860247f49f3a62f3038eb868088ccf94bb22597ac10d715e20b33fe646c2f6836c0ddb879f9808947c761c5599c595a711dbdc7c0907189d0370a77fb782efcf7380d4653afca95288a8ba3cc0782ffd78703373fac6da8d1ac8c8fceabc6a25c095e24e7308f11c826e1dee3fd66885d6faa83968a43df2e33bba05097c59e4f94f7c714dc55339c4bbf76eb0139f9691a6173b0a35b09801b2a00c746f6efae256a9480ae18e36c8e82ad36f9ec4264fa92238e4db24462e3f1fb908e90a741797e708ad2ebe1f3b9a92b9fe04466787363e20fec689aac8d8d5382435e2fc245b28fc0f70d53bc6a613712e9b4cc0c0946ebca7ed87d2d78af1f6c375e7bf26b65f6037a57873597d4c625299dba3acf13fe4daada89c860edfd1b21f3ff74542ded0f10accf721b95aeef63141651ff18dc892f894cbed4c10e26afdd970f7834b3dac5dccc4a17434f8c25a30fb99566c8ff4a0665c8aa48e9b2e9cdd410385ab8cfde45bfc03c70e5f2674958573f5e25abc5efa7cc1db1e6e37478f40951189fff739403437e2b5ae051eca38e74ce74651485fdcf9b4d59e0997b6ae8c128eb961c2296cfe3fc08abfa349ed6698a8a6ed0fde6fe33786a147092c9cf3a144bb5f4a25dd0e0a1f5bb19b0776ebff398fb754bd44851c11d12b3358f5ba9274e29978b23ceaf9a4aac4c4c8378cc3900da7298227cca0f8a010f9260a8d0f9dbd567f4f0aae7e58cf2c7bf629f3129d6da76b16946f9baef3283cda4baf592644b801d0dda1f7fb6594782790fae1bff9b874b816ba4cc5e8480f5bb0194d9bb7ca0a2447303aea25abb66126e0ec174d5a89f84335c9f73b49474ab89d163cd76c54df002fc3101b4fad23ce50e71e77d5705093dd2c2796f2fc5bf846ce07c63e9ed5ff1a736e9fb619db014e69ac459f4c0442d999e1dd595f70158c482291ac70dbde9de9f1e73bead9b1b5b85c49768ebec765b079543ae7cc901e1c6faa17fe4c0ff4698ef405280d9a5fe01d500b8e7dc441eb1053b8e3e12f0a8db95244c9d28270fe31e3f0427e347295f04fad486a1cef069f7ee16afd08487514e7c5d904bc9710fecdd5a62f804b387d2ffe28f6e7e8f5947be5ab5898040db12641ecd2a4e990a648fc4f9f457a006e3bb52d0baa73fe9ec34e8502f8072a5c4f372f2ff28265ee196dce6b56af959951a491396e00d96ee73199ba3cc46a16f0c59441362fb3a14be238486b10c6edf0dee05944fe0ba4caf8da473394ec297f6da08c0a4f611c8067f1f73f02414c6e518d3f3f0406e68d86de570fb5c37c9a350b25b22533e0cab1c2b0f06bdf8141baa2c631d9953592bccef113fba894fd74c3034de4fd6d994693791319e59068da08fc2fee8137e77bee6fb18fd32754ce5f628ff5f44869b7d90f1293d4a67d47d8c3bc9e81a69d18b0ec937a1922772ffe69d2459cae402fa6cdcbcd09b8aa1157727957ad4270f3f65c11a4715fc6d9e5d9567c7b40843c3ffa29faff7be947526b56b20e32a5ac804ed5b6ae17dfc5374d3261a1272d6ccbea194be963ca8233f997f2c0bd6eb534f9aecd3f99414dacd7a7c6e12f40fbcdc5bd2d43d4548209e063891114079406e6c89d1532e9377d93810007b30c4d5aa018c60e7ee9c50f6aebe6b83592eeac3a31afcd7d13b54082fbc92a2390d1e133ab62111fd083b42ebbace96b8bceea0f88c406f4331ba45e1ba64dcb14bfed613b7c860f06d67bdefb6254431ad2408f794f03be65b22ce8ff8673ad7a6c8b16b7216fabab9e724bb0746d974cc9ee5e8418104c8b228e54a74e7781846b6c4ed762c8797c777994314e00a0f7837b963713ff4ac5dbf2913399e6a914d9661671b20d6544e2e60989e4a5475049c9f1e0765419696c7cd75794ac77f271811a29a07024f1f7c7fd54059162a7ae5970db8b8b82a075cec8f4989dbe64e4d04d0d5e431ed8fff8aea18d43206449ae7aa0e70b6cb06c1d4dee302cacc74044b924f3687107d4080a7a070702b8aec8844f6b0cbb78ad0cb8dfbec79fad035e27aa06562b15104f0efbd1513cc43683aa96be0195aab05072ef472089fbe9b25c7b3ad10b02416b31903fb86960f0d92d3faa968495fab4abdb31416d268f31b4daf47f04cf8bedaf09927ab101473b92022a3754086d6bc624ef2649a1aade29db7254a2ed525d85b7a7e94109b4ec9e2d9f70098da2b25f32a4dec79c5ed272711ebd12bd8c2df7959e44b5a6bef1357a31584b8b08c12c44f2d1c42018fb88d81cc2be647153e5ffc9f3be86591d53c414340ca521c331ca1d6e163a0af5fe2b2abb2a6e80211ccb43c72ec7d3061940429722d76feaba95440244d27e8c571ba5b2092224dfc02a3b6790ffadb3e6615728d9ce5897d62c54102fd552edde914084a15c2a51f695dfd124f0d28a4e48b6a4e366b5f8387103aebc9f6d3ed7d66e62fdbe611652e1fd24e63cb59fbf7aab4e10d612f85d9376f373f34466d791e64959a876e626762f1ffe80b013ae932fe4ee33ea618192e5e530e68596e190e974d5f1ef661a1a08a9993df46de977167e055092b2b7131042f127888426f2e05a603d85f237b487d5ee9038bee3e530597e2bd66460f9fcf163036dbe64468bd8c59cc1a5023c33426a739a9a159e721aa181f11779ffe845c1602af8b32489d9fff97fb7804d13e0ff35b835d172c18ca1066c56eb3d0a6aead7795bb9e5e318f3f2405d28c9cee56b9908b3dabad68059d4ae746a4ab33b0e7ad9d8da20afda6f54691f70f51d6c75cc8a2bfe63981401df7fb2cbb3904005996ba5fee02c869c7bff3ba9792c2e28f68e935ded57507e6513b2dbb640c126176fefd4b85128036435f1fd168042f1d8d2916b8dd82b384420a4fd5be5923c9c4a1f73dc2214b1e38fa76fc4db09200e1d5841a864a45780a7c5d9b4bde525e5f20ad05a92cabc1a70a9a7ef5af83fc941895551032c26a19b58e93734e22b19c0d353c414ec31183f239086c8807e490c08038e73cf85f37a0667cec46a131ac7a009a76e2fa44aadcf18e0cb49771996e2805c524d82fd586a65a176825f17028baa0ecbebef21135314778cf39e7432c63f80e806fa1464944d274869ca032837cfe8d279121d0854c0a4e09ddb456ca80b148417ea0d4d22240bb63a91b94a15c2d6d3860bd4c702b1e83aa6d11e0843677f42a5c4ca12f1d2b97f5ceabeb607c0f94bdc90f478b93860f4f0452c9fd4c1eb8a3e58466ab748d4177a7a420a928a2800489da88766537ac9a132d5b6f0c347372effaa8c71ca1d03bbd600fe2f5e6706a3420584a230dae63839f0480d5d36c2fd420a45e753c7bc69e048af29fcaa38fe95d6d1a813f024b09e663dff8aaf350ebeccf88f23fef532bf26b241f64f28d70aaa7a83f0fc24624d35b45a3e0f87b0273a8f35bbd75884917b6eb90c53d12bf17f50df8d2475bb3cd8bb597d6fc4e9445ef1071cce5be3501a9acb14203f8b9779725a724ee6075ae08061fdeeea3b651f848643b1355f46afec056841425cb1b1dd9d8b0751279c1723a553a765835824d6dff8d8ed2937235f0c9b29f2f16e1443e67ae1b38d2a965f80a29fcb7cdc12ed6576d7c53afb03ea6537566e01f51c2e5f6637a72f135ef44476a57d81776c1704321ad8488b6f50fa69a9c41bce23e1cad3fef78a891c68f02fc173fe964172ac5e03851ebab621e944f9e0ce6cc4cfd0f1044800fb2fd5cb5041db6ab376227ed13856a5bece4aff8e7c6571fe7ba354a4a33cabebf39009692250f75108fcbb63af5a3cde946c6d05d47d12f8afcb0787b273b3a92bdb9f1469b049b472a148af1a0f4bf960c11c2c1268cb7930a7935993699006fe9cafab05a11bc99aea71e430213fd9fad5c86a6cfdd2de21c3b70aa92c3581246ac7a6687d8e8469145777980bb658af66df318fc610fd53e72d043dd4d50ce34ca093b112aac099c7ad6ac20474c857582486379d258f33e2e797d894f34dc760cfee559ecdb4c5374c902fd06c35e70b1592888da840265bc286b5a258c74dead56c1c999359fb52b5d0098d727282f362044d8ccb4dd38c7d9d8bb36e1f0644d78760e0dac99cccf7e0dc7747043c37f6c94352e01fb49f9468e6be281ff881c6925e19e9acfb515754a16338a823e470e214419faf594ec743d1a91c25ba2ca90dc8cf72982d970c7b5b20353d19d86edf31977308d2685f342ac941ca860d33170772c703645c437edbf46dde1231f6daa0694d30007f47cb96293feddd8d00ab1b9c31d0ab11e722db6d76a9bf5b90784530fa207f6dbdac3945eb7d62dabb103c2688b92789311da33fa5ebfc27b269ff3ec4e83b1faf6b48409be3ebfb5476ec8ef52c41a88a2831544f8c1b4425069afcc0c0c9b2ba22f7ceb747ddd8d64c23f00e10752838f63cbd6fb71a0e9c918555a52df742eecc513725c42bca6e5c90becb2c76be8421dfccad29f64650c75d35010a887ff633650f5ecb17c0a3b9326b1df8fa3e4ed6d10026d8e2f106dafe33272c081c94bbb2acf07ac082a1d9f697df439785dfbd85ea81e22f70a7f62e2f761362292659278107ae088462d58dfadeb21f5643ead8e6f90d39ee78a6625d3553326287ddff80a7da83d576abfa5c1902e77fbfeb7c637f74d24494a594ffb9555affc0af1140a5cb4b4b8c19cc999b51135b7beb514270580e84151225c6204daf0302c36fea7a751ef4199ea85093b832ab4e8b004a18f18a5a4251e57ef8960fc20001d291863883dde013bcf46c09c7aa2b0914a5ccbb85c09494769edfd08981fd541913d069240d4864a801773f0dbad4d440a95a5b0d469923198020fa16436b5e2599ec7799d1f7680ed73d1707acaa9e1eca800fdefb6d77875d989512b88f1f7478f7d190d6e04647791451958f799944eedfb1b1d7025f2ee6126d6bf3223876a1928a53b61fc14869ffb1115cb856bd98ec0879f9bcde61d6139e20623c90f316a267148ccb59dc630e1afc4f8e29cc5ff407e1c01567ca10fd69967bd8ab74d5c083f2d11540dadf5043fb155764b2a860ea1ac356a62d6b8c443892fea396f121062fb34bd899c3337f71b4931039ffe5557b49c1130c96bc0fd700ba6f0a4ebf5d66b3562a0d7585e896917ea171de2dce17e534057e3bbdeb57d1c3b79f6d997c0f402ac499002549","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
