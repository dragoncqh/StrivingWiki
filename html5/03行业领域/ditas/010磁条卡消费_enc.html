<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17affab98c76ce92e3ec9cc39a4e3b51578b0ea71d69e015f136da6dcbf47eb94b1106ca4c0dc60cd6e94f3cb0200ead2706635be07c410ad66711015fc667b1d56630fb7cdf00f88425050cd9aa0341d8f0f29a85735ef180a510280909b46685e14b14e7729f46c903f250a4efc0fe65d4c7f869d6805072055903b971fa374b8e440957fe6bf21c1df97941816104483ccdfec9d6cf20543f3d68ca181d0ed5fa1e078de10d0381429c6ec60db9e399390533793939859da195a3f2da60795ad0b7919fe09823589ca8a8592a88acf16380eab30e3afc9baef3e9ada102ff57f090f93cd71b9cc333bffdd597c605a64db6dd2cc9c9dd51d6ef084780b4553dda1d51cd75e4611c3cadd7a03d183ab2c1d0c9ef08c10454d1cb5ba184f36fff61cb1f4ec1e7af32a84ae0da2a03f882648e509a35f6c185c681f08886b282337394516c867fb6997570fa223c3bcbb27efb9799b9d234ae35613510fed54c319113efc09de6c5027c48d5c8c6efe7247a524a9fc2bae061fc5768da492da3141d951aabeb29b8ddc48bcc6a53077790db7c3f9299ec426d82d6e3515ee9783580c2fee9e28bea084efc05fa25a8e6416a9f39462a78d054e1c971a1a1672f49ff83765f939282d0aa4e8e1cd11313af2cc27038823bc566f428f6e5cdf9af7f0b380a936de9dbe9f5d0bb059f17683c23564b91889d4bb934555d1145e6d146b311d9b096224a299f5af47fe8061ef9329dd1e5c685d3b6c4ad777acc98fe3c6dbe5f1439c7e483baeedd9ac5d60c67740d792bd8ba647c44c313f4236e235f2a92353dc5ebd299d0ba7c62b469c4844c6bb2338691d48fc01bf7e77b92bff33511d0e8b87f95cd26c1dd20bf06980ed36ac0e0e233366cdeb9cc2f61a45604c6b406e8e32fb8a4a07f9acb3cad4e4a8609118f4b12cc0f4bc54a8a7be35c0b09f7c46948fdb2ab7e866d109d46cb0309012e19a9f01cfae248cd5f888420d01d131ea191bcf6a763b32f1af88f1a9b5ee11b8aeef860ecc04bc52591200edfd09c285ef223763f80345509b794a4404f4b5905b82f92c9695564ae243ea2134291c16350e7d2ebc95573d62f4843fc0316d8b04fd12f239001d66413f4f774bd7ed69e4a3f77ebd221317202a1f946981b40862f13eb79d230f67d6df1f79ed255a1ab50db14d00f63b7aa63a7f76ce69c80951b11f121240a35a8f020050868cead76f1e80bbdb33f62eb679969115752a2f53720fc0533806f00e321c8b84d1f8cbf305df59fbe1e24bf04157860e23ca1459b4ad8f3a8fe1b128b8d49f3833efb1086a577e7f50416e20a7b4295d8549b86e90d04d45c1fbc22abed53ebfc3d418fcd809f973c6136297d0c2b86afd737f8c39cdf3e2d6568ca1fc3b6e9db6a200c93d26fd39c5b822bf3cac16de82e548697c125714ec9263e5d5eca022d582d2ed63cd4a9472508e2155a7ead0edf1d768e8be9f034ad09b5867d19856981ae4328dd56be7cb63d05765d2c3619cb23f57fbf3050c825c13e185f46ed69b67eb8b2716c2b7e0438825e77cbb2933987aeb72d39731f77363eb0cb17f740c8e591681e644d808750abceab84fb2266d765f5bb6f151b907692daef556b65283178adfe68d0639f937f4af336394e2380cf89fb68a89823e38383ff6c59a2247bbccec7f9e92cd115aaf15307d926a85ed742cc78c233f5805703d17f1fb92b070ffa09678019b93971fa3e90a50cb05c2201018f0c09df6cd499709647cf7a2f4485bb22ce3441effc359364e30e089cce1d90e43816b1833a30af95c69d83df3b546d540cc7b1e14cf95ab7adbe277ddb8ff47490b9b6e27867326d505a7b6b502cedbd1e1ca44bf4289939b5e29b822a20a7dc921d7856d68d49f690ce8af8d4d6ee5204ba5d4e813f8b7975b3b89b80bbd23661d0f4e0e201bd7b2718c3ae1f0f8fa13ebb1257468031af37b29900d48b21951e2411aae763109250f1319bbc9afab983ae35adad87fde70d90e2cea6aeb4ed2e4ec5f201136fcbae4fc1f7e7fe066313c538887b13945c9b16da1e874490e1ecf3809c66c8968a4575516c9dc9c128a35a8d87ff0e82d6b5d29c3f43049d3a38b4b20ef6ce2a29cb73df3cd817d22f071e875d1a3781eb8da3c9a916fa91ebc6b28051963ca5c1ac45f7af0453f421a073be384164c8d42cfb83eb40eea3ac498af5d8fc8e4548938b1fba7cbea0303c59a0ddc8e1ded8d1a93049d0f5e716fdb1f98d9de3b27d7f9975fd3b5ed824923acf39b67d6f14e2ed05bf76d11adbed57b4664321fa57628b914985a4dcc74667c0f69973d3e6dde44c399ff164ae1fdbfc862419b4b11f97c3f00474ad05bca11eedbe6221a6a35ffa9d18701d6656d08ec9f3bec3ad0ed2f21069127956ce9de7b06b825696aab6cfc3f764f3f5d06aff2d2b0910a6bedf2dde21a92e9bf324ceb089b322cc2685a49499611ff4836b3f56140613b79407f3253b08f3864ca20d4d49a917c190bc4b8b35cb5eb681650730f3a119b208ce15b65a9016fb35408a5bbc0e605c7f22ddbcbe791d32c7a683a5d347553bfdd30cc41578226a0e1c43b03b3bcd5f1a5f3c786221d9a2965a040e9032243c314c174ddc7f91c11ffc4a2aa84f098b7df09f27bfff8756ea3dbc4c5b8c0b5239b6755284eec5fb36e8027702db31fb107867b9433bd6f4dd6a3582644cdf2d028e05c8bf918ce235b7c708635ef35bdfe895d82183a3fccc56f5a64dd23d61cec02ba9d9ef0cb0432cfd7c3302bfe61e279adfc9d208812efae8568d7e98719bce2d74b39a87cab9aef8a91f548d9797463974e581305cb633036d864039833420ea43391fb819b2c8ee691a05ea6eeb7858720a15f908c1619e099f9f0662c4cf1f580f73732c275ee258ae3575858ec7aa79cefc0aa7103a5bc244ca6f9c10f8c04c60c9207ca3cfaa83b6447e4c71e1816e4cd6a3d140a493752a49211bfe1a52a5051d5bc1a348223ae743b9b3264cbf6b254fdda06624121e97ebffdb4a9b0547ab448ab20c66f05a2dc33ef785aed0b9b8f7e5a6238b2bbaaa0c4edc1e64ac8a941f416ecffd015a23d2b2049f9d13d1bf07a3b223f64de48e10b8730552c44f82ba87130b474953e4a74e0f7fe285b9c561288a52a9768f1ceabb077602f61b8120d33485a9b746739af3096f5210c8b9df23675ab9f844e84271dd70ba2d83f31809b1261ee0bf7a5d2cb1752ba7b48014c9dd5bae9d1fe1bceffa9a8f8a2410734106e32d4874f38954d1f495552e98b1b845eb4a228a1c08dff6ada9b7d6b979bb1e1cf5a36958cd15b0b30b5ab020b1e9161908296d709c4a67c23361fb8755f96a36b63d4b9e9bab3aca1bd1dbf4322500bc6562db25866e8188b83f71ce8a1489b55baf597304b965f14fc8ccaf3939a0c79ac052427292d21cd9fef5579963b5345fd318653c47e56e5b45188f54bced340e954b618ca071291b5134573ad2cd8b67aa884c7234c6905be5c5ca0fa9512f812ab3c6ad0356d3678482899cb9f3bc501f2eaaf6bd71dfab14fed9d4f9e233a49241b3e360e72d3d3a0c6debed6838f3c9a4d4ee5a2e26a2035e292172d0af7d3b2e224585385402fabe7efbce02b5cd02080ca88aa5b270f4b1329c1cfa87bf9fca5d1d68307a1aca79081d6d8c658295235de3fc7412f6954952bc0ea94eda59810fd04494e59931368842bb2fe0d41ef95ea898a48cada275ec0adcbc69dcc2ed6ed711a51b0be9e4b123decd1d914e2ee8016b52e47ada14e39419edd503abdf7b99e55f81cb372c98a6738aa3cbe090dc3c4a0b495ea785da3433e03349f52fc80834f7a802daa6e63b054b3682640b7ee2f15b487e072a6ea32f7971bdf7594635054ffc8a7a95157de84d75a44d5469511b96c29195fd8711679bcf1c34766e14f8dffeaf5726fa8f964efee1b5641decf8c14770da8e495200ff15aa8e083513ae6cedf9946f7199df303bbc6d8138d49eb501911eee7ba7e2e7c5e4af800cd585cd92b0ed1ed0ddc90886aff101e87e4f543c9b670efb41a13592f57432a24040f9b27db354f0573f22817902f114ffca6c92240127ac6420e1a4ae6d1e402336013329473e4668b6b8c8a6e9d4a4db4cb192157d16df4afd50324a790d4a9924b37f3c99b8fc8c936042821188d827b254bbc5c781b0508ce61488e1b722861fa424f278a07db0468526bcf94a8d52fe2235391a1dec9d3c8bafd0fb984ae614a684ba610527a4c566b035f916648c4ba7b3f937a65e7123c79b76536cfb4669348945a63f9e10fafcbf97280b885a1d071f8c53f28d2a11e5ae9a83b7db37a29e78f26fcd5f71c85f0ee429b2372499c0291f30d46a8633b0c821a6e842cea0a392122bf58e91e53524b9bdc86dee4c503afb227f2dc31312b5a89839465ff0ff3601859b9b9bcab8fd3959b0988f6acfbe6c3aac43bb4ad79f2993a2c5fd7e3475142652ba4e1fbf7a51c25a358315975b390a35361c7339046299a9d212b72d0e3f4f2f5b09ff2f493ba312f1522b3302b5e5665bf645dcbfe09468d2cac991244c000e3f51a25e969b9e035d48a5074fdb3f0debd823db2fc5057b2657b52a5ab7e8d53c0c19f4a083bdc3a35d45d3291691401334cb6695af1d43773570d3c2307047985e07c25e1e6a916f5871b715d505edb5aa4b3b3fd5d593641554884bc610f6ae0d6df345bd7eaf7ebd1bf3db8b9010527a00d01f4c42b35fd388da5fc0bd4fad2a22a3562bb928ee7eda6f8b68886b2a81349edc09f297fb1d817f0dbfe60099de94f7c3b5d29d3fd8f631cd847947ff16384a452c2b969babd58806b3e2aa3ce54a1d893338f6133f14db2ba530dc4f6e74acefe4e47bae665733e1671b29b6bf87bafe7bdcbd4f3748e3aa9658f63b07596c248425ef20765cec881de9369ae67f5f99f5b9852a3e26415e705699df37b801a9b68fcfb8b39c9194324aa4a39d68c356b1be18f7932e4e76173a273466f9138e032acf053439188aeff8909a1ce11f2eb6d538ad597439cbe676c5c3082a6f833f40865bcf74040a7338013e8d308ff1a1d6c4532d3659c06154a0a39006aad1c35e8479d4eaa755866413c3ae04588d12300bcb9237f54e38b5b1797a6038f7fb0b5b7eff6b17c9d951c8abdd9f49c9b130dd2094e67ef9019b95da286e5c5bc071d8506c70b209432a5db5df3bb810b5ff87dde758fafc7d80759a9975098a644055771fc81b1e3afc95083ce825b7461feda987d6bd4c7f37fbb455f2345c8820cedf784c2ace97b005261b65d580d423f798644dc296c7937e425160dd7c374057648e078dc1dff8dad473d13a02561fbc86d786068686a6c1b77048df688039221793f0d0fc3c154e0ff13b27ff525678b3a146dca814abc4ab3097f2c9a4965b282a8ca3bcf7a9db28e36954c39927efd8cad8e2cb6db4f111877cfa435d0f6170de9f4ddaa3631c3a2bafd672322c8bcad6ea81c33ddf013ca7bbd88165625b4c65b3f0a932f08180f68f0041195b36fc6d357340712b5940f663264323c84a4c9c11b663c12625d6d29338cc5296265d8cfb7f8040b1a94c40eedf03a09c35a020b78e185d076090057343dae9f5b7bcfa19291b7fd08c90f6fe925bba89086af1e8fe916a0605a3e5a8676322abc533acb2170712a5c7bb0d9f05fba55313d89c210e5cd37e0134c28cedccc7fb23c9a7a939bf1a8372a9c1473b9c49a60970eb7fe28ed63f45d703ab19a52d3764f83efd000c137bb8f324001094a357fa4334083772d2ad81e0a8bd9b00f04302f4dcfefaefa189b00d965a54bcedf4442f104c7004298dd5f09513501a49688b4169d7feb1005baa10f3906270814d2089afe2d356dafd870612b5ff53669e475f5f42bdda06a4c8f33a661dce64f8e2289e9fd659afa8024d9763d848c24e873f9cf3ddd6aff9a1c346f879a80b7b12a605ea8daebb63f38c909c8d69fa6ab796bdda565b4768a3e97e85925d780689b61e1f3bb20d7932dc4355a04c1f0b3a42f6e871bc1c72cfdf23c868a9efe580381f519573476c13ca546a15bd26d13ae441938ea5a98cf4d52e226de4e54ccf540777a323e33c4d4f19560220d71d6039182078f788a2f42c5fe61372e1df79c5c2a779496a51c2692e1c3d25297bace6467b4215303caaab3391a088791b3b6f6214be31e7b5eba35d0776aa5014b00904aa9fbdf87e3d51aa9597f27e129143fa1b6b91bd71fd1d5614cb6897e83a7522cc4d26fdd686eb8fe39c34f73ccdc5a2b5fa893332806aa98a811d416aae42d47c3e17d00ddc4c3fbc3753fe9477215449dacdcdc961b679138991d255e4a30c93ac12ebc7125b5d2fc72d7d853113aab2f09b59359ae209d943744d0a8a3a05845483679f788c5ef657167a3994651e45f68476d6493e004c566ce7dddc12064bd8de28d42539737513c8ee73b2ecc585b712a68bc4556eff481e3269e34ce7c1da26244ca19978ed441a0528f8d4d78c7aeb4f2e6932fc5e87c2a856fa12fd7c7b7666df4fb55280591602e7334d744b81e725535a816fb15f1efe91d51201305be5deb1ad5b6fa29b11423af99e05f30226abc69ddab77214f48d5559ddd3f4b559e4113281c140b095a4366898f2e83ed782d7686b27383ca3f4a1fa62f2cf593d45123bd7d90b5658be0b9779e8b09546a80e9a8e08a827919a6c51267ca4579eb1ff7d88cc84032fb09b884f67f2dab71f1a120ece19532933be63952667c22c09f94f463a0520a5c2758df1f8b506f3b0fde371d9da9c4005c80c3b4fafee13da0cf92623991813da481ec499385d25b45a865d31bc491049844c6417fde5629cefae5a4cf770c009c598ff5b23abb6ee60dca068dd35a0ec4f02f83d8e1fdf36e3302460f2786bfbfb47fa80377a1c5522ff78c244cfeb9c73d7d8352a87677357ab7a1fa385dd29ba6ddc0943bcbe10fe7702a6b6ffec1aae36ba40519a8d086dbfa475d124a6fc28cc0e1eac2e928a2c7629457d23272282995adf675ffa340a80d673ca2ae5909591eae695f48ad7e81ecbee82f1095a967b5e4ddd1cb752a791894968cbd859659db2e3e36d3241568e95a52a073db0df0d7e21af729abd296b328897f843476b1c71755a84b209019c3269551b02aa0276e4ee3ba87acf4d6329c20ce77508e5022733fbc96dd55f0b969b076de7a7ec5e63b21a85fcb9538ad1a6c060e9ebce911e6481b8a9f92cac82db45141048bf6a6bbec38f87dc9cadeeec81c43872470a37a951eb65f92252495e7a09741af113b3cc86fae877ac32db4bfea7b19576600e76828dbf331b9f968f88169b9474257523441dbd90850dfc08f5c72418777cbeae9c13ca49d37d25f55ec3a14175de715d23569edc9d70feff5dd7bbc062862f69b5885c1226802be9dba3314dc1d8f180fd4c7e2014ba4a8666e8e323d970707fc3207cfb2c5df5974a1e5d545c31dfd079a09b557ee539b6fbe5971cf41a1b5ee9de5877594045928fedb46a3c187d3775ee8292ff7170d344f503bde988266f8f53a2f2f590beb5910e91a40ec9eeb8b15b61a177abd25f90952337befd2b9a3b19bebad68aa5ebc1b38765fe90edd86a91af52ad40ab727c64dab7e9df8cef18e54ea4bc23653b46887e60713ae9fbacb380ac3ad474cc6f2ed31cd0c5f9d74cca6017785745dfae18c928c9afae2e40bea492800134cf48bc9c59b058d4861ec0ba561a1f9424af3f5d23cd551a9100fb5078b15e284dc310dca7be5167b9175203cd5b969e4058ad4524129b9c529c67f0c1a4d2e4ce3c45f7b6be368207be9038e0a554e0e83d7e9e259b3ce6042b38ffe331fbd3f694b3d9be35043c28ab3d2918f12de1a634a1b066dfca5eae36aa74577cf557ebe586a57391cbe007563348a435b3bd157dcfa1e10841e935b4f57b095c14c57c4c81fe7b692a6a9ec197f1e548518644f45766662807c1f3fce12bb96e25b8dce7a9c7e4f3d5a50b204feb52439de87c5e29df177f7e1b3ae7c0d249eff1307d7250cd0c8e0e17a813d20de86667363e195577564053e3f0693d695e2b5acb16f44a82c72ae56438bb7b24841b0deb4264d2a8428b4697fe148cff79e625ae4a4c369ece50f6797668616ce3f4dde6dfa4cdf4eb68dafcc63d55b8bde9984327e2c299d258e0edab18b2fc7f2eb682fdae930264a04e725a2fe8f1e0ff91a4563ad54d9b8c04b6cc568be92d27598f517e074169c43e590377e1e28492af387217f4ee063a023e6a343f6c228eb0c36fdfea686f978af8bd17bb344313815e7e652e2f4a442f632407b102cf9bf7b911fea3cd4e6db0f3290a7837f40c65cd77cd70d6a7f2653666b0e599a59e908a0917b38b911f334a01d32dd285053397293759ee78dafb79f3eae982e5a547241df45abc3c796700f2834ceea86b2e6e48dbcc5ef15ec7e49113615d647a6de9a0badf55ef56435e5f58d1cad247e0fb1da2f093c885119451030940957137d2a3fc36e9e5a8c781289048481174c896a6025fbc660ab229137bfb836b6ede1e914101fa610a3828f93ddc7a506e969d0b01a0fa9badae39af26269c1eb5e061ab885e9eee9d7b3595fa0789da2e15e60d9ca9f443ddfedfa4ec8bb52942840a2b487972ed4057290408c86b592bde01211a396f32daad672f3b51caa578bbb6e1b5e3f6ca7575f39217e9ab4052e864f788a31317132c87d3ac3cdc8a32c50e484b292f7c384110dd792cb03c6a8b4b490341bce1c309e3fd686aae23b0cd4982b73259627a1a6769339a64be2ea34fa19b28606e365882d27cb7523d03fa11c2fc91faf830aa272c171a67898cc21507dc92d370c207b6f5480aac2dc182d2c56596ff7f12d80261abb31553f964d0b1910d894a1c510f039b4b4eda3b38169afe75c78b22f1f9c19822a127355feac92c0d792c71053d2f779207e23b3dc999a0c5a0c3630c52906b448e00d0a029c64ff731ac6063aa353089f07316022972f6ee85422a72f43cc62115f0e6418d81cc8e3e91635be671b8bbea56b2d9386e8c51f221684b015e004c53167a7fcc4478b26cc2f90caab9b3e75fb3e1e58ba8dcba926f770d989675920595acacda22c44dd875e1bba11af80909af6b61eff928622a310b3a5ba1f19e6313675b5a1f8edf8c67ff834c6cf898bf9e840aa0cb308175c8dd046d63f5ed8825d3e376828ef0758bbc49357b6c0a23f2ec98bd2d7d411bb0161562dc914d35c87204a8b6f84c789e441a66db6dbf9f32cd6147b01765f7aab5feff41b52f0f7ed7ac406382dba3f05f37dab85e52679a758e5bfff7d6765d763fc474ae0ceb3530bfe89cd5e1c86434e29bcfb91b83496d67d26ed810b32cf457ae648c73a678acf94c71e55bdf9047ec6d1c1decb32c5b0beb130a82663c6489a71a0de21e445dd43e37dfef9739227022d40032ec469395f860e3b4ede8b2d224ed1069d849614dfb4f9b7f80ad3d6d331174c6bcb9edf7f16d4b3184dec742dd31cde05033f1fc4bbdc6fc36097273364b5688bffd1720f4cf40847dffb7d603f9803b7ca0218dc3a6b58b932a9613bdb889fae056e399f5bbc53c67ff22dfce0075b9104d71300924577be112ebdc3a16b01764d241152a7341360604e3b29e1c0b04be256e2fcd8b5a45c0f39d345a4bb0944940e1a3fbe888c134e419a821626b79d2e9cd7368ec822e0896500ffb579aa49bca235c63ffa9a372ffba97794ab5fd29b3ea8bb1d16ec94f11a5fd8e33178e80a6405ca1eacb549379ed498b4893e846670784e2e4df2200a7e75f10485f8f76ed0286d76e291d628d0e63e6a48a0cae49b0f17c1b811dc113f540f727f483041c5d48e27d5d700b2ff43f056b2beaf18b8c0c1fe24f7c45ecf296465228e3b855626a8bc466fccb3f0da999d1b931286872f9062b3b249cfb406042167f196e01d6fba3be1491f21bd9ba5b9e53bae8c59cfb6319304d551e297d8c9908da9ba67da73f7b3e8899f0ec9710e7df9e33f166ee4f5317c525af938ecb9fbf763068a895e541b2734e1543917c2711af08aabf2fbdeee5d9f628dac8f5c54d8d72b0eddf6fc9030a94ee736cb3ba90f10642b13e0a79309ed3ee5ceaf06aff05dbeb57e89c17c944a94a09ef92473e8efa22b4e05605b51fb885a5b0509867a37a4061c9247d40e0997631728df577cf59127e889396bd181a0ae4129355e1aad9f285c7db87154e6e4ffda2a9df0420d297dba6e64655d7eab10e5f66da9ab042c37354ccc46ce48479fdeb4a142ac8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
