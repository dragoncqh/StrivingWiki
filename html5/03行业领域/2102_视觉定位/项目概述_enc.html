<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f77ee37029d29241627da92132a4da6e9fa092f5d593d741226cdd577af8ca62b11f48377b551262505a5c6c3df611809162b808f4e31a490d0ce893b1307de4730234df3d8f3c6058589a3b84966da0642d1e17c54bedc28175a7ab9b960f9b7d1ce49d3cf569f2eea3ba99863f3f88e483a610d3efd843b967ea418501d5166791c4fd2cb10268cc4468d4e641cb4778c21c1e50e990f692c110396821c71adc0df74e3f5d2026bd53f745fe713babf34981781ea2be8e0062beb01909b4cbb463b393241381954d891c3df0a00f0496e3cef104b1c191b2dc5cd8eec42f70126acc7797a2e5d07aa6480676690195b2106d4a5aa08e303232854e6202ca7f08d0659a023696f6f725605a58f87afb00224465639b4af969a4e54c572bff5c39e5ebaa865f60f720fcd606e2c5ef78272f740bfea8b3c837c33b065c9f0e7d24cb51ed50a72b43d6dbadb1ebc417506274c644d13ac231ba1264e9374755f011206556ac3a26094b6996dfdc9b24c575c7d2c10c4cba5bc166df53542488ec46d4deb6ecb048fde1c7de73a6042c75a5d57a0fed58455bac7fa3e7e2436de3610bced0c163247b567f1905a5713958a34a430206623c50b19f1e6e20254edf9cc6ccc34813e28a89c516abdf46df69a54f6ed55de88186a200731e3cb67bfe288f4dfdab6bfb68e65cafab7bb7fdeef2a1ee170d8628e19c6c4717a0ea925c6a6101426b6e45d351d0a56ac13b914836e0593d7749ccc94054ce31b387e618e97b9002f4522ef5032fb88be349dfec33d1dd0e6b37edc6f65b1cdb9602ea73f97c9dac83f5a220b6e96882bd96c3231a876d51fee1acfbf9437bd6215b4217878e3d15a9528a55ead930d5e51a00f5f887c577644c5deb7d534f4eb52f7f9ee898930dbfbee994fdb66e3a48c67d581d2d70b3d9f16ada61422b58b3fc2a36fbd9dfeea2887a0266f0e8ded73fc3e773ce11938d3754eb32e5b868c5573131f96cd17a16c79f2e3ba670e1e6cb942a75bef2b7c935bc67169e2f6906eb14236934816ab3dd5624e0365885449afefebc4a2c1ab164557ba93483c071a615a51f6bbc5c094e5d78c3d8c87946d29d1a57fae9760d639d7740ae83236b2bdf2769204241c7eaadda5ec00f329c0782ab10ad8d9e2ce23eebed6b0268f4cd1decf1bc4a66a5e07dde4df0d15c4fbb4afc576b365a39dcd1e99c10c66e6ba3bc580bd01e0dd6e6c8ee60ba0f9d5452ec20867354cda5b23a48e64b3ba343f29d9006400fd351517f11e44cfdd4bd45466b2edf6d038fe3f8ceb17b11b9fea45aaf7eb2bfff802acea453ce31a4fa5d7d005b1679549ac61072197aafbcda6285a3d7427a49a930634d5bad50150da097a2f060151fabf15f20538359ec7e737c068de4d87de2b87bfe77383dd4a004f59c1c7b54e2b23e19efb1a3bd490075ed939d684e7b2781d1d28e709a16757e0de92c7eaa1f025f5a7191e853d9b568ca2866e7f44102f10e32ecff8d09385e8588dbd937344a1e1f16edf370a1a52eadc52280b5853d09f40c587f9b5602e21b6d4c5738d69a38b7d4c8f257d41796d6690afdd7c8af7fee36950a06cc564e6f695a27e3c4efe3a51b05699dea96a2b0ad3bf610dd81c3c6d5dcc14fbdd781b36c4ebaabaf8909465c60eb98d5b7f26e17a0e8e4ef3061c42e18f7813f2b8f8ee92b898a70e8123e5aacc0ca066b31c3bfb5b9214282cc325ef80c3e87e5b5ba8be851bc98b1e8205f7812d48f55186384e6f7351de4d55d1590753cbe26b7447ff6120095bb1c5f461164c35ce6286925021268143cce249bc3eb4cb5e4182896710946f4da6a68c724a8c41d98e389ba6206de8eb52ad4be45f75e546bd4a38e2fd4f2ce37b5947a8a6bfe74bde9f2844c9bad164f0dade5a0d407b12090fda1f90978da3050ba6695826ed9704755535a242d9d4dd32591ae976c1b447c424a0d2680b3fe018029db1c5f85e53bf6145a1ff30531d52a95424ef2a1de1c3616af3f754eee16de5a7317493a0c0ad90444109d422fdc824060ef67921cf753f6265224c86ec0d0476b2a33fa0e2df88487b132218f24b945f3bc6030d0638c2e09f3976b1e3886a5d67f004c70d38c533a6ef9141f925d56eacfa8ceecf0ec8de3abb231b45a00440fdf13c2f443d7e73e66c52c22212624a8fffdaf47106c16a287535f7e7a6fa50a6035f6907b8d15ab3a22bed1054d1e66b464e2f728d942837afde22075a7859d38b887290438a9fd074b5cf66ada85eaac2c2098b314561a17c8aefa55f6d09edfa18fbdbb0e57818e7bc5e2a16840f635acd5ac36653ed4899f3df07ae73e00c4720d7703302220d4ce5ae18cc3e879b3f6a401f156ccd6108df48a7932425c61fd27f2117d4abed74c95fd66a70efa321522edcf7f05d53e431c3d88a4f197c9213bd62e933addf5c17653fdce072d0a2a2d678d6c02c8e110bf88ca74703dd5a52d203ce939d99effc2d6d45f99f0ee5896ade1a9dd48f8d7d40ac1eb4befde5bac0c1a35fe484a1f3938bdf1755bfd5a851a483186b1aa161546bc0b44f23b038dec5d4f8f523a3419808204384917f57003625388bf75554ec204e704fe4e76d96f79ada50409ba9334cd0f517b142491e5dda546ba0cfbf473a943c5736b61220bd9c16d5fd5fa5a5efdcb6f1d1f18f23a4dccdf5711ef6db7969f7bfdd5de6b9958c5515b6007acb7c06f4dc47171d74950fa19803bbd399acb227b5759c75bf17982785935b23dbb1ca62e4642382965709fdc4689df6530584c02b39acc6ef829b111c178fec8b3db7ab1353da097f7962cc185195b1d2e9af039ba1b33b7859d9ceccdb3509c81fde9e0cd8364edd97fca23d71ccf8de88555359c9b839bd230cc1c09f8df658bfdb64c532757517c22c2a79ecc3d8dd0ea3d4e453902c461964edcaf417a9ab229aead5e4ef4cc50dedeaf84b87c59acf8f31e341271c32b5d3ace859eb338f28b37453d4bfd313feca27594e66d19073b0143fea772cf0ca287c44198a865bdc235ebe8370e05e4592f84b05a3bcff2e24c8ab638b799c426e19ea89521b6b12d0b865865cc2954a2abfc6d906f97008320842c14cd09e42b566b17b500a02316ab43447b4d1bba78d861feb98ef7117a9fbb1ff3bdd5b8a6383a00dc4934d926272f984a9f460e9339128cf43f3ae6f99c32d1e4433b1303cc5f7294974e9ff6dbcedecd639b19e8e49dbd3c8f36a94655b2d7f6ef123bf15a95113fe1d99445ad393972d81097df9faaabec38b1d376e6bb1f861069147d855a7b178d9a38276203e2f7a40aafd9af496d52896fe07c5bc5fde34ab7e68924623be875a39d471886e4d8f88d23c7a900f47ec42ec1fe180d181dad18fa61956fc06ca4a6ebee33a3738fb59a3886e8caee1f10643d3cce6189faeddef8dc32c30fc158fe19b6bfb10859567939d79315767937e747ee7ea731c977908aaa29933134ab1321fd8be4332a3399c9c187deafa98f0c08ab28fbdc28167345ee47b72f5b55b7ff1f6943fa608249fec9c793b2902c365134e65f72dd9456eee5691d8666a3c41e239cf58a2c88cab9214e5c1ad5391cee018ac60f08b9ca41211ba18f9ee7aa169621a5fcbcc8e8eb78af80331619010d5506748248a868bf633d51aa16b2f0ed36e3e52624073455fc9ecb84af630254c91df271f22eab0f05eb01d104b02c52a4990dbba7e15768e68d5d956252b4f7a3bfab9fa9d6504c5a7292589dbc5a3b9c8c13b5af7d46d6658d134cb766b71d903d0159e4df20f1b6effe7fb9910368638d3171581156c6b68e210f643ee69cfb59ae262fc03440065e8abc0b17fb2ca6ce2bdd1fb64050902b0c9c20ebad3f9e3726ebb0c36215ed5b1f96be393d9bf743e924cd2016b3fc63232960db838217186035b644cd216f916a011c1468d4259d333f44828bf00520dceb57d0bc7d3376f2cbbb5426b815e370c4df13cc692b72cddb6f82e5a00876826fa5f338bb715a7f3e5bd0b328d131a8841afcd9395c65dbb37ffa1c7af529b0b2b7a627e02352a1ba071b5809cbbb6dc2a96ee4cedf2aa0e11d06241fffccee1684a2a46de405876519171a4d4715da237cc69fb08c013853dad999b8008ee0b0ad79c44e564a41230493f14c0d1ece2770821e26eff907e241619ecf76bc5fde8adbe12ef5fb87d9b8badaf5cd7f260f5ce17626300bc976aa8f91a1dc2f4bf0cd648e8bd0f13469cbc0ab1debc8d69046ab6e3f10300a13c86b87a0a2f1e69d625b742e1fb47f1fc047dcdfe7310a33c62df86826ad0cd30fed6dc6dbc45ab8e899a969f1a1da371360da46985fe7b0f481856b6ecec9280a191152c549c0f2bcc8b0f5903285e9eb0ce4a8ada0ea52a36c3c119ed1202453e1aac0dcf192db75be233fa4d5c5f626e5374ba56aba998abfa5619c12759f321e9ad6e471253eb3f7cefd61f6bceb7b6dec9fe54bb1db9011661913fc544498f218249213546c70d42d24044d57d0419b37ed88d35119a44402523e3cf2af5776dc8b3a4b52b5ecd270995cd65251310ee9e94da3d0622094bedb2d0d46fa85481627df6e0c529b093d85b0e1ab7bf137c67bae26b3a1f14b234e42f29406dc965ce966fe41f42a9d9f644352d206f5d9d37b54502903570911ea33cb79b7761fdd471989cc9246f3aab5f4522032c2ec5eb99c9b35df51568a3af1737b61f9b9c7701f5071e596f835014b2936fc258a656c8b704158a1532ffee879e8447e590ad41306440180d375f63e8cf85a02f32b68d6570b76c3918e1231a5b830c0924b1cffc59e6114029c57e7fb98fac91b7269308e4777177ad583d32f3b62fcab09f8f58015075e8c8cc6630bfeb5d0126cf638a63edb183dd052807b23769b2ac1940130c35ab253682cb9d7997ece1daa8b355fc6f8654249c950f34ced4883472b03a00f8f537e57b7a5ab2bc3fc46331d1ba53c9494d325309934f3cc3e3d4b559d766c1b6c782e640b75c91c6fd49a6ac676398f8d0194b63f02da87c0f182ee6231b16e41b7db3554a660deec5ad84185b1331e2be032dae36785ca774cc80d034101b5c6130bf0d4dbfdb14a77b93ab5b0026df37fa86427dda48a5c94c79cc3c68f7f6b1b5c99e4a6cd316b32ff3611e0d3742f0f9f48a033563e088dbe3d2dc4c91ad47ecbb8a4c4c4afce84826546e32442e351b21b1b9f3a908e5fb08c743f14e1b97637c12899c0c1eda5a3a911d7323d5dffee93c0c21b30d93ca34a22810b0af367c45d740f02709b4520f0cde077fde64a9c70bc2667920e19eed6aaa63e700a133bb0e3c3fb9e78ae89f73972ba12f4ee10cc8cfe1c5d4a22085fd4f173c12737181f7e763ab0cc107f30d08baa6124c16dcd0c70081f407744a2b705bc2e95f9d30a50ba8f37652f68e1e53ebec8f7a6fe5c0ba06312beb444495299c1c1b6bcfa5275f183ac4aa93cd2ea731f2a5ac22f4e8d5bcfceb8729b53feffc92589c1712d25e4451de16d7c1beab8e29e6d6f13d4bbbe7b9df1fac20030a7586f63e6935124ca4b94b819e7f5c96bf68b0a8fb878accfec45bfae728777fff036de3d604bdef3f28cc238fb02aaaaf8f85ffac6f76838f757c04f6d9a5ef6304ea907567c77913b5424c00788196f15a1ac57cbbd62b4c64f03e22f7b526200b50bc04e668ab447f3c62a4197091ba020515335511c84d69ee54c815db1865c119f0f63e6b7af4e8ca3eee459e27d6f6727b1705ec02ebf286c98be99736d9a8304e8fa3a158820f2f0b1e2d159c24b3e6fe0617c85937bd519d95e5fb8f5777e5d327c8383122eea3643d9a384ff18ed1f51b99a29fe10dbd9a0695a95d4fef328e7019ed7bc9dc3902d3d3f83e023067499cc82c0e7e57e9e5189cd15b7a14680f0916ab61d5f9b1bcb162f26ffbe0b225d276bf798bc3cd44285414e728a2083ab2dd7dfb996790eef37505ff8d4048973871552d7eafe61cd7d20f9d9f5d18ac25cba856a68a3a894d969005845a4972880b274558ac3a01813e89ca57c4403874b98453ad41d79898fe8181455792f1707e3c478d34ebf4131e448ce43b8550f1fd14a4fa562b73c10dfe2c97fb1292c0c40ffab13a2d62496c4e514c94608050bfde59457644f56298251363b1cb0adbc5adc67f29f0b7113b7dbb383719516de2ccdd6e0be19a1e168cf9c2597940afac7f288af4ead1c4dabf27fab3f0519ed6fa48b04c75a205bfee0ebae9c8b24dc9fdbe0ca9e9a027a501751693209a89d54e29d35d8304986d05cbe4714bf39eb02943ba7c62bc908de1e89f0794f2900417355b6992b9daf54aef733bd05b031c95fb3475ebd36d8fd958d651126165aad27ae9022484f60c4f518363df0988e8120b2bd029481f3943f78a00f3614a576ef4b0e28ed50868459302db95b44c6b829fd1f88a647c81e5d20bce0a5a252ad93f537b4700c26995a2f47bb1fd0174e222ee901a11f6dacd71d8eedaab31fb478f04ef26875491836a8a4ec95c5aa489ca9e763d835fc99c70bc5a40dbf8fbbce4f10b8d7a264a3dbde1f99f18f1c19dfeb766b927833775b6c31fdc33f341a7b2fa287ffc1e7867a90afa156a367b94b4d95b795e3db28c03cfc4976d49edbb2c033986765e5789b02cfe5a4f09a7c77e544a51ad6f852875fa24281b04c4c431cc1e570f29fd2e649254a96d0dedffd7b2a8b07cebdafe03abdca8287f264bd5c252af84d97f2ab570b82f1710b8dc28c01edb30bb4aa42435fe86fc8fb24bbed7b173dfd4d55aa5519b8ffd7b33bcc414b2956b6d12ac9be26aa7865d45670f035b41347b1ee8ba037327d3d2a41b33aabed0a635539e469fd0818ae867f285b1c5048a2633db055b55c30ea27c26fa40f7759e75ac91cfdd1036b678b084b21bef5cfb8b92cb19b2f4565fddb78289b0aec827e80912a51bec1865a041a126217fba45f2ff392f0b19c9bf3693fa32b454b77aa298573bbd417f63f86236746947acb543454231056bad64c6d15a11b598904ceefe5f37f0aad6b08fb4ceede0bc8af716ccfbe192c63ce83435136ec11479de36cea38d71433a3c6210721cdb8a147b1179889d454d82f154aa99420de1c35c749827c5449621d4a8e0421afa1b018c5070ef914cdfd11da5a18b74c26c26f21d6a4f3d9301fd4ded5e0e90182590bf0bfdf5b54c531bc6162c19ed9f3b2ed6779ae088cfffcd1e198795c4354bbff318a3692fd3689b235670c6c50341ca5a992b82bc60f3378a71e99e713b597399f540a321d02d8a92dd02c6996d154a26f5e547fc9e2a76ce5a65f7f4a3e99e66e9968f10b74595af0e969714080209a22e8ee43ef945d4671b635fc91d455f61fce86f5197945f8c1d471e6fd55b160d4fe88e4c3c996cea1ee1b112f3ea6ee57f4c7549193e35908461faa0fb2bf8b4cedf056b26b1645f9ef272be8cf14a8805cd8a954d30fb9e2ad3e83bd07afff91184693be2ce80ad46b9e8924f8e8427580db5b805e9bc52d9ee474b8c621389f15bebadc290cf66d8ecf4a56b43b5e2acb5b89503f4a86b87fe5aabb840ca2c260fdfbd264e766e591aa05a1867e6683a5e82118766a3086d1c79443302349a382c94cd6a06efcc91a03a87afe2668b0d1312a77ccd9a714ca9b0cbd6b1990a088bcfeef7f404926948cf746eace36b633329c9eef6dddfd20252e3ab4b68f4303327eade495d7cb49731c1bed5101d1d48e0d4dfc70aea17d201e73bc5405a6a8c300b55eb58f3bb1fbf81a7d976988c7c8c482e53bb274686fdca3429b007d3f0e3842d4a1ca21f9dfc5bcc6eec298a78e5c29b647ecec85e3799a2895495130e441d54331061ee0d8b338f8ccbeaa4544a231d5633ff2c0e6fd3acb2a5685f3f0f97188799b8b512531eb766d23f5816ff9921fccb6c3518f437863b5c2e2314b5b1ea09e17d48cb2aa7f2922c457f644bd7cb048d60a84114b1bcb59b33fa6b02b9a4aa4792ccd15de4e7e87dd4ccf8db688190db0c209dafd88935ccffacc681f6620a205c259ee6e12ae4472d16a0ad75bfd055b911a2b6baa0d53485f3ca0d85d3929c11c39ed300673bb2b67191f5d5cccc45603c032daa75931cc7d6d62ee7f7cf4cf8c270448683f29a9b81ec172b0551443371daa6825a94bc763eb498b9bb3864b56538fd65ef2c5c56ea4435694f1036568301cc5e8d4479542a690d52461010330be6eab65ab97c666f450e9083840b47bde4d6c048ae01c88a7e94440ca8efb7fee1b4be5cfe8e2048b9efce36d70d65c90764da5d3201c0d6fc42cb47fb5fcd064e9e07e41f69b755b9e1c893294f602ea9f77d69d600ac5258c1782ddf7783ffd84143d99d20607bf089263d5a0fe1558d1475a5be07fe312b14d4e7ff34bbcb56db4bb44cf18aefb28c7be46d9c32f04633be3a93a9ec5c6f14df7b44bc0372f5e02f8b23db0970ef84752d091a18de55d456b380236ccab0ccff0e4be776290a38623c80d273be670b90da5d138a4db64b9def13d7bd71e4278bc0ccc017ef4333f658167aa7806b3f5c8faa3b32f2857f727a3519cafb68125e5520af68d285d057ba01d4db69281729c7318d5a4c518acd7e5488e8493d0eed0a83834987e5b32a0da3131f53a02957648dd1ce2316db1714077a5b11dabec0cd4d496ca3cf25a26468bce05fa156773df13347c3b118236e07fd4a029540428cbca096721a95bd87e3a54dfc38cb4c2b6c4bccea23ec38e8492b2dc735123f30d1d141038ebfcfb99570adbc01e625e892022685a306f3c2d3958ea53c2933cec63d68e9acd7e12bd55dc425de840f6c9211a058230fe5f3f1af6cae85cab12038bbb59b9840ac307bcb056692bd9dee60f52e97b3b74674097186c316e5c2c5e10c9dfe4775d555da8f5f969ab849357103aeb6908edb2388c7ee360c961e0ef62c5425ff4b9da67c77423d0d09046fc15e96ec7448d37c753961df8f267402c915e9bb3e1060951be58d5d5d94a8ee6a64e8014352c15abad0759be5a6f547539dba964e511096a497dbfdc3ff5f468141f47befdefa872bca7bb4808f6518c3b9fd54ee07ccfb5088d4cff01339e0ed1de06e98c8f525750ab1447db7758b5a0ca65dc0faec0439cfb1b74c676588fa4cdce0c8c857328d0c841a1e6cc0fe55a8fc0bc5477fdb54278d6eca335dbf6341d8c53c7cf3c24d98635c6dbb8d364796bd55386982c0ffa452d874e8584221ab84551c78e00fd190494d2b2fcf77152617020048fca9908f9a80f9d26ee20609a63dd5ea325a32ca419e455c2cd26f502fcb335f2c28cd901fa30ad43895ed6b4295ae6f7c5736fffa9a7846c6eee5dc062cd1989c89d9aefebfb323c032d59fefead1c4b4fb1a28dfc0905f69623cff31cec8247980d4365c1182fce2b9a782e11c757d616000b25d1c210e46a2094f784187a32d52cb00bdd8acff1fd547739d7a38660514830b7c519ae6115405f70e93e5abd5bf3f3255743bda450b12b4f7969f96926176750408edd599bdcdd061661432e61c941d6a714ea255f145cee9a75c5a31c7d1220d4fcbf153e3b521944eaa181961ec6147f0229d0ad6729a1fccee9d468c17f8fac9a1086314bb8aa7601377866f46279e6aa04253d9214e43d16063e9c4d4d2942d1177150f5d21f570fe99cd4e3b087c63681aea5daf926d2a7efa14456a4c7e2fa60bfda00a7d3126eb9a21ce5ea7f342fcc64690313e1c31c71e9933c4c2ced7d7fb31ba1d698f70be8f2956f5974eafb9a3b3e7b65b8b71db6fd01d87458d86db7f679d115827c7fa8dc61b4634a37cafb1f0d9ec1fb2f84832122dca5287e123d2b995602859258a77b7cdb227d1bb8b9877d2464779261d5983fbac29decb22e08a3d9588cc1b7a915f19e227dee4962f07dc7588200de5d0130830d18e12b5eb10526c698a634b8ac4f659ebf2427b14870d0a16639b35905337ec47dc11d95bc071c9c4db2cf1227b1ea70b7718827066e6019cc887ce6abe9fdade08fdcc5acd96","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
