<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c8633bd0e582e8151c1b6662a4f6859dea79a8e528412ad86a4896794a4005b8e551a7bb4a257de089c6db2e4700d246dae417bda100ecdb6e2a2ce13b427d5fcabf3354e5d5cd32cfee207f567540aa734644bd3eebf2cc91364530c00ea69b9b665b5b3c8a0d2df5110bf3f705d54bd674f0c64f4046523c33c341f67933c0d69ac863d01ff9a198b7c072b3e4a2a99efe1e2629d76f812a105bb0e8d03977a316594b95a5b54e5de27d48eaedffbf551d14ae34906a7d565f03d9a4a66d4f53e1df148311f93ae4de9b5cda22328e40ec3876f4fd7892f919c259eb9dbd863da39412567de79f6666d83e8f9886732601b241105d4f622e91d639d0703571d3672a47cbb4a629b79e9d0fdcc1556e326a62b7c5c59b069835370d6b968cd4040bb3b58d907228ad790a0179c7a834b09963dc1d72e61648899f3faf1f8d908be70ceb29d420b173f32938c858642dcda0841f0a09e89a5353be56ac3324a223b309ac121553c29d62b3c644a2a31fed7563ee1ff109203940e4cee92bb397504f5b0a2590a615023102d355ecd0c2abdb52204b9ad79283d1d0d5574b027fe9c696006ab2b9325d90ab8b8f68d25f358df595630ddb0bc0ed236c807c12a02df43aaa563e35661c90310b4a42e43166fd47b11cb98949e170b1b281afc940a04a5ac87ad530140a3611607333e2d257197920d133b6c6a68ab1c7b37efeb5d6ef1c4493f1e63e532ad4c3b30cca18f26399b68de000bafd5165d9ddf5039e59765181d1f19458660170166884a700d93f58cfed17415740f99f942b7396070c79943558ebb4533a444b41718d053d3499b65500333944ba2d12207cda8061bde912102e091831bae176d7a0dd013c6ca95bc4dd17605e56fb3f21368ba169919ebda5f08107c930f150eda25cd9ba7123bda51fff00a95a9f784703b9e7f7f4121bf6d43569a308a677813e6ddc8736988128bcfcb12654e6e6d68ce0403fdde2495a4095cd13b89595eb849c26a8063de1f6adf105eb8410b868903e641bf41edcc9638a5f034ea4d16eb13de4fe39e42f63651f3db5fad6d8287b5b803d726caaacfbf3d2e23742b868cd95e8aca3fef82a706bfcd9bcb637cdd6d472da4900b8e9ed2788b0e991ed3b180a67d3d9753050b46b9f102e2c1878783b079e56ed28ce54089547e4481b0837c6453bce48c3d04c3d09bf5e0ce9aee561b422a79993706b24c8ad0315a3801665ec38db9ab964aa650d9e6899b18696d671da331c31805db7a94c06f49d21d0b8dcca3a40b50b8e4eee4d2361d5c8b176b98f231a256d6e6981b5a0904f28738cbcee9ed5ad51711fb15975a2801354ed0c6e4b5f6190ba4fbd5d817db4d6ecbd72c5b2de7788c91a2fef922d7256530cd5478af41fc1e39121563cb16d3f9b9bbce38dbbc8402e3e6a285044a3b3220f2eba59a105a92199578a2388765efa1420161d251468f2a61334b1361e24666d4b818691758d95dce07b6c9159f7f070fcea922c7ee2d1a7f905152f2bba9b9cce6f446328ba42388133eca49a8bdb5803b038ed465ac8a893fd128f4c20d08483dad3cf45d9c141e795db96adc20f487bfcea115af375404a4d3c683ab8427544114c90acecca12b5a002055dcbaa0d5c13f1cb7bce65323047f6bbefdd3fb1abc51c86c93dd8a7a1e33c1e201191fc48c88e9cb4f81da41ebc7b20152cc5773ce3b1121df6435efd2f45a40114fa6716a3fef8a7c8f169eadf55a99c768438189d9b2a9e607adb26a420e267b660dfe520832ba7b267776058bd0dce6b7e1d424a2491a7b68bd6ab85677d3baedd82ea9a0f690150463b83f8b5f7943d4722d7729e0be738b443983d773280281f1729b33258065eb753b9ffe71d61bc07c39bf53e4f18366d3b2b82cb13e8bfd1e75666c69b353dc7b96b6241bd888643b6931174fa64a25f4a8120a20ad68a39dd8ef05a7fc86226431f548ae336e786d465ed9bf74396da30be5766d3fd84d79b6697c08b27fb933e232a78af8431dcf7a4f2caea05c0abfd75b6deb7870d41e25be3fb37e82305912506d271fb6771df09f20a8e31fadee8b12ee257dd4772b1b3474feddabf10ab8e140e9ab8528ea4eb21a1bd6b9d5ec10d90162990247ff0575a3b8ef1c70d32f0d200deb90bf3a0d707bfd1985505123ffe2fe76537a2c6a19ea9b1c63c3ca207abe6ddb9520e43d04bce09b4d79a06c54d4a53d2a3c19386b80aca8654f5a5620bb67f185bcc3362cbd63e706e8e0b22705741fb895a2b9a6108ccbb458699dc7dc14729173808ca50d8a061fe81c3aca615b6f4a45d53c96a5f2c6894fb651a6ac8d232da220d3937d659d76a1743ccb46c1643b0b187f2b1a941322186c25e6827ac1f367ff7d8c25f23045e4dcc980fda2e847c53556cbcb500001d6dc4c5fa6faa304b80a0ff597140bb9a03219e44b238fa1e0ef540356c013ccf5a558353b495eb8b2ee5e2d367899cd3952bef9ec49d95b8cd4ab306cea55474fe3670ee500abc0a1dc44d62a33d95b0ad69087705c001af35f80c089ce28a53ce1f0d5f61a64915415e72a495d7d42a8c567939a82c07129774c5e4cd32e3a348e822623f7e7284502506f878ad2ecccd7936a64bc554a14ca7fdea4f09109093336236941a8e23fa20f4afd13740dbbd539b6f90f7a39b8c26521dfec81223c7b0bbeda1f82837453815195554933b3ba30453f6912a03ae89790faad234d9066ccbed72947e6430161a2551d47d185332bcdb4d1a6c1285690c41664ccc4e54fb0d2bbce3f402396d359d9cbd6afcf789891d05337822fa932a8078d6c1b6a6214a3e7f484e65ed95924aa0267f50bcd106136fa142f521422907c1b49ec561c2beabd5643053ff2c721c785eb1225d8e89a678ec9825173f399333cab11dcea9b62be134a5a3e49cee5baddade9465427463ca776348e3d785a6f07b7e7d8e165ad47b05b3965d2ed848a4936e052f63fd35690d5097d47efc99aa7abac1011d4251215758d1b701bd22f35fd34701e1e4157372eb44b7515299ba56a926f638393c6eb00ec92784c137452ad1a3e4e9b654b0d46c764ae0415eb6786c4790c86f3967887eef0db29ddf28e28d51102689cd2086c29cdd97adf7de0eb3817d8003b807e8dffe2a808ce0319325c85bde185149cf353f6c44ab25c86c1a8c264a34e5953f0c08c9b574748003bd77427d80c81f681111a33da93e5fb63c5e60799314633bf11c0e59f0584acf2c4b55e37eaeec6b695d45ad6719af8e572ccc33ab12e12a77d8f4545336789fbd9e66ae5e0ce6fbdca6c4b1ca5d15eebcc414c685c5df4f21781555cd933fe21fbc3892e55ace27b6a0a7217f9f6aef8a47d1ff58617eed251d569d75b05223b5fd8150b2d85613923f492e2ae6a7afb13c9fa6b454deb53e7c48df129d610928f0014dde61286fa13a5a19bb32ed12aa1e7af27b0a08a31ee7a51ce6c54df83df536afbd70fc9c41fef11bf6d4bcc1eb6f6c54ccb82aa5e994348cf87195effa8f0085b3c27d979ddbb918b91f14b6284209edb1e1a9b385b27e649db24604e2251ebd8306d62e35894112d42ac83d85c1a84551fb2018a7b7dd62c1b1c01e81a0276edaa3c3e025c3e1fa88d658239a39fe9d85a48fa1fc7f2668db45efd3f564f674f1b48d3a2c5af92e3e4ad8002b5d3ac16decb92ad57ac6091f10f7430692d4456903407e312c3c304acbe83783b374c54ad5d5703bf89f2de2149ef5cb8bff9ba053ae9fef5bdb0a5d44dcc18e1bd66b9ae699d2b2bc9544258e5e59d69e7390d6aebc3ac3661800268aface278751aa09f4b6f92690e1e5b37aa59ba2b86cf286c5fd83cf92e1f655561a6125cc6363e6ec443cd440d372c5276e7f2c1e631d16250daa501ce4729e44c4b3ee4c79b7935a815559359a2b2d0637db943fafa1b792239f32db1d07b315392460e7d78907cfab216d3eeb6b775e41426940b852a90d2ae090311f2f2882132f3309e336ea8e0f07d91a41e32cadcb9f0559421f0dff81020f181b882b6dbf52ba2a79ec16aa782a7713200383f63a38bedf53b127614df03f6e6f5c7d8504e89a79a76aa969ff5030a86da6cb53418fa69ff036f73fef633c069e4dd3b45aa299f4c295e1bd476d0587da8f1b3fb6bdbad8c32098ff0b6598fcb404d05a7851c15a116a0d85a74862e2149e44602f87cecaf5265abc7370cf838e900df4b4c3f944d8d80f32710fd20a188830e59c5b9c75772e110524f804c73826fd88776be232770d86556e022da8a0e1d203888852efd9ce0144e37c2f410b0857fc0f47f0492810e47a9e681c890da6dc5d4f7e4204b19fd6169daad47e79b502ba597451c4746e3e50bc66e03df1416b5812057cbc38b21e0d4ce7151b30ad3108ba694e4b3206d59219d5643b54c7c758cd18e0bc7fd12e83d679aea363398fbbd0cd4bff2d92892698b9645c40a56c040d63c227cc9f19002952e48f8007eec5cf4ea12fe68ae9dee8c19756d070d0b8e7622269526dd8e8667c32feaf90dcb98d75482f5f27c95eb54c3e2bb4d43d96226dacca0272266ad22c54243c63ba461b340c14b7fed23114a8c41acdf473ab9cd21ee89ebd166f38a08e15e4069ce6c2da5690b4fae124d43f3bec9a802636719cb01bee30226febc6ba620d1c379a58bee5c523a2144929ac833368ca6973f5c9e6b211aa3ba345ffc1e3b0b70ab351b2aab2f3d6aa0db93c41c0af01d1fbe4f74f1b027f615ca298b974a741fe9f8e7fca6a9f29713b29a609aa04a49fb2b734c608502849abc357452bfa7aa94b11c54da2c39dd1bb406f0b56c10db64247910ef4d0c1fb9eb34c2767851591067bb9efc3129b984ccdc88a1ecd7590815bdb49696e9bf2f5e036f3a82f46d1958f277952430a38214fb8f389f225868511ae0141e4147b48b96e6fd2551b6a04a0ed8c5f5831b7fdc77b9993307979bf7e03109beb3c4a4a90e1b4b96fc5fe68e3028e18f1dde19d8db1f9a1372d4eb025b954098cf4383253f8c709865327445c67c55258ab756c612b15aea6273a825ff63e131787ec787ecc5c521405836a58ece2a5d83acbca0fd5fa5e0ef2c4bb4ae3c7ed535ef7346d889c90ee4536359c931aa7e33789bb2bd52389e913741c0156f45a3f0626cfaef0f4a60af02e3482fd19aed5f76bd539c1bf46f30f02bc498bd6436b1ba1da713fd92b674589ad5f56d0e041a661e600f46bba84684bb2be41fec775926f96510d6e6c123e831d6ce1dbf24c51035bb6ab2213fa51ac0822e0b7f0b79f4cc683f2951e00011be11dad612b9714f01e9b0fe8c67e4519343a1ef2334643c3cd31795a739c76f86c1a75f0db4f043c00850a24510e7565915e0dea5280522ffd886855f819c663a8cf162fa8e5aa3b621d71d8fe0fd7acbcbbdc9d3903f6320f81e1e876ceb7554ecf5e604042288a70832c85d146ddb79c86b66948e1111c995826dfaa0938d3eaf151d16b34c6b7992b82f933f0dec87b3bdb8d0f041aec28ef496048b18216bf65afb739374801edb43cfb877cbd2b4e04ccd9da72267d4ffcb39848aced303270f123f37e5cf72a489389b61735d4429f74c0c3140fa9d97e1820710ca3308200feee4db1270f2f1303cd44d356c3724c2a682e04f12533def113755dfeaa0d9a1ceefea49b12a3ebe188c6899781a5133dce035a42fae37e1a56917d82cf96693b711de5d4c06208182e288856bcef1ce1ede8f2afac6eb9136679d4a4964bb537bf955efd015f8e52730c8d2c345c47b99aa73ed130566c1a39d408812fdb4e3f8822eecf685891b74fa3b1aea13e33fbc056030b17b44655621bcca211bdec5990db3c78958babc64a232d17e96def98e9553a6a14c6dcd3f4ae4c36cf17d1b25a97736f6f500188024deebf0dbb94c9f5d189ee2c975b560d1e0b13e1055fc561c4c2f6729466e5a6b9276dde3daf5de78935d3dd87b749490040764ad565f46d09b3ccef9c4b9ea6a4847015dc4330f1dd7a97a250457721f086ac9c30d491d684cd7b45a7a13924290a3e3fc339aeb198500bf28d76b0e279828d55185c522d29a6913e525d525d4addcb85deaf034be6adbd93616429d4a6ac1ba13377c09ce10ba71390fa9f8bf2042a358cc91e890864a66802db755768771da1a3d416e02e4f34eda65ee04893ff07ed7eb9d9e3d749a8a6b5b26658e93b58e31a8a6c3ecd0600f681d1a0ec3aa8ba0d34c900af5b3270f977e71d224863e460010ac3e8f3699fb1a8f6eedf82b3e9801bdf668216f23da238c3e0e98edf362cd3f7fe91c3f575823980e5cdeea0214827d700d87f78459ed88cb761a81f4025fbe33fda207af4d5244beb3b64b25b64129fa0c6f6b4fdeb4bc257d844097734fcdf1a3b9595faa6647bad14c4619929daadfdb8df1d9725a74fc5c25b96f6b13fa32b6aea5b198b22aa6c9775ca32dccc2310f6be938437f63bd9e5e14a2641e9d36c9f804b93a367e34a6d54f65b96e2f8c881c28b7b0c036081321b245ec7fe2a1f16be7e932e4b1c79fa7887591bee3892b5bd8a59e537740e63e312738c8433b50694fb2ab84f93eb5953679f836917140340f0bea031840cdb308bf630079096285eacc5527feecb44d57fe128158bcb3e6503511ac99045f39f203d2023859dd18b70b847e9ffbca53da74c7e47694087f1ad4f1f61c5ec87de480fd49986e626525f554ea1f37985e5982ff680478bb79ed61ede4107344bbe8e7615d5909112954bffc1564b4ce4744fd814ad8bc77c8d53649ef4c291f9e352c8708375a6c6a80646e4dee43c3af389ce6a6240193ce6cc9923c8937892bb659ae463b28fd05ffc21cb6574192564f13bbfdabeb0443dad0e29337075f0bc56215ded4c64b771eec6768d8bfcd6c832cb8f57f5879184ad973afb4e9d76422eb1259175b3a88811c0ea59fb9d42ae7142b067ea190c6acd14fc85d650009905e3dec19ddd90647e9daaee5c6ec9b325d7595a552479eb3430cfe56f51cd00ec57a0404e3c14ec21630750203fceda826fa576dd6baf0e0c2dd08d8059db39512f13025059f7b497cffca63f14a1a09a0b956354eec9621e0faa2eaac5c7febecb3c4fe06f1c6218c0e30af74ba3509745cc4c2b309c8388e1569e045c797a16bee9a5050c0d5266c48f64ab6852fb521a417d34681e4bea519ce6d313e1704a89d90cc037b545fe7fae99f61b5bef59b3e819c876530222b93f57cee78165cc2c0909c7a64d1e616fae7538a55dc7fa45872c67221e6364ad5df14b88d013f5ca024cf0593becc6945ca330877049d3ed28618471cae3f8d55fe300db95ec0e109e87d3220441c55a359b043bfc9af25f4de079c1fed7e29b93e1790d57285ce3a552a0d5cd2c378e190a5bd307be668f5ca99c90f08440e5581e66f1f428944bc4dd477e395073b6988a57b7a11cce2d751d5eab641090a371c71c53328f7d799fc063113e177382b99c84d4e856b2325f98b01e2f58b3204fc9234d46069d9c2769194f208814151df65471ee48ad63d43b63265bfa324004f3f3d37d756f7871dfa3e700cc4f7445fa6c843c9965276ee577fdd42da30adc97fdec8694ba5e5ffffa9fce275ae1820af1e940fc2a8a7c9c2602c3b5e0a6065c5a12520b4313b8299bd4f1b35ad9c818f7dd3f7011699549ecf02a16bfde9ee844e840723e79d7051e09cd619893afe0ff5bf67f578bc6275dcc1a015e187e545c72de57a378b00bfd7f14ac7534ee14478ecc3d2a07c5eb87826139913848ab62129aeb5e72e3692fd2d3f558aa75720fa56f3017be44db8d047b7562b73308e802d5a8d630013108eb65e49fcada51b05eed23531fe33f0de85cb932802c3c05d333bc4cc3d7849783c6dfe75ae22533e075a4ae1f7138cfd14b44511cc3c3ccf01aa18f5c82e15b6b1f1995a5c249c5a3d11b72fde2d33f0457f8d96a1d6756feb3435b9c5ce40ec45a9b3c490788fae0c3136f035286812915a8e3204a8477411e60e41a5a57c97deef440760dcdb09f11ac21b7597aadf94b1a5094f12ac8e2a645dc720c653eb50fcc67d8f98c859d3310a6b32bf70d599c395eac80e7a09e4dd4dc2b02c0c292c3fe94c510f766f6e974950b21eb852f65ef45ae5f49f1b59188b34b75dc1792b542d0ada7055546d69dcf74c89d1741c887b502ec9afc70a3d59c254b79e2e6930ae7e30b08d99b1b3884dab50bd36aecfbbfdf150197db248754a5fdf86622f8ae0be39ab0413de75691bc95df2ec011d2359b7f974fcb1e176d3555025d07eaf1015ff9b043a410a3a49feca5646a448602dd31db4581697b0cff6708c8a8dd45e4e144586a3793f6d2bb3afdeb22513d2262cf9b8e9f42048603a12cad1c05f2664681e68503f5c647b54f66a7cc746bb88e5c30f3360440878019c4ca2489217e475b0e9fed4808e407749188845b5ffffc1d804a7db512accc95276aa5220aba4ca7cba3709d8f0c8cf0a128d31c8d926ab89f0dd395b06b3200f1db15579c07e4e6b0991db29653684c0c6a8de40b07d3c37850e82c565ed5eb676a46ab4d8d42eb52fcc7a9a54cb19922e06f82bb599396735ac9f351982b512013e5948ff001bf395e14b507fc013f20e21c7f07a96f00313baf4e63076810c5fee2db96e62d0a767bccbc2c7f5390e93a8dcaf2660a8821658f0c102ee714fc328d5fde4c1cba9f315d60a2a2f1b7caca3d6422907d5daab471d81c221b7c2c8c706a5ba85abd8c82a93b9d7818f89639d17ca52a065d4c16b4d83757b3fb2dd3ce2024e442b78c5c9d0114ded9e16a53a6422ac62ab8cb422a0cbf7da98e4fdbf3d1750efc05cc5f107e934350a1726b5121a4d3c3d1c7bb51dc9fc1830a1d40008ab9ed1e7ef9a2a34966183853d3e658680c5da3e392be533ba7a381ebb0b70f4e8a0d8b4f64393b2e2e4731fc2a1f915168db63b3543e0a86d83bcd6791e21a96eda40c3bb937da8d41440761a685913daecffb14beef292430fc2b2822ac957edf1aae06717a2b4b2021651a5c1c662ef46f73ec8d8496c80e3ea5dd62ff03d3389beeed839a80429c634969685d7210490a36eb74763178a8df0cc876e5cc9cfa3d5adecd8766f228c738dee36a31dd902dbbcb5c2967cdc37efc8810854e37fd3ff14ec9e85ed2a22248b8bdbd99d3ad612269038e59c54e8c586bbe334b4de2320d7095caa2682d71e6f8b4516556a07946e9d629239c542a9c4aa0f59ca3422f834c2feff4ca438fdb2e9b0ca65bccdb7cd4a30b2f1d712b96177ca0147ad8942e48270f2aa766937ae03ca083c60a3e8bf048339a6d23b819b20ca169392dddf1fd519a41cfb977e948b4b44646ae769f1a6d0c5a27b3e7b51a4bf7e49ea9a750e39ac277dda7241aad4d749c01a7ffe50def28c74cab48af87928ceb72b41ad2ffedbc0b926fb1c0c2fc5f14a0d6048cb604173e2872be80e88563806589c612c98a632bd2c1437cabaf63c94a92919973ee12886583bb8b25b900849505d366115bb965f6ec6db9018717ed55d4d2943b3f94fe936b6759dd2312ae8b300a6145b4c23388a9ec8acdae455b584e6266c022e532c9f611e7cb317c4fb44549058b0d02e14184a137dd6c44ca1324cdd2e2a698999bd4b7e4c81f3066b24102fd9a20a6b731d511ae28d39cec893774b48d8ec7dbad42f6534772f05fb27aca17a9a3456ec779b4376a74c62764e400a46b5ec8f30eceb7461cebac0f09feb69cdf3189e28d70795a8780016cb523d7c2d92f58e26c6a37e606921ff66f74adc3ddf62c5e87e7952b4eeea27d39bcf8e2bed53d6e6954fc06383232d3b7efaf740832242ee9a54fa196dbe9d2dae1b256fccca43a8c9f1b57a53a834e97aa5ae0fe0b416466e572ce518dc2a54279f3cda024c44b89f8341daee6fd8db87f996c9fcb062670c93533424c24ff5564c895dfcc814ca8434498141336d80545ea75514a147b065806308cf5c71f80f8ac04ead503ad275be535d5cf8f251e74d89a91eeee67590d8838b524e739ac9fd0e9f0c97b50fff9f86c13f8f232eb9c6984372983e0545d267435c61e1a01ae1cea203ce526e9fd97f4e89cdc20e101d7dba79add9d8d2f105a3a240e3113efb8d447575096932bbd6e7e1f90f04ea528a496a19e2f1ebd791ea0c486a1d1380abe2e73bb45b05f8f5e1555d05771015d9d5d25e474d3a6d8bdbdf0332adac0ff8237c226da78490b16df6bbe991bdd3cf8382eb7ff6a1404310b4ea3c1be24f95006ba9c9a6d898294521a5dc025bcca9274e9484fb78c4292fba0e1a6ca81d09af17f6672383df2247b85627aa64c72ab5a76f255be047358facd037b649ec21ef0a08f994b2a77c4b5c2cb4eee05a4b5fe2bb85e09a490bb2b6bbd010b880a6cb1598bb11015091df5bc6c8b442aaa9d9a61fda26800dd285f84f276d85fe57f2a71959890a43aaf0e84d41060fc69db22c317e2002ae5b5e4795ec5864c95f90d1bb7df6cdee9de53b01a2e8a85bf2e34cbd72a95226af347ede253dd0ad8a6935bab6b05813e20b8d467fcef59f186813d0b13e5438d512a84ab0579994b030f407fb553f6581068208b3d0f76914b72fcb7d2313ad15b709ceb9bc7fb0cf00a01ac66ef8abe1227cac09f183920a56072c9a709f5d686f58b8daacc6a955f087d369be165ad21783622cfa690f8c7e9c661ce40ec82c81d0828baabaf522211621a0ad70e2692719e92c48e94543c902efbae590dea74d7db3154e195f7c9180e7052e4fc6f7c1dd0b5cc5e02b4888ada6e91552d9be4350cfb36c9008061f15ee17ff3c6a2d1a51d48275c1327fc1fd07c01eabf87b0672c2cbec5cf84b8fc4dc578836305f85fcc75a7a1970f64d43c22b214cd056976db5270acd7b3b693e1dbc26ddf6ff202ddbe0d271cb2c131ce283a7bea6532b95d7a78fe64105d15ceec28140e8829f2a10690e805b79e9c22dae29b1cb9c92e488f4f1b65381b3f62c44e71bae9e6e75655b6a5ce4a2919280c95b0097dbb3c6db6d7f972c01b5f919e309e1c42b1730acd94aafde694ab7d99bc2e83d35ac63b71c09dede998ad839545acb8c8616b76d761ec3667d93f998ec343ebddb3ed0b20e50b4ceb4f2b4721e9e9f4a403534ea3eb823eaab6b3b5c13793acb581f21cc5c71595bd3906b1e88cbb594793a71c06e0305082ad7ea2c408b480faa46302a120ff5463e023c5a969393c99345ce375d0041e00c1c1c3f29934b0435f726eb62778be5277d7a922de074679e365bce6b5706207a7fd3d19e89a2887a216acf7ddbc1075e484b18feec55b03bd130ebfdff3d2b58a7f2905c6ee40f51f63cc151d7e16bb1cd1bcd16b86afec09680b784b4c2d1ddbb821eec4dead3ec24db14a6466827b57c42c7a64fb16ed99efe68109bab38743d65131e9abc84341034afa5b53f788f95f56cfdeb01d1d11f84a5fa321f27fe8e4a4e8676dfc0e0bdeada374897a7f3501030933730ae4b86517d7008f872fdb7e47ffb307f6023a65e1ec426f44ab96bc3edac77ef0712a7996486eeb7d20b353b5def07607d350e94a41ab711996d803af7f8c8c5eaa10a1ef468083c2863935df3f1e589e126df30a1dd4c7c5f71fd19438cd8b5ac67ead7d2221ee866861d1293a737928b12aa6ac538dd0a59621d5095c547811ed5acd2961b8804d02374a8570e02b5259478dd57ea1b0c15bca20960a11e62eb814775b5f4fc824d1dfe7f19f516064be207694686104e67a141076bba3e1b6ee5931a678fe74a5310f73da15dd8b29375d3c503dcd5048073957146e490931c1665470f3abc1b3c180a8d7be66eebb58441f49d13818791e862fc9f64046b270e94203a1f5f9b604af628f1151c16dfdfa5a83cf61a8ad0407b3456ffc523511d2ef9764da19be2077fe0b97743db986f64c4932c72c3304b253bbbd7bf6fd01036b8530d7fc1b5f6ae45ee0221ad0b3b73de610608c516a313aa11ddd6121c89f59db9fcc70f4412bd99d789d962775eef87ede255d7ab51c64ae0fb5760ba2955ca192308432cc03b1d1654b3d832af69e47c2a8921bf307e0b4cef4c7c7df976e54238308bb9c7d1b947664d97d3e298a0abc9706e18d3ad7babeecd2e3d0ddbeca1d275006a3a1895dfcb4dc0b57f2d3155b2e6e0f63c19aa8a85f5ae149246efd695e942715574c595c705e1e0c9b3740425094a109d089b339fb7a3952c83c98a39d560dac937b7f0ad2b9edc7bcbb4b5709f0d88931ca38221a77639994cac1b3557bada3272f9ee82f0a486724aa10b9c435ee2ec4d04b22bd041ef3ad9e3fc38a5801907611dd40b15f8b577049d6bdb199753fc5bcf05a4789523c8cbe8635ea969b3618385d4070b9532e051377aabe72b897d7917513bb496ba972b3330891f3aaef0367f1c7ea711785567711689e73917b08bf488937cdfa5b2fc370e3f532480c452174378e153a7311cc48bd416be3f2e8420b33190077372a25e99b497dc8fd23e9184caee96ffaf324301e80971e5a6241d3bce1ceeab0bc58462f0891dd42e2705a1c2758ceb4d2b755d3e600e751d9652b7b4deb32a6fdbd495e53b6cf5e18f55900ae25f8769ade3b75e7028265ae7abd83b711b516d8b11ef3b6a21c9c2a6444f95325285d33cafe6347c2885875ecb4ae626cdd240a0884394167bb30ec97bb1cc7517909404e7ffcb8a0e9276791426ab2ec9eb7a33a5cf9f5512c769e73f77bd5800323057cdc4cfb6a92992b176a1a76d905979d158ba1580bf13161947839a4f0ffaa91bacf0a3c194935a6d14f1b6c910ff94fe61b40c8f9aff907551d28f60d31149dcfa33a5a2ef23eb38b319a52093818e4fbd7d5f43fec3c402285f59927239c524f522e5b5389fb5f42bfe25b4ffc12377073b8e43e3d9c2277a50019d4e70c2ac33febcba6bcc79d9ff197ae9478df0537ad0c48aca20d8aa459c2dc66985d4e564702341f0613c131abac855809a6bcc63b10679fb45d107a4f68ab724f25d2d5ddd66626da3cdd0e08edf6c1fbdb094a5cb05ec224c4492847863fa033e4edaffacc82cbafbc34475a8a1fc5d6656135848d5d8f26b16cef00bd8f7e3b38071bcec63b2db4edc20d934f0e7f4b967630ac5052489d0761f71b4743bdd5e525591f06a12d9e32fa05b3e691eeacb7949518ffbcba9197b57e09b762ac08e82bb6769303d74d603a22b72b200e44912f668e147284ed976152aab0886b87721823d2aea33644de7331f3b4b7943166585953270ff9c1d61214c3bf81d8c8e95e3f5cc70892db8363c0f946f283b10ce974c8dd74428b276a1af07c4cc5151a47a46c1f91b0c40b1e31e09a1b841bd54dc3d9b3dbba6582e8217e3fd7b97f38aad6d7b4fc6b431a57dd5bbacbc23b265aeb3a101eba06dfddd5eda4ba90763ca3597954822681a1869ed43bf23ffa66fc24037e6c412962b049ee6c31588bbcfbb13223fa3a62f0db121fc4f9f91e2ea90a4763e247b495a82adcba40ea3e281156dccee8d72f91569c3a34fbe5068d28135e37c330718f79d64a3e944b6ae112907fa1fd1c6af4ca0521c1aeaa36343d8a93ceab71deae242a971afff5a982fe447409b613c927dbd2f79c798529c14b8c821fd6ca233d76b4d598b5b8e60150f3643641dab7383235264e50eb7e31047247ff5432f33850a12d5c999754cb42ae82a3bf0a0e7ef09a8a557be4dc7c22bb140182aa7cdba4e5f3627c193d2b054a14ee88b1c66d247834fbfa5823924127e9ba8cf063a60321f289ef4cabde08d9412b68ac415a6af497e7e463088811c2050751b9d539d3dd5f38fcaac2bf0717987dd81dcc0bdeef338b075e3f3d6ca7a086428908b479c36b54d3f7a77322e7c52b0b6c69979b14117536d955f2882f1f84afb6fed7e6518ebbd45bfa6c794cf7314f4334d990aff92bf47f43168a682a6f40be68d229de4319d0d7251d624d73d510d11ab1f1feac8c815345655a81edd64248f9312cf5af44d7ffafbb7b656a4ed08c9b19edcca1ff50b120aadd7a342968e6e3e6d7a0ff2d8a5d15a65b31b530d46af7f4cc7cb196e310b65800faaf350c070e1cc2c81251a43117eaead5101cb8aef104e6d41e30a158fef39e6dce6007c59d8d34f815f545187ea165b5592d35a3368f9514a07d509fd55c7ae4384235ebad1d0156eaa9dc3929ee5bb652ab5600ff35ac764c98ca234c9a024a51f26dace4fb78d6b6c2a383a7760e59a7ed07ce87ae10730c2e91b1f5975587d74ff53104808e55f833208392265ba9b577355cbcd6dadbe5484a9c9f97b702cb8737e1e05bba2037a29d2fe2bd3a1e5a45cd8c376ab2d336788c7868a36a9b1c7dcda8fa0338c702c011e0bfb48230bb68a43de2d0ee7609af0047e846550252a096e2cee8817ea2a2f37b11b68af23e56fdba88fe792a7f6b946b0ce0c5676ac695c54eac3a925c372fa296584abf022e138933856e6f33f1610466fc2b5c140d80c3efb5de0c00030f167aada32cb25d779aa2a1cac94622335b3d2f327d00011fd978946bf3ed4095af878a059d94c19f5c56ac502816063a0153e4cf14308c174311e2e333ff183a2f297a7ab4eabb6394f9620f57ffdd86b551ebc2df853636fc22297bc07b1ce57af20f843d77dcd72656969fc73a779be1a23cc143da36e949cdae86fbb74182ce1e99f9de8c2445dff4e840585f203bca42b33e7dfcae221588d845c33c061729bac262224719e7731cba8121f89ae8f7a5ada8bee9e7e7c69666e8805626b1d30781130175ddddb0043b9295d74538ff1a2eeabad6b55174f40a4f75bfe8e347d88d0938634fcfe438a44638759d0426f43f124be1aa96386eea73a1d3e9c9d59fb830fc2c7bfbd51bf3fc0d5b7cdf73bc25425cb6465b92b67b7ea2c4bbe1e5954bde9c23139dfed8ecf8c4265c58cdf19ec087372c3c2c127e1571021e853ee193021144b4cc491cc739c54c4b89420fa9e4ba5d7daaa1379c47a746960a8a02f2da62112d4b7ba2b73ed17f1a80b2ad1bb5cdc75c59a5abd7037bec04a4c7487fcbc23f34b6e92efeb57f5d50d2dcffce535bb6be6d85bc6616d18b532d051e9bef48d4365d5b3ba094a3b75be29896540e411bce534b0893046a9666aa24cae05fe483bf9f209402701568bc1df26a4814205d60e71f68c6a6028d2694eb5abd649210c69f4abc19a5246db48412e38ec4ac4109307c154385c264695354d1278282046de5c8e6623b0524a8ad59e4bec2e505a5cf1cbcb7c67ec4ebb2fbcf988661f501fd129845099a9ee4ff830f553ac0991e1fd56ea0b015bb4e2d35dd16bdfe4aeebc55343185a85aa47486272f02eea2e97b9c11a0605900b45231c6a2216aeda057383e460356136bd782310aa43c37f521c4fec834481feb9eae8ba3aabbb75b13ac1d98b592336e7cf65e97f3c5b40e4f38825d2b6ffba2d731d2895504ac870882ed57173b551c6073919e6088eb7bcecb61dcfe5fb22a69e8a905d8cb112e6f3e810c4de68b25dabd48ec3b8b5d6d83d15cc4a7bcdac11676615f0b898876c33f9a80a25263daad1a19446a7087a919bacfef3c74992c882c888796c76a8ddd093c030db4aeefeca177a41a3dd53938e5092e5d6b8ce8d89505244b161973dec70c54112f7e11300fa10a29d61835e8b4d5f7b70a2f1d1ccfed3aa5f49c2b64981bacad66bf9c092b568449879848648fddd47a50a21b19cf3bfbb1b08b14dea9c4853bf6e09072e0c15c86d0ce533d7f6eebfe79af3cafb8241703fa6becf090dc5a5ea93a21a1a04879a57e2092ca2880892804340bd7392d584134ad8bc3c2c8896758be09c92de1765962ccae1a69282b1650d127ee78b9e48938c5346783754b82c77b09e730d919fc50dd62f10481bbc1bbace426d8a4f6f9564b2474a35375388ca8aee722415f3ba9cd70dac13655b4008c5b479015007c68e06056d9a025f664f2d858c7ce9c8c56742ebd9c129c330e5ef9f7ee002216c71115ffd8a9e2ecf1dab3dccee9999f861bcafe11503b694cc5eb1b69431bce08d81cfb841fe02ca79adf47bf48d5e76e27c0e32a1c3d6fb6da5fa470efcd59ed9d2eb21a791d04b127da85bcf09c5f73a1b0543e988068f1f14c14ffdd090c0fb24da1bc14700265cba30879388ac518111bbbc48b4e0d3cf350fdd033099a35d569214a8dd660311de2c95e491b9b3534ae9ef26fe260779df6344f4f50a0f71069a59cc49589def2d54967f11de94dd5fe1104bee9d76787c2398394f0f4e32f8d71c75461c20c210aa6aa2b78c170730abff58f966dd0beb531056b49407c77b0de778a852a287a2f573802734a249ac369bc95d4d16bc647e10514d52b58580322925be6aa959606db73a1710a0ed06db9d66a541a3108e8881b6fd71eee39551208f2f88be49be8fe1648e5e0f70cf388cdd0f485f9c534a66f2b2251ac3f5147d4239fb5ce5cd7f000edc947283e79f19fb5c821f792af6997a7e53227ec5d157cf57e352dab116ab4bb3a1ee8409df8964da6fd0710bb5abb2f5ae0c9bb8b389c6724662386d44ae8a3e9be1511cb7486f1001c562c0d8628b25c0e7926d19148939dbb1094dc4c641f1af66de75aaadbaa056d1e8a1b3d6035e677174f4ae34e971f2ce2c7a9a65dc61d24db893ad98e32046f7a966dee30312c7d32153c2e02210fb386f68c7ea7af2b28c218b63b33b7a432eea43c02d09614775b095bcc949cfbe265b2383474f1cdc9cfb3a022aaef446d517cb86169d02968158289b03395394f9707c3247c1b385c6d726ae046ce4537bb087f059a931b3a61158282627fbff2390580a25a52c91edf45e769058bfab41fca5d573d0ee84ac2c05559bd3d37520bc58e7c23c65f2ca25a67952036223815126ca7b34122f25a597b0d64f79f70ccde38af3731ed85f2158ba2fa44cae58288bceac64236913cffe43cfc708bcbbac16dde4536db9308065c5f3d739fa07fc65c496a2d64be9ea5c3c9868af7fd300a180e126bd511dd0aee9dbf575cd16dbafc6a0d1f7bd26fdb8d8ac33aa6b9f9d72b633b97df28599739002d2f932b065b0a2fa19783644825a5a72fda64b669dc4778e673a30f4303b61b646185122d2deeb0f4c26bd18be67f104ded141bc496a2b9bd5c8e576f7e276fb9c780cfe2e02388de638e90fa3e5d8d50c0f78061f4784b6f3964189b8c38b1ec0f3a8ca68c035779b03fd630fa6e3bbb6f884f152f43633bfaf0d69ac8ea660b16ce3102a9d9a5bb185dabc6001e78085e3c6d9710357539624e81140eb56f2d8f57c54766a4200b8f4cbe02b4466e3ca0784d36383680e8ee43f89a7a6f05515a4a83c003c564b42bd2ac7ea349736143f4f4fda76bd537e1fe6a1ba79c98d24b8a71f1d55149839e703c1f423e837560d5da42ff3c5e842d76487c455c3b350129dbb5d1b1d0661285101bffff2e9a4424b1b9a2ed5218aab666aab621a2cb0bf0a06b405bc5996c495b509ba270bf3c240c4e526171a75fc95755403f9def03bc55b05f549d5675f83bc94c373ff9df5111a044b2a28f98502e12b23247b53b8129b5b16e951ad478e7ab09bdbf32d1b84e828089f0b3f485449895f570b34e3ddd2dda261f6bf62952c198bd8ce8a5e6a40e0173e61341271967fb55ce91ac02f3e696d212106612d12ea9b0bff979ac6b1c2d3846bfd05bb3bddae8fbab4180561c7610f26ac7e4b854b938ef77ace4033bc9fc939ae4ed409467a8465abd027d7a3225cc5ec7fce38f0b19aac7085f9c502f00a33e24b34f629","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
