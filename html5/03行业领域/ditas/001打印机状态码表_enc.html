<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ee8fe4e13766d9822058efbbad5ebd7032ac9e7c42ecb0f9cd71648e2354db424ac8827b1b56148d9562c167038ca956e757ee2cdde4903c7e9d214acbb36c867f639477981b7c2b35d85e4591b5eb5c9b1eb22a22ddf8bc05912dfcc9ffa7f8cd9cf02388e9c9d99dcdb7557a94a9cb1d5b02ebc887283fc6c14fb0c3078a8c5697abb1bb83fbd1bc4b161c7d6ffde545917aca04fad0231e140d09b31891560b9fbaa2047b67bedce7116bc6b1f5de57a34e61c41682038016b00628d9a8361b1a32601a62721ed617f0b378fa2eb5937134cf958363118fad24ed6672e4778ec9dc23e0b465fd6cabab9d4e30d7b2c222f4aa8dd2fa03731c0b2d61f400853af54308f09c2a96e48f30e2dd9206afa7cf8624165c28666bd1814cb9e0e5ab44752f3c287e0b6471b0318aef8c8ac9f02dcc5cd3ebf7c3f5e9929cbbd96882a3dad1180baf78758afb8764c746937d46e2d506be38279475354d3c54b236ddb701f166d12c728ee566f3437ac52f9ca38ec182a848a2ec1c6df157fee01faf7def429a983f4855fa349385ec21c4e9720f5bbc989529c28c3dcb8a4ae493c58fce204b9cf6596a2c363e79d56714ddb7b5f23635323507e0a91b7289e0ee1528d96fa34d71c284828b7a1fd8a400c4995e036bfa8a3f558e416da2ed785b4d7fff34e1e3701adb115fd7ba117e418e751acd045a9fa4400e7bd9eaedb1181fb74fd72681819f119383442fdb29730a604eea60b1dc5c1b18e707479d18deb0a8dea510cbd0738b90df2d3b77980cda641005bc5ec67874761138b92f36a5e736e42a80d1bfc26b3b230c7ad1c9d8363c78d474af1401e6b04ed8c2215e0de4745f597c8fce3137e0825e0c2bf09f8eac67afc0dfad62bd04410f75407d556260a420cc9116b050c99f9eb86751d707dcbc341859d4b6ef96eb5bc6f55d8a12f793a6acf1aa25db6238cc35caf57b79f51168806641adc0aed47894feddd055098a2d03f12702df5ce01e585062b56fd5f1a3e137ae090edf5f30d490cf23bf614ca45393535ab4b888c292e0ef87d1b22ba74fa9d4ea1b2e50b1d3805df0e59ce36a48312f6b8a366ca7f5adfe093d5a09d1e846c2b4c59ddfc863c9cff1ea8f3e04ecb4c11f27ef67b87469f63c7d8408bd1fce83da5a5c01f44212ca40b80aa2aaaefb3686037298f821c3140792a91c5d3d9631470c71419afa3fa88082a6d23f0527caa4934396fb7be5d441cbd0ea1f15401cc712a4a8b7bd841ab07cb9616393701500d46dbfc971291d1767cf8cb728563715ee57d50da776a783367ad04c78d6b4e1f7ad61f4fad4f063294608519a8c38ca40d9d3b07a8f75069e148f32cbeb094fd3fef67ec1e28d03194dc61be2efa6d83c2bd2832676895f640d6807d46cdb77a5d9c7eeef41bdba46f41004e7a8d5f06a130b4a73535dbaac0ede0cea570d8f6bf4ee90bafcfb650a8652a107c6337f09e5012bbf928d847cae2e1ceefb3b49c003d425a6d76d2b252aa2b0ed58e6ffca7e0dfdb1550f8b346afb17e59e0bf39d0bcd788d314421f0600e43d562f5466b59ee41ce72a33e55d7a394c47b392a4cb387008bbd4fdcfbd18bad2d1f9dab0ad34c6698266599b32fff769083f644c8d19959eb5384915d341ae0854e0c70bbf520931087ccceecfb49f2f5115f50cdfd3c47864174b66a9cfd8c10e36fb17f7c46daba866efa16e79709918966521726cdc262f35c16f80c535612a736ac80f3934a554e011cac1a489cdaa3aa2a96523c7a9ca4c067667fc9b16154162e99917525951f92c3f544e1915786554f231721de66136eb0ab0209c13aab70966aaa320eb68645df504b37b41f609b4a2c35094b0a556cadd0d9d7ad2e6d4b1f7cdc57201f3276032cf30806b84a195a26a01813c4c963b13cbe132a33384eb401d92f7c9d96ec11e4170c409025e5b3f2ca8568ea2737b5d118e9487985bb3f28071ce7f3222bff6ba314c35f01ff0eca8e6a7f37d6adbf2203fbd6276d724992ce3418be6706180ae1578f2a69576cf75bfb22008c60d87e125fa5923926e7ea829bd8877f16b0f7c33b5545c7eed00d584b8ebb26e9e666f7c79acceca61be38cc5ac49eee369c1c1ef382c2866083fd594a58a96f187664acb97ac2dbded7b26a06888f6100a8da386afe7214749923d58a2eb91cf739754258a9369c279887af31dc11fd77d7b458826616ef14c9643f1c7d0f8a9f0b3d45342c92591f6f72f389886eb3680188bf9a66514194fa2ae4551d87c1320831570f2969be08899c8c3d1d235db0d0f296883dc2fe3208f09b31e50e13309018a841b21ac67aeba627b8b2416a36ebb298f80928c96f6405913d69de0267cbcdaa0c593ef63d22ac65ecfefa492b078d51c742a3cbfae0b7d1be9611e5ae8d8881f0e8ba131b8ce994113fe4e84c59cf9e33a736389fdb15747adf990d46cb12f94be647a74a6c608db2e14a5b907f45a084c70335a18683a8f7bbe889fb8b772be1747b1fdef35d9c2380faf01bc1f1da694ad69809ce870c735470a0861fca77a7ee40fcc80956e9f26aca5bc48db5c9f685b82a45fe3e53d5cf2224c9dee14040ad03571ea4520cf3689c14780304f00a7c9776b5408270d0e8f3a23ff2a6cd86b3cb04a90547b03822688bcf521246844cf9415182a20beff13d3cc2fb5cd23a8281b2eff9acb79256aef418484c9d744e4f4b4c1c00217298adc755402d19172f5dd424cd764d2f387e6b4b46354964940996410e9f6edf8a391c810015639e57a11f22874730d9f64875d9cacda9a37efae10b35c27c3dc29a3a8326969183a7bd2305f747a8ec6febb34c52487f3b940183bbd3e55a63e744bac7a1021edbcadc8961452c8f86aaa2b71c9020af3424f5c21b076c606b379dc167f1610d58e3894c0a368030973dc048261e9075570ad8cccd708c25bdf85c98556d74cf62aca3e412c758c2be5776e0ad3acc0b0aedd12d428b188111563d0525dc70730f100451aefc9e611ef0e2028aaf6f08698342e640b182f7dad517f57736b237770c320df127c33484cd316824e8e6842ad112d2768faa431b2b08e19ab5cad9a7e41c3bad6b4e372b50d324a317c02b5c1299a3fd395b4931bcfa3fe76f8b8b9ced69614c8943aedd8415b04c23ba264733686611fec321ebb1831efc94294463c89ebd1ee4e8a76772b155e55297b540ac94e376c1bba7385f8fbff26a279a07a12b15040f904b890a9731849aca02ba9d3e316f4ef1d92e296be873001394543e999997b522c8690d848823ace2c52c656fb564d9745061e1f1338e83011aa92a5aa714306228190678b956d760f90f4e3491f0d4fdd921fafaa7cc30808d0f2d47ecaee67145e376d07b21b481eb7c23c21c234deac5356a0614a61b9b9f5ee5c0048c9ddb6a0e6a5e7e2d7d586d8b41aabca73a2f5b7afb90417b7d9dc321c8fc14402b93b710ff4845751cd6767d578133834ba737f5ecf180270b417d8cb9aaaaa612426c898b65c3a6bcd5f9ae52394ed7f09c19726045332b5e67acee54437e9e713ea092ff98a6968ca70af6e0858c04ae9ea80ba190bb132e454364e9cf6442fd1ae99a491b1427fb4a34315db5b46503ef7f2ea8fb1792ef42074b666278b2b0ad022e567049d0fefa5205418ea378f8c75e82c43531bdeb1a81084979be019a5595709ba1078de07a3ccd82c3fc8129b25866d9a1dfe903e70bb1b1cbb0b7ac8f3b06c36f48fd5cafa0c59a2af3915c38e7601735fbfcd3b3d55e0cba763093cf8bbd8cb981f98629404c1017b5484e7b279d439e1a44955f925ba41ef82109efab6981395eca081b3f36735c3cb783aa16f9f07f3b8233a2c944a72e8b4747b20d288fa78ea877c6085ddac3a686f4e9a2557654528318117a33727cb88d0a90f0504074c7e1ecef110f9806370b1383762d8bd78f71e24960345b3773e2664b309e5b8ada57c9d0ac398b571436feeb87dfbacd6185bf968ecc68aee7fcc2027db404beb61a379f0b0ea35affd01674f77db8e34732dc6f537bfedf11745f2f5669f910ce1d68f495e4cb6914478c6d0cef947e8b4e2decc8c90d1494973275d663ebf720d0b1f06d8067d7d6d5214132e5bc5a40fc39f1b2ebdd57ce994d1c94929b31174d86f0f99162efce53fc7bf366896649f6228f56153d1c9d6b2a27667c904a90c3ba67f1d81ee8e1c4c711e7733cf5b34d2f4e0dd113b5d97cdde3212f7f8f1b391d8d4b5a4618c1073c646268f3897543e3412b84e726e07a7315f2f850a3f2032ca4576d0f0195b58e9f7cfcbf150255712ff5e5304e4de5c0046732174dd69e6542040fa66ea56f295906348c01125b622b7400540b7f9c6a6c689f517a640a8ade5f1c45bef9cddac9f8ce1581eb78f62f9e9b3e56dab26f3e91f0e55b39a0a0671d39b62f5b92e0f31c04db81b84fb396cb9b42e82ddc46af10417612f92b0a0c4b628ebbbb53722e886a8565885b723d15ac4de9591fecb176e961128753d6edb3fb608cd740d15541ffca4cffa71ff7d4f5ea4a2c4df00967f93c364405f14e3cc1bdcb5451d51d22b7b2f7d100fbb3d9aba5e0f5fa56d11986a88f3aee62161842d7cef31ea9fe426b53d18da203e0d7e5bdd038a6be070d7bb79c030d9e131998b0228f483e991913e25552edd7dee019ae6e6c91ebc6108ff460597dfbc26a14929a6dd6853b644b9d1746441cac44ec036b18d11df44680dbd3264f1f19225f4c6dc458761563e59ab637b8cfcb986363c8b99f990b4e4404bd8cdbdee60c902623d7c1cade1f2cd760dc3543be3902828f47f330236bca64205887dd1804604460a6abe90e852c81f9000032a0813dd1ce54ec39dc03c2720bb893456610f9ce5ddbee374b16d61a80b85915d6abaec96b4d39417eb3025ca6ed5f3e58240e66c8e7df2e8f2f04268547bdaef6099337ebf893aef9de88109aa4ec0b524fe6217d17806df22c90dab4120dbcd1dd1578b501233d5a91c141ae557f5db2f637f83f20e3f6551e99c9880752fc2021a70031495aac36263c94d55302cb30f0cf7a8e787d972880ba7a486698c0fcea96c155f4a0e4fbec7f171efc1bf3463a56bf7ce7c6b6f58d55a0d729c31e1229b8bdcf244b97291226be412bc848eb2c1251b5eef6977d2b1d180ea516be83f7dba53ad866e6f280d2f1802e25a5efb2f89fedff93d84acd5d2aa787cdb8ddf53f69ea9a67fb95f2f6d33ef7cc86d48016028709abb6f6b2f0a99573f5dea5a4b1b139aae319396778eeac9344a44f926ca5637112371caf6f993bf5b8211d6ff5e4c02dc3c94eeaa4a89bb9477c2c03a975dc667595bcae30f8f5e30ab8ad1dcb9bad7c4b84280a6f3adfa3bf973936918fd20e485a4a475278b4f357686fc53ba32c1b6e5973756de2d17a33df88357cbf1a10ee35146c1dd55df02a143520e7fc6da5bf50ca094a27636a75b99a8f1b1a3c2c034aa7b29539228cd4e767fbcb22e6d36da0c08d1fa7917e07e4908488bed9d9b318f6f7f1a2f1ed84375255a9511da1da3318c98ed1801a74dc299d73f851369b637b34d9bd919abd6849344f66b0a8c41f434a691621867b3b554f96ca67ae9de516ee712c500817dafc74ec291c84bc47ab80f270beafaa6ac7e5d00d712c242796a44ffe8b0e90439c9af481821ea551a6402968a597b24f04221e754bef05fc4adfaa246173ee90092308ab6d7267870e5f0a3d81a474302332f14b6ee4f3ed8dd698232edc55bfcc18af7f5b53f358bfffcb07bdfe7d5fa2e4d7b268946b762e22c636b0fd0b0a94faa782c8d084223706c61d22834eddd2e8df1a47c137a23cf810a87183154bbda10b50ca22cc04532110f03ba1723b12fc6fcb7c92bedf1ada92d4f20822d62efb048bba1985e0ada3860c1d949d6b3331fcc1b71cf30b494bcbad1322e5051f9094cad60ab2f12fe99ead6dac6ebacf4ddc0a258c6cccedb2795b209fd80c89da35c081e2e71542b8fe9874932068e328f0e5ce289486e9cf1d501cb69d62c7256afbb9370eed4b77264dd9093de6f034d3197f02e33b5b40799015c5ff5ac5d94b275e8e9635e0269953098dd658a6f2868765a2a36751a4e5c770e17db9f292d8550015e2a1e364a66f95ab83ba49ff369a087f6fbbee61ec33cc53efb54d669ebf2cde33a38a457e12ac5950b7ceb3fbf29cdd11d806e6056b66ed69b4f732cabe59bfe35a9b303521a388588fecca7f69952f96e8867798dfa968d298bcda27d9aa8b3f2a4374fc65e2bdf2768d886eb7dc41f8930d0cdf0203738ac5829a431bafd7b88e6064ac6c44779cbdbcdb7c9802ead08d662aab1f8c5c08be8b73a783d09b549ffc0657fd9bc7e07ea8c663efbd5a298fb4a36fbb6ce9897bc263d4f1a08a960136a69a0d3c1c36038c93a0ec0b96d349cf75177de4b9f4a718b4b92acb0e0cc464dfa9a9cf67bee5a00a2c9f32c98a40125e40b573800b8bdb6b705fab77d8b7e8663987fee1a29022934fb698b579021b80f24f8cc2188f5a31b8e81b8952e7f5cbfe97b343fbe651c898ebac4aa745084262c2b4da123a91e355f27cacb1b1e4ffedbe12e7a6bdd871cd1bcda9e310d937b51da3d8bad6416a97e9c84197037e29aefec829ea651ed0acb817dcaa019880be8f83bb6776c795930383fbf657e3ff48cd2db66313caee7eb282c7879565493925d31bd6a2ab83488170b99afdb811409ad9bbd1b270d547e8aa0395968944e07c529b5c2ae9fe8f2c1d5f57df2e171618dd1bee4a7cf4bf5993125505a9f919f8287988d7568365e0ad74da745983994b2afd3a85b8e8f8991205d1427f57945e1fcaed44ef19ba1993f1b1e9f78b5d1768ea55117ad4cb459a1ac1698a20c6da3112ae0a2b6e2705c9d9408011f498db37e6df1880903e2a65a5f8784342c7450c97447ef558ed32eeb32c8d600aa0764fafef4c38c911e6bfcd75769c705dd5cbb95690a3cb8d8a5e4603f008917b70ebee1627165a6fa4fe931c1b808f9fd9d478eb7eb2faddda619e9a336db2a930cdc4206c2b8795a22ee26bd5f1659476f165161b424680aa2ec90201e9bd1d9971572e0db5fba356041134b31fc558afe6bd5dd94f9d859efc77ad5a6912e65e02c1df51b90f6253f34cb9aae1eb18308ddd77804318ffc68ba7db5a5241c14093db68795d17b4a0384e9052ad62fb73376e9a3fc4ab7ba6d6653af91f2893e33a2dbaeddf60b79e1d319c85b7712d8dfb1835ef39e7ca0870e549fdf472b7dd35665e4b584d663e41a23c2d66be96d618d89b31b49d3a10c0ddd05fc07c8787c3a2fd63979b0cae6fabd129d363a343176caf2f47a92304c83c92bddcdf6e4571e09c234e95e6e1e7f7e6563a64ec2e68e061efce5e02ce2b8a7605c174f7652fdde80f6d7554b430085d72f62ccbbe032ad81a94f7340f50d7d75f0c75ee125c3c7684490be238daaa2c08b219afe9dadf60b67f791a32031a5af9e36aeedce2fb889bbbc5abc7140f3a68d837cc2c5df7bd3bb2f8497173636f10ef674a84d9a3c526f7320013df57c08404e880d4724d6a92261e00bf017608568d17b2e8c83cc52f8f5032d5693375484145250dae8516f3a439493c402e15c559cc875347dd4ba728e1299783a3919812e5bd2269486417035b9aeabd3a1ff4b19b272a6ad8bfa62ab90088ea35bdce37ae26d82062af5f5a0cadec64ea7a88a65d2c825211091821ab6ff0981d34068dd91b32b111b26514f308903a433614c1152c1144a21ba04f89a0c9d75b1ef4a97bdc4a7cfec0107ecfaf98c004caf4e3c06947cfd8ac38a224e046af36bcf6f6728f25715b4d9b1f8bb55644aa1a3dcc3388cb0b3989e20d610981b67d0f84b2d659674802f68d7e35541e8e637ff568be2def67c7c6ee932efd77a1ef06021295efb1867b058818d3b3002e32016e3b369d29071a15be6ab810d0b46d90b1a577b630258531fd06625375a83fd61651acd07c27a952ef8c30a4e70ad8561962c113489566adabf6fe5c41b47fb1cba3d693b077b61eae85111adebb10507ecfaa20f2bfddc909fab0848ff519666bd63f064b2eaf4347e0429c9892204579622264cd649916a3633cb877e35b224b1ddd32e309a9be66a6d6b637eb7f33c948b4254207ebb7a198ffdcb34bca60518fb2b39715ef2af85d1c183acaeb3e8a69f8c2341def68e6718df14f66aa0227d490564960e5c34420768a24500ad2058d123af767b6f92c7f49f83edb0a22159397b5247171bb06ded2a7a0d753fbf3d7c27a669b7c5cafa75ac2ab1233622ca9db3156f448d143bd1f59f4558c61f7a295f86bda410b27839628856e3adb113ce6c356b561023c5eec7c769d78438e6b1b726760b444ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
