<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21837820d1d7ae3ca8d1cc9e7d0a8ccdbb14723822b297377c5ef8abb56f27e974c4901e9643f1b4a833c9ef511d90ae94650df4da0f8142799d7de5046e461a9f53c7472f1558f87a33f5d9897c05ffe56de6336fbb859988088f7f68aa2b8e0adce15a80522998411c2083a2e0ca9f074fb433b04fc1a9a5f5c411305af378d03690c01add7e43ef0c82a402f375594cdeba1370b394feca65e0456a080f0c9c17c3d8a3a8e22ea45811f5760a8971c283962823fa41e32c1d6f0d30761fe9cfa077a0ddbaea66998f67ed3438013d89e122e4dcc20aeb8b22c1827b51a7a3ab94157a509daab8dc826356267ad9ec3965564995613ce0da6d64944280db76d6e67941ab3e5f6314a2913750ed87464d3a0758db8ddceacd356b499a93f9ad0b783aefd4460e76ce98b8e43ab4d35b7153b1f0cd82b83c6b35e8a23b874f8157f6e46291a41714a78d7c7c09ebf235dedfebfddc58b6969cce1416bb25994174895857857b3d2012f52475b1090d39013ea11bd6b35c8d2fc824c7fbecbe3e9a24be497c55188bb624631cef087cd9bbc92ee2f8bba5134f212c36dec6444f146c1a2b0e2e6d139330f020247117304459cddc2b372c1e421a6a55eb8ec60b0b7207a6b0be4668d05376828a67d6dd375b922ea7101e62ee1c7f49ba6000a8129e2260c4b07cb87ebb1d69eb8eb91767b4147bbe5c0c789073aa5776dc0294b2c7b80674a9db8100fba86d002d27da6f42557094cd1e1657d0ca2e4a945188a52d80c71a0aa18982cf9b742a348ab2cd88dfd9b6f52299aa05334c3df0ba4f15bf49756dc2d3b3d07c1d5a7bdc27702927dd099a47272a2c15d9d3ae6c01b5a4a68bbdaffccc128bf37db94116f161f72ce0080d080fdb799ab1633a6ac209163079f2a1ed9d176462e03224372297a9c69aa817902174f09f4b77a362ba5d2ba34aca7c118ee59f1fd70e0902974376ac53ad7cd381cdfaf122fcc12faad98d56721ebb1a09aa3ddce67459b72783b3dd4c3babdc487d9a343bdb0db59c5537b5a488548c4aa8106ae3f4fb65d0a66ff628ed876b0b72853599175bc6fa251c12f01d25df25aa1ac92f846ae18e44f163904bac037eebb55f9d792714879732ea38e38e7957c7ddb68df416fceacf24137303657babb06b884c590878fb7cb158a89f7c2b89857075af03ec83950781c34e53113892b553e087275a88d02ebdcdcf952c4751490bb1614bc6262e08b53fc2fed7f89a6795b0b82adbdfa56e5349d407bc152ac5c2f9edcb2a5cbe83076237e935b6f488c1c3e92e0faab1ccc432afd835b85658748dcb1e00fb0b9ea8e30dcfe26be598599fb4c4659de5b5d1e65fd87ab53283fc33ac26b058a7b79492e159992f66b7fb1ad1bb49d1a7ecf30c8e71018aa0f919b2611fb287891c7d0be9b8097957536c4927a191049f4089850c33e397f0cf7d9a775d6b1a4d7a3a30fad1bac25cf4a4188b9b89292b31d206035c7e56a088757604405931569235d805d023421c607a94e363e87c77817f4548c1a64cdac8fb66c10252ad6cb6560d74aa17f828218f492ae1f6aa04cff2a2dcbc819cc604f552068735dec2e3fe7c45421e3da066f849c161ef3a9593851f0c26f7cfef54ea1145c42a76f16e1145ef140dc852e416406a280b9c902f9abb74b5834d1e0f29803eb9282ee02576ebe2cbfa2fdc296b4004b5a0df7931e36dccaffc340e4fd96f20289a6086056867dcc66d62c1154fe6b5efed99ed1d9981e211d3671f1e80b25b31d4f1c67f4dda32cbef023a961b831392d883202e7d4f5bac1452f1d23ccbc98a8412f1184d96a29af4e83f4dae4c524ae7cef1dd6095a9d707305775944a9fb44ee6e55e50343669886caee4f1375dd54113b9b251fdb0b33df6982f2b079c89d62b0e47ae5d7dbf8dc9f99ab8be973c31b7c6a724c50514bc59b39c099347eaba2d4752dff2b92b012a94a8e016df662332052387924948ae84ff222ed1c720c8feb02afe91000868133494fcb29ae21059fe0333df36edcde706f518d48873caef3174a9a296b0af1fe92673a1fc660db4a07a183b79f4d6fe4fc03f9769b204f7f6f955701b852c4549c76e3381f5ecc7ce9eb5028c96cd01cbd51395b485a466d638ac577e6d5a387266ef5f014ffa85d5c61920c4dab63950aa7abf0476865594b3ad506c3e8aa1ec8be4de161fecd6565cb45792042e1103658f950972a3f2f7410754063ff7d33c69f893fab0e430b1987fa6d1e53709b052f61a9321e6b1e9c0543473cd2d0f18f3a87c57bbed7a79663c9ad587dbf38375e7a3646f6b733dd7349e773bedfaaa1af9edf75558df3fa2972c49d607a63f5d600e583a7925a3718a11ed4cff14b02cdbcab56cae5ba5233a1f9651d1fb0f4ea16d2925e1ba22f892041b1c0fa178e1c92d96374f01bc8fa01609d1d01cfee437b4e0b7bc2b6f127aa4f7fe7abcd5c32ee4d15eace16e9bf5808f8aa5d74c681e9eb8eb89e13841b3d2c0d8d7845fab369eb932160ba52f6243d553232b831a0ab52582f07d2bf714571de34b9d5ab056dc27e41119e03a688d9f82ad99f7009973f751471e1e567b42dd2fc20fba6ab5b138964183365cda023e8861ce86f944118cc47a406dfbc2975acb7620d6e00cfd8c6e2c2758228799e46cd9b571ff159f76248b3b0b53b40caae7a7511b141135b9a5b2d2014d2e0128506faeef2b118b8e63689ce5cc391b9bc35bf5b3d9fa28cacd0f489c41f0254fa68fd331ea19bc82bcbe3ef6f1591caf9a89aac3eef3ee624a4081f18cc27ec9b93c44c20fac6f4efcd7df01a98e255d9f7965ce617526ebf42a01a0d72232bb4de927ad4718273565a12155040f45c2af0b97bccc7eccdfaea56d0af6ccc72b95661602cd8703a0bd7da767ae0f3134b342d4e3f037e782d7d25ccb3f79fb4dbaab899d53cf66c7bf84a54817993dbf6412f46f13be78728955ca95a4cda3c1765ae8daa0a1b061c882ce0e358a28a84c16c915d85a6d2ea26aaec0c4ff72a3fda5e9214ee7953cb4be58121734ea79676fd2010d7b13d2fc9f01c242749a5121927e7d8b6a0fe1cc4df9030e6ac09e8e94ed37bc3383cea25e3164ed83668dc3e056633a0f3bf81c1ac3d2d6b2e505ed79fad3875170495cd194f61778c3bcb9a83d83ab47c6cc5c9e8def75c68f76d489e993f5866ef35443f7b6b20c063a699ab26519ef5433ec9408a7ca18e003da667472d4090463d89821ad2567c1d6add72034d17c638855ecdf4007c570a166898764af943b4b5030714dfa3864ed56039cf5b52e7cc928563962e727f844c84eb3c16efcdaf0222e01133e5963a1277f82c0294f891102b9dd600351988d7e310809836bd6856f659e04ad65a48c2df9790d703e43f048962a241ec485e179f3569b6f3b186978e59684c26f5f7a99bacc6ada84acd80a25802d0aa38ea96d820a003d8f7ba1d901a6b797fbc43b8ed119ade85acb171a0bfad6eafc1f50eee8e092dc6ea7435684a2836ca646b727a31d465aaabc80daf7ec91d8d4471354efbdf1acfe36c239afe2be269a5375c06026adf16d5221f7acbf098359f64f4e0dd74cb9bb112c6dc2b061979ca87118ef9ec0be09699acf1a52520c5bfe4ee233fae97fd36e9c5cf48c3575e39b10025d4030b3b2db5fba5151cc9b578844a55f67d2423fcaa12b086644868d712d110545db1d8b9b9af4b11d71725bd9bd87f29c3b37966300d7803e107e604d11d9e4f82d19b482d69432bafed759279b5aacafc116c902679b9b3170ac62fbdeb043396d131937eb3cd2ab542f56f1c4ed7925e5348818a62db3c14c0e1efcfffb89265602412056b91b33c6919ae62c5dc48121744508f9c4777dddf95e3222941f713cfccb7ebb3c8e0a62b9c7defbb8258efcc91095503c6d50431a38203a828233c13ea6373fb57340195fb9c394cac5b92796ea32bca45436ce83a461f11ed95b230093b42f5e0a1448c013a6c4e3e8403dbcde45a99356168a9df44aa2d6f81fb2363c2c70a286cce8361f27568fbb6c062fb0c0478f0d68af526635edbb232af56e17ec1e2ef4835be96582a1ba9f8e80ad7ff1f1a8df8ec788fbcae9dcafc1a7088bc37ac3224739de7af4a18a0f3ac8fc77c57c0f6daf7949e615b4ca8ab0884a1457272389f79fd1a03ee235df9cf1a56b74e12a4d3e1aca25c38bbf7fa5d28531f10d53c926f19188413029396bd7704cdc323f4fc280894c8c0e9b781f2ab59dbfc2670cc88d824c3ffe19f186f77d754faf0b26e059edfd0bfc8d62772e4f0d4713d11f689ae4c775112f067040c87d50b7b3b30b2e382509cf15eda7c33e4b2d8b0b882239e50fc31b1bde49f67287ca3b3c162c089ca869cd19ba884158e1c123ac5d9064fccd487b35c38caa9e9d54714056ae8e8cec1b823c6d78849945af1eb516064205cfc671c7ff2632f270a1c1ce525a098f068de2926a0bc0b15e96e7b1e36b7f226335f8c90b51999e01599604368d7b9da56d82f0165771a702b456cfeb6d0a6cdfa90b1544001015edd0b39005278afe30e6b9be9676410db0cdfbbb2259f8d817d3ad4a17cc580f693feb869bd3338692c7f19838595ea11b9cef58f685233c83078f26cffc97c8aa5f9f1fa9e18e06a11986c4a407a5a13858672f0615402fd6aa270a1033645855883675bd1b9a3e5c840f115afb3ebfc2088abd2c595a12e4ab9a6df9cedaa8bc97b24e9e921f6d634000d75c96873dd4200d1fd894313f2c3cd9c9387b506d160a2aa8effa167603eea580afc6246df5cb1ff4277c05d204e1062e20023004ff1742233494d5ab4ab284e6cbad100331246e3ec74be4b77902c28a67a7e6f349183c99899290f567f191cdad0d3ba490c7d86a5f2b12ab1e6568c87b952df7dc9feca99e2d73145b0e48eb9589590f7fc1a6ab73f15dabc570910718f8cd2fd027dc69c57c26b79bcb1ba56a4b66ac6f8db8c3fda76019","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
