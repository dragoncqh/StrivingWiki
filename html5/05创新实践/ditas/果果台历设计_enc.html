<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c2022521673f89cd4897a493892e56d833d56f7655b1c9f644867c033ced933d758c58b685fb4c73676285656dc408eabce489ca041c7c0cd98a567d8f3dd48cf352cd01abeb1c4d1b90b2817fff3562d77761d2ea5d5afd9fe741c295aee7bbd6eb02471e98567c9a96226166babe371ce2bf95e70e3eec09a3f548f3e02f7a0d850bf13e68e25d37ff08e7ec68457c7791e90b04337e8c58f30d435b9f113da0b98ed60e57d0528e8937e30a6552e6be3b087be9f510f0cc6756ddefa9cfbe2fa99f00c78da59802a350fed8d95a17f7881336ad8eb52bbf03c58182b25ce0fa8e9baadca026899303200fe3f84584c845147fb8d9e6dcfa5a4e1f95b2875496f6831ab163026ef2cf8fa5b658e9a800bf469de44d0b4f01cd277b38f79304f22e8922f98706317e31aad41c095f4f6171d7516b7d068d7d465ce601a64f8e2fe5d07dfe886a1c8a6541a89f58f474595692ac31214a27cbc2829f1aee0d56b1786c0e1941cee36e63915c38ad85aa6f0bab8344c6ec84b8a31dc5462de753c44b2eb118be255963d0a53a0c11abaae0adc2185bc42679579e2adbba8db64aaeea372278509849b39a1b263d57ef554e802afc8932cbab3d6ff97386bb26b909004fb95b1dfd14500fe5cdd3db7855e6891d5d8363a56202727df395f630dea66f013cd53cc4433feb419f2ef26c0af46cc5ab96226155e40855645998ea35a33e9f50a71fbb2922d6d8314485e1abf904e1764f7d4959f32f075bfac835833dd98b8504e5a7d6526bb45a48551c392b0ce846b13dff9293537fe0c99f5659f26592424548327b3449dc9104b9bb30469dbd7c66fc0268472c63247f2a4f3e9888e02f452180d840c79e649e693fb6bec189dbc33588ca704874a427e05a7fab6e0aabcded195c87cbb61a06c77af4c71a8160fdcd35cad88a03a35345a3bf10839c2843ae75977a6dfcb5c67904e4cc022ad04b96a826ba68de32463debe8196570176e8d59bae6202f30e766de68b4a0bc7f9123faea27d0a4c700c487216523d78e4b67dcce3dd98a9258ff46f168130da8a0284a6fadedc6bea5ea271cfddadaef976d99e1568470c873e3e06c701e432f0014d4b92ea0f0cd86a5cbda581af29990d880d23ebd8d67a6a5d1e067129d1166eff1973e9b96aca65b410dc16376b873d8e389a34728cd5a7eedac3525ae6f2b123e0d1672cd5513f7e2827e715f623c44aeff2156caa26a29291f77b707ba615a4a3e58ff1559099216749117db92bd409e3827bd18eb859fb372f0ea6b9c077dcae9da90703f89a7d6da01f52177571ca686939a334483ab45d2eae3534b02327941139204c9ae82fc3156276bcbf09464d2bfb9df28962bf575468c8c44b7acc4b8cfd75740239ac933415394b11311efc80381abfee4a935d3cd802240be156e8a0cc6f70d76ef587c3703184f254096f54d958cc9cd1315a94843973647bfa5b90c1686d6804eb932f4a26cccadb4c094edcf6222c3c01a34ef14acf46844b7bc20eebdc6788b929046c191205370de8c7ff4759e6a1fb184310c44713dc1432f48635c190babdceb3b9593278470374ae8dd22d9f85d62ffe1b4bd4e6cd56fc376d2978f0bd83e6f323283ba5b566814d5f2820ee77aaa597fda8d8042da8b79431bb2137a279f94efbcaf6976ebf77d2ee979119727faa7cbb9bedf45712321aee21c95d01f87ad393eabea1d96e5821e0591867c9ce25ef06a33dba95becdcb4fc1b3d1a15c7832afd6f526ae8db220a60922cd55fc6b1e0105f3826e0a81a6110cce513f53c1d4f692c172fff0c83a2f81b959bfad1e0a3725b388430c0068cd3ba1e2d38d36dff13417e942116f74e1d6e6dd144f5ef60086ef2f534959e8787ff37e910b8880a64fb1a77fa14cdd3e572cc87e6d7f937cafdcc00ddfea1c85573661d69d45c3fb64d10c972b7250ccfd62c99c9a6162ea5fdd520a2a5ccf42a6dd72e569d0702a5c81b7cc8e3207bcacc18c584798779c75ea7cc2c6ac8453636a9521088ed7da498171bfb0a394f27105582d50eaee8e0db0b663b5011870d6117de110497c6418739dbede3c39fe80ac216feb50a95a178f602b0569624705a89d79ac2a5173ee50611194c94419e566e25eb427dbbece7430c6225b72544fb821fb53ba8ffe4404b9f58a388489e42acfde52f2fee2d9ff5c4ca9b6d36f68ec3e911b6c3e434b5b7c231c63b6a356d2ef4a6d5b4c55edba6463f5f4b0eb3a69b8fbef27305a754c6d1ba421a0e2a5af56f0740dfc32257ea665d05e1e9a1b7ebd36de36631f2085daa9f6abf11e091bc20b6b878b7fd0aab7f01bbe5ddfeb891c16841b093789dbac31a990121f2dfc73b6c9a70386e14d5cc9abb3ae37ade07a1acb221ee616917e4e0c765f2a0d333b509271b386f89351eddbe8b5303aa63e437fa514f6b69c0d464f7914195bcd4e40fcfa92bc29bfd1492fc7b61ed145261e4f14cde103648f8c32eb84899a91845fc2b4bdebfde896567755ffccb80015a37885d5822c7b9d972d3445cb3122f494a3b7b229a839df60d86259ac24f7a2045d69dfa599c958b995d249f3366aa7853c2d7167012318aa27eab9345b0ac484c35aae23e7bf7dae210d92083cbf524205fa7de7224e5c10c83072bb4e1efd5709869ee4354ddd9accbbe9166a637ed48fd1f6650d8da70c75b4b410c1c7d09c8e78f617f96e71758db589e9b0c9c940aedeb7f4e883ddf62d24b1373c290030dc5ee80b950b7e4369351086fbfd64a53f4dbc9e3bf3fb1c471dbc1ef16215f7bc4386409964ef74820da0aa10c32c1e85d9c27f8c2af9d1a771fd3b28a42b1eda22034af1d32e67e15d713915fc71dc1a1d3a826888b1c7c1bd141c8b9bd8596aedb8ee38ea04e7b95b3fbfa7c5a3e931ba033ff0ed7d83b87c2bc79bbbdee8f9b986366135e5b73c690ac6d8bda95c027e439ed50abcb87862611dc2fa6f2801243c3a7a62d025880e145b89402477a396dc2e8bb61b75e2c8e562bc3e132068b43d4e72cf7ee058eabcbf6d4b394bdfc1ff6fd8830cb252aaff7b4a67def807687061cbdb469b57c266988d1765e1d1717136e98de6484678e94f2ae54954ab76619f54c932bc020cde8b2a4357489e24f7a8cb9d9facd311d3de475c3929f972d3d1145b045a5995c30a8605366c38f50e6318a93ba93cb0339bf82a8e3c3924fdc57bb7c824666d2de49259b1c94414493b828813187ee77f268b9972c00e72d13a4d297f3f1b55b8a635691d07fc8b074603868fe4b1268519239d4b856e7dd7fff469f0890540b727eee765fdfd8a32d9430e74740b6d6982a85122ca5811f4360f71bd3c116d056eef9769595d01ae9a705df646be52c37a116424a4d13dae8beb85e87a01a78ab46a0c0cf644861c4ce1937b9ac685860402046711302f3b0cb56624898cde8665b634c6bbb4fe1e959ff866745fedd1507e992faa0a42910f76d5f4948786f9b4bfc782b333aeedb53d190fea34bb74cd6c5566210e053ed9ad824b3fddcf378f32b8fe4fe4af44b3e180ca7d9764f2c6c6841527dbe2c43a59a1390c860314d80f21fc26562258857bd679dfec081e909ac9383ef31022fcde6ffdf4ffd44c2373f0fb89e81c206436435f178efe4df36a685d59a587600e34b6b9ef026f210b69c6f998d57602f457ed5f171a7e95d573ede7bf07350c7e2d1f9338a669f7dd4d12c8133add961dba17a20f1b13ddefc365f53c04c5d802fde1ce982d2f3e9f3dca081fa8b2924ac756def93a0ac406e07760db6c3af0ccb88a671a2335cbfe5b65afb997df8c41e759c75febbdcaa3a3e2ee64f65b8c0efe57ec5e30e2690ae13303b0e116f5d0b9dda86da878b3f13a4e85d8fd5fdbd985ef55009fa9310ef5cdc1e65e71a6810fb67247d43d7d60f34baf066b5dcae7296e27631e53ee989379ea6c2e921deac0d606870ab0bdf29ac33a41d62688ade91ebd574f3530db9f194647067a73083beecadd8a357c0b01a9eed6c42e6117ae9c8f34bfc1fe8703327fd349222d2c4794186287a844ae2a65d0a21eb2e4020351047d707b61b4d2f12849ca5dbae9e7699e4b7d258223b43cd099d24be4d700042349fb2391b7f653f11a918446d741cac713257c4db0c6ee5a0c72e1e4f9e21febd979333370424741745524e8dec02f1aaf36c962a1724f4f5dd86b2d997cb0cbea5a0c76ef42f6672701db476d9da564dc02783b074027f774162014de201428117503834bdf340929552959f4688bb6adbc596a6eaaf94a304709ec6af59d78c0205b895b3ea6c6780d23d14cca605e41c2c7d493fa650c62c2996268df5ab84aa1a737bc474a15130a33805b7866cb44f6be6e0e1bb761f01d146122579e8e155c0fa9f0cfede0a887101974422d2fa69320d6361eec228a145a4956c4352069753846ec69eb72a67e6cca7217fec343368f724613cb73692703215ce1165fd87fb9ec27aba0db96c2b8d2ddfb8306adc246dbd5af1ea02d2c278e5bc20962a2601725ca37b024a0c06ccd2a02121bfa5758e45977be8f88981f3986688e29a039c2657ad89fca1928b1b4120afe3b01f6df0795e7d9ee9ddb207713313a1ae6068787e02a1b5e9e5bd5554354535c978eb28770665fc93d8e91bb1704f4f51c1b99ab797397f5a33ea8c7ff503dee5c03243d1a74291da40306704123744701560702cbafb988b95a43b69b8ab0a86988eb565906cc9b7c58c0ac8e8a0427716cb760a06bba899995ebab54e5946762ef3ffa376cecc6e277e253d8fedbc78ca3d991ac5e40eba6a626bd4ff349164d9ac98eedfd569d146818fe538316652cfc7e2743eca11973da521084b7b2b77e6ad1bd10973bad78a79ed3537112ca9c2f38298ba498d3fdd1490ef25573b82b1b802f1f57e618e4b5e566989308e39cc923118521c26b0a6aa0006014868f0529a569e449ae613f01f44e5473adde82414cd74780550bd891eaa5842bf793990b06e2d200415f3a9c94578d02d621da8ffdb551986fe19483af3aab180f10a93403cba833db7db279af670651f07739c6e3a36e5fa2d690738f38ba2a89fe9d7bc134d2382b84ebde014c41788a0b06a193dbc749452f08e09e5e0c8f502f9480171d1691bf44dd6583370dbc0ec36ee7e1863cc64fb7e1e9e7fbebfc4a0811ef80c2a40a876c88a5558fed2aae96747ffb32e934fd9e77a36dd21bc8251674ebd2f33d8ca000782fcc5e491e32963254d2f5de86c2970bb2bc8a54bb173f57e74a1a1074c0e7eec71f53d7d29a02527dfde4e33b4f89ad95098d340fba0ebc201b1c57e340bf165837619e2c39f453f970bcbf8acf2249edd233ed09ee9fd336840a023bd9df9e9aef003b00cd2303d5c833d13ba5508e80fb234273a81b52ad8e496c100953971363af609d8b93da27643767c090787e085af0821498eca6e431869ccbf85bf82f5477d16f024cefb05f6ec973eb84f7a798ea0b4c6961f63b539d005cd5cdc56d5a45ebf97c3ecf7ed65e6673d062a2037a572ef2593cece1c684c8501cd7a2eddee977ef04e12a2b08179bd582d06e206ca53441d10044295600950a1745349347b1efd003e3bb50f467bd10c0af52f7d83a73e7e1e7bf199965307bf9e1d444fb1ba8f0dabdf6e76ee6e40e20e407b7667039ebf532f958f63896fd1461fbfd151c40f0a1c944961a0e7acd00b4a4e32e89b9a0df7fdd56f54bc8ef5a23c2fa1cc98ce61ad295523e5d5834fb10acfeb4aee9985d8eb97cfb224b798c103b237119d8e06c73722c39005f52e36bc8550a70d8f4da831a7d8cdf4362677bbcef7d160a8b502eb47bb8cf56d7a934ed1f07c26b741944120ae1c46d26ae2565991dab9def26203c7b3ffd7b0d2d4d943e02677ac40766f82a7fa288806fd145a86bf4d47ea4c75a33f73422b28797fef241c98f10e64282d68b61d7d6341a055da2fe17f0a612f818de635d08f2a5178e75855abf09709952af2c3e702db6e8994fd59402854f9b7b38676cdb629c182b0c5f206fbcfce9e5a6ffccf62407679bb376687e922edfe5e91b5f79c321b975ea388339db090471e75f9c7ba2ebce08c64a7df072dec6e5a6989ccca764e5f720255fb29eb171799d50514c76ec503af923bb89746117e0bf33c3abdcf3fa4053e4c7421c8dbc6bc1f33674853dc6105349272f64bf070a3569531356250f387de252c271b60a58bb0d42ea1635c5900473b6e2661ba3afc80e309d377126892e212a080fbe389c801daa7be23507644f0a49ef45a6873989f28b3cb3cd6a99a095f30bb0722ca323e7514a252913457e7a0300df118a4604e89a59166396bf0ba6d445389854d517d2cd35bd0c21ce87a31546c34e0e48bafa447a88efd7cc8179533ae52afb85cffb8c7bcfbc960587d5f0838221c8690123fc47adae06e096adc383f3d99dc2cdbddf35810c5139f6be3cb8e9abf3cae245ef80937724cf9e40072d300d1804dddc80ff8b959887efcabceedc54ca40de02de5081470ea161662b7c83d6573875b2c8df25865d4e4bad654d7949c2176a9ae86f937c42529125432d43235e7b7757ddbe3555d00cadd0b0b2dfa15509dc99917b79357951d2ec37dee62bd92fa90368691fdd1293141b71d76de3a0bdf55720dc4b6b20cc91f56001e254498da222a5573fc8249b8967387b13131bf26c53ad825f35b27a31c5e02f7584040eb5f7340cd9bda8e4b9bb7006296ba7f0b57ed5d05d30d1c72d836d87db4a406f50232c16f389d0e9accf56a4ae7d08892883bcc42700c16d201d685a0117b87a899b443ba223ed500e0b6ee01848602c7e61d68a6209f3d314f727b553aca5f47ce1f1b7b81d4a4f9ad73ee074b7842f90a68fb054a40230ca2945443405639409ea1cf8f52c03d2fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
