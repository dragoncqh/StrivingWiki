<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8db2dd407096ff9ca99797514e84cca01f9f1a765fc4cbc24212c14285381ded2758c2d2300bac149f8ce91f099714b37cfdb6fcdec44066a904710d4534ed7faf06e09b69e595be5e0880826b41f13ceb72e66d5aab2e497bc7b093ebd25154e4861b093c83fc340476e317bfdfb0d3347dcae2d57246b27e45c81a544e64ef5b5ac1c051b5146c0da8db55ef6c824ee90714a7a2b769b7ea12a250cdb64a819fc67c93cba4129f26c9e0b2e9ba0ff2f578c465d76c75df768a6771350afb5745d2b9c80355bb579900ba412d47f6851cfea48105cc5a7dc0302f9eb5e4fcc902e6775f1cd3c306ab333e43e171810f1e605fffa9f044869981bf7a6cc50dc085ca3848c57e928ae55e0c021f04cd52c2e0329cfda11d4667cf8c9fe3da1ac47971a22e6adb621250af871c42f64fa13e2c481fe6f91ff00612a0ded0a41ed3cf0aa5549ef594c63576146a8882d6abed937e073e750e0950d03371cc713b5605672c4221ae1ff83032ca6b7626ca58577224b4a42465ddb21c57108f843f419677a15c7283a738bedd59b26d1fb46f4fd4449ecb57a024d1f610fe6af9807218ed4637951b35e0b9527f352c9afb3d63800da41e5bdfa7cf709be5afae8fcd2fa2afb005337d094cf1d662b11c854a197b0b967e65c58d5aae4e97c93573a85efca00a5dc1c4c8cb7f68f5a2bbd79814e92bc3b4cf74f58b5ec39e0331aaa2ec8cea480bf55bdeb62c505f70148b8c47778c2ac86d6f105c8ae0450732536e844d879e36d11189a8b2e25d433e5324d5376e3eb6ec1c9e7c0541859088fd81818b47f9239636e7c53ad0ad29bbe2912238c3d9b9ef28b8d5deeca8b51ffde434acfc4a840692d4b5aa4b15b2555dd669c6578c1967b2a5fb785c4555ae52ae725cadd59f10ff5e26054b277367939ad6d76bd9b52c97e12b5fdb4e5d8c5df3d75ba40e0f60adfa1723adf7c0f50d434f4edb6faddd2af440249afed1176c57f201c2ec61adcb0cb5d2dea9a6995900b8116ef040d515a50deed2060b26985bfe854aba06a3841743c864bbe0669f76a4d1465780a3e5011c22744710b28a3ff651d12746035bd520a94e85ef80811ba8c543639c82441d06429b713ded840ad7869e88abdc5f756302734ea7faff2b41c9507ed80996274478474bb8e96ad853d0920f26138ff4e3fddcd26a31f2b97a79d500eb19ddf09fc2c68da0b0562c882f920404bdb44821ebffc85a9d4908a65ac608c8c73ef70a42085dd73459b44652ffd4211aec4a1772b8763fae9655815484e0c1ac6601c78060dadf37fb42d41a27e3f5551899f60ce21319020bc4b5fb5c72238cb52903cd53c66fa2275968c29f351f7751f660e5148305244229ce2e5b2ff671260e5885fff0aadf6a5cd0b90ba6bd793672c2cf698737af11d92beb99a510bc4201ba4e8ce4e08d900b018e3b9bb2ffa3bcdcb5fad6565f7d80be638bcf749410ece02ce09dfb240112c25fb90cc07d6ea4b403bb6a36b9d7f1653afaec78d847d7ba9d39cdb492d5e43e25bda956f44d93bc6ad3842673db9f186f44ef54a201a7d6be4ff1d9eb031c8a14ceb7257b121a0aa89997108555d84719af79f6b8f2d2730fa6e4fd2ef50dd3a9bbe1c969c5efab84cb9628a46a17c209249cad1c348bae02016a1642f783866b3bd51dbee4448ac1b42883767747cbdf253fde75c762d253dc21a638e49941afc55410f6c7e6f9109a523744e4d13045e0973a2147ed30eda8a055f15f96637cb3b73303e13a0f877a03906f20e2cfae85aab491fdd35c02bada31f21525e6a64156734bf06093bb4e4628c2a4e786045505766c4ad65bd945c4b436ded0e4c539ec8035d0f0f041389eb7da7fe87dbf04d43c8509b22246bb3d464faec87b7f4e57a84464f832d163add3777070c485bd55f89de8227eecd53ec4f08c2d20b49d1dd164a1a972b27e10c4dda6b7392582544f28eecbf2ff065ac171b7fffbf7a9ca68464cbbc307b58e83b8f5c4c5b792b44babd11afd4dd340cc6fd163dff1fe1b54514effaaff5225b86c6a77bc8873de0ad5869508ba42662581dec73c8178a66a082da21f1f725cc1d2f4564635e50cad7aead16bfab60cf40e9ddec0fadb384ea2c327c0dfd5c4be8d674e241c00c640d1cd159f7868d5a8a0f7f6e5ca13fb43d1f83a08ba1080b3bac2890672668888063cca841920608dbe247c20dc88b50bcc2b134a8bff573e513b24eb06ed3c004bb6b6d2098e7189cb2c3880935b1e35e5f607979f79bc3daa5a612f57940f5cfa341c62f7d06747dbf02155934ce0c24ec074c73eee25fabdd8cd4fec10e31a18d4badca406ff6f47c8eaf047c3ca791b1f7e7dfd092ebc4a62ad1fcb5f5f75d6ab563a780174289dccd7f752ffa8613993f404f62ac6d06df10a8fac7a4454287af26f1a7dc45f1b57cebc94819cb0888bf78e09a850f9c158a8569deed4ec97abe980044c349f70791b102471f9f9e4f51a987ce2d7628cc107faa0c5262bc33857d9eee17749a3a3701fd175d27fa30df181dc3aadd03012302facba4798bde91290f8923bf797636d95e219c7a230ef1377f4261995638340574c6841edcba0c7ee7cb3382486242c414710dcb8bf0bee5ac835d81cbf4746c797c12c1e9d5f77964b69b3f68d09ddebcaf21c706e3ebce5d98a1a37ebbb1a89343242d37f45ad210242917c34a231ded6ab526682231bcb77ac1862a1dc6e805d6b02b6adfdff9680906f37b7f2ec3ddcaab4779069728875d7ab187f32dafc07307e113eeb4495711fbc5de05a142e7b2332cab689e4766a0ec78fe56d8cbb508feca589e25c290e7033bd8b1f550098bdfb046e7ade9e5b13be451c346c79a5b612076e32e991f22ba1f4a5887061561921cce4f41ca991ac267ae82ce5cf919cb81d8127558c795eedbc6fa73b47f84d531f746e78839378306a2ec893cbdccb24bdc08b5229b82a4543f8dd4ec63172e13865dc9b54a836609c474bb944c92f54515028b9de99213ebc02166efa190691170177bc28ee182661bb105c8a3b834f8ab93cf9c791c0d3f3f6966d4155a424d039673cfe1a3fc54fc0e6f81e01787db0cf2ea675b1a4d9742ed2aac84df03bf50e7ef7c7e639de64a96dee31eaac7768a71b0151916163cb753c920033457b7659cbba61eb5f04ff94b357539c065f997381bec0e43a5bdb4a6b275daa753a3657b60bccc7bc2d56f617143792d04f00c89e304c0b455051ee734a35bd9351b10fdeb0d067c05012f0ce85448abce0ac3e3d623284b4acb6116465f0a3e631ee7c6d6ff8b44a44c506b9206c61f369a37d32579e9f5440c8d64460e42a36ea88c95a7dc35807637e9b2fbb7174c88a320f757c3a47800081ad9622f88c7063a3e3690efe8baec718b74d0cac7af39894bf55d5ad46f76a7dc96bb7558c46ccc05b1a895d22f61d851ba7aef7d7463e2c58e83b0e5333ad9f69d296c97d85c50c70e211872d22bb942c040006a6781a3e006c4221bbcdf6db846842ea477f638c020a111a2068f70dcc15f1810a1f71d80a4299f7bc133537d8728fbb9a1b923991361f40438c2d9d0a0d80f4bc4ce400bc7a9c0eadd9748b14f814392d1ade33cc94daeba326b6f6d258e36101f1e8a2dd296e74c73e306d880c2427692a69566761f873f95e57a721f50589aa06021b853a5cf43b75311326d4f7fb8e8e9306ee4d98c82a7f88debec7fe06ad6e88df29358e466eaf27d7f2989c8f0a2b1fef0125f8b2fa8209de433e38ea68d0d4eb160e37a8588c70659e7ca3cac2eca2a0e5a1ab611799238d8cffbc651c8daeca2014f68326686083ec3bb1c945cf740cb78eda2811d0395bf876264afbac9f36971b4a521f96de6cd5859951b916fba895168b45aec14c7127e2ae32bad306781e94534ef0c42190ecf7e615d0e70f6a9adddc42b9aa580d2652035fd11f80da79de6a17b82476b0071d28fc2b4a60177ac1a8b70f2cea09168bf2770e414beacd82335e40ba337ac4aa5df97a99235aed4b557ccb2e77386e32802f6660991a2b78754479a6ac489c3f34dca26a5045a164ce679ae18105b8146c179d71068a9f4aefc7e4894b288dc4f265a195ed8ba67b096d5571ac08fa7ab2d615bb9115b52da26a4b4f1eb6d26262e66dfe2da99c5895cd3e06e1f60ea937c4bf41d779c7c64d867bfb9e29b1c772cb484211df0833f32ad0e202c0a9a5175e18e9ae6d1959729c5dfd64df49dba82d80bd7a1c7158372386288037105e57dbe79570562dd0bd291f91b3b4c73e413b69744ec062845fbd83fc0e9fe396b52bd61408958a098b232e6b85081770350e9f6cca8c8cf5308371366654e571ee994568736cc66e11ce682453b1b4396ddeb83dfadc932b026097ca45d5adb483e60b95667455e85468de8487366684198d1347033019c35533dc6d7126b0cb76e6af306ec538c75623d758d94c59a037b6bca14e47f6867c5df2fec1982b6b4f2a56c3cec0be3becf4c8f4d097e274b512cacfee92c5599c54261098683fda40637496d8d0ef057e4aaa20e9b21cf3e611823125debb2c1cebf705431a1b575d9c416a59349e332ad6006dd073ac2816dfaafcfb89bc44f39f0cc7dd05374d87d045cf3c2579c2ed23fa9c4a2998d7add8c857c039362bd6ea25ccf4db080872a4156542fe8376e6ea2585d74df466d05033772de30e348dbe0a4d14781cae159157509f94df46b6e9b9a76b486aad19defcd6abc28e36ccca11b6d0a7617e9e16c7adddf17db480e4c6e4230c6c3de8e93f3168d24201a441156d4a39d5d68afd269f34189d4438fc0472e030c6114689390feab396e39942cd9378a2392b97854213e08797839e8b6cf5052654c6d26314868055acbc2df66a4712cf6d466f30268eca947a0bfcdac3bffef7c29d58f73c57e7c8972d39d4807975434566abfbacc6c1dec9de81e403e9a747b17d965787379de5321cc1f3563a1baeb67b2ddf394c38a12c4f7adef2c3d5fdf59557ebcaf3336a426c765690606022539617f8e94cb8afe5ced15b15d3497ba6df155f0de5b68829ad88f3ff274ad8de4c95505606f69daf6b068372f6dcf1ccc4a99e82c76650d6ca584a9e1bf872c0b1552879808ed7563b722b3e1d235b4e9e203a7273bbe61c43f9f3848f3ec51560584869ecc795d836ad947b2a77c628ee427174720bc66a9818b9b8a1d70ad36e1de98aa3c49c208fa19522386ff3951fb0a957281f70760f2f916d522d698272be14632ae82ced06c93c6c8f97ffa3ee5e3acc743c80e36ef9b831dcbcfde965d0862dc3f5b8b29dc691b8a72f3a08c87e561c27323a3afcdedb07c4273a4d87cca32b824f601b1f808f99edd0abd4d6eba7fa7e309c455b250b177e8655daae34611c8c8b2910cf3e39c19c843509402aa2e9cc279aa6b1be55e40f1069b7888a61d381893b285a89ab2a797294771840045278ed1e8166982aaeb9a2213c8bfb6fd69a8670781d2ba34dc45afba32f94d08fa73e67d4d89a8fb0c403f6a4e3f5272481ce11c75a896de40e2f138183e8ec587b8fb64177fae9541e80830e6785d6e258321c3008e4a2c8d6400875652952197f72add486e1b38f690e89d259b03d3cb39868aaef56f0455b683d77d7309fe9cf5bad57bfacd2eed2d9459c3047b1d555d763eed8307e10e3ae76788b6e14b1b45c41e04c0571e77ecb357e0d13eeff76b87bf67aedc7126b9d6f5c9cc70ff04d12332e25e64646f1b66ca53fe44ea0ec8ef25898e878ac9a8f79d624b652b5bd5aff75df6895b19b39b3cf36ac17183cac4bfd3aa3d14addd52dad63fac1a2548501847ea2a452353e25b732c0846dfe50e9548a247a294a108aebe32330d2de3649548ec9676ca2fd8905577aed3291842d7f7635ffd9b9190c9062e3899e481f27aff4359e411f3969f685e06fc335226a4d3b1dbee59ecf504dd8e12bc80bc2d056feb8d693af80c7162b6578f47ed503f33edb2037d93f3e258976eed1f72ce3974a142585bba4429f778e7f391dd6463e396e55aad95f1eeabf1b945955539316895f0127cd8371dc361f506d78b878b2e2733f565616b24162ee21c93dfec29897aeb37cd6b8cf71e9b32bc488993c93f019a9f48b210cfa238d4a70b8a6bf34e9226c0f3ad2ab4394285cc09257d8871acfc54c23366c37b837ea5cf1a9ba7c980f6c91759c2d15101d256b19cf46b491293beb52f800d196ca65b05d886b5cc5b32ed14049bf279f83de54fc5b10fc320495f4bf5732361068dd87b9881c6b37f550d57191d13d3aae7fc26882fb5e228dda381d12c945d267d683e8cdd23a77f1f3ae5774d961b039a80a2222ff0251444ddeee8c17e8480c165b264473aab4ba2c0ca545c076ec04d2fe3b060ff2fa87300b5182dfd683d85c2db3717822f9a15ff6178fca91b41efdac94415a6be0a9fe5051ff5aef90e90bbedabd10d505e7fd37c14f24bfff293fa986d46eeb393635a76445b77501e467baa8ee820306c94380c9d991bc68fd78fd4e86c22d8c6ebc5eeebf715c83161b4102adf542e52f72f80bfcad227470fd26e4c9b03f378b335e0f6f70b7fe949ce38be2d4cf0ab423b9e31337583188a0fa8774f369e81fbce91aa7d1c92f02774301da36d4a15db84686d8e8bfba5efb4eac112ca4ac2e8659a2cb34c15fbb1b4296ef9c87a6f958868ee963a819dadcf076b7e25fe79740bc22f07a6ab8a9b5e7e0fa213408b819960b6fabf506b3e8fdb123474bb21e47bc2f28e3cf496e82c9f996101a6d86a2f16038cadea0b6b8f722eba3815e968bc512811698ceaeeac03343fd209ee2ff5e8fc2c65d1e2f7d13a73dc4efa4e59f1a2b8680f0b49428342800065684c2cde29de41e2bba046f9865a867287fff4d1641387525f6d7b5cd6c781e0bb3715b6b1c8121b1bc1404ffb254c011a4bb9a206904cd7bba7d58cf2887857c4425fe9b75c95236a3c1179f85fac3578195f678753a8691a0e47de8ac1e029bca27d49e71abe4aed1cebfe93cc9028816049095477835625984731c7657572ced6aa78df67d1db3adde771a152a88b5ae4aa602f10e3ab566f502daf2bd4516800c5103608bb9e100492c4cdd0c01f3debfd9105a5c4a7ef2a034d34fbeab4b7b88256eb49abe3dd6fc609073c584048c697722a7babf5b28cf3390a41de21e19b962c17748a5d1396a8524046fc92c1780377418b1613a2da9d1b7ebe311141a763266b75cf84c0036038f1a7f177dfedd30f5cdd942174171ec18b0395f5204a9c56057016321100bf09bfd02304f92faf815a004d304a26b3b71a684c485c8f165f07946967d903abd5fc6f25c317c474e3fdec0227464f3809348eade998f5d15ce79f878e9613151ed2bad91f3911105af375c7c41010846bdb15bf1aba94d5bbd16ff942fd6f08ff69c1846541853c696e665d9bc7cb7b815570f1de2734540985428b6a20b8ead350934a7faae581b03ef9405cab71af6e4a2788dfd4d852947497dd23888cf266c7ab94fe31afe6fba575b0db6d371365f510e6595fec5b22ade93a09b10cbe1861865762f29b213f2b0637acf8c68a5a60c01802354b79b83f23269355a8ab13e428a6939f87e16efc049ea2264d39fd9f8442687ad11984646a819f4c025fe97cb6b925cda9e9ee620a5f44bc730e0d39bff37638039a921f489be6944c9ad66f9d5d0b19412cbef33b54fc6e070642abb6852ac77bf44b2797a7ad668f0fb5e55293c96deff2e219d225e2f5df4addacd571e852d3acf1738346bae092a5424e836bd23075be6bc118f02451bb238fff9071b7f41edfd99125cb7e6433c8d01f54eb972e82ed1e29729f211eddd032c42751f7ae51598c18739426cb21420d9ca66bddf2c5295b4252316515322549c7ae1a215fb26c84ba38153eff88950ef34450572ba99274f1d42e8e21d924f25ab7b6d62113b59c7efb564fac6703a57dee0cab259f7f039e13e59b395388b56deaa3332c5419837f54b31e68a5ba4b619b1b8f68f051d74f1e9ee1ab8f66bc76447f949cae49f90c28b5c6866c5ea63bf86e398887adc8af275af4c0abb5855a7628ed1adb88ee398fc35712897ee829ad8ecc1109d2699d74ef2516849ba43e7b8b10ee8807ec0f15fdc8d44edd6aa2e9b26a2116a3ebc63553dd516340cbaf150eb9597d93be41fc9084b4ac198bf9654e4d1a6b8ec5c598e956f9e93af16c2248ea4099e47363a57f7528547f7be9330e16edba0eff055e29cf17af4f15d0889ba607f317b72a8855930f9820c67e600af7f4abafeab0a0d8356b5d89494c3585baae78705f2912ed8c9580be444b66f41620bc5e0f394aab2e61277f58bcbfb804c0ac4b978bf49e0729f9bf4a58e38322563492f8fef90a7501216f2a593fcf53c4e8c32700efcafb06062cd8ee8907ea1e25146a6a54b00ce84c500460433201e497baf53b9eaed2620eef263c4134d97fb679908bb68a3e84d3220755411a8d7b7a79888eaad0a7177241e7a133ac1b90ff5325e4a9962baf4eaff7d6230e3ef592692c4d9fe58cbfd36a8f265ed87298f55697176bcb53694f411d76e1c46dc8bbe5a7d07d4630be4cd24505e3a9e4f0d0168d96ac18771c8dd984b5709a3a8dabfc50759e3e4b78969aa8989870ffb49785a9f4ced8dd90a9efa10dbb2e6403774562f4799335098e1eba9a1c7edaf747d4aaeddc749147117308139afc1778789dc4f9be46655806ec635abe43fba15ce1ccf7505289ffcb42319ef193ebfe2e5706385e97738de08af2db516588ebcf1aa6331ff07cf674caf565fcd26dc244fd0f616c64df81b77202cbc8c2479039222469bdd43af6d9c846fe3668d4055203158c51fdbf2bbb7efe54c7b752d651fed96e164257da87a6bce66b0d8fc3f5f33b052da41a875f9d7e78583041bd4ec82126abe3c4cab950ec243e411f1e340aa84c8b12609da2d3d9b22f4c94c4de32564717600f414f91951163997230c84966780fde5e728884f6af72b2365cdab74bc4bf6f9c142af2a095c8e7f97034d1fbfdb0304099384f3d112c7f430e6e9e5ed07ae053fdd8e449b67fbed180b166c185479dbbee5753ff9afc4b4dcd8b366c29f3701c27abe0bc18e654ef515c1bb2ebb2126e097164cb8efc4077147d0f1ec516a20bea79fa62456f3fa56157ce3bf687008db8a71e094c964274158c792e4f5af130e5ea84adf520f8192735716f113b8166f0f23b7026c81c5edbf0f2cf981f0935d7a4e45ce873837c9d25fe6f326546bbc85b583bd62fd1ad45f4442f089311ba1eecd06ef1ba7d395c79984c2d0f997f73c47888a16cdd1f39d0e0e088dc7811889bd1c8eea25cffb9f6733d8b18b2cd1cff62d2bd825c3195a5cfd5b8c371357b4a1b82dc3d23421e43334690050cfae490","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
