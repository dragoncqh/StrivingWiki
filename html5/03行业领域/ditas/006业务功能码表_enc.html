<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b92e73f8cd0956bf43bb4fd75ae32de355dc5d8930e4c6eaefc816da1c20209002d6f4b8bcee32ce6a63fe7fc4c142b7e31cdd5d1e326ebce3aeaea30eed1beced974c248c5044e7febc2a5506cefad4d7ace0d21d87b32db600e32118791fb687ddb88425d7646e50d9bf7ce01fd9699ec344d5847876146e790c80fa784f11aae72c20579f97f668b80428bd255f9042bb6eaf309f89e9b4733d7a466353a0a9520b526c7f67e686c5edddcac3e4b36ba5695bfa8f3e4361d160f8f86eae0d124c4be08bbf4104e6f486aa0eaef7afddbf18a06a26ab0b095011878a01e36733850058525df02f3d035040915ffbe9b0f76e0f68fade4319144c5d31cf8474785d3bec12eec41f944c09ce8b13f39ccc72ceb573fee34661ae5b4bbd8d53e0c03d22f9c3a7f7c19f298b66a3e8109eaacd7a79e0163186f681ab5de5233f21193895b4f25ff83433bc3da2a0fb36b518e6b80654692de35454ed3640e51329f7e7835799f0811c5bd3e17ce233a98afb2249cde3e72d0ceb6e50a6c13096be61c3e1d57ff7b1bc0a08e8ee5b920543403ad10a87363eb54e989b4fefa6b85fb6e6ffe73a07e338ed36ecbea8ab91ef8b90cd56632ea1029ad95dd0fa205a53cbb81c23389c4b7face8b6bf9aafcec0c331f4b13f8ebc7cc83b61e324d571a8637c8646627d0ead724a34e1a7e7062ca73d00cf498392bee5cd7fcb51ba87bd444b32c4ed7db8f70d59e0a07c9d3393d3dbb3baf2afa7045b87b35878e5b723855cea10ee6b460163e882ed34ee106232328f37b80568a13662f2f8a4eb6b37cc1b09f4f152cc85ce07c56d4294853f8358555787cc248218a82932c106f0d07f599f3ece596980c0e0d58400b03c5b723999c37a6b032229896e868039271718769dbd47b209ab31bb2140981a2ece1cdc2f2a8166e2cca87472ad5a702f9e94a9f6cb7b1596b625e64f465947ceb70ab8ddee0b18ae9babac01cd30448a4edafba42c9d4257e7cb19093430d4aa4368a682d3698f0b37c30c92c3c8ccbd2dc064eaeb33a1686dea94531749f5b02c0a7df4b2c0455d4f02b494012346ce71c8254265a83f61d491342c69d1dd38a59a0356ed6f52bd8bf326cab605afbe06302c13315faf9db2a01f56f7b48d0e22c7d35d6e2c7d97c4361513b69e1b903f0f164a63064bd05684d7de65c94e440a61a377e04f38937939c2bb48f6566400323b13be4883e4bb1c4ca9be47a785652c094880e07c5ce726d9fa0eb0abb8b8be09f2ee2c142d9658bbb122a677c5479c29389daa6555f30136e249a8aefbc72ff60936098e2fcfa14a8bd24fa4632bcfcf912a9bf1e3301fdf4028fbe3d3aec8257d127ab254211935a37a4c053957bb182bbf62d3425a8d7ad35f3ef0de1911145b84abbdff7eb3fdf40fc09684aa1972f6c32ef2dbeb09dca02eee5c5290a28cb4cb7d539ecae3f2333bc86df772dd9de712fbcc4452c50e293e50bca2c5dd147f4ae024981eae3f7e00407053bf65432a97f328fbd2651f12c6f9531abb47af38a4c86c0338dae8f66cc1b8c5c56e12327d97301db1fe6182a538dbea62de8de4bf7602e9a1624946e68abb9b257616bfdf60346c986275242ea59bba81d9471c7a99f1d8f634754904faf2968ef900c4f0a55aa93ca04e28d0a6f7541d3ed5ee27f9ae7de71c85ea25705898f9633d793b91e669efbd360c3ee64737b1faf31479d060c56775baca2bc61d57c0ff286b044f5327661943fcf18b7012c99049368abdbde6d967e60bd525c4ebc241475ee562ad990a47ff387c9648f5a204e85fa846ec959762682afadaae418241fb6b8833ec655133f235dc9078b7c72577ebaa78d7d8659e6591d1181e1e50b53a6badf1a5e8ff686ce933c07eba8d77e049d305a7aee3a5261fd2a04694b18ec6668843d11cac61e7817a0a47ec27310c47769d86049b1b200a73f10dea70a2d5f5b2a579f294e0affc83292ff6690c7457775136e17a9e04b730ad89de7192dcf72cffbdf1bc405cedda3022397325d775d6f36ff1523ba4695bdb969b070ef57a1cb8575cbc2f5db03ea60ec9a2044f555ebab4b4edc33e605f1437558cf082e3318e0e257a1c53b0cb69a42889294b4ec9bbaf6c111ecaf304cea28f612c3fbd186914cc1b2954d8e3cd4f9da6346ef62cf72dbb600ac475bb8aa0bd00e026f085b941169ecc82032e578ab7cee255ef435342456e93b8dcb24fb24aa82cfae0f76eb855f43dc7df6eda729b921eadb4ec05fb3d14ce0a6f027b1c750cfba11201c6f40c308b7a46b93ce6c910c24bc9c1c222bf5632761f84036780f5e7b6971b362dff8950fdd577d428dede9b11a5764c9c50d0f82c1629118c107da4517a6259b2a127ff09c3466e0b466001e8150a42e150fd3b917626f38d8e9048e8ed232c702f897c2457c245fc75eaa34a177fd82fbcf69a20d382dc8095b2ef7c6428586d5e4564265da580f7d7ee028efce41a39be58f1d1467de6554d097624b803513b907baba86d15c95752e94fe81967668c6ef39d06603591990c7f6a98f39d25ca08189c7c69d68af70a01ee6d6b96e56637492ff727333476b830c4375f4af7059eed36bbb6fbbbdb839f898a70fb4ffa6503b648fc4b9c552194d1dbeff931bc15478f0257ae5fa04f55adf1244368c265d06c12de40d12b4f62b115ef31becd1c8706db32c5b1f8e68ad6aea32fc8c34d6bb9660eba6ce1b3b96e948b8bf9f025a2efc34732565ac6580252186663d03dc6ab6bee4ce7fb3f8601fdaaa2e2cc0ee99df5d2163e34a4c31d2744516474308a823be9efaca2c5214a5eecc3701a793fa0d14412988654609e971284305ccd12e53a393be0b666536cc90d6eae67b19efafa8d2c714ec9ed114d84c465503330e5f2bd6aaac06928f3e46d4588ceef76c1d7d2550ae13116057ab91826afafa14fe1b1978bd21ec00eca769233c3a5b5ccd925cc3a65661ad2a2f31630d291f918fa1f12f45aaf7388469c9869f72dbbac41b27c5fbdc1e6f0b2190956be8f0db54f9d746bc249aa07c0b4c10948744b7d10dee87dbd56ed71676106891d72906dbfb923a6e4dad9124211b7feb142cc65aec864a3f8f23c758cd6055ea25aa1543d4939a3a710eb28af64929e0a72643356982edaba5557d3866b7d68ba7f008a630af3cba25234b73317513d9049187b83530c21f68ca1d5529d97e003acb2ae27771a0a9cbb5527468b712e781c0df84808e7aef5f89a5c10f11d4ec27ce33cb450ff68209660522b6eacbdcc742e56b86128d8930d68cd02afcbc80862f66c4e4d137b2997bb88ed2a176b610924e3a6b400d002566e01592c926bcc80b9da5cd23cde9431297b60813c08105105bed62fd358fe9ac6d1721c828faea7ef4354fccd6279d6be58f79d01d6b6984864bc4872e44631ec08e73d0f5cda4bca87c00cfddacb696d72adabb174cd9a233b9e2a599b648613ca3df0faebdc39c622d31e47e1b1616dd6bfa2c4f11b73d9ce18e01668dfb9435b89f93ba0f6cd43c4713798f0169d7620bdf3aa241a8556aee77d9843a191639cbc10f68dd45ad11c2a3d2c7415c19ee37b91034985aa87381fd5f02cdef3ab66dc48bf461b3b16582d0f4da78da45992f0deb6c7172088990536c78726e013f00916d71a122424f7afc4c73c41523ab4581d81039242a9ef09ebf64c42e68aab55bc3f5a712d88aab05a91731f1572c407632f74613c733b123a37e0da00109c2a6f28fae3e9360a5f57227b34b8a1365aabc8e16e59cc772ee78977164769a9e01752a3cb5efb6ed1eee8226e0351d021a5955640ffba0b4c194b3b10e675aeaff0233f41cdfc8634e5603f0d45b35a035fe905db3913044b2313f54921077b52bfbc2aa1e2bb2c04e0d93e3cb6a12ef216b8541c0d0aef647b9abf1c737918eb9911c0097c745ee5c1b81d6e8ab0f4940b978b44377816c5d9a926b4e384b7d743fe3e28bea9d45f11760b23dce45ced8b713b5dc1fd5347210376a899e7cea80aa03a80e06cbe7ddec365ba7cf90afbc11273a88be0acd07cf857853b8eab94edac9859e8408477441ec6652e53a86604366ddfff11f4fc123d4ff71641db74411e865fc1e29083f6fecb119af19f5b4737cf0e6e3fa47ae6d99518624ee75e5b0d68c4691d84191ec0598cfc66b4ed72a140aa780671be00a196b41ea347ae2495d3741f4d4475667cc410e4dc7812d01f530c606df056eb79d27befe90820695b10ca04ab2c7b88c900f764936c9d13770d7b0a27fed34b4de5738ca228dc42473e7d841a132baec5068e78ff8bea7433cb96beea31a1e8c2cdb41b571253a8937d1b80ff3c105580b778a10413b6dbb58915bc16e01a34c1505ec84d25ace2af9beb7e6b93b5bcac0d92b680f1a2ded765135627acf8eb6ad5c8ef5b6a4545d382c28882e8eb98732f2eb5691254448c4f218982c0a9d5d13f151c05c39955c9a25528b8c46939a68cc791e72b0528ffa17c8c7eb9e52a15c38e8d8e979127b885d47f0803f9d80c6b4fa9c38f3d06450cc052580803ffb584ded2a5eaad60cb154075dfcc9e20695ec35c8ff716f36208f6d5342288328a0c46be329106f22bc2c749cf0d7e6dcfb4949c584652f430d16e4b9b551ce9a105093d94e1f33d04c5c441dea2e1b1893cf3a40ea73ec1972c37a08d6159a762699938fa5fe93be0ed1ce793d2d10a73afa92f358d8d4d62077820e8703af34e0f1d8914011965783cdcd04c560e438e518b1a6a9916239cccc7a8a9add17e1b2720dd98d337d0ed56b94a83bdb25b5bbc0348dfa5e36ad3f8918fad079f7b2d12683701ef80451fa657c8ce19e12a0e6ab454242fba4dcfb8817ef10f75bfb7b54a305f15908892750f02ea93e5620ef3144373b8147758b4a4937e4347363ef64c6c55fb3b837762f38ac5e14cffda0c41474516336cc801a7449c826d24e9849247f096b2cc47e81c4f46b36962e869f453d167222905143a59626a0b18e15c15633bca2903f4aea8493d0101454f7f4973d6beaf73b5ccdbfd28cdc72f4bfe16036f67e5fc8b4fe9c1ace3ffe5459fc128b2a100c1d235b6b3214e5a401c27d6beea178e1a374212e1bf0a46abe9bd77a4901793a6030abd5149ce8e60c5dd66dd195d74fb69f5b25c976e1ede79a111316764b69314a80b323a11866848331f7bd99143d3b515e46d5f0b7e3d658b4bba934c40820ee13cc0867e1ecdfa055b051cba2a93d82fcf5c149cb4854ac8dbda1e70f1c6330b575306196513e68b80c5fc8db19f3619b44cb8506a4856bd10b75a3291021ae4435c4e5bbca7a5c5a0220dc394c47fa754e15b3df25e260dcf57adc47126c63b3bd2858cd2befa4fc33fe5e6f557d242ec66769bfcc52b0030d7f3ca025d151ff3444c28b89026e8c440965ccd50ad4feba113ead51b8275fcebe968f6e13b19059225774b8bd6cf54b3189894f08fc1eea765bff31c89b9a50166a37ef2747d7fd1cda1684c12be6ba7f5bfdf8cc8fc6571eafb9d99d1ac02e3e748138f8124f93cef3be6ff8e6fcd8e3bff558abd94917efedeea905ff756425e8d4d79941788d43ec88f9b45215ee4e9da089ab0f25bfc2b329da95588088b97ea90f1f58d7b818acb830bbafd5b2a8c389f1f4ef25c839b7432e087546c153bc4bc97ccbc36f088f82952d50dca97420a72bbdb2e9b894a0d966e48bc97c34f6601757d514d1315cade9a6a77898e03f39af1a2734b666a710e8197285bcc61e49d3ee97a54fe90ee1420d3321afa5034554a47a392280249bb53251d0f88c497523209fa6476be0d523cbe861cd23b20ee2c469929b78662b45dd04d55a97dd62e5f32e9a67e23fb3ef2711e65a109bea2e34656f6cc719bfb46540823cd2aabb95ec47f9c4343c10f5e4cbc889d38b658800e38d456502cc48a925c62cfef4c2c64954a2b4986d052971038b025b6d911cc6d7d3e0919b580fd4339694d500af415bc04f610a04e4161551870b8f115fd0dbbf965c4ac190265f0c06380c2da3dc4e39a1befa001337ddcf1e90a1f41de776a864db8c5044f9abb2411c759c6326e5a9566686f1388d60247f8fa0fb3078ae0ee17c43076722e9d17772e4abdf254746f177229e6054caf9c9abe12889e0f85ffbd91f9550376e7e438cf10c7e6b7533d58b2e393432a6b5834e54a2b573185c7f44c2774371a9635a3592898d03857fbd703585dee4aa35d2868c0217dcaf3313384b60b68ca0627a2a321c126b032a5918b09596a804037c9f392d31bcdeee7ecfb98f6ee6badb531b139ee8b1431bb09c8f5cbe3b2c35d8a2bf08e91f57db045f4ba4cd6ade6879f9d29b885340a03cf08a32d0279549c88a7b07204c5c0da1cd5ca1ac9302f5d3fe7cbf249ca9e6aa0f2d3db71d6cfd03937860f91aa5b4db2064d66eb89a469e7dcb898ffa9c1e2dff4d4458dfb0d23677726cf47339779593a3afce0aa46340ab7f9d0fea0401f84e6ff54a7013ad6c7650d1eb3d7b41b9713b5c64096ab057b980c0f066b9c17233e6360472f197cbfb208968753dfdfcda560d349cffeeb4173dc01f07e3a52e95e49ad368efd3b3637dfab54455de30b1db789473a047abd4703ef53e14d73c81b731885155492f00f7eb24c86bde1cac2011bc41dc6cbb714c9e3f8baa3e689773ee66fe155211f04d5e734029a831e91df4f74565af4bfc0c00c3020402bca075c09c9add7253d5feaa06e221ef729a4740c5d6d7de111849fe332db26de67bc7c6c783d05ec2633508ba4d1b08dc7973aa5343fce8c8f4c7e53eb38d3841e5c54fb8dd9a683d50c65233722d15e1ba7b572a8de5011640f8c053eff3ce3b46f725aec971c53122933114ca452aa10b1a5fd9b5fe77514dead5e580c63c81db8e7af4ce605ef90f12b0ecbbe419a8b0d785264496f60fc578ef1504c1c179bfd7607c2039ca165aacb03bfa773d24f97ea519a674cbd35e4b2d33baee4af031323555c29b4dd7732d17d06fef08a437ac470c424f8ddab7479b7806508feddbe8c97b378f202622287b870842d1d8b5b47606d41eb138b6349516c7888a1b7c895cd632284d410403c83bf5b807d581319a604292dbe2a28142620873e8e1ec126a6320ad53bd8886f4d5299082d8ff5619923c63be18accb77d5f6fe95b4466d239ee966db3477e4e78a2ded5af3788f125e54fe777f311aad6ed2e34561f9bc865e2bd92112b3b5371059554950e5d06cd4cadb5a0945672a7e96e07f0436d9310add7f1ec159843bbf1ecd11853254389ef63122c88722f76999409a780f6f864700ec7effb99e121b00f6c4cd45736fa427d8c32727dced6ffb88dd5bfedc85f3217859bd51e312df36c12e1bfd237b5dc2c0504b062315036718c4d082c04f308e22d213bba19c38c76c9799368cd8985ee268ea543073e7f412e3580f7b41c8b0138b524b667f87e498d6cb622a0d4bb100ee75353f00ce477893055d5c677f63fedc482c732afb51a00f402d31d2dd0c8699d49a12d02e08f7c90c54f4885cb649f7a57dca17f1b44e40adcfe91004787303e5ec72a13a4e668d3ab878fed79b9cfd3d49c4d53be6ca952008abc8716c650fe1a169a8bcff53b2564643898d6202033e68235abdf464136dac9ed34dd1cf1a167c332ee17c0ce60970efbce5f88c4bb2db7be85622e2874717129ed671de86edfadd2b31d4425d79bb6e551b3a2e49d87bd77535fe23587fd27a5e4d9a1d5defb2586b2ce03e8ff7b4a1b4f7ff92177a0f907af8ce24e766000096bdc29e8671b1f17bc6774e8d7147c303de076fcfe817fd4727db16244b725c01765f8555f7b7589f4925d4e529d6d376bf4b2d2bc0ffbd5871a52bab1711bb5aaf0651a360c44bda6d2727c9244cb6e84819243b4c115ac30295ae4b30b3154f1b8a3ec12a0442490469c6ea654756abaac3dee78154687509c909f0d666d0086ca0377af16cc13085af9f4a618944229bbf7c1f862b812f6928b152730c62cd928acb28151fc1a7eef15d0cff9ba9d826add9218a9776383b06511a9db2d0c9e600bd4a9a8f08a34cc5b521bc624f4e7e38db6acc0430e5b57f6588cebe64c48a26c76978ea0600a092196b5609f9b947a71b6d45cc8822baf157a1faf93afb4609dfad983722c595e76f5e82b46261e0ce326b4e2570bb00aa5eebd42f2401cd1052121ee98a64b14dfa793ceeb71ef729b7803b0f12ea0527fc40fc1333ca887553953faf6a7cff33e80606e0dea9561ba0da6febcd28a9c39571a082a66290170b326ac910850b59874e71df06ad7706847d564109f3338fc66c5d7ffcce24340effee4115ae69090aa1117b603f7033eeee7f40d735108f79ebe2fa99fc4bce667017075e8d6dc15ffef39e120b4d14a77c7b1020d5cbee2ea4fa26ff1c6a01dd3f404f1a5e90d0da7649cf27a85641fa2f59d5840d689032082c451858ecb0b2f754b99ead08002dd646fb65d700f8688da54a55f9c7999dcd695438b6a854561d747bcfb66b6a428c8558fc61061755f25cead8df763f1f29cecbeb798cc315e80ea811f6cb69aa4177de8e7a3f7e071745f8d42611250a02da6b2c2f399d24e718ccddb48fca6db512eb665bb8854671d49e307679c4fdfd4acaed9af5f408c69234c9ebfe37258d3aef383ea399f5d58c700681bfc1647d980f632b298258dd26abf4e5f8fed63601f623ae62f82fc710c8bf4b45df1b913bb93f9c362adefd36f34df2f5583ec6659d8ab18f8b6765e2f63507dc7d35958c02eb2a5dacbb80701481379a102b4e14af3f457658a7cc8539185d5cc4cf082cd7d956e49c4eca271e9414bfdd41806c6c935decc597e76e20387cb3e6bbb0c7a9a3024245ae3ac1cdb07282ed46b1ec3d54d86f585138423404b8663e6acec4676fa31c48d0fc767828bd2fe974025ed169347861b8c50d1e73642000da11bcf0ca326a468a8f4b905eda8db8300e8133a60c4ac2dd0433cc8519099d84d0d1d95e2272c18d39efddd214775530036d90d9168cfe85d51ca94d4f505da8f9f72ba8a0a5a11b247f918faabbf3681f1cdfe4a7157b4bc3d7d4700253396980721603d21bd3aa24074df169013064f18ef23c6f450fac4d319d63be4d85b5b41ba61c379194d83396d1496c63cb9753a441f8921948365140d056378070c1c984b9e1ee4bf3b4a66f42f8d8517281502a8231b9e9ca5d0b6b447ab604dfce881c29b024bd049ca009f96eb75d139ca3c0345bc125b447d940dc43ef75fe8d8dc7c3decba842a81029a181dbf927fc614b7cf6ebf8dd1b1bc58e37a3bfa2ceb2409e3c75622d8131720f53ad17732724746c7842c6dcbb9042193091999255df2ac762b07effcfdea37795358b9cc5f0387b00ae56b7d3e702355e28d6b9608695d157c03048ef9f4658e4fc152e6eefb6566327d5894b8f9c25ba1a41703061da9fa2049d660d3b65c8f00214f9695a67692bb46d2abceb540e520efc4e2943082af2bf8a1edd654c6fabc262c724a38d998a12c4002380079aac9052ccae4013248c9e69ebefb153d1865499ea767139a1cde7e8973c6ab3c6b3d61abc7023376184c331f159175473fe48dcf278351f04e43df6348660f3c4fca7edbc674aef553d7f50f2e6bc2fc323ff68d12ad8751ce0ca05b610151b0c9a7a7c372b35b2d59b096840db5016347c6e006797eae9990d861ac11a30682de6d5d61a94057a874b528dafde417c785c450436292b376d061699a61a308f9e170389e9ea459036b3174a019a0cf680c4ba2f69b55e9cade4b6924a4f3837d8f8fe636f934d093c71c791c638cd8e48360846a447ca292817389d628752ae80025cc2bbd865e11ef823f7aba71e0515e7f803393dd6f66a758240e761ebfd4ae6ec48fde8de8c665873ae5688ae05f6f28ae4eaf43b35b462178de79caafea275041c561d12437b8b111d51bde2bf8979b433ef81f0920ff1ecd21e44af3d39660acf2b238848198004355d7c5f5fc907138676d12bb615262b0c6fda1383dff2c75bdf7e04d73c6f80e6de96f3e683d4782f95a1eaeba4963770552b56e1cbfb0ee40c27aa5ba824502cec976c933e51c5748d9752aaaf3da32ad9ab95b217f5362423a5368946f8e1df7272499d42a056f751150b23d32a159c30abe674ed2a79e5898b07642536727f2252e2feccf34412d0312208b4595ae1e43667018833192ca9b1f1f5dad8879bf671f03505a98a9477171ba48f2ec0246665064a6144c3a5dae5390fbc90e187d1379221153e3fec797487ee6e1b4ea5ed7af73ac90f84674f63532e873785d54536a92f8d4389486365f5620b304f89e02bcb758ceb86ef4dcc1e6f1d25494c49314f5935b40767dd3235921b1a1b151de4d5f20e518a93e6d5887a9634237616cc411fa37e27e8f777ef5be50c962b3e01d64151496","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
