<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33c2075846ee031a4d3fedfaa7aaea31ad1862b0e3c7e684888df97b020803111bf9ed45f97978556a4dc6df903d5a5991c1ae82ec5a8091ec548fb2126e7f7f376e2c9d6134e2db043bf8dd947eff7729ad0ff49bb9472eb234277776e24526012ad842a8c50b74405e6102cb49923ef54d47420be3ec8a42ab47ae21a45ed32e1e908fea7a1f8a89007cb6c6a06214f6325ed303512006a8a322666671296b708adbf653ad4f061d368f74a858ba05ea5b6688e8601da0f2e7b804c7f4bcf22702c1b0410d2f16a8c7a3a4ba7bb40ef0aa178471d77f2d74efafd3ea76f5c1f28faff4c4a7e6df9f13ff87533e424046f726b126159072244dcc2fea6bb7b4f2c1ba663aa56309936f245e01626065c3e4603dcf2a4ffd3a182b57e8d144956552ff5d9c7f6ef6681135f859b644cce7218cd8e065c64212866a85f52ffde811ce78da4dae663a68f5bee91bb4721ff2e7ffe71fac296710cddd9b761c1678c48d5fad56cfc55ac45a0dc3ee25c84c3351cc653d32cad5352d15baccb972c8314a9ee1a4456755a39625e103f58fb2b1befdf49492d7f098e1e0f28dd55b5b7bbcde7402776d602df233e3cf6b06d3d08811f6c47936bb6ee7682330f0e2d6a4f4e38a77604846f6f37dd3c876bba2e144c47ea71b679f178de3ddf11d6827e35f4af82598fc99fc299799268fffd474047bec649359fed90ddd81a2188048364c8cb54a9b76d43509567d90d6ef3c729d16f9b206864c09861aaea52e9dcd203a9445a607fc877000e2bff4194ddb766bd79e74569f4cc965cf82a63769fcfe83633535b9b7c291f6021e3d9200d875c27ca743240f4df4b6f5dd0457a8d963338143031a8d5f82c08f85e2cc63eef33642003ebfa38af879d64b9fc1639c44a2caf2ad29f7e7a483b5b9c41e35617ee8c0214ec8b8452dd17c10e8a88498a30cd2163d2fe94be254ed97e1475224c1a5572f4cf973923c610637726a715332b106e318aeb4b281960581cc5b8b7e30e4597eeff11c361909cab309703277300f93fb3575bf83bc9d6fb414a05457d90f39814683c0dda8cdc09e18e96b065ae1c8669b0eb1376fb7be96e7dabe8e94c6898bd9d2a76ab5493b2e9da81f53ffa6ef27989ba2d2901b7ef84675e4ceee4ffcf8e11d2e91580da348f26b1c1ea5c23110997cef8c2b2d7c7443766d70bc31f3fff81a4d613994cedb5cfd5c8aeac46e8275bfeed09a2681da0af4d88f2741876da5c9f9269243065dfc61ba89217d6c4ceb76ef7c3445ac1d0283629c48abea9873377f43fbcfdcbfc3542d1dce79cb488bdc886a36eeaf0a8fe6d2cf72d9fa15e4275f18dae2c66811c9c364ab9caeec1471a673eb118e5673e5f3aef53c2dab8b389f115b77f8aa1665eef0b40670ec7affedce70285d3164ce017022f1c3e8813450c93342ba0d55854668b7f85104c75053f360bc6acf1b9ec1f12576a1bf3927cb15697a674d23455a2cfbf6f302cb4ab7bc94ba3d9595310312a1fd8a049be324db3bc244df9a3f79e34f9baf4cff8862d93c2cf8dd320f77af4d28c0ad6799fef5fad4509a5a6e116ab57b88ae64ecf32c5766a0d56b90f08db0a5c0f3dbc4522a3f9a961eb7a3bed00621d4800978a02f31c38a1f867fc4b71efd85c7a9b54faee46f2b054a0556521d373d2a6169e7e304bfe6f8d84560ad800fc7ab23d4d4c94c5dffc761d328e67871ae5d3924fc1c2fda6792bfc4a2122cc38941138e3a5a4798d92f97d8a22fc7771bb19790ff243108854716823ad22fc1ddd2b4943559da3a0c95fe7582e3926736e8beeaf3a65aa62a3ce87007e54505b09e13101fb6b42b069b96af58a05206901eec7560c6eef080cdc84986b32665a870834a2d4db3c86ee26139cd7d15b39cdcbd2bbe50528f6a83de792e424920c35b7357287f617e9094ef26ad2595d2e9fa43d802f724465b2728d550c022ce11001c3176b8d69e1451222e8af9a29dda366eed8dfd82af0056cfe7d23457edabe5022ab1b53d90da11fdfaa242d1b4509d9c54b26b0ad06151b6f89f56a21b2ece20a9e423f1767297a611334acd6958eef41662f0beb902c7d09e6426b2e697ba994821c14a1ba42f937b2bc464ff56dfa0b3daa1ed85e5eaca411dc178e70569426f1a17c4e5b5abc6ad3652bf66634b9f8d6544d918ef4abe20f334bcd84a8e64ac07d3c196715f38825efc683e3e96d7795c5de3b5535ba385c0887c2cb8969bbbee4af065d95f3340d1e841d3253ea4736a7a394bb8c8b23898eee84a34c0259ca05ba3fbd4deebb32f3ffed19c7a98c16d8fad842d968820be9658ca95bf83e39ad93e6f5d324649cf868a149aec6e43cb452740bb0e2f2434d3dc47c14a0bb5f3e98e5f318b4d67ed5c61e1c25d25aa3f14c9f91322a5e9bd5202a53cec072f8a05a9cd66a2099516e62ed252fbd9bdfe7fd5980916ebf1b35a02f71c8fcb4d7a49ed57bbd8b6e9dadaadfd19851ea75818cf7e4fd6e4dc600c0e9d26da7db00f21188dadcc3adeef44148bec26440e5aa699ca68d4883593bc20c2b90dc5890194412c5903708a15cb78ab6c34ceabecdc4e6359223768afa77445d0ea8e21d35595f86de9fb62b28d096fe6698dac16894bd92455f6a8de49788511efd52d967cdd8643d8909b44f5c8ea76e8b971fc44e419520b2a26f1e5bebaf46cd6a4060b267875a5192fcaf9ee5c9f316ba2b04e4d82375c215766d8856c7b778b425f9705dbc62efbbc51dd8e064869de0d3f04be5e05541b91ad19725d84f143c0cd879c8b5f97b4402aefeb52bc09e7d08f07ae64d6f06b6acfc2c546fd47c25d3eae18a111c3a629782988a39eb92c307b26d7e14fa82781e8f01f61f9fc4607cbac899bff8a1f965f25ee29347e8bb9f5b665d9e376451195aadcc53db10e9e1d40bc22190e935d5f9bffc3a51ac9a6655f36563c1f316768200358f693fedf810b55555786170d555a0d6c42a2491d29380f113a062dc39d5ad8495a0e1e303c7b42df04a70d050223820b93fc99512aa0d2293ac453e5c0ff0c506b31bd7f540239d25e6d70c46d84a9b4381dcb76855cba650f8bd88b6a99711661dab8215e61aa5bdb0c369873c3f07e70da72fd0144d69a89f0ddd2a825067ba1c20ca7d00b6f569086014bcceb6d7c17e09f9ed6c5e6a848168bf45fc3b1e4acc6926c1b1d4ddd572bd42af58360702b72e8d5fa2324fa8183c05624df92e8fa0cde8bba56eeabc83b8b1460e3c0c30c18f32f2cd0b390576031070c3f5f29b22c796ced0f134bbe8201a341a6c94679148e26525a9fb5b4cf7b568d8417759ab6d197e6476b6a5c7159f0ff10b750fa436ed635dd50ebcb3e44ebcc8cab66a5833ba77e21613584791a4bb239bc590781723bc18133d9824b908a0f27653da64f005f296eeadbcbaab57c2448c833adcc172786ace66d524716a344d738c9b491ff6fd0e9099af0f7dde3e7165a9993982840636e1a3b75774bb1f9c63a7d5d831681fde8a993b7c96221dfbf5b87be2d0521023d6a8fec3d7e85d77b54d085249f6ac3d26dfb481d9e98137af7ef502962064a8b03159b3072c9e7e233c3ef62f3e8b0ac24b1eb966a0b85433876bf154c0771ecf40439b29b26c898a7c9d08994d9d62a81470c8985943e1de8c416df2b655fb46e297f90764c26f10098f0ec9f960f716766c4a6207fe2cf215f8063d8f25124394d4aa0b1e34ca6bb60e8d2d36a2a79562fd64d570fcdbc2d6f669ffd609b302f9ff212d83b5f2e5239baa8fa8bfc22fed919cdf863c687cd3e4e73e773132dc951d003f6c50ad2f280d0e7846c865fe22fc3885b333d85a2bae37c2241fe772ebe1524027a7176b1db3c01fe9a65f77100f91ddb825334ad3ee1e133189dcb5a6372ae5e6bc2dc6c152e2c8425a3767c968678580d3fd7fff4e28dbe75738dabc5916f3f3e467ea86c19ed16a7dadead32dba6796f4fd0aa26dd2e275e82d1bd19d8287c0444a7567ecf6a877f3d4aaf8c25d110b9034723d304b04bd7ae9f52695ed80a9973a8cfce5a8b8b8d44f07654d6fa1797c76586b24724231822b4d406abd29499c5bb61d7bb3d70d18a9a942c77f1a3157dddd27c425d236760440ee751451f8c48b588f0cc8baa1686e14ab4c3f5f9298cc271c841f59a026146689b36e72fcc4c7e1329e8f4e3dccb2c0611a0c024cc1f8c06f776bcc8cecda492cae34b80a1a651804838b6e31ecfcc0c8845fce98d413d2b54f346f8b8676c4f8b24eb51833bc9b13f44dabe5b34142b3ce40062ccb229bcc8e0844d0cee8740ed125125ac8ecc1bc0793e5dab64229f05a476113cd699dee8003857f42a9a04d365e2dd474cc9624fc2f3f13e1d64be75705d9582ed3da408dd391068911862c9e68d9caaf98dba5249f652f076fd9eb3a54ab27d84e0e0c556c8e3888e24ec524cb50a8ef0a949490981c5a2f39f2d49190b8f9bf82b5e1a55f138286a22b6517a13392092cefec3ea3ce455d56f2ca662947d4bd8d42ceb36f5052cc1df03ed1e00fec0d4a8f7b0d6d902330e03f6c193c355a8e5110754b8bb1713609775d0cfec251fdafa768d75cfa8a376fb6114c169447ff7bd032d1262b3ca8dad398b96d15b94e23a4228d79678ea7a8d75e79af6c651e9972e262b98ad2e4618829893034606032b7c158c55001d09ddf052da543e0b276b32ee94a254b39f6eaa68fc2d4515eb629dd98f70cdce83bc9a8e3dfb490338e56daecc40905317427c5754940f5ea36fa71ee48f87f2310b35113628500ba49ea51f3c8961de764e1bf9622d3d6291b1e4110334a0bebb381cc8c678380b3242c54fe189cc55a700f0decf5fa1726bad26543579b592bac6f64de41c978fe1f42bf10b4f300143ba493b93bd5056b330449a82210b5c7660c0dc2ea8051c8392c1560a649640f17b2dff8a8b2eecdee867a919b78721e69ff7d365599c4979f7b592b023c6e61236a442bf651ac1d23ec5352e305fddf78dfd4592ace617e34a8a13c8954dd5de222fc040b7c8d7030a9bee74e7d3c45898614264d96179310e40eb88a8fd1f1e1e3e99142cb7d4e32ed6c4c7942b62f5c6e89de9861d6abe43707725521a220358c9447d282cb61aab7f12478f574efe21edba158f88150a11795ba30b6e9920b177398ca006b7f5662bddd5a530353c2699c012b124f3b9a2b58f878b249a774cb9f73e3d79ec564b5520480dc7551a90122a58d43f39c52f44edfb4852724319f8ec7b34f6020aca47d85f523067c0d0a18d5fc4892ae35382270397adfbc5d8df11b1938085e5a2b94524a19bd34b402987d72f6af2bc0e268597904b929b5a2b126d1afabfa5df0c2030693263f2a7ee157595eb3266e15432cf41f24ec3e97439bee3e284f0fb3a0d0904113809984723f09e9c46ccc6dac894c9c890dab54e7ba1bf6dcceda89173332f7885810eb4293d4a60f5857e104a615291d3062634a9c9c337aa555b96679f31ff5b070dc051a959ba85abd9465933cfaf830c033d586228d9aa6b772b91475dce03dfca1f88f1c350681221f07bb0f70e8c1aeaa7bde667bd6e84c31149d8223c7769975c5a437fb9bb579fa6425fdcfb5d7b4b05bc331090ac8f2223b73a0600db4603607817f616fc1f472923e8f4147a0984e91eebb9647cd5af5022ad55bc3de640f7fce7939e207d5a09450c8d74125013c78c0284926a91ac53ef58566c6daaf716a9a9378e063efa9cc06059983166fe4041b6c9ac8102b3e7f945e8aa490cc3a619da01f9f153e01308ba2e10bd9ef6fe62773a3ed9207b0afbb2dae8a3df9e9d21c35df2769171ebe09e53c0f2e1a0ee52883eed5a21544b0cb42d47f60b0c6634509b37d8cb643c389dc7165a05047228b3ce62114be324be5848981b4089b92881d255b7b31b573440291ac697f81db3c694135cd8cd181a825dc2e1dade70418a8c2697c8c9390e2531a35e302e53361debabef85e44e7b0f04ce8933d68280214519aed98a958b4de19965c493b175a08e9097678f41bcd3ad63d24423e73614ea91fc00c8d4e6d3753df125190f9f327d8c585f297d9fc2ec326db7a113ef4300850323215cb6a713457543aafc2381467934ec2de5f41110c6359360a009388aca5fd90b00a236dc0742345fd10b0d0b5343c2d83b47dc3f2a34aa15a495aaaae811db7c7bf29cb91917bd143efc508bc7ae009019eb9e6e92dd7a95f492fb16d7e141999c2a35f4dcd5550898787a9e5c64a23e8d3c0f79969cf60454623a940c083e3e3b8f3f808514121535824cb2e28d908dae20fa7122c474fa1aee1d59deedb3cc417b190cd890d11f285b663cf51d8b4911917eddeae6f458b4427480194e984022eba4265de4bc0ea427f492af2c3ba3b33e8b462a3d964199a9daf8abf9cd032bd8b942b0b2fad681b81e638d5180b412345895a13026b4dc7477dd19cb7570350768d0f9c007aa2da8183d348d5ca9a5a80b5d84aeb846ffb2ef3094d8ce22676c708a5e902720b84c6ad89ec371efd505a5219c01b5509140fee62a301ea37d3c33716de69d9f6fde181339bd845428670eaa3df564071a1e7401961a49d081fd2bcff469ae97831681e816412843a2321785ea287f21e16fa4a2b03fcf256ecf3f34cc89369eb8dd500f5edc089528a275f6192af0885dd8d05fc60adfcf2560ed11dbba4d9310985701ced0d5c00a943c7a63c9d8afcb5b2fc5eade64931939b8ff797b9ba68cc7bf418796033c64f9a7582e555f7820198713c412ff50cca615677ffb7c0b7c9cdd8326ed2bd0b7a16e43d31ef132f8ff795d48ddfa5bf7990f120479d7f87be0a3103432a06760685ce594729d83433d1c48bdb00cfec3adb8f3c7042102adaa403e3b566adeb2f267ac206e9322b50c96dcc7f37578db09f74af03cb580872679a6d4a185e0ea0d9c4472a32c2fca35146d33db996ff7af1930f54028e58dab6555e4fd740e96c54f340218f015814c152d4a8e795c63c762cc88fd0089c82f8561db870e47a78f0e15ae7a5734e35f03a3f4ab81b292b3055731cae19a0f3ebe98f8af1dd77dc835ab76e5e5d036ffa1d3849e7569538321109482a1b57a9e6f283da6003e50ca38aa6035931456601e84675c95c197df7c848f45acbe9f0bd00e3636653a5cb2f90883d5c4207b39c5a01e291f83feb623bd6a01393786f0884fbbd1b78f26402c826a19493df104a6bf70bd376367d9dd6141040365d838750f4fa87a51b8fb83aa88d58e621b63ff88c65909423d2f88eb3842739ff63a6fe8c3896acd3085b7df9d1ed5f8a146dde6e73c74901ce608ee067ba680bee232ebde4f2e32a2fe682e1cdef427e168b2c75f05b0332e622ca92b794f37f41505be6cab785c252c3556061a51940b9a77b3b956d46a1ed2159186f0c8e59127b413303fcc50a4965cd1105fffd12fa34399f563811a8bd31ddeeb90398a3952a49c4cc89928bd0b543f337474669662f1c52863747fa619bec9137d85cd3c9641a2db244d4b5b46f6e6971dc7648da74fc7cddcffce31ff26e42dedd07dfe94e2e1517c3048c989b29ebcce2318e12a63c2b71199609d7bb24fecb5aac1aa57deccb26565c8a7397633d9368e7ca43accac7a87bee729edcd937faec1ec44b96d9776954db8714ac8b3a33bb2d941d95fc4aa1fdf3ee62253917ee6282b55213675e12d0b005ec6ad45e4211085585de83bb59f63543c219893ae407150d888b637f6483a444a95f573a05b0a605ea3d070f7ec82fa0005997bba99ac102d434fae8861e655cbb80639723ed9eff6f98b7d90ef93a45093f09b922e9d94500f0e64a2f8c04371468c29c53fab86cb5372d88a291b5b8960e8078485cfc9a7153492011f5daac10380460be3b4aeb45bee6713fdaedd1bad6e0bfc52057cdca0c79019292a276cb3f5f1f63e00feef264722b5c9daf07ab20faf96202ed6114276ab20e889aabe185f881f127f566849c01a8786b9915fa5a72d9cd05dc06bb4036e733beeeec7f31e22301c3bb330c1b3dc1b88c2d43063dc0d007c7e51d0dfe1088bf7a7c19d9404e8e1075a6516858fb0c5b069a2a7d41efc675ca28d968c0247add4cdf1c4d997bc61d509cf87f7a19b0c9a130c58c454b53c57cbf3708e1bdd3472aa8a6680d3f42f35de6eb365f373607c04093a120eed7fc7ef1b8decfc1f2dab16c88b5455580ef4cd25e841520c2cbd5a0497bfe8682a9eae87d6f161d37bb8765f54dba448ded6ef8ee6b0896a7241df3c2801f137a849ac26113a1f574fbc58bada8c5ff31facc8ded4a5fb1fbca2e54d1b577f694f308137bbd682c9d1da678c5ad703831f287f7b6425315ab1b86fabd228a568a4734740a0bbbb8123def258afd8c47ccb0dd4193588db409eb3482d9c1a0fbe5d7608f83cf98b48b9d4416b06ef533e37af6485c33538db12ec947dfa332d88f7ee601565414f8c1cbdca7278b4b21d5dc394bdec631505679b7f252900c60265a3cf0f1ae2c0d504f82d44c6b0a7c61942c6766e816b29f3ab34a98917a433094c087a5ebd18da06c210de05701656eb24822317a9fcebf2a753da141678d33c9db5193f0a79c4f44e204f10ec77a4d16f951cca613c42b8fd05a651cfcb99aece3d716e2db7a0f5fbfcadd3e176b67b8cfc6fcd5962a441ac9565ee1c490bc938e3147f1ab360c55e0718670045da660edc29fba86b576f1a22993e02674c13e9eebf60078148661db8675e92a532219ff51234916dbd36696e919b86cf35605b13aea247d14f6580c67c7a043bf2cfca5c7b3014166b37e024a232da30a75351a9bf05b0860f3ff4cdfd1388d6944ffda2f0d63416327e726212bd23af153e6063ebfe4dde5325d081bc213df920b7d0a4d529feb53cb5e0436761cac4b5b90ba2ce85bdde1cebfdfa2345762d6c88e6247cbb5692015823c52b3e8ff480ea6241e5cbb65d43e92760b36396d970c71d4e568cc70c74eb1c9c07cabac1641961f57e11c18f4fba63e287d27409ce3187812aa533e5ca0474fc78986aa983b043610c4ff0c7579bd87fc9f2492898d446e0dff51f5f1a7f3bbe9dfca701f94416e12f0dd498545535c19857ee21da229f8749124028daecf62206d8cef5e04fafb1c2a84ffde6e2e1b8f1d9fc8f1db4fa30c92295372388bf810623c3a86763e39ebf31e37a73fa76c300c5e5ff4d237de65fde7997c9b94fc43f6a65964c8809ba0c185f48e591559da01db18673fcd94415651068ef2470daa74d6310c417a7f5654f439fca7ea122297d6e0e8130abe5efa2744067352c64448959a3a27fc46ad60bf4791b4a3f3475407fdfff293510b2689a8dec49e48ce14c1761fb9930f1019fec41825988b2b3d02d3ab6577eecb7f6b59b8475dca50bd359d07dd839dade5183dc4051e50c353c73f342bb2cc40cfd2c864d40b5f01abb0a3c6e9146661d4a7a0708cfed21d8ea679b204eca268852863b85a475e828f3a6653af6bd617265d74b18821969238f44d489dda6006695f2e95f4746198a3d7ba0ff7ff4ccbe5d454119ef5a5cc1a4f80565de42899b202a94e9854ec854c78dd51a4e89534f144e82a01b811f388a1d5a363bdd253e0d4f50ea43475b68b8e3745060f7b81d8a7ff3e2aafce2f751765ac8e8d2a9b5b1197a41d726995da518d628ac22de6cdc5f8f237ae0010458c0eabc2738517c8aa49ac13dada98c069ec5740a5462a671a45907738b715632cae0aeb617fd138475769ce03c2968b0ef2961d65e011515b7838913bd842882b966ec1238bd8d84a9822e516748c36826ea2504a0d09f8caf78425907a3766c59ce65ef23081ec51a33715c6ab2d32961454868bff77ca7fd8b11d511682fa0a4580fdf3871d1262b4c522e1a5cdaff20e41cf97dad7be287a2ee4a415574130e12f76f504380e1bc815851f3282fc6876746be5a08024a303f34771380ee124b8ab2cce0d150b17773ccfdc35e110fc5da445481871dc737de1e66d5d12b1104f1f9ed5b29c91adafce412b2181ad2c3ff8fbf1ff0443edfc74f36083d5c435b1e06f734c60309e3fde26dca21eae588c77f4a6b6418914b1b44dabdcbf21751aca8a24f51f565642a9e07f59568cd5b2b00fe78aa05cb14c2bb6045aea68e71c74d3c22522e61d1a3cd81e79b008be98a206d35caa5b37bb8ab5de0aa7f8f050705dd59f25b75cdef19691230d0a6f7378fc5483e37b789261896560a0521320403dbeab6bcbb1d97a0753419d698453b72573a43633c83c6bde6c311a013ed7bedadab3571b2728ae42898eeb3c6d502c2cfcb1896399e0b8f72d6e070324a7af4cb468617b8c19fd502c46ebd6e2b32f13616366946c24a57465b53ff16c0f4b29fea82b800b4b02f79ad07ed987803fb9fe3b28ee0bd7051d4f7481a6017d99bf3fb91d19cb3a5907253a5d4f87038292f33d2f124566615e2cc8d48e3d30835f4b06c2ef00a75db1ae9a063d0031d376c18117ca7812f40f88a5abb448e116904fa9feed9eaba6bced8a395a093986ab196eb5f5c5cb385cadda1f9f94d79d35602b9d8fee42f2920f71d9259b90cd571970db35bb6ac0e91ea8464c4d5a0b20bfbe8528d609a07144cde2a20dffd87900b40ad2b027453a99b50b4698da398b1d4e37326aa2f807beb7b06053eca71ad6d5a345ae165c9750a1b4b4eb53db0e6e43c010850fa8315e61b145e370f8d9c2e3ff35fb9048174b60d0746fbc6cb67404c5cecda80d50c3b8466f2aca147477617c310609a8fd0670e45f4c180762833d4609cd4be872ed2fb25ef0177e59180a49b78008a2d554be8f749249e76eb8fde5b02457b14600bf369cd0d765a8a96692dae5212f0090ea3e2efd706f2fca3a9720f89aec0c8739eb9d8df40fbf0d69b772ae94eca446b51af89f5818e68e77a70be0617736363291dfffbc0fad3ec7be186c17fc2ef5779585069e60dc5de1c8156ef499e3e0c09b483dde64a6d79f9cc395fbd11b82b9a1f4958ca21c18935fc44c918fb10857b5249af6c49c6c02b26e6764a2343c7eb4c984f78d9394296466d4e05abbc2c9e19355374022d339101f75f920a03a07f3e4b4761f308911edf4079d8f2fbc014a2d2ef5789aa736f8ceedc87cbe111aa47a299fbf183a44ee8597893ff49c2bf56d6b6622da098094d4b65b50cc60eef6a222d0c0924f33f99e23a69be7b982d0f60b4d74cd4298b16ef0b980c43bf7ffc933961e070fe7802d26de1d886bbc4bad7827af8130796bab19d05a661a379d9fd3dc9ab696b3a9a664b5596b78529b51020b1b9a1e0088d7179408bfe3c065c8af5cd03545a83f58c6fb553f4b30e620b01689d035c27dfdec56b1df52695a25d0de205370cb44543320dbfd58cfae3d23cc74fd5ac0040360b15135df903eb82233b21044b1a5122a72d4f9185960e3d2a01d3d8902cb2f57f77a88d520be4af22ef6a0910aa456e8eee2c0b6330f18999e8d9c03176a2504157f7cc87c5daa4efb5c04c3c178ffe8195c6f0c69a9f481a67c6e3f122e527d05ce31f743bf54a156ffdeb15809f20d1945bd65e4103222a09db976523cee97b970ab35e1d022799b7571e7a1a6796da3af040562a3952b7c8375e148f7f276395d03aed4bc87c1a65774944c1dcc7d686b2ad67c8217b4fea7281ce5c1215deafe882e8a251a0a60e23fa36f06240f3fdfb56fbab57a25e7ca5ff05b2d35ab6c50cd8e089489857ea56d9891494ec93bad6ffe5a0eabc3340358f66c0e1e1016ba7ab46f9bfbac90d64687a7312fe52522964ab69b352814827901a9fe3c2baf99d6b3d73d272e258a61501c2eb8f232d39c315b84e008af8e00a251ee4b4b50723eeb7a634c29d96f5d4cc16e6632020d81f5139f8f92d734c7342ec34fe2b91ed96f06b312d99b125739a6cb89e0cdf585816ab4a5e2a744b1fca7813af33d2b4cf90888b7d46d94914ef7921b9c274a911f49bc4887b8d21f9442537c4749891143cf3169f3a2e6cd23a9d41466eb3d03ba6bec614487e97f3d79bccc2fb8f9326e46809432a897c02736ae54d72d254e46b73ccf6dd770d4b9aa9cb57e3b808409ba320fa97d7f2b1ca55842c4a86c0567d1e1b16ff02c4d9ba69c073510601a8a5e2040667c6360f4acdcee689bab697ac158f4b13e6ecfdbe75e65d53d2103a942ba999a07df36e8869d47c7aa87483e5f5a2fe666ecc211a3570ee07bca88e1c0bcf60d8cabdf594fdcc17f7c5f595b70b6cd32ed4c0e216634a11b91e402617dc1ee8b18d586c3da9f6f0850f3b14aa0d474f4130d4428f04712e983818519ae90ce4d9f5eede941b65f31934f7428ff8b28662c9d02d228cbc39a433fe47a5cb47060d8482de0dc3a4a0cd18c64e8c4e9bffec79f41f24a1b7837265788f859cb9c12d8af9d505295591acbde3933077a3539afe9bccbfc6a9258f66bba6a9eef9b89cc27429b90f7003104996f718a7ee895f89f7f0fff233acd261f06760c0a2297df0eae354244b589a2709bc43f9fe577ac2c6b256ec8c30c95ad738d1c44c9b33e9f4d9b0408b91f544fc99c5f3417041bbeeead75fc20092ad687e37fbe6a3f4fc2a7edd2f90555eb407a93f14ae04cef3e4aaa318745811455e022e54f37b5ce62765a1000d3a6129be03dceef9257696725bc99e585bfb11ace383cbc401ab854a65419c5b2aea9748cdd61e91ed46566c53ec1c4d716988113e4633f16437e492dcee87cae46c292ae9bc85978ef968038ed0cd4876ce454a471ff708922eb84c5ddd33f351bf9012591138cc8ce0a9b41d14906cc0a71471f60d918aaceee09e5dad6448d222bd998684b2fa9e8b46f5ba74b16e8f1912c507ecd1df05f7ecbfdd4240873054158e5b66fff58d9f0e8c57d1833c5d2536cd4c467c79a6de85acaa69e463dad87c73f6ea481d42c5de8e715f50ebc966c93501a5e137a596433f9be498e326b53c7278f7c0690831b7221b840db1325d7b9c96bcc5561265d7a71ddad2fa9d119c4ee151ef30e312aaa9f74c18e3392061d61056a51eb5db4c3755f8a887680f38b6d131502125f51addcd16bdb0e378f8c877e40f5d71e298709390e0309751d7f6a0973028da348358fc240f97f308688cbbbe240b3177c4bc0743740d413349a858f2ab5a1261838e692a431a8ccb619ffd6de777d9daf5343a771911f315876979da77444db5257a4c3f06f96af3ab21036fb17bf07b686a54b47a70e82ea05a68f2f6c54a61667d60304e927a2e15b558e4cca1c1857c735b1d162d8dd5c9975fab724440357858b7188b425db447219fad57f9ad11e62157ed784291c41094a163e3548876a7e6428d6f41be0e5b25ebe0c979e29e57250200022fcf3691a86c4d5bd31ac87af478847322088ab7f3575cb8b47e38f7fa2dc42a65c5064ec3bb3d1159d315e5fb77ea66a8a7b91ec08d8a5980094a0f4bd61138c163574695175f339e4d4a72f0bc95cf74fc841c7e20237aa8bb10a11a68f50a6db28586e3846fe8e809919dc2b7b7db0fd6b66e474b2380664904122f944eb9a6c9cd71d607c43eedf59b5be518241638c5eceaa8a7a8d9438fbbde84e31e5eb9ed737845af1c5d421362c767ec37bbe102c1ce565952a8963733286b1da7cd02bb7452f8207f28447728d036811fc2b6c486a303ffec0680ecbefad8db33b7906785b90e2fd018c22e6bd598e39d5505128457c4534430f3f54041fdd0ee31f993bc317a5dd2aadf05fa678a5764d7327f81145e0fc61870ddc30ee008ffc3653fdde51a54204c255e6856b6ae82870b982d1234960e3e002885f9099fcce8779eeeea4d61988ce7fb32a25ff3df798306c1c8a26de34c3d3321b18153daeb939a78aa2dfe520423a75fbd9b30cb7866e5c864c9d46b772f057795b2fc42b28ca3c367500013ae3356796da661a0a1a855b3496e6ad7c96c3a6af5885d86f48a0b2512946da876e81c752e3bf78176e3049582b65ff6fb5db68698ba6906abbeb7aec0e89cb02c867d9fc2f99410f5c831813e97547b4024cda9e38c4c7d9d95059005a44137346ad72e9097846ed33ede12210d01cc04786838d23f1b48726c9340930e08c131274eef34042a1070fe54fd899724b0625e7a6304b22460c93b9c2e263a51d1d7586292914c55793e9b7970e8f3e4da30d0d1248e986ee624243a9dcb26e6cc0127dbe5fb52da96fe6fba45e60a87b292b737a7582e40b206df0926e5816b1a7bd133af11867a9b557be4b710261edc327fc004504446cc2ba0559bfcc245f58a283d38911095b2383624248e324650f51aa7b2c21a907a24eb434e67c05b01f60599a6f91a0610f2a0ca5627b887b3bdb12dd79680d2c2f4345e71d10f29070058776cddd582dbf1901c958e79650f971e476f19b51a44345ff1e407cb5f8448b9f30477d2cd235e6f327a293ab0dbcd725dc7885b9a9e075e1d7408d8abfb6b38b0011788196a1de23445d48c595a94ce9304e69ec33a958c683e1260cf5b36eb506ac7c37be9a8b04d2b8d56bcc07f954f1a7c60f272ed31e233f9cd3c117a8378848a20b5b8f738e2fe4ae7c6dc77012f2f6e2492511c4fda02c0fa5f5b2559128f0c801727b97f3fad148ad6090ff44d9e7bc9e9c58d7f14bdfe1cc082f50d04909a60aaeb87d289aa50e4f6354760203ba04425a1daa94a06f7d59dcf171a1b975e988523c05c79201fc116bae989a9a976f153bf0d50e5d6dc923fdbbd2596ed26ae3663342bbff59a57aea4004173746c0753629185c7ca0ba3d958d9d227b19af6ccfdcf4c25aaf01e671385141d77c96b0926e59ee2f6a4e0cefb48a3128cc906b3aad089bd680f88a28741e3b63a1a1acdd9a3d64d8cd0e7ff514c6cba30f997568457d80dd0f404bd06c797844a5e8b21401e7c66bd054e48bf20f5c38313b4b5192188e05abb66ed39dcc9f6565881934d1dd92bbef21c24e240d18a2aa4c2ae1ff634f7ccab3ed17d24bf863791defb46d15b1f92bfa8f3d17087855293a30806cf69be54343682f7ebe6c40e2429d7234e7e04ffeb97de18ed972b6fe0ae175d0310b90e95e341d2b26997e694d6e703be4743d815b26c882ab773a0e72e21ee7f18418ceeae5ca2b604d728bd1edd9a215a509ab9d81e463a92c9063048712fbc8b4d0686f94d7ec5f706f46db14192ff0c670a1ebb9c81e77450e997ca95e09cb8bc2a3b4c462c4e4bb7a5770a112a2991f1ce34a17900c1034edb830f58a1194770cc130fcf8291e502e75b6b15c581a1602e22bb8c7200a938dcb74645cec48b15a3f97a95a85f369bb498b4cf07cd23162a7ed4e9216187258ba9735636c6cd65cfad167ba1f636e89b3975ed9a9693f1e47fabfc946cdfb138d29cd59c50e5e45903fbe08b6c12846a3da5cd219ad1da263e5baaea45cf407ef3d0ad84374943b61719c495b08ecff0cb55bd562527fe54a016867100d8a238695693c97627fd1f4593e8b913702ac1e29aebf3ae87ac6bc6a4077a2680d5305f40eff7ee28e80d0d7dcb61e23c1abbe891349ad2700241e2340e95ba2fe1cf5aa5a10456cfd139cbf6416bbc515630df0fe56401a5c610da70826f0ab7b8f0acdd90627e1a359ec4931fbbe3bdbbe2e6249edf8ad2fc72f39281068cd38abf9d608bc0a41c90cc7d0c373db7ec592ec5b5c39626aaa15af4d88076a3e8d9e73a6319594c168f8f1b5c3b147b863b33f35c88f168cae3ba7989298f8592951509c8c8e41d2c1c2fc6b6106184650181994e42ccbdfe4f4c94bbb5f6958653d97f44d97eeefe4c908c0e2a82fc38b45056eba2ec72f3866a0e200b38d760ca5b55f49f1c844e376027de74949916d17f4ee8e227a7875b4ef2f86fd1b90b8b0bfcbbb8d3a4c0a2d21223910f48cbeecc84d088ed605c8a587e47437a37c3cc38d03124de740a77a11a99520169cb2400d855ebd1e6505046455f877c8144e42ed76f4b682bb36a46407f503053d546c68b33307d57beac5e48db1cb7d8799370f15730bb3e3926b048b12c0800cfacff7139b7265fe933f5b62fc5371ceea0c5f1ec77a888e204d980cd98d7e21e069d374319f5a3793a1e53df7c83e41f13bd2db0cbeaa7167f4afcac1647398a2066b5c536de5347cb7825d95ac14a489899a31c39045b9609adbe10c142320e3b23e042bb33a8d5f1ba49caa5df4b42d4642efca01e2dbcd4e8712d249b86586a1dca91217b399a0846f1630c679e7f25d8d1b23c2240f9b541380528d84885019e425ce82821404cb54d2cba8825af4a852d3c0c68b3770a820e38fd60bf7da9b6c1415f6a2b9463bac9f2fe65e51e3a38ff88abefab70f28abfef321dd2361b38eedcccf7fb1004cec5cfefafc486b2a54b98b6886bff4522de255caa70a65cc40beca426b8458b1c27a5575498083b5e328331c558cbc79b645671becb77eaeed5b7f4e70b85f8a432d449cd8cb663fcb50fb354af5e789c918d82b20bb11e511584dd50ee32ecd949af84917bd6a3c5f9a781552e1d1dde1c479e3dabb2059bc49c654e54edc6a31065190de2484ec665a9f76f2eeb9c8fae54527447092f59eb7d83f924cf2c274cefbf6b5cae17f2406f0ae1486acaaf837d96331d510a460a04f82f35d6402c3499f2a8a0b759ef79aa861ddba42e91031aeda82fd4a7de4adc06ad97d1871c05dfe2d8275db3189189abe4ac86d6890d25d32d620c9f49e1b61ff9b752e537b5fd879c8633fa7fc8c25d84581c267be8a6156456a7b280a43bdb961f2a04978ee8fc2f7ac29e0ad97233a102121bf795694480633004a62d0e9667a593b6c75898efb4d8ac1880a8956f9f71cf425baca5454d60d8fcb6da1136468f926e88851cfa1836c25d601d1764174ea1110351341c37de7a33067648e53a5cdd26d9510013371a3505ac32f01c22a3665638cc208ef8083c133f0f550106fd44ad9eb87a4890be1ae0c4380485ed0732ae1717fef126879a882742447b6bd6e1ad4b17a6b50dba02a25f508efe9f1ff90d33ce17a930ad4d7e7a232821fe66abf8c42b6422669dd5eaef5501b3c01a4e7bed97518c0d159df524a3e9d7ce412ec865161777a6cffaa0af9c57aaddde29890fd7d0af26cfea649ab45c98b9f35e6d499396689a9c7c54d7f07c7a9ec86444f386fd64cd4897f52f2bc21aef9ef80ac6bedb717814e0d1d089cba18e718ad3b06390160fb6b9c8488caccfc159ec3a79572091830fb64a14989bf420506dc38ccdf3386388bc29f4a572788ef3b1fe1f8f1424988ff0500b31b4f8a34448d7813d0df945e22fd4566c14e6b6f7aa04e0e9bbc6b148dc1d423e4b9df2ea060947ccf9839b4d00ab973b23e70352ae8136ee531df26cd5224aa6ea9a8e69ae58e89ce80b74a1daaf0704fd102cf6c24bf38209b734dcc77e5fbba8680f72cb787123c2be215748ea6846600d9b5cbea1a4530d2d408512abf12d34e1f034f8714a8486493b7cbb7d1802fbefce5f5c9d4347abff2daecb727e27cb87f6a1ef403593e3c65da1ffcec2c1eb21a320a69547342a6f1a476ef83e0fcc00edc93d9cdc1e64bf60b925508269912f69654829d845de43b6eb6df888ff193c10466471bdf95a402f64ae2dfe48fd351bd1f23933cecdec6bccb994128bd1072fa8fa9a6d4db18956fd3604c075b4e715e87e7329f221753a40e22681ebaada90681ce4234cd51334b6ebd13f105b3675b926358e1bbef67acb17dc02b05fe66cc15f8190ffd7a3a8b008d47c92a29251c4d70c5334f6bf7f870fa333b25d641effbccbae450aa9b7282a84a8ef91ec3e3f6fde01ccdf3b9a3f846140263c3ab703eef8c41de789588e8dd3d2e114131237e60e65b753f5e5499d466cd5e172bc7644d50c6d8bb21954b41d724b6571bba52a71333feb1da6d058f2295e597060c0f3022bd4b6f59c0f5268d3d9a04f003c4a2ed851e2bcc48243c2dd5693f0c52a3284d74de0720e2e4d265de1cc351d414962e24dde2f267e45f4c72bf53fa3b6d2ffaa5b5bb12746a4e5b7c25694aa639a2813c5710b37c6d4174702c8c6187764d159941bd0feced8c1ada697dc92f97478f93253489433ae442e497f0bbafb96668c3091256b84494f741fcffa74f4c27f7a8386288dc110874e52d70feace8b2278455c11b354ef7023d6865a7ec18ae03ea80d2c31b7d6dc0b5f436e531219782f136d1eca533085c34920ae20adfa0ae495a82aaa75459fb676a4afbc8f03d7cb311b4dcb2e66866f29a4b7fbabd9e0eff081a2b03dc95bcdc3ad1520a6136851b0f5bbe8b289d0e0a682677d60cf68f9ebaf22e8ef26db2c20d7a80bd4dc2034090acdd4e6e870ddf2609476b102d0330611c20a1267e3491a9c3b64981e70e48cbdaa36ef9aff12cdfbb8a4882d4c112471d98fb4feb81e6cf4967e121c35df5a9150fce3a31c5fab4179cd70cc47bb671ded914a74b09e21dd02ad1db6443d60620ab705afbfe6c64bf57bbd9407ddfb15a8652fbb2a7b5c0a4b96f607d2d1b87104814f1c01e9b7e3dea8f702146bb58508f380b1612b15e7d156af3a1494eca5430d0a115c87019aa16a82008f7f386d71ed4117ba39de357e1b1f51024e970d0d3b79dffea8a082ffed36f81d119e0c44c1c55ce8ccf934c07b819f3f80169fb0d934b4e876b7e412ccb1896d56e828dbb458cd6f0c6a699fe8576f525837bee53e641726336ac56384ed1e551f189aad098dd596d2328b7d4ca4304470716f9f602f1514ed62810e5d4a0c02dd7283fe28087f167700eea4786a2200e862aae9d227106da427d6cdab090b897f6541c41fa5c06e6bd2957d125055eea78a830fca5b69c17aeed9ecb2f9e94ace07d36c6eaf11f524c573fe890b4b5cd0bc8b15b94179e2bb3dad37c5790e22fdf6260263b3f262543dc3c95239a30d705b9ac918de285cc7f7b4347a1650abb677ec12a0d0313585740065c61d740d9f035fa12f1abd4cec903b33ca01205df9b5869e3422ac0f7bbda2cf8ed438230472e7c25a79fd530a27232c0e15255197c2d7385d97f0a38dac321d8cef7c980db7f6c35f6a1f9b1972a1001754b6b2136d483195a44aac7b927ea554ed7a91678aa4e2e853a7d0e163f1a5eaefa8078eeaa15e94d7e6ea79e5fd056e13efe165b3773d1078b769dfdefd64904130409fce57a6ec4eea7947d1ff5ad5ee28aec731cd3a018a040ee31ed78bd5883d831b9c3e2b2b4a730561336d6bc8f74c69c1a059b2e65ead5a86f2c6600c0e70472568d309d2ffd05e1111ef4457e4e1fa8ae006d8934d59fe918c0a3b5377a385176df89f1dd0e025cea8be2a5aea8a23ec84dc42a219cb464151006bf1210271b5880a3dc1ed5b5a8574cb5035c8324c19857dc0840f3abf91044bc7443cb7367934bb5c50a431c2e20e52fd005194fd7913a8b1eab91e551fd844441743c9459ffdee2c24e4562e99ad31259569d4fddc2df3f160c25f3b2523cf3451e3783809043ca998d71ce34ede5ea51717b9d523e5799b43f718992887825cda59f3fdbb335c07c4deb8ea33070e2d546c380b4ec7f32b0e6e7962224f7a3d438236509b12ea9d09e615","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
