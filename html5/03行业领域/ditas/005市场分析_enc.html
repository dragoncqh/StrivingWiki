<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d139f90ba3c7cac5efddc2580c5f00e9f437822434ffbebe67ac05f66c7e18c2f2d4566f24d940abef563a6d559abd2afd0b6c2cdaf7cfa3d8eb8b18dfc65224147ea5b42c9ac2c9bbd6e2094d6ef333fe282457aacecdb9fb3ff728eb0f70a25a7f9338d25e739f1a0773451c5582a2a54478c90ad6201f70447ca4a78dbe20d73009ad84dde64b819984251d14a54bca5c1c27d4a0353d31e4b29868f9ad08a3be648ed50751ec649e7b7bf98199dbfa57e2f030e662f9fd717cdad48cfdfa24f8118afc2e593d7b34d74c407342597eb5552baaaabd221ca974ddb7e60a0d51a8846312c45168f8b2f0e9f837d648237caca293bc4c0613bfbb1fedb71a9958ddc2837273124b2f7a3194779480e343eebd76790c4331a859079e913c0291cc788fd4c589768214f329d90717dd4f5528090d922ace095585a86a6615d01638b80bed1f992b95efc716834660ca5afa6143a6894d1c03b82225037b6c8e07ad0c5e61981dbb614da2a83dd68fb75b9b4210998f323b8320a2e62aaef0fc23b9e9866b14e3b9ae50702ae3133830ad9b704ef40e5fec258c2f12cc4fb81e7a15c8f3b44e3c59cc131f1d9d80a4bb85c3f3eab040f1f04938286e52749c3b1cd857730d8d9d6fc0f01c1cfe5396c206c824b1c156d11f16a262baedb564854b46ef3fbfca8b0ed48e644e59d5ef715e324554faef203e91fc777ba169d1fd9e7dd63115ff0ce803c9f495d122afcdcbb21cd582238a490d261a79474707e7eaa42ef7af33790fb3b357aaa5ad7e930060762afb7ab018a0f7ff6969a00ea65268bd678a5de42b5db7e9202115bda54490ebc3aba07f09c71d64e7d2bcf98826a1d2d13383e811631fa7fb9a459ba2de45e3bc1ea153bbbce79656c7428fc6a09af9ef76c34bf85f0b2598abfc8cc738d10106ffb7cfb7c7ed64ebe1f00782795c84c3a549ad91a6c014195a7b27af25b73924d24e299abcbdb440b15bf9b79bfbae137f9414d2187ffdcf087fcb1f4003bfa79f0da16e4704d46d72bf8ff927b0982dd0846901bb4567a8e940a015cd637dce098f5e5ca0db12798500f57d0b2aac2616284e9d4506fcb0ec50ebc9693667659e7fc8540587b7a9f07cff487cc2d2c3153706b9be664aef04ffdb022262d191757aca84917345307c23f260f593f08bf72860defbe669d4d46d18203c57823c8f337dfec52647a5c5f790f6a7ca1eff668a4638a3abbe9c1556465d3f9908fb48700c75dc1dad00ef8900cf4b0f0f4b040d4e46f8fc25cf9c64a561128df76f50df258e3c0fa802c2b4d03f7d1437e1cf347e49e4d6eb3190e58f7b8134f55ae72dbbebcf32bb791a799aebf8bf917dcf31701cb56db3613c315abde1d48aa74789ffd3981cb8f9936b9f13fe939b2d3a0c8620d27c6653fdb8e6f9fc179636053bc30c1b8afac890c57ac39771e1fbbdf2a8c9536691a8117777e829cdcb57cffe168bbba0221c3b8d097c3fc4b643fbfce838a5c529d0f193128df617a2ab1da55a9fd3f679f7d622b4e61e30ac1159158b7617e85b9c8fe6f4fff8da8389ea83948a8941c464232e058dee44872518888e1c64790f25d319cfd3959caae1547d5956c569c6478a9581ca17734d2672e06a7c0f1427518347f3d7b0241ec450add50023b79a6fcea0491e1a118addbc381c7290e7b18190ff1575b02194a50e30fdd642f91ef6ebecb2751593c825b83283e05c96ca0c3129ec64bdea9ab06370e71541287dcbb91cc18b5486506b9a57feae187f980d2272a1dca5024ed9aca1dca218105e01235ca1a7c1383d21f60a287a33fedb30d1f2aaddda01de7ff18a7c5381f0a332287d719cdf1a09def804aab618498183a78c54c93c5ba52e82c5121dffeb55e501cf862925358e8c13d96f2eccdde5ad1fdf7639a7a10f048cd83db3e69bf4a9bd09e8563a33711f351aeaedb413c0689bd6ee5acc30cca81c430ff0f3b5d671df27fa76f7147593645970307f7c6e7b25ee9a2851b1214c570ea0ddbbf5a285d151e5b5b5613bf3ec1d7ac4f18ee33672453cfe99e6433a6dc9372ee2e5be0b04a2c71c87d82a334ab826fead7a6637f0070c62c233545763fe414636eaf687d68cdf2cc0d97609b7d10ac246168c2a0799b8b02b0317c6671ad9a4842cf6191a898eae0e371678151ee05bd003a3dc92fd31194b53f7742250e8d194c2f7165c95407c337b58a97aaa0935f7c6b42812600c6f29518b259a5575025befe61aab3138b5a0677d8d4f9a83c329b33e60a1a936cc29ece0dc49dc69d92907bc34a4eac16a039f11c8f538c06005a040e08c073efc2e78c7a103a1e3cf7bd96dc76b64bf82bee1a6839b0ca6f4544d09565a24599a8ab6b08ce730dbf22a4f7405626a58e1e68c202f077952cc87d84e84276a9d3f0ac674fa5eec9bd7277f8d907d003984da8cfe14848e12b9d5c85e89147f52b6cfc59cab9c74dd3ebb1cfd3bf124947a247f75d9ed96fdfd5675a2801a795e3b9c14de51ea6d9e7bcad05e853f7ffd6d8b20494877ea6c11fb7723079389b2b262c737c3151d67007b6e06107f096d605be3ea94707f4ccd0a9574d54441fe680bd8d02b9c3eaa962b99270a1c0f590bd46e36dd5608535cf26f496a5fed5b6149fa7f49d1a7811bbf2e6d62eb67354ab56a087784039aace15db2985bbd8cadd12d88331ab762895a70910d7a8c27a0b5d1e56fd9d0a66450b081e35fadcd693ecb63bf1ab64782164ae72c56a7759b1cee538cb5063cd0f9a2423f61dd121e7951b9cf01963f0157b116b03135e39f90ec47508de53c51da6e38f53d22ff14eaf49d48b7ac1b008eb712bfcf9db316387d2cd43651273f60ee31ff6a30209856b87775663a588d17edc8bf75d5ddad6305ed1f2aae9927784a0a5c7b0e469913c74aa2df52159956a8eb74d7731ae78768d92a5e8a33dd732801aa03b2bdcb47eb7ba67e7c06491517ddee56bd37dee3867d7488d9cc313d380e9c07bb7a91b49da2ca13a82a9488505849c8d987b10c409e9ea43daf6bb2fbd09d74d9d0b85a9e4173013a3a585d699624c3cd1328a34fd3158e1465bf45cb741703dcf24029ba9319ecd793b74548d9d7de7646b87960196e55655a3fe548b4a36ad653fe3863b7b4e0895f34aaa9b466acdded08c240982a3fb3a1a950a3308589c0d141291fd5bec64c6861a7f4add1815fd966a3b667032adc057fb923961159646ce857d0355e164469223a2a8be81244424decb8b261a28f05e880177ef7b5e8a1bd50f4d54dc3c0317698fc0d0d887358fee6ed2d2ceb64a973171185fe1ba640f87456f10abc4bb43e93ce23c1c2225c732ad2b9aec93cbf22cfb9f7a5becf60f0c255ce65185ebfd63e5e571a83b4d0ccbb03df1442db4b5ee77eafec80aeb2bfacb3b703a9a02e2edd432f3fddbaf026da5ced01bafa7cb009a2f2e8944da5f1a63cdc587fe37ab2383400931df7cdc96a3a96adb1178b9dccc84c5684b00e2815ea71e55576b230f4e380d4d9352b7462165bd67d9d4cf992ae1df8a6bfbc8819dbd3be21b21abd0c035b05221cec3f87036159dc3989ea6dd651ccd8a8599d672673b1fb8ca9daf6eff8833eba9fcbfb78fbcccf6f78727806b533041ef00e587759cd57a2d2a5895d321449d6cfbecc47db521117f017e60f3afc076754acda7db6d22beb8cd1392c3e3abf5897cf5f95edd13e0e91d29dca6a83a522efc21d84db61d8195c576a19cd66f5bfc9cfecfc3d02e7bdcec63891c6db2780868051ba4705f8d3022a95c6c3e352ec5fefe2a4deaaeabd19be6584b3d1668bef736ce472adabc6b7ca466684e1c47c68e097b813bd7bdfe377c481c974c72ff1828b50937df7b6c2bee0ab1faebee7d40759699e7a91dee008ae92348d68337f2ba42d9b28476c42c7f7bd8dc95d57806e5354af03cba4251b540c2666c450a46f3b8f3ae2e144b11f5ab6950f13b24fb460b0ae7417f27c350f09b460f21b0f662af7847b3d2da7881161e9b1cb16a72eff4b7979ebed02d96eaa0200f4c8280a2b15b68186b7f3faf249bbf3ab26d2875c385be3910700e3a85b652983d460fea647c9216cc2baa78649616700234a01e933b2eae721608d18ff87e8b3bfc55f8839f93b538860d1f02bcdca3737fed08ce66fad94580c94f01739ece7172d456c3c6ce82a8b57c2a85b51a00e3c0d3c8712929438e15f7f46c2d3f40b813ce1df0c8032a4ccd2ad4b56b7e9ee750373763600d891e2d103a6695615757fbe03ce8d562e0441d70544e53b88b6f1c9f25596c9c00ac8f693588eed8a1dc6b5c099205d4c3de96ea0a6353af69346efa8cfecfc157906a6e275040d4a43d54b51ad0c944e9359097e02cc51345aeb1d54e448f45178f24e87de2e9cea02c71bd7eaa21d55c3ef9a1ef6c6b4ae398213ab83df0b311622e481431b1a620c4b2a36dfbfbe057428665cbd30f027e4c62ec383fc1f1fc3c1a5bfea1ed16ce4b8d5fc35864d1dfaa7853242b3921253f79560d7ddf69785724793cffd197849fce8be728b880384767790b42c74c14a77e9a174da610d9210a2f2f86c3713fce8294ffd8bd27edb5caa0646b44cb3ce6db1d531997a5f7812241f20d858cff2ae2d58d20665e47d7eaece3b3da62046304fc3594fb2b31f023a4a4ecc4994792926d02b9c96299bdf8ddfeacc892fc52a2cd1b6f5eb8c15cafe8b38aca244a51c39e3cc0eb7893d157b2b5d9b7c478528ff79733a4d04d656c3b49f6b6a53e2644fd147da7ec010e1bccabd1a360ef16562d1aef71e8d70d63f43aace0985ac42b417e252d090a306b246ac80fe1471ffdf5013b9a2f97341186f45bb53158d0c84f58423bde845f990e0958edda2d54a63e44439965f3c41d891153ea8d67eca82666f88735492a28d2fcd9d65fc5973bf0f6f465fb03610e3f74572f299c4552f839cee21ed03a3518b1534f1085248123aeceb359b6fffef746a432e3702a8bde73b023efa554d2672b16267546eb91ab949bd3072cf9617414557c59180b1ee59ba0e5cdb9c730f17b629fb5c9e03338099e6cf6b5fea7f13b92df2753e2dd07fccc8c7f35aea7194482b428439921117e62ea29aa7d3df23f0fbfdd3b07d40b15d306627040d873caf3bb8cf92f2645f37c8e5c3439ad3cc49d7a9f1ef06b457afd7806cff415392fc9f33ab87faa59cc48072d2af43c838aa0116fcaed337338e38255b936d74ecfe98479b01067814a4cb41c6e5d6db76bb83f152aed0bffc7bdd9187d6bd08e89607af6d5970c967242396b460bc1b15b774ca6220e30934dfdd4b1a554ca3cb7eab26f3c9bfb717e633914036551488f766de603f48951fe4c1ad3a9b8363968236ec710b7003ab0ddad83dafa8d6a55813d5433e37b7aac49f5c71974d8e3f3f2f4080535781101edb125e33e70ed843598bbedaf58e958faafcf9f115c62a2b4f3cc3f9f19a21febaeb720171dda51630782387f59a0612f77fea8910e9e9d48e3a0c8f2ec1d1f2244374ed4170de220ef2dea25b391180c49cc36858d4fffba0ceb866840ca2c496cf4b6e1e082927e04172642463f984e5d9e78eaa3d72e40cfa35f14181dff53a5329dc2ab4e15fa5a9c18cced9e7ab7337ce7a65e3162166f2bafe22ddb363f52a38680a10e2177d93260f435ba76af5a811eb10c3c1f6feabe020b88e99d65cb156b3c96f530d699af0f7827b47c5f2d65b586c8a0d4c1ec11f8d30c14d16f893944c36b09b5f0ec871de3635aeb0fa5b828ef44bc5bca4ae3cf523e4837f0a944f27e24709eb1f4346e9deb2cbec3471ff8eafcc49a33d4390d436d8536adefb8b81e05a7a1b0cd6384e4d8083e48b799725cbb7b8f7f435586059076bba9b53aa1bd5d55c4994351e2558bf76479a5f87673774b891a59a81810c66d5b3a856ddc8b759f57ad79f5248539e8acd89f0b15495c3b64b02b416e64ef6ee7dadca35591349aa611ab48bf732c89c5534f243b84c7d16033d147c3678cacba99ac48c02cc6b020a339cefc3610e222f2b158e70b230d282a2004ea5596f82bb0c686b7798bc0b8516c3505c87be3b97f3d236a53a05a939c79daf0805aa7fe142579534d2a9105e35912435b074305ed1eabfadfbebad77414f6831eda68654483fe92c35e289773baad60812f49f7ec3117303209c376910a0a3d5aa7ed350572eba0116bc691fc2ae5ae2e20ff1efa9af7d2ba37adb0d7e1025e7b61a3031bad829c8215807464b664b2ee62f335bdb6d163065dd81a5b1b9bb81b2dbdfd866d1629cad16523faad53c5281a8f580e99ecfad2effe54a2b7ca9734210d575545d0d94b5c6f954250976e90f9be44ef7d5bf16f7d180527c9dad97cadc74f7fa6a62329a54fef7f9d7208af6c64f029674cb68a2705669fdc88876cbf78aa673d8ff98d04181b3370460f04b0b958b95c04d83457e89388329825bde7424e5e19d2662c8a91597fa755c6cbcf9957326e015ab4336bbaeb4ca233a35a2a1344b2fe32fe686dd657fc3d377276eeb284c65d60cad42318ccc7f8af96dbb337040fde80d38596fb69829c51658aea8b99971d2453684444fbc9c14a0316ef47588410d38d007a1d3178f4fb7c61332f937ac26b5724118f94647c14b29e72ad3a1d09a9f906293b1bdef3aa7640d1dbb629d0aaf7e32072da8e9b34d6ce24d007a548d45686a7884ecf33971dd296f8398378db48df4a9f777d8ff8281395854b25ef560e97cfb29e8ec96d5369abe6db805695bbe0cb2a9ea4777fc456d3e2eaa53b65567baa1fcd2ab48b4c5e90df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
