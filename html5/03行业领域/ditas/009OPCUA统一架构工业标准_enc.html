<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"acfacbe14cc9ca42e7498de07223a97e43222b2571b4fea5b209f0eca04f8fbed0ce61ea88301324e2475e2d18fa31b51a3bcf15fa7ce9adddc68d0a7e342d1f0f25aa1e2757128b8c36cdf2f1f415a22ba65c1d3b1be24e75478b4e80a56a5bc122706ca7b251a9ac34f3303de622dd7c94cf651550cedb8e8fbd28c78caba1339e41c7b47b7c7339a9a03cb78e95102223a80eda451997f462b7701e519fb6816fd17953c998125dd9ed8489415cb8a56acfcbe759102364024e22bc8e78939fe0da26caed0bf63c470fc52fd5d8e956262f78593e05cb0bb89533875bbe4789acbc7f4378cf43e073da46b73d8fb4a53f1da08e9f34797b89b9a5212608dcfb9ee20efaaca92f721db2fc2e787565ba27f40058faeb08866e5cc0f54f687a0507e6d879887e1fe362cf0f3ef6e0d7f6ee88f1de1b94c6c4737fb486b4b1cce12063a200f6413b5f6f20d5cd81f13dd1316b023e8e0147792a078b92cc0430f7b980d254d1e680666f02c994605d0d6bfc757e0f7580207f5845169cbb9333a196c5a41834bbca49ea45a72937d4d74bcc5b8f33c0a3be12f04945bd7073effedd0da2e6f03bd6a7a937af3af897f4368380cd5500816510014b584fc5de6ff45f3497f412acc7aed0727465fe1b5ba8d502016af330a787b9166d7b752f8d047dbde0f25fe23350f817557d3904f91812184d5b61153a3dc8a79c70cd0556578669a1cb3812ae475bbf6d76197ea8db0c619c91615969dc9e3c244835f08a9cb24e40fee37141e6e2b61fed58f3531531b94c5f4485d0c4cad1d6d6a7dfd192664146de701e0aa5c942c63d18f0c273e5c8b0194029ae925df8aa32aa8ee4e959158434492c9a28b8450274f6de0c768a60a9ef635eb603a552112157f0af5edb778e58663045e8eabb03e8cb263ba02737146b732e6765dec5496d8665da86a03df8a1b2e6603965fc0e4a95eb034fceddb5d5a0ceff23905e69e83742ec36356bd49b06afb577007f508e2cd0f1e2b44c6039670833e46244472499f3d1945b8a5916d0dce77e76c5011ea274e3e628e61e0bad58955e423f9df9c385eb0b6907beac4878f5f8c6e6f9c6d62ada8e05347f7895cb957e94e5e2340d330fcc91631612ebd193d4bb7fa5adbcc2a70a26fe9681fe2572f8abc26c42ebd4b6bfbbcaa4848865369959647cbb1f820917baf03ccbf73c2cfd07714dd953c1261c68849b356d8a4bf878606548a0acd2d822f1de64522de4d8c55b855151510e009323ac76250d3b30547bb7fbe4810a1dfa7136af045a0f195b3f36303ec38854b5c494bfc2e9977ca9fd1c3d34c7ebb10bd076fc2e73d2ca1aadd7e6b588019d38ebdc01138e31994d97a1eee3d6f0abbd9ec8bb1c03e1242007d615930b56fc88cb36ef2495cd010dc2afb416ab0bd7e673eef0cd72db2bae7bfa290bd03c7fd1e71702c4c9d7b1a4aec7ed1e0a9e7a1f6b9a7bb62acfcec0ddafe266187ef2fc5eb4668bf1f18d99b4cc5b5b47f412f8ae5646f924f2f699839d875d93cb7b65439a5ed2aa72e996aa6c78f4590c15b0c1159be4b1a21fb591394a5e918f6d32e29f1f45af9a119fddac3b94a488cf3caacd62df54db1ca13f09c13e1f25f419608a4c03b06acaa83e680808b7a557c53497826fbbb7c4dd46bc08d3f2560e4e00bcc958ed640e53cbee63a9fbded363d9d4fd6889384f5325bf3a8841c6d5e3669364d38b456ff15c36adfd37835406b69521a6f583f2222db02fadc786953bd370103c00ef75dc296d3e0f7477fbd0a6319d6d82aa35d29a7ffcb32b8033b100c788c914770cf550b3543e585f6356dc2b13c6f1efa5e79d08f1b0b6ba90bb38a3ea113a4659b5ef93f368d1b717fb551ad949581eb0bb5d058975cbab1fe963cfe5a5b1decdb4cda4e6b3e64213f4b7e320df5ec956e4dbc08d30082a403b84812bd39c17a36b98be02704c523299acd7e7abcf936d4d2ff66045db94df5d87e97121539682e137ad6e2c0be05c3f2fe1cca6f0a77e4d6e2b24a8961bea634681fd3a074c8536d8bd84a90dd972cba205ec62b5825eee99dcc48c412713da3027e9bac984cf1f4b3883d8fe17b09d33cc269237fef0d3fb9e538ab346abdb18f8ac3259099447acf8cff6c226b967153dae560badd152798ccf7816bd4440a7653f111e43d69b7554ceddb5c7742c93c43ea9faa661246bdcd2ffae5b739d0956cccca40cc6a2cd670799ff7843deea241ad845ff069a5c489a96e377eef19bb1c1c797bc2363a1c1c159de4e7b3eb217b8c9ccdf24e36429fb6698af3bbb67181ad94b72d6bbc2c2f8dba29b5a5a7150e6df62c065c14df8f649527987820567d9a1767fa90a07b513044c72325df28d081e2f0881cad654967f6eb09c0d85769f916778f5ace9799446c914df2588f14878729662946c92da8913cfc3f503e190871e0c99285bd34368ab9b5681ce5237b41a44baa19b95fd7e21880bf6c8e0d10883b704ae011e7b259f02ac39388bab45226ea5ff11de93068175bb169887bf687f9601c7c874aff70a28097c3b039fe626d3bdd7ae2bfc31f33c15712bfd6030121d833c9ae7f5ea8a5a274db49b71dc745ecbde16bb25903cc5d328e75175187ce372dbd228d7662bfca7543c2692e64a2af4fa0f87df901c10ec6b7f78082ac9b05ac81621bc8d5fc2af56326b7836491426be57538dd485c1b5f02b084741d962e3ac9bf3aa741dc10359db791341ba2d6ef272dbddfad4a2aea4e99860bf9da4230daeaa8202b8c0b287d538e84b1990e0f3dc65b5d52772a5ab5683f6aea0425391bbb32f1266cdf05e8a27596f107b864cb77baa930977158ff889eb6087345646aa3d8aa5482a9864efbc0619a2c94c688c29be1693a3ed3d170efcdee412ff50bf5819703d4e5a2ab0d66a872c22cb273b0d9e619e045dd67c1a4738f690a2032e4ffa18959fa064d30e6740789071754a3044044cbeb4b7105f4005c774d755172e6296353d5a3f8f010025cedb9e41adf88b7c89216b49b421e70e0c1685cabe8138ba3bf77f1ff041be2ea20c7c2dbfdca4d211208bf47ae29b9a2de0a55cb8098f3f5892b627b0e908ddc46bcae52407c166b54ac5f9ff273e09e422697fa7baee484bbd5f7e64fcd465e5d909ee23d039763a0aea2070ef06ac10228e497b7253455d332fe97f417229f89e2aec1d52df6986fc65cb7f35170462813e73c6efc8c7eb10eff78cdf5afc05f21185b53cd7d29142ff7f6387d5c06ca9322f4eaded5637f8a4f95832ce5b0445e4126c7846d3764c60a682f6216ba0f21f1e37d0d4b49091bbd0f7d7e594ad3e312acb313b6659a51c198d71f7bc1bb56c277bcf54eec0aeb478c566b27379cc835be3aeb2bc7b336dfbc2382401b75eee27b2a2f79d70ea709d167c6ffbe58bb1d2ed26ed0e62ea6a8808ccb3ff67b36a6592ff87542e932c211d227d8806974e4d841b21dfbc9dc7a1af5879c4190443080696bd94a73a647b049f0ac201d7048aba5e8d9971b9fe3f5a5a29e84b38965e7ce5b2fe765731146a85e22563c2e655da563f7e0c910567a921f8da658278b6723aa5bd1fb37c15b7db98d0cfff42e65d93ec71a89c893693639086a679b4e4b13234dd08b8fcf23c1ed967de7944673fa7fbe6bedcb044a857019f53f04c58677aded922fbf796ac073a81f1279455ad7a70065113a3e8e29f054ffe1d83c8e18ce584348d7fed8bb265365afcfd7e9d180ec08513788b0751f7da9285c71a03c07aa094df2d3adc9718b332f134eb17d5e08b76d39c125dfdc5885d897b3afce7be88396b4402c6a0312518f879cbb6cc3db37f8b66cdee437039048622960822119b4a5d9edc04cbcbd19eb010601efc151d452382c5ce24a821b02ffb3c5adcb0e51968114621caa5a8c82de2d57ee9815d5c19dcc58844a46730f8b8ec8d20d73bc8095bb43723d4ebc4ee262d94fdb028af3c6a684ec323f315551b07720ce8e8be59f59c3a837a6c7402545f0efc91e5c3a8509f71aae2a3b2e57cb85168625eaed4f4c6226d385dd78b0dbe6dbe965602188bc8cc55db830a935fc0c9aa61165180800f65cd364f17978af70151926a6b552c23e1300350fa451a8abc1cc9b205db7134f5469a9eb3f0a2abc3207b2aee01061d7349f85ecc12eb055878834b30516194d1cec16d55e5fa0c4c7ea4ac9177216b80953b817faf0de84f98ae6dd7d228b187e13c42d56f55ffdebed6cd01a296d6a1d991ad554a919fedeae1a49667e626770a072745a53a98f0f9774777f1e555f53931721b1d4c3b0ccee19e34894f43e0005b3f44d6edac9ebf22ca41a0c50feab8035d5b0be789d26d09fa4ccc467eef721f00e234c37b5104d477167ff85bc33cb4c0728e6886b7670bafc98da3a7053086231675b8d717be6cf2703c4335c139d808179e737b3f7b3d76041bda34c44918f509ace9c4f9af7ccc77a51e15ca7844b7580f342dcb8bdb697bc8c6e332bfd9b0dbc51573c73fcc0fb18909959875c41174bca9719948e71edd66c7ca9902c15e3f4cd8ecd6c9956717bdf14a8717c9b36a86f2cc6cc13489d581e093c88bc6610cf25f780c78e5d538739c7132a1122f9701255d97ee58205600c6d3eeeca5bba9348fe791699dbbe083764e0b340a268220a9f18a9e89bb16d7a2d224ef9532d9da5af665aebb879be579b3146b603723771685f5fd449238c61a6554244d9fcb191fb4a19aaa362d62de6f5383dec4b6925566018d32503c95596fab904fed8128a9503b5759838ac0d34e1231b3be0aec0e93f3bff73609c39ab74f807c944b0e46defa356b4526f2057a48b902017cb888e9589fbfb077a540875dcfd1bc496445d05ed5c705ef254378aed1d89795cb71cd853389b863304ed5393b84ab09ec13a2015b548923293c857e01978f5ed0505311f3d65ecd2a65407a6fd33327394ed54d827563f2df28470237d37c05b8113ffa77798a0548b8d4b3339e0959fa20708dc671b241b30b98092d9ceecd757738873387610cde4c0eff84b01617eb253ad0bd7e8caaa72d22ca57f503ac83c2de1fbe24bf5183172efd542e3e5186e046917cf89fa9bd2f5c2abb7a224e27679bde40cb041f2621c3921cbd632ebc41e4f3d74ad03dc2039fe4f110c1fefd659a68f1c1e54ec98a063fa4747878169299efaf6b12030134b2851145baa55c20b27ffad39e2e2b8ae157d8a676b535b2ce5a20bf8b4c2ac5f4b8982445aa5fc10c0984c5db74e30bce60b7fa764ca649714d6653c10bf004e5b809a88327e1088cb599a4211e3f5c70acc325e2c9550009bf027c04634238fa659a57a74861770ace6110d05431f725ea1d931067a6d8d8afc2b52da3c2f0eae567a6c69914b9025150a63efbd8a65fcac8dff4660e969fdfbb4effe153a324ee784dac15ec09a7e82584146156e7101f5078a9b434cacc90017bce5c44a55a231abc23649d51dff5aa36180421a078ed18634d323fcbfc430d45508b887a1fb62f8e6bf82faabf4d9b7fec84bace2885a0c74718e98ca49ba1b560397c3b436f09b18197d9e77c7d7c1b2f6984978607c6a9b227c3b83610b22ccdfd17d996ee5b6c58acb2a70339e43cde1f4201739d0ba799498e038b1d4e5d8496ede50f0eb4427acf00b6e93736d703a2a1ffc4dfe733d384b7c523b686ee067856ad8ecaf4e29e7159fc6d0da3b6913dfc6dfaf56672d4c45f004d9dbc19a37e1acf59b4ab384bcb6db8b6caf7a783b42b8645261990e0c0ad9d9c453e3ee9ad83b11738ab2b81f1c1681595fc15fa952044b27b4b5e38673a82b7e05d78b4da53b894e601fd0539a6923e557e151de57a774e4e0ef209f3500490d5920d45ade378cc8ef5c90979b8ae08693346a1d7e7502890477f387f8325f0c5053ec803a9e5b385467ff43d9941d6b76b20c0ba0f929adbdf23a227bc1b404ee743f750ff3304389b79ff3e2a1c4dce9d8d8634949f8b0f466a4024bc8c1e991d4291e6caabca287dbaef25d61b39b34f92dacc33f89f0369a5147e310a9e6a647cd8a88d0e65fcbe58aa3b7f92b8a23475df76e91b132cbdd148131386f68b68158d3d20398a8b39ce519b64fb4e0c455b0e43797e3cd382a1886b5477bf067683175ed86ee9c2390d1a6914e84e264769e0050d2decfa374fdbef607a0a847d798e4217d62212a7aa804297587c3be0c4d01dfce17f08225e9e7a7148e9db06861506d2c86cd08767939aa162101a6552a748b94a24b2fbeefc9a429c3b470a50360aeaac575a917457f1fba499a738a10762df8edf368dfccf9185493307973e2035e31d45ef3d0b5923a449936a2606a3c625250a4a2b6dfffa213f68523d9d35247e8796eca0fb0ceb000e9e58d323af4994174ba6b110e7f7be3049825f20bcb61c7f90933b5707dc71f58932aa8d37eeea71282476c1fcccf48c104d4d46d66489e1d9d47de3d9c86ad686491991d5011891cd722353d42a0f634c56ed2088aaba8aa9a750ca7302c2b8547542082c53058f2eaf328e92b9a4a6e2c0feda035bda1494d0c12279c6de55413f8c6414747d5498a35f8a699caac2019868a743695d0a27c96decfe4373ac6f78693994335570e8b755faca516bde3a0711c3b06692e9a4ee7db022666a18f26941dbb3bf4d2646bf4aa93403c038a1f8d3ad3a3edb3dc0bd21292e00f152b0ffc79ccf2289ce220431bb00d279e26ed8038ef94102475eb51c9c3b7bcaf1a60330ad08b8e056e1d066e12a9fd09c92869a90b136a5905627af99fe73d410c3516e88c6cd2aad0ee21c038db6dd279b9c1972862c7cd266b8bcc7a55c6c90b09e05e6b27867ad5a1f74d06b1520f9b68f9cca5534ff28dfb2a00b4848c4261e002dee88f3941103f75c77e7325f9853f603ee346eb70d4e10a26af81f364f525ffcb2a11600ea1597df1b33568567c9bf04fc772b348abfb988056c6873c48d50d5fd338959d0a21a54246a701702365eceb27e6d5656c1edeab4470499bfc1d28c741cc829ea25d49b61265623afc47697f3de314fe2fda3dc285317bc616858dfb93b7bbcca2e391259ad06ec1f98b53d4a42d16fa5a571a135d99159dd09a964067c9a9a57a3e385233ccfbeaa5bace3b67b7615a6b363cb3d1433d15fe26d43e5cb0e0644892a83ae5d73b59ae86b4da7bdda61b870a6a3d706923e7fc1023070fdb319ff211d7a1042f34cd5682432cd89b60ea932148d0cab0ee48e703ea337f457e7f678f2c3a35570385b5e60b6bedc6e9c67368bc68031870e2c6f73cf2c37c1ca0ee58500ba68f29ff13e3e8a084b0897c57d2c559664cd61b680a8a3b20426b37e33e7a608fb5413e856269b7c59907031ca534e0e169e4e97bb529ebdb11eeda9892c0d659b12c87b2a5f2c481e3a85c42e413c8b9b94ebcf255dd2d52193a6bc3b7392c5e11d3475c82a7df4b5b1b0365a092c9312256ff0abcec9bd628f146b64401f626e30bb1c93d2ba42578489f5d5868d5c06c331667a6101be32a295","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
