<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25ad20b0151c43322951c52aec8dc4482e4439cb16f83a8824725d283724ccbd42687c8fbc7401281356a23daca6d5144a1986f6e17dc595a7d374b077ba107af18a4213319e28e04357fbbaa582fbbae62cddaf6bd55f3693318af13880e72fbb1c22852ecc984e88134685806a43d10483ee99af84c7fbcea6dcbae94aa17f86683783b6720d57e52f5cee9502dedd684f1760bc1ac08d6131dcd635368eadff1406a5ddd1b18103b84e87a67fed8bc82d69c93b78b3d86cf648d20f208cde2d717cf7c8d98e6704adc43618071320b4ca9c547a7aa67e5bff0957e744d49574215136a92624c9559fe16a6982a10c6b9fb37ba6e328d8c03d05b315b8e907e77e28ad19666f2e443e366115e6b64741a79c65aa89109dabe9347e3ae916b2ed5aaa056e7a795d344307cbbeff8545035e40f18271ddc50ae732ee37cac8376255f122c66c715b6fa6da697dfe64d0e14326ee0dbd483b032eec791d88bfd1c720bee79009e3beceaf856b0b8e17ffdf4fd2fe80aab21ebd7931d721780afa0e6f6219fe224d41489f68cf8fa5f1f177c1a1b5ecd7076f2320e91909c3de1bd154999d104d1f1c3d60f0813865f22808fd497db370bb688e9fc18dddbc754cb113ea6e7c0fed4c6e215332a5ec09d88f1367e9ffab01f1c48806d9362646aa85c8f3c9702b30dc123d970c28f5765146f2d0b5d539815f3e3b14d333462c933edc1da5b3c78d75c8eba2fddeff2ef83488a2ed5bd957a114b60a246567db77f0830d393fc60d8e72e7405166588191e6d0cb0df096f4c9bcd05200d18604d9c4b4861d0a31401c3e0ad9128749df91ffa9a8f1a25241375c6f4761f984fb0f15101008716b695ac3089e366acb23351e6af7a615491e6a8d680be3b7d105ea3a0166146c91697699a5b596236c3081710a2727cf2dcd5e9faa11c92da9ae6c03500da419b0b513d37d56748ac8e09704dda9f8319326d6540162bdb9d4ec0857c55f0843612d9d262fde0a1b1a5d735d2766da8abe21e5a53c37af11f7ebdcec69ccc813835e72fcc2efd46d6d62ceaf7db279fd4df6f3c04a4dba05334d3faa54e731e095ec2321068c5d21c614814644498a7c58a934ea3ceab0d27f97bcce07b8e2dbef2311d73f71883d2a37971b5bf70e0d825a68fe02b5db35913376ce446bfd9a97b062a7c8915f569243cd1f05772f4bebbfd23b16e1e8dd47b8c76b9847bc5ee458ae7c219bafd4b40be0124c71c47c1de053e379d583c2a7c078e6b3d378b7b277bad0df0facfa641ba13ed5814a5ceb792a51b441e9eeeeae751f0742842878adfef4ea269c7d28b122ef44c05dbc41eb29f895deb2e45ac75434cd5f4405431582ae18b4d90b7cf23bc5474e16d519fde4a0f6dcb82a37408efa79627e0d9bb7ef81303a213a5720b9dbb954d946083aa2e4c989d7af2ebc29e7ca3591c90202c21e89b073f7802a2287f55809693f9c0378ffa90def6565968b3b81b5e87d6dea8ee9e58f56fd59704ce1abd86d32bd724d884fbf22b7617677be93e99f38e17b9c9e795ba480f5f0f00c21664e8c364a65cb486b668cefaccce43cb601f6eeb0cb998cf5e5509ebb5751ec0a4efe0c6e397955ef28986bb180cd13f13bf26104503e4efa59a0ae3976893cf93bf55cddf960f18d1379ea84cec5d2e901c2810a32e299944501d7888beb98ec1afcd47d0403ed68dbb2d16c225573b40f98ee51d892db1ebe9429f7dfd6804e4285ae4868c8bb94cd783f9ad8373f9df9f06221e3ab28c39e4a9d1aa33aa28baaac43da63c81dd2122266c67eafbd65ea6b1f7337ee857476f4f6484f9690293cf340b5eb484de47a87fb5d1592f0ce3a35095f49cbbb836b7e38d26e98c08291dd231ebc88b4b16be9edf986db18aeb2cb2c5dafbf51d355f29609bff12e3071ec0e1ca7852e742a54366c9b7fa974716a52a7d37beb106f8abe3d58c0157154797744acbd6a675b25b15f1291f687f058caddc8b0d62e11577da3d59589166bcc536a4df28fc691faf5659abb4b3c3f9672e67e6767eb32e1da6054122efca25324871d53067814b487ec406fae8c7195f048ff996c9fb5e3b2ef1ac5f9c3e84f6e9d0fc2cb0c9b837c952209d552435d3fa54282ddee3860f5bbf1af6004963059c115f87b5db460a84049f7ee44ae7a064a395208166a6cfc68b62c81d08467a0792f0fc3bde73ac0f9d09802f459e92c1c107f4ae4b62bca117a82c17471f2c0da99550c9fa38fc1ba02198218e875809271ddb7a8a4c3d2862376edad42d7a9597e8bfb1c8f97f9ea8245d5e781287b8f5787f6598eb7ecd7ddca22ca21a55526279b952b6b88c4ae28ec1587b6b0f121384e1a08f7fddf3d8cb0d3ed382043139adf4cc705a5390178b5870e8852024ddefde53749396c2b0d19fdfe2932b8abf5a1929b07ec26c7047d59b5679a62409741b2115f8b033f709e18946dac720afe66967c0a3071012bcc8a99b245d27952bdb864f467d9f3cd3766570ee1c22d9f9adbb00e25254f7eb9c3bf7972fb8b142f788f8daeb92ab45ef852eaddb69dff497dff03ff3e014abc8a93bd6a40ced3dd56aaca00549f1fdb27272846cc9fd7b4d40949ef43d7e78ea88ba7186593052087ae675072aa52982b6b742efed4f0942fce7b9aa4a15a7f619529dea2431195883dbaa4665f69879a4cd65c87c71ba1baf7350d717962c4d270349f2ed3ba82418423cceef9cda9050be36b9a60bb553b07d9782ef42cadcb1d81f4a1fe9f7fc4924f08955f56cfd38f17c9adbc603e1911d6802a391ac39e432ce3472b40eba62c517729f66f6adb3efbbcee3a2bcc39a2e78017497249556a20426e10996705365c82d37188b54d618e101b5b66ff7a916e5422cb3fba2381cd56fc23cd4b4adeb90c0dae6a5f375a3a5a923227a7f18ee5a740abb2f065403ea6eaca520f3bea758713c7b749a396ca660f848a0fb70568aa48cce3d808ab1dbb8f8df6f4987251ef5cc88ffced96128d97690fb4316f54d585ba919ea1751ece894b3987a34a1186f1abbab5c160ed71610d5381c89da61067ca090fafa9da56a389c0e9b2a1671d1de5f561f16dd31aed139c0715037c5c104c2469ebabb87630cca226d696367c73b7a07f2e4efe21d1196e7839b57b85aafe11d5aa92193679bea4fe1c88f77d61c85a1cf9ea710716efd745b787a0ae737a500adb98128279b65e50ccfbaca86c3542cc874c2de76a5c34b26224f45a8f4ac54245d41878758f438e07565cfb858af8ea2fe9d98183990d7e3f6ce01297186336334c7db216ecf39a6b5a05136717a77c1b961ef45ebc2f16ecca416d2e4fc43482168b82431bc1070a9de8a79de423a4b131de93e1993abba4aee970af805118213936d897cfb8973e5ae1759dd741bba397b063c3a78972c19c88a0ab50ce78405754046c32da3435267eccd5926ab4341a55f78e84df569475431294e63f62ff0664d1b7d8bb807ac38471ba1c13e8bf4f30f8d0401032ac3ad4849bebacb6555bf65e98354bc55a22d5914f8ae5cd8edb7ca1764c659b876eab3390d88680ffb7a7b571a01f2a0c8511954142b9ef8fdf78f4a21b90696782e5bcc3c920d0cc5bf7d0def4b15aa442f73cd4196e76e28f28ffd54610d4f473359cad2307fb30600a9970e85221276db93f71eebce438e9880bf5d400c3de4387353e3c8ba314e35f1799856c317392e47a82d33632f1262d2e77e57f1fa4f27b3c02d336dcb1019a92d0d41fa5baaa04c2ad10f977d76dd2caad9196d9b2c084a091b51143e629865f494b13293be09719532191eff0ac04ebfa04dfbc2c21a1aade080765e3db50bf5da5fdc8448615db190d7d581855a4845c0bcb6d419760ca9497e71a87099353ab5d814331023ed371990571d2a44d8181dfb19ff25b50814bd0cbce362c36d2fd665f47d15b469aedb4feafeec723a3af3da0e611a8a9d01c1616876ba5e4951c8b1de73e528559d4964cf067a2793b10fcf4b284be1c137c0bcc593370c9974a8043e8b64a4c61fca467efed75ed087b41283c927352193b4b6f9eff5d0143c638514f95ff102bdb29e36c7dceaf08674960af872d1d044975b0a53fc27327e17a4cc611adcb30b349b86e4796555a3b7a75240bbe505f8e59b4cfa33cef5b9a1d2747f1851e130dc547537b691eb2c5e51143ec5ba2ed00d645bac1afc88b9896c697123642d906701842d4d21abcacc8a31be92fe116fbb990aa3eec55f65186a62c7a8dbf30891691ee1bfea2aabcd0d10399927fb699885dc0f6b48e1669bd74843c16e6d2e45817b09a5da3b0c840b4168b2b1d7fa26b63fed1dc6c810c09e595d47478dc448db32b06b7c9b57ae7c439635fdea7f4878dd404d748e2338b8da67c92eda2ec405eab06417f48c39f65ae2fb59959fa0de786d6ee6234c9826bf06b3d535684aea3619075acf7a7ef1c996a14dcc364b3cd76df9fefd023ef60a88c2ee0c96fa83f161111167863446dbd31e644d4fde4b226f830909bb59fba1ba1c9529fdfd0ed9eddc2e72027ec2423250142038d8d7284af9902723bdc088e8c4a23fed044762166bbd7774af6ff7d64a4ea7ae8b5173f3e6d8ecaa279882819ac0c03a94b194877de0a363ab825fc8e03c863339c7ba004baa2d2d8d2349134359163dcd4fa2a6136c9fc8c1100633fbe16b10458c08523d7bf80ce8538d7e7be3877159a297cc400f72e7d7f81ee7774407d22c8292d6245c43f8afc7fbaf64ab248250dc45a6be6065ab095aea0bc5997c1af4d7adb90c8cb7286bafedb5d9e4969e7c1ad53e211f500ea0b5db500943fcf9fdc742fd807cf07a73d94a332add7b2d72b7d4e62fe9d2da5b47a94e77f5442b5002125cd549db1c4c9b2afb03e091aa8f6d0a6e5966f9d6e2aed7a5deb5a0558ac0e8a98ea7c824a43a00fcca98af28c18546eefe6a346eadb433bcf0e455c1fc0017a926692cef690a0b9e0415e385e755b039bfc0e0c525f1ff103d252a6ba76dd52d9796bb7c5d86920b0e0359c8912b0c10089d476bba47044d2736949f048d117de90d82d20a45727c5a8ab4a79dd9e25432e05d9f1f6d1288079ec85dc332d62ad305d0b55bdaf8ab9fbfc26f7b4d0304404d5c1126c730442af402327a1bb77f95be358dabde89c934aa0889b7cde071f9445fb0916b165bc0edd8a870dc38342dc52bdc1b30ff65f2e430981b7c1a5a7cd1ec7aa80e130a12ff633d7fad668fe7006e75ed6c4b7fcb2fe4b8c549ddf83ba2704cf0ea14a03a57c935399b5782d98416eda67cc9641e236038bbc44a62d1cdecfe8ad6332754e5ea59c6252c09536eefe228fef21c05d7a01f6b6dec2d076b431ed8f432c6b1b73d9c285643e372a7e393cee20d3bd8b11bca755c0e329e2ba449c81a2c4fb6e74398a38f7c496a681bcc2d822d30881875e89d7627188ce2a822326da2baa22333c19251595669633b647f1b5165b603b2515c1fbedfaf76fd56a70955eff313ddafb12d67e05462101cb6f32f7b18ee48983d37c8d5d78a63ba6966756a538abf207cb3e120250db6223da09fbc4e025a11a03683deb4d1c460b101c8a947b4d6ac2bb27e3655a6c667fb214b39eabafc9d5368e44bf807134cd068afd88e039a4fa15e5e12781e3cc9985ffe68038920d0f486d5d3b4e98cd12b51b40bf0e1c4a95b0ce15c20418ed7c09fa86e765c3f905547038be01c0eae1629f1faee82936fe2cbdaa87ec3aa85cc19d28b3c054390e3bbfb8b741b9d02fc7fd73956e6fb2d6353c1d43276f3bbee965706ccfb079ce1603bc24a90421cb8d724147ce14b4334e797de3c9367fbedd95d35c4d42bd4cd2da65f22724d5623a4fd2f182f8750da08744d9c981aff6581fa9850d8b141a23b6160829147911b42a6a54c2b092c66bfe2b033ee134a5e2da023dfda521cb249d8fe1c3c178c394b2ed0934fc0537346cc517981765c2f7f2fad3974903e7da67e883d7dea55281f5a915783500df57c99647ce0905522ac021b77ca61c50c90a4c3f9f1a7239a0e15423e97eb44f87ad4e80def18353ecc27a6d8f0fc2a659afd8786dfa355708c0a302ddf76666cc335b8f8c725e6eb1524716d299c00b285c1d240dffd8f886fc9ead89d68441e3ffd27eb10824bd1e57d6cf955e7a709457d281d8caf69d5820cdcae00d89d9a752cea891ad149dd1ec2d28c12406dd7d918695c09efa01a5690ff485f0f6e44eac98f3af9ed70804e09706f9f4e4506f705af95d0bcf7789c942b21b598e07b55cb1b74b643bf623dfe3ab6a2b6c65da1297aea621d1db91703c11490ed5e680caa3bfb97c9463e22771a6cee6036b6a37594d6a2e8088a482871e956a304f9f9427f031dbec33e0e65f1e3ec7e000500f7869710513900589d443985f6529978abe865852be8dfac84a5ea66144cdbcfd93a83e717a8ec993f2cfc60c4dcfb6a5360edded6070162f32827c11ed50bf76dd78d46aa365729909cccb4de45c76388362114e8a95479dc59ad9bba5ef7b5fb18d5803dfcb446505b42e68f1f3f383e6bee3b13b2eb0bc097c336a95cd4093ea8dde75aa02a9f1d218ef63174596871b737faff0da4cadfadec3967057ddf1726ba6658a69762e8a6ac2203b702c155b74c200b0d01705dce33e8d3c53c8f7b4a35b107d6776786473607fed67812b042ca11eb734c410d5e07c1dab8945acd17793cc433832d30a06cbe0a45ce24dbb24b1d9f2edf6f38e807dcc8d2d676a2b8763e82b5753cbbc767ab82f57c3654f4b7de134c412ee97eead58c6d7867d72f04a9457253da48662ca79a9ecb8670fb6c26ab8274a00be75e268323950f917fdea63a81385d927b012b78c002c2e7f4428298a929dc3acb68d598db1ed131c2f058b9549431d17ec2c600a131f8239b37d94cb01cb7dd7234fdddea4fc89e8d1451e87f762ca03825acb3bee91df24641aece8eb78fffc0fc7f238af0df0f473a813e65a7110b10feae228009e85366c0046a6720ddd082e9b4f079338d7432b90d69162ee706d3614332e7c165f4e232ff71efc8a2ebfed522a3648d731118096f2ba2115e03cd55f0f3e0848a1b682db5e290c63fe0864c045782d746900183f203d908291e1f4b787dddc61086af204ec22f12257e31dc9af31c3ac3edbd9a694e373850508379b7e1a44cd4c63946101b242753ae067ec0754e47344eb6af395649debb4fbd59dfa6f939b1dc1115ec95dcb456163a80a60d735daa8dc4e4a3f6dacbfdd78f3aae308c3788529c690307ce39a030320a9619f37635a9a7f9cf1aa20a9bb8ee841684b6db967c50a1e2ef83c377441fa5cb4548b487571f953fe6d4c389dcc01376d3c0b2d041434122b841fb83ba21835d9e5aa1e8c2cd9c770c309175583fbaf84705903927c5cec7f7432a8743ead663e7e9874f623a3ce0e067c026bddd87e547458dcdbe69d784085ca456db65e57a7a17fd8ac7a4a65e8ddad8f27e27e65f488b3e22859ab2b15e672859cf78e3b8c47450f9b5dac7aac7c8d2c982f75fd85d1b955a24e52d6a5e8bf395b45ca885010d68607bb273699fdd818ba1939b8b1a119aed197db4019d5fc3df7d9f28a809f494541213c4e4169d2428dba6b7a0eaee19f39cae9c0fad99b7894c2646e5a3b98f029ebe85518a138764c6fe2e911e2fa2e3a7402a813d09634988a8fc21718f444bc8f16ef0a2cd033704526e4cc8c22b139e7223e079e1a0286449a85cb9b1aa61cc42e41c20e24c7ab235650c397cb962a2017739a00b5e745c659dd108f3a33b12c229d4091846ce09c3b57cc298b524886c9897f6bf518798d7c78aca1429a5c1eb4d84166baa5374d100e21af64f4a46817e1d291afe4cbf22aa009b67a9b1d383c97436d9600d98599df2db37443c9c6ba660e11d5feb628354484e81ca2fcf82857bfc69f162222944ffd7bca5264bbe6c856b3430ad149c97ffff132e307221c918fff7e12e1bde1b99830295fe49edce103224bee097303888fbae64d049f3e261e970a36da3f1aff9d59928bca1462c152c3f233481f5cc67b0c1700347a064a9ab332f88ff9ddc3ee49e80805a01b5a581714c2f5a43edab1cfdb3a2eaa0439ee2aca2a3db8656ae6b9fe83c0a9e2ed16361d6e8a3ec63e622578cfffa404446df57468193bb8931d0ffe93c4f65da37eb94c77f03ac028f64ba155f7b20030fa431c6424d16f5ecf608e645eb702fbe69194c819b2d9ea07d63794f3695b96cb002742dfc7d195dc254512fe943ac1e0f5ece3bda7939e6dc01a20a5447914b697e24cdb1a43e9261dee2833e7a4b1f081c0c8c2c5a115007bb4c8057acf5d58ed83ef15c7c71c6e300ef46b3512323a79911a969a7919af4cdcf16de05154de1ae6e2793a7ac7ac7725aed572ff996556a72b2c506fa877238754d22f2285c1f2df77165750adf69bf9fff8eb9a87fbfb183e2ea3c705cf686d38944875c2c841ebe104611b2bb0ff6ee9efc316ee17c7c35e3d673fedfce5a906ee0b22a98a2349d0df3daf4a7a7a7f5b57f7aeaae3da553433ba7863ba4718ea2bb8e42fe8b0fb5207c041d6bca26bc95b7b4b6a0aa45efab72f7db0b8f22cadbea8f5ae583d88e1011fbc8a85a28eff9c4b72e802579c55a21f665ea8b043b817b31332fb60a6b358e7a74b50971d0fd83523885f9f79601187ed3c0f61eac6d8594d278bdc8bef1805077689d853d4b2a8a3cb025536460a874da19baa47778a99f1a089fe6c26f442b38c30ff1822f1ec14796917bd702a8c980e64207dbb3053a7736ae5a9433faa900312f4d4416296ba05a17ada7a2d11b51ed4c8b07abcdefc46c62043aff0ab9defdc8f4cfd40de4dbd038c566229901f2f803de4a0aeb137f23ff05a71ac105e2d90d6dfe5e4243befd1de859cfa5f616fd3275554e628202af9c8fe199613ca87b7f0bfb919f5b1a0d38ea3fa46ca5d0c4046269ad023022c96175c0256a27d1b9f28577e8029be00865997a8fd58799471d81a249c4d0e672fc818f76d81038a6817442fd2f08c26ff7a63968d00b7aae1e0c2ecfe009171f05d94ac08db1265e94dc1101b3f2d5061438ebfecc8e3efe036988232186b355c12f6609eff73624f178f3a1e449f4166c3b00dbef5c4def1f6d638b26ecf39901d7dfe1c7290bd3c3ed7e9339a206d307035d7cbe20d6df64a18822bcc389d9c9aa97acd90b2f346953d001b78daf5d904a32f29308dbca9440343e22380b9dca14e53cc734d05311a04c531a3e2b624e2efaccb3b9f856fc44938785bd744f01f161b74f7a86d9bf4e3195680c0118eb14a27754581f71473cddebd1f63bf2d11c606f9118bfb98ee1e5e5e67f9f8768a4c09bc309862440317efbdb4c786a392f9ad09827ef9d82431ddacde41a54c73def8c91bf1deb9d2470074554aeddf9bfcf71630102065590ce694c41cddec6342523788d1b308e06847557d82e7dbfad014aea34a68c408bcd9d82b9a241ac43aaa1710e0de4deaddf9c348570a9ee32e5e9281c4b4107f8a8d142b4e7f4325fc0fc99044bc754649bf28affb07e247908c2b1a31717b26c7a735d874ad676ac71dea96f528f144324f61cbf6323afee3fb97f10fa7d1fc8615d6a548094cfeb02e79d1161e25cb1209c5b75eb0264cde9c8cff045a9211bc69a34a329cf56be705be7e10457dd0e738fab6c7d73f6a3be8e8ffc233bbafc8fe9c52ed2d61a905dbc468acebec36e54629639c673764ce6a8d34cf2d55d1b9e0168e78f99f031d1a5ae236d4a9186e451f299d73ff0cc76568ef905ff90f1eed0110fe3912d07ed17bec72aae59ef9823c34d94ac9ad7cb78d1f65f5c3012946d85f2e24e41393efccbb1c0a91977d4de9d854c83352e22cea694454a2dcd30c6113ea2bbed9826c3846608374173e31ee81373ad4287dbc8467e746d851badcfd74870e50bd29ef80a237ebda6a13755afc42f318d6a868472299256c19e2b8cca7dcf751bd5beef33d6a05b45829a391a3eafda4c723e87e48e5d7719eac5c7b43ef7106a547eefc7bcc27e642b99d1be9fbf3105a8c74f2cb09877df568d0df86a62b33a19239ee5a5b32c9ad15949fa620e8db7d26b4949a43dd81c84fd6702313110973edc0e95041c4a623b0e63d79f1b99fcd110309d3e524db9bb75189a708f6ee51f56b1d50bcf7e355e601d31340e9b5bb2a7be6e947f9e86acf862a1fc01e5362ef94f8026f64dd5ef0a8340366fd68be4c44fc9a3d146b54df786eb423fcc42b491d242e8802536dd0fc78f12c18d81657d2c46143cf3ff621b3b2f5dce5840e9ee0842a5408fb8088b8f86ef5039bb4492b3650821aa9a8885c496e17d0a4fcaa7a04a1fa195281010a0505b1334394850d1fd63b9a921cb3037b4da6d602ce6ac968244c12e6c6287339f8a1c28d0893c1df321957de8095de7df85053dc97dfdd18a17d0810084399abfdca241589d4bd1d1d4acae2ec87e708f1f0209ac4fccbcb7ee21f6e32249d3cbfaf903df68a554aac48c78c7a3933e7c3c67ea753fb40ed2dff252b408281f4207b3bb9c8e9fb2c7cc61fe862a78b6e62dbfadf3e494a7dc50a68872da53a24f92bde225f1be4ef4285e208e0d698c20afce7075d1ef5472803e67256ba87ae11df7dc064fcf71f6c420913d978a3fc8a74426a8bb24a30d5587b71a3ce4ea18ac450f1c9ac782208f4a6863d8d8bbfdefa5cf714fa22446d4b151d7ae510c25f7e504201271a6868bb1184115de658c836493fcbd78c2cc37694cd8ebc1e008d6e6dfe13e40c6029d52f330a2b36a40998a8d220ad11418b43d0067ae619a53eb5360560d3d053326dd91c4335ef81b952d1cf77eea3d1771f432a0e69e25571e4d358496ecc5171ecd2ffff8e0b4096f88a927309b002ae2c24a36f0c01660226b586166c3b611e54ed27d9aa0d93528c20a387f96bb4432f9013f69eedc64ec178621388c9f97d464a81e299d8a8e6aae3cb16a017db88fca47bb21c9fea16a38ae8eb5fefba1183928b2362968275a3e42c9be22641186d291266046cf2374c8158863b9ea9a22dbf89acb7193f61d15166c0bd68c6f87d063657ae4eccb37ed6ecd4701ec6810e8c5039cb1df0812ed663b91ff08adab076cc013c5c92586839c5cdecfba78dac7c23a2f589444b16890349d002ec61773f733feedce2a8ed82a630542fefb0eeaac07f2f4bea7d3b515d25fc74355ac8e9422b0933a23351738e214c31681f5251f47d64ddec2a0f44a688b1ea802719d648ed5294181f8ce5392933fe89823c9143627652b5ff6bb6001a3dbb17dcf3593e36567732a1b04ff96f636acf4d980cbafe2af66957cc6378ace5913ecad4c48a763932770ede8d547fa4c4be2cdb1d4fe8f2c44337f10e1cf85e4c3c315ebd1c6d515e69697b57ad88e2204298ea819dca741676823d1117a3926457ca28a85dabab783f59a3baba9538f30d9ed80b44a685dac53cbb1cffd0d301adae901be3684ec4befd9084d09d97abbd51bf6a6a40770ed04000a7620ed4e369dea7b65ff0149dcca2fed363aeeddd4ac3e8631b1f4c0629774a1671e2fd7d88a7efda0a19c80b546f0d78f5f2e7a78be7fd4aeda87d836f67d0955a0f986efb1c1c52b667f9c0bbbc72e393c9679123466e15d6ff955b3f78d75a5a41e05fa42d026e519a073ae0929461abb0c68413233b352c76d31702ac6f8fbf82a84a97f2a240d7d8ac72b8bc4a7cb8f861f46140ac78bad45ee21561e840753454b884fa578604b0e6b0c28d654fafa4b6063a3ad612ac8168d003a8ffc949685dd8946ff9d81922df7757283424e5e37bf1f9d272e489f708004d478cd17c49d8de71eba3746ede48118bc9dce003b2b2c30e4907e1333fcaf5c140f297c446bd93f01ce06a13a46b848d9843ea2485993de08e8843941b18b678b4d039b516785705ba24dea939229ec22b81c1c8eac674b8dee89b85ea4744","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
