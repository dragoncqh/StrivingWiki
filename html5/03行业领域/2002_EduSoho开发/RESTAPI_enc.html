<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d27c5e903dc6c9f0abc30c290bf6373dfbee4412f887d364c752f9c82810663810f1245001d48f3cecc89109a29e89d94fea6c64782316e40c7cb13241403e6a0ea5df8206c2f79ddb4aba254bc387c122f9221bd584918633f24896122820c6b75850597ea330de1021a8f3f128d7834feb4affdbcdec8b5936aba7a5aa4cadf28bfbe5d9317611c3ace38ee33e77a971051e9177f75de8119306c898b5075ca2f97e4c183f636fff356beea2940b7f64830be92818305cccfe353ed8278593e57e8ea50903a134e8af3506c714ef9815d639036e0b8f2d9099d54349f95c7f13eaea9d9eab4a500428591dea4f16037907989e161c8eff231d61fb1de8d7c1b44c281fa217572a74527883a24be59382e9db36e8c6cc84a439b7b45810049907e4d705b7a7ae27d15f6ab9fca58005fafb6de672f41f37db5b4b35a0314d5494d4fb25eafe3d747adac468c43d10f2b71b7212eeb7c5587915f569da40cfa7dde8014fd68e9818d1a4bde62f559afe92c1e96f3d6329df40781cac56058ab174302b54155ee063c0e5e48d069e817a534f2190c1637001bc9425813ae029c770c3cbaf60e26a31fc9b1e9daa16a5132967f6b8dfcb7b3389f37f7faae3f3dfeccdd039bf437eb22af74ee5846e8f867251a380817f107afe1283d9a28e2f2f7046f00cbe20772db310822fc8c6aedddd6018797845e61fb9a189ea15fdb15d15158f1932f6b2798c7f78e5dda2e06e434a5a7b541919e7ba91c8955ec2ae4bfefdbbc8b699940ac67a45a9ca8f189bfdf5865f41cd94c8cc51e6fc46bd634527609cb55b23185de35c21917d0cf60a43013bf1a91447fabac2900fac9ac427d841a5c00630e0e985827f76ffecbb373da188022f81e08c6aed8997f1035d503b209156d69af55737c49cd1ba19459f69d387b0b264c2a9534dd38da49112012d9b896f37995674d8f411f9641fc17a60204fae87d0747fc71fa3ab3d593103084ebd486e1757de02805c5a2c99354d75f7d0df89a774fc98bfaffa01f961d771c5b1d82eb4bc93bf3a2bc881f1812469e0ff1a046d6b7f0190ec6a7cc8b8cab93b60f414d2e55a26fea0e1b7963dab810df87eea62b9cab7ea8a656f97cbe22d2d05c7bc3d8edc69eebc924ee9dcf8f532a530a9b5ace87caa25109347e8248ff45ec29d6eadb5bd75ef884fbc5187cdc0cb07f9d09e21d95ede196c4bd4315f2f587785ac564d9f02e86d47edf84ba19c8da8f4f160a39634ca26cb7f128f0162e6204b058a4412e8e0f156ea9a7da95a8e69e2f904c64c0053aadcbc4123f29b5fadb56d4c0c0736a80093fd2a9254820cec1a17a7189ebc76fc3f3239e62bee03de9088eae7ed7114a5b75446cb13b7918021e414e4a561cb08d7f420126a6b2570f34d2e24a838f641119272ccd10b6ad25f1e42c2d1c3c5eefe414dcea49f63f677ed0c546defc4c668a2aeab24819918d2a84290347e81004011f9f82d9ffaf5fb4428f574235b18ceabf1f05c70c5da0a8025f84f08b90a324fab5c815349c7e7b67dba00d624178b37cc95e7bcff83cdd74c3005bc1594d0aef18c9b6a904fbbef6e8913f199b1f8fa9c35086922f766a203d032438c2a47df477ee523f5105793c5633f92e2f91d5aceaeb3b224b3bd9bc45fddeda85fd3a1b7e2941c747e09ea46e785b6ae56451316f5676dfa20eaa35d033a0f7c2b1d39a44de65edcd2111958df9a7aee19e42d1f2674fda6dffbe96263dcb31563d36363d47d4f746880670b8a681eb50b7cdc862e0b9a5a5d51d6546cd4d46337f468facc58a4f62c0be74c25e9e909e897a8f5d2d9e11c6dd1166034dc951fc30bf42b47fa975d144249f77f5d37d40fb834aab7633c0a3f741d1fb4af1f959b56a29a45cae3a72f8e2819d2218add1de636d95f60ebd1ff2ab952f3d83e0d581fa88368ba6a14e39a9b5c8837fc0d058ab7d0497896d26f407c23a4c2466bf8267936022f5690f38afd7507496b7e455437b9f5964a4bc8b65731dfb78e154a9e8b061758eb04be2a94730959d002e81737ca76911d36fa535797c7e3b6eb698a1d2e6688e5381555f6f8691415b980a819155899f9735eb80ad64a57854c9d99e38f487fed5943e560682892c21c5610ffcef8a1f78dd8e47f261fde9efadc4ee430ff82448da33f59b2976e5a5806e217cab11c44c4e3cc813c3f1792f09c662fcec35f24438e19e78fbc5b00f37cdf28b917f4a5350c001fb2e0cb7a83c3f16f657c62fb67e65553e0408a8b04a8f16e7a12cd884ea676f98619be3cbec524ca5a5ae471d979c529ae05a2ba9017d547e73d2004a735dcae22652e88b84d7cf5d250457c9dca4507990fa50c526e8fea99a6952211072c8b08f685e2e3826c3ac8bfae6a7cd98eea2ecb95b7bf9c3879e92588a793603ad5a02fed9a5b395ebfaa5dc845490d19b6728308db6834a175d9823f4388d320142e4edfbe6efcf81bb42bf707e80cc23b28e07673650bb8019ed7b37fd4f7606faf58883cd62bfeb7571a140fbefda09d0ac680cbd7d74205de4d044c16cf0835b215fc6b54d118e3e60f5eb2bebd32d42cdd1c397847fea99b4ddd65f25dce281c9d890772ee57a33c77b75cd773216d092eb610a9bdf413d95dfb868b3dc58cdd89055b5816d5ef9e8bfea1bef6a4ee4bfb063c5619483fad8ec5a4270fe4e89d2b40b2242b5b2c220f487fef0a303b9cb262716cd0b55e04ebae36739489235571fd142017e27aa1eed51c28d65121267722320066d8ae24f5bed09aa97a7eda2d4c59753bd24c1bc657066e886ce27f7f54695fbc6d9a15d4f27b5431877718d97d224c9b5ae89211f05b656c0fffca7d11dd65323c9fd675160aea2fdcf3c7927faa48d1363115ade7704d7f7c10bb516ed3edddef947607e58299cdbdf71fc0b41d7743bafdd97b6fd830b6dd029c41835d9af3ab4723f81f0f6c309037e86711daf3a2d0d1024a24045d74cbc6ca43fdb1d37709abb82af824c19e51b3349574e7cf0411f7d5771ab603f66d7cc9454fbf1094f835249efa825c77123282ac180918751ec50f8aa3d89a56f0d974053ca83500ad07f15035a53ccfdfbc99146f6bea4e61bd5a4b96ef254fe168efef384d4b38c977785757d2d10cfcc862811a53e4e30dafc3b3289a71450a51b6b494843cf82e10da60364de46c8c74e2fab1bde6756df41e736225a20b834d44f8e66e21fd87487ffa99bd625f19be5986049ffdcaee3748a334f159a880e2f4c0717d023966708eb45ac6070c3e9fa2042524e067f9ebd61c71452faf3880b65fa4d45c9a483931e7f2cc92a86ce86b9921f5ffaf31a4d2d399020856657e67c4834f689d1eec695cedbd6c3e0988a8361ecb3c263233d460653ac4f3651a515dc14c6bf8c26dfc7d4b2d6c17f2cefd87dc30b082590d0bfe73eca9ca831eca1efe324d0d22693c1afee9bf9a6a9444e6865f140ccea67aff53bb314f123ad1a74da02a68131ba1f78844200e684c68edeeaf359e29a82bcf16e85bb02fc5952db12a0f34785cdcc3adf10901aff99fc972dfef92f35868d4609324a7edf43651c8bb10fd73894c3c86c6556e265d15d4e993771631ad32a566ed5b2aeb91187cbc72d8dfbb6b60dc6adac1bb1d0afac3fea53b9bf3329e505e23be7e747b35e514644ce96ca190eac560341e0191aeb090d396cd7e76f6ed73142c83f5201ffe350b4f06d3102db43dc3885b4302cf5ca234a511dc20c432feb1259238d2eb9c5e00e720dafe2a1562759bef87d5d396a1e6fb9f8e3e5b36e69f312617e18c1a764377bd33f8ecbd434fd80b1a185291172a4d6f5cfe5c450a481d9354aa1b8d86dfdc3a3e13393dfc0c1da84dec2ab2bc5a333ccf90fb89447814ec6c76626a778cbbc101ff27ad9f265f34ee7100fbc39e6f821a76b0c2c07f8e1674054d58f3fb132ced32bf6bd51f730e06c661c7c65089c5971a138ff7d53f095f783428332f7302ab78df79c2b3562d77a029ae82bc85ef77f17834ee2f647922c8ba6836777e424f3ab86a640f16474e89dfe4720666df4da07b1eac2fd33370bc4cc4f5bb9e1470b14eb08ca3720e2aad6054896c85222c2eaaecf5a58b0aff370d7e2ea0587b269408a13729318501fe59128d745e9ed410c03a5f0ff8c7f44196be9b3536dfc8e71392d8b2964c19e68c64a1fa849e0051fc07d3f522d61624a17ff48b27a6f85988567c30bec703c95c8102897e9a9ca097c6b59abd1fcaeafbd5e3ee2ca7e3d26d9a252085057b1f41f945b854e8446794b7c4bd1f959f5c4dde335830d04aa38dfc0a1ef45242e41970cd446e3f99b615de93490d6a6c5d09d49b3c821bc7acd565812f74bd01a9691b5a43cd4cbbcade256f65df7b27677c02033dceac3af21e1eca4a008d3ccc97c849aeea85e9346c0faee280afb41b15a23f60b4141c9f05198c42f72f65131e036d9e34c5192ffd9608f9dbe9ff554f60bd5893a52fd3e42d686acdf604453eccacd1bad06942979082fc2f15d2c0e1e031919c69cfdbc861f56eb238b90248ef780da38f8c588388bdbc387aa8f6f893e0077db3386764ccca49498238300b04ea0760bab7cc8d5e6c2adcda03a2fbef68e3f4efb1791ca77526c45ac9268b08d8e9c1501b7ad4d88e042fd99f023b539c5dc03265caf47bf510e9fae997c36353b420f4f077a174a762accb924ed5f81fcac079768899365a293ed06c49ec311800d9c0ec13d9fc835f3f48ffa5c9c28e1b2dd4bf84045ca30a9a2775afb9927489e13ed1cdae74f89a3440dc34126ee8a3de02cb54b535f9507d0ba508a0f937a06d5b10768451904fc76ec3c231437d12e674ace8f76d7a3cc2a1c1ccbf301117d99738f7a5b51b784bb10eaed890af85f03061113d95ead88a0efcf4ee864f46b2198d3261bbe5670a489e89e9b278de652c7ade30c91f4b55c897dc5ae8e77c5dccd076584aa21c3073161c350f227bdcb9bcd737d2719512641e18079960eea9323d4bda56e5933565663aa708f6eb78db367fe2555e8f363cefd96d8690f8c150da541ca0079ccd59c689199a02e36870bbe6cf8bf625c3d6263175e68509499fe973cf8078cb8975fd99ea4a0c27a09d169792a283284c3937e280dd5f37667efcfe5206bd488f305c80262ddde78d851327998c89d88285ce7d2a0754e0a425e9ace77c59ebd6e8014c162a3f9942973db62cedd36a15cc373ee255e7ca87a7250dbafcf94c4702b9ffe6366b38ee6cac411af1b36e7e2b77061b8289e41854578783750a95ba38f6075bca3743e0e0c9fc8a72dc9ff3df5bb20a64aa906f7cac12bf6feb1a51377f2e55070b4a88acef411be5fa56356fad4635252947eab7929c93e4ca89b54d5b66af69e52c8e684a114060c8d5f0db67388aa654a18431a1f7ba1480e49c540f4e502b914d8695a272b145591e93658cea2c0a7ae342fccf3c5d775c787546d54e97e1d63b9904c93b1bdc4174539330621421871ea68e0cabec48d19e229535e1d8b9286c0d56c6eb5fb26fe17ca90e264e6060ea6e142327e5414ace130ab75935cc27a8da6ac45b5faf6bd91683d16f03db9a2cb26ef71540117d21ec9f27e6ee0ee247a4d07f152023c085cdadf086e0f56a57d35a388fcf6d552e8bc0e50bd2883b0366c487e86e260af668b8f13d9bf8b634d8066030e563e85013944151b637392a1adfd6698e3a62185db2b12709d40d33af5f96efbdca9b5730ed8ac1cdd2583a5852c0e0281db29ec5a7fb48a1aac183d4da0121dca0ec10b0e1b94c2fd99e122d4e8facfbb61f02a5ba77bd5203d82a185da972d99239569817345e68dd1f2622e3f53f6c763f69c53ac6815b2ee8363b1f45c99e5a9335f3f967e14ad0f8b5d9beb6a9cddc11c77dba23fb5b5352c01f22d1e8ee68a5448854d5a73764503969c276bafbcd9cfde3563296057705c8d05bd1c0c22287583e4b666b7ecf11b1d82cd4a3be12552182abb839b4d7d9a7f8e0c1b6a8c83aaac26ef91e91531ef0bb28028816d29adf5b81b9b594e417f766904d942a61881d61a15cbca1c387cb213a16395d42b5811d7ef14583e48f3fbe3844a529583bef6d6dba495717fa20845ccd60f25b9b329de24291d353a517984e92d89f998d0fa151730c994b2ffbd25cfef52adf96071bcfe2b9cc7d25a7f0f31bbd0ebcd200f7f4eeb8d03cc20b56b9a73876774905d247a4735dbb733e9ff8525064ada5270ce9cd2b473c2341b12b48db2ef0bb4c79e9e11e59b838060d51af21d860ae6533bbbe79ffcd15f7c3bec1738b92a59eefdf6ec4aa2b4f3887521e07ae356bf29ff14489872ee14df67f839e47a8f2a4f2733c389df060e3b10686ade026dd42a321ddf481a1c053e7136e42d245a48001dae9cab377ad0fe227a470e3d07743695c16e50657e5df69a2f95bac1340cdc1e740b9cdb0d7a76ac6859f5095ba5cfd7fe67227228c848ded3117cd9526f3d5e1f2c2a50a0967ea0773fcb9adc31d4961c091bda8049420898b0ab229dd50bf574b9d4b23076a11bed1069a1d5071bb42eeeb0bb2fb663a39b6a245481cead88284f2de7ead427cc395e3185b07baaf220869d5fee497b5a41497de59b2c32542b55c7e0e1436d322989a672a9c633fbf5acfc6cc2a05c7128215d5096768980f93d4fa6ba504487c1e9329ff7b7b83eed8b272f09398201635f69dca000b1ea89efc5caa133543f0ec9b7ed56a07dbe8a0f53d217eb4b55ab67c215651ab026647b4fda8163c06c4f4038bb767a42497293e9af7dbc7dceeb31f1d5be87cca52dc38eddbfb0238cfad2e477201ed13486b787c2235ec3d8942a53ce974ef9d85a6d7e837dbb96684375fcfedbafaaf959b91ef8685015d7133f23545035b5e36cf6406536598ede6d87df697688322cdcdf509ce40798d2b69c0432d4cdac70bfd090889abd7e177b7034cf90249d040c1571871fef7c5194fded9025ef5eec9b75495bb7b5696cb3576d45adea533b7fcf8406ad8eee5958fb745291a39c9dd6935b9cb91a1ea9a93972d6b2abf29247a1ed75b2d51b95dbd2267b2cb8dffce9ffb404c5755df40c357d24814e06588614bacfc7fa82c33829253ac9ee3fbd8d2d8d2c3784582ba115cbc16b56b5655deac6f766c7c0d1b7b0582779d97233fabaa7c941b50ecdb0cb004f7921239dc775ccdd84c4351033f0d9688f2d2bc9cc0dece9ae589e8f7ce5a6daff20463065133c49bda175c78ca2ab7fbaa6ccbd03a1596c17df0e806eddcb5fb13e44e7afaf720e2dc95c4cdc49a43c3b7d94851851e5e065212abf318db693c6a0c83dcb929fd6efe68bb01d426743ac7bfec6eaaaed3d698ad04a2c912ba2b9021b8575a5574cae151f7edb6b64d5eb32999c885202f4cb7ea53ee29c7b2ee5eec6c3ef1b7fc6a725c960b4a2810a750c2d14b80ccca55a10bfb901b7a373464e68c8e67979d13ac930e3cbbd1c1f646bc380dfa2adbe7b1e09b705597955bd5d89e5f79c8781e42b72d7b11ce1ad8f8173426eb9b3271e2618faf40c0bbf042e164bd1783095320325c7acf928bbe49f26c12b791e387842f4c7dd8c91850cae99f4fb1be902f9465cf0dba37ed2fa57cacb5a8b22805c3800052c2c9a9bfac441309604ed857bba35024b2f45875495f622cc18b2cd12636353aa946471f143703eb3edc6079f7d55961139d344794e5e3baf95efda117051f3fc976e3465f5640d65c39a49c45dd7fb35867014e7cef075cc970c8d86d1ee9553f89d6bae4490644f5e5390b9c4442ced22493d99fffa5cd34ef10f7cd653138e112baf8efe157b9a52142698b7de3373ddfad0abc6412cffecd308a0d643dfbca509d4019ad21eab6198b6081e502536dbb105cb4ea7a42d44ee797e2ed22414f4d3e55b59e0380f27aa191f664db55913bd27173725d11ccbfaff1fab4006240cdc3cdcd49640aad7c06a7e2227ace933675505da6e02f563b402e15d9c4f25e59fd2be93315f08f052bfe0532ff559db2813feea2a44cf86890ce11846c510785975e402a492ed6374cee0c9b2e54e393f758d1c00a37e7521cd9d9b850c068152ed999c9f6b803a6ee7f651abe251966414ea6ad942b28fcb453cd6d6b68590e58af919f05fefb3d61312f2efa6b0d4169f6697d96d134970a20c7936c57142ea21bd7f67dfcd313bf888ea45405f60fcf8d39bcee9c59192871d4a25db3dd3301554a8a723d2a02d835a757657ce9f70cecad2da20bb5fbf9a54318f26e27828ea14f6c6deda6011cf96f778cc90c99afec7a6e18e0789a6d05a16c50042c2e6a0178f3fc9f30073a526b3055254c0dbd1b0af5c76d9f0e8de85b848e5aa5d5eac2f4e5ae02677ad8ff6d6abcfeafd5f94bf01118bfc72f720d5b480fd52dd099f91d0509b6649361caa7030c81114b9381aa84652f9cf4d2cbf48e6f436c2d19ef9a58eedfbf2b1cf09a99a94671492a3c979dc726c1b0a47806b24220d522c393fa0e5039012068f100d823a6d971382a9e62b41cb9b70352319f2cb5de8f8a206df2f13d96f99a5fe5d91ed757d5b6651e5d8f0de10d2797e7b1a99b783a7266c7f7fedfc9eda6003cf44c68a561b59a2550e53b566c769aaa5e53656c46b74a3e3afea3e44b2af933b0afa6e4129cb8dfee382e2d1090417036d7aa2cd93622440eca797e6bc83805d94775c6ec13a2d92f7e37e379f9440dd7880a648c12b7f32210d9693a201ab5a40a45e78ae6957b0f627314b85f7c2e115394ea64dfa675885944ff1ee028f5650f8408f6c1b6af1d40216aab8db2b7aa20fb4373708651b7151c622535171ac85d5e3c119046a3fb9bfe076cd5d509f9dee02fc87fab1d94df2dd052a3288ffe891418bc3132d6cf56483fbad68b6a9412d7c43d9543234332896edb658f61094e9c954cdb2bb7bf614d7b35b0bba03ac274446cbf1cda60afd4d585c0d708260f25d191715102e2b265e7a0f8d6614312d39873aee863dc4c5adfa794145061f1a10cf66dc4fe97ec58b7cd41ab37a8180bb8472294c381bb5eee213f32476966ba72ee4d77b5d17a2fc7ff1420ecfa795041b8a794daaa10d07fd12ff3795cd500188a178f363c4bf2d4720419e69dbf25efaaf31bb5fff9221f276580e119dcbac9924c00928a418cd48ee97e6955bb323f32e7f04d2f02d66adf3bd1ada0d2ea07694689206e88fcf35e875ef51145fc2410afe76b882c51997bdb9fe93262439aedf3a7ce736a1d35bea2812b22bf34fd28fd0dc93c4bfb0b5b15b8354d5adf2434977a41a8086b61dc575568f2f5e1da74c41e01f39145c62d713a2285e5f946ab60b647c681e2198c9d548943018694ebe29ae7fabd6b0cb9fc9e5a7da48d6ceec15b07e61322f1f46e470328d7228eeb1cd74c5d519680b0c23f6e6e64df3c54b2e697effa7152c6cc90a5d749e5056d4677ce73091eb52ce68a7e4e81d703870bcc9a6f480fb403dd028959b7d996773157ce2c0b9cd09c19807a5ee104344d4120573ae5c8639c3ea28755c313d423b89478b0bebf1cff83929b64065e0807a7998997ecb1e8bd113b18c204c48d64a43abc922acfcd99613969129dc09624b2f74b8cef9d9f07667339b2a26d79e267c5c7042bd06a0b76c3724ca881d3569d70230585e6b626b28fbfaea602858a49e0e5b721a3b1ad198bce043e88c6ee9dbc802d76ef36c131b0398ef7ad7a61b8e71617f5501759b5fa42f6b9d53976d36f0b8c71d5093b3d3be58279478729a7ecab62c975c5b5865d47794442a4be029c7db9c2d86c5fce32b94546844928ae94eae3d08aa8de745228aa6d3935ab5b0a8df1e58cc5e93ae14a282eb44f646fd324305d027725bd60141fd0012d921a2022be28a0cea115bb57ead5ca8a20e2f01f3bb0f1a8094e52987439ae26eda568c0f486192ae3577591eb4a4a69afcb9b68814b2c4924b8fef85c27954b948876a299fd83d5e902400067ef86ab5c24d1a29efc230bdc89f00567111bc72ec8f831f3d6d84ed65c17dd1b9a687e82c8dc7a815183f8d7ad56b8c02d473e77d9e427ede735bac687beb5f9cedaa08f6e6240d1069592b91115925f54a1a3ee79863254e02cf8214910ca40f349af958049bc30e23b55513de2c0692dfcad896769af2cb4b081e5142b0d5fc5fea73b772d8583a5da97be98e204cb6ef389f86c6b8d0e23ba502d55e434c2d2469367ea5b157e79db347267209856b436d922158de13b747561f67131be07d70b800b2bd625eac1e7b692c9724372ea04e3524ca4b49265ef3b2998d16c7b4be6346a6b51039cb582bcb3d822258e9f38a82c533b80fa43d6d559c716d690610c7c46f618b8b7dc3f0c129053aa0c1d0f10529ff5b89dc6920fff7059f6101194bdae94ae4124fca0fefc8e3587e79ec33f3e039c82d48ba18e3bd6042008988ddfa23d344e80bdbaae08db797eb3fad4da937961d9902d76f553acd546563f860040b19d9b66b763893fb299a979ffca329209e80400efffec3b24abbd81baf39ec596874555c8b7bc8562d5371d546ff605706eaa27edc6b5a4f0845243fe0c66b136f61ee4ef245fc3affc3ed81c7ba878dcf037131effaf1b14f44c37cd3fef3d6b03d000a10bb52f62d195bf9fbf80b09abef510875b82a7ebf9c27d5c0fb608a76b3e189c87d5d48abe02a24b04d8c4f889e63b5a81da33ef8db25b832eb0244780f5b1cda97a9b94a70e5b590733d3f8046e575eb150d6ce4695514e1807b03a25df2844ab32bc1e01069f15613f7ccbdad9419d0aef2151581aa069a5029596d4ad38312ca5a723b13e2edd55c862d4bce35830e0731e138cf2f84d920712d59ffa3d8bfa36c0a2d15ed81583b03145c4b7dee036af1a43b2fa4c11aa87587763482322017b68ddd9bb23c65ba4dd3d12c361f6a4047df1f77a0a39aad1ebca94e0cd7355d53f7ff10e3ff5a05aece8d35235524aaefb57b8d80d35a708d2cb37a2a52c38575d81b9b568b78767dd55c2b9d2d3f3e37c5e1ac8095fc712d6c54a2a730f4b8698aaeaf9edf868e4b6972c74d8b73520e4f80d65eac2171ece2a97885b6a6b993078d29520021309b314f4bd31e1464c88952835ad2fa0d2fbc6583011ae7a1b29d027c0033c7598a129a4dfc2384e492d33fd815c83be4856f94f42c5f916c85ee154366844a7e134c041f5c1bfb20ef384c3fcd4317e8b9347693b42c07d33dda8d75546201a94b766e7dddb4f9c531c5a65327e4fd977b1ea140e0546b471c8e6d3832c98380b34f9ba7f9a91c713fd77f8283392670bce0b3ca73006a8e5743ef5a52713362d55813702302ae76c318dd674716199d17bacdc052f61913e918f197de81468b8db2e36281f075d33232526fe8a848c3e493f8515ef0246c5e80b354f4bb27b918a36b9a5dd78aff47d51365787bd9434facaef0fc5749e4e1d6e96ddb6833f15e32c1ffdfa3036af4faf285364a9a33ea72c0ead3debda3ac56ee68d58a82ce4a5b145264495c7fc4079a052e79ac5c22dd166f6721393a7d912e08b49651266c5275eda1ff7a31d8203c0304516e3fe8378c3b826b42d8a85084dab8c8573abe462905a31e86fba77a7f6ed78b85009a41370b1b7faa8a8cd734d119e26526b0aee1476479c0603de240fbdd4404011ee21cbd6828dded30877c99851f980d30fbbdd57ea474a392e9903b7c3f518e083f6096d72e8f86ff4469ddc83f13881aa8d0e2d8286d449160b19223d9ce8be6a497ea974eecbc9fa17d5071169e42a6b8f252c367f58da722d595efd12d9eb85d90896f9225892a883989bd4959d0a7c0b2bd12cd08d71796b5204f6d1da9aeca699c0d41be6781b7d76c5ed694f527a727e25e8e70e0080256a85c84afb455ac959071af9910c283d1e0e90377eeedb50044ea9a171d036b91f721ed5e114af5d867456016be026d5e7693262219fb546c50bcdda52477a9bacfea20da2cfc8280f6a91c7a2c4377ec75f2e86b3e5637ecdf8015b033accd6362a62afa7e3900f3ba760db5ba1ae753e07ea67fccdcbada6cbea5e90b08181655f8a21bcd8562ab8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
