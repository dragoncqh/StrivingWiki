<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff306df195c68f9a515de80a6f23e9955b3a47fe9d7b0c38bcce0df80327fa62f29c5e9f1a1fcbeee9fb446a2acf5fcd32e88ebd2732fe7ac3e083fa6bfd8118c3d8d341f525951c6d58b4629ca09a9d44567ee889650aa0ce37075aaf26cd6ab3c7682a09fb58b0ed1c4bb2c85c675c18a8e6e4da21a9a522410643e2dea917535b831b2c55f1039c7ffac693e8c6b4ad1f5674ecc6c8e9a2741981a7f9905b265d1944f9552e66af60aa8c20f9cc3a357a3d655db6181a3476b08b9c23525d7e905fe40004b1c4baad5603f65a08f3bfbce593d7a03ff26ffa71aaee30336af5fd397b609eeca3ecc595e0a45579967f8e6c2a64725ba87550cb9e60cf75fa1d072ee505133d08ea569d3e009f3f7f245001e5abeb5a33a1392bf50e5027226dff72f953a49835b9397d180de4e3f9186a9b0647ae6cedb54f54d8a510c1b0c5ec17cc7122fdb5098df7556c1428148d354963f591980b4468db2ba0c2d63f910fb47055bb587c715e957a7517d25a6cccc8bfeb9351c9e64aa74f31af90d272e4cf2d8e3408afc76ab49668b807200e4d739cb8a918b9e5106ca82772700e5fa06a63cb46ad3a44c22d433254d78cb990f11cb94253ebfa24014c66e32f8ede0a847ad5f0865dcb9219f36c0da8c3a511563e24d193a23277b19e30966f377b5fb4b68a6764baabbcb0dfa9c01fc92179153e8c03107ff6405f72b7e25030134fadd7d1b1aa194788a5dd1df4897bf162a42434ed671bbc743288369bf69ea0502f272edba4c71fab572a724638b8a34a58519125c28f104037015506716b2dfaa92773fee752ae48496853c03a63ea59811ad9d1a126e22111d460a1f077f219a92d4581587d26226863172b8fb04b6b7fd24376f31778a1193ee8e8938887a0eefc51264660b7530dae59f30d930be2558b41894f4f99f14a18ef4bade45b03fe793c6e206cee703a5f1e25d6856e2ce2207eb3857eaf82245b96bf08bf137ed253027efb061c9f437aba4d49f4d45c40583d2fea0063d9e0e727be57cb09c9fc5df22bcbf597a5886597329f294e9585c67b3b18593e1be3aacce5c689267cac32e011ef0ed17b3ec8d12579afe5ef210b2e14328f8c34297bf22b6cc3d7eb128c7ebcf4b2584d3f2a0188f93279d52d14fe48da129b363cafd5b68e6cc6f2743b1503da3e4339830bbbf717441634cdc480dc1d2b10253e5db1a96e92e738701c5c5024541840cf70f492476b1db2e265d3d40dabedfb55eb3b90172f51312d46f9a7c0ee14261b2982c105a0a11bbf135cc9d07200cbb562df8f805562da1156a8b0cffb1dfff601c6a7fb01b7fa5fa22d6734a4258744936f7228c42929c6bdd65a1b3eb9a3f9f7ed0e64d5db70a90535dabb82ac65d383811f677ab1cf0e7a00d63e8ca84a8c4843574747562dc42e45c03e742e5c102d9e0dd6cd60dc2eaa1a553e45e73856d670c3f9ae7441d9e60b140597c4df1b62f08a20386812c7b632dc3c6ecd45b1f2933a4b578581d642eb9e3a9544c50faf405d5d86908ccd64417f64273693bca53a69967031fe8605d2b0cf8fe6eae2ccf6a43f8e1666ca575129566af6794a7e2522e1fb7b2d19eacb469fd73f5a7ede02954f504f0a0057ba81cbf3be321e4d1aa2965e6598ced7e57e48108449d26e7dbcaa61d169831215594f4043180e37c61da0c1fbaa89c88d872aea69f76f1044a0aa0354349006fdbe322910eec4e13a3c2b5d700910e4488d663570f88e9842343f62f534a7154cfad5bc4ef1d65992b5eacd1e14e3194183e92f8824fb0127e65f9c834a6c2043399bea9646a765df39c8839c803e3f222d535529683d8a629ddf2bab32633a0e40772bc707436cce32c9648e01c7f04cca7ff87e29c9d128ef4dbe0c707b8e1f257bdfb43a482033fd9ffc76ba47da2433f0408648b579fdc025bfbe3e21365c3f4829c8e03dbbbd300abfdb8cc42f06a926cdfc14911d8ca7c1cb4022eaa42ba81eff03e1b0c6b3c9d0bca4dda33fb15c89d29a9d76c1754cd2c12ceb5b9aa1720f4337329b60c63a9611d9c16668dca331274074fddec2544b6f3e71fcc4949d1319b2e2fe48116b1eff871c4ad2b3db4684579787f019748230161ecdddff7ca48e46c7dbace41683b61f38208041d8b159e1072a3816bc3820168b896fb79c67eb50c977c76a313da569e44c92f4ed4da3c7813d33093a9725350010c23f54b0f9dd8220927d328488c4ce8ada57c7d08b9a47d4bf160163a8487cdc5642a0ddcf13aa868e55938f5b76be5ebbddc3e3dbf6f2222d55e8bdde608c9f4f06894bc62af418393ecee5fb644610e11607fbe55f351c5a8a51c3be529c3dd66c4150aa52c66c7923f24d8c69ed30fd41c15717661ef61826c1a3ec2d2eb9dabc6179b54c9b0588e8d91d93178a9e1335f42bd5227b4ae300957f5fda9f453e0a9c661ccfe3f6d6c3ba8dd2258d2e7d42a36eb949d723aa659f6844303a6c4637bc86310f9a1ad1c92daa376c5689fa22663fdd7a6a201fe59289ef9adff82f42342478236b87b0a91279eb3bd71b5dd0cbdae7f1f141d3666711f02d02b1f367fe4389785489ceecb15bf8ff605124e1fb2f1d2d1f89473e52d12edece3467acb9183799f6f3dd7b5b67a729d97af0696c4acc820554bb816026322223c43aeb4aaef61b78fcd0251c6cab0de9494bf4c7af6e807b1b0a126042ef70ff40d122eebb43f2f3826f2c03f63bcc83caad63384a8c76fa8e4cc160d0e3fe4715de45301bc06c04e86ef3d897fcaa60e59aaf8446bb752ec06d8a36c4b0039f5f38dcff563f0317646bb239c52e5af9defa876acda581095c43b919772d658741ec81f4c1d15e63f5cca2dab0a282c1a3a8f4193b347ab791ad2aee58723d198bda75834da36e1bf209879d325d82da02924f0e788758ddecd7de64b5e5123dfb5aaa1e7328860eed12e9704a1b64c40a61581b2ce02d860ca43f0c43b85bec57c8528bd1c7ff95eb2d0e01af868eeaf7fb42ae835bd082fd94dd156d2a2b63577d55a726cdad262240dca1f8b6c18036db7e9c75fdbac0823b78a77819e94107963d9354afbaff1b861454c7740f4a968274ae1bbe82717a8d61af192127a4df9344267b2f3cabd48f326c406429ae4316e4f6a6bc395c61dd11c914490c1e41fbe7db2d6ef5572350e7cd8791fa4215d9162cfb247c631b45944f3b3e25d6fe75b8e8afc399c9c28fedb6dfd8458e6c9182125aa57dd63bf40554591be37836b85e31e8b9d4f14c7d0faafbe3a4fd52f2773bfc43a9ed98c88660c63da9eb8cf4e49b3a569f2ac06e8d15052329e91c33ce97703688426695076ae56d4086188f1414b189bf3e8c66201ae714a8ef51df54f7858d8b3fc599962d6e39aa1117598ce62fc6819045993941e78c9a46ddeea1d54c3091a746207f193fde932b93c05523a4cfae5d195b8dd3dd36f970b87137acbb39532b46b21332e2e6152fa2d13a963fb23ee52bd2461ea34114cfef09e10de6277c3f93124a9605b035513e82e8a0d009cbea7534c70fdce759c4d5183c1ba61bfbb08f76a4bab4c96d02ed5b2e39984c2e8ca255b6b744c62c71d34e56dd6d32525adcba0b315053769d3c633e3d8979ca398fce596aacae0a20bf0a17fa16f35f80233362cc8d5864ca5f5329861248b1c7906d5e4fce431f7d97fdbfa18ddd601d9b74f4b04c519e86309e591bd1484baaaf76024e530dbdd735b9d2d084f96d3bb217f8e297f4569922578471a2235968fdac30059006f8aa689a2b2cf84a6322e08a5d4316286e9ea9d3f4bebaec9b97307fdff6ee60abdb39698256c8ef9e4c4ba44a50cf4d46fd5d195f49b77c873483af34759909e0ca72a46ae2b486e3e9228496897e6e59474dcea873f0f9796faa2bcea4de97b68d4f7a6636fc05db3ae3e51c209364d90d225d0974c8687dbd0cfc7ac528b037fe5c3125298d7630f843e9a35b4acf24781f049d046acfb9d9703c3f0ce09cd744bef67c7851d62574c80b63b484cf3f247f1a123bd1a087b2f89eef534f79bb0966b9911ad5ec1b01fba2b46e05f9f8216111681552099f8404f4a123579c80cfe2e81e5e782104b2f3b84be36d24b1ea6e83c011ee195aa76b5b65725c438d6c9096f48eb7e5a8e7b6e7364e3155af41c87e227f0611f2f1432fb9d02e28bd8c3db3d4b2f26b58161f6650e7a5dd97c4472f6342fe5eac863847f5ad26278f984ebac5ba9e12e060fa79a4cb273edc7252111548bcfc92667e7ca347fb8e2b65841deb8e6e03e94131174b85ea3e10be400bacd5fb95e3f3ab9597572a2af9ae45078d3f6df378d1eb87ba6820e0f32d898dadd7d509a4f30d2771255500bd5a316ea6278b146bfa5be7829bcd83979380430843662240de16d99a5f198513dd2f8c07234c607011eeccf9061196c961054d17a988994f6deeee2f24cc970ebe21fcac04d68880d04703368a10ca6ed88e35ff33ee494f9d35372aa6b16fdbb96ea0433f4de6649af11aeb54f79e461051215daed07313fa72893316eb7a40f8444adcc38181c7d29a40ab47b0ffc66d766fc350a7fe509060a98a8027c0e85de10b2ab44ab20cf6c2a0fdb3415c5e8ce0676d943ba7650d637a840c82ff3777cc3c23f5dadde2942147de689a1219d8f9c65916ffacef75eca3a9d8135839937ebff9fe805b8c78cc7fda3bb1e429a72245326481adc79272549eb0ffad638dbac6c712f601f80815af2a1522041d93be1d04894481a703561b98ed74048f6487c3581a47635ac843e00bcca4a62b50d6d5df70499a4370a3f5e305d43ad26860f1b915f78b9ddf5f8db5855b1738e8e40e06d13ddb4105245819a346721c8b1ce68d3493a294cfce1cff67d1fcded4f32471a9b1f17fe4a8a7f68d455582809f206c57a6dd7472159259f5bdba76c95237bb0f2013bae17757f754e63946722709001399b4a2f74b0a9e0c7ad930db36173baf4069f014c550cb906cb648f436a98135b8cb377230f65fa1184d53c5d5e900ebc31d330485b8a305a393ff1b8af0a7ec0dfd3ae58109373140456e689a7d6049d2b50877760963fb72b279d276ab950395060b466e0ea81b21e23da019c3dd26a451260bd406f3163300ca1bfbf8ae82023ee8ab258ba07331127ff31af900ad6486f5589ccc4b7c65f81064dcae3a9798d6e5de85f94ae625a3113fbccce14098e1828ac0dcf22b261660693affd68643e862affd77ecd09f9d2694e571aae268bb951db02e57d3e70a3f8e18b06dec4ca36b44a94cae936eb224fd3d0ee61de8fd311debf83cad49a897bd7fa6772d1b9ec95723bb9e7f3bea4789a96965c6baa9369d7587500e6f14199a55384fa9fbdc0a312860e505064f6ef8e15bfa37f4e0d3313fb69fe60181b6589d02359f2ac92837cd5f1fb4c79f3cc46dde4f69d9e10527dcd1f94139107d3d43e08a1ecda70f65f764e3ed553be0130110dc66d59cfa85ff5a9c50e6a28a33884cc8721b06802acd8920fbc857073b43dfe308f762c5e5cbd882625f9f0a99fd573b863f869584a26e40f8c33829d7c7f10bcb8ebccd722031cc7b60a9460a21d3af9d2bde78b271117a70813709232ed3d0d55e95e16bdfdd4fd5c8407aca4450cd2fed8daf2f765ae0b2c15a106b755647de6b0ea8a9d63befa68039c5f755699b698af121a9a5b695af9602246850355ea4d9776acdc6a823edad63912cf4324d7dcc6063db856e24ed89320ba0880185f04863cebb4de06f1fe33d88230d737fc62cdb9c06650050f307dd577e3bbe3776058913728b998bfd83a09eaf56f98aaf0bca55debbe2e619f5e11ddcc2df69dd779b6cbfefd3446f96a40d3a93f449467d1f694f291fc00108bd0bcd5355710103bd3e09ca1c9cf39358b9d9a23be834b713bbc6cc3f32e5a00a76ae41d90af6494413aa7ec4bce019b278f1108e7059d68a6ea4aad5b9034589dbf537b09a027a6dfd38bcac9f59ccb49418a2e4f685717077f76a0496de81357a54b354ec60be168af61d73d06a4b9aa52985afd6ac06e2b279a7ff4b09f657c06a004ac57a859b7ce0586d9ab56a36b7226f2a58f49d02470b60598577ee7f8261cfd33f21a6a77cf5f6e8df0d0e8c656f1331f79ddf3837cece5b452adaaae231e71b4a972bdc8240b2c004a945dba62cd135105713e29ca54ae38ea4f1a1663c1b811ada421b2c97a1d0c9ba50594a141c41addc47886e516041b8118bf5e23996b0785eb7bf5b9ab0bd1e2e7a7e254ad08787c01ed512412440aae623b57095916224a5eed3592317e716c9963ba42b3d4c5a441013b5d122f96a83162d139a93f4c31858f3d05c6abf9e8278c66fa4c60c2a92e49f92ea02c1ee712e842061561e21dcfb7dc2b66bbc6172818bcec22abd973ed9067d63f7ea47b50880ae26ba1a8d9cd8c706ce1c62782471fb8236eda121796e5d3fb2d5c468f2c1c065249bbe9945d9c90a063e116af9295e60a9b6e38a05a286e146ba74a42541de6d9b498f8bf22639dc35cceb796da40cc63c88fc0fa55790e2107a3736765a81213c8d04c000001c85b6cabba3a6f11c8d8062022d3d330f3c5e634de3dea1e38b7e8a14056258d6944d5dac33f378b63a1c1f4e8b089a62411661bbe0683b7964e3547207329d313c2c3d660f1e7e8c15524a858102e9340c8973211076c84b68063353dd96ffc901934408d687140c87e3e23533f6ca850297218429bb133a81fa229faa5206cadcbe3b03ea2b141a863e9b4c04a61ac21df23f9c928f44b39a512418031dad581634798b38038f21d9c6022ee3138267aff0c80289209855481a2094204a6bfea8a4dc08f6c1ec8e6e3f1c0f5b8866333577f867c09dc0e333419aaf416d10685e1e7a3a4510b7b8752f0f8746d3f5d8b40a21ad491ecb0362d1274527adb9cb350d9275d3e2b69986aa9a95fd0d299b4ec5e3e3e0f60b1e017d29dbf22d890965f403ec3c3f556c7b190eef8913293e57562a6b952b97043c60588e86cc57b1e434b86ad88bd5bda215513ac09f550f4d5c72f95a84909584faea5c2c9c5c76e09f6b14e5437a1dde2421b793f23c52cc9717e7d61185391042e8d5c5dabc69c422e5fe56f39fc5bc0581071b1046450889368ab5d5bc1ee3c021ad86e1d8b3df6525041064b8e6d9fa74900f199183c1cbe5cac819677ed3dcc99b8fb47361ed1bc19663b213a070ffbbeb046d6abf7458b2ef746636e32cdceccfe7e015e2669e72b5c92d2e0880aab10f1783e960e900224e1db5fd5620f4bc95ee74de23bc6687cb9ed0dd939b15502f7f31c574488b27e72078b0bf451ab087399bc054736f43216ec7f965171a4f0849ae4e4e8f9ff616c4440fed1a71288ccb754c46b7e04742e5936ae8f3ff1848bce2cfb23bedc266c296748e1e32b65660e5b997446249290471548575efa47a56950b4017ccec89998a3d719cca95f7c391db89e5651ea41ec34fed996ead1c5a966f8c3e250ecc0231e0ee879d747b87d89b127e0026530d78680f79d1cd750c3877e2da14ecdde848bf557fcd8d1d3af8018490ddfe93d0ad808491a40886c75abfa27fac2ef38a129fdf94852a23e4940de05c22c7521e0dd0a86cff2c13dde4a22fc17585894c8ced1e8e09e1f2a20850da3a82e4bce0c25f73cd6367761fae40e4ea2f2aeede8aac716603736d0e8bc03b234f8a3fd82f7f79483ff7f80414ae63aff129762cad3364273d145d627f620cf4f958b3690d6839f6c3a5a4e05857a4ae37dfa1bcec810fff28ebf25bd265a8294e34c0f3830fd12a92d470e7ab707ee6deb11fea791748e5682347613c734f42e6ab9166c0d96dd67f0e080443ba3e5b64bf978e6854158ecfd593b8a5da3c682317185de113a3491a05445b1f7688fa053fc362a7fbd1f3a04e377f7a565e30cd945127356bd3fbdda1d0772178477d92c5e1c2edaf295105144272c57e8436237dd834bd6095851f10f369cc0f4906c349045e3acd69bc200954352af0e2d2426e305030ec2aee394f7763e2861b2ecf236600004f74d95c09e846f79e2a687a606c3d344352652f1a98d770b8d736c5dbaa8706b3542d4d6eda6c8b8c04820331ceea8afc7791ef689fc5dfdd045b727f6d21bd7f8b3c217f21f1f40fa54b617f80996590c84b74d9259afb269aff2c7f073e16876b6d967ce56310be2c9cbe651bd176860b54b2a5990c13eb56913c787b64c24027a83858da58718294c83d89e9986cb2c49b8bc4daf0f062c218b0a86c300792b92be0890073a8c79e64dcdf8449dbf0e1322be9bf5a36bc92c6effe6a40553a332cf9bf079fd9dc6ba9886fff8969d1e972adde4e162d25568b478bd4d05eaab39f4778e41108197826d22a7982d7492c081116cdc7e1bdc3f210fae31f11e8ca090419b749226ac210664b36834f3cfebfeb440c5d6844ccf82ad18045a4e43bd539362493064722c8e710c17a127a92d419c8e8525fc1adef04aeaf7ef420d93c9ba70770220b70cc7685c9fb56c5c506855032fdbc4ca3876992480f48cb1d135ea81b03ddb91c246d7479c699cfb6eb02b9bcea337e9ff62c6b8322be54509caad02a215f48f945efb0c6cb74aace152683f92e54c66d27ba513706203025da9ce3abc8f5bf52971842caf433b9b9a97bd0cb8ff02ecec3545140ab1b9fe8d11610b24985f8c5161055bf2b1152549f9f22985055301bdf5599453742ecfe58ae3dcc116b238f956d7dc2d7419a5c678e7d47aeaf279ac509fdda2a7476ff710be26bce87198012f051c53dfeb37a1e972c8d67310cec91978c4ca1c30ad1de7ebc0673b0a1262194eaa9dba98a1358f7c6e6e24522236d270f051edd9cc5cf7c68f56126b37e62f91c8f5bc5cf5d81a993640d9df35e4868b778644c45548bf598757f9243b08bc281b6ad950524921e0d41c29f2caa9acf6ba0408f5a56fb71a8119973732ec2e61d364b09985bce1a37951b4d2414ff3100a1e64740a43f52b94febabf87fcc56db1346e90d14dc8474422366f07188dc3d83a8af2bc13ae532f6e8141be84a79b98f656d79f93f2294f9022c278a716918286b30f4e0215ba8b27562991fb9910de2f652712961cd8b2d8e11cacef4556e1f9cfa8c6acee606e2c986e1c6474bd297e5e03d529018004f40460ab7cbd7c12aa005fdc8dcb9e6f2cd4ec4282a6ea3a2777ecd91cf474ba682f507f0417c463491adfb458184d828906ed37adefeed131b0a822a60021f2377ac7e37d34d609dc92daf416266403e7ee7e06706aa609ae2fe35a91c6e2ddbb24fb5aa42f2730c336fd29f975115eda4705a225ec7d7debeb79aac0dbbb6cbf8b30c9053af634ed8a60d1c6c80dd56b9cb7343bfff095301f910074ce4af076af38a281c9d8b9276a41a74afedef389c11d0216937b65921cadfc99a0043c9e0929ce9cd9e7e61f71801793ba7d0fadc7c1f0d6bcb8d95a0cc998e790726ece0d36d4fe9fbc3dc372a2db5ab9a430c9e21376a0a0ef7a2bed6df593c172bd3e9d37d314a19413769c392f0c698e001f4fba576a37ee2b4a671a46fb50e05ffc4e814a316acec04336ca292058e5a1875d913e532a023df3cfd217c3c57f6d5d4058a64bc9525e19036fc4fa8625c0b344d8375f378c54cd9b10d0b01b997d72ee35f71e7c031bd0431b681c3945a05b55b64546af750d1f9bc9a339d3d4c871140afc9ad3e9b454e0e2c5306b3260e04b9154e48a18fe9a7cdaae5128eb107a7fb3d812a937b46ec6c4f01de9c97f0815dc48bfb3be6d634e6b4b3ed6e82d55abca7d9b1b42d74c7247cfd8dde4a86852150f392f8b7c4ebdcf879dcbd7961f08077ea5ed16f737edb76531d7da53b780a17c284d93301ad1dfec0eeaaa6c08f5115920178f3d949f1410c0624c643b34329f5f9ef1063ba5044591fc902eda0a794671703415b4208438d5e81a5e5877bc12d8c4040a8b3140b0c36bfd3d2e9a353c83da5cb421db25ce518018b20b958f2fb878fbd74017d9d59ab44c754f0534fc7f36756f3087d63d9a5c56f86103d1c6a449ad5cc7fb2d4d44e0f4672115c5ee18637b97c3a39f91092302849f797b837e5797ed476d0345bf76de158d524dc36aec261b4dae96b809d7a9922aedadb93d28daa7aa2aa6ee538300b45ee5d96c8bfcf4f9e1fc4486c61213492d803d15272ad37c9a950dbfdc84cfafe5069ca2eee54c3139fa266bc821306611a2e77023460197bfc77aa45293e8babcb791dce63423c29e359f35d3a210b675736de3c7041ed47c443101f7f9a36d6f8db4e1a030d4267af90d0be424d5f051ee3edb1155b4c8a0e994f6448b0f81f38b9c8287cd3a178c5a94d59c30e6aaa78838a628b9a6b9714ab3cb805ac6adfa252863c7c6dfc33d397aef76b766fc9b071a2073b2d07122ee940a0a5f3b9dcb672f1487db0ce27867f41afe7eb386b10f61d352e1d96a9d1da4a99e285f2ece15581174209dcc7be42dfcba9fbd72e352f3bb022b9946c7d0686d2e2eae703783ddadb6dddc5b34bf87d78c96c702679e0f3fe8baf0c44b25dc4096556ad95b85b496a573efe02641437f81669c572a46cbc8493af5c1cae714e0b3ecac5e3bec80c33c874ed47f7f816e39b6cf9106a08905e0974751417935331ff2702f606fe260a5fddaa95654efd19cea04c177d77200250d00f05db0f55195747c48bb3a94157a7df696be7af6780af83a6d4da062d7b2ff0ab0a2779d752c4ff16fc614fe678f4edb07f0d29736ba6d8417861412757349e4d5f202a6af85f3a78ba507af266ae9d0c19341a548e2a11c9e09ea3b78b30b8abc4027babddfea0e374381e6a0fcb688c0ae78a0cba2cf6d89309fe0adaaac7fea1a1279c0594313b12b41b867db799e03932f1648f9d9572cdcbd7bd85f249c12fd06139e09747f44b3fff12383ddb9d884204207b5de959442f255c44d773b71434bfab390c0863a01232434b51be20a907354b850f33fe158e3dfa90147a54ad586d41b195d21a3d78d2d13c0f49e64bc32da75438bef546f1e3f8e6eec7620eda0c43574377dc9a0bdb0f4b7bc4fbfa0e271feea0edfa438dc586141d0300f27ab5754366939fd6c2fa045bf8f122f5064c571bf7213600a87b0eddbf83af372a8a3b77e3d91fe166e37ef18ec2cead8ad3760822abbebac8c08c6f2c8ea6fdf4aabfb0259c21dc965303f5f3ab9c8dbbed64b549465bfca6b523ad5e5dc25b3cbb60e1e1ea675b413c469a0325d9afef188192e5df8d5dd77e5b3049e7e884d5e91542041629728dd44c7c3da962dfd44778598afecb553655e99a8b4fd6430a4172f9573286fbe525b1dd26eee388a95d6d1ffd3079142da99047f71836bdf63b428d488a36a0ee881fbc03d23d25be7d2b405c707e059034b6a573bf5330aebe4175bf99fa8bb4e3e789c42bde4fcb5e2e92d72f027d0ee1b02aec98c24cf905a390bc557a5f9f9b0873f140697ea40cb678ba0f63de79c16308d613cc25a74c4d17f33f26079165e91e1c5c192f2e2221ccef5399f1ecd155e8280469edd1165902b788eb912ccd43011137bd465946c6e2ea9592db71741ebd9ba34a0eacf31d3363644bd3055baf4a1c3a9e084f774e347f3dc2b23b391e79e7c764cee2979bc6e2ff04a9612798968a5f88a60a80c204765a61e566ef783862c85902064076632e00cbd2c91123a451e21214d8c7e9f887dbd9b99443588598718b10557ef8165b99272e017133ca5c05c06111607ad810011d8b892562541cbbb09db7e1a54ab65bc13b7b90703632610fa3b9d32c829e348f4d5a7829fd30ccb8817f5795b0cc5410084a470afdd2720982008dc4d07b75b3191b265dc68f7e2685da34c9f0737061439de1e8a56ab4e0a2f847802633293cba31a6d947972c31482c8c7cd7e515330fc6fa3af05d9bc6e4699e15001e891e9428d18d850916c3c3a0bf6979658482678868242c2412338fbdc2c32a5d8d7a3aa0d572d72b1337ef22a2145c97ea1bded53e663490634fd03390579ac4b3acab364b2310795e75eb248f09acf78fe3e776dc07858474ef57ee14870e1cc2bbe6c7374dd6022e873c0c17eeaa49f049ca22b10d68936badc5c0786ccd4d09113e6a256a6c91e7b27edd8efad3d83d7a139067cd4e78e96bf6a3526135248f4bd97c2222d551f683609c0cdce5b8fcfb25bf4267e499733da7b26412a40b28e6095902493906a6e88610b79488bb5b9b34f1841f22e34f3434641490811b30bc764e146fc0de88716eff5cfecbdcc5fe3ee8cca5e8adc749c3ac193fa02843d80daecff8f83dc748f47c7ffc637932c301a1efe4e740b2033ddd02027043f7429397c15c9ec017a63fe7028663d2c858c929c03af9342ea66ee3726a4264d9ffebe21a1387b2096f7f7e698296f929b074749094c86eb7a3633c65e1f43f49e3b45a15fcd79213ae29e30f88e1352e439b290476c912e7565c2561e1b14a6eed61c90cab9e71321cb36feeaf1c05ceea52cd4f1213a8741919a1178e81ac34193e767dc06bf0582cd52a1133bb9d2b8a5261629c8e6e8a9701f853ddb63e767117c53882c3154ed75a3a99c26e9d257f49cf6081ed333e9bdc69ca7f14c8b3a3e29657cea22d7d0c8cddbf92ea6d9f7a3f7de5055d642d240c52e83cf056ac70d22e103c44c077cfd5932e994b16b1dcb0b4a2a47e0be43e377d2b857df6b638848c6964327c723a2e87c7e6abcd6f4ed42847a3ca015d53420170914a9dcb01d7c09052d694b5f48c0d3bdc3c900f536ffa64accf951f776b58e6e88fdecd32d3ab7599386cdf6bc542d107b29d558cd3d7d7108d308efa914912b556808ac5ac68541b72292e1f52ced8bf4c9d4fa3b99a6b6f49d3d0776efa1e545c702ee7e2c130908bc516e890233377f4d62905cb62735e074c6a0fc44b94821311a4a394521a1c3cce0c2bf3d7e96316bdd34b42e68d33e51064ce57d7953744e6d5e7a5720aec520255775c0641cd7b07d400d82188405e78252f0b9bfd1bbfe0e377994334890331116879de702c9ac0492485e0078f7dec2a9ba2ff9439b566b7c79f4ddb0ad72339d2dff2b1a5d3fcfc3c39218b5dbec0d67bc27fe6e61b7914cada63d7a51b58580d9e069e6117a64ecf3dca81fd64db43efd035e7fea195ac4a2b16c3329ce511b53874b48b9905e6162a4f97bbd7e51e7623d48541dd1f9887a01a4c50f7288a0d697033206e1e97f90e4da3c82695bec86dea704be5f8b8cab52d28702715e4454ae2ecb043e559741d91ea90cdce67f78758b585e12498f77f7f8eaa3431006a0768290540b1e18ae3c0eb738537d167ca84e00a6cfe8dc667e5bf5eecbc6a13a9fdf86cd4f19de0ac9ccd6e6b4c374068362b1fd9a63832d91f2739ac61cdc69e6e796f855b9a6e7d874a2fa418db4c7e50743bddd96049b4c9c369515f42874dec67e5bb39e800e421e293f5073a3390db50223b4c7febbf65b6ada6f9cab442be35418d00bf60c8b80df949f6d03fc68f5dfe15b74b192f108e670535f3c8b665546a9bc56d3f60f0ca0abcf17f6ecdee600ff9ebfca0510714f166b9ed91a7d1b063761380a400ba0ec785047cae2360813f47a9cb10bd8a4e8ff36756c91f69a73e2b1a3136ce29e77824f0ff1cad7962859ffd923b782956c7447bde62518080e4fac3061f57dc09c6b829b8da6274ce0f9ac668191a8e5015434ff543059f0f33cca568d736cdc29769764a1b0333eaa7b1f6cbd9f2fcc638da8ccb78177332d4f946f2d8f7bd4c215c1de1ca8d5ed393b8aabd61d03d1eac744dc1c02c6ee3ec0daadeee69e5fbc9189d8edaf964c4fa53de3ea2ae3ce00242ed6b8756560f4e2f64e034b5dfdd7848a1d6627d562a196cb67cf25b25c1dc62a8b3574a519373875c61b4a04c849f2970d61a70b4e563a3b235a1b4c44a8489d078b4b39428e7c18d40a192f78bb65f38a4969bbe4d61e6acaad6ac801d26f7209b63a382e43a1689990941473b098f94ff7903e2ebb96fa1ed1880e9d9c11bbe7c43167aa75859a1b62963ccb063be3ec1269900aa1525586ffb19cc8c906fdd8e665baf82e24c884e360ae77f16abbd959127e17e4367e5f2a10f2ff769426b694ba6163d1b73bda3cd5f22cedb7060efb165201a542785cbf887b06f0793ff6995ed61e6f73a1e657fac03b8b34a7d98ab95760144ba390bbf876c8c640e675f004be7482bbe4a8b565215caa4b469c3de963cd1738d4534ac8d0cf1c51e5331d3c0e0b1ab062bdcf51705953fcc21bd71a7762a8de6486b7da4883ac99a8a79a25b71c18d63670cf7ca44dc01fc43cb79f1e96f68feb7e309de524635478a90b915b537f9229e020a32edde4be73257cfd691a316db926ae7f201a6ec027dea194834aa19239e4974146a18ac92ead77e3f0c03d5c201068da59248eee2ccf3b5cc54d74bb0d165277e2142c27da19b617a05e560ec292d3303a6bd96cd0f46ca39b76b1780ab3282fe95d2ecdff99957fe663cca728d630bbbb7edb10e28355e7b9205054635ee4028c9a80b57e1f917d665feca284ab4469ace6bfae2ab498d43c2cd82679a7252785c500a84b5a475a2b53d68b3b93799919e912986ba1a391d65d867991fa8f51150b8e42ac549fcf2f2a00034a8ca6165a3f17835dcc992e26d6aa844f4e0ce00f9b087578d83dc0487919f10ac680342e9e7e81c068ea9f2a5e05b91bf0aac96cc0c9c9be56794993644a27282295e72b3d0cea3b51f8e471a2f2163fd563b8feba3b14e8c88144ee7f13bf3a13371fbd6ebecd63f94bdf31fc2add77917be080fd0cc2694f4f8f05bb3b018236186e92d8a8d474a990ee7294ae75fc0b9acf2d5bc0a6287957132db65589956107edb0fd4d62f2a9786844864dbef6a84232af3859a5aa03a884fa6a8c8c665cbc69216aa78a96e5152c5e0caa0632369abfd5a43b972b5174ad6ce21a0add71f867b7bd36027fbeeffede89469facc480eb53a83ac60ae63625cd0b1d76378c80653f58b88ae19c02d783bd75f78b578c9c3e8d27f034742ab29fed9dbe03ed44f07bc04bc55a955596997853673b3e8b720d36cf4ddc33ca58761df64702844d4851063f6f96fd3c0b7dafd2204faba6a2d301490e09d3cc7c3b212a47d0ec91bb80e037fb844b7200865f751a52d27a6641c78e0345b349529e2a3ff719a99362c2cf4923acd0b8226a4e773cf87b47e11ee93606915e4583c5267899e3cf846cee1ec949ab293cb7c1434510a9f8348fc4d0f71a02a4641e2b60db6f259130049751753faef56ac94a2e10877730763e91d5e54ef22849e386a20d0e02c0577b6cbc7d68dd519be1d18a4b122bbc7b24c79786f6b05364cf9ae3952be438f97b4f162072e73a91229eaeb02e65d1c3c5cfbeb92c4a3a11756f550541307f1aadb57cca2ea3bb4e44892686577dd673a2d103f961296d4ba5f51c4ff487313be2eb76f2ed3f3e7fdee4333cd7c31f8134f880bcfbb2ff60b96eace5625c1d5eff385255552cf5f2d1109185fa4a5f9afa5c68bb435dd1ae803f73e25fb1c4b064593e820251f2fcd918c03d0fc7d18de97b380a0ec5e7a02aef3177bdc6f79ad0abe76950c7d239b1938cfad38afe9276a06bf2ec29cc42ebc418e72f04274e668d74d0302731cf5d5e571d4eeb246e5938b76f193d9c35511d3839926c20a24783bf4a430a63de198e2f9af2bc37049421380ba0e3ab74b2282af95aa9ab4d0ef7b86bdcb5e50e4d314101e136d2daa09f7c6efea5997bb625622c9db2a97312f69649b21d23fdff1e95736205cfec07856a3593013a5fba1d708bec11da2272f7193a9f44f400a80500f53ba8873083788612de12210a6a32697914fdce7e3f9a4f67277cd47fe5692ef863c79d0a0f5563a8b8088e28e4bdc00dc5626318742a32025775c6c95d863835a968c48aebe956fe8ee48fa8d1112f6c394df8b3914bbfe749e09225418569bdb11e0a61b633bd53a01fbfaf4a46abf5fa5f1198060c7f709970524f5118baab470a909cbc4e6a055affb6b1bd59857b45ffc6779fe7f08425eac0e25cef0758ce9c839445d1e782ea29dc2cace0dda6b3d7beae3fe180dc5dfb2a08274758b86625a65b19c19cd000794a775e9320544f05d37d2b2d14510b317be554d7b1a68d4c1638792491d5bd2f038a7404e45df6c580040b25d6a43d49083a416991342a93d6566638e68d71a6b83aa24d210c6fb0fcde16f09a7dafd20908989f279edd8a8d4d7b24bdcc57715a43f019dbd337567783e53702962ccc8962dd7aa0eba52a709e1755d1b30b62e97be971c2c79863961279112d95494490ebba5c0c6403adff8c5abde987933f90c8801cbe49d6a81c95047298f3b22aa3f5574f74034f85f1ddd4aac87324abe4e7239be697adb2bb1d05b752798c9dcaab2c68e2d9f4c6b35954ae27f3111385ca4b3a79180634e779c9ad14299ef31640fa3057cbebef2d051cd3f6190a0f4c8c71b9f023a84514791283dae0bdb05db0139674bf292dcaf297d45e415eb2211e3a5a2121634e849772d7db458d56f96edd62fbe69f19446704fd9ac4ef07ab5f33279894d400a354962627fbbbac3195202f3f29f4e94d85f96ad2b8643f02203ab4934cb38fe5285be4e534fda582e09c94eee30a6d67011c259788aa6f87ce18916b8fce5ab5d497d555007e74006c364fc7c3a7aa0c5b19ba38f81a7c27ef4f786618ad3963a597fb3394f313a5bf97f13cb3314bd7810bd545c53d8385b2253fcecbe6d459dc8c50c2762236d52f38ccd38c298af3d4d30d955d5fbc0f4a5ee130dccdf1e5318a82cc0fbdf3b7b7b3d7093eaa27d9a981f81761424fa5a10de14a5204f667eea42fa7ecfba7af3a3451b12260009e4d5efc8cc420c06207d43245bd83766ee8529db6744368e79d0cb92115f791995eef635826b56f2a276f3643a12ac46f46371f97a9b1416a35ca1c6f4b72f870af3635175d159288fd1b83271197556ae1f3aed00960d76426c84dd47ddbf91eb740e2fded5032145584e460b948f94046ee081183a43a1e11faa1ab78ef946f266531c32fbca7e5c8de16b5e9d08212ccd9641f51d284de3ccd8072730509bed62986e2677d35b8fb0412efd3947aba6f0907cf519ff361eaca645e4c66a7532b1e2af38037a5984f47a1252c1aa8822de547de791ce22bbff3c302f2e5bd11e9d00d8d892cc77e23da375f8afbf5fcddc13c530b53c29e075a88e1f7a2d938ead97d4e76ca167dfab2c2379e2ef1f3d4714c989533b8d072e1fd7d526f742a7b87445b8e1d67f60a56c96d47a2fe440946a4de6a40cf3293fb10d6a59fab094cbf43123dc4f9bb90c8e558dc2284511169ea60fd7e544a5465981fdbb3c4fcf1a11aa987b98590f0a880ae1ac174d4426dbf280bb0e06396d4f8d3d31de7422ac378188bcf1241d09a56c21bfdf4ae1ab616d1b5245ceba70027287ba41d392cd8ebc0451d530e71d47a002bfd2f35dc1843cd1ef8316f9c25d760d628c988879f50938f8151f8f53eb3657ad3aef8e002dccaf042b2dd2617b0386fa9e7aac4ef59cc40f3bf200c6b58f7239a7a9772ed72d68c3af9a5b19f4bed38f0640a83e2fdb48b1ccd433e5ad1fe42af63ddd6f565213f0007006244b4aa4b1561c87763fea5b372830099d565819cf1f425852d88104bfdf724c5aeca1eb8cc511f1ade46c500e97b4406e15e732ab38272a442c352a6865c45664ef6cb3a27df48a4fe1aad43d31ede0075775bc4e7181e499f117bf8d470b4e450735309cabd9449f3d5ab531a5b92a12f0104a1a0c82f06c8ee794e1ea53f423645cb040c4340e7430e087a06903d24e9492707d14677d5011e8890337507c530cf58ae64063613c063a22ebcdabf53b9288f3f60f40017f34a6d29298070c3ac2d15af1ea56782ca34a5f9ecf274797e7a3a50b2449aad03278363614284345218993c0299ea99b28cd52240262d8687e8aeb2013f85d17aec1561d2e2d580bd376ab88f2a3c200480636730e7aafebe6ad72b2e19112454e29e0c4f094b127f2a4f90787d2e36df2e311790c0795685fe2484f99f8a4701c26f174c642bae3360ec5bd033f45352de4b84252ed31dfb2d2fb297d9c767c3233532d4926b6e22da52e8a5e6eb783c64cf0f435678f7e4413623f5df02b3319868a911c9bcc602725d72f65fea7039385fcb7d836b23ea725357ce56956d212f8a9090a38d264be4e13540a65f91ff0265e697268072f29194fd758","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
