<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c43f456d5bf0642cc2a5f275bac53822ef48834a32dbc136e74f4f8bef4fe3b191f70989ebabf65612650258e86e7d290513fc5ec7bdc2722d8e708563d6185b22abb739c1c4cda5d62a63c019ff2ee83c7c42a4abce24824322dec6fc9c0c3576936ab8dc8e33056d00eadc7cdc12dcab48261b8bb71f37a290537c5015dfbf9cf46243b62cbd48c72243101e099b0d4a2a47e4be53b2eff7a05ebad5f12cbf567e206cf8d87e38490a40d583b34f8d9b6a592ed1f8ddf1c69712b5dfd7aeac31e3c4d866dcde3eb0672f6bbac466f9cb64450a7497885f8afa4586f1b08c3bfe375d7291268bdd8d32e5e3b55ee6b2e5b1adb816a53dcfec7c0f23cbe8144641b902239ea22b7992b17a8f95de95bec114638abbe4a0e6527864b4dde19e72f327a3fa780575a0540b603ee5461f8955fc1d9f7ec11b931ce330ab6f67c7b43914725ec23f3c3783292201be1f93ea063518390662de7cb205f0384df70de7c68a6c28f3d8d97556734972cad6958ae1dfe68e64bad22b2e46eed680c96eab036a537c1ae8bc6993844d0793691336667480f83cc0e9a0918799ee74d84e1253ac4a29cf1338fb1640dba468ebe084d90fd7d266a8992fed934ae3217d7f4a0b63ec4309f4727f72cab701a2506a66911bea74d384ccaf54e13c661bfb6a4ff0b2de08774d6c80e2efb44a20f743f8d5223350d636046c3350356fb4e5442a5ab0f05733243f05a2887791c28434477e714ccbc184b64f24c621f8e86eae70ee914a4b89e3ea2039b060dc3d0896994d398b23866de78040890bb17847d22ea7b243aedd945134aec1a79defc0eb7766edd0ea653a98cdff133c9f7fb5ffcbc541e9db71623065e709c6bd7c217388135bc28036da6189628be351b59b132f9387aac3a11c5d61623c06fad641f5a04d3e4e95f17a111d22d8112049ce1f6661860ffe6a47e421b132c77bcff48c2ca8ede9f8d5ffd81e626c3d5dda1b50951d69738450a02a88c0e6c682aac67e17fe90979ee5d4ed9e5fbd0591431aabd6dce0b31c191c86770ded08bf64f223582b7c6becf12023871833a96e910df627014507645fb5443e55ea283b4781877b4893737bafe021bbfa83f7cc9d7606e2056bf2abe99de1fc524b3756d615548edbce18e2ae0de42e1c1666e456a35822a0706c789e1ecb99828924d26d2e5624e8fd731d1fb4ec82a334f16136c56bed74e5c6a4e9c92e27c746e14321e6a3bb0f1f46b5db74d9c3455ecc06549c7ac59f100a3b30f38f8d7bb4f60b52356f7d742cb50ca7deac693efb4ae51498f80802507eb7930d1adbc662366310a1afee20d0425b0dd52049d33230135c548698e8d229dc800f47a854bea8ebd0a716748b730320765f9f17085f84ec2ec126d6a4365b8fdeede15c1604485f6d4d883cd1b319888e95cba008e1c8c123c1b53e6c26e519cccb03474c0fe9f8ecf4a5c41bd3d9e324d2d7818accfe20d586ee1c8123da3133d61cad70e2b9d1980289accce428d507cc0d2f40002b58908796ec2804718169d413958bc5ec9b00a2ca472729aaac2ab36047ff9869f1039445d841ce495bfd4dcd5b9b22c117cb18e9c8f3df89f480de56538c7bd2d47ca3040a389c1eba240533ef05c8b920297276978e8bb1ee9b571fa6f536bed858c399c1209cbe053447fb4fa7dfa2ac2cef4c8b3af77b60188887b57f402bf821d3e8db2c7818c60876cf70de93db8fdcb3fab4a602b60a85edbdcdcaccb8cc89b3ef9e12e5415d6ea0f612d3d7f6200676aff0c7a013b38d4dc653d5aa2756b0a5c693d1571697b5a7afd3cb050c5cf2d1dffe57dc5adc22f6f1847072a12e25f4300b7cb25a75aeba48b12e3aecab1e055988aef16266bec09ba2b7c64fabfe8d37866cbf61b9ca81fd94f5cfd4fee827f6004cba0cb0905255c2e3a1462268b393ac02941531c9bb53ccbee61318d2b3a2b5c6fb8e1b8261b8b6fa1828355e99669c83fbfc134a38c1f35d3ee9ace138a138cdd612c0b307df64f5eab358ad9b7c310aec62024cd6012f7e9b293c0e83a54b3542a1d492eccce61dc2f1c2c64a9b8ca2ecf712d44fa48130662432928bbf649428762458b988ef4ce994df235dc5693d533692fbdfb6e35696e2ead3011b6a3bd46d457fff4d1d992b98fab69965deb6875454f78f0f5cc424946cd2a97a44f531236377d1bf789420cb8edd9e3623010bd52e42d37282c2d440d484a6768960e1e1cd090d6f364cfe39cbb317bc4679ec3704bec075f816b3f7b44434aff9e1b395043714039c20f4556a2509307548fe0bbb805c0f4bfa6af6f3da8b45608d9ce79bf6d9f2662e072897479d5a1bfc87f4d51767ab49c0c26b4bf084bd857f69ca1362a8bfcc749d8f6e0b9ccbc5fc9b3eef3f102ebfa18bc53837329599a9f2b778c97044a28ec99dafb0f9b81c72ab91752edba9797152a542ce2f4f66afe2772132de7b9ba22ae1ccc90e562515134ee2bcb4060a592d79a5ae24f9e3c5c2625cd6fa7612e3cdba8bc58daedef9c979d8a481753d060999640e25c63b623986728bed71c7f461a4a0340f7dd609a73b4a42a9d7df7916365ec99589257a006cf1b5453af2bea26b05c2bbc31e91411882c76b92759beae68acc7928f4da9aff5afd37ca6c38fa62538c926ee1f234ac49d8054d3ab5172917ec9714c3ce4c369482707c8cb721e86801b8fab2ed41f680da0df2df06554c547514c15dfd19d37c458ebe830d7bce7e5b4ef2727676f5063140de8cee433c6d96ef72ae7eaab35143540e3ae85dd2c12c0027758d6691b411b549b519c15daa6906b2e001470ba63be54183ff74db01c0da0b86e1243c492254559034c393d87d8ff4365139c45517b45535cae4ab46c7a701c81cd2b0eae94f6d650af61b44f1c57132fd3eafa8756996a936a84180cbe7b1c38e588e63e39aabd38d678f0b9e58a638a58ec4903ff4fa32ccfe1df7d1536b64a9bf29d13c5ddfd16f81448c591d83bcdb0bf24d0b296f2b8b677b9e2b89b77c70687576ee1d907b6df675f55e1089f52911aa2d32474ea2aa88ef1db75360ac72e26fe606f53f9174a7f065b3f50b64142c440fac9c028ae48e078804f47d4021f1b56f983edc071c8c7bbaf9aa964db185b95a6a480982340cc92f539c4895ae6e6137c20f2ac829444e4bb35f6ec40aaca050885531ddf61a456e6e18ed1a801b794d5f6862a4d2932e22b86929dde9a826ead78042341006a6d196b77f63c18ab2da15d3f98d1b5fcf5868f192aac18d816208ce49d8b555771294ad6f8e1768c71d99ca4a8e96864d0b3f62746e2077a622dc9aba700a98a5ad98e97ff6668ef296796fdd639910512ce9b214cd621845750a099c107abd727981220392dee0b8786643d85638db22b30e4b3431feb4104716c30054f35db13385c07f8c2e028dbf8e043af5b75c01b8aed9c5e6995999e821ac84644bf37c6d48ce00e41b7fdeffb5d5c26ca0f21ce05f4268142e677679fff391448a5083a755d74d49f74ab0e443359777612b031700fb378cc207db8f996ad9be44332ccbd265b40f3614154308e1dc165e60dcdc84068e750b33e4cffaf88ca0d85a2795957598eefa8346a4e758d8e355650013c6dd5c5e2f451cd7ab66511dbe7ec2b397cc544cb8de7eca252325616d5bafed4dd9ebdee6ea8e2666b621f3f406de866f2689b04a07b405d348416c236d67de32c01b644e512fd6bb4308d8684d7d038756ad66d60777166a40e9dfb100bbda932cea5843acf64c14bc356b0ab6d975d19bbdba17f9662bfcd254ced3634b8d178e3e91bd7d3b400a35c3312f3012a7912ca72fdaacfc22297db025233f53d46c65c29e85bf9b54cb7804177bdcee3cbc1e586ae8260fd557b1c605dd1a575613e5f19ffd971695f2bd3193e359b0f2a18b3d74a5e924ff421f72416bde2fc11b3b87714722d1d3dde222cff7746935e503232a2509b320ebc49b1f579bdcb938c6e1f62c6bac4834b8da418fd2b52be0540f8f9f8f01a3f21e2816cd66ab764353036d0c2da40492a7153ac8c99ff9c2aa5ea55ebaae08cc7d60dff44dc953aaf10ab545fbafd7d4ebdc04615950c3b385acb74bfe37bdf59f54a1f862de0673308c4c11d110f694b659b5720e1e113e13ff25b37460de53b30877fc30ec60a777c9cfa538bde4fe9d7fbdc4dd79c5252690a6115ee09cf99ce336ca498df447b1d70c2ac76a1eb1de7e218fae430991de3dac307120a0cdb715a12997545823a946d7a6c012ece87877b10f8f4e0d9bbd533960c625acbb6978a59b27f97e14c754964d4343c07c3b17fe3f2b31086f1af965e5ffccd6c5b4550e210bd37faca4d7920388192776dc355771f731adaf1125790caed1f56050e37935bff5307da848c51ea1d17a86ab9e8e00b403437320526530fa8178c3a84fd8c2cfca1052274c412aa2d52dc6add3109de55a819759133b32a7d5667732120a0f06f14e2767721afa336c6d2a61db1dcbcfee7133abfcd513e42e9789b4da46e9a31f8e18f99ac095351e5275e02ab4be17cdf371faa769b16e50d496b94ae747562c5798124338102064a3ec6301c458f2dcc2da80be1740ab1e232f8c662d4f7cc2930aa254807379491e97160672f7ac9eb036feeba53061ff3311122d7b9f17fa80c0325b2b69eeac670c0bc7aa8185743b6e8778c46765c12d747c8953f1980d5a10c18a725dbee19d53b3c8a89e7ae1c9877a72c537486f545f117041d8840ddeaf0bc2c955b03ce694f03beaecd6845e95ffb064cf06b7567a2a35b503c523b19db48eaf3488a5353d84f1fe805fdaa6dae73a943b7487cbf26d9191c71704ae3c4b361c41d61c3a5fd45200b9dd7703aaaa2afa2a5b70b6df82afd8423478ff3ffc9b9bc23323383449d609268880622ba6d717c0ee3a1f39a687b6e64cf980abebc5b38acc8fbc98a176483688b511438df046f95d8de3564e20d91d85162245c1540830c94bcafc701c4647fc714eebdcbbc8433ab5074f5854836d70c4f17a2164fe00453489843af7b285286fc932b03d908a0cf3b3d62a8425f8c22587dc45733cc8294cf8d3ca68e4207b394578d03feed2c56cc1e733db07ef43875b289abffac0632766d68cff7cf7ab35bebfc5d27f55202647728cd0f817b4acc47c9e879884e4467ad3d368be627f1064a7f07404d67dc36a701d8660ca3709f03e5ee36b8de46dc344c478e3f05d56af15e99b594697d099c8d1d6273b37bf4383d33aeb187c0e53626739471ece3895ac98331bb7a61fdddfca695d860acf9f80d80b1356f857a3ca3fa12b8fc18686f03fb3883c5c7ff6fc296416f3b7c946bfc7d6ef66ea2f6980ce4e97dfd603021d5a0ee7f1f7ab9c85459d38b87ca513e11f32ef82612e9395253bafc1ffb092344de013adbdce34d41296c6144eb14a29c5809e955fd08d766a61b2704b50f0c0537071c1152eb12bce71309f3450772a6ca8e2ff46ce35f1e67148f990f9bdea2519b2ff9753de48361136837a13927b8ad76ee85b68e82ef8119e2253ea3350479eb29eeca9e522dcd15acd0deb4f541bd7321381f7bc1ed7e9a9c449149f6df323319bc7bb002855c4be0c6c7f67f781807304aacc771d7f789a99457a7d5cfba0c3c7b9bcda82e6bb5382cad10b260b166c81c27b06a158030259c44ae9fabd7b0f4d77fe5f5c1ec873d77fbf07579b6d273eb0df6067059e2af77b9020b342384016de4760e3f3b18668cbdb6776c5993337e4ac2a0aa5a2168d41ae1496f1e2e58b0cc3e179d9897347650c08b9a33083a4fe5af4e13bf697712771a4b066c6f92f2e66b8290d91c7f3e6aa2d96aef12ee7ebf6db822059853b10573979456da81ba0434b5232250c9a8ac363d2be71de1c57c343340246db2b7a64d79f6dc5c6321716ffa97027026fb1cbef30053e4f51788874387884d88f62afffee19f9b49ac4a3fdea1054719f88bed86fc1748c9e8469eb130f4b644578ce3792ab61c0fae9eb86b94d16eb3d9c4c64fbd4f0944f5cf77dbad92f959ae7d9d2a3ee8855e0fb7588149de2fcc62baf45d1d3b88950b735eff8489d247e752d3e075470ce8dbb87a708864601c142b1b80a421d311a9df0a91c29fe28360bc76b57a1059c6e2b22f35e7474f743c327c9dbf6d2dc2987dbf90a56a8bb5411d3b19d322f7b5549ca5b211790c655b10feb5a02064d9978436936ce6780560cb093d4b2e18e9bc7027faa28f58d4a1f1f604f92a33acb821b678f82d3b83cb1cd4c60941fd7e83b2f42e1e35a0717e1a5032203d506d2a6b3dc21bc2a1a048059f28cf05fd5cf1ed47367501d053d4e7835d782f2f92165353299e756d99e68e8179b5cdda034faa02a24767ea286b043c4f42ab86bc7874442060e56c0fedcfb7ae53f6937b1584eb31514cf8b64d3b7eee607818678a5a70eedfc1970fcfe4e4d0c8961087d028fedadc66427b32a969089be0fca6caf3e8c904d0b438bf24be4d66a4790051b94884bba1949817ff0dc3c45ce65b598f873b5570eff256f7b116f5b7cc72e91f95235b6080ef9d4758ba3cd93de2cae2e0be38461b72d9437a2101295985f369e98456b164e7654796f3e40ceab7ccaa696af1c23bf376460aa827bd0505d64635126be16a9ea2b02ec901b8436b488d36dcdb8748e93d5e7cb77bf8d7c6fb8622220271cf04f9f23121e067a31343d325d985629393ce3f06ff2fa7bcaf39631092fe60c9a9234cb60d7aa2a7a6b32ace22db1c5badd4e74c0e6e6865ad3dd51d9155d01bdbbd82ebd4c8ea1cca3cacb2929e1271382ebe187455cc2e2d35cbc1f14748a395e96ca95cb997a38d94fd66a708da9500513082dcde9a8fd99bddbda7a6ee0e79c33bf28abe5a6f1478f48698f07ec999c22298ce453db1f6acebf56e664f58e083c31abc99f592c0ab6b999611b222731722f25ed8c9c7d1dcd1d950b37954a47cd0d9e1d5d6a88b92f4c0447e723b6f3d00bd46c885de071c4bac6e565dcb5de214022cab6b63bc2d2b793c6b014169994989a6278e9e1f1fff6cf0a655b5bc9b51ce186735e242d160b13165fe0142f27707662c9eb9667ff285c52673d5fb43030f1a8ed9cd303c755af17295caf6e99cfb69195c1043766efa6682eca8a7f4835d0608004bec11d535d3b11871bab403c2c4679a36fccb5db948f429b5221b091c563d5428ec6975dbb72adba6d77bf5c09638e5d9794474d0c51858148ffb5d9b13f813c3bd8198ef2918aeb5b6c769e9aa7f5767af6a17aac4d277c79bec6009b780ab93af112fbfaff426be0cbcc645f959dfb5a1b44cc9b4c0cc4000883c61302b5a0501f2b5817cdc88f396060ead9cd8c731bf9d515dd864649ba1f585b2ac4dd1d7c7314efed74d7443b18ca7b3e72f1bacdd25c5dd9490485df0d81f55e6bcae556d027d0ec875a2f365dec72f47555aeed609ebdbe39bbd6a71f592ad49eb073081dfb0e81fea3b43248c70629d39533bcec85d93723a1c7a68678bda65b5335f42b7865cdf005191e1aa53015cf6f206f8da47312f4967c3f9e7ebd307ab154f09d96e16451c6d5a2f66a6ef1cf5713479147c6144ba4b38e8da9e9dc97160d9752b342937dc2765fe467849559f14713b0ad135ec31367e1c75ec133d8a72652024fbeb5bf23d93fe0d01b62d4d3c60db6f145f409b8a9b8428bf0d9feb27b9d9f0b357197f83141c9df3747308726ae0354087ebbbd5bad800701094e77361d7de051fa3a8228bceb176b49b94cf6740e558cf78d30367e96437320d839a0e468869178395151960adbe8b486017d801ec932afb0f6fcf5dd8e0ae64923ef845a87a125dbf45ada07ac9535cb138bb6f8c677693f10bab26c4c66b557a3bdee9608090e7917357f994f26910561ce405fb4ef3ed90594f6591031e2a15be766a3a1c64ea1290755eeab55c4f77761e0bb19887cd819e76a141a15997f124139684bc1991ec9dda5cac9ced53d60f75e1efb63ca7cafb72acfe05e7b15791809339d6cdfade95920476cb9dc7b3ac16822f230357ea8c3eefa4ba9af5d6ac32fca156b48274be32b3697f9ece1e3b099b6a7f624f8d73d112002c068cdd86c0e54548e2f4d6d12ccfd9dd34d5c233fc17809d55d8e3c924e6affbce0aeb0076017c0b524d98a6cfef46e179d479325fba381be4897367030cf02e2bdea0714f9cf6532a4e9f0e7dc64885fb7b644ae65529986fd92c54c2b5b421f70c1ca356e5d3caa0ac07ef8a024580e7da33baf49bc195b12b4c6d6d75844dacf265a57ac82c53168746cf5e1d62cb84da59d449078e814b395eefea7a1d2b15951eeaaa88cb1d84bc239244820bc1142caadafa88327c16cb276c6e62a7eb108d58054a427c3037389637fd60b9b52a922b017bf194f891c17c06d798dadf2117f66d1a43bd2310368ce9121fe2cc8818e410538bbf5bdf151b7d76d2fb0c890cc8e500b1d210754fa839fc25040c1e4fa688689e259bc5c3aab3feaaec5ec4c87b7a172ab26dce0a88f28e9456561d4325acdb3914ae8580c06f5d9485c02b077932ad9dd51b2b47e00dffa85b7b91d5ad74073892a9a1cf53d62d751393b362dde0cbab9bcc7deff8595bccf544c7a3dd2ff4efb174ebe7cf4b3d545d2771b965c19fde5c728cc4694afdb480936e737e8170705bd033a8c4d4580a1a5f1e701916208f3ca8bf588e1d4699c10967caf96f934177ffc38920efb01f4b2a81a2a936039dff522ea5cb8d8f14c8a8cf8e3de86ad5e2f3990c22cb73984a9516470ab9bfa74fd7da5fdefb30e181c2b541baa43831bb288323c43364b8167c90e8f24a048225399738ea8ed6199a2caaac0e8fc2189ff7e064a66de105145f30bf08fd14430303937ddc9a538413e1471effa869e3423afc974603f69559ec811369236a41ee7b94d84d215a6ce7693141875465424d212f22e7dfef2d50f6024f15415b6d3a858d01110ff98b9a1bd1ec9a5e9ae7ea5c51466136ef1d01f8b5a7015ee31c8f7b76f291086e19be8bf939c162f2db83c8c387865f76bc007829c9d25a4bc9504075cac3b3cacd04e77feb1a5857b460a5af48bf64c9dfe69e5a32d71e475666775fdc33892d3a789ed9c735a0085980fb832c6d60124db508247ed313e2fd0472091a5be28e20d7eb34b780b363e31002f6383aecd19300f075b193e0ff349326b26b625fa7d4504b16cb93787d7bc30e764ed2923a790ecdeb1084972dadc4cdae41c50738e7b0a65db3fa1832ac72c2c4fa25bb9485e3c8f2ba271cbc61ec5d2b75e1b0521f0490b1279ccc376906b3604bd2318c03b34afa387f3696a1e2e4315fdca497dd9279548354a531df8c675fc9b669d5341793228c3cc51c2977c6bb894dcb03e2c65740011f970a92d2eac0f03bd38b3d89058981fe3e548b15066896e988abd912207f4b8732b8f303f3d4a6da9b589f3ea330283dd5924d33f7d7c8976fcc660ff354578e085ec8b7781bf05b034d231939df3324a22d626655dd619fcb64500c4f499c45ef9a72f2137c5254994f9e253fb15e6fab63251618abf5717963b60b0468239a01c5e7da1a78907c0120d09b07f61f7fbce061c7475497e645a533aefe4978bd8c896b42f015ecd09a6a07199bb6e5ce5b83e8a1c2d315d7705707d639fa2c15d056720197064795cec984bfee4f23c2a2d24c0a0f2af22272663f66ee25fbacd2685e8f5b3da5ae4c202bf4b1e10ab5ea5f941ff3619ab673e52869d82caeda953972a9a54b466d812d942346f883d5b968d0c47fb427428055d99433ab88d97d7c137dac16ad82cd110d9a8b2bc4f80a9ab169ded713420e295f59fcb76fef542acb6898e415227036886692eb9f2613e1de7498319b147ee377e31619c80fed02a3666f199edac71dacf7430322ae32ed13393642ae0a292664f1ebcf0936e2a027035b0342ddc6a70c0e903094fc16253974f8ab30e1401111a5065e37a30bd74631eb7b1416620a17654d7dfaf16a91686e5014a6e7322ee7749ac4c8ffbff7d50f8b9de951ec6db8a595f1f253b9ab7f01da028aa838c8e37cf0505f0609a3fcbeede4976beb9621328fc54ce16336911e1b1aa729cc4e7e7e0ee7ba8fcefe30c7ee5349f0a6f78fdce0501836ae9e66d0e655e9f1aaeecdd9d36968fa357e29b75c0e77dfdfd01676b119179a37f97aff4b024a0a36ef6f9a441d675036cb44c643f7c8b26c992c9322e15d34d7f3f33001451ee06f1e7e28029f0af145bba94a8394d2689ae37bd9f9471d80dd328acea8deb037d42e858689ee8e4e1367947cb2e0ff852778f6fe2425efa448845d12a3a682ff2ed61eb0a105293cfdbaa5565b3fc362bbb0ee88754147500695ef72675d9debfd80558a67b429f9587ef9b15297d4c84db52e1fb4ca445f95f4baf0e08d88e759daa6a87a8d0efe99d9c4481b6225fd6990130a2d37e243216b87528a313c93900b8996abbabeb379756","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
