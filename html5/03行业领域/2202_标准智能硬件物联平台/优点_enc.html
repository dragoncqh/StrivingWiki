<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99030de2aa22e09af1257c795cf340bb7cf55ec9765143c9a5cdeb59c3a4e1e684db57bf2ceddc1744a83d98f6904df0a8fd2a17bfb8bb2d043941c195da298a484f8ea03e83af0207b9ff6e0d96af6a68999067cafa1fbf388162e0d09b5a4dcf07d187e6ab57e5057871b0c3dca3d3107747371b795bbdf28ae4e53a13d28ca4dcb3106fa2e3801dbdde43779967c66d62179ae639f8d3b5328eaac00078d867487344975745c30bc634efc803a9e9fe20e96b7b1e00a285efc12d3a89e306efb1953c62ca02b4bb0a6e4db8f5d11ada3246d477d70d72f57a16341b30c886466a5ce6dc0d9d4e2686eb867fb2081011e3b02d2cd192a9ef5e713fb0db05d32a4958ace30971c3070d921c43d899a1e5770bf25403fa2112d8a4f06e714aa15c8295e6e3fec410c5907f4c6eccc4937a892f363ea76d85ebc45aa0fe1c6d2543edbaa312d77a74f70ae0dfb99befd62ead9b91f620f36220c9ec77558a3b81bd3b4e0f87a26429a2eac60d9f03bfeccfa106f6be3fcf96dc36dcf4681e5aa511f1967d2f1f33d385629b6b56dd1b1e59b2ab0fdd92181b30e71cc5e8bbbd561f0d32ea155fbe04c70e298333c829b76b9bf3cb217b133dc5bab8675076ef74e4b813f57ded9a525a57212b5d0399cfa8a815832547296483fa1c930db596ddd2fe7e59163d052499f0e5538fac6e9c78edd048fb15190a8e55a095f53888814e3427e6ca207708e220242f70c4763f39886a4773ae2068ce8dd3d25eebe8dc83275da04022887602e61f91bd6bbe2b9ec0f41fe937bdfae0aaa7ae679fb18dec0f2b91be88b6160c6737c69e1683e159d44922659687c1396221f175ff89c703d2fa109444b88025510173010320d529857988ed1c8116255ca4ab0741b5b760d3f01b242f72de9303252453dcaf924d4b693a24892b54becee77c5d7963e5ceae059b5b915553e978c86f20f86c75164e1bd9cee46fcfd9131d18c84c124d997a568dce9d50a2b0a285d53927e907fe21a2959532ba80943269e4edc03b38c8f2e10b806a270fdf99fff4db96cee44c1f79a38d15dccbcf28630372593c06352ae23448f3751ef653de31923be5eb8f9f3d462b91bbd4f1fc3dfa3055dd64e0ef170d45cd4187908f9e6f4e1c5beb4aa0d0c69aa0b4523129630ebc5ebfd978efe78fa280d857734065df82ca73c4301625cc14f104cea52b518c5235a3a948e0e635bd9f093a05e5b15e5594d57e44fd2ab0e1cbf96b92dfeaedd2e1234930431da89b397da7c98d61545d484eb246e4dc96fb6e7783dac8c4046be4702017acb1ac502cdbd2c6aec700ef82bbfac44f68380f99c2c161251d2fc4e541afb0ff7ca98f5cfef0e6960301d4600943748668cf6e8117f40e235f064c9bbf2e11742507b297c6c2e16f4d2726b22acabc529795ee7ff1c196e76a778e3577bfa0e87dab946f038a84f78b801d9e37fa88a17d110919277793725e600a0be19504ddaa1d8ed96b2fd2091313a4be0e27fcba87c860441daee3979407c441f28fb8fe7f0c9729eb7d53ec8a2c7f856322cf1e13a664994fd6497e7ff96d8dd0c462725a8eb1b7dc6f731f0d1ccd40ed7978925fdb401092c3937a19ce1ffe2bfcd01a6487108ba68bf94a86d42fb4f286f42eea8494fb68d2724d03c6cf859fdaf61688a57cdcd1ec9f033929f615ae8c5b1f045871d3b05bffda0e6825ffc3e90d82999f5b6b60396420905ba06e2950b16f068053958c28b80ac7d6f47affbef05097310d0c20cc7627e596072409ed6aa20fd478fbb3a1ea5d2b5e71976b7fc1d7e50e6614bd8a1cb0c64f42aef8edae4679843a630a9385a98a6fa4dd735337dfeab9b42e04fcbdfac50396edb6feeab3046589d11a0dd4a86328fe4c96ea1112fcefd0090779672019632596bcf268460a0253c30e5ea279f49f7a2ff68c44dd19fad1659eff514569e33851cd33f25ee1febcbcd12170d970d33d5676b9a8e94fe3836ce24bbca37ce27e978f1390fd371078d01048fb1b5c306436af8672cc810af4ee1402fd331340b20d99f107651c1811f42d4bbb8d90b381127585a39f372d9a19194155e02f2a8c04daeb07b0bfa29f5ab12cf93fbb3730d0a8cf582fb6f2e33d6023269ea3f0e48463c6e1eca52d88e19ec4d499439a08f82e69a079a09cb02488adf8482ca53f90969daaeba81215e978387bdb7aa8c810105f9188b5cca33eefa98c0e4e6405f8f49543dd85412ca425dedf46f170a102a324b474f71a94ae2a13db3b42ee22afafb00a78db23e9d872268b3f8b2d474369ca370d009c68ef7686d513f32fa605da58f393bcd84ff36be9df528637a4caef21d3d8d0c85b3f075161933016681e48712ead45f3a5c8edc532ffc00791c534ec9430b427b5aa1f780554dbd1ec92287acee11095bc28b3109b2770971f30a4cbc694169a04e8ec75b0fb091221fdae2a602131247932f9b35fc37d42de805c695c9dff1957e186aa42f669c7a0d9add2f544f7bef55aaa2a559a1a5939c95ca12691c2ef02bf6593bdd9fb87be11daf55f58e0694698b94ea149b3c07bc2d8236a4070fa91ae41953c0389c15b17afa21a4e8fdce8e09f746bcacc4469aedafa1174b9f486415a1ba4f1fdee9158ac77b4179551fdaa95cbdab71dd66aae4b5ad375ead84d5cfc8e4d70d0d5f0ca26f2719f8c7a014548705274c9741046d7e9700f6420461d9b8fb8e64fdebbf5e3e6756c355a01f69e463bd3bcdc2b61e89d442a1ba4ec58ee605e18dfbb25eb82e2b70d0c84d135a03dcbefc18f24730dc9529bc9cef3fccd5cd0c0358059801dae230545388cdfa74b0203380e5661f9a274651230f2557686bd86f3fca730c7988825f1dcc715911680bcf36ca7bbe7144fc1c50e2f0711ed534805740c5d83f9e47d1d61db6b8f5cb994771e2721506a379e80c2e12b32292ed154a062313fc269b67850ea0ba45263b7024b172e4d0247c54d6bd2edf83bb06332576eaf0a99314a2e3d50484076e03def05796c17f876dcbe56d062b578c09a1aee9804923b42ec97de601206f22a346fcfcde6e38c9416ac80cda78156a2e525b0b83621040f8b943066808e39fd4f68b7a89c1e24e50112c77a02352de71c35504b34c5fbf780dd0539aebb9146fbb7a1d2ca109deab885af42bb0b3b71fa1d5b04cf8c450d835d2fb1ac36aa725e40a4a98f136ce71bf19a60a1367aec92c1f54e4ef8cbf32fd683f7f338370d714939cc7a3c18c5c513574cf736e86503560cb3ffc2eeed763cd2b4a73d2027e214b6de6d77f45063e048570004d8328217e37da856ced7c4e9b696b36f84cc05668cb736498bb4d98b9a0ddd4eaf65f3c7afba10027d160d5cd303774f514410ec21f43019834cce07af1dd120a7dcee6fbc002ce05d7dfe7cced02c41a1e885f5b79584df3ee2e7577e0634254ceff5ec9b8a42f5da768226a0453166c8d99044bf33ad58e85b786d8d08ea503a19a4c02bc802fd9a7c163c8636c003db9e16f5be6b9cc2fa86a996e4dbc842bdf0e30dbd607fed504f5e9f5fbbe0743c0295aa7e2818de99e2f6c81d4c5d8efa2c148f4ccb6cde5d0a70eb1df3395f50a28c9435533434e2f43c8e1ae454735337a39609577b1883569c15ebb5bf1964f261eaa571c57df07eb5a36e52027b92032a60d9f3a4c7af0360983b95af43e197c11f7c1948c9317f7dc153711935b58ff96893eb914471659c84fb7511ca46811f623dac70ddbd4507b94142b28a478f8c6ebb3f1159d95c6034960d5d78d583d01bf0b29d724fa276116431f619a62e63a98ce7218458bcfec7419243c02f8432abd6778f2a024640e3e9c82233a900226bc34d507ffb3d578a10db2158ba89d5e729b9cb9501bb4923597638406d95f48a5e62685bc64af453ec20268746c5cdd912a9e3dadb2c633171ed4769685f1dd99e83cba44c406c1833e7c6fa2e3f26a2be95a4e2dff586ce3966fd4e9b1ddeb00212a13130e769a043b4844530162638e83544eba462b8c2fd24ad2116a32da53942aeae04b61870c72914d78840747ae5d6c152c33dd4dc55593e7930b18d7d74c81a11711740830a1e9ffe91372f2162bbd0f3051261d863509a16dafd54982562ec620c611d5fb3a8cc98445ea5c22155eb23b7d16e04d65020d8af729d5354fb86059a3908a087297ad80a2819620a88ce2f09ee6dcd269f8ae7d5b7efe675e178816fbcd0f68b71c8db8d8c7a8a31160f21275c9b0f7df8c76309add8ebb8b8a2422cd2c562534fdf4ad23a616bb44595a67fb3396d2085470380787ee2a827c71b5732e216b22045a109e2ff8de2d5f8d87ef53fd19df0f54e07cec8cb46a0e604276f0fab8f857d7e7f1616f296bafe4e8f1f04edaf83c4ebe3e17c98be8fd0c52a464f795549405ac8c3100a56130a3a71e8dd7e72eea26ca2ac253e155eea891feaeb6492f4226841736fbb22920a9be1aef36604233410d01d7aa8fdd5b9837e2f54e1f814e7724a0061d8387833dc262c3b8a93ed7e0853eefa4868358a2f75147dbd3bea7c1abbd7de4ff97c899933ee4395eceac4754d6b4b0c6ec3aeadd409c36fab5749a769eb10a3a153ae461ada43417d1662b774b44c2aa7857551ae3262719c91b9b97730f3763773293a3c654ce8abfd08a1535e15b59383b8ee7b2969e5631a2fb99b84a6502e89f3116a9668ff2fba0bfe9ade5885192e74da880d30137c8315f1d72a339046f7f03055b7ad35cf8855cbf88e2332f8ff5f3389c8fbb3359ac289742d7c0e9ea28fb411f6f0a448c1c25749b1d63268a84ed5f3603929c154f5c2a35f56f41ec07090122c1ef8d14cbbcd295812601cd7335528cf847adbf8360a67d27c4af143f03e8fae5840ed22d6dad2627503ff8efa797c2848f86e5acb4e83fb8b82144773deb8fceada2e48dda04eba7f753e3d0233e82c7d323477ffe2ee94fe26f1bc4da34b20c24cf80839f047f33fa1d8ecaa5c09ad8f28f5e8ce47de5f9129f610ebec63d507c80c8d0c59d58ccac600adb2004b5507bceb344a018ed2c874c7b7bed90d67009751d28595d025ebe640f2c4af5c58a745d4c5011f233b2532c158f14879ac96aaf7bcce03dc451e510b9572c1aeb50a33c7b05c23df2102bbf388bc4e75b9a0f494855f17f798dd0720eca307e90d921acbc9343bad957da20a98b15bae6f8eb07ee520d9c2e4e53a7d7e6296ca5317f1b57ac59fb7b653aa24764202eb0ad6d296828756d6993f015ca110ad0d8d236a6433bd197fbbfd69144fb81d463be47776ecf8e68ce6f5dd0164e841c6ae87a5f19bf2814ee292efdb722f543244c1b0c115a367ba7b61d283cec7da8d7aa02fae8cf7309089e1095eeb16e3b943714eee3a6280fba1733bfcc06416151d4d4b97dd02c28a15dc658acc69f1715cd4b4c6f63ad816467769098ecfe040a0159064a7849c3663f5859a62261dec9e2263225dedbe2fd9db1ab4bd6af65563a8ddd89dbc7f6ac030fd0440221540a97f1961995f362bfb789325a21692bbd6690902973879c3c08000a906fcb851e5ad43e787f7fc045eae2d4d1820ca6f9fc8df4247bd5512d7d0126c1b38f6f94aa20d6bfe6ccff0bd321198930833b4f7715cbae552c4641ff83f5c08658f09f9d8188116eb1e739b4c902a18001b38fe2aa76372c6f6b826c11020f18702d3806feb076a541c8df8cabb415395fc08630bb2734dcedd1afb44207897be0a7742139f65528018c94f724f33b03f7f74743d15b29ed7dc6268f292a19c655cac9b81208271c88a4d674a50ea1afa026cc1e1d54fb088f3725ca1face96f3aad90608eeaf25f538b6213b9d8c6620192dd69cdfedf85e643fb275280ab207e10e6f5b9de77aab564d637812a153b4c3c670ab9228dd233bdf0ebed8190f26ac9e6866978b5f0d0f2c1ba6b8e05bb0c97b4fd2cfe9a6df5621d81bb2fc1a70faff9c0f4cf7c8027ddde5987c64ae95bdbb71cb2f3973c73dc4fda37d5b2ad170ab69678873d6b3273aef4682b8492e416ddbd800a898770dd1c8382a912e5d3d40b8cfc6ddbd951b0a8899d314612850908ebd28a06bf3b43503610f0c548055a9ae51a43e96f472abcef44b8908a0cd52b88fe18790474a8da001b77452088bca3e2607f544348264f2138de40f3f9808e89b5bd70a681e13a7b966b22d0419e1d4727555584dbc4225eab1430a6b51eb418410199f77f9381330bce895cab1986867c252f5c4792e2c69332e9ebeb43472102485bff840da995aeb9885c67d9418a76eb52b572823829161a8ae3b8d1326f657c284f83e87d2a87f00dcaf5443db08d584ab142c63327447adaebb3f316a4d5d20812cf1ff2b68e23c4cc44c3c7146ce8664c56d75dd6cb3b6fa20e16128a87c781a7246f05adc2e761176258ec1b5418a775aa57dc2c8a3667465cea4ec5ceb7d51651b9b6fb17abebee1deb7506eeb1b0a2acb675fca7c405d8c5db6e9cbc4c1f29fd6bd6d73a8d6d2dac8139021d8ac44a1ca40d0e6f14ec07e1337bd84e6a77405cea763ac0d62f7641a28553471c50b152fcc7396687aa13d3e8a8d09eb21b56e8a9f0286f84c821d5d8d298a1682b27017c4d0ac7395db529bc8dcd59db3775570d98409ae155c2a01adc126567eb56032e4ab9b7a148c4dc6cee6b6ec15c79c337b6117ae970aa0b000f34aac7357a684800fa84b2001dd97e3cb7208ec5e91e29d7faaa0f1a0d769bdc3c0500b93436974c00617999fdc6cb6ba19e985eec972a3b5e58c56b3568fbd5c36c62ccb527e53fc3b2c66b9cea8fc1174f7f1e1fe504a76c74b05b517f2418c8e2c3952dbfe95a71860c7bc88e8198e3a0ba8c7a254f9d4a67bba511201fb625c40b3a650ad13e5f4234c5f1b2f7f921d36a8f994e3f9db98ec3548e7f5530d51ff0bb30b9916aa1128bee8d3a13c9343e1e80f3a4c2f21fefcd9d75f82c23052acf3c3f181e81ae699a3f54e43a2da0fc49daa31f258a3d984260d8e1bea5cd98fef104a6352abe6dce535f6068ee005547fcb5180007e909da9624334b1d746562d3413c375e2567d35417c5957a2d271526a7eed21f8c997541463111369d5e9215c1377dc6ddb819df3b8e00b59cb4c098260f110261fc6f5b1acc2c90b20ec50ebea7629e8ae51e57206c2b34405a08ab5ba203b98445742c2193fbce5da3bfc9c7e537bad42c6cda153985ad9a4ba5dfdd4478881229fee3f5f77cfed6ca1d267ea9d86f2b3fdc6ff0a9e1002d7087c37287f7dc5566e4684633e0c028fa08c84789f13efd2329c239d669f07ad1415c4db3c04f3101519223657466fd2ff40a5ed1d382b653d3b06199e932dc6d969145d3d23540a26283e870ef7d15ed63c62039ff4c37566f5928778a86a8d1cf64c383f70bbcb713d9441c9acd290b99a3b41253610ccd70892a538f6989e698f7002b4fe6e462796eeb07e88653768fa7527edcba8197fc6289d09ee80c61dee36bc8e19786cd4bed802868888f2ede4f863ad14153721469cfc81958fe72eb2243653481994199761de9a448e4299e30bfa4ed04acb198633647e649d166724813623dc7dac55b62859d6eff4a5cf67897f8ff3e5395e1ebd1fb61f40d0058a5cd3474a664215ab496783fe93904594637f789b872a26c90630b5bc98bc9d249632b2e16569bfad1f60baaa944c204c83e4fe6861c72fe0a9363668ea2f9162dd33eaea7c5807845faaa824a8425b6f2e44f53b6e3d1cea4a9069fe12aa72ac9e1293f6d970acfd428bb726157ea8c822b069e1b8233c7d230b04163f5a3b20d33cba89a42ce2cc041b547a7c682ac7282d603f20f929ca2bc3b33e3fd1a671cf55d48232205078bdf31e8aa3fb0541468fb7e6c9920f9de2c04b71055edd20ac2db710fdedc3c5c32103ab6ced1d21b9be9b1c3d2a8ff5ba249551c0158f10feedbdbe6684d02256f73a2268f2473d767692686ea9c041dce4361a7903f949640c20fdc75080d37cb72aac40bb8a60e371fcace1a6ee1a954621ca6995c6b21ad9c400a9a58603bf9b2b0fbaddf55531c7be5fc24fde5338a13a62cdd49f9547a11328491a558d31a436d227efd5a6b2e70616eefab33bf61507657bab0ede6f6b49ccba059f3bf9366efac5d7d2b4abe21673306e778db4c376057036c04e88231cdcc499336813fdb9bb2ea6cbf705a6768779feb26527bb066fbce5e82f458fd785530a82e8f5c9aa4cbef0b726444b6e23e6ea0d14c71078c299f34602120dc041be239a353f376dc09eb622c158f53481c83c2b842c2f39a51d4b8969bb3b8e5e9a28939fb59af6131e06360db8ffbbc74c3f0219abf800475cb1a14602fa013417ed62ed264d55ba99f1088eb57ee68272d77eeb5d2c08597bc0471bf6eec867ee98a2592a58041fda6920945f46af4e441bc75fc4857eb8c3a945e444133279691607eeed81cc2912837889bb342a31d386686c160e415edc3f806167397e80cc826279572876914108c42e162e986d2b2b779d4c32d2276d82c3f359559975a4c6b15c8429fa6acd0d20403dc0f381bd409fa16a57b62a5f4b470f0886de15f793a52513bc57d1f760d2a62ad44a949b934c0a03526c3f78acee6bed01535d041fe81915d1403f7c1ae63e88065f30110b77f882e8920ec0dba84d20545afddcb35826864c2d7cd0e4e2bde148ef85967554d02988c4ebcb2cc4055a8b704c197943b21630f5515d33ae8e9825c86c1732c8187d1adcbe4f8fb2c4fa119073fe61ad160faccd680bc94ff7a47e87c39bfe4b06dc2b02246e067aeddba7fab8cfa8bfcd15aa5b1e13ce61ce8b9ab8a665dac8d5ca07450f8353e781acf3f8823f5b5d40470f5f6a5473babc4c1349fc6d84d23534a50f5b0dba27632163388553b1d40e5908d16bba3976bf2e80f382d41ff98ebe120ed2e18f272e7ff906868ab8882dd8c0897aa2a3f7ce03bf7356d8d200f38c29ece73f1a6d20bbfbaea546ef788b350ee855d3add4829281c9aab1b5d89b9789338221b95efe16e06b61dcc59c48cc448d56728ac1f94d081462ad818d000b2c8d06543b7a5bd0e5ad85e1beac32ce8efbd03693644781ec167666d79c419f776fde6c882f7423e75c5e81c7ea68bb569dcb1f1e80bac622722ba7209f9eb19a30d3be6ad507be79e3e235a38f0ef6088d7feb02d20856812829a8b51153a600f49e268e12900f28872c785ebac4d50a15f385ccfa776a53d3b0ab707b1aced95e93c0878c4e907f503d3c6aa49d5e643d4ffeadb66ad737050681b8955fbe28844961961954040a5095edb10224fa8725994bff6e7f0addb8783f20bbf63880b6132142719f70425cc301a9884c2d20ede7b5892798cfea36f8450976b1e2cfcf2ec2c693346f72b11733d721188edfe9fe1ea1671960c85a75f5de19f07d0f636557addcca2b09484d68bc5e6fe4764bcd257edf864daad79f210bbd66734432a425ac2aa9cb9270147139153f3621bcd855779bf6d3bc2783fdaa4bee8a27e6d5bfa48c8572d78d819519ff1bacc2351277ebc35aef8d4a3a88b9a1c233306cca010f66d8213fae0e1095c1d12d15a4c68daec85e8fa94198705f0f38d6485fda0109e757b574406eac3a7463f55c347d4e0436a810d96fb5c38db410871a5f7b4d11e1484ad0930df229536664c02d92d8abbffd6d9aa52acae593a22eba9f1c4eaa4d4586bea9817b9ed94879fc5dbeef5af2f2f09a0bf3ba86d9eb5a897658d56622efc04d318deaad960982b95321961ba86282806beb7a078b234158476f9f1093976b12d7b60368850069d825d3174ce8e0ece7dccda6c7229f655eb277bfba8f86505b0e0a61a70e3d48831b45a37fd962d6c7da41ff2a8035c64d14196fdbec2b9df3490b50f352bbf7d231e3ef622afa7c9f592305b4b1c021d33bd38f58727b2ff3979f331861b16fbf8579887af7ba73acb23854c18e5847f828a1d09db3e3cca8bf9f3d87d627babede39b6db17a8872ad88e825ae25a73329aeb0ebc62b54c8fc6256b58bf67eea42c24d466ee59cc87444c30d39e350603a761984ee917752b4b38ec05c2ae13f00f134c8b7036e602e0a97a72f8129b3dfe7fd3dd72fde848fd1f32664f793eb4a4741e0528c4d78269d4a72eb961e1a885533b6bed586bce7db70bf8ae0e4051742e20acf82783cf3445a0ac5a1661341382f90430f1b098e800a48b97c4ffb970cdcc8deb26c8ae5ef9e0d89111e9e1a30ada022e9151e1134f0331add3c235f27099cbfbeb5639523d879d80ae7634105dfe1be45b316812d6793a02dc3e01c7ee73ef7123cc46f08beaa1c5e083bfd767b51b0d4d3edc75907116402250fec98dfcdb652778b869b6f135c3ae9ec983f94f8813467655a3c9a94dcf807d79688dbc4da939e750bfc98af6ebfd761a8414adb314f31be9bf59e6a65e1d83257afd962edc218df81592659ced05cc63ae8952abdf8895e07a22d434360041819ed3debaa99c8b55e0ef693fdb288335e6e921ec1690cb533b9c8353436bd670f83a438a3048cb8032474d967e6a6856d8fef86099a877fa9ef554f99a2d179d73688ed8b6c9c1c66b05c6042ff33b9530d0475d938cdca7e75ba191cc5b5cd503a4cfc1ecfaacdcc221ed232696f254acbe90680f2d9343b6fa3f8784184078c7be4c1b2bab156a272e874b561dc06424e885b5856ff7653c2f8f743d7bba10127616e3cde1c91627396ecf27affb5e4395ca7ec73a3e1368f2515f13732a10cbacd2d911a86cd36cf68cee6714bad9c818c374f4403bc7b231054934889903c7e2137669e638d54ddff4424aaf4bc8b93337af2d0fc5231650a3f42d9074a9af8ef0a999a13ca2d5f13dd67318bee1fe1af88bdccc5cd3d399f6d19bf4f59f07efcee8b9de7993a211a4cfebf2868eb53c025b4c9b646e1b2153951d82911298f43bd3b512e5fa6ea452fe34577467e01330704014801912ffc6a47851e95e2f2e4d7244c7d75e799be05ea0987af50a13448b83c594ada391d2d9ab37396c10350dfe5bb6c60fc5f217e9c59436a4e89f4046abacf09b4cb35befceb689832efa43211437c7804438a061a851bf8e397f221f85ce8396045e0307b2b0a4198693027504ab3495cf847ba4140bc132dcbc102264bbc4adfc0d2e696932edcca07190e6851565e81aee5adc492d0af9fd898b6f8386ea41172bd2600562024d630dc41f54bc6b482df4323f67119cc5cec55e66cf57f6c8f53b11c5f6f93be8cecc00684f492a8b1bb3b597d6c2196ad00c3cc73d70013bed4e6ee01e2cc47140776c10be1ea7bc1b97b476dbd792f0e98dc813ccd0136af8b57fab4156851f26b8cc83914a358fefe87ab006e3a18846937445a6624c5116d4e473f9df3f79ed846085279e096dbee1580e8e4ebbdf856e4f54cedc3afcfbcf0271307b75ae5c81e082209cdac6bdc8d3ce58ee1bb57460b010d7ce9cfcd5a6b60afc76a8243dc5982abbaf3476eb4e0ad39a3146ba4e521975d8b23564bf3b9f210aa11a7ba07a91d60dec8f2b27719b8f30f9e2a66f91b76596384f7591a326c0d551927a6bf6857cf444ed86ff57fb2e4ff4bb00cfcf25864c0bdc6615cab14c2ca7e0f8f8138b43ba7b977d5bbc0e67788429b05a3744aa35f1a1bc0d15772dd6e908fee98062b89a217ec6c23b115a9033c0ce2a596975d52f2f0bea5640bca7192c59f4cd02aeccc45551421007c9b7980213adc92ff0198f400b6fb1e9af7dd5c141782bcb5e4216166edfd754cdca6f839535965dee2a7f09c488283c4ceada26377893b76adf2b72ccb1e6ea2d1f6f2370e6f8fb5f61089d75fe90759f14773e6d3d96bb24ea8decd771ed718a90e3b9fe6ba3d5675e6fde34bb6ecedb75ade49bfeb43af89f6176a492cbc1300eb7aa3ce73c2f7a69cd3158a0f81a64058c6ae7d7184110760dcd149103f48e239c8bee75c8e21be4caaa0168bce4e05a2bfc4fbb7f2ca83ac773222f7bd2431326169ee8260a65e312d9c8e3090c50aa19d9586d56c63d177dc3720cb18a9b2a3c9e886dc295ea501872c0edd0e57f1e77181728ccb1fb616a604f4a8956cbbb0762df80c79c36cb5587477d38e6b763feebe22b306c13c6b9e563ac00b03434d0e23062d8e0995ff7e81d0b103f94e2e5f153142725e726312ea9fe88de9878b7e9fee4a4945faf28913f58b025fa0f7404694ed3aea2564f352b170ea96e27ce38fdf02ff39ab37b051fa723af5995ca2dc8b9bab61cb3557b9a3f82340a524bfebab88adfa2b3bf98c8bdd5dd4fa14aa076515bea93c40e9e29b1acb00a9022a5107359a5b3a6769a171cc6618924d372c94f92c743f0cb13e458a4134c3fcbe518e98700a19d95dfad4921840db9bf46194806e74b6cceec51dbaca8d56d08d60d2761021191d22865e7606f55960dae71dccc600fdc640964e42da6c0458df0725d4215ce0ccdff19a96ab87c3eae576b0e5c0939a7ba5cf1a986eb8796899cfeff3144a32c50b6de788e4f644d4085d1b865975cab7074f2c4a029317078130c5a5049767968ef80f5cd2eb3c8d53ff3cdc83f8c79ce3d76ae0a7f1634d18673ca5b2cf48c6d9f6790cb009bf79657c644a230770fecdf595f595251049aebc4cb2f86e83fda4949e9a9838ddaa750341f7a4cb5df6c9605fc574e64df83c9accf993fd97659a4a065cea448d11a679a2598557b075df79639f7ea9a2bfaa8df0f11656eab6f89602e341b1a301e1ca3597f067006fadaa12ad4b0d89879d3a46a4a10924826c921ebd5009975392f3aa7b9948cba097fb1843878571bbd48b2f352af5dc92c1b27efc7f294477f7e117bc5de8f35618c4fb51898da6b755106252d605c6c58e19e055e6748487af2e62d5548f6391e1643df5b26a564967a0ec691cafadf19e5f0c34e689c4ca3122c0b91d02ccc192918c0f7380de483285faefad1f02b74ed7116ff8c16084faa17a3f65e3b421aa229bf72dfe350829d62286ae3d3ce14b96f524168db570519c3211af46d4babebc14929a724cb299b985a3d807ebe075d1ca0f63c139dbfee1d84fec41e0c97256b906d9bca78e9db93b24c604d84b72956c9e50c581fc12ae8edcdb3fa5770d9f8d088e77e8634622d266013fb336008cc354ba92d6210d8507c83a786d2480e0c13fc11c43c7d0eee20915bb2dafb73910f6e2d0e5721222ab77aa97bd54a21f00fc5a73ca59e81c7f3a4f02207ecb652fd80e962fc80969c9b41a4cb680d9c40283e6146c86f2fba717b8ed94a048e2674689736a85932042959ccebc115b75309d27f2d314c1cc78fd215fb2b51122ce3e061866117cbae5b88fa5b5a6d8f4b5ce9eee3f19d5f1a42d07e37b0528242cd8caa7ffda0ca0070bdc0cd5537b3b94e6948d92578deff09ef02e6eed87a4d7ff2fceafe79553ef99785dd1c2a4750d02908726a18be7e82d760d24acc707081bc862dd40dc720cc3643d3d818e194f431d7a259af4b07e4bf2874e41f88090f59efe4fc45df39f0f24945da87668c68e05debd29d96796b9309980b91b7f179219c4703c414c1d506104a74c2e265db6bc16336d0b8457b29269c56a26258ed0f6ea0678199cf20b6bea3b3976759bf77587adc18b6a1a769588d0fb488dcc6ad0c351a04d4c7bc4604b943b02d1cd4d84ca03181df4052568ae7fd0435fb018e629e6de68815b4020957a976ff0fa8357a0a3273e047b709608f75edc6f1f77c33a01b037e85ef539123815a64099bbaa16e9f2a15ed726efc15ad3ba33db14cc1e37d70dc944509300cf85a94f001769eb055fcc27c575629a4494ef70ee75763ce590ec249af95903a940a001eb09e83f91a572abecd82870290b2af6de24f96c7574142bf920276c2f3632de904447cba1b317e3875fd0ab7a90fc398d46d8630017c70b02df7c65fb21540915599fb89bab2dfadd90933fc5050916d09bf4af300f989d9ac3cff618031cd0b19daba742dc59fb5903ebe7f30e685d6e9d4445b4fd4999aad75bf61d2d57c9082a7ec8e14d701b3aea0af830545af74a108619798c856b5ffdd220011e53de71bf3edbfd7013187a45773269fbc43e9b9ba61262056dc58389295fc787996357a6a6409db3fd2ded48541c7bf56b107c21e7a93c90ff21e0c33b45e585562b05c6e907aa7b0416ae819ffed7406d581b04959d785bdf49efcec1e1f3e66c49fd995cf879bbd25486dc95ddac0c60fc67886a9092b03d2ce9cf4bb27c4941f93086009843d62f0ba65f95568763de7b767245cb19dca0db1750fd2edee54efdb4f73a51a8a643f4c15a0ec6bd98a15ddddc45e58b8e10dbf6f7ab54915d41d9184d5435a7efd80465f67368967b39723813e60c380aa93676df7cc6f12e97cb5bac3789985c2999720dea7686927cda190d41e2c771647cbbc3a9765fa2b15b1ebaa18b4ca887f6bea411adb9d1e24e4f8032d2bed153e2c85cf0e7d074dccfcf4bf637661c96be1e59646787f1e55afe84feab6ee1e2254ea57d9986a74b06f73174d6e0e6aaa714ab68fe55b5ba81e115821baacdd0f51a1f67e790e9bfa920d1b7c956c17801443563dce9547c9695afb02ae2fc92b9140e9889f5ce3bc7cac4785afd2d47f974f12f8f42434f69f34a8a656f305348ee7c51994916386aa07744cd483bcdf95015373124f47879a828f573cff5e28fbd68b1d2f587fdfa980a17d102c2db72efc7763d0449cc2b95cd83b8f5e901a37bf779c054acd032255111ab7230c7962721569d6f5e69b248fa827bb0f612ecb6f186aeafb4e7d68f0c2ce1e65340e37900e3f4d1bf6686fa9dcefa216f799518d52ce58f5d4af8fb00b635f0b75696b961057b7a05a0a8797f4a1ce79fee7713732a5fcc2f7db505662cf0156b4bbac0faedab37b89bbc426b353fa7f6440b263c3876fa7aea3d1bd1b07cffa123eafaef3f829e2da92956689f2145aae50fdde6f753d300f9669c144eefb7c572197007029c4370c90097fecbc102d79e258f88c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
