<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d96d4af069bf42363f979b517f2fb43b0922adac140ba3158acd11f0e16de46ef0f87d76286673952c1b235526420104faf3a504073f1c16d36e07e802154e0b2acee2d6e33c29603cfd8185251a202af1a1acbea126561329387ddaf25cdef13113079f8a08dc728a4d61d8413576f5f30cb72e0475c750216e33a3faffea9a3fb6f3f6f266d8aad550858b817429f54e5c5894f65305ef2691d500f7100f8f67274e159cf0ca2f56f0aad5b8c4623e11cc324d4c320575e41b8b0ca3e31609e062274cb760a9d95aa7fad6b53e67195c4aafd882327b5245791897cb6b6d8b5acbb6b7ca270e33613bafe5cd7e5a28da676fdb83dc75f95f44307c72cded39f5eab421b11613cfa0b01f1a7546e39b840fd5faa1f0f5266bf415dd7fc6c287f6c8cdd5ea63085cf04bfa43fe927e7bf9fc02b9865f90d9a55a4ac93a4693c9650ce870e8859bc09fe3a5c08ae1cd9f4ed9e022cfcb263c269ed47b9ad46528817e6a10ce174e2a34ddd468c6d7e4721957b87961c6234f3b6dee768d87b59c58ef35250e76192259976d637ca497d37459f200d38ba1b031881ee674eff7fc0660b1476baec1f48fb5246eedffbc6330045c3f7b0b227b72c2319d7dc55d8b3eee927d0e55934d753c07de644db21d49a98b789e64489b8786bf94411f7f1034760b25b0e60c12b6c7367e0e038ba8bf375d20ca49681f6a0a6e407bd55dac1f8af4395fb2be62dc7fc35665ef12a28b8bc66aa81b1208e659b5b66e3d50c119aaf4cf4693b47ce552b29ccc53286f41de8c43b68648d16f9e1cef4d359c277be372c5486267ddc4f6a07318b3a615ff29da59dcc4a9ac4064b820a81ff734e7a833bb71d125be8853735ff028dc162897a1c9edce82c9bc36956eadad0d6cb5a98e4a8780665461680c313393465966af44d414a576dacc5911b8689479d52c193c0b24e26ef45012a10a094fca098f0cf9eca65f26573c927660a7eb089df12e2b4fcf9b80f1a8928789dbd1d6f550b9f83140093cf4f2650aa8d033950a2d81bdf7952d38cc42928855309015004dadec865d2a188526014568e5b49b16c905e317f620df881b630be253cf041d9cd7018a50bfdd3c43eb2f16d3dd471e85fd290761274946f7ce161dc743b25a41bfb4c0f2df552bccfbf0943482352e3654a0a5930389d26ea71b4abe6f6099b0115c4f0b3c30fd84d3e3926cf72c50d3b342aeda0f8e67df4f8581ce4f362dc4078d4dbc564ac4eb37c0afe3e937a80d7b8c38e58835171a29f4952a9c1222c7c476639e461c1e56b3790a23adbdb9cd80d8bad9c31396d25bd9e44ac7b8fd65de7333daffd67e3b08d3375d73b9533b4706f8c1dcc0151e47d4b7eb16fc6057ea969ff91431041933f658a50e5d6af01231e2c61dbf41952533bf4b9c0cddb3f1ad06e79875829884858842fbe67a6be1879d5cb0f9a05231d99a688646a15c82e4983b86bcf2d63253d3801226dc5cc1afd83a46b2bdf3b23d45bf5ae6ef2e38b42990423d61b2ffef2064545b9548f8d392695535f683ed410af52301e16a0287c0172864b93e6936631a7ddd3165d0693bf4163ec7007d3e409431ab3fb3903f31e5987bcf01ee920f0b5bd01e261226a95ff6c86f9dcbaf82fbfad08f97cd2b216ea591895586e96f6cb665c94b66b9bed9c76d53b551e9277767120cf28f3146740d915e1af637ddfc752337ffa2227610e0ef79de65121bff57f728c09f417980ffc5fc7828c1c491143a5384a8658266db3d6053d07ad24697ba660dcd0ef1202b29267b526fc552601cc317062800dc8928e9aa5357e611db5c5dcc24db8a01c237eaad930227e64135a67d9ede28cfe557371eb3e16d1ef3e0a46ea5dfb4f742621f15c32423be0da1fa2453570d6c3e929745959debf8d051ea76515825cee4e95daa1e27b9ae5ccc50749e87b5a07f0e841bffa9bbb50ae347199bb87a5f481be036bdbea4755116584465e8a8ead725f8911b3a68df1ce952399d5deefe15a2a785c75ff0a46847b09bf265e7876d3fde597d3e91ac3fbd6cf7b52d84988156ce19a3d0291c92e4fe2e8d16570f8feef37d33715c8a099f64300d0d44444b3fb4c3f4dcf4dcd291dbf141fb262531b3ab63d983007e9ed32ad35cb3d2ac28144e895be15082007350321a2b953b8e3ce237004e66ef26b2751ec55f3d56dd5338c4a07dbcf21d6c67319055f8f2fd4284532ed9303cf4d6c8145630c31b32fae367e0e3c3b93efcafd749a3f5281382e51122fea5bd27fc56d0e20987e79fc1c61ac21f55d8971cbb7b21ad171e827526ad289c1277edcd265e1af396b056d17cd8012160b005604789ffda6eb2ac6a50478e99e43203ddb61634856781f99c5987d66287c03b7b676baea6be4c131f127029d91bb33d70a3b2a67907af1086fe690134f6a80f30a9af0eb48ef0405f48ce19084a405ca1fe32d481d2ca71213190eaccff73308d7a408580e63a72a43863fbc6df9d8b9334bbb319a76c831b389137672882fb0ec0c72471c26ae268b1d6c0029a97ee6b0d5ba7272a5932b1ed79ea29cfa39a4f9db416505d9c3f683deccc61b38b3d9a6a47755d604cd6e36d9ff3b119b61327f203b2ff09b8656bc700503d163a461d2874a2ba1dff01687dd18ae832114762d50d85a3bcaa7677eba24a420ccef0022c00218bc2d2c7332d86db44a53fbc9473a028662b43c9a90be4605bb56da9b66bc90c57242ba9a9691db140866f9311ba62845c1d247acc7f03d64f35886e6d532801600b8482c414539c63395523b3c61e0d12b230a49a10feb218210439db4ccf065b90f1ba2e3bb5ff3a061a4c45441e003b02c6ce29e267df97ceb4efcd8d32b633939553c22a8d2702213ddb1f1cf599032af47410caa80dc1bccd6643f19d211b908ca7d631cba640871d826f7073cd8ddf61ef6858705f040233cc96a167844d3c76b897decd0bbb176be0ee14bf5fd2e04c9ddb133190f34101336dedb801262c5c28099d9fb168fa44c42d044c49d8014dc4356bd51c9360dfb1b4c667511da347191f965cba8ae67b85b2c69b9cfbad7f6b892f7c1bfe24f369756441bb58c204e381e04c957d4e0418694b74712d6501dce2e2f9838266a68179afb32f578444f9951670248b277beeb3f4aff2c11d6a97e5eb2c02fbbe22df242f043cc8c28b1000a4e968408540e4bed58029e4b56a90ca934ad8b6796fde7ae72819e2d674faf00908622349b441f34dcfbb5e533def548f0bef2700ea7f5ddd709ac3960b940fbbc696868e1200c36c310dacd0613a3f9a4abb3aed939ccd4f72fb2b1e713e5669a07cfacc3791a3de03dfa91c3a3c2b73c49dc505af1e6ea623c927baad177a953e74957d6fd23c021b4fb4bff256f3e24b2871add083164c27c1e2b303e6f99acb2b39c6ed3e1566cc446b186b0965b5266449d346ab55ba48cf04ece17d1acd73d4d0540bcf89a79416b5ec49335d5970df6bc3e44196f22abcf4349e7b3b0b16058f08aa897207075756ffd44ccc2e5425b6b55ed17efb1193b2145a7a935ca86dc6cb9953b83847a5f9c791841e8c08ff7f9039d0b01c031bc1b05236131469dda0f3432553cd2d062e773ce8e8fe6c23c33c0ca1507e40361608b9b0bdc806276a22de4880f3834bdda04572baac557a5d904453858ab4f9a40f9e936384a47f02957e8db0093959ed0a0c07988dd20d1707e38a2de4ff3bb583b6a8993ab2df3cb5cc0a5b082f849122ff03d49189f4b3f432804d3e689d209d2cdf94e826889485e22a6ef26d6ac14cf8f13168708cec281292464a9f9abf4dc205aede057c34a864b184705eec689665b30f5ab17c98ad50c950e2b789fe7ae4dabcc3bb77df1937fe6f1fde22b9bc736742806f46c62953bcde16946ccd611bc89e50500ade8747d543c1ded276bd2c4c76fa235072f451ef327dc36885dbee19cfe2aa10ee7990c102ee213de1c36b398f8e71bbe79d1ad6f4ad8ca6dc67d2a7a0d4779dbfa97021a89449a3bb14db4880bbfe5be187b9ab2e896d146d6e6b61c8a39fdcfe2c87e5ea0464b07eb052a82e04a045cff40245ac751624de4da17b88a72c196fb3200a7d2d82997f873e26bc1ec580ed0b5bbfc2524af318af765a63ffdd49db44bac20758ba65e020858ce53ba58afe9543b1bd5cb9e378ad97758cc8846383f7b545d9fe9f725553a092d6eea2a8f98d6b438bacec77619a3f4704f02875078b11a8934bbd550c9f98f3401a71fc0fdf93f7a4e4d91db51b00d61d9151035b87657ac4382107fbbdebe5eb6c859dac0b333d79fa349f4f6a99530e9cd0ee79d4e0c32230d50b778585aa39e07f487a98f8414aa315555d2d7ffc9b223350c89fe79610bd76639e573ccd8358d8cbf8655b7f2b848ac82918bf3b4ae086ba9c801efd93be751155cea832493333b88b8426eb490a2d799c7fd0ce179b813920eff4767649c0c68ca592cea6c22620d3c672bd5ebe6154f0037b1172866bbf8e69d593025bff2e245d4a75fd64ea6ba3b9270db623a86c6e6c9fc7df846580ca8a67bebbb79ad225020e2891a4827c34abfad074eee04d413d4812c4ba3afad16c01c9e25b24e7bb2ac73ae0819b761fa306e2b20e33192900a67a790448bbd70f4f69bea84f449d6065696267d4bad02450ed95606dd8c75cb3a6368505dfd8426efd505282177c0f0fc8ec35d088f2cfbc06b795d98092b8681957bb5332140c24d190ed82a445b99c6bab99127b3c197fc8545a955d3de62860679aca13c1de7e66ed70b8bf83107b35b2524726e2a8f3c9d291604488f1b040ccc06a238898dbc6bd3841d900a0e87fc92afaa30c2fbec549f31bffee91012ce14e433aac8a9f913765344d1354248baec4a366040a7ed37075277cad197f4e650b9f2f3db85b0be29147d3dafb4eb40af5d82b6384e7a3fb37bfa515887817fd3039f020dc95e1460e6ae98c47ab0ede9cfac2b8a0c0cd7dfc92de5eca4bb5b7beac6d397ff5ed8ed2f5023247c51cd29bfa6507edbddee1f755fdb89900c52fd5ffdca40eac80d46986812658a0989f77d0c91a485b40b710eea9e858b4aa6e721c150b8fab384cc1a0c9c4ee9a6d6c87acc6ebe5a9bcaf7e0a0f59e8c5c134cb58e4973ad5021e8f80840e715616f0b67fb3dee89267094dfaddf57bef4ea2cd31f9c9f2cb054897172d0b1a86c368fdccb86463d75e082a071207aed50cc011fe58e34314b8348e565b1898a7ba30cf52250d7394042e88f0d9d8b865c42322c362f7a8d377abb5b842ffa735782942c795fb9246527833db5a70fe89afe0be77acbab2d19ae245c0d783e5a02ed8f8c0a6f067db2df7b640ef0c92f13c1a03e390e7ac87ad501ebbe94d4d86c626aedd38122c7bf1a5d8259ab48da61da6af801440b8b7209cb3616af9dba3ab6bd4e9679ea2e00dfb919aac314511cdb8cd24d61f1658cce5b4c314404f01d4c2e5f9933c4560417a6db8467c55113573957b0a170aa666ad42641ebf03de3d8a47993cc76401505fe3796018317aea75ff982e3064d3f35f31ccb14486dd71fa1334c8479f14937776eb2f72b42f8376eff387bd6982275fa48256d506e3aa3334f9fac62359aa96bfb93f5a2fceac79b3748be94a61174eb58ba524736c6e4496afe841b04193b0d6540188bead0cf3200b5d67b5f18a89156ea92a8de9fba503714f9abf50f4da36ccf503556b80606098ec6fdbeb4430d6d3f4aba08aff3c381394e38475eaef54a9efebf7ab371228595f4695a6f9a08556aea2863ae62bb7ee80eb19f04eed42a00c00edc3dbc3cfdf59df9933e0c3a890da2ab409d065c273587d973526a37fd7621427a7378aac57e695b07416eea9a37c554d7df9153aad1353cf21a1b4bd2f1adca6fbac35aa5b82827e4c5f92444ef328158b82bc0e3c4c1fb31141a4cf82291ab26da8217b24afdb011c53678b78021269fc7e043ca15bd684c257e6e92e14222285823d3387d2ab13d0e4dbc38868f44c7d1a86791cd3f19199119330375947a7a4cc2c07310314eff925e934b8655944ead77c94322da5857d26b8b47f6de84cdd4d8fcf366f71b1b61b9e990a29631614492667806bfbd79715ffa39f12ebfae1f188470f4077fa09dbd13b88acb188015052c8929d7fd4313c7ad778f833d508324a29f254eacf976c66bc743b2a9ccea62701f527b27f15581a384eb56a96557c3131d7fbd53c1749b00ee358a0f217ad27fb7d064a493c8ff2b8978ebe710ebfb066dd7a7e3190b3b46a35be847a67a47fdc230fea92e97d3990e6bdc6c821decb7f2fc280e6556d0440f8c16979e4f3831c67255c9c4e5272be254e252c32635d040c0cf2321191f7aa4c58289a688c29268abdc63f828ea8b5ccf0fb7786454de71617f8896e84136753c9bc2b71a4148a5b317ea6685c93614682cfdbab254648cf23a79599e47e577c016084123ab6237870123795e399732b212656ae64d6ad66bf35bfd29cfb994910ddda504d01b3b84b417855285e1ba98e06ba21f912d0448e7510783d97a44540f3debe7c1fe7e2f7642d053402763ef0f20b4f10ecbe8384177577d728da2c3571ba0db77d56271ed75eb0080d123f9e3b0ff66e5bae1ec4689ca36c3e636d6891bf9397adec5cb5a1e9ca5bb76db1107f5ec88b303c0b9248d054d5652a453b253bd5b77b860348e0ce614ec4400b1226a9692e199f2db49b41ba6f2bba20ba20a6c8e843024cea9c3879aefbc690f332ba481e16043dd13be36bb848e21cfcebb723bb73f51a074d16abc416e4aa3adb41e70aa1a64bd5c24f9452ad1e486941562b892b423654b5d2fff1805d42b486129118ac2a31f85773c8f40ee36d005bf449cca18cb8f241bab5c60eb9d420fb24b9c4d875ee00cc6a4bdfb2849168f0f8bb953d299ca531731f01688a2b06e36df15e4b8fb8697d8d48d0cf5a65dee324eb5752036472d465e973345ca40578a074c052c5cdc5c02e859db6bdd8165d5b8b60972b51bcfcc812e9a77f79b786cb68f4f6d35ccbafe73612b76bd22c56572e87177f2e1c2272b4f782959216ad89b5e7502c6d8b626a05ce8db5b734a20e31d6aef9f96bef3eec882ccba37088e14a001d2fad9368b5a44212a562f93c7b0f2d4e842cb71b0476048c62b359f2cfc8b7618d0ffba8d1b23b90cca6defcf0647f9ab9a92f7b738ca47ff49c44a721d5087937239f0f37b9d054eff855e9e3c9d885bd23c8ad4543fd5425fc717d0528a0accfc64f854389ad091062748644f5cbaf78828fea60b4dcd51319a4a8f03fe0022acbefeb397f62e5ccd2cc3f6f543002ab20003a138ce9dd7743b03583cb2db4b34274497242fe2a5d779b9b8beff0afde9d71a6a20dc4adab4a9fde72f5fbad9eaeaeeae969ba43df53af0ed286a92d4c8e20faed08add37443dfc36d6f5fc91681324683c816f215f522dcf29854d5811b3f8f1ff528d934a5800b7326ec6e0b7a05f1c289609aea911f3f3d59007e6239513d1e0936e7cea0ce8f254b0624fa3efa7518802d75063c0bcb4bfab297b493e2f3be8aaefb75fe757e333cdedf62337b5cad5a1e29b3fd44c824fffe286368c9254f58fae0653dbccc5689eff233c9f657d8673fab1988f0da3a6483eafcfaf87f0b21793c48c1cf80eae8773f610bab607a8cc0e60e924cb3138c0e6f3c33b57fdcf4877ad943aa52a9eb221c7f34926e8bed2d67b0fd2812b2945dbcb5fb3f8dd8eddd6490bdb649a6fc7d76ab3dedb26d3357e5853e22b271af5c2576d2a1ac85e8fe769db3ae70e0e5bb6ea4ae3df97f3ee18e657422b68d7a096d4d960f70880f7bd06c21a45bbe30f914127aff7576fff43d93c18c8fba71198820fd943ade9b6715897fdc1f87abe5a0bc1136e1472565cd4009120169dc6b9bf6aaef31a9301f289b1e14359305be326233d0d4030f8eabe22371b49f4f2373a1f2c4406eafe5ecc35f4a53b470980af224c0c923dd160291456d975ac34c88af765fd6cc043555445b776fbb297cbf5cf252811e94867f0988aba0ac2be339dc6654f2f06c6a24dab31a8c45a430692bbd5952d569c54374eecc34085d441167cde6454d733dc7d828d5f5cec9a5fba25e04c596eb2cbcf5dfafe693402c6184b96ae74ddac8a1b6f371f9c8602d049c309ad2576cc5e4c755a39a5580cb231c10b129f86b43ae791d010878b317994620698c995b88bfaaf4dadeb6f659df7c886e3413c17d97da6d98fdee9bff421ec575bf37175c5815121abc41b2a4ce6af0976c1841b1df327a07683375200aa3bd3530b5efdde2a87aed5bf262832159fdaa2a407bd8c806d58897a9d1c2722117ed886e368280c3bf221d5c5bd4ea1568700b6fcd41b324324d52d5948c7a119576d3b35c99ca95be476c55ae4492e975895b270c8e4ac63358d00ff040cc823e78600f47984a0643f23b37d694ed92b40c2305e825a90ba801c48c6a98645f14a1342c7de5f49f623d5c86bcca522dbe6559df57bc235f8d6aeb561f1753f9a0f87607d9393a4541cfee6b5bc8491590f0cbd75140fadc8e498243ffe52556e4e00e647f0dcbe63265ed516a89d9aacc26cce4284829a16f115ea24f09aed9f974ad2cd5cd64f092894f0d74a008724bde011eb94c3e71c69141385b01b65d09f22a1d3285ab2f97c1c99c803514256d30af14503a2a5946f9dbee1284b5ac5f1ea87bcd1ad6f22654781b98e5442e619b67e88baefd507f3be252134a483ac08d48faafff9f0899e65f60fd2c345937b3cbfe806a21df169b31264bed7c45c3713b876f9e7ab8821bc7ef2a7ec79176a0d8a600ecd030abc787b1cee585d8232abfb2fcd611ae7373474c355efea6ea8e5aa9ab41e1e1815a94863e27a84b232763caef47bbbf5d2690b7c566105c6cf82753eed197b53131b0d39aaa691d6123142c8162ba607e7ab38d61554fce6fba62846b4201cf686b826e8aa7adcd1df4ada83d5a0dc32e5ed92100239739ba430173b3c8c8b4890d98e8788c12ae5ad54989f5f625ba904a60e56ce225fa051e6fc0166d02b346a126bcca71d36db71a9b2cf424bd7bc039708b64af22ed9710f2a9efe049a0252f67a34f5c5ee8a9800958d50e3ae4f682f54bdbf12248d19c79d06eaaf3a1167591bafa2346e7690fdcea6e6929d710376e79053fef373b5dcf77e65fcab0329700895c3b85e6fe28be29a0e20dd098385c7a1608b57087de41a1e6679c95702ce4e1c0e17b0531a7e18bb3088212318615d11a7dbc1e029c8b806ce7d0d35af86c739a8b9e0bd0380fe5863a9e4c54b3c4b5670cf63e40744f19381580ed2b40c70820b376abb0f37dde4e7131547bf2b9a9052b32573b46b14e0c82184d97d211f87e307e365df348e037f31d7605d8bb261ec59858540569a22c429a3acc661ac9e507bf84d3130691f9595005079907cb04f3f8596f87a8852b72fb6c8b5dfc0454a0227e5bde8a1498e0b372e084f57407ea7189df2fa3bc70577ae72a0286c677694961e771c0c35901a315744d17ca595b89749fef573089ca491ae4dcd73c8b0ca6a1886a5978ccbbf2c0088224fbd5eec6d0e7b3d2e8f7a61944489fad40c8b1b4651d3cbe677690ca128012b9168cd3425e1a54518bbf2f73180c7cdd1fe9f0dda1ca056acc88e1ad5e14466e1c6a85530f5cff425a2d8c4d41f2ecd980573604111fbc3a657a2ced120bfc2b54cd392c7c09f0340f3e16e332a335aaadd633cc9a59ba0f71f371f2f105296149c52df26654dd5a0f8afdef40fd841885532946d2b5d75178f1e3c2f07ef84e6322cd54d9a0d7826e3597baf384501a2caec10640c5a33286f40ec277c8d0851a51229019293a1f896efa63f74daf83354bb7b1734a1f07aae79aba2d83aea6d454f4f9bbfb82dbec593cb2355cd4c331660f406462cd864ecb6c639a8143d06d32dee43b8c4266d27a9812231e73de104db8eb514ff432dc20767f39736194d7012891e41513d9830ec9477235ab3cbe13aceb65caf09e0ac1655a0a9d589a4209a9b31e509c2df3012d53453052b8756333723bc05377a9331a8f53c399c3e39e494d74150135ca1cba498c1c3718710fc58899eb438de67a6b3db26cce802f6d136d778d3464c7e2932366792d4707d68ac35e5b4be47d06f2ae9998a766f7df436d5226d77a80230e1128a1a274e427d4cedb4aaaff2968bd65d5eee3d8188196263974368edcdc3435047d5e74cd808daef864bc2590129150d75655fa6f55eedd35f97b505d572a2d9895614cae9cc932d49aa10c3ba142c22dcf2a1cf40f9a071a02967e1480a2615730514397c12aa4848d0d3289813ee81fe42e293d928c87b3e5e93c2521bcb6dd846719f9523c47ed0ced544c6db608ab3e123c8939cb8e76ea6e8c1a0e3a72a923a7d0f2d3dc1430c2a371128df8175f34f5fe13eacb7303318e42a7265d0e6c2d9ec7b4aca31ab0e96026a72e7f9d57959fa80411256839ff157943ed1d605e9c9f4482e2f980609827e379afbb5d6595cb99614cc49c17f548d62a5f590fc82787d4b288e6d3c823127dfd3b8c14e0ac1ed4ce1d888fc2b6f981c75852009909a1101d58b1300c5cc57e3989f2fce6a0f237866baebea17abb4b9e6fc5543d934f6560580a2898cd9ffaaba9cfa3bae43a7d196cffff66a0cf1b9f1c18e45fc1a561229eb63fa464ef60aa9eb3b70586042d364d47467b46721806103ac6c7108fac494a573f195a0c09ad5eb5bd0637244b5b6baec97a4e2a3a547f6e8f6db03b7c6dd02b236a3cb7f75b33152cbce3e0c83999477766d97d6e94ac5d97c708605cf1b5528fd6621288c33bb4ff7aa293d7abeae2d160a7fd798374280c683c522eda9092fa9f09cc6efd669fd8f25a96ab4732ae82960f5da563474bef31f58606a79a9cbf71d280d4d948624b5391d81dec8089b6cb547ecef97f76ed436851ef230c39d66fdf7564f10149f937e6ddb39d65c081240cd0913bc15de74a8e181cc62a79184b577322a714ba1f3582f7a1b1ebbbfcb0fc8c9b940f3227e9cbe10cd98ea95db9abc55ed8111e0c66148f96c6f0b55ee1aa433e25de3c1f7d1f54f4bc4555fce2e5addf5e577006a5b487194aff20145296572582ce5bcc9833bade487daa57ee49b2d69c8d8dbc72c745dbc0b838dc2f2679631a80be2b6e27e0d8c1149e43a0470039e1e238dd0d5a9fd2981ec12621d6cde58e1e0dd7ea84c1b59b1c1b7d00e8616768d53c14d57a56eddb58db16d79ac2626fa36aec3d3617e629d6238d260cd5c862dcc49e8d3cbb9fbe99628e46a2b1f73d70711aeef9ac9f8c8c737541a3635370ca7cbd2c37929f651b15c16feeb484dcbeba5aa199778222cc5919c2ad116a642bb4d2cf4ed7235a87fb812126e4a6be326183ecaf9226694340ee1e646702e6c0e9f442d6275d61e08b223d13f435d4a37ff888bfc3144a8a1c0c0858d7a472f6cbc98f15936a453353fa2132f73aafcb93c73f3b837ca6f673eee3379e3f386d84ed4560324c5d8fd464c7e16de7068ef6b86b93314328f76a71254e5e5e07e09710abc6eff763ff5cae61908e2e306b3102bf2febf90f369f51dfce820ec9bac27d75dbe5b13a204eb6ff9eb9e209032308e3fbc804085e8408f57a5d93c0b1ff94bb60ed67cae28627404d9c1abe4f9c00184f6ecd024e1f6047bbcd0e252e624fcd01df7f22bc7d67e210d4aca73ec02a24e81534ff43091e11ddb284ac57c85c9d98342fafc4f896618a300edc7a143461a452cc94b2ef222860c17992f37817b9e157f86f80c68c0e2bebab6a811f20f466bec7eb3bae2acf1d54dd816b54cab0742ba8e4d3b8434edc95180b4b617e327aef41ff4b90521e5fc041bb317ac88928019abf618b7a94b1224403d70f5b343ca6f64191352fb9874226df0fc547462e476367e198dd61dd8126fc181f389e1ab55797707b813b7847a95ec3383d15dee536eedef0b4b671203e10c9317ae2d3183b7f5f480a23f5f0971e806f4f39c6a30517926b3658bbaf1b439c87fe9ed344c87589e448e58af34336b1f1e19bb66a05a95e6c4cf982acc5949d7d68cb91034242af13028e2e89dabc18c9d9bb814d4407c0c58caf068789a5f7634a940e34a3944617aa4e1b5fbdc7b2dedc7b212d7654c2a695e91415331a2493790d664396d488f83f00dfa69fe5081e7a5a3bc8e37105c0741f67daf3045079fc7f66a08d836dac5fbbc26358fd5588cfb82b012daa8aa8ac247add91285bb7c0ebf5ee8a698316fd7b7cd32aaac265a46c315cb5d99ab5e381a25efa10f14d2ed85a46165047815916b078e2ac2488720b4cdd143b503eb3fda5bd3da2c736663f06b846db29159af070524e2432597f8a36fa805fa8f5f5a997a020acfff8ed7f8ad0ccd7da8e9040e3c7d46ab4db7d89eb661822bd07cc1745787308b7f01054018aec03beed96017b8ef0950161f9a715029a8310dbb454b277ec900deb64f01705d3a0fd7788412b9fb73563a8dda9a683672e63e7f55997306aa70335184887f18b9d0878d02e730046b6a7a4ef124899e22a1b0174ae802eb6337d0302ef3fc89c56cb4d9ffdcb5a0caf6a899b608bc8cba02008a7449757ca27d274d1f0c01316f746afdd8063f3e2a109827e37784864c785d31f30fb312dec6b81087cece84cace400e8bc04b1b326e5ccacdc3d85fe904a4eb682998f965f22d91b011c7cbc3750ac21487e225e6eb0925142f6ea0c2ac90318afd57e60c9fd32232272d2dfa6f991e34d56cf6a97008ed55a60425779fcac55253bec6b891b3d5fd9dc600daaac9faaa4a54100844fad11ce22a86622a9840df4614b961a241dda88891236f8dd3f8ca20cb158660f3768780e3f1b366dab5e13407ca14368ecfd87dc452c2efc8a83f2f1906a25a19a052e86df1a18a336d6fa5810ee402dd4a0a0e0816ce666b78e403333848da989910e1416c0e0adba042c5ce54e87e621f8f2bb7c54668ea265966b9d95932a53cc47262f83f532b49db523c23d5953ea874a5e93ac2778997ef80c5d366cac1955a8d3ee5d97a69d5aee02fe15654eff687e71fdaa261d628df4cd13055ca4cb8d488c595b002a7e874091e4feac3cfe96eddccd877d7251e7982968e4c2d0a4f622927f7ae5ceffdba2abd61beac094be6756004247abd6871af3a2c903d94460bf12acf8a4f21a59f9f2a92f2444d76c7278ce22335c5acb380658e093bd236ca47756aed7ead4bc201230af455ffb10a06fac493ab4dde6c5c1b1cd21b6b11a0797729ca57d9f4b6558a43cdbfa4d03825a640c27f2671fa7cd2dfdb8534830b2d3564ce894ba3b89df1d038aab91f770bed215a6ddcad43d47b00a7b63f16c89eb070df21aa9880d7b8ad14a03b81f086352d0a7d5ff76823afa97bbaa26faf2800ad4e82ba8be6a610337e8efc2b91a6f66505036c3d7f1f7a7f459edff29dfe17e77f002a25cf49b378d4a16221c6afbcea3f2e31ffe204555c2296c6d02d619e6491a38129ecb651d4bb5dffbeb1722f7c4c2c4f0013ab07df71c24cddde4b49faa9c01903c5427e3556f7953a21820df195a7713e672fb3f5f75a552788bf2c1d7afbc7d3f68975c600480ab986306360d1b5dc7cdf8f404ba26c7cec6c590802599e7ccd75e8c410f852d9ce52eb22c9090c90d6e55ca601b5d4e2070448cbc84aef94f06808f47ad03e2dbdc9548d71dd2732a36a38cdd8861a96d272d1b4029ec97c46518b5f79b858c9c65a4eb56ece75700b732470463d258238bc7b0cbb15db5edbefed7fe7ae35cc6be020a552fdd06cd196f5958b24dea3663077357da96490c85c8d967790ee746ce62513a8e96875121266b6ee46b06a01a4e05d63fa3aa535866f25b24fcd0a6519a813a2127e24cc37d4cdc1b9f3f2a2e061e7c4f78612ebeae0ec63430d903be98a4e2add366a28d399d85e7984e5c42fbecc5861b6401b146911aaad4f1bf058d35c19ad553435bb7a450676a971f9b15aad6ad19f740c62514bbd85bbac6e794e6955da01505eefc4b1f7cc0c3f795664268d8b7a24c38b6f69be74fc06a9e5899debac4ddce97d7fc1a9b6a7ffd372129a53b244575cfe021993e11f4dc8f5185807cf656f8477d9aa1660f2704381ba84254cd2a2eccd00ff57490321f550242bfc1b94f4256c99e74716e368f48924991182264ecaad9dcdcadf5fe257c2090988705d84a07821a090ee0b33fcc37d0add4ccef88f57e294bc42753321240cdd2abfcb308b8661f684fd437e1396234bd83b2a9d54d0a6d17dc3a9e8f8d1a7b214e801dc0b7ce5478497d3bb58988f480ca532534571abf8396cef04cb2cf2a4900e11d445119a357a7de7a67b87a985551902e21261a286c3958ed847302dd8497ae959707623c69e5e2b82163cc801c5a6bce8f9c62b2b3cc228e27bab8c244775ba9bf2d45b162f3f6a96dfc856f5123e9438089b5dadef0a1e0ab10c86ffc2669cc0f57684e0c340106bc22a80e18eb6f7e010e215b83d3bc27256ae77d656cb0f5a1143f04aa9168f361b9d9ecc1b2cafe60335d72ba0e55895df561d75566695ede45383e8bb4288983802e5f671516cb210580844fa4008394a6d1587327389b298370fd62800690b1ec31e34ce6934190fa6e6c042cddc9c5990ac1b9c5b477bc0285b20b54cc6a939657540ee56ec5677281a6950451c4a100c7e6a793caea5fa475e92587abcbec85360a5ec06f92578e36f9466f9453cd82ceb88d50f72cbf54ad4d1c143bc20791c5da191855adcd4c622d013d9ea8718c9af1ef464c947d0a2377e0e9eac3868b0e6c81aee1617871f751e963e175be6dd873047f14713f05340bc2a41f3ac422844bbd84e8a05979663c55a7683bfe3f2e7c8ef3654c7fd2e77e855476febf5ce604aef2a8d5a23de38cd9fb14feb3a6f6cac35591723154fa5bfa2b4fadf7023b0935a265139142011625ee652a6c874f219332139862667791fdbbab2f698560ce39290a9ba585d472c5ff7feb0287f640faba4bcfbd1a5b174440219491b204dc366c65c3e4db4a38728aeb2f372ea69be4b2ac86c7bd2ab267c5bd93d54402f3f170fdc182c449b268c822cf62c55d9c11bb16b59fcabc97d7b97a9474d3b26ad729df9c7478ef5a45e3ebe05a6c248d6b6c7f6deee248ee0f8184daf88a0d050703de5ecda431db6bd8faa00c89cb88d3560a1fe1d7932ef7ef08edf84a82d573a5c8ab37ab06b2612bdea4f7a11b3ec37fa95f1a9ac56f128892b5ecb255d81b41119771b5c14adf9df22c8d1b8110126dfbd911a7d8f582f02232077ee0a611a779eca5b0f561fb7143af9e9dd9c59f7b2eb1061c3120640ef5b7eba83746dd92a703d4963ee1761632f9c4ef8a75bab7173c2fae9a9ab8808ba93763248f41ae820541d41fce16c217fd11ba83c21fe7e4e5e2bd36f4359fad93e33e66fdc42b50d04dff1b259d5769cd3d20956f0e5c6c29205e0721446fd3c18ba295a7bcb97fac07829df9acc0ac96a2d16946c0fd40bd09e12ab967a6b2b64860b942729476277bdfad7b836ebbd07a4707ec1940bf6f854f5066d4af5d0d9bbf79cff7396382feeb2851b037377edc176b37a102d042edcb24f49db7bf0c330d6f1facf16b4bd9228cc4693f9175c8bf7d427b3067a08d7a5156ec6d4ade2e97c06c21047981de19e6e28c83d524b85baa7806596a07221c93e9ec50492ff75412775f9c5d434cdfc8647cb7e0051628f8b9c281abe45bc22502a89156a439eb2ce7ae7edb227febddb14e131d759d74c5af9e06ef20fe879e643acf99651d962675a62a06ef8659b327f019a776e36d93fd2bba289fca21c2cdd5f31b8f9fcfa767b31a5138188cf456dbff9f75ede2f5bcf5c8f5fb8ea01b233b1c41e88f7937a83f424af5db9b9714f1467b51a19ec3bd94f0d33a941f109f5b93f9f58eec30ddbeace42c6ab06e35e308e0e6baf2774e82fac4e99ce602f9c13a4c82b55d411fbb7707519e0a6cdfac9a9a733a0046f30e0c626e2478efdf64791e28cdb700c58c6ae1e0d1322fff991506e0fe37ba97521345b0de69e9b39281c8a0754b5e51893586e670d677a6879d2dbb882bade246f317f2316a52df406cd4eeb43075dc1254e1e91b8fc1bfe7f464e4618feba54e1c3050913c2c55b044c92b66ba480dd0b5ac81051ac6fd0e81fec2664de925f9554c0c9e483820bda0a0f90ae869900a21f39d2262d3c5540124417eea72dcf50cac164067316440c9c84077de3f4aff8387fd81d162ef267ba71d1cc6f291a1bad48704913bf0295cecd71eaee0ca43c01c1dbc68eefa744ad49f1f0b665d681185068790213c735d8d26b03b5ec4f3b6ea18c8cb89028381bc5287e5b79aacf5e92a7e336ba5c53e5d31b6244997a2116e45d7823b9aac3e04af044161514115c00e7d03fa03285a8f77c25c1833fbefdd7389c7a6a854b58cd5ed2088e8efb6d7589d7d2c6283d07f3231095436442694202d1afcf1c6b94fb95bcf8875bc9dc7af4a0d15fc079f4fc6834fce0f3bedf8dadb498aed748a9ea9f1a69d8ba1d0d7b8b7cc4bea91c520cf4f54ac8646e1bf393d099d054f245ee9fd41e1e9983d85cddd76915d2e432d9c800793b3ce5d4169891457f7f46e9abb51f7a50eda026565b7326434895636670e6c9f2719b29864a27674bdad3460426e6611d3796336e329338d6d24359e54f8ff64358d007ff88fd7d8884d1cf93aec551bfc111f1bb5d126acd36ca1840d5d8c9a4df9e9f461dfaaa12616d51fdef955a27de3dba5f0233dfc8d3a8e8724af03bf20dac4af9ceb2b0815df55bc3985c0d9188219553e8717a8bc4be9953c0ee6230ba16e351359c32fb377dd5b4372b5dae707084fffd96d90db7217db929e25ac78149823cfb1caf0da00f79bd47eca3f4bff7dac6dd1d3a4674b090ed00787c071020d88f0128d671dd7b25ca4e3824e952a2383140e3d9733c72c02c06fe3e9e4e93fe4215b593a781828763b3e2568b73399843a0f79fb68568024e6141a96e951e7437ab8d07b50022e512bc90bd17ab7a93015a21d15d9ddf6bbecff39d93d4256b65b3a885b98dbc65cb3e34214ae92fe6e85dfab55e9bc7766fbab590943e6e4d911b16b7da9ee3471d26968174e1c2345842de687ed8e607e88b10edff6a488822a4205d2c8b8bb289429ea927af4e4e0e79e8b47dd9963a624d171bb5d84c2b8c4e18bdaab6dabe1c0fcb67f9512bedd103c29e4bf90db71a0d5c3a98919665053f8a365d73f245d5756a81c1d74434eb7aad157b1c04938a0f422dcaeda1862a21f568f7dbd5905d8e241eac8e9a9bcb0a727cf0134b0ba4a3e03f81d9edb16618911e9ad28bdbc29ed8e4f7b6821f0868d58d7377efd5e42ad753f0a4b6e211f077601a34a89431aa09ee4592dbddbee5347cebfaef3ee6730bb63d46bcf79e991144aa987023a23ed87858ec69ad55942725bade0371c85e630f338108c29d422e673fa1cbaa6ecf2a5372ffb1f27d501585a783a2729e1e21e84df26324b115608d882fe70e5531c15286dfcb02663fb0b63287f68789d57da973ff3dbb2ea60bc4412c089d26af5f706c210e018a210ed100cf73c684d941d75cd5b9a55ff0f1146dd9ceb51694d8e445d9cb79a930d71712b222782e90cfcde421b19e613386cde1492bfc3496ae7aced9bd61d157e260a3d3e97576f1209fc6213565c0acef225e0d7b1959709f39572d8f7226738d29994cb24859fb7700103cd890f5a96d15c035c82e5412316c481658ec2b10b88049c50a99501568125a4a2d0dc234ecc4fccc380f2f76f57ce9fde8988958171d9c24862c36b45eaa2a2165888b760c8c6563b593ef4d5cbd27a6f95742037bf7a70c5c3d8885a3fd8815ab6d3d71d37562111743f199934b3bdc041a2976414707bbea096680c6b95d36bcc4b551f94c520ac7904d898618a063d5db4988ad3af43191ed4e71109b4c9a20368bdd39c1c248375465fccc996a65659946957a6567d109e54a97400d7746048badc8febca37539a0d8e7d715c0098fc4c8b921739d35d5831a12eb05e1da89d020f3507eb74d0ded74ed17a1d65a033d488cab5b84cdd7064d8dfb6bbf966bbbca6d584f310dd8b16215fe923626f95919a0a43bf3f56c88370dcdb53522cf35113f7a92f5da2cf02aa01950e51d075516848bdc2021ba38471a815bf775c27145b395bda33fd072b7e030a3d4063b48273d71887737d28482264312e6bcd362802ae421a6e6f47362720444048d3006c82bb9c8abd32d4945e7528be6ea10990b28aa687a2abb662b2ddf1bd17e51c26b2e56e3eeeaeda87930891e9c103e287c42edb52a2bd369a0f76d56551a164f8f98c82253e1f069a4c4905778167607f6415f4930eb3812da6a8a857f45d64d5da76b53c2eec3f41e34aeefac6016bbac661b73e8ebe22b30d93341706456855cf7c5e2532b0e10fe61c8a0e72f03b1167c482c47ee38f25f0caa65866e1cccfc610180be22a79fac9dbd9e92ffcc7dff7f6a02603caf3c4f8cf3f1082dc6c6a80830f6635c0ea145525da27afc7b227375d4db85d2faeeecaae8d3fc385891d1dfea970a5a055c4a05a435d101ec414b0d5072e2d4da7f606076ff6a4ff9c54a6e7f1d570d4e131e24c84e46acb6b27720dcc9adb7b56679a1129b3b3a6df682b5fefaa18b49518393a670a1ec1611b88782c219089ef8c1fe5f434f6026b9e62b3e8e44cd49e48142b4f1df4ad4d91d624ba3deb05edac305c4797719f1f85197e840e05644e4da7b3c92b4eb391a01714caf57cc84d9ccf6e3bae9cdec99679eecb49b02437184474660b4abe951257b4d33661c6a2b47d1b589bb6eae3d481270de80d5d95878956115106d8085fae002c1a76f0daefc0c30d576fe6ebe0c16dd9d5bf1d6de23b4a4e80f2a9f3910293018706cd4adc31dcd1940512726139f64db4a526cdb6b221b43698d895e9d0802cfd6546c26aa93ce4294e9595925d00e6d38e95a1e21cd1a6b1a4d692c46d365c0f6532f565c6b931583c6ceb067bed98a89db7983b749014e17f0944036613fb8c43e6f7b8caef9ea0e8c5108b6d65bcac114d88eccfb560cb7ec5951aa8e7665c3d1d0642086ce16d4907acea2f89b1ef6cc0fe54258e26e572ebaef6c346c4cfd5c9ac9dcc258ded9f953ffac5fe888be58ab2f7bcfce4df44b8be220131a455c697ab243ae69e50e13a7c06a44639289f042e427ac264d6ef9d7096e1fb7a3c428c2353abbe028f511b566ea9adfd34050c7579df757d033146a396098e97a53556edbb1eb4d6a194194531465226e5ad5cb5a2d4ff487f006b526390918f2003ad25fcd5dd3599838435f0528b41536c6378d4565aee5e2d9cfa98d3e8a8d175f8deeb8256aacba52dc4dc9c3be6dccd07192945fe7ba002e9ef50bee1cc6bdeaaad5c6c1f08775ceedcb75fb5facf1dbf2cefaa0287e15d1cd4a2962f4208d36e4f53da7f679e0d1a4869c453c1ab1879873c0e7ab5222675d07a05037dea0f170a8f8ff8ea339be5f104640d659d7f0f18480cbf668afbf75f93d88affd167f0d346cc682c2e132ef636af5c1c4396128bca0cd296f93352a83791b73abb4159feb2d1dd368d7e66d15bd5a58a38c5124087fe65745056b9ac23ccfc96366c804a90b6ee25fca915cb9b45daabaef2c5dbdd72d69e53e27273c46bf43e778ec60456c4ef764ca01133d2ccce8a4c7be02971c9b0522b7280c307f235515d1c6d52e1776ee6c67288c056bd86538a3cf77e0069c2804947e01f4b13f552ddeffbf4b428942678f38aab07f053297aadc001fccf6c54995ac89073e1c4940c8bf5b193fba403bfea0318fcbc76dd54f96536cda2408e5613809d0eef6161da54b9a24a98aaa53251e73596a98bdd1c50120cfee9be324971c1444220b92bf166cb10e4fe3eab2966f347be33458866549f47ff45fc1209484e1e52564cde8deebec8548322e29241313035a0ac473c21a67b7ec8024ca1df7d4a19cb0d2bb444ed848e412c08b19ada60b13b5239aae8f195040edd4dd24cfc20087ce2e7cb3b445447bf5a56d04be9885d8cb2880c51b019a45ea0fe482a2e35b871c43c0a60db0d598d9d8ff73d9e57b6c2e184d939137ec791bbf20a220bcbed71835c1b65e1e26d3696ca12958e75853f965d12bc3bb3340f10cf870935e9c95afcadc6dfd20680b9c7a36d4b229c7ce6e81a1ebcc36cc7206d8d3298cd13fae6c1f1b4ddd260acad4d1dfc9cb888ab3c3f4fc07c439a2769746a9719dccb7032d586a3dd9f40430a67a8258c8db9b5407c50671692994746cac8f8966ec7bfaa82dc7b20159951cd63ede55c3dca2a721102f9d138b01e681c3ffb3b6656cf8bab7503bf9f0b08c8a0b1e8633f6272428a2d7cc5d383acb0216a6ce467059cb791b0dfb644eeb78ee16be5ad0121be32b82762b18d2586f3a4c433e6f4b7cac7cbbcccb34d4e57e92b689ec794fa1bebf8b71c1a203a26a56ac119f4299acc30761584725bc3dd0bb83002383a96309f7c109e6e3e4e1620f0707f5975b91a938c48a20d37cda20900d86d6f71ea6011d29a8eb17a02c456de7afe937f0ef669385d175fcfe9e0db75977c98656871be70a265667f406005edba4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
