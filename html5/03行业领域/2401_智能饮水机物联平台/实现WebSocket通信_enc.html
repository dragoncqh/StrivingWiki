<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cfdd9b4051663e83ed03496fea83d028362d1ff0316ec121f5c100a40e135d545e8bdc7e3d1074f19c5019d0bd5b32318ea8b7c40fb4fba2b5183e065f4964f8d3a3d78ae03410aeb1447f9b854663f812056eea316eb11067139f8d73838c70f982506ea414ccda08001c5528ac30f6a033a40e5d390ba48324921cf84bcffd0b98bedc624454cc1c545f731468683e1a7849aec9ba817e017cb04f27cbd64fdce4183368a3960fe16fc4bbac9816bac1cff22788b21baf7ecdff02c2e35ca788261580d3723f77b7b5df5e12298c800d2cd11b471da40a504dad5d6e0c7fb15631c64ff400e303343fb6ae68b61f98628f5f1613a264b5218d6f9e788bb736d7ffe444700c86d9fa09e1ed2c21303dfe4655f378531159a7d9cdd8e5a753145e8060abb60656f81066e213c3a4342de2cbf23cde851c447c455c1068fc882acd7bfe23389af3b4df57ccfb60d2516d1ba0db99c94977d92c41c88c15c09e161311f5969cbf98c52f8bf040e15c85de1846e653168c95c8fecfc5e9d64d554c8c2bf80cc27065341bc56e3f99cf4a34e786d9bc23a16a54d0bf7fd7ed1e7aa7bed0394dfa46ba49683250cd3d44f05650cd7a7a75c1ead00bd3b313430fe040752b1593207d62034ff6d5a54faad29b616076e6a0c145e95a6c378d5eab98c7898d8fd468256b6af314589c74a230607459a4cc822a4f1902246baa06743c04305e79a90bd8b36301ee2f9e1496187f7d9ffa6cd74fdf27eb830c3d23d8310ab002504193f16b115e33aa99676d90d9908103e8d1f8c62c1a7c077fbfebcbac5bbf9ddcf00e7c72536159660e258c24b65ec4b8e4990560f3e6b8e6d39ebacd8e2751f19d5d58a87f40cf272c7be80f976d7aef85e8c888482b77edb7619367a7bbc1c6047b5f6f8cb7e1e447bc4f0ed03305cf62cacd80d36a3459440cee38dbae9035eee0473cf8f2127da4362417f410809c0ab53915778675c4412fd4d4c97a1aac5eb4e82f352c997af627639791403c7152d09c06f36b140bdc178cf69e22621051d3b31d28292d93e62f92637277cd0b8ec025cc5cf401dcdb390dcc3cdea3714e1470f6ba0896416317618cab6b9671aafe8bb8bb099d27299619985339d1c040f92aed03029cd4f8d635ce762bf25f8edb5a39775c667efc39e7d12416cd13595d0a2b897f6c69d05248e3427699c60769a00e888b0dad737b2f028e7490d14ed4faace392af05557e26739dd52564ddce7ab3a2b515dcad5a8b9b46be8a36d76c2d24bfc86a22057ff42ae24915ffb51a2e6a62420572c618c4223d50b57fb644a81f39f9f7648c16c5fbf34e240d36eeb27e51a8ec3582311a550b7f816581cd2772f230d0ee39e74babd64a42f646b12b13f232a14c5e8f6f79e393ef9faa64aa54a2e0b387d1ab01ca7f73ce53baf9b8c98b18f79cd8c71a6c087ef1c8f0abf00d9d56f4ba2b46afdd3c06fab5a8ca1f4710924dc8f0e904bc9e1c9c62284ed5a8aaad1a0e4a391093f10c71a4673362a8fe626491ad85090a5186d6f4b944082988925b68a98eeb95113ae50d767ae91cd712c8bf0ae6fb3a0fff4428d50feb3728f302d75faff91fe4cdad493ebb81a99dd4932e246056a11d6798f4fe55d35bbc1952454d4a6211a56d0fa025a257217538c595051b2a758ef4484db2786f0a33be9a774fbb1ff6319757f81e67550e7bccf67bcf81da9042efc3b1d24d48c79df87f31cb457c46713ebee0e0575fd40dc7dd167fb196924cff46bf7cc5258273562555a5f0b0515b7ebf6f7b320bfa51183cfa6e94070a9a69a01f974bb66558a9792ae10ee42c958900ec18a1c17e5455ef3f8a1e816064cecfe3b66307c4e455126057ed0b63ed9c9ea07e07a25b5e00a00c7e05ec605cb6926738452651e83cdcab760aba94fc39b911b2c7834f03dd21d149a3a4d78499a8e3a1ad18319d1563a59a118979debe754d27a74951db665245d2c1f9bf3d58062be420bca0e3e270086c6fc0e5492b37c263e8623d60e4d8a45530a614f2b59a54a2146a35682b382092c30b4295d0668368b53330e789af7dfd5f32fc19422fef206bf472fcb130daa6b7074863bb38974f644340bd94c83b3aed26d4857802ac1dcca7fdede3a01432d977f9552065edc26e90c40eb58e9f8f8e74cc48c2fa13ec76731604c0249f4dcdb80e1554580d7c35de2cdaa1be2e6746670e5eefd5b7aa70618ee9763027991e68af18f0b5fd35b02207112269b47f16202c649f6e62023ba7b67a05f7d2107cf5b5acff878b56e41fc48544c1d06b775cd200fd1ba3c09b11798a88ef0b1048164c684fe88dc637efbc689708f07ed7c165a1d9fff9b751be390f36caa2233a8e4e1383e3dd6e73ebc7794290427c3fc8b947ab318f9b72fc4f36edf7d05d2dca7218e4408cac8b43a5e82e2f501b996be181d70de4d0f4aeab4fb7f2e13025d751652dc93c326be2492c3426bd4bf6a53b6406eabd0ef9bdf7414e6edde556b7ffb20619547f121ef3a0a66a8fa39d27ab66bcae8b1b5d134dd3766a9484275951d6e6b2a0810d2441ccb69e8441e2a67525c818ae793b6065bdb6197835dda64a9ad26f979f0caec062f41e2a7113e8aec116e63ec32c872d760a6bf58f52c1f12258bb31fee6c9b9646bd66c277a37b06e5dfe82a5bfe95e76405705bcbfc990677ef96ad99038d4ee26c33113c2dfcf983b8d4de8956037f1bba1ba1ebcce5b1646724e1782daf1453e5b92d104f61e1c91fbaedd20c90983e9b890dc33a5a85f97b00af6b502b95d72c46c533424841cc6181708d54206f5d2ba16f50bd3ff4b90c7b7e398234a70bc6a154df767883c3448b514ce7ea70ea577dde3abc56013d73be551f46f0c3e08be425a396e3be1ac41195821fc644d63ed900cc4ac14ccec6139cca4a633b7062a4ad174d7dd6b721f125809ad5962af94c3c2f199a50f2651f1f11ed3c646ff7fab5a8235378c98562311cbe2ee3fb1bd001a8f023bb17cbe87cee0b0c4474e6f359f98478ce9a5f4676d01491da6ac2b9b0c0cc45c4f78076d2304ad31c2d15f9cc126f75f9b0873bc74e670db577a99d7c3d13c22afb6819c6db24279a14a8b703ba46a7977e3e37aed608bacd1e0634f20503f16673b94239be8c3a7927679f0b19186ae914a7c15fc6dbc762aa45d281dc911cac64ea4b11e697caced5eedc14cfb6f4c3e305ed412e793687d5ca896e280b59a88dc2e017ca170d2881014b082a404df5e167978a9eb45e283aadc66a3db443c45e664a3d5273fcffea5c8da6a5b739faf0c23e4f3103e250dbcc3e475b054a56293e2ea2ec4e91ec4fda69c0e2a9c83c5ff9b7ad57877369bf031b900e23b0ae62fee1f0dd191ec932f21c42b5f04bccabf0abebda73aac6405cc6b2e60445d680eaae04ac1b901b1d1925aa3c52752b24f40cde65f864345a9fc653433fb1ba5ef2e3dcd81f492cd8f156bec6286a7f4ca55e27ea5aa9dd1f772a7b0e6923cfe37a97e4f7bcf1a149d1b3708206b83e01c77b36c68cfda38a74b39839925dd265a6672bdcec75096e22bfff11efcdfda9213434c86c360464e16c2dad046fb97add62419e8b713f6b61502b4343a422da7bab50ddb518ae45e00841dc2ca3c894ee9ccf080fa80f7f51c9056dc0cdffcfd089fb50062143720a13d7396f1d3a3c2623d4e605e6313b006721ee20ba15106e93d861f23cdbbd0b446122742007da2adbf204cc7e6577df6078a97f8bfc8039716bc7123e41c4e221c3e03515aae821d5ce8e57473ee988e519758743aac3f7db55c2a36f0f4efedac6ecdb09e4025bfe4d45ad4a1064ba151f8421e1b83abc514bfb21e23db3c62d40209a7978060177c7bebdb442e6afa32a9727b96154bca423ffe61a6c7e319f33f0b72dbd349d98b3ab44e51329ddb0a6bf366641d62f8b1b36694f784b98431ea28724d7311bbc4f612ba0c4fc71fdc8164fd014cff33abf441201d5d170483aff2c43beb258f804064f4cc69c67e4e13eadb514dee892cc8d084b9d34260354d550289cb6f2c16377e2b8910a506f11f4366ebfc48ba6cfb10e6907e27c47598aea74b1f50be7d1b028b187f505784d8d8f8d00076a12e99dd755f6c6961052ce2b636a30cd7332fef57f9e13df3896ab078f36c618b1e94400f1316bc01b039f4cbd154a6a98dcfbedd90cda405fb299b69549b51215c065e079b3f6a5e09e60f8ae16c43dd4062dce0a32203f5386366c86e1e02d79f89b81703784c4553570f7104ec7fc17ce397a237696338a681a5a652adde7f339679db57c946eeed7d5745a08f37961bfbfd56d404d87316d61a0911c2b2618b7d21413fbf00c78fdf26d714aa0a97d6f1c95271edc833bdc0c7d17617757f91fdcd82cec16f7c4c2aaaca90ac8eb590992d205af8339f045488e54a11cd2507674f11909d93a8c161ae0285195a36e8b0c06fa509bad51895fb970903c314ad1ff1a0717c26a5adcdce03c81afa812712b94016e89743995b62f89e4fae24633184af2553ff54e39d37fa43c8dd45819aa40eef58ae0e2159fd965e1f4778cc889087dfa269c3e09d0dfa18c8212ac99955baafb0b60f3aeb2a935bc8c88c959962e281a8059b468f1efe01a4b7cb6045491e2629dfbd812d520092e0494986f7fcdf874e0e024983ae91679c7c515b49695dc89552c7d905ff5163afe88b3f56f9c1a8635fd3496d7dea76f49dcdda48628e9a2ff519cef85874694113c6a859c2ad4a0ce3d26f167e462ce1e8f86118b1d1f0bf090977fac385bf2328e1b32186bdefbb2fa6c64f2f7c80f6e7b9bc2da87c434d8f02dcf739d658c00e2d0d140cc5fe55e4b3311fd59d9fec1bfe1291050c2ef262949a2f27a4d21984115d697a0e7b4bb17549c6724da7b823807f103b9cb18333e961f46eea9eb49d462ff89325a10eb47c851c65a0d128912674f2ee4891a58428f22525b03cff46563161d9ef533fcd1fcc2f7c3c7d22ad3eb5829fb42063eb92c6494ff3efbb01b82e2af3a44677f42ba929e9e2e716f0d9ce0627827c8eb4e2c624d7b990cdaaf5043493f76232e49369e9e2d3755ad786e745ef2c40836ee7f4c29e30599a37dcf99ed1997e3d0e0d184a3360c6bc9750db51d371b4d8351f1c1abc18c335c6b18eed9c17871f341617be652e7885bd01ea37430082d1969431981869e33733ce82ad567b6b4a410b0a4e68caa92ff221302a4de51614f25d65915f3a0d5d1f510a21a8575369c47d98e3b0aa6c63361cc160824225f25ce2ab41fb28a5a9692e7c6cc73741c82fd13a3378ec0b4d688a692cf5bce5526d713e359c2fec871f902afa34d55b416330c095af451403c3fdfbb5be48a567a170553f0f7627f95553de0acfb4816efccad93c98a1ec52975df9b1be5119cf64cec91cbe5677dcb3061351c6781b3a6fa1885f18f3320ad3f71695c0d60a183f8e3edff904bc700ccdd208c4ea2bc128633cec8177130944eb4ae6ad100685bdc456c55a7a667e974020d9bdd4caf85da05227c7ddacd781f320ce9938c1c0d10cdf6de49639dbbaf0ff44bb457d12381e89f174791a51192f5001c625e48b86527e5b066b9307fa68f8a040f031b261c003ac779c025469395a74258fb5c748329e6756adec2e50de4cd8488ef3856e5f5369dd8e58b76d17bd20f7e1ac874f1efef20f74e2130cd133e479b64fcfd67296e540378f2556f33bf3ef4f3c97f999fa03035399765dabf44054443a87048a8be28149fa8481896d6b82f36df229fe2d60b57614668c99a59c43d1a2d0070aecf8078b740cefe38c0528820f7591f158072d5858607aa3a75238eaafbde433ab04821559bd0298380c23500b229e438c9c6aa50c2499ec2eb4f3491b6ff93f70b095d840b3ef8ff90dc066207df9af4e09c9c4db02f3b08f0d79896fdfdbff34afb4c9f369f595e76afe21ed434adf7f669099e713a4569c383265680c11f9264b51bdd024e02048850501e2a31cc84e37c1bc3c2a81df8789e6f3f9bf201d2d8f6ec5e011978cc090a1098f7120317e58202b561156585ed09010b2b5b3bbb7f1d35134383ba5f34f61ab174bbc0f305c3e5e1646857ee648a8f6e2d039697a5f687edb1778dd5d78927f89b58e8b6309c14feefd21634f809da1aad98360c0e31d7afd42a5ffa61102b3c4c4ae412884e2a229b33fc1848f767065372c9d7570719ee192e711dc48104390737b9bc736496ce9f8d74c17183869f4dfbd5e986465d6af16935df9b7194fc0d4191efe04814b512ea62c0986e962e45a90a28a9be081de37e6837d0ec98f67b6d8d3577dbe0f42685cdc44132cb318cc068ccdde2ae284b7cb5e90cf246b7767d060cbf3584f2671e5b4c3c9452aa9fb23f354fb4fdbce1e0485fbae78b6ce9f9fc174d8b50da3bed281677443a83c5bc1f0cde361544a9226d333be53fc2ddb908725d2f2a85fed20a17875e26172b5c7022f14ab9e39d5a6fb50a21afb9c855707525b71504494ec9275fe3f1597a8ea933ab39d04c03d61db6d0d32377ca7dea80c83ba96f118e97315ef9facdb5ef158f1a9250ef26e3a883e45f377bb197ea8ccaf33be1f95feac0c2cfd0a5f77442a30f892f758d2202a34e678c2d953219b0214a27fffd8bccde6a5cb3ced0d52e773cc128004e2167a2061d509e76da98530086a75b89038a052242e137ffd5f7afe67d2448783877fe240eaa8a3f4b2e2fff1a54201f666b79d3e9e8cb85fef60aac4a0bdd8664d86a3f0f7b67d4bf4d51c42b2540469c768509b4bbdebe5d5778a1af4cf2b3522c6deb054369cf822fcc10a77ddaafcf16ef6cf80c98d40ab60282b01af0abffa362ba77b4abf4fe96098d245818134c9383fc6287dd82e20739e288b848b97826a9ebfd9b931754617c586af512925a6a06c477df68eb13445fc2299e7b26c1a70411e2298cd4feee647ad8785062150f5a9d3508adfde0b42e0643da82cc38bba626bf2b194f719a12ec9b3bf97b8a3883505136b082640d500d1044a3dc53b8e8a6bf6987e10d7d28603a1e86b5c64fbc542950dd62a9e7d8f8a652dc9c66f09e689509ad94dc49467d1d67a96e433ef1126600312e3e8209bc6f1cc3d0f197200700103713fc4c3fd65faf7cfe697dca4a94363fbb6b7f8f876e78a905cf232c115b33dcc4e29ec87a25baf60e0a0ba4f4c0b7c191ba0c49046db95e63b74d341ed1ee5463ed786ec15c0ae76cb928fd8a8f20206f90e1af6f41302f193f5e4a86f683ed477c17a289f33abfcd6ab10003c84cf510218b682c3e4421b0de5c4981ddb9ebb7c34a99b6443b27a6ec4aa4af05dfa9f07f861a4d87d1b9a01d57550214c7aaa425e122e56c0fb5cc5a7676c1df53531198f261b915dc14235c001103ad0dfa78130779a52f91d122b4ff214ba2250ff5ca7f636975ca8b09ce74ba26cbdf5639486284cf41e2d0db23c356545cddcec14c433274ff7516ff41216291208d83d105d80a1af80d97ab53bd0933889f29e3a6156c03b6ea93e6a103807e785bf7dad8b1fc466cdf601790104cc33b97eec910d6edcbbada2697b2bbcf9b43145f224521cde1c1f52bd915ae8e3d5cfd7105aaab4e185a31bdb05a961b60a72b4ad99f27494f0e9f5b89ff732975952deddc8a5b21b17fa4c6b02ac815cfc75fd50aa6b20086d21d5584942a005f7c7b4d147c396d71dc07d7c4207bee4968af6fc0bf5516df2cf4a47911dcf4610f38c1ac7cad2e4feb71307027e498d7d607ca19267beefb929ff4e248090080c31705807b11b717c46b60a466e57b1f11bb250646f835862ccbaa75a4005485401454c22fb1c4577bf9c41e758bcf19098aad07bbbbe447d45ea23bd8779f482f2aa9c0844685b75457338bf624ae505af6ae375af039fc9048b719757b9094ff6438be2c2f3647e880f65a4613df6e6236f07130f31c872879eedc084c39641f0ccb98775caa4fc9158b9600b2ed0366e24f058858d750144d1e218c136bb3b2c84ddb3a81f9f6495183a2dfc77daa07fb63d0f845902e3c334ada347e9c7883d7dfa13fdf50f42f8112ed52f1b5af9ffce235cb3a1bcab3deecaa0a807f59354f09e3a78f6315de213aeca6c3fb41f9a715b36bd99af4603997df84cd52fe6e71ee9e1416b32c93f59799d2069a41b2e8d891be29b9928352221a9b2866ee43e3c17b5211505e93222b11844eef06127ac88c3b588bc553c2dc331124f8d04e1f4b725452177364df42b8b226f1adb452442ee7b7b1b097dafa80a2d9fc4f76428cba8eb8b6d55eb10da2e911c2fb3fa8e5c7f3714ac7c6ddf5e8d5de5b18718b66f576014c73f43829ad512ed35c6612cd89e71659f7f4afd5463501e54eaa02b7192c5cb62d7176bf297d846bd09ef21370159312e2fb270c7b00975ed13dac9a0a16124abcf459a3ae50627d11a30097e56dda696736de667db0936ce7ef4b2bace5333aa46339af2c8b739052d526cc21d23844754c71b918c35ed91f53b2bac98b5e117d8b79f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
