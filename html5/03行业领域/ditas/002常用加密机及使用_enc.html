<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bc33b95a66dc446ee7dc034555981450b10eb290a880ba2c5bfd8406aa25a8e889a2256d713bd9b6c3b98acc5f27d544a5b4477a906bb1c5caeb6d34430a07ebbc6011a1d7d26dd5503660b9a27662b776cd48af802456ca721205ece237db8844461ee2683f9a0749a045ac7e6c7de982fac28b614583dd6235365dbe5e5690806424826bdd2b908277294222fc6d0088ac433cf6d91b6f231896223bea22a53ac9b36388d6c742605fc32a2b632097e90ce585e34b821984299d0c98c8e7c9750dfe6bb157181eeef4a0fc6e8d47cba883e6cf6584796eddd88a1b78a2e6e0bf28b8dfae82c6dec8ca27e977250759cc542873948e9bd9147cab2c68707466ab2ca61a63386c77879c1370c5df1c70a6293add3f1a7ea5504cec07ac34e4cc9aac376b782413a6a79bc4c7c2394743b8029119b1f10aad1ee0a4519affffac921b8b913a35e1e2b09fa9e812d543a8196792fa5492832de4475ab42f45053ce49538c953340ff8eb3958af06315d2dd7607995c39e092554ed7a7c1abef258987feac86cdddbee859ee8f2032f4d5d58c9db23cff4ba12a673c29a3accd445817c340b03e30df3fed4b4d9bd74e45d97608a01d7380960a0073272b2d4fd62c23adc8ebcb08891e56ecd394c3fed341b16a3c9267b35e83ba9edea6e8b56b0dbf6590acdeb43dcafc0a6e543b04d5006e2ad7be620314036eb28e49a8c9d75f05c72b5239f555011a499a5b2531d22e470bf4935b9d988ddaf5dadd702c47f90c8072021fbbb32cf3701c64cdf04054bc36a75bed2823abf5e3e4f4aae8a07c0957761f87226569e5e51f35fbd4eb4bdb4c6e75b52b4217037b92d8d76407f7ad540b673e8afdb65e86187e30aad31e9b4cde759ea382a621a33662fa030f1f04d1501b52bb527f9a99c79f1c1de4ab138d44b02d2006357a017df282a6135c541aa738a24dd515cc35907b4983326153cdbfd2d0d2ddfc6fcffc20cb371435e1937220a98e22e34b97262dc5e5544bec129a704ad2f984b7a5456e1884027ffacc5e1cfa573006d501cbecc8005afd82d57c01615860b821c83c2f612a2c49f780b3f08f0e9497bdb5e44158ca4bdf94367d1f532130a6d52fa3e51fe039981355f509945fa02902aafb40030b08ae87b7e7f1e5eb10c70e1ef74d727e43a23db7302fb5bbe92782b5a26fc77b98263b06c46227dc5bc7ba6b4decc3eb5c97b00416ac342fd314f914f608cec565aed8cd3f155f4adf0ab2184866da2bc48e22e5be925ce857fb99106d1e5192eb50cdd001fcc4767ef6a000cf6c43aab1cbdd8ef9c01544282b2b4cc56954f87bfda0940766cf4032d705eeb07bbbd6a74b475b9d71355fe2bc4388aea9dca3201239240f155f283b1610cad9eaa071d0668d2d37246fa923634dd3ce3f0e9b16f966a34e5b13bfbe1c81d60c2aba1ddd4b67e5d1b830e18245a0259eb23a4ceda02694760a68facc9a33f0280ce62f4e24749b4e036cd073578fcec2e60d9c20505ec5cab658c3d4de38ea0c9343dbbe87c4413c63edc04196dbea544ca26eab547d7e97ccc87913fcebafcf2aaa97371db4a2d880b62c99271a9719c8f9424e35fb80f1329fe3b3dfa7663e6f7af5f2b26743df5b2806a61900b7a3a7de71b4743f6fc453467f10d5707bccd5dc47ebb228cd2d282a4a3aa45a713474c73c3057431ee1b48852504a6dc344cf59f7b71c7ca71b1b4bd8bd3e7d9ff0714c15f26f657d5e4753b4dc27184ba514edf255a5362eec29c2dd6b19a27721c3a2a734bdc3052d68191a370c6b68134f04e28d03075c01c15089cb3c0507f84e984715a5ba5b416683e4393ff6df5a43bfc7e9dd1beb2a49bbe066aca645a0b88a16107e52dfc6232611256232909e2e1960a72ab8a611c9b565dc13038dcc272152d0220c1020a2949136771690ddff0885f4558d1f3423a2d889e58bbd856d8b0055a3fb2d75b2e38bec567e17f0739f9b3064bb155cb41001d9196422badd7cd263ae5e8d7f4981a7d05e3a7165899e9fc296b659912066a73b7001aa46ac9e3b4bd5c9c12f3074d9fa9d319cdb444db8f72e524fff71ab4bda8ef3fdb1eb8044f52735dd30c9c2a0b3ad5a34dce539170e3a12b96a0a4eb4c2888ecd88dd853f2cacb7940da6e4491b2aba612c7a34de537354a5c0672d9c573135e760a3fe0562e2aa6ebde51d93e1123400de13e95da4e872ddd75a2d148771f61520042c4e2d62b670c0aeb37e1346b2104b0c1273070d35c7bed76cf8ddaf43022868a36c083db19c83cdfac12df94bc5b59433356e8edd1e0cfd10833105118d3bc98a16a1f1cc2efb99203edb8dda9ebe7f8cf32b75d3e4a55074b6f9b1f4e7fdbe335a7e568f66ff76e23972f899a0b06d3aeaa6ede8e24a7517a5d4bc25b6c189a0177bb4e98f7359a92074f390aabad3aac969d8934e2cec5fdfded6570f0e8d629687933654b784b1d290fb46c69d0dbb1d0a2840668f171712b7d02a981478e02dadd62934cd27c0b427f813bc76ed710912413f534588930a38342018c5e505a31cb3b646ee4563d9c24e00eab475901f3d951e18b6c6bfbaba75114300b2bf43c5aba336cfca110c9430799f2cd4779403e4ec1858ba4566cb4563bafbbd623755af6a17f1f270a0c054234085333c1bef11a9fb45b963dacd38ddea69601c11c02c6a33d39f84bea2ee67a0fe3dcfb412e44e3ec2d76d990c7f6b12354e9ddc992cabd97e0f2f10637bb54953695989e339704bd63bab792efb95d3aac75550fa3a2d28a527f2219701d31cea07ea113e34b489f6c492236d1cb97b78fd1aae8d425bba55e9588616fa46b860fb8b67772591ef8e0ed9197db89930dbf3c167ae68a0e245c4443de7b98a4b01915694de35d170cd7f3f797bfe9de4985c472995095e005e4b066a367b642f9788713d422cab33829a1f75f6739d8fb920d1a49e94e60cd47a40d4d8f5d505b5e8c79c933a7351d644e4954f54e09c20189538232ce06e00bc42cac176d22e991b5f40e98581dfe1a9c7b62de8c8281116e6fc66437fb35429c06b30017143d73ca4d16188ef4a05d6511c9ea4023023d30ab5db1d0deca116e6cc98dc45d93bc3da6be52be452fe61500e100845791ffc648346f1f2a6628192d06c6be5e2155bd0844367d5ca2ed82d3e152d96fdf14b92034012fd98a0799a31794dcd6cdaffcb4b391222cca9777252186267b52d8cf122e647fcc656fbc2e319fd98457f51dacd0bcd71c04ae43521054d66cfdde6afa12365947fb30d8a6bb64c5b218210a62a828c28cda285130d4aa523b883532888caa4b6f50e0ca4d98f2defcc4dd4ecc90665c17a84a48308657fc76c17823f5693411c2e13929f1aaa2e536ae7b63e8d254a9af5df690a1a0a7b9b0946bd11a54f6277b9df75cf62614cb3a18fc3e9537dfb58243c131b60d76489c18146ebe68106bf12912af5f6366dbe4dd4b7712f02c75d34652fca3026f64dfdd7dc0efd924e3ca1b9f8e3f3fd4890dde0f5f0df63e381661ed5445ad29e96349de72c96fcf815ef1a05e959bdafbf91b1427ca2dbe916670e0a97afd615eacfb92e13f65d15d88c868e5f85f04471d6a64463be42256d45a620ad304d60b4f4cfa56d3c5001c2f2fa44540acb8b2a6190f995ac3d8b0f3693d9425cfbea482594fea570b31dfcdf06421202cba384e0b933a91b91cb950c0a8e8284b7fd9368f6cc0b13c4b8a42887cf88e2356c3907e92193f8e10aadee1090e48430426584ae771eb9fdbf372398ce14a1b275d0079bea9d6aa70dc45f8db21d0997d47de38889e8a561a9d1f3910d631d03016a92b4be558457985e08f18e608624094d590b3d5ec4b5820348b1faa9090158f38dbbfde59fb8631ae3ee71a4f582a88e660d2236e32a4987a7f54a793157b89b38e8b90af22017911d52361ce8b3f8676268a92a4f62dce8365fea563f449f1dea5a6325ef317d5ee940ab2ca59e3e33cec3fecda959152ab902e299ee06fca78b543889f957ba51f2b614ec44079c046b0d3729e2a31a4297cb73f763d59a3365b0ce9819d0881f29a898159b55972d9b61dc57b9ea755a9ff3442af6eb030fd9602e9d88136fc3fb980684614d642ce55bfee5a570a67ea4a15ca0c27950de6f444c2be69bcc626b3716321ca6e0ca68d66b319695016e432330dfcaf0bec8f3cda463b8a26b9f0fc4ca92d73e1cc7245e4eb97cc7f5d31804cbbbd486217799e5152028ca69c53a1f94ed0740fd31e3eb1bc0db4ecc1d5c29351431541c42e6e699c797dc7e29104ffe3b6e96963c873fcbb60c1c3213ffa285e854c488aa5653dc8b65924bfe94fa866be7f40b8bb5408f02d5de085dd18ab6a06246788e5cddda0a2cc2d6d1a8453bbb90483fff7de0d2d8009171d2046e95b00ce8f1df57b7d19bc41ec850866252f58f71fbf5c52a1db7d27cb0cac28eed929ade9631681653196b1924f9671863e294dac30bf1a39b9f96ae7fc4c22f2c24a9560b25df1c6db7b1c6bee77d60edfd5f8380849bf64ada7d32a43976b6d54047510e9615155b45a7869968b0ff138e5e17a0826ab84f32bf74fc37f36da8a6242172ced32b9895c16ee2d0c37cef19f15ca3b375831834f94eb5cb6be75f354f10256202551bd385f720ab5c475708a8740c17c48f06e5afcb12ec2eebc8ebbe8edcee5539b4f9de1cf4d3c269ed2f4d981f15843e682ec81bfef9b2c9f07857b42c0ffd939cfcd2abdffde6bca86c6a4a63798979d1a922a094b45d414bbb828e39e7a90067ba9e8c1e2f8949ef1e128953674130bbce732dae729cd25c3c2a81782802fdb90f89bc6d84200af77e699b612bc1cdcc7d0685c941a5c59ae7923efb7f5d80909b584729f752fdaf81092e1184146d37bf8444b1e629d314c9934050b0cda8df2c8f251674d028ae89a2f0c2842d38dab98780e5d85a95af3adab2368d4d29fa6d6d02e3bf7efbcc7cda0369a9372d0657e4cc33e152df9dc7aa41548a9855d21c0902824f077cd66b232c738196af58baddce7ba4924ab4cac2c4c5036601421350f20cf3b9562b14a2fd8123a2364fee08674c7d9513e2f9a1234db265ab1ab503386f1750330f7b0c0e75a1868bef1bf7be71563e908930823c50ab679fc3305a7b83545bc8443dbbfa0374a20e2249f96d939d32c149ee714783ec802beecfa48ed72d1bae30ecf86eaad4276c28add84b543bc720fa10a4c4d8c752892272a1123d106b0f1ee92887f9e14d6c72939ef38aa95ed22a664e3eba6ac4cff6324274fef8238301ee80adca01ca9322ca6c192ca416aec56ad4983ea93d3dfd6697d5265be6bbdb6e3757345db9ac5037cc7a85caeba3971840f214ca245d6c759861b66fbc9593dae3264e94f7c7b5d664d5a0edc41cb93deb992fd315aa51fd856d01c93822fb0d6be733efb21566245ba1aae0990eeb1b61953f11248e46cf055cc95779597cfbaddc4c4ce5e9ac87c92cc90d130c0f97b31cc8ab6fa648dd5617f14236c0485db547b905fe5bf9edf800a1227ae7d70663d2c8af08e5339eab18c7370e34fecd906b2bd2fb02a4325809e3718b31ac31eaf1db8ebd268363f270bff4de03d8841a6c83ded6421ab793aedf06d2bb5aa6a48c03eecf33cff8a335c971ca7941eca4d9c73b3b0d35282fea1eb95c92fad5d412b081063a48d2f40785ef27bac90992dbe5611717684aeedb3294a1d7699c136c093f54b6cd84042384a88f1dae04c015c724e1583ed2ebef93791722b6a54c096c9d06037603415c4d51d32074b76f58a837d3914e8cba5d6fed4827a3663d276694b37c60c41e0a0e3dd7f111f0172caf9a00f954d955c226b022febf654b264f80805ca9462a8fcd8134be4962072c9fa08f2d672c90926bd379d8c9e76d515b10675b7741a80e97035209859a30f1c1542cf0db98f8cee794729f7c6f8c9ea47f039792f857e3c3ac08a12fd7c776897a087f6a59f3892189f636605377b5202cb3bf5622344f9a591618c1e33c16bb885e5ebbd8634729f746c64d18e38e4836e839ebe3e22a36d02f4c7c33418bd6a07a40ba764b136135656dced96e06076d13bbef963eca762cd71a5cdc5421f4a7f7eeb1a4d76253f092964ab40204e9bf7dcb0bdb2257138afdf789e2ab29165064d5a01bc25d85d28953a0d1737eec7089c58ccd63c7784fb03e422908ea35afd70985ed2f7fbf4d107f5e3648cdbe8a3f5e9b364b1f3e860cae28d718fc14c9876af636d993d1425171686ef4f1f4049bdb4cabb12b10d675ecdcc71847c7169c182c374a12d9f79376e3cb57d14c920359650e402651b01f96e19a1b32b2fb8c14478643c05214543cbaf0212c6d830f18f4484f2f86d738d0d2ef9afb29a836c7515cd14d139fe7288c22d8b597b642571acc44989f0b34cb238b22105dca2b60599f1a3b12c579a1c9ad2456e320c02f915a094cfb5dfa6721643b0aa9ee3f2bea574792706f7ebbed6e388128dc8a12def1b5f100e82dfc9b6e7f2b3084f9f8cc1f7b0b8f3a4ab8a880b2dab320daa4f81a18c71e15eef404e8dbb5e26bef1593fd01cb3772f8b970b79fe66c828ca1ab6351ddee7601454c0ffb33d2122e486626d00114c8b6b45baac4b8e2a707b3a2ee109df6d8b919a1b9cab2d3da951208e740c2620550ee56c22b965c743b9f44861e681f7b2a2fb819dfb43cd47b61fd37a8173b18210e44bdc23025136187d478d00ff27f1d2c40a475d006250cd99d5d2765cdc5e7e3c84840168408df42cae31bbf5ec4e431965981a3729c75760099bffdf8b1e107c20d159b01d71eea3c59db291c3866f040181e7366bed083eb4ad6258cc1578e9e13bd6abc09798ad0dd7f8609ae173c3be39478af86d07d918f7cd7d88eebf96e465549bfeaf3e52741af544fe4725697ac8147f2c9476ec2da895062e539a380ccbb6b7166a560f40d4d2cb1872471ae047330962f30d887eda787ffdca347d0bfb61ba8950d80f355db50455f63baab505150d3b533ac20ac5a1e5e199f87b94eec132e6de9e6b3cfacf59896a0b454f9e0904979c6f98d06a1282b0e04b7d4da43dd3aadfabb7577d460040f8fc4c2d106c5429f60150f61a5f72fd3e714ea3e6df0af58fae95702906b45a8bad00a68d3ab0e1436e431906187f74c8dc0fa25c68cd1b6c9387589f9c9b0d863a7435e4bf750c60471fd6f1769a94baf5228480a65405250d4d25389b7605cf37ca1dadc6b4e0e79199c69924454c588ace91748dbb67947765d14a6abc8631716e26d3636ead99c77eaa742c78ff0778805ab8b5616ca8dfb08cccbe50cbecea93cc2c2a28de64244d2da3be7421225bb300489056237b8596f2eadc990a63ec7c9ab481cd90476e5011386e747a43a3530fbb27f577c07346a16dfb81b600d44cad5023df96fa58afcd9bf3bdf54dfd3cfd985579add18698416a0b8ff0319e41004c529f847ed878bd164310855bf6955e133977e2d998817b8be0738d5c9a25f456fc17c3ae3313e67667747cf7de0b12892d8091a5389ab5206e33c09c9231837b3aa79d80eff06db6738c9709a8c8345747a3f742ac1eebbff47f0ebf376f63a2944c84c1442d50e031c6f1fe67ef08582dc414e3d1e17740456d8c5bfb565f80b0c39113e9dc3aee31aef4e382806f6c2749236116c2cbe18b80a0d0435fad0f33573989b9ed5f021a01ddc8a71547b4e364634ba63b8c140f60c350657ad3e3ae6967c68ec4ae78cdb34f2824890f608df238c92d85e7b07d012464298a774178dacde30cb9d35a778280e01fea96bdfe41670f0e558555487234cc73d7261f1f8258f6f16052c6c1361e194c39d897ae1dc317e2d080887139876c7050747864658d65467a4f6c0b85122974e7ddf46af00086e6693f21452131116c0a0993a84b43aae8929052b8404a4180467fa999342c00c87eb64faa375924ede0f53db24074d9672082c188e4749c5dd0f67af3ccdb06e11c3a3fb12911b2f650988f01550e9166808e809af928971a4d9ca64edaeb0d0ef4925736f69d844ae59004b4c7f64ba91dbde1a572ef86fede76e10efe319dd948cc78dcbe01af98eace576d73773b6072f90e28d7b4f54268a17e25a80a72da376f65f400393c5c6d28f933a7bf8d1453a86fb00b63a2748626a3ff7ac9d64463886ce473c0c2043fd3f41536472d9729f8e7f48808c71635c2ab05a146b366773735c66b2c67928d47530f5e4231f7f3da268d307ff7f5ee89254c6f7ec9772052023f313f692f3ac4133d11393956ab78ad400b92eb10ebfbae609cac085cb3859cce61c074f8073091da0a03cf2aa19c72adf1c4ee173aae900c8f7f96dbcaa7f5255bb747ea86e45004d2d400d65ef6a00684fb6405a33347821700920b73d624979c5fdd1779f60acc39e204b915c740ee8a53ceb4b287ac1a4bffca8c811b373985150142e1a1d504238294465bf0d806f9db151e22560f15ca69ccb336c3b7dbfdf870cee7bc7ac83d8aec4003c834348979ab9db6d5d5465857305784007562a4ad8b206f263c1523e45e4f244e391d3dea1abd0193a771195803164a8be5bda94f6ed2efbfd01bc7d86af879ee6b5e63a823caf6f7944ec22253b89a7184ccf6fbae6a5dc9fb60a9b6a6aaf1aea54161eb144c8b879da92621516acd56375bd83ac03a10487fca3165e4f255e2141da9c7f658d5a6759b3b98d634cd2c32f6295139d3801f758f20a8b42005513b724dc5a902cb38576011f70bae17c608d887a80e7fd351b7b2f7229c3f57eba6078638e274e4516f8c331d5e7e52eee7661be4d041fd447181716e7c9db031dd1709cde8991499951a308f580a36bfe6c5a5890001bf123573057ff52e34ed15da0a01570371b3206fb7f34b1bad58e5d8913fcc3843ebc9d6318c0dffe315f12532b10ed0e872cefd3dcb0ecda799109d944d8996fd736052914706ef2911bcde0043b608aea4dd67ed17b77e8932835f5044b08faeb82dd4fc7bfb3edbc00c3b4eba023c3c6ad29485ae029f215e7f93ba608a0c9ac930a8a40d9980c8f8561dbaf0cdd1a6faea68e749b0212fb7ba78d771f16e97e1c15bc2f3b74003c9e11e46bcad69fa8a6cb5f30d91b29eeeb8318118325c61b92f6b2db27833658fa71293f781cc8bae880ec5be95c5bd5e1abd2ffb8f68f970405bd5d6ab0968204c695","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
