<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2f0fe21e71a7ec47df64e6d155405286c9331b6701551b3b0d4374f64b8c9e86bb2c00359e466663103968eaba531914f83fc80be7f65af87cb58fe64c9955717f7d8df47e852209a8f798cad3c84e593fb727cf40c938c20c0ee009ba85daf004d75bee776506368bb48946fc4ac80c64e23c51c135ae14b6aeaa6745884f6901091d09bf446a7a597fa4b25489699a5ea3c3fa49e4e0eadc8f38c0df6156ab2385f58230a40f85fc67db2006535aa1bcef486f19c1fa66d3f51cd213951414aa394bd0d89a694c7941b1502a9173cff8957bb5a6ed0ca7faa3c20e7f6998bd71bf74717a609fe2de772743a5e189ace7cbdbc16bbd17b30d46c5a729fdfe984ad8e854f16df3417759eb8ef0c233a6b20e4d7f0ac1c6405735e5b385a7d573d00a5bc7bf8f43f216d119474a4e18b9e61c3fcf826eaf38fb714ba8d5561119f1c29b49a61d569b43fab77e97e01d1858304976c709e197f5bef6ce40e4664202a11d7fae5c18aa24a73fc7fbd8b72c2886110ef0a01a54e5d5759e3c02f8db6ed42628a7a5f19ee7f1c7fd88bde8cea6be32d541486246fd26048be79c4ca93c55efe1e58a932da7428e51ddc2b9e7612373928fd7ffeebd502c8b63e6622b74c2285ac2494c55faaf5799f76455b5b931fa1b71f4426e859eb9e4ad0d659777ba84c88dec0db9be38eb733529174e6e489f378ba7d6a06d4be0da64da91938edd7f4b53510c16d4f08721690a32fa6403ed75749a81c0c16e2eeb99485914e05594ed3881788c45979c2a62b76f957f44ab1adf04e9ae7378a41603cdca17a0f49eb3bcffda19793e2ce377e682307caf0b5ea18a05c6a621b1e3dc86260c2e3106b36af7fa5df07e62757157ebd3101ea145cd29270a2bb1c728d6fe9d25adedd84c0df46a7a799322063646b3ef9dc35a73f524c4785229d240d2e80655c8d98671eba3a80f52c77b6f814b78747fc685541c5d4c5d4bf99a03fa43532bcca5778a5e8183158013f68e8eb02d69b035aa244bedc6837310308da306a54defc34c37f31e35c633f9ea1ec4f8d00d4b8327a99159fa2a1351b577b1877b9068accb3fb63f64e1dd73b00af81383403fb45b0a7850d205430cc169c92d65891974ac572adb920cf6088abf4fd551e7d9796006ab7fefea02ff1d91c0a5cf1b3585ccc992825bf1317fcdbf4f5a3af925dc8b8ab7d03977ee56791430746c2b5400822944462a2e4b0bb56e2dc17d630fca7e818d68f4ec0d7bbc4370e8ee2e9fa9d8d9ce568fe7dbcfa7ce95c36289d1e4d1a264043691842c6d579de2f27d98d85887c922cd3c467da2ceec4ad2ab861464055cc7237b924545b675993321bffa8e00d2d75d1bcf2ac9aa4e0a829bb1ab0213298d4b77d9ad62c78eeca8f687caee91befb9dbffc7219307bb308d386424730dba0dfd2152de87a0cd7da16574828bc85b2cda80581e6463b049a9078a3d9096849ed2bffb9a4899bc2ad8b4521e87c6ed5c225557c00bbcc66fee6b05a537da4642f6826ded961fe55cb12d9870af170ceba05987b8405aa25fe8cf4abdfd93b477d974de67334a52884293e3d1dd4054921fa7b2d3d4bdd3b4ff52b12cdf3920dd8afabfbc0b45fd3041c303560d63227994acf82a81f515173e2d518474f20f53ec316a887076acf3b54ea98c0576bf46c5e880a121a115f33c6a7aadf80776f0a5fb32fdf64ca180e3f3f5c1b694cc1d43f47a1f78f856d8eef68f07ada098cd2ff339f16c1d88b37ef7bbeb5ae3da4dc6fe1d8d6cfabc5a9344ec832782d471256cf2088637c999bca72a566967710a99b2570857f3fdde0cf33293c0f7af973b5e4cd017ad719628372b14861b5077944963a95be9eea5ae1688fdf62e731a2048a86f318487a225c3ea130234ac69169dbff24bc381f219d21292774018249bc0405f6388bbc739bacb666e21684e0ce049e38361e95f3d67416427d6f4057cc9954c91ec233100a366cea0b3935225328395ab8cbf607ccc2c4d14240d9a12eb1f5e9357adf75739011c5b0626dbd3815d431a052f89bb7d9229b83a307f179a30620d2373903a1b4a8159cebfc560a3f9ce4aa41cdcbe9989f6036a3c72f6800eb944e7131f6b7ac81e85aaa7049968b8834d0b80e81af52cb97210c68488101ebf9513dfdfa2559a5ace791db28b9516a3c451a57e4aa8235e4bf5487bdb2436bc5f2294c3c5ab63c446cdbf123dd6d08e22e468f0bcb187594afc830ac339e6cd92694437201e75552665fbe3a65a40ee3f36776b6e6ad8fc6f2d197d47634237ba54a5ec556c0ca98c3ed9af66aa8be5fb28a501e900eb76f5f29c7e693e95f3cfd4ce9c40d8f37a9da671402664557db1b7f4a72b2fda14f511077e67f9a4e40db42c3ee34952bfc0e6016b484afa15bc393b9615f4ecb4584767b10ecd54b4b4674ef8ecb7439e21b69c3baa74229a9cf8dd3b7acee9e6b88ff65cf465af0551b204f3ac8158d9309e11b81e313a1d8f3fbdfc03e04a7526a2e220c95df81506fffd99e40e4aa8139df589210a499442f1b01209884ffc6923b11f9181c65a58df85f8d5d9639fa11a07b34096bb7696bb9a923cdd2c1d844e191b75460910220b970d2a753fd54f16cc8e12ebc1dbfe4048a9bc5ef1ce4289116102bfa9d7fb8927cdcac36739aad95ce4f6e0729ee334b45ca877f6e8e0f7003168506461531f2a28966f259beae9d1ad8ad3eb45e2b4d8efb3de7483621165219a5f454353893b5f6d1b2fa16bab67d0cd71e4f5525dfbc082537035787caa4a13a1f249b692fbf75626aec5d26f7790be6d7225a44aaa020343a5447f8e4b5de0a2af9a5f027762555710427a63c8f129f5a709679a368b993f8431462a394bcd0f4453ee43e63ad7dbbcbb0eb7384a284069f5a2d255c76de26c8dcb1253bc75c0296e3e1bd2824196aeb0b4f40693c7fd4a46f5fb0b6ee3daf05b37ffb51f57a248fbbc04359a7d5d6467cfdca4b0d0541467753ed241e693887606cd6a1ca695d7357b92c6fb4312b365c87c244f35c4d6014a6220fc06ef1d1d81a548ca3cb4124dd93a69667eb6cd2316afad4b535a7bacf5a6f447ba4f2df44348805e4d94b2bc5228e70900dea759b9af16db6e3664359f7781d7152d39597bbfa2c39274a96a151fc8bf58c9774f2f83ab0b7527be425e8dae096d39765a9c898f52a9d85b7a2de0142c8a246ca40557bab08e58240cc31685036a15d1f7be59447f33a12aeb2c4b5dccc78dfa84e23f36e938df504f5ade14bb76c5b15e5fb0affe32a367d35d31399de660947f618f707c27bcd05aa60b472dc99898cd2ded6d760cd4281738638b4fb0a261b756e2b41b0688bd8b66abe55ebcea6bf863decc1e438de441dd891a13bfb8cfc757db0f4edeeeb2c7e6d3539a9039634d4d969da64aaedeae6d6865b482933883da23e5e7674bac827283f462dfd0ff5f3dc65470c4fa9bb0103ad8230f225f2cc50a8cd99ab71a0074262089644b7288f0f8a1d8504592bd72e1a0c028175784dc39dac212388c43ea7f9b5583c181daed2601bdad0200681184851d6c3f806779a4a0c0344c59758d6e804fbadad6389c538f4672f834761a8ab0c76dc2ae09db5db1945c4f9aa58b5a4c65ed5a1b369298e16fc421921669ba3ecbc985396f0d8dedcd5d8ece5a2e9e4fe162305ee9425011a48d52a68e9cd43ccbf0c052bb2c9589b2df71ae639dd4e1cfb50aba2977e871b9b74c35aa210ef9c148c1c7e9d6febf3a5c61df37ebf46d9fb43b477c9215b16a2bc4556bc35a6a8254bbdc92d018146451e2d76bd6d8798280b8227b531dc4d7bc9e38f6b7fb909cf71db9aba200f3a8398b17758981c4c97ea35443e9eecb188033425883bf6ac67911fb02394aba514b839464c36a0cd923b2a00a28353d077aa530bd727e11424edaf068425c311e575b15def402fa80fd6a5fae70cfb37bc841b7e1c34f5dfe8833e884474dc628694d595d8d1156c8b44af35615b25a28e4216ab94b882d9c55da93f4486d36c1d5c5b4309eba3688f3fcadb876ed9cb8fba93ad04938c36ea2a53fa07182495cb52601feb945ea23166641640f34135f391227649b5f36cbb95c0f1a06e3246dd09a62f190c11bf1bc453b1755dbc8ab46b021905a13a658ca40cf08156a3587c63f0da0d0adf4dd3ca4fd5fc6109a04d34ada0e48e50117dcfe9b13cf72f62c1b6ba769b2b88d15e37e9a2962d69a9bc35dbeb731dc987bbb411c9cfbf02d1da97057368c08452597850b1878f5f38cac189b2505662c0f2dc19019dff7567b568c7fffbbfb91ba85f4efdd8947c3ea231da48628ead80498f4ab3782e525eea66faf42662ba31837d2d873816c40abe45e21aba132314763e6890fec18d9e69e8430ca34c8c3f4e38845d918647d17f13ebcb9eb3ba2ea5b46259aea13a4387ea36ab37c21a436b8a5b4ddeac3111f429a7dcb346a3012a00dc818dce4cf101ea9c8dc31da35d631adc08eb1c26c0159f0b764e7ea3beec777d937b9f0b2514a9255ee0bcc0286d280c757a89f0a241f441cfbe3a487c5c2e3d35d9d6a77270a98843dc3b5dea9aca45b4fe198bbee30696f6608d4f2578d881041b6404b90065d2bd466a72da669ab0ad55e8cb3153c7b93ea9ce9c998e9623323d1be91c5014a57e7f8b0fe7d3b9832155a8970752c5b952c94e99819511acee833149cd2937fd5f4223cf37d1b6cd359bbfe3eaaef60c4341e4ff4e47db9cb71c36ba72067378381755e6904fd01f158b4991460827b13d6784256a2fb41a1a889a550e742031e4de3d5fcf795351113d1a1e4b8a0579d5a10fc49d81657dc8d2f90e3f3ccb1e7aaf85c242af2c57c2e3a2f135e82864ca81d8a895b2fd594f26e91412649b2e8428e7c0ade8f2045e3c1e4ded1d589bee3ed200c388aa291d6834c228ef69fa77cd8a0fff8a0cdca43443a63003f2f0cca4fd3104f24c7a770a222f75151598d1015a33fce408b160fe339c74b778e0b7c1e58e6891938c7c33aee436210d6762b77115486e0e78f4f97a8a7440b2b66f965db71e2fe996c6ae505664a4b0f909ec1cc1e7949f43f1942309ddcc05b7801dfc8062dfb2716b7310a266df3c2a93a7440e5bc2b9183c16f738346873ada86c91c1e4977a1a0b7f04f3ea995cc492ed310c3c275d9a99e6056b27daba1fd34e34ca6d7cfd81438f1a3d36cea489cc4e8f648de6b3b7fee362c60018b16c667fe66a822476aa4a404c656486667d07768240242858a21ed065b50d052b82d9162d1e779a05bf54158f132c4301ffb63c629e076d6c7bc18bc27c05e526847d3531afbeb048cc8de699f0203737afa5f5532d1fd0ede955632992873c40839d48213d5c19a5403ced7b5efd0987b3065d7e839690d6e4f77f7cda242057275a1b1d2c4ab3b3d9ef5c7898e0051e7937545937ef90971c0cdaa0cdc4e46620d666e1e32c88e95547ee5e48fb3759d802026caf5fda7fc832276e145d48ebe3e893c8ebd2b6b8ad502fd85378e92538c6aea2d970754fd877169f42c0473ba7897b6c68db99384c2ef2c36cafe305e30562422d97802114cfe6989235ef2591ac1bbb4009f57f0990a10d4522be0006d3dbceca3452cea2ed09579542056152838dfc799029c2ae2db2b4ece28bd386eec52e3a194554bd0625b9e1f01f57b5c41643af42179cf3cd04e6f1b23e6bbec179217e7495c7186583e04049581ceb89e825fa0082323a049563ec55b575a47c33da7a8ae2d1c7d52f64f991bcf4d8a1a8204c08f0eb787e928207b03b8b1c98273c496f8fa3cdb6d360b2f0567282411c801e0e354f4d6609af59ad8d3140902b1f0fd44c19e79996db8cbb04c50e2b44ad3947d56849eb5be53770386ccf09e6d6b51658f5b9fa5cfec8dddfb99ee2f91e0bb31839d1ee67822b26bf4db549056d3c25ffb4f7e3d238919e86c8d1082e56dba07d69c5f2ce3550109c98be558beca7218b322763be1bbda739cc753d304e3e591183efe72e73b747061a6a7dcfd973c91f854bfda87d4c94f27770627a2bb3dc61d2aa39deb38d1bd243deec972fe0f394282f6150882b0cccb5ba1352853367b9032d70b9203e91dda47ae82cae70f7e85707a0f4532afa01ffad54ce46bdea9fee5c3ea75a618166ab191f742cbf0a81394ad1804afa0072fb783d61e2abc3d1d9bbe92ca2dd26a9e955c2954a9e2939eba80d8fa4c04c8c37c605b52eae63646a5c1ec08c60657263e883d0866054f8e73e748a251835fe591f811bcc6e2517d0ecf192408dfcf2372b2ea203492c46cba56455b1bc478fde689cc2f54a744b660edc492f05e5ed7d96ee7378979f196a5aa3bce76d83ce1433eb8aac423d84fabacdc5827c37cebb6bdf88bb030df746bb48201a81b38f4ab890b145bb3dfbb5e152ea6cba3c539d6535571248afdfdd002d072d458cde10adcf17a7b0d95149f2fad890028549a3ab6cba6f676a51b6e1cedf193197f332722b59d26a29112f5550382c008c0130ffa589979762d3f539ba519a232bda595f5953e0e4b99c9a410ee8f2e34ffe4fc6d801651952d296a1248112a757d6ca2d74e942f0f6d52a2df32d1272e7bff3a82d187564b6cca2ae78035ba0b99b65e07bd243f07aa1797356062c1d54bfc54173d30b0eaaca085512d8ff8a56cce1d0ec331249a207c428eb049fc437853a4835d5e5fdd3b4b28cafac36446b45aa94484643fca603241636b42e45eb1a1f154f2b7fa9dd5f6d629bb4d95c52c54593b58e20eebff03fe33931ccc5249e9e86523fba156aa06ee90a7d1a3f97ab8681df1bbf02f7cefd5e2219f27851d1ab6fc552079c6d6611549ea31d8774b786a6e37239cd8dbaadab69ef66f75202cf8cdb94c2f0eb4fcb495ccdfeb5bab322aa6872c0b0ca7b353cc805a5d343d8c08fb5b7ac5ea969130d98ec3fdf3fd7c83415df6db3f46033bd13d3427da14fdb3da9b9bc0b90ff00174bdd0e12be7a903d638c627c2dd84bf86655c99d5d332eeb00fe30b6a12afc35ee6ad910f8407e11cd278cecf389c3b7cf3580a775bfdca8ab48ab3690defaff794c00c7f9b05101a6472e73f2b173a1b1a77e7501aae00dc0bcaf2eb23fc4318123d769c87ced52f480eeaf34f05089500526544b64d9f91246b49c873e2f7db0a76a6783c0f9234e3d7d21266e5f82828bda4655aac4465b82bc00f38b761fe2a2b28895746f49e028d44e7e9caffe536d72f2f57b649297d33597b7a9e2879d3f1558bea38a76dca374a3e6b572f90219db60888c5b47a0779d1beeb073900d958c0e4ad137d3be691caee819ba162a27141f42082ecc47b1d2acd8d158d762a8e5e8d9416d4f88eb64d72927ac0097c713c9ed1bf5cf4f2b84aeda2f5a2c598e3d4edc102167f840459b7faa293b23f4dd1774b8ac4192346383fcfae2b51ab9c21d5086a92225319fedca2245f382ccceaabc0c0526dc9c50085b67727656888c5d5c389d2e98630859c4d1eec9367e9de89b395eec467cd7b756ea3b15c117544f5e2c38825f88bf69d1dc907c8f51c0a1af7301ecb6aaae7045bdc56326d1367a9d69391dc22c25bdaf742bc8a120a42b507986f39093e2a88d4f288814ba837659d653ef7ac5a50b5ffadb7a915cf7f4ec01888032c08d711352e035b1f3b7f5c8697580d8e4a75aa2d2acd8cb3478b1961238f934b9863b218f61b82e2dde3eebfb990fcfd11034ccf5ce5e9c79c4b7669cd789276295fd0b6b2739add5f8ed25970b7d1305cb502edb5923c3b84c34989b011d347ba926e399e3051f1cbf09ee0210ab4effb8c5de9776aa1ada351731c54c9139131ea28d1ddb998eec5c03469fcbf71208626fcd4306333d5ef58358b73c2a09a7e4948e75e3bd6a93001260782d7538a596cab556d1322308acd565e57900e29c9e2ad403cf978ab845012f34a4021f4edf3161a90b9fd8bfb50d7470561cd3ea3e63536a4fbfd0fa42ead5b91863e5a672c54155abe51c80d139c3b7f6aacacfa169f88148da864933dc3f7adad8418c41f724915da6a82cae39aa62705b92688248629467d8d6d6575ae5c48318ae6c265a63699dc13ae5673734f4b2e99f36e90d416f99f52d6f89c4e6562d7bbc508427f9057dc1419fe16a498070d224d8e23d80482a2b0127e1c8d0d7f44528ff56ee0b8b358b812be1116677e9859febb6658c8ff6d56abfa0ad6c15021ca4ba7a8515bb284f7b9bacb446bfd05fd491c8324a9e7ac52f72d60178eaddb3303152073460c78afd7aad50908e5317c099d0b2be04a56bb551e0c24dcb9dcce58c33fca0cabac395c7981ff4ea4c0560f209a3b7c6fe00c77b21f1ddfb0cc9ed6ee64159d85043a45a9837fcd5d1f18a9c29a67d87972e200713fa0f8322c49c786dad6f36b94284b24b68b67474e3e3946c6c0c2b853dacae2be185db74d012803f49fcb883537292babdfa47080360a5dfc825cdc8f8759e3c668403eac9c5e2ea8746ea318db97878fd64903e0e46b8413077d6b14694d37e2efde32178a81e60ea13a3f23c0b0426d0b8633f6f67e26476dc45aa3c508df49dcd1070d0ad06e8c2fdf3a52241adf3608f403310508f5aa6f2734448ec2572b2e2453c7ad5280f7dbbdb8a1829e5fd44534ae10d3794dda00eff161034f58d33dabadf1d8ecdc87abc73b43b75cf4ac88330f9f064daf61913962cb85e316390fe2fa9b0e5b9a27498acbc4eab3eef8809c555f7846bc9ebbc8d980d8ebd36fc20a7674c4231fd0e74d94100c4db4f886f5a70e057eba8f394b08c86d99f838deb3d601448233c419819acdb41b5a98be2ac99ca867d1d53668798e8c4a7bbbce41d1a24f3889122ff54187089a546d0433f725a32e415a574e118ca99ecfcc38c7f17b4665c88085f121175a97d19d62736e4ac64698e5eb579e45a2d7df448d350e923e271ccd4e86e6b38084692b4ec7c44c6fb74886ac6f407d20b7d6ea15b787cec32acf52cd29fd1fed747c2a9a5074ffcb8adb021363ab89abb7e8e418b588de850f04eea7ad2d650f68cf66e0d92843de493ee4b329308e0e7700588cb7832bff799549c69dde49aee41e242202b07fc90bf901e73e2409dce678b9032d2ca09197f06b66f114ec1e65f8f42564d85934c79ae77d16d9a5da5e94c68465398541b6c3bae8cde0b303f9b0647256313d7c9115911e1f2ceb858bd4966746f6616d838c9c8670e6e516732e3bad4f19f113b1b15360b7de7770da8d277af01836319a87530312eb614fa46c20b50ac54c0790ed5ae57b4908eeaae2c46676969ac94e70fc1986c229600289ad0c088ea2b2ed4fc1d775946228707e15d31e91c67c14c5eb16149c30f0a5ba111782856e8942d420b58fc0003468eddae6e314d950947fe4da423236816026903d4a3a93a95bb9451666930f33ca9bfc3ac8d397b9dfe015e940d948c42537db9f9af80a5ccbb1554106d9c56d62e94ca8588a52824843d8c6a69db95a480dc0042508e8e5f45753efae1a466de053309f30b47c5d0121d413c08c3f9d770d7a0cf85ba9be9f40d3f8925aa0244e3e2da0bb4a7654c2bd45347a81aec5c0771b692cf489b7fddb41417685c351c24b237901d19e838e280ca909dddb970b988980d316bd853e791a6c6eadf9633eaffaae75b62e9c6eb89121ebbb530cfb164b023100f9f81b2f826d66ae9fb89c4241aa21c9dc9db05f8ffb2ee2d5928f762a2f07e0299aff43b0b0405b39c32865992f9a8bfa1877c509e00a12b99579068b375f72f1bfb971a9dae87610e84ac91caa0d86a8b5bf8540720d5971457b8c2f957328ef2da175c4fdde79125d8a1144735cb3a03732f8ec0f5d242281800212c9eebd06aad4554df41877ac7073958b04f1da905008c4035a123bbaf4275bb072c76245b57b8151e3e5b262b0cca82eeac5843940339446bef9921f174d949340c7e393defa977d79c758dfc4027918e2bf01834763e21cfa90857c9d183c88ec527cbc534c64f7eeda9b8166a95e7ff92f76f408f0552dd4045ff22d8039193c6a32ac46e0820223a7fb36ddc0d686af527e250479236ce9f608c9c2b8a2825dbb7886583ac2607051f858e22cafa43d81151066becac83aa0e52d5cd08b888e16860847626174534a6ccf3644a0f0474e5dabd28bb06821551bb9c89ad615ab45cd10bf4dca0dc5786e5ba96ac57c9dfb8e548d6505c39641c9ceddca2d8ff2158ab16ef19a376527268c21580a8f769a3037f505ea6cf616db69e2fa7a9cd538b4e840923bf9b323b21b7f26e97610b6030797989a36bedeb3b0d320e7e761e0f826d735ab5d6db096d056283870cc8f74e8cf0c9fef8f6dcb9f9be04e774d8c03f6dcd68415576a43120bf42d7cceb1a6924555187662352b27455d38ebdc1741ac20a09b9268da7fcc4cdc23edfc6e61a15d7aac89f909a0469b6db6c405b5481c090f28d4a2b1f1814be68dde719dcf19d9f06d19933ec8d14953b3e8e3b6b270c542019531f5b58ef6cf735a7fd8d0b32b4fd54117abbd6a2d17d67ff507f9867d9027fb68acc6fdc1e0b73b5a1828e05bc886fd918431591a084e8b8454dd1e2ab213dce5fd1ee2e52a9875569f6fc1135afe319d5305bd816131f70e7af83779d842adb85d75324fd209a086d4c756bd1c2dc26b3e101dab510094322872eb4574d57c14556a19b1325a7a6d3d0b5127de228777e787426e5216797936a681d4e974740d8a3b2dd08d214717bf8fc2c5dbe8a082ada92b821d43720d5d1946feaad0b891ca1ad5060bd2bbc954b10ca6caf8a44ff46f37826e485cddc97fcc079f98f32b84c68ad9ba7f79955d1323c762dfcbd71587a2defb52bf29c07e39592b3d1c9e62965d676013dcef62999889d90522af83f6dbcd758db00c2bf6149222262047cb5e7ba40df260c26f6b496d67db23999a8d1060a1d728e6a6c70c4157cedbf2c043fd4beacbc5b188ea4d1bc94734646778c9ee75f4529103db1fc2f8574023423fc5add2069be9de4a4901fe2ac19536a5c0d753da70446587e5e934154056d4cc3c3ab1163753240300e3ccb0294dae75e1ccf566c05490ebc86d60c122df1499d781d578629f78a9d84b0f595500aad695ad06af2a33fb565ac6f2b30e00ac49","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
