<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"804bedcf3f7f22676aae51b676e18a9fe00b5ddca1e6eb5262f31b313f1b09a0560f15e49eff1cecd649f7a69c3799b89a8df941359cedfcfb3cfb7da6af13b6a0a81ebd879702ca3a5f20f6ad71b64684f219ab2daa5de1bb3257f0b613b2ffab570ed0c6b835d111c1725e884d427d304ec325436fff43445c51dc8db49942239b1b0d8739db81dd497fb41988fe3c58245c506f6037de04253b189eaf7366ca4cc203f51efca7f5bbbc4dbc142541f3e5293b1b26f7022663df1ccbc0c157ff12de047c29490f3806e9fc66e3a1ecade4e6c796e670c765ee14724cc73b0d1243ad69435bcb724afc13ebc6ea0fc21cf69042e8eacc5607e71950999a2091884895733884b0d143399f80ef75b6d941d60adab87929cdb4cf1e2bcdea00df71ab019bf775c324159031c861f67b1cff8ea2f891f480fa5a39886600b2d013c0c0e83449f52344a3420106e5b1ca9da00b90631d4261b3e78c45754edb23a59e9966f646b7110f0081061fd99d65826d395dff83d2230513d2ca94703c5126f21e1e04c45e827b5e7439f87f7881840d65d407ba1f45158b7b7b0203af3db8316ac9f4f96feb89944f76375f308027867ccb72a0f89b79ce22a9ada0b4ed77853af9896b02732897f94bf5981cfad9b1082da84e9f9652e0bee5fe21e3d9eddf998d592bff4256f6ae758fa71a5b0545375f3526c628ee6ed880e35f9adfe7e910ae2809305f4e62df4512841d7c6c330f972d5d2ca47609f9d65844ee77b6e1b57d7b5f4eeac1219de3c5162f7f6d03e095ab9c837ccbfd0769642127cd03274f2ea6d8f0a41479c820c066901ca91c03b0c2504d4c2d6f9bfaab0055f5d6ef0e4815f4cb6c6f886a2e6002407087de2bbb4fad8e90039c42fbe3f4bcd1d6d46f984bd7fc89d548776d2168ae5e79df97b4c01bd27e074162a630134fc36c5022b023ca8677a193ef38c623112cf675e890b25dae40ef6412ced99996378c7789bbc3c5ce6f580421d309e47e4a5b05b25b24642eb0d8290428106c4b58dff14c2918580cb123f7d3f75bcf657fb236b9612cbb21a782d27ca5e37460e4d885041960b56748323478f092b8aa4fbc6e93531fd4a2ac5de012574b65c6235fa3acef5c341b3886703b9b6dc604760373503efbfef6faf504853ca0431f25b46967655b6759266e1dc2afd7aeb7c41af64e3d2e3f14471d5219c5a1fb0aebc27d96e53e6903ae388355f4c6f215cdf4bce3225d548cf2b38f4a90b22361dcc3f035c31465bff7db2225462fba9a719976066965e15768dd49995061e33843e455b575219c1924a98a99f742fbf93df10ef02a944fcb24cceaf2c5062caa0957db8a1b900763d74ea02e0acf9baf6df2093a3d9808da8cdf04b25609449b9113294d03311e18406625a40adb8be1a67e2453f1f47f06159c090ec75a29cadb33c714f3f22060fc03f655731da8751f45ec4ebaafa2c5b154a5de963135f5854a2331a6e98ae4dc0524a5236237faf2e2caa65d85ce658f07063e003433a589804e5317414f4e1bc8c9f9606ff9d91958eb11105f1099e539f3bf58d9733cacc3a3f3f94b3e6e55e3d0612292146c25a6096cdd6c483abcb1289f844baf7b0a667e1a402b6ee16836c80627f7c98d9cbef7de29c47c03fdc93e3a773476d45bc655beec08aa6f40583794d09ae7b70e3486f15f0996d5d01336cc0ea3becf8362bf03f751efb3ce1c60cfaaca71373601124dcd23bd14d36acc6a3bb6c99525713876f84fb342d3e7fcd1d6f471c3e97bc9ca84d2d0a5e0c170123afa4576f09ac640638288a91bffd82038e68ae80ac3347a37b7c7ddd3cfc63988749c26023cadd9db8e713c493f4eb5c30a19694b5c56d68c3b8b75083d420ac0423ec6dd06d4ac37d318206aaacee18bb3faf9fc2008dd07dea980e3845fc68cf583c18078b5ab21883fff4fc1127c45ce568ea0e7c87f1ce13c069d3adbf2b730cf06d06cdcd1a1b80b75ab2d668b689e84626f6be4c51f4e00e8d7799d09b1eee3e1bd27057318a2ea32d46b48136c09f3a4ce255e91e8d172f85198264906eecb2c541292804392f539936b3a7aa6850de0bedeccc6cc0b97afc25bd27700089fb9c6d8775f60c9a60a9b00124b33e478c75423a0c88f7995363f11ac3a458fd797787cd2dd5d9e1879dfea97bf7bee9f6f02dad44865c6a4b4a816da3e5ebf38131553e7f3ab5201dc71ecabc70ee262ae0dc219deae91c1d625be93c276cbae13e3bd7b1abc70fb8479c4d3d2e74a5f797b258097ce4ee601191ee9704fa227e0aa589fb44d84b7e63cfa8f16c67de2b40f0437ba6fc9e0c67a9c71a197418f7a6d51ffc95a2a8a7cfbb25eedc8563a7f188e5a3953fa41e32bad60910cc6b5413f9bbec6f7b3cb18e7d03d16baff8509edda38f5ddbc2a1c6308a14da765dcd910d4d25f8f41123a3c09824749ce0bacc02753b2c4737074f2c5d03327d3d1128a0930dedb7db71858c660a8a96b0ea3cf952725906560eb1c4bb55c6262434cba59039b05c4cd14dac2d51bc3397859f60431ca31b2d78ca7b6403ee2e57702cc6e7c87462ad4562618a427a6069c7b79506ab51ad44db6278f3d10a4f7110bad0016c2673e772c238ced9e45d1a471851ae3fc2874d68fe8e0607cdbcc7d96fecd5f54331a4b85f1c20831cafb3199cf737ddbcb0392265af7351569c528de610604d0d42ddc9571eb369094b0a3e12f3fa0909ad7d280f5e0821bafc2901776f4b82c6aa06524ddadb482e5b1ef1045ecc9969d1b701cf097859c94cf5387a02e1351d79e36af9171db452961d2d180f4225a0521a211819f3981799575080cba5e4fb3e38f7a881d5c6ddb0a841bc7327614907bc608259242cbc7d1ef705db6db15c34b66cc7ecdf448dbd8afd94c38b8eb2aa6fbeb18bf03ae4f4858539dbf77832ef9d831f43453a0eccdbec1301f142a1d78a39f33d8bcdf4a519c479b76380b0333a63fbd02a2911a7382f5bc9cd43cee4077322d58f11378988ec1e18592180028b4a6b68ec0f1e1a1994b9bfb339c6d330f0addda41f2e76374f90db275d92e1fa6a03a6285505e8f2fe2f27f37961ea7705f8b4b08c691c11a12c26d375d3f4a929b59a59dc2b6c0907392654416d8c15fb4251d5ad875d3645083c0aa225bffd262eb69ceee3e43cc853bc23a73012560f2070bb5bb2e5e27db0e162ee9a14752c275a6f8d869a899571f2aec1c3f771257f682d11211f4e975ce44828b5eb60996ccdaddb9f26e050baa672381e33ef8131e4ee65c8cab76f3c1905730cd555725d579da72faf527df18859935a0045c3d6e31db926b887183cf1f2212ccff5b9dd3b4ec3c53c785ada5d0f6916d114ceea7484b30ced3cda8bba37fbaf0e1d8d7bb036ee40e062d4b29cb23278c895bd9dd75a5b49a62b9e80f4a3197f81dadda07a8b2f14608f14bd79d0d767fabc7304461273490d11ad318e597652d0449262284df7394dd1770b3ae809ff55307e98f44973550d1ba47eb3d915b16c77702b967243976ab48f7ec5e08a2a801c98f7cfe0d02606cdf511d688903b6fa25318664b2d8bb48a03981d11b5fabf81c7776ff9ede5067e7b4ff2d6c25c88435e5a71129a571ff1e70bde3d611cb1e9736da7704ac79ea602ab62fd833bebba4cdaabaf7fd18af9186dd0b4c9663a8e370b64223a1c64d9549319a3620913989c2038e3ce7c37ab076c659f077cb26eccc022f1f92eda438a8187c8135d8a36a5bd505608ed97222642ec706d55f9b9d8b3af9f7395ef212c6708598c03d62e6b62be300c0f46ea8cf0f4e8022cd42189f6c9adc4f00c19d948ef6cc2b3a8a70ae44183a77d420db53f9a077f0245f24c4abe87d6369bed82af9be6e37a702622c3424194c344478d8f5a96ba49843f9ed12e866a5397b163ad852017dd28ce982c0f3b0ecab3e3693745236d4e0280ae2f836d335ba148602d242101bb2d169ccc9bc905ea90291c2a25a387b47e5d132580ca26b7aec6fa261d9484a1b1eb086ffbc2a300bf4f64bb874f68ffb7423f3e11c3d55b0843c7734da3bd171247084c191e7cdcc31727db9de3770cce15a164ff03fe0cc635525d0f72db438e64ab0b5301f8fcbb46e0ace83b355cd92efb8eb34b93c4e151b87b36efd7c05c842988123615469c920abfd1df1367e1204baf6af7c4f935afb3efa8ec310730b4141e16e825209c91ae90f5cc40d99d5da2b4560dbf415d4c2c1a99f782f1f5c9e429b839e2445328404ba6f320cc82d8977d5eee500146f55da10cb535894b7f834442a27f762ecf4869d085969a8d210109f695eb5ab3d6818288c203153a5b6b1440da3e62724ccc6a0a136441d26b528f597775b27e415aaae5a79bb3d4a68296c6f61028dde24515a63dd42ac37a7eb7c09e73f6a2b69fc8c6211118ac58e82c93f8b78c6f134ecbffe9f528fdd81f3d8079d805c81b8bc183be02bd0e2cc63e68472d49220549e6f45728966ba0bab3c098c1068f3d76ae7057e718b22628ab9c55fc2d42e67c1980ef187bf837c14b38dbbe209b548cff8c052bff066205fc7b0fb9ed4f83b9aa74ff109ff48e3b978c25fc627436a136c7b23a20dee55048160b5e96f5d3f2c537464a243c028bb7d1bd50c3d847fa7e94612e47f9e451765c6808bc759b002238f767bfae4fb24273b541152692f807a200e48bda8f322f0b3dc609d2df703b523f9d13ccc061752314e57b2c1121201e581a74494d4b19d8185fd366d5c2038f7ce107ec4fa8f9b06642f542d5c0cae32bc2089937ae59d10b425e25e01924b55b0d908017d9898d0bc23b6d7fb9e231332369c3d68d262341cb8ef023ad728898b0f62ea55dee81db2f6e6e0b5206863d6626a8433a9238758ce30a483f0c08a2d0e0b8f0a400f24e5f9b40c346798a5b89af5dbc685a3f65aac6e73fd78b63cbed52004a11e9353d7f1aa0a2a1ec6cbe9b56f203b4acab1539abbd1b47607e59035be31f89c616ecd95ae3e63964168939a8f9d9f770928dfb02102c1fceaa0225af64ee36921cd753808c756f9853c9c6dd0059404dc905e94e97ca9326f879816eae728b9748ff87e071f814182056ba0573d065bdb4fa6a8a68eeebba9e94302b4b299c5a6f91676c30c319a8b1fc1e9adf1972e8ff22516d1f162fae6dd88d4355e0a81b07af2b4c55139bb0b70eae3c32846d57d8cea85fe52c25aa7370dc902efb188e1d705b4c0ed7da65885a0ad7353086d20987a43aaca6f340e921b9968328959f64a7ecdb87eda9dc8cdbe28b44c022ed91907b4b1547f69abdc95caa9039d4e38a1168ed7c5de41c1862fe8094cf5a0c01cd9c2a3ca47d9c0d15c31102dba3ba5622551d6bc23f4117e4f9f2c9ad2694ff353ba09b9c82c474f78a238b970047dc7659b6a7849ff6cbe04d08fc583db57aac814868edde6341591a443036053c78154fb4bbbf16a76e9987f55eb014c937ddaf88c1bf923c89a9b9352ad61beddf8f307e0124717211255bade4f0c408573627b80d2c170e19c9992514f1c0ff7c7b648c79325fe09e43169477d19982356b1ba7cb1b828464e05cc1a3c9145f1e7d67881f5fa2a8b3eba356e1c2510fafe8a85ba6679944d0065bcb088539512c7f0edf891e0aed734adc8cdc38a2a71c7b5ee787f706515d3462659b59b2817f87ca90177433c06e2d6c1a2380a8b1a30750bc2476facfc628d9df9554ad4919f9e527e8b2c8ab0783b8423911e3998fb5563b99ca49da13d7a4ec330d3b71f9971550c6432bbc3ea6c3c25199be62ab4dda6e24ae786dfbd2a6c82b7262150c730365331a7dd9a3b98a48cec72e37b90fe216896e0c4cb2d1fe52bf31c9c7a77d7a589960b0e28ff06b55c65e565828179380ef30a8977f16f5ffaa6e087823cb7fc8bd3e663362a05f6a6198efa2aa584f48e15e0bf776a90e984258f9676011e6716f52f874030b50159f0871e79ff961b1d908d56e7e4c3a699fc0c64446ca0c459dd73ffa923bac06460a5e9dd8031afa240bbdf7f147d1ddbc656820281f4e1fe90df0a1d9c472d59d67d9432cedeae6bd532425678a56690e94a75f68e3036abd6abdde21da2b7e2e544410b13b1a09fc0500a91f61cf3ba3867e6bf102a9b1fb066e0d2bdb2af6f45b65754a3dcaa4a437ebe19ca6de00655c228f0064b2978821616299064b5b621c244e7fbed058c4f3e9b57c6d695ab4fe1a2d62b0bc23c34f1e67f5c5635e974f394efb3daeaf4b5a7ff6959588609a4aa83361e799c86e0f4709cdab7290f90090b9a2bebb4296c15af4d027cc63e2255722037961a4c128935e8d6d172a213d666e3765e0fdda357b5e71e286df722c6d6aa57a74af9a1329b8b0e7ad48759f760f60dcc55145c466e0c3a78dc3c8dd5daf69cac3e390d6433d82ef30f50253a9c031b8085640e322f72ced787b256f664b9e89d00b439d42ba0d219f87a1145c5b30a84fa5627ef66947fae004bed9dea624ff7403b9e82088a414f99b3e733f3c182bff5d360a28ebadb30b0ecdb72816fb09ba2b42080088d4d4a8139666e31f9dc24b952a66bcaee474dc64394a3c1eb9dbec7dc659110e88d402141b5450eac7a884c3bb8ebb036494da1e16092dfe02068dd2a4951289c7e0597947fb10e8a517fe69af617bd6874736a7adc14aa843e1ceea8b6b7c338c520a9e056beeb359e60aecea6824580d342c70221671fd122c612b265fd75cbf387e3a84e43f30e07da002bea62f3bce6e7ad1bbfaa4722a660df86226d0e9bacbde2aee8f7181c4de8d9e5108dea43756ab3723a192bead419490285578bfb95a8cc9a00878ca032092fa0d94830b184495e7212b2c99c51b21ee684a657c0474a769c85c944a67b09a873f28f228cedd72abe7f5faae727e11bdc3b52ecb768611421046ace60f58a2d32096c3a4e77aa53f17545469f14f4bf1b849eb8a49b0654ebddda71f7ef8ff50f6f07f0fcd8dda037ba257238d8de6d927a4ac7e6feb7d279cb6ff9edd62cf473cbd6605347735dabb124ca69f7a594cecf60d63c24fb7449620bc9002aa1eebb14805c389a55e27dd7bbb153b949b56a3cd79ec6329d4e5b5d51fdd85032148f78f8abf644c9ed6db8e76b509b7d1b79f36fdba9893c832cb9f69e6856d4a304086f4a5fa182bb19e8ed52f2e747d074bcc08edbafd3935eb1a488123caafc92b7ff62ee27e7f130236681700b382daf8372324a01d048a2550911442bb690ed9b0dd298ac9d2961d3fd4889f3f599fbfa883e5d6d12fa58befb12604f2b5dc2a0bfd4d45b3bf6bfa1aa86c48359d6188559c947187345a4361d59db9bbc9850681f555924d5103315a26fd94d753a132f0dcdad78983e0dd479a2184a098cd8d0d77b86807eb76dc587522b8bae0dd147e32325a80bcefa2f02db22551013d37d5c5a48c1c635b94c19c6dd913c3252fac67f76032174118508e94c60c5677187292bc3a7226ba8b9974fa855ec9f89b2f6ca2e87e930db0ecea46057d5a91a20e48b8c64c0fb0e70052285d598b6845c8b8d6a2cd8d5830c7c4b49c9eaf2d928140b00f88d19298830037e9ff489b9d908441359961416b4bc3a91b145ea56b4e94304a7b3f941e0159c064fa7afe27deb9f1543df0e35b76422875f25a1fdd30913042071e45cfa4864697b915e76633f77536ec0a45675b89cbc33ae97811c371bc362ec2383c58c9d4f7a84686c23371515d82ba4e804ccf752b1cdca356cc2c1688347344b1d1558b794733649c631aeed9ac1e9ef17c7cafa9ac03e80f3497a31ff928d3fe496f31d500d4297698c5cf90f4d14ebe4f3c136fb3f2406357bcc8c9c74dd733a4a9249ee1dd42a88a47d5eae27b63ef13e0899b42f6caa2d59bd46430a1cf2e759df3a5ba64fb599d0c716e93bab73d477af2064ca6192dd371486bb0955afb4c5ffa94cdf69a33f354207d3478bfe21a87b8bb727c68185de39d3870d14084676efff7bc456d1c45bf66414c4abb22776b234d0baf8a482fdc2bf7608c5475a4f202753da5c2a60828b391e297daf4d5e0f807ec3c99b9e55a24ac39b074166565a49cd82fbb5bfa275a8e302c41d4287e6938c45bfd558ee15e5d661997df2bd7da13194e729bc4006745fc7654f16949ae48b5aa7fc0c0ad2e154da1a6ae0c8a4847d13dbb42141a46cea85aa08262cd70ef12c5b2e99dfbd7341bf6357ca414f34f55186602b3fb043c891a30655dfc73d4b37986ababc2a1df5424ed09d5949a1d8e55397c1232e4482573cb0d54882cf0cc3bfb2ac7efc51ae13c33f675dc0188c38333a106995dd76df3f858ceed09f34df50e6467a91c33cf8404b694a491efb690e06f4c5d0828c929328293098652f7eb3ec67b1e563b71a80a7b1b342b60dbac8116f9a753ce7a61185646db100fb91c1c4c6aa7a93510bec80e094dcfafc6751a229697b5f7c3b5beed8136c01a0ead3a9727ec00b417fbbbd4187ef01ff93b9609933ed230b961fda365b4ae2ead07f68bf0eead09bd142e67a83b698df6b22c83c0809acd67578305428d078db754266222e71006cef02b17fb138d13dc9640f23fc21ac6896c66c955849e0d369e69b5a3437f7675180536462fd1c5440a041dbc3e207872c8a0ba6fed3ec59f5d0c71b771d11176169f727b1ed061b5f5cffe8f3e3669b3984b3e4cdb0081c2b5d6a8297e5768976d6964690d311b6b80acc05e869aedbfab5cc9de9b38ab53743ae36f1189b1bd16fb499cd3dbfe2f877274e741d640ab57df669a05d71fbcd7720d066dc0806304a7237236acaf6b4993eff9d133439be49d08df21476c983477f3ec5a69c07f4c6a801138262d0c725e086f4a74c1fbb7658c1314a23b4aa9667e3f7bd4f73922d2c1ea93a47d13b1b118f0d90abed29f2e200c9c3d54b4c126f5046a90f1a3d681034c50dc6f7680d83edff5b35bf64f089b915f0810ed04e75d30c35fe2400178beb27206f91ee29b840beba8afbf8481fd58efa2f602e83b70779a10c490a9b9f567f3299b3713a0093ebfc34e7f8901f975cc500a30579229b6a5c899b76933756c81e9291db8100655a99b75e060e73fc245287a378594d0f4caa7430c5c4cef242186434cfb0da43726b4fdd0528536a9e1cd1c10976f7ed483e485ffcc5ce0b61eafd70f1f1b103bd132196c96f3c274f90ca5d87175eb93c960f667716b0a34b276abcb545c08ccc98e2cd3a71a382ac516579df17212e74014802f0d2e3dda5b146b6f0314f1eebd124e0babc0e4ec9d48bc7faae8fc2556996092689540b5fc7e43f9584ede6d4d324c47682ce3fc4c9b5ca18831b92786d379bb5f3a4787355d17b6c12b9d8489b255331ba81cb733c1906df6b43c0eb5cbf47d717ee507215cff82c2fe5d5bb3c5aa639acb43d0e9ccf500714a629cc58764431492ac1a85707c9e9c69abdc9204726a212285b09602bd9d1e9faa6340a52915eb6f6116f9b12e249e6f9b6189b9bdbd7cf22479b97cbfa710694051e7b9a9e8cc8bae6cb2dccbe59d22fb6cf20e4266333501a203d8b7e37c84f1c87c69143123a7c682cbb0ccfe878f0f4f63f284131a0230e9b2d676be1e7aeac6950c041288f5307ec0f8715f88beb62b84158a59ab28648b02a87a988efa3289de5ae533a80d0959c090555c6119277a2ae298f40a621f6fdc1e9d96f5eb9510e31c5b2f73d543803dc0bc2b3881487b2e27ff687d3236c8ec57049351d9021cbd35bdb220cfd81c2579f3a128ef3e7beaa7195cab507152bbd185b4ff079a72beaee5df01656e47a6d091dd1a0ed37f5fc8474d723f18b0251f1515ea9f4241d284808236b4793f4280f927d6cf581c992ea5f3a4294f37406075cb6eac4d101817f49a5b2e5fc65d470d7e3bee5920ba7e42eacf2391ca04d1ab47e076b9032bdd2cffc18f309273787d641ced578352491e5c4b2c245f3623c409d6382549dbd96fd6e588ae5774b90180e4ece350cd2c187df881e2b528630a28925249925aea5ebe177724d173566e4409c8076ad100a5dd6d93a0b0e178746586390e491f0ab75c364e16c98d18cf9de8df43654df25bde07ff1a223ea6ab15572ff476679ab736524d50d1876f43213f0a6f1daae5003ebe5aa38abec3eb69e33b544f06fad1e9f986074d0025f97407ee11a45f62315bfa7974dae93b0243821b9a6026aaf9831b50a20050320b0d14cbd868e15aee54822a1deae7cb921bb989c9d5a4546b4b319962c689678f787d745aff44118a6032618b0f3f586f0e123656d8db7d18d0d5e1b700ff1a82b07ebcd2c7d6b34e722acd737089c3bbe998bae6b3ec8e65cafbf07ecee30742a91e8db6e968b939780fd8802397b27340914517271fedb7948e073fedee86d5657a85f8c362593516ccc93ba99428cf1dd26ff9add95aa9879b69e2f8814541dc50dc66a64e899894cea245276e8f0cf5d2258cf3d4e193a314a5491168e7aab30565b36ed605d4c14b3e0f30cc26adf56556a9ed5020304e9c587b809d11fb0679147e97ae640c43304374fd7b20e354e87ee80b674ea714c38ef56cf5e4a58c2488923056767561b218b568cc5ba77971d5366f2abec12ae189a33dc79297ef5c381f273e9eb646d0936c2a675eb03dd3a096d4532c6d7d7278328960056544f8641cf1343d8b1653119417257d870435c2a2ad5101f09d0d3fbc6f48b58f331218b61a401c4eecbcd3f2119d2e886d59d07a1c5abd340ba04cd96c0f966d445efa05f15585e26da4b7fdd643ef31905898473b89869b6e56fc03963f42cf45a35b7f2ca5e83b4dce78096212aeed8cfeff874469a7f5a017b278fdada331b210d421e47d3651ae9078405df0ffc0051858f17150633922cb38c6fae14cd3b6d2cad54938603a1c1859eee6e5265f392793dd7ea81d86467236b4ec228554fb7c09bd561a652d9c75db2c3935ba691bf06753abc19fe5c5a9d4cb3edd0efd9d9759636c4a1be7edf0ca43a3f73c42bfc27ab42ce7533073fcbc8f0036e7aae749968b62960ea3d7d7ec5f728d50a53e50c6e534d90eb7af2b38602635a8ffa201004adf8f9796c0133a3575c0fa0772243d04b29a749be25e70f020313940a179d3cf6713f5bc89a1ebf8b43874fa29895fcb226ecfb48c7f1160f17731668cc55145f51a6a6deb8347daf0af20b3391517a65028fd89f93c7e90e58a3f183c0f34be26fc2f3ec835a884c93cdcc1232321e7606e1347133b912819f1f4793af1509548fa0e8bdba4798ef718cdfd75608db56c379c6dd2460c13b5daf527102bb687dd334fc94d554ffec5c7ba3c83accea5c24214ec1734d8f59e8215711bf5c80ef50082d51c9c66e7dbf2da2721004857bb86eccacdfd26478732a4da5128f7f412c1c9fd116201cfe2a851345f3bf4cf9e1393fd50c13078e746e682bd431982c66efa839f00ba3301371d6b74af5334d931c5c1c8ff6bf0a6f8b9b1164b19397e1de540c6411a6da8136f6bdce97bd326b604837bc6872f33838434923625b0705ac5f1e2f084396306e006c69ad7870ddaeaf3dd230b9b04909d17a912287f85796f1080d15c530e866eb1d71a19c4c5716051655cc43b3ff414bd6ca38831ac9024519eb843ee0e4678d9d287856f6f4947d7c1c7d8a329c8a8c61f630eb1b0bf05809a27dd2fcbb1bb69ff73fd82b7c9ac52d21bc4e88a8be3d5aea84f5b91ae054dae911d4723c43894de5e8031aa1b9c3d1b763b31e4bcf09b1f2f1c09e6494efd161223b0e9c2288888c24dac2452ad012de306f4b53d1806ec9720dd73e2b75c632dadac05bbab95399144478c5c7595b2989faa47df1ed15554f4e9bbbd30a1b329c4285edb2a56a47180c39c2e145dae9496650a36ff70a60aefbc1d9754b09f963753f671686da7c9a922541cbc8eab9170034a744ee880f70af24ccf4c0324b5c302bd8cd7bd37088ada2e060dfc3400ad2cf1033798760e67220b0593fc0306ac7b0632768b582c07ae468b1dadd8fd5abcd957c76d71c04c1cf592e9f62be3b6ded2e7270784aa649215a5fb6bef3a1bf85ea2bde77933a12272e22b0a3c2b950194f6560e0ede4c0b586fdd10e95de3be5a414d77c219c117c77e435bdf255aaa4bb19ec4b86f9b1bba528697bfe9557f6aa22eeefbeb7bdf10c9962a0dd1f7a39ca7bc2863ce6b3cc6d364f8d456586751e43ca55e6ed0a541ac8ef63fffdd2411a874207c4d60e97bb6efd617b918b9a94963d4fb5d60ffb44eabe76343544f9c23ac4a0fb6d5d0516cf350bdd82b2731da6637ff1b1e4c809c9e3b938d9464846cf4db318c47ed177748a45903fd64ab1242eae1cad18f56b7881805fe10edf4d634324df9b7ad43bf3ce1fa1a5abc3456a2a5a27660f1ee330365ec3e0bbe6b74a12b3653ee12baeaddb67dc0385f01cad49c8a08b435bf91ca8d1ed44f460d4f242e90deea841a32186bd1b8a374561456b0d505679d7b6d6c03ba7553f22665266827a0ca63c05f6bdcbdde870e1d88ad786be4cc6675b1d17f940ca48e300c041c9ffa6bfbad66f4a61f534b5377146ea5e8e66182c942f53b8d5a282623febd441c1e3fa94f3374b6e5d08ff4be3dc3e60b19e648b9540bd33acc4e91f6442832b43cbbd666c80b152090807881fc1997320e00798d115ce3447c69433a5c9b0c90dbe26113bfdd3c49a314f51a5561e180b9baa41cd9da5b13eea6d9fdd0a5dfe32c1c0e46c5adb082bea0c97f1120c35a6ff50ff22e3f24eb37fc0aac861aa687ac0d4812d18740c97a22f551ca7485ec4b32440e8bb2884af423cc81d96d4bc43923393da11d3d182876d2e3534f176709235abba8efe0d8707c96ecb4eb5bbdfb4f1ce9ad68e2fcfc56c26276a700d39feac303d5a4d41ca4f1ac01aae7342535e47c6c6c008261ee3e74a86339a94222896c1fb6b22dd01ab6acce3332186d95a98a6d2835e3ca020c8136f62d9e4afed74fca695e4553758e35ec9c21d28acce34ee3e59afb24c0c59123e2d49b9ae6a1b81fef05aaa7434f97b13d3caf2e71b1b8cd46076044e5bd562228d7741063478011121ba6a555df0df4c1d13d09d703cd9aaae90c6f100a8e80e8628d3c5f984ae27fb84ceef39c7466610595d93621334077db76ac3c0cbe8fccb22a96d2df72e3881a927e58043fe25406c59d2623513ceeb1f08feb967d3636cdddf11730eb3b61b841fcef9b9648a9e10b3247d6c7fcddda9acda114e8a54d21522c654c66fccfbd5f3e086464050068a763e637e66c05d649af70cb402cbe4c9f6a226863a55d3a03e8925bcc960dd55b78ba03c97f4a65db05bb2b8c8208cd1498cbe2dc5ec3ee908a577e95c8e85403b00660e56527ab88400c102ec89e199caf8418a490561dbcf18705bc3e1b242bbd77d88f652054a4936c2e8ce2e59666e461a301f30cde4f1be4cf3a95842044da361098456fe9263f0cc80938d7c4039b6ada5f3a320e23240d4c457c594bc196fb78a74ed1319f853a222f2ae417a1daad254ac37a841a44ecdb88446c4af2cc53c22b854c4415141c2b33c5b572ec031adff3ed5a85710cae4785eb1ca634b2e1b8a6e99408940050f0b7cd53ccd9ba541695d2ead24d8d971cccb60f421bb4bb64213c1d7d579f40eb4cef9167ebb41b2d65d1fa3a139470ddd1ea20eb3e15f1d9352c15a5e7ee3960c4b51653d802f4a1eca6afb394219b459ed9c5f9323a6c3ab353975103223f645a827d1fa63a1cc8734f3f26818f3c600812b5e817501cf491fe68ce27a12f4e20fa32f85df811694862edde79823a1f9fe24b4a6296fe7e50a6d5aa54b12426572e0ab514bba64454d926ce183732bebf0cbad2175eedd08604584caae4be83f6110ac1dadec449ddb4f1528efe380ae43b0a44a713b6c3037ff21c30dad6014527fc4cee871970cc06fff981df8ba5798075d428a0e39dad7c6d27cbe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
