<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b16ca1e8e60032825fc83d26dccbccd50aaf09dc28c970f06f240a6f5775faf57384f73d7ed75a004a7695703fba8b592ccfef7a45c138c2f28016fc041d79000a862f3bbfcafbf30f9cde25dd3412ed88dfeab512b576b7ac812f32c49274eabc3121ce9db1586ab6e5c3904dbcdeeba9145d071cef9972f95cf187bbbe3f6af2d0fc5e957d52e4f281c35fc8787d3f6ca7f7c7cd444c999f4bd6cdc7eb39d76c36031a4e2d0aacbadb3922227250e4d3691274cca23056ffe5da7f82f07ff43d330004ebd662404732154c20e184f217e1d9f0f8d87d17237c60b2a8a27b0ef98b71ff24d3bcaa87315d35eb7d1c4206eb50936c050573767c5d222e8e4dc59d151110e132ae81d9bf6244b8e57964a529148711f7d03656ab748ab516635996143759520963f2199796dc8a86f0c4ee13bfff002da6f0425c586f39cf911e4962c2c7024b5ff9e8f0f5466ab7b19849dc36df00f7308a5d6db4e29f49685ceb95780b62e7b485348f9d3f85e4cacbe817c883a4f6b47a630078ae1aaf1764d3282e71b42e78e5f002fefba5a617078f941606ce33e76710176ffcf73d4294f8c99e315ea33a61156134c6aa2e9c258cd0520e554acbd1c0c4b27dde43d43dde094a0c197032c9c603ffe33fc9d28e6435f04684d5287a05975f2dd330b995a6f4287ca0fbab85bddd2f5b7f29b92b200650feeddb60b3b637233aa4cb0cddeb6d0154628411f3b34ae34d3e51f76df4d34a4988a08eebbc91c8ae8472b1e74c0145c6fa3fa1c37c3082789059f089649d85d529d897809ed9311cfac37e1fda7f3111e9b10ad3e5b00d299ebab3fb6b53760241095c017aed1a26244a3c2d5cf7ede87d52f5c4cd9ffaf424386c731ebe9a5fce03087cf94876c1c0f463f8ff64ee3de29640bbcdb2d3323d90a4cf465dbab558425496ebd734375e1f67a4dd5d343ba38d27c47221974807cbb866decb4cc3834a6c096d3789f5c9fbebfe8aa81fd6bfa45f997fb69b4b35dc431c68dea4a04dc4bc6643aa8a94d0f509e63a790197e633adcdfa178b73730a7def4b6e5794eea251929231a76d4da91fb329b4c5a7455c1a7e6597241db7d33afecb84f2c65d4e2db7031a3b33eb9345e3701ae70d4968e3306552061aa0830a8f96f1efe5fafff4a2d5a8492ff38ec65e15d6397e908476abb2a3db538fa20cd0c7515026f0ef77ea78cbed71d4b2cc528fd24a869b103243967e78dfb694606a869bbe8a37b5e1619b4992a905b4766b53933df8c7cb2ff387f6bcbf7b246b1e1435dd4569aa70aecb35ab5a233821a970b78f0d9aac534cd47334a4b3269b3e8b152cd86bf28eaae7b20190b3cc547b387ae5b09248935201aca1107c83272ff5a4edea410557858ce1817851acc00d88f80397dd15dc64d496fa8baa1d1c79908eb13bb6ceff462e650672dd30ab375d46bc45eabb1dd019dbb9ba6e34c50e1e06e534fc6fe5e661372fdf765242f1e405aec29cbff2a4cd02dd7f9a06e7705992611923171c746c357d0d35174934bd477d806451bf2cd8ba95be9377d674793aac3c7aa1c26396803d946d21cc85e0787a4627cb6dfe4a9c064526f5730fe78d0c757a151814d1bfbe359f8bb3771b7f871341bf1073c404e72f899a91f2c94d517f46708006274c291e8739541b297140e3280279e6c5dbe8c9c32c3f095dc8b05e258556adea2c5af333a9713d7b316b7353c573e837d56862cbdda73deb5ffd544518a26491851de8b3eb29d7f818b797ba9000b6d794bed0f5b43fdc29279c44574b5389fd98633190ce9ba0720c306a2b246ce3537d0b98ae110e815eab8b5ba5fc67585b5abd040804a3422d7d5690d71f55e2255f4008038cdb2fd810cd130743b266de796ecb63bf22009097265ddbb0ddbc6e32aab9aab1bf123818f85affa58025704c7287427058212e9fdca545770fa8a7681fd3e52c46cfe56cc94f90794a9f8c607151df86c57eabbf434277f0cf6034dc6a1127123f93390d630ddde76ee61f9c19c1202bb8ad6fc016e85ea407e864f259489a6b2541bb46672aa890bc36ea40514ad91ec38fdec042f4495f2d88b139484f2c8cd03ff2389ea91cf4eda62ac84ca6539df462f9bc4e1038a1da61379faf302c76c7dddfb51a95a779c54566899512b19294ebd8fbdb4f5bf6bf25dcb233d398b793398eb9157c221abf0f772c0d748ebe2d106a797d54606f3676f65c08f322a75961e036f05928eb2ce6748c6d8bae4b9771eb6502cb76cdfb876992552ea86e1d10d646faf931caf3c4529c5c44d4baea8bd0467b7a29d2fded72043b731051f6cb7f293a2cbecdc8db1353cc085d304ad9487b25a79621700147ce2ef36b62b5f4a51b3fd81fbd539d5b5407163ee232b8d7c19686f910e661796bad983291dc48c7b840d7bba477ce1de622435353f1372a1fd3cf972aac032166e9b547a707c2143ab4a751b35f7484d3824e9125e8bf3647657bbaaa8f411ef73b127fc9ba59758fd03e606acbe44ecd846f373163542e2a8a03567e776bd57ff38e3ceb0bf5b70356cb46d16d55dab9d5d0fb9ccf8a54bd268b7227e20475b40c46e2db3c65216c37345985d311f3532c5861be42aef93ad0aedaae415168c8aabdac34a346d7ba8d40c4c3874fab15ddfc2a9705eec2f85707ba8254f29ef0a8f3e136d5fe0f140b097774740a481a9bef222981170e12a8fd7fd0a9bb049c50d13a060b1d89d51e30146e3aee38f46693f9f2c7de657d12da05ec072729cf32f1fc9f7438cbe98920115f8a38f5cca29dfa33f07b90d1dcb9d38b31781bbd370f6f381e38f3624ed5b78c0237ab0459b5199902e5780847a62e99420c9ca774902a738058fb27ae3bbe63c128b204dd288b9c923da29eacd9731064d0497e526eafd6335d764f95e29a798a4d78b1303778aa8f6a35cd3183fe772e4e737c5422a4cba8502f77286d6c21746122a022606ab2d72cd590db53de9153d87e06368187e591d7127bbc05e8f1a8690f05557d74e5d4d27920c20b917875b0b1609c3830aa728ba612429c9857d4e1d2ee4b163dbcda895cf29a34aa2732fd2476f246ec4de3ac581d1765b6bc1859f32604cecafd1c1978062070f95de1be69e271e04de5f952a9bba47922656722e2d5d4663ede8545e52038f82d9459a6888efbc112969fbbe37183bf074f3f3f1edae191e7848b447a6d5ac03c42d66248a309ec476bf09666fa6417a6acca3132f37520490604df047b3aa14d105dc5454e084ab3bb8534c83a8438937bdc9eb752109284d1153ad643664c9ec9e2489a8cff9177d9177313b3ecfa5f4692262bc64aa5426dc26fc8bff10a550d8cfc5989f2d8f88615b1f892cd74f9aa2837febc5a360768918388679c603ea334f42c628bc298eb89b463eb480bf94309056918f8d8d1c625d977d239273f3cad8758fa06a2eb0e0b286ac03b16cac73c776c267579e4f09ef07164a9421e7fde05221e113f0afe47ed04b3a543ec88ff48a37b9bb5e62a20238cd5bdbacddbf0e098ca00138f13f46627b107f65d489fd4e7615d85b0d09306b728be3c04ed6c463e37714983521c166a699c03faf51c4935a4cefc20d0066b8daa7b556e96be54da422c7cb0b2d2d3ec079f240d375bd8165771239ff988ec2214b2602fe121a766aa8129e316a7a3f8e337de0dcb5945e3dd6e2ed5b1333cd2336abf4990d0225bcf852e7aabda7cfef0ff8961f4b9124d266d7539a1dcf11bfd8516b83236325a689c7f840b1e5e22926c3fe133584451c84048208126d8f791b8aa9965511110c8a14bd5e80044d6e3bddb307718f32a3aea0d5dad9f3fe8fad73e76fd9653ca35615d19a921e34db28edd756cf3d2c5f5fc0fe3fc9c0aa21b5faaae03a971dc7272bdb5881ffdb049153550619cbb5dab3b36744da7482c5bb654869ff1b199f8cdfdab6fcdff0122bb5bdc523e8f2e3e0614009eefbba8a997e4d0a158c512411bb33f0e3b6ab7eeb8f3784171d13d08655e5970333c4f0a5f52c05006f533bb9fbd22f3fb2f93d17989b269daaef8f226da83a4a39283f9e4d32215ca540835f1998a9c6da08112a3993c5386153852d51dc13c1bc5603fe5a2d544cbde84dcb20ac99f5c3f433925adb19b2075c94863c7ce2e3cca6969c6241165d86a1d808072075a85ae871b8322f690e995fef3162704f4cdb5101f916f8fa55f01e032e4b2a2631577a9ae34510edcd8fbf07a1fdac7fd0fc3ee7ff13264fcefe4b1c40202c64817fd4044501777511bcf897cc37635b67ae092dda78a2daf76669de54bbf0faf887878f768ed87f4881ce496914b3134a3fed24bf41174940c54dde4ebded78872adc1c2e331cbe2173a989e1b68453e1d1334e726b8ea172ac5091d928e5146488f61bc0f907cac28dba275a9b5ac73903e21d28f6c23d5dc64d1ce48c4cdf8ea3e4d2143856b9e5890a13675074bd57f9e393ce524637457515b505534c8c7248989dccc76699c3979f4abd876263fb66c64408301d0c4201993a742b61a40913d9106ff109fc05ed072af525980e0251ffcb9ebba422d3759405b416a614e883f3ac9280cae01792aac68f5cff5ef2a98acad7508ea9f7c12455a0bb3e5528be0eb018a5a30837b7cafc7893bca6452735c9563781d1951b4b997c1e0cc835f2e4d0480244bbcfaf2f7efe876e67479846ef921e4c57a0a37a91c6a9b0fa152977d2a44c7067dca0d7ddece9b1a6483e0c80c7377a56e6ed04ac51711ff65fae43f859ec293c97fd5f0c3ce3ac7a2c8b91cd04c1455cdc77fb957ba44328e02aded0d94458b0708a20cb69a42aa263c8627a1d828b68efeae57432ab68a7cda52e688122f19c9465c195aa0c96ec24668ec7b6422a984f58cfb8ca53c04098a478cfbe456562d9eabf5d6cdea0b7ce410d4198895fb720e8c83d878a47535be21c49000c1834163ba775be10e3fe90971e7be7165298b9fc1cf69b9632e6c79b62f34fef78f18e0d7084df787afe0b96c3bb0153688d9960075e3f916060d1daa474c195de745ed271ae56a96b3b4501838ec9c8142d7fb01fdbd0afdc86fe76a1d1e784898526164f505e6f78a522b089b1aebd93d707b918cea1ee6967489e5bf6c46d4bd088e5a6b7d68d2ef3038fc052bd57a36a659c23f45bf46f7b356eb4d0cfefee47643953275025975b43d95f73eaa5817db3e9ea5dd1b66cb01dbdb70b4cebf95061919bbd0e046bfb0200d969039733af697b0fadf0e68c2279e0d37153103e5529d93a93d9bc8f5a8a2aa8b3dfc29f642aad0b31d81bd99bd766ff739eec7517d7914b623317db0c45efe5a82ccca0e3315bc81daed6a6daf34164ca67e981f7137cebc0af9c3427d114a99be24504bdec950ea0d72b078feefc944c14e136204889c96343e1e60d3e926bd3019ad4b2b6db640b16fcd6b4877300df1264cfeb08bb018ed5c49f83d9bc9ba28ac109f9224818d339bb4546e3d20a7698d9ecc78dfa655db1da5b0d8ba7c8ee61c17b29e6bb7b86a65691a31b99f70fcba6d244f258d6d854a2ebbfbaf7d50e07e3f7d29958500013972605d65e310b6cd7a3376cb56c3e75ebae911918cec4fc892a9386d05676a3634d7840b80c05038ed0d4b1254bad9788213fb0e12e56713a45d2de91f2b16599c75eca25251a11074c28706886718e0d38798a24a16f086e623ae7d329330f2caca307218deca5b358ae07991e7e6962e30c7d5297c8b961912e74704062881819096ae35be3f31ded7b48aba972e645de6e9a77cff4053b33b138d1f80ec45331d9fa1c8a1787fa1db5b4e47974f54731419f87ee1bcc6d343d27fa0cfc961817aedb76c00eec6626bd17a6efec0c9d6c8108edb2838aa03fd2a9eeac198ccf7669ed44a36812b1926ef97043b7784a5346e3c74a0001d5ca27ef45bce3b22bfcdf443ba93cd9a31de54ae9c7973863742ec8acacc31a9b306eadf55bd7d4d4e4ce9b7b32e77cfb9107369cfa79841c0b3d16b9c98cdfc64f659977281824432108149a4004fd6ed3c3b7d6c14c547229e61c8a32791a06381b21abc836e0a7a368dab45afb5b810734032754c547e36a62c00cd584c3ec33cd67ad7f1d59b2676588a487575d302dbf01f9a332a1e9640a6257913ce520986833d381d3e3f306a5abee1077f86eaff3c219dcb6bbc62ff4f7c37bc5b38c94fa53cfcde41399c04e3829384ad151e4caf8f8ab2a41a02603e4c9833f006a744c52ea492a4c9b1083ffb4f080c39f812be860cae2206a1176ae7f3febb3129e52a8e56b8642c2a62959444372aa32c8d5f9757a516601b6c02a1ee2d343ff058987ac38a8768ccb1a18155948dfebc6cad3a428d0ec1730035df40a618847202d8aad0403adc83aeca49e848ecccc468da0c791e92f47e38903abee013c203748635e145816390a19ee4d755aeda649097c6248ececb0ca67b1aeda28fde9cac8d25c293d3338ebbe77a5c6775322fef271222eb305548f31225f6849bc12f4c4ad2bf43aa1769a2b61f0d9858ce8284ed8eb56a60a8e1fc98de05380162051899ea0363361b00070534eb51666717d81f4de545bde1e1440be1c09677215d0f3201928a35cfed5cb1545e191c7b0794e4efee346497f2ce73949ea1aa6ff39df472787c8e923dc3de69fa59c1b6f5073dc8e51776a82e3157af2bbb788b6c650051ad1a7ed5b535829c0c43a5d422b09668074dec73a0a70bb57183be493b276438427bd81da08e1751e6862c1c0b5ae018bc7d6e2832fde3d3ff4296cc37a2969538857c4f3c95515b4d4dbb91db2c7d413b2c8a0e183f6a76cdc7b7276c450e71eed5a64647aff8bfd6a6e92a34ca38be58aae943bad3f51d8f155d7ea6f9e965dff63aa4399a1117ea698ea1568bbf68adc0b676e8ffc0406fdacf42a0f12ab08dee59cdfc8ce529b48c1645cab093d67f394a0d7da3a27e96109521de96751db016f80510c427e509cb2c55c103969c4a5c052b292ae66975d0600a75d1aa640344d9db930461d77c47b75af7db28bd5f88a46b74c9e00859d1f50cf2b6ea110241402d7b7661b873503364e5f4d7ca10c34b60b3b3154d2d391c3f8159c3222421059a2f13beadbc2b5ebc73726675a904a734de50009dce75c0da9ed360f7dad6099030084ce4a4b853ef55ad5137ac2118c72f846c806d0f402822f4a7bfd5fbe6c8bf6ccdb07bc2cc2469743e202e73d6b1c3e182ac0a2cb2d9829180651cf50bdb8ee7af9ae11762772eb62a6a0e54b171dc1f9807528e288019e9d6936dfbd408906de83d33e74bed527100ef42a59ce4558fe781a21aa3f9e37383d760651bdf9d7c8036f5a02fa0b6fce1d821154b0b286fb07fb9528ec3507beb4ea6b919c0d1d78bbfa8e77b64b0b21bf3eeb9b36da697a28a5cbf064066f360f496203b08cc52ad4cb81e3798b7e660b2d5c325de625e08ae569894817b544617718c08f12790117654593fb1df9287c26e240bd1212c89c4bddf42e4b44ed483eb97ce6d48bda5e37f8760e79666a029919942ff64b0cc16bfe6e189159c65f8b725ed9ab5d3381a7ccb635c3da8ed30337c15e24257cf79485002ffeda5f93b6ff37cc87bbe2233befab592ff600760db1b9ce29fa93187d77f78e6e8eed27932783cf73e180a7aaa645fbc1018b05e77588079bdf476c2606d4f842abbd557af999a0814c0cc51e90e137824228eeb84333964243c72bb9e50dea8c539ae2db08f78e6e7a7eabcb04e8fa345cc663c4fe1270ad6e61ebe527c573ab8282239ffed94fa3f6c659300f9adc7edd0e3a24b4a53138284253fae1d419ddc421b71d34a49d678af17a12e1c17cd6e292f11a4a9c29752c2568ceb57b42efe3600ec18e8277c3c244ca2cd32d92bc68d24d0c9ecce89ffc82d2d2d74e76321837cb011cfb69ce3bcf0ce34dad0b904540ecf91809d51cc99ccb2801eb4405f2699c6355f497258bab307b1b5d8f8fe2e6eb6cc02a4f42e39c89be5c27f7c048029e7f3cbf8720e0918f2908bcd081b1ecb7d8c2afa1919bf1bd6093ce0900707235699c5ef0923e466cd35d709b71ba0572ac8d7b05d0debe5a7674c204176da1d1cce421667d0076aca111d083fd4f65f9093e60001eb11f9044e6e573fd44ff05a740439f24d4f5afd33ae35dd0d015355f7757e994c6875f85caab99327d497e124946eea7dd8a65fd28b9cc5809b07a0d82886a98934d2864449d031b74e6c00cf143aca0328a1d43d406baed0c19b047200bf912e1df98a96f49d5a51d70b761f84daefca136b4873a339ee1c2562e9fa54062ce5a1498a0bc2a75ecf637efb7edef64263fc7885b228828736c9dee516a5e84328b07f053c0619dc4f76f080f939057fd0284c8f81646b6d68e839c131e03ac8fbbb007537c0bd86a884bb37350eb0dfaf814775aafdedd8f00ea10d99e2d7d19db9fc0eed5f4d28ac3a1bc3fa6eb17306c36f5b00f3fce69a14ee10fd06b519cdc19ff979f547aee391cb5af41c14c596fa50f0633d56bcc4e768be6b58bfc04594b36e5587439f42500513800176aafad515b3dfdc6a02a79bba8d6fed5ecc73d4db55de772b8681f1ae384af0cb4fdb4c386d0bbc6cff7a2ea1706c9b7905a6fdcf78395fc7142066903270cf73a3a2e7a64830f75f77b1bc4c807cd19bb35007752f276d96d7e1a1b6e08bf4d5a01e745f06212be0b816829aa000755b4a3cc64f58c3e5130feb9bff05453528688401c0596b513af9bc8246ca9f23afc8a92843d64d3b72853f36398fc5ddc1dcc620a1cc3dba8a02f9b48aad2b425d918f8aef03449773f039da785f7c109391549b5defd5be816a84432b8c8dc6cb6bf53259f83e463b9af7606ce32e6abbb9f66fc34a8c02a5a416ba2342bfdf8169740cdcad56c1e260021b8e8d51880cc6bc30aafa9be65fe8560722eea150141a80fe7a2d9eae5e38cd93b7e2154b7d103da57183ccff946014a3c7cfe6e72d3e031872df5481f4896d833dced7a563c24349c3c54423055ac701cad6e25e08d6017647c77deaa5404bb7ed264a2e87406abd0f3d322e827d76bfbea4cf095461773991e6ec44d7f7123a0702651eab50074da4e1d809f5849d2f234c155281050d22429d197507861fa2b4e8c164dcd46473df96cdaac6b58b0c6345bdf1e13aafd530901e3d50c6233527b7e15b8e0d27b898a5d466a93bf78895d9213082a4e2a10bd0803ba88c705fc130ed2a38dd709a9693ca6b9d91a59a4ed78586498aaebc4f8f088e75ad81222619d9c1687ca108e004e2159b814c0c10304659cfc3e993832079f8202a43af9273862afc49389bcf85e1ca41a77ee6300038e79d30ae52249d4d547591d6dc7610f7b9b8c8b263435cb93850d585fdf99e332616a33bb92538b3e7c5218e04779466f4fbfd3d02aa4fb92ab9c28c71e612b655562645577683a4c505e9f63bee64d625cff94c3c9b63e5b7b7aae462101b435357c6b7fbeef0db1569e609a3f4f7a3e8d1de098e31b583258d3af14cadf4aadc7d491cc8272cd11904bfb1b1fb2d2ae6e12704c7de753d87489cced5d6fb7a494df5b7d5f8ff23c1975b622d0d5cd581e3ee1e57e4f5f4dc5dd3a627f9ba62092f9b9a4a6fbbaeb913b9108adb90689b4023a30f253969a0064e12e2276a9c522c0b05bc640cdbbb3a0c904f6ce0e8e935a6070ed7f7704c132a6b0e7bc52b4d783e9990781c73618d767bc7b9929256b0c66eb443febba79c975cdc7a76dbd4aac31ad41e0ba4d57e02f58cfd8f9c32774845f9ee899b7ff8cca726220b92b835cbd0792d010472fa7082dabdff9e5b9b495756621988b514072d4181b11946735e5895b597da1c4558719b69c5632c4f003540ce8b8686b6e991b84e5ae1d3468aa5f671100ef9cba82e22f74158d9947d6942d4f770c01dacf0924020633162215dedf0b38d89e1ade9327c43c486c4b7c527a6e1c947b98a10c718184fd8dec5a35cd17ba3ee3df3048f41eea2f072fa0ca364bda595dfab15d40e2a3a28c5fedb7cbae98c934d8479d86f1b44947af661afb14a7dda4e5e6d19ac7023e2cce5a3afe3b2e79c56f6c5f9cbc3232420df3b98747d18cc4dfd1e9c2de745f4188dd3f3e0cb58f8210b1003e32573f7c8c1a968d1e56dc25226adb8a200ab05bded8b435d8f96b0a6752d31af71f1ac37beb1e52250c95137a3a74986cae6b56a0879a0e30c28d0b772df58ab48a1817c46fbf5608adca8f230c0d85e93bee9bf13eb9e707eb8b91cca6b304d6bb51ecc4b32acd1b456bfaa333e22ed979f884e5394022a0e52ef3bb953b92163e43e23bfc81990f80727e13a8a3122c0c58c55eb4bf411677588484c3e554f4f067d2c2a99f6b9f4472ebffdfc9a3ee9735ad2f219c79ded6c65e7f02a28edd833571de0d35d867a0d99d78b11464f653deff4bedb3d659a3d3733aebba0e61629e7f63d985f08cb8a19a81617ed8d73c85320ced1ecc32f569f03772b3abf90bb72c0c2938e1b889eeaa6b6e47cac0afaa7436e654aaa5eb21ef39afcfa81ec7c99674531f87d00181864ddaddcdd75b40baa00d6d8b8f053de724a1c4ad55ab1db065dc7c373089a10090bce97fa1b572fd381330cc57175552f9d03d0897c008d19e7f8155b745d90bddd6e8bbfd89c10b188011cb267712cae34f22cb965c3aa233ede8e8aeb8cc4973c181be99de6a9cebc3b8719061dd50887c029e050928de016b697d405f153229e46d80429bbc47ce24d233300f024cc85f9e097db02338522852fa0ab4072fade2317ebd252edeacd446420fe49e3ba7b411cd094c947431f8474ce45344e462aca18366feb53a54faa6b70b85c33123612328166e306c5fd34ca7c16482a8b4435197eed4a58b727b8e5eb03983e0bba87055fe016c202839f8c79fca264fb1ce04178766b6da4699cdfb10706c503517ef3b12ff262e2a79394c5bd991f10ddaf28c9555bc3d2a8b4b78213c8db4ab8d3e7bb968f0327ab044e98550df13a7b58e85e1219f6cfc74f3a25ee4670b71c8c37d18b3ab258857c251a6a1a0d266017e50806d1dc95c2b828dd83f44e4f174adfefba604d7c47de7d4b2b6eb779d24987d0d5fdeb6faea43a310ae0bfbf0a20e7dce43511dfd490d5c4ffce0e7b89cb335792d1befd07cccb49a8560cc1104c63ac7e7ba4dbea8b67a2b38ab3dd25091773bc1263151e6331bcc0069c925a6c5b5765ef8c1ee72d6fba15b599b88af983f0b91c1b1cd51f86bcb902a201e4224df9705ceddddc9b1675f09563a2fcf3752aa65c071090512235734803c87742eb51e8bebdf3dd006f248ada6ded319dcf9f311cbf0f7b7d3097d0da21a3623e2f7ed7b0989ec35b31ef233d1233d2e2853b7d0e56e329703106cacbf5dbdb9dcb361f44e9e89879a1b740bf5835333fab3e7166b821d585206a636144f99f27dc3b85515eb4d0cb19a09aadef84531ec57aec410830dbe9ec5d18a36fdbe79b69e87daab0659d09bc28deda7ea9e3c3bc69a221e350e07624d22c9720566097474c8c7f1187e69acac3c2cd42026b9105fa6d46631360de5e49ef3c00982062c98a6aeab6658ed8d8a1af51189a170f4b830dc62ed27a81ce1edff85a363f3edca94e61eb0767199559bdda29293d9ffd877f931892deb7e91674238f058b9211a69d6ff49f60ff3c7447aff22f96eb7a6cbe5d6e9e64eb00520874352cf905642f69532f2753ed3e1f44d542d721fd45f876f042c3ed95ea24501d0b690cfea72003b0a7991d970fb960003332159d5973d981a4b173d8c9e4c14b15dee07360686355bec01f967a39c882f8aac69a55c2bbf006867387d68b9440092de1bcdb123a41c7a598072d6bf4e6bfb8476a4ddaffdf491a52e31cb305bec3b4de311e449d8a9a339a7625d7b7fa97499bf082fd3e3c52e52feadb75fd63deb0f6f2ab253568639bcb2ae51a7f4702b264c1fe59a25ab041f92010d033ccb2166863216f45c9fa0c75813271dfabb08bba78aea90b5021189de742c8b113e42f3fee6bc3425e8cfa9ff09e4ccb92d11cb5d1875c391a1f3e600b86551f0d791f6c1126bb145c2f81b90f64ade306b20e01d01d16cce65670915b3287d956fba9e0855fcf1460ff6dc915764a496c7bd5ad296c240186ff76f7827c6efe5e3e979904729bab1e4220f0d5e4c6fdc091560911d17a9f2cee87f89b3d5fe9bc2f07f8ce423fd04347180b633695f067b5d791de3935c3fa804afb79441dd53991e70b48624f0a94043ce6e2f8e2dd9958df0d1ce71884e43c9e836e97e6919092b8812ccadd2aaeb88e3ff828cedfe1bf5315cfea576f5d892b2601711ba4a2cc99e3856df7f17209926daa1a1745a7838955372d1485922aa471287962d3d5a4cbc98bfe7813ab9ebc72103fc7f1b65e8840a71a9e4877d685c58d9be775a801e078b16e877930327d9355c4bfa8934291c690eadc61b65abd5ac9e25f9cbdb69b358caf18e654444072ec561d42f5af88e9cacfa51ce0536e71855ec50d245f3a32fcea85c63b11d35dcaacfb891952041cbb0a6dc14ed5e79b233b4d077eaf15b389ad8b5941ae4d9f421eff32a11ebe78c28906b3fa2e337fcc18f7293ed3d6d6292e59378352a4b245a8b1adee49662db42a9578f71d128e0c1c11d50ecaa0d8e7a0ed786475f0e22e157b13e858d3375b9a80bab0164477707dd8ca0edcc65a8905c1661c9e6ae1f5ebaddfbfc9ef13c52f9ee558f32c66f9925a8f90d9a4bc9965eb779b228358ddc10ae1d9fae84bd4d91af4fbb560948e2dde7d11d46d7e6aa895f6c06f81b00aeb013a1bcbe2b876410d5064c6cebf1ebcc6e35ff244047868ebc8cc6431f150831b8f813858add1aacb467ad4b084b600e116703c0363715a6cba66e677d3868e96ce6d35b5badff3de934274e29845789050488db4e1a4ffc3f19517df3617e5ca0acf864927f83511750547d8653eaff3e3d661b2a55605d88726c49e3e4f52f8e9b0738ff484e752257f99a5afda4175bce25e15848ff470c2f1db3e792e04717623aea74474f9eb32e4de1adc7e2c922ec12fa564df7420d4e078eacce484c8cabf8815f71030e605c3402aebae2e614f66ca28651e88cc11b391497f5329780eae73e10be4cb100fbf3c63e88c7b8199baa2ff3e3caf087323e6e900d9478a7a8d45c72dc85037da3384ad6d18082558cc418410361dc11a7966d4373a4263311819ff4597520a79cb3d2788d79c7c26e6be564d52ace7c791f9a93541a58a8132c3bedd5a26d73c4abed2431b47b57dd23aff78ba6ba5600dd3f2e37436d2654eafdb028ae3d8ad5e29c6cb23537c11c0cdb8e5bbb236e237cdf51b230e7240eed9b591207076f18cfda3628b26590ef6fc79ade011b7e7ce5171b53ebd4a082643c1e0100b267eedd5be2b526e004fed3cc176586c6fd8f5f84cce25d040d5628be8ca20c3e4cf49d4ca250c32edf61caf216b4444f69671e2f25ead9dd7ec1649d12b4fa2f314d0d776427c190a618554829556c3b26c8a11ef56169aa631fa266899a9ed9b0ca22efd13838ae04b090fb27a94934f8bb44cce1e2cad768758f17f4ac5b873bb6c985b42c3703195e0afdb53dfe3aece2ca5fbc045a99aa4bda3be5030032b4440082a37aaeb655133be81437272fd86a06f2d84bb936ecbf6a3822c11f7111cb54cd882f1c782e3f3d5a1024944d1840a07a9c50f2a001d72aaf5be128267f41ecd384a1bcf64a6abbbd0f8739a13d3d179db6bcdcf18f48b236610acab7792bd4101b2308f84312ad8ea7b65fd2e6bac2a444902dda92870fde64407bbf0deff61fe6cb3ad594d1215b894b57ad19778202cc9ee79d2ed8a1269837795b17aa54cea5c45104fc48e38687805b5a2b56b23b00a5a5305b9a61e73fe0d180717a1225726487afd490032823d9950c7fef96d2a56908f58b0b9e1d00426a48f8afd1abb22df1baed192d8cc8252e825e91eb1e312ccdf3d45842c0c8b3ee48d999d374ac63e6da23a530ad242ebf5a8fe1de4b31f64a12f1c1de36b7cde0407966bf726880bcc239f490e923942bf3ffb9b8d7f4fdae65fbfe0170c3cdaa81463da0167a5501a005eb35d99b0a348308db99ee48560c8bd058ee93bd079814badaf1104679bca9b510330b360001d45ef71a8970a0788805dc516fc87712d7c5e08bca5f0de8c615fff5f32484f665c053708a0a17e28efe9eef5cd76e6ab567e4f8decc26d3d4af4a73a395602c386010e7dedfd69ab6a277d2ccb884267f8caef37d653877de5796177f9a64fe18bd31b8f07e83c60cbe49bef861b67753e6223d7af26321e137b7e893f198b7f4925444b51238f3f38b379bfc4fbfe053a9f5bdeec51bd8bad840702ea5c654209188c033763a3457370acb7950e6aac6aa405449cdec74a94a765579307a287c164676d5a7aeab5178e65dda8139e7afe0bb1cbcc6e69f219f5ac36c36c13561c3d154cdb691178087e7aac447f350ddc9c7111dd369ae3d0c981c32c1a643484e7273624f18889094b7646e599313c45f1968f562fd4df79e359ea6594d64cab7f285af4c7940266f220f2af73da6b0287cef1b90da264ab520167ad5bd6b034b5ddc963477189d39b5c69cadb52933452a3ca4c1425a4d72b57fed620e7033bd72d9269640be4d8fbd33d1ecaf434350bc60a31f37b551a73e774084eabc87db2cf8711ebd0589838b5ffb233e48fcfa797c143757b649d2e1d87a2c7b215f977befa351789147d3d79777eb3f83194823a29f1c1ffa021cdc45057fad3de2c5869cc0f836e8d21594295360cb2a5bc68d688054fc0a9ebc75f80a2f6b73538beaa031d7b1a7dcd9ee205409d27c93629b8be25addfb3283638a9dd959224b98da8285feac5b4229604016b586163c16b57c4868ec0a2853fffce777cf39e2988942f634723a96be526c8f2cd43b4ff37d1329ee68590cc7a7e4264855a09ab194d94bceb7ec7a30b447a9d1093f52aac1e63de58e36c1a1f4ca6c9dd1f8533be8e331c2f44854a00b5463ce60d64c3ebeee701da62b24598ce6d72c9c8f7e2245fe23cc1f3aa317ceff7f163d9871e05c68fd36e57b9ee0a3afc752eb11d107b600637866e2e40605d8fa5afc117c1236cddfba88381c00ebd2bd106e004e54e163cec1493966e5d531adc3a1837d3d0b4283d03c8a72e51b36e5efec2f0897fb0c7d2a0e3771cddd7f1f4578e8274aecee942a6737fd0723a2f663248f5084a9b980fde76c7cf6f7ef356bff694eb007a03f9985bd61667a40ee1400dd2a8c19ab4e1e7331d717d161ff971b8c525c215e4374375e5e707eb75d4e3ce521e33d4fbc4582f3a98f260bbdfaa296e1b1c27dcb93b4d50e2ed468a71d501ad65c97ad70a6d9fbfc68fb8051a35321f377e3e2d650ecacbe81ddd0c1e3cf0e2bc90b2b8b42abbcbcdc9dedf21a44401753296e71f03570421f167b492cc68c660c92a8e397ae49b9b3120692286634f9e2b8699d0e1bc713c69084979b7eadff0a93314b24857425448690be260c4b2f3433b3e0138ab4662239054242d6634e21f73e0f99cddcfd08d13a1bd7676677af9a1bd78788077ec61748e042d76c42ecb7aea9364598282a14e4d5e0de57c47789cb7f52cb540477021083d0312dc374763ef330d577eeb385675a69429d8a047a8a54949d5e247e0e60b32c2424769f3d0000188bef9fe3ac14cf62651e3639a51e7603ca6cecba0c07199eeee6daba1871589fac87212d8e472dd546fbf562782388c4c851ef907f5019dba84aecda4c4321f42a0e63adc5887fbabcd449e9fb042a3b493a8d2baf446d082c42a0a9ab381f1c30254902853b0b9f86d6376bbd0c6e9596ff51e984a82ce99d09fe0fda2764bc56610ede63c2f7f4d5162e569577bf0fc8eca3f619bff16dc329d606b1041c526506176dc351d3360772100e4407aceb8c6cb1c7fea15ed6c976c8d6bad0071f1baa6ff101c86cd7bf77b4dd2fed86aaf74f20ce43f70fcab9a31d0b08393ff93f72b434f50b96a8613cd66b8aec733b0f77b603185ca92ff34b171bbacce6fe4e4c5242b5e8765a884523b36bc72ba7792d22fa587d40b8e94a5d502f1aa0406ce8403dbe34c5352f6c77a9b29f54c6f8c7d55e410064760b7661839bf31bfc183e6c61dc39991807b9833fd32d9c8fe3a8a82c6d6241470c9bb9e6a6d615533ad837c3ff7ac09b08a52054abef97a1d36a5b7c06471e4044c6d72f371233864cd77d473f35eb7fb2b1eb110bfa5299f1e1ad4f5f882a440cb9fc0b444d2fa5e42c1dfff225f7be0b34876e285b161efd02857c944dfb48ba3aa6e7e8c4f5db3c91367ecfaec8e760faa409b91305c2844bc919f10c5b8529ac9032c6b90e195bff16472f43d08a7341568f43fed9ce063141a0ce644c29ff5704a109ccd024816358ded906b0ea81b17a3425c8d44c796d63ed94feff76a9c456ff3126f1ab35029c1ee68da7ddd26fbdd4b9ca5ae7dbb42165edcf6508c8881ee75bfe27f5243520b9e5d65c1ccdccfe9935b53bbb615f6054b781999136cd36979813f628c3a819d2228f94da178980dd1ef4baf415eaeabe40af03cb6b3c472b00d338ed264b955221e672605310829ce776ff63b6b6727b7da157b39b75b98c7a9aabd632696e641452fe508c971823202127a9aa6b6dec3c883e3c170a2a0be1d73f8b8abe004818b76d987c8e085df47a456e5f4fb61633157ea76320ed9a9a0ab80b209e333a3e4e7cfd389afe4b7a66bfbf0746970bce2546ca83de4f24951295cb880fc70d22f12258516cae3a3182c7a20d955be1a87d3e6dfd1f0d24bc61f5105c68e746b8c854630eda9756091476703fd5e35a1ab7efb886fee1e637ebaba807daccc81879ccbf2ffea1bbc4d9812eff8914a98a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
