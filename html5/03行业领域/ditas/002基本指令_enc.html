<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d8884b79d5f234ea8ef878109507d05be04ab84b55073305ddbdef99dd3c946e26af1a69dd60b9dbcbecc5c9fc6be8ce63b4b41c94fadd72322aa759b71b6bf4d56b2edf083d2ce65b02066cb7189a29857ccd6460fec117de6a1b4d02a3fff481e9873a65775c10a9dd3b3cc76a6410b1a9c192204a81e027f4ff09e9c818a01219e3ab96f75591f745ee590c8534095998826b4463e626c41c727ebe098209f6b76cc8a31fc5e98bb434244f25f566e867ba58fbcd2412abe4adf319d46c80d1a70dd465498725c0ea147f30c9f06e1b8517db089cd280b33acb378caf6181e8c263fcad913c8cb33a9c13836d224a836b8bbda4eb543efda8efddb59476971ef936068d0b69f1b9daa6c03d1f94ef1bac49ae0fe70434b0486ca9b9d89ca7d2bba69aa33282769748e676ccff4c534391f72252da32ef14a98d076d2077e6113417905b40f9dea4fd5cf22974aa670c954feedb2522ee5012121107650b00ae470af267d7df0b1eaff2a724e36a7743af061d2e03fc49dd795f97d321d18997b0e0a7826cf345bcc4b339d84721d68ea221f3122fa285eb98e1a84c8aa25387365e31058e0894421a2bdfe2eec3d2256cac977c97639ce277064d55f7420b3f4c2a9938f4877f9d98dad36f4a0b06b5e4042882cd38af2f76784d4e25700a5386efc166f4efab6b5d07742f01e54fe881554e102ead409e75d1760618993250c9e03b4a79d03c55918fc5a51432ac2f88f4c71d1a4fc3bcd4f89ef4ada6281a352455b67fecf2df361cef98b27fa47887f98e78f52e284be18cad45a1b6844fd3d633d31cb7c408b1734ef57ff78299dc93bc7fb8e844c3c06b37c8e125bcee6d96c69fa8a7f413d33c5f087162b4326da8a8e8ab85bd104ffa7ace4537f8168cfa6707d635b7bbc324b4ba01c71722f7c4122ab73a066173b9619c7498c752c6b04659dd42502aaf0e95df45e745437cad1cff77a519d55bf791fad79e8913e6c8513141d72cd17eb36614807129adf7b76fbbd6c62477dbbf3a250d408391e40c8fbae703d4ecb0905dd096a8c2f64851ad656650b75ad264dcec30b237a351cbba355daf30e1b7f71f8e29b23ee19d9d4753c831cbdfb8ea17525beda876277801c51bf9aeb4fc999a8cda68dfb5872bed196af8ef0e1aeb96676cce854852bc3a1d04346a6459b38f8f3fda30addf2e47849d3911d793ddce4fff5c9161fb2dbbfc6b7af962f7241a31a765acb74f1f2b1379e0c8a24cd76f35ccc5176947a5acd412cc23b42c519837998830c16166e0e449bb81cab92368cd4cfb9b6c7e45071e40cd503ceb354567c1fb6d58bdcad2bf356a669ab51d65ccede7208eaf8753ffbdd09c97bb904193b30a2d2ead8ec98cd65d5c4c2a393f1031b5289e7038b6714035a1f3aa40019aa892e5ebbd09a345fb1f54b4223e21ed67d08a275766183096c439db7148e873c46a85ab5ec895b4ec279ee83f338134205d09878628c8942a38b3cfb59a002a82411c35299855ddaa5895b7bf2692914d1d698735c705f703c73835d0db9a97ad19c8a3e9fd1f34ae9eb79b6cc9b73e0184852fdbed6d75e1e941e0c9d24fbc994b1b1cf5748abab679a1fcedfc8a7b43bef60e8a66ba836abf0083c5fa4c16bcff839705998161e1bf1d08b9e5541bfa7b04b2b663b6d7c853a3050c10b13585a722ca85351c8e0b0c3eb63f7945336aa731f6cea3689c8a646a7610798cf93fbb799ba87cceca46e5dac727f561a095fa23b962f3c2919e8438cf73b6442ca378cd56366b8784997563bde435f65bd0228ec7adeca12fa999fe7ec6fa54f0bacff1a77ad21606288460c1ff5d0d172d3324a8f6ac4d09583b108bfb5378d01e25799e048512c3858718f978158af93d8a4968bdcebde14fe97ed956503fefd8d781d050ed62018b9d28d382dd81046c8cf23c6aef8eef43fb9e54a1da00ffd6d93993616c1aa6a41356117645292f66c923fd0cba5c261220a9822a48eb3ea29f19cb39becc0a29fb637ef76f1d0a331127b3993bf262fd6706f8b1fedf069ac4ab1c7abcf54811849c2717423d07b91e81ca201bfbf1f6ec3dd4f2fd9683a0f97a985241851d831243930e8cf06981d2556a6372fb4293bb5b8cc65d1d3518a9ff789d8a5fb7f0263f9bbdc3cebe48e16004bdc47b28f276e3d9b26f8cc5244f607dff42ad0142ee2a63c606d1e82394e74a1be2d9a4cf532a0446e10fdccef02b684b6b4041744f6e196a85592837330bc26635fa9c645badda405341a8bd527a6c9372ba5cdc8cbfe1bc047eaf5de0d9a51cab2d8ed7bd9f156db322b75ef7a070f3961e4c106e186a4f10d3560897c7784d983b43cd4c459e073075f1b4a010de804051df6367720010fe9c3f16df878b63baef3e2c6eb39ac2b8257318770ecf6a98945b57f01e3d30bf285d27bc139f076d53ba8e023dbb40bc1fe36a8ec764049004adb928f855603b1173b52cad5994376329aaaff22de0312e901a35e3a023c50af063505f76a61fed519f11089e8e164a6ee9a044e601a5a6812247b0c688f409aa481307379a26845b11b52cdf9fb1da0aae7d30bbe7c8e8227da1ee325d4e1095c01929055fa427b9e7322f7887ced20037e2a653204554cb089590768e3cddbee8fb8ca02a408a48518e1c2b0791cdb015f42cb73a01c9dd1ef7b2ad49e2bcd83adf1e65930a58faf8d6f730bdb937bf2ce7047ecaf55aec1f38115f1e0a0ad8415eb035bdb5e6d69def88aef72103d336af61a7fee6fe44c9c2d0e83db98440936b1059ab507b8bd63ace069173cd2a99b25e11e5f30ec019dafce6d35ca090c742f8460fe66a3f85a0925397aedd247ecb4d568707ea6548ff93aacf55a31b0dbd57eb645011b0a079ecda44ff63f83e2e1e004644ac9784f348840a93609bfb01cf22d872c0dd15f6ef37204eeb493747d2dc4dbe6cf3eee1de10c2d56cf9f84ce818074d2eb54b1582fb91c96675f3c1c1eac8a4c6eec9ee41b4f0451b29332551c875fc4bac765951995644efb49f5d2801bda7d47a1ca6219300b060a673099e75507ff9e9b808f30e1dae72cb0ea1cbd867f8aba6ca7681c6906311332cde88ec145d45bdc01b6a644ff9f2ab3b1ded0a90552e147735864e01fc09f0a254635e560b5ec1dd4e949c89a29fc8d3c7e15bbf40df4989e60773b484c3708f180c1aefa5583b3557f7352dae4052fba95a50c39be6b6186c68d06edac231fafa9231aa9bad705d0dcc1a5328389d4239c14db31f1baa72eb340e5c02c59dc1b6e9ffc3e297fcc96a4b6e104f3aaa164bc56efa503712f6b5006e71d50503997cedb98d4d60363fcd9c3500985be8db654138a0c7b87d2ed90652491191777ca2b3a58e43234aad3091f0dadc114a39a615bb6e6899a4e70216f8cfcc290d228c16923e0f86845ad1754b5de8286bef243d1916a2144d0224fb697213faa1deaa031744ed1bbf8bfd27cee8c1476b0ee6bf381ab2e416a9a147745dcd3c445c9c99cc4ca2f75874ea9df1be33503f3f7dbfe0a617ca6965a22cc1eadc3a29443f159576a2fb311bfb279fe472a9027c40ab182b2d92056c3869eeac8c8204bd5e31b9105e4a7d208a9e9a30639caf7953340125dea30ebacd75d1d612f3cc54b1c8c37f1d49b453f690ef0fb83c42916a8e89ac5400506dafaa3e6c53106860e4c97fdffb8d4f47ae4780d30750192244106a037f2bd4166f8e3934c2e73758482e49a81161ea796f3834cdf73430419d0dc61bab4824be1fc555ef0d19508df9e2428decbfc6fa704fe6be8d9ec5e7c0569fd145f36a6ef324f1ec5cc5d604c4f16f93898f801b948235e8a59a4d9f134508733b7561e16ba7b083badbb20768fb84532dc4dcaec9d93c2d3a1393c5db63ea881acfa320e81168f79c6d70a9ebcdac891f6a0fdbb19e277fdbe9e9ccacfbbac0bcd881df283e025058fcc42528fb8bcc0e547365d784bfaf051462cedfeb876e2065042f4c0ae88caf6ba0011a7e8d62be42afe69b490672c872367c6e1be0e9dfbff1b8b5cc38fbdec9a76f70f807a7971ae872d77b59d05195a866b025c503b96bc6405d3243c1932499ce46aa428de5a8e8a637d0d921cb117fd3af7b4f554d57f13c0cbbf896817064d02742529e4ccb29b36ff548c34e1d23ed19c392132bcd33ec8df5142446d306b2ced56b33387e6a0afbbc0e0212e44423ee4e81577a279ec38f0607844ece38f727299f44187f5473b938ddfc409dbf76f72608aac6ea2db556e04e11734d0e4c26a0f4554ea90fc50aebe5c7234c6d21494047fe81fc721a3686f35e549b8a25a654f61a8df0a160cc38b6a5ded8b4ec6679c4bd3a1039e56af78627fbb7d520fe2c3a726faae2a3f8f218eb8690a9ac740d688c3af6cb919ab6f8548aa433ae151c9c6ba2e11d6da6d6586fd4674f90e9b78c54436849ba2d72a1f4257cda113726d4152023e9e92d2059a94033726b778997f7318ae3eec086460aede25db8cc48ef0cf0724a10013b2ad5bebe8d5e64ae74a4da7399f9e998c8eafee1e2714961581560e8be4ffd50044f2895864309c60b8b4f9beb3ad338ffb8f268fdcf53cf94141944c2dca652748248bdc8e46ee267dad75669c002273f9e04e375ee6a7a2d38e66c64444fec6190b71037c59a746bf0694c8bda117007483dc181acdbe59495bece8d59d6becad30fe25386f03485619fbf2c3e6a002f2e3a86261a0799f32c242fda4fdf2354cef69868f3cdb53fc7772ef8c4d4028dc2c881c99b905d1b5b0d03c46e392db2d76840fb4ddee5b23eef20faf641f9af965c644172105aa08470a7121f9837c398d9121d4c96b56bfed6f284ebcdeebb4fb5d2e88bea3f3712453d08bc8ae8ec639ce55ef34f6170385f452d64e5ad633a54e1865f4896e074d808bad527913c247b9a195d25fcf6597e34d24ecb249626da00ccf9863700c3f2d12c3df616dc4d1a1baac0501f690ce34dad4240ceaa43e7324275596f6e3a5b0f4e63bd820697f21bd743df417c43f48d5890f7c0e0031ba1e0b5b9f8c8b94ef0c2e513fb2fe3e694ecdd910ec4162806790dcca8632d0c964e280140a7b16a9a5e39a9bf40db058c8bdcd0cd0a24d2cab5163c3dabd7f4bf6481b5ae43fee99e13234d6b5eda03083f95e3d8cceeb20930d400e7625b4e6db0e08ea4afcd40083b7f37da3a74cf6769b900ff029b9c2027728922099c72be6f538848960d7c6d6cc43f395ee201db45da952634c750546f5923b008d27b3af4185d47cd4077da138b485202bd855eac151a0113149d0828def81b8a6a16209f89c6fed71195b7771c82e26c8b9827b52898e83ce5e6919f0f50c4becbc20eeb9656c2f718870622ac3c0118735681acbf4a0d59cc5ca5427293d16a006206d712fe8a64f2628a12af55821c513d6dcccb255c74d56ee9e8ce8f1a5363f8cd38081ca051e1993bca397b5f1acd6618f7377a66b1ccc5b9ef6866923ef94a2464f79a693eb4be211c7780ed079b66510dc40d7c7c7715d1efc871c32832c63372b153035b387da1c2d1d8f5b1781b34fefa07bdd9c40bb36421eb3852df260fce07aa163ea7e36a0f74b7bce93bf1348b912333479dce3c6c4d42f3918aa04b5ae4f4c561d7f83f9abec38e90a4317482f338e50c78dc45cf562ea0c7f73a438f0c4f74f72874dd880e453a6adc8f8c6d361bf06f74e03c67b6ef90598454bb74e8ccb8755d37d6a22a94fd3fcb783f29bc1de3264820c1896a8c8eafe6a7daf76d9ceafc942499ff65815afabaaa41a517f28166f37f579b99a4eee8417a57026261e7689ec21e438b68a327c34b8c912d9b7ec574424515568298ad7760a852855e5043cd88c4131860ec9a81bff04fb2ce5f1c8a54c97985e600b01f4d72646fe1fee5e074df9008b27656c1e024317d970538b550d3dc663f52b6b30c0dcf012f8fb58a2fd727967ddc9676649d889559ff05f37e6372474ae90bbe5640ecb96de6af4f41a8b6de811c18805e9e25b089b4eb5a4a84fed4c7b875e69cf42597ae3dea85bfb2b89edc1cf5f0a53ad50e41df6405360aeba7c5b02c33d57502bf912109935c0f30bf1aa893f640b1ce01403f891a82bf0f0e39c1be2d271cd0528f7fad74d313a072ecd3e8a685a5beb73dbcb643b887b09e46fb863e06bc36525333c541072dda5b49609dc872c10a185699a1c0ee3d7dba6d8095895ea1fa488abd146125de904e1cac7b6c3e2e2e79697abee7da726352baade62f4dd5d8d17431da13e57398df45446fab301276a12007d9b813bb143c6fa5ba0d7bb76fdeaef407c9d97f6ac4cfc075109598dc9ceb57b57f9029472d4f55a45bf60b64c5e802109a2e29bc280b177f72a6637aa7d343b43653a3ce46dbad142910106714f69dbfd7440be57b50e73f82b3d6a04b19cce515b4886b6a70714903844786a94d5bd59445654e0a878752a5922a3bdcf66d73a0796cea5cce62eeaa1a7dd16b42dbc463f4181e2cb183d78c9a438c61b68b60da6691ad541b76b930d97326c5534124ccac727eef2283cf0bfb0062ab20a34a51cabc902a53e111a70209fa654c64533d4edc458fa367b414dfa615c838f8cd6b388f277710a3d2f6d58f331ef5682b0f6cbd7e6ab6999e206affadc050bba882af455952d2522d9aa30e377b2272f202ea4172b4084fd307b1d5e7d1e241285a206f8681f3be6f632fc1f8dbdb30854080e10a04df2ac4a64b1ffbfaf369dab094c2d84ed7b1f8194a943f9ee5aeeed602fd519aace276cdb94a233164cc62eec2a5ffc5b63530946e7e70b8b2b8952098a96fdf419c073e7c8306d14a04e8ac597aac6a8d4c803051fa87043011ecb04af3247a293210b7a98b2fd04b0fc7a29a6bfe909fffc74c3ec267804548a4e878fdf806f8da0c74da1518a4c750b91f953fe3eea9d7fa859379b49f6af8e501a1e43346f156bab135077342bca51eb51d10122ba0e296b69bee24254429b8d1eee01167ccf0d08a1b3100781a8ece8648d719789c919b431150fcefd49adb1473940b9fd0ed6ef7bf32c0eb8c54d9cd0280c16588127dcb3f1d3b819aea4b97ea08c2782c736c4353435e6282196c9274bc6248d0eda62ea7274cefa880ae7af334e8c0ed07c46be7b8a0cbce6b6690319aa579fe9bb1bc16f0e8277fec1084a9ec80bda1f48d7ef25032207287686fd723c05f975834ed9373bacc283dcf37bc8fa8599a491530761fa68f85dad5e3ab4edada4ed06ff2789eaa5949ad3c63dc50277aca5ee9aafe4b95ce540834d1693fd341f6fb46f52971546bca9fae6f1c3a1e0e14faba5e6373bac65d297880e193bdd7f8aa202731e002614c0c0239ea6e73dad44b3bcc57f77f3b8a2bef929fcee4e89b8d9c59c88483fd3bb7b988e035d10013c85b8f4f275c8a6873b306dea5a742f0b29687b29318d2cb8e45b93cf65f117727964f817ec84fe569043ccf65ef1057871cadf0f7d9543f9926247271d8b83e4b2cb39e32272da54be473057156fbf432465678ed91f4eef764b5c867c0ef38adb5b6bb92a078457334807d3c151ba4eeb5bec2a4cf4ec29c16320dc92f5b4c4d7848333945544cce498d60f5820ce25ec15a37de1f3107599270aeb02e172a070974fd092a15053126e0977bdfdf6ca490cb88f2077b1fd45d46d0f44c9864e195d7cce1fb01eca6883f1b237cdaad44f7c9cd7c80c175a1aca7abd5c23eeb723810c11b1932a98b08c99c3a34cc411dbf3042a5482f3e6c23c45d976eb0ed248f35ff0b0adc8243c9b37c1cca5044a9d814666cb3a887397676cd4054fde714d61736f3545f66526535014a1d5658bb82f1c8620227014026136cecaf3c3f53417b859ee21058817da434beb41d1eaef1babbc40d37f7eac9f4a57e4ee1081d124b6574a527ca0a49082e446d5273bd0579b1d9a288d2361b515091c0670f8dc82681f8432c2807fd2517460123f32c7d3d8790732f3bb1df455bb084f7ebf9b560b05380f636b882e3aeb18d967257e0bc78334a1102f6fa6f3e43742f02eb14150f4afe5ea37072d4b713dd5d41a511edd786d75c94f7bde341d947c297f5bc8637bd89f7e59f0af1bff5a3d45716a71cbb6a1616dcc29f74f5e5437929054ced5c486afd729aa4eb52e4cd073641f0f806ed20c1abbd1b5a9c967099e2eec4a0037afb142b85ab32fb9b4766795fe43582646c6a5fe4f6d3040342f01439f1f3902b0bc79bafe8037a3b7776d6d1d008f29c594c3ee26c99e33857c38905357976ab60e09392b0e0f30052b0861f282ad26e692a15d798719d2186887c1f67b10d878e58314f407004bc219144d9c46685e0151a195c0fefe7c75ae5e88ca3cba318b587b22018a7d60abbf397cbe2f8f90c6f08d6f19b8af93501d7293b2c4c5f44f618db17bbee89d98bc8ccf464f6ceb8e1b938b8154ddc6739cc404271c78fa19b114d94e0ccdbe8750c4ba1d06d5d4023ff3c0dd0b4c03169f86cee57e59fbbe00f83d4a9cdfe795fef8988393882e617eba0dd918ee2c7448ce2813d563fdb7fac1c6399b1ba928d5e503f7761da900dedf6826bc2902dba2248cc83b691be1c3e168fe0d56ae5c712d8de0c7955f746e8c9d272faa8139288c0a81cbf3ec11861cfee0d53bec60f82ff87afc56dff02f094dfdbb48356fbeae53ba80cc89f05c5ec0d7fd60a9235851f1dd5ed1d414a02fe63bfc54d7b6b0ba0ba2094312a7fb4c075f3392a6e3e29b62a84f81440ab19130a4fe5437d511b4e80caf300c973fbddd0a6095ac098dc333d406987a225bec87074536d3bc8240fbfacb1e7e7c3a305c3fd0a290b1cd23d75a6424a670a54fb4926d344b45dc216f027729418f96ba8734961f234a5607732b2f69a46182703c28417b8bf450a09dbe1f9e50c9818ba22b5510bc48be948e02a5f2fba17eea512b8aacb7e140fba02ff49ae94d6f5ae8cb57d7bfd96047b5103a62d4b1fed485c2eb523a5f51c032127757c19eea0d8c7f46244179c1a17a826865a848141182ab5b28b5fc967060cb7aefee3639984e17d1a2e7ccd6b3e99e32f655c582438d02ef2c7ad9af399059f8e2e179ca9bee57f4a633b7c2c98e9b52d0145729018fafe4caea020c7720d6a20d9ddb3ea25c0f1c5b6944a90c867120b0dffeb86751121925bd3cf40e2e4c571d81b0cc70a391506b3fda8e45f0742331da9c775698117392369a1bf81b516272c42da913b378d56ae080b590c4c2774a33ed982c48f1cc866f3e79b0bbc8e2631ac3c6cb5336666bbf8c4994efc13190720945e7bac15cd4fbf8b69379e585a26deba29290be051c5a6fbdafc6d9e362d80b0618931a199504b2aa580dbae8fb60e22ea330f8d7fe4cb1e565364bd3a8219c854dbce8ce16b4f31e9b508b81b28c9dcdeaac2ef311b21054806eb336937bd82bfd15dd251e6c84a3f1e9c0a2b7c1b2fd71bb2a086e4c422df1c401ff2598b44df2c95dcede0e1cf983faf141ab6e4661ba2061ea150791804419d4d7eb4512ad064c3fd0631fa67602528f7f50cd1feb9655a7dc42feff1db48aa1aa09d17989b07f7d811658eb434b5fcf152a3020069f31cb151ca21b888b062f4807614afb279ace61951d9c2f84a59c2504b04d46e6d6aac2e3261311c2f3a04b82b8262efbbdca24b8ae0407c12bc498374b670e41802fcacd617b7f72aef539fbf3f5b4c38d0da9b1ca2d1ba6385875c4b3f62c48dd3861d3959a26370255a6a0d86c2b049b94cb297e4bb41836ec7fa8ddda9db14b917ec07bde46ad5483f48cc70caaa34768edcd6654507e40ab1d3974c040ead0a0feccee0ec514832d9d12e6f60ee2f49fee8f01bee447089a5b046a0af0471dc5bde28138aa704786207148f64b023c30c6a4e82f5a158b77858d1ed97773bca52195d3e221810d3b1304716778ab2c37112c95ca073fe44f35b6a78e0d84c3d1e27a8910d5bd45801de98ea1873da635ef80e70558df37cba06a2376313e400d76b9683ef72ab2c00ab1299aadea3fdae50449429c7f7776b8c8a2522aa65abe5d373a742c97657cf9315ea0d121678057bdf3f53bf56f44ac41a7cf41f382f795adf5ce112c3004ff1e4f75cbffa64c0f4e4708374818cb29618bc0b5f2feb95a57c7a82df671b5a0d8c8f5cd393e7a46301c104cbd88bf22d22d5cb0f6068edd7fbcaae12dcf8d0721bdd15d91850e3b9dbefdc707c79050346732abccacfe500346540e10637de2ff3447b50179050064bd0e9872c37878639ef31888e71eb1995beee40fcab2f8488eb7a6ac7a53c8366bc152e3ce4026b0f3c9e27c76ae8751420229a92292317a73d385bf61a850b6b9dbb80636b32e2c6cccd6dfaec272d1bf93f3f526ea7f52c74742bfde1eff1456218c545d8f04ee9402182052d56849599011716177edc99b707a06f80e7c3de3fe8b53872c922855bb2b50c6a1586faa51c8c19e8795a842ba2468d04016440655ea83418f515d67dd381efb1c85bdb52f06feb3f774dcb133fc81eadde7ae52c8b24ec38036963a58307a80f7fcd1f6964a1d1760148490d8ccfdc016f7b35e5b2ed07cf793dff425a185b46fff06adaf18b04419c158196d33148d6248f02791dfe4f6f69b7219ecdbc8ee47a775c2a9c377e4aabae9ce62b8a7d60ebab2175b37b3e128f45aea8dbba9874162970f132a80ef9d09e878e94f061fb778986e44e9e8664a6a3310abde7272dabf0ad3a4d80218d613cf9b805bcf6c74f4dcde849e80ee4d6551eec8d3903d51c60bce4d273a364e8f49220fb7338bfd39a22c1e5128374f843b87c5c4aab06b98f8251635fbc1e7aaa2da1a28a1e66361ed0c981133276b77b59ff28a29e4b440e24ab50e763f63043948ced5dddfc7065446bed161640d9df3c70dc5ecd0f1d5e19c3f9b40cdf0922d042bdf3163fd19528b41f315087c93e3644c79c315feda94f99d56e7bc2ca2b12544b11f41c03b1acab386fd01e1c282c02772b7327c42097587edcace02467e851b68bc9177575fc65ace3cee5503d88cd84da846a9479276cb2bb57bc93ad848740e0008c6cb4e9e013338c0f24c5f22b5c297fe9d5d413226fdcd75ab6cba2be927c7f3b450372f9852ec7e2cd16a9dba5c2496c01a703536b2a11ed89551ea59e8a8546c0cd9eb778f974e5936218504d6801cdcea3b505231d5535ed69ed7094e3c9d631adf08168343573fe03d8a573e1d325bbe12dfd6588c58cf84247d5614c35197fabbfe30b2ec2ff48c485a529b99826042bcacee8786ad6b74a157af1c6a5fd50be6f0759c39638a0758cd8348251ea40d0e580f1a5c9467ee5ae75d7c5c0ee1b4515de4a219216165b6f1f6c7a4da2c91f9d1041acfac87e0828e7dcf6ef95ca8f54eaeee83798183ef14e18fdf1b3095abbacbd0d8039e1adde26aa0bb7d2bbcc4d5f77aac33a11ff2012839d064530dbe2acebf9558c1d981cedae369586392e7d069a06135900080996ede97ef2bb7f73df2f6fa8f6d7b89a3c93bbe433e4cfd0753ea13e3fca8a89081cda3fccac79a6a76d879d17ea6709a13d310b76e9961d53b27668b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
