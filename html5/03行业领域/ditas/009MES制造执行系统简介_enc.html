<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc900adecdbc11bb8ff357983856237b0f2177b72acb89da12fa2765e891471f721a32149070d548779c5a5bfa1b3d9a0f633cce10ed6ebae42ba813ffd644744365076d96363240bf458e6ea398e26e3ab798bb9e093acb45fa36e5b962e6b2810a261d05f3bf022cd473bb3043c77a71ce1cb3aa520dd254e690012146ddff866acb0797561fa8c7b15f1c9d3e2a6a1bda34c9cc5bc1b4eae4a1a083ef83db09a2f267d6a3fdb8a2f7b645c7a7f52fec4f0f936c751e5f3fd667199471aa5c31bdd159a35de10847c1a2106991a1e063329b2e83bef991fe619fed89b6c48c191d6851c95806c04f053c516e6d891dcf8fe94222133771cf06fa6d160ad653da52c6b8fc44695a62e1e3b152706c5d141e2cf71d0c035a3331baa0640acdba83b0cac2053723d9e74504397de87142ac148615f5c2186d00c1eda560883b96bff7da13f32470acd6468bc3cfbbb4797ba5bd1e81a83bfd2adaa8e5678b2aae16748fc56a19370244b2fa33c20f398dc3ce7cb383582f8c4872cc706691d176c03dde4fc56a08f8a07748d15d29ad0ddb33e1c83c9098db99a6c689a0e5ac44df56b99c76a984b5e4b007d96ac7d4be3aaf5ec221e90877fa2e2de0ce7e0fa89525adcc70eeebad9118a890ed7716475bdc6e061641225a7f19c80c20c658e20738a57c4336ada569053d018939b9976e990b13920ebb4170e0ee6546a677af9c788daa6c800b8fe6e68b9eefe8b2a0ec05fa3f00022ae2727d4f03151a7f9f8c02aeeaddd780beeb175c43dcfa19b68a62768aac9305f675ced654f0cb49dfefd7598190b974f8cd855466f6ae8630cf82e2fdb81ce2425f9ca5dc9aa1b19d42f1d7670b37699efec14aa40315f0842379638502dc6438f370e7220dd1faa1c7e17fcd6c6eba56c2f96e925eb54a246fe4d51eaa4021e193e364222fde3679b6859130a156b4a5bc364917d81699ba5627ec0a008afbedf36f7b54f16c7f75ee25ccbf1169fea79e5db9d94761030c4f81dd478542e4be49adb7d0c548e27e3e6ded44bda21b03dc6617f7da36d2bacc00efedabdb0ebf34c25fde4b5dc74456bf46140bb1d83510816af77d610c064bfe31311102410b6d8de1509a0a3126a527bea19c85b05d6ab2c40f4133616c655679d52be287b341c4b25bd3fe9033b2d5484bf9b3a23ee34448a626f03a537d44f0ffc16c98a42fe3fdadc714609629cb6ede7149f25cf1ac724d1aa00d800b1ccfde72f54d0b487d9acdef1896b2b15017579f2c26ea04ba7afc01de1b73b46a6679f490daeb357bc90bb25e6e5e4d217bed89dcd069c2f4bceeb08328a40c1a234bcc1d6bcfdd81a7a61b83b2c9f7cf0f976a5dc436809d128acd7f8515ce75ec577107b5c9ae6600ef9cd1562fea8728ee88ddf5901b16c6cdce2424cd38a2896463485363d9a713855b1ba32f1ddf8a5dfe5f7855ccccc77465f851f0424db4db691b1190397dc7852707554a9be45859cba833b906697168add775fcfc0b617a8419e809f699f5566f41eb0591f7dd9bf70284becca9e963afbf9dddc737a21fbe5c807d066d22c3c888703cc31b5597477ba6d755a96234ce5181202e7913e9af803a3a9e94430a60c5b69604a55b121954db23243eff447ffc8e683a937ae4c2d65c125c7c7e35e0beb451a65536c595ff105a2513c5fb29c31a5b260fdff7c8d171ed276a684adbe1c760ec517539d49b972a11d14a824bb6e68c73738c3e32af4fc612b037f4ad4311de25f08450ab4c46f92412e521f0a23b46e0945b586ffb64a53271214f14eb5631bbbd68968d29413a4c6255f877503d590bce5dfba039ebe756691c8e2a2c8ec59f36be2f22b83e907377f558d5b5a7181a86712e033b68f07c572e0536d9fbbc16ec8d0375a099617c20c267dc7e0777f1e3abbe9ab875566a0157824c9eb54ee2d9d9455c55e23d3f1da752025e6239e35d3680ec87d87a9189f42199bd9a09a56aaf7cb7847025ac1b4ea16aa1b5d4f347b0ad8b1c654babfb423986034da1ab19fde8e94ff6f7b565e886997d1d1ff8bd95ce3cae2b4ef14c9d9c590bafb75a4101c85fb7d8d0d62f269953e70e1c49cc9fe848067bc891ce470e4d08bd6c789dab8d4069842a4fc90341c285b126ada1994abf41f98d172a47f49c770cfaf4b49da12960129d2d9b14d9fed5f0c9b3f10e60d366c4258a44d800c5b866bf98e63a26b4195d0b4caef0dd8c5045a1a3487c1bbaf584e779bcc72b8d67ef370b9a3e05e3561f27ca8b375061a2d94a0fcb8d8f5047723c5012fbe42678df5bbd07d986c594818686bcdef6a528d2467d4f83f08cc2a2b8f2e55f8f92e75ab7e7583f70a7d0ecee830d541cfba8e4c8e8b54d00672d55d30fe3df6d594571b1480f7102ba5e088d15f555ce567b4863246320159271823ac153dccdef9860e51d228f4f1941e9b773cc2aacef5d086c9b36e7071049ae249b3376b1307ad7681ef99568be8138261ec0a658f019f203bebf97d39672925e7b0a8bb20307225c76b48fc8117650762f94a96269f4d8921ffd439e7c7c9ee06aa69df69c2aff0d95a78ef1b76ef301cba8bcd8d87a48b86b70544b7d3a0d7ffe717156d4f02bea8308be381bc6fc206538e4584e6a9df25e0cf024c416c5c5d1e39ee7e8a3230fe28665e2b34a577ca05f4039c8ef8c922135f3d64c7896e7720e0af48ac6c0aadd7e4e7f6fac6b888127d6f01936852b1bffbe15ec123ec27120a73350474000a75f84cf52d7e4556ba8c6efb0d7a364d849ce8ac5d71fae53aec976683d31a58fb0e73c8905bf323cb4c6a6e7843994f198b6eb06f11ebafd811b140958bc084a0a57a83ac848e8aa84b09d47c0a4987694e8b8d7f8b52ac91a82138b3efa71c633461ef849e101a1b2e481b8690370943745da2d53eb6bbb1871d3269e8376a4d7f8f7d88859077de785edb5af36052921c8e93cf6f1d4248b0ce2b9c6bd581053fae9f44d6d8a8402677f3d388c0820f0c9c91d9dc9cbea4bd196c745b9bbb2782b4dee6335912d649916e4578674f11f960a06e955f4aead12bf100ad1a0c117a5ef3c1b08f883226ea0dd43ef95d214f22754a00451c81aeb70e29a5efdc7373db230fab5c2aa4ab10ee315b2f4e8365bf10ed848a89e35a0b48d7e7c7c9e208ad2d886bf0c9b974a1b36ec524d46d1e040e5bd9b4ff03d63c4249e5773bd67948d375335d3d9250887bb84bace89a9168463561681e658a18e87b5f0ca89f825f0a6d517cf99f30ee2ea9105ee8cef05797eb21b1042fb1ca23de57b8b9e87c3d124d2b4a5128c4ead577510ce6191c446f810fd6a1d369ab29d7d9bd23f53454c2cd7c0d09c9369a138c955175c0775d27254795a59c4c3ded6a6397ea9a3e7d08a9a9a00d7fbc4d65b021d4033fbf821cd7e912a9f02e801d8d37116da91fe651d8e48f78f56c1dd314609776ec691cc1ad5370d808df4a86449023cb902bdb7c85ed94a106dca5a8a7e65d992a238a68f4bb255a52dfe3205de9f017b0af792233d73aa325f4197c69c13444acf60af10c784dcac6afd4b602f25a2fc4efba529713263c79382ee00245769825bfda60b9040fefb420c29d1f1447181ab8fe3098d2504ec7b6bf7e7f133cb94cdd899933b6a843c56dac9314f839bd2d473a98702b5df0338e84be8194cb4263aa40ded15f5cb3b26c97d70d1047f4a6792c4b1f74cc7c4a7951a0c2eb4707bf8996edaf00c22438567d4b8b24fb4cfe9715988eb1c4d1ba633c4c4dcc3aff7358cae2eae2d11e6daf4b16ff4baa131b1ba7dacfce7b6186e3bc8a2ee27ca4b07fccdea27e346810e505fe4c742f4783d161ce2b3cdcd6a0ad20976e66d24f0c0ab2b63d1dbe588b0eb5bac4dc3c3b20433e4e99e0dd90c1ec6c29a48ae08b7e5a4f1bdec4ed47e772a9f50a6be367fa6c9da500011cb166f398f2187eccf282813b2e7ce10ac0bf16205a96df42bb5d3774590db9ed940f95ea6fb42c55f4c751b7f63e90511fb9c1346914c81867ea34965cf4a2a6f3eb6314356d6eaa1ce4894d1b5ab58d44bc874e5952fcb0694df34f3d15dd87490505a1aa77e1d37494426833a1808deec21914a28c0cfca2d52fdc64f28779e45489103a07dfed38950494589853338db2a6ea330cde6e441817ad3359ebfe71acb8e99d01875d64c73f4c42204d6b77d53372758da7632bf5eef8ca9b59686edcc79facdc52860d0a0e8275f8c6e238f9400fec114efab5bd5f7e1a0d53f68d32a0547c938b9d733d21cbe0b7da3dc95a9d97ffd06cfad67f060b8ad523acacd3c3a8877b684e96a7cd3da066bc6bc28ca1ad71c16b284a750d3feed2804bf846218295d9418e6b74daf222f1dd3e8a060dd06a9e10cf20a617a451d334c9ba4c035f43898f934ca6994758a448926b41484cf4183dae2bb47dedf2fdccf21a81ee0350ac3362f46dbc3e64d2c0f98cc77bcc9b8dfab2573482ce1a83dbd7c4fc53696a7f9f1f9f269bcc4085d3a753c06e8458ea1fd34352edae769d9d6d33622efff9f9a079fedcd63f175e22588a899359927f8120b032f8cff00df8babce7eb909dea5c4928b076c158bfda9bf235a1b1b528f19b95e9c58a1fcf79bd65ed4d638d31a924745d9e7ffd96f54f744b05d960272ecf551a066bcf31f0685a1be2e969b44d81a49233b2a9a91111bf248c128a68c0d85e4a21b35a5e6c27f14c924c164d6957465418e46f15feff3d379ae6e4e1b80e2465b202f8fd24884d3cc034b8d7eaadf4627c879fc47c1a8d52754ea00acb02fe71725b71afdffefb09c6cf2c5fd22c6714c33f4d70f547ff100f808a76f5a8bf20609c9c65bfeacc71975dcea986d838f0b9dd820053c08f40cb84ba555fba9c8befbf770d4dcae2d8cad2c4df5bdedc7f0582dda18f5217d7beada67871933f366b164d9b39eff926b306d2b1bd98299bca71fab0a7bd6087366776a96c0458dcc661d870f62b755145f7ae92a760dc731c62404b3c518de114f5c5d7acab90166e69aa8489b202daef7af36358d86ac1d8ae9bcbc1565a745add36cfe9b233becfbfae786334fe67016fa7c1f8e416ca47813d9d60499a476438101f41af93b936292ad10776ef370727e4cf6276e148cbbdb256719ac30715c094dbc1b31abb466702cf3371cc4a8ade52c59d62ef2424904c2687ad26af323de7a70c69472df01b91fcda3f2951394c057a4ad24c9707067c15ab0faa57f2c30258b4938a60461eb5b163b290b15fe9f06bdf7b337b2e637dadece4988302083b1d0412c26cbe2062404532c29539a4cf840722abf1898c37472a0f5e2382a434d4bb38022431fdeafdd4d1c2152f31a611b567f3fd7fcb35181c0e1915793c5753423e23a49dc1e7adc25e103f0691021d7c613a3e0fb619673cb2e585556292fb1d0d29832c06767080c7ac22c6fb2d79a04f5a5513428d2662daab63b49bf57ab65ca0412a1a0a24745ec28eed157166f8cad9b460825618ab5786130bee885eb4114acad56147d1b14856d36864edd30384c405984e04424c8c848fb1a25476770c477f5e149bf01d28a7670bdf93125086207769a2d770cf6ef44313280a5bb4e85a6c3278f762bff7a180731fa6c3445923545b5e81ef1235a0287a69440cb37bd7f2e85b4dc906983650d6783056b9c02d1a38bc11a922a082bda691f918c364cba089c415fe48b544d52177ae570a4a459e46b9e3dc8bcf1e255c8885323b228c3b40630c8e51a703d540cc5f2b4be51f9a22bc7068ba6d68e8a5595a776d720f19a16bb71ec4b6410195a8cb47348dc28edb55eb1c56a4f8dbe35e40d38486f80055db822c1aafc6396cb699ad9f58afbec905c77dada75e417d28c442f7d68238fc9fa27479fe67ca781063c0f99757e060c7440550d6766174ca0f4b5ed67e21d79e1d680f56ba4115e6da34f9e8300f7d40c1faa7a51cb0503df5317fc36374e4c8b0ae29b927b1fa4947ab515ecbcdf4a662a49b045483158c45f1b32120f91ff02f1db46c8eb0f45d77d7459d6cb0f8a658d7f824c4eea0cedd3eb869420336850afaed75b69d48e70104d76e0c5bac65aa32f41e84ebfacc438580d93bf7b7ca4e45f7efc5222f08aa43b9866b7a26c355a73d68f8d90b3c00c3e83826a2a4008af8a51f6f768ea98758bcc6be239dc9cfd9afa7a2128ef4bdc8a8272f8ea3fbf9bc44e7e52252ed17d8e31ac3e02f4eafb2173ec1efcfc097c7025b04a5d5a8b8ba05d8e8233c1f9f5625e0ecb1fc9685a1f824e6c23accc9f3ff71536d9153d17a260d2a93db4973981ae713b3a6b811610199ad9b3b620404739365985df9719d63787f6801cd918850d23bec6aba349624a009db8b0fd3508f2c5e126646f63fb772f937d3c57bbc7b00530c15d02bd59d8aa65aa07f8468c08e858a2035957ba2cc017a9d02cc02015edfe01c6fdd721e2583999d772f0278445a913b512b8f5d47bfe41c80063b69708d11f928476f8132d00bffd65dab15acb4a64d5709bd80e4ce6fb205633782c4941c23735603c4ae6328e1b2fa70e7ee1c4e236ee8f685d51ec86f0819b3aa5b9ae459931a993a8fe12a591077a8650a47f67e66ea935b3896007331df295d644f136aad6c6790d1dc3112e5d25f21a965e7cf38dbca4d0c4f97754ce244bc08bde71c06e5a5ce047aeaf782764b71f890a35ddac1663730f34ba987e426ddaf3193cd6019c3dedb494c05dbdd2a06c0acade47478ea0fd598817ad6bd54ffa48eb893db79f49e7370ada865c456095fb48eabfaada19f7f18c675c83a72d70528660646f6bff6b57d22bf9aadabc170ea6b951a59d97e9be475ef6512136e9b0e579602dc46a793f5bcf1d9e4c4f7438d47ed445f6bb5310ce12b74b82a8893629822d2ae80c254d95e31d00b7017e1b0cf860238f8a5bdb53aebd011a56fb14ede3267568169142bbd7366e9bad43135aa43402ea77e1c3180ca1ab23529430bb8fba64f6f3222bdf68b10f1ea20833653a420adda99b11ef51c50d9881ef519dd03879c805906c12a93cab356b13732feec9ce69299ec3938901e11dc8328e5ff885b7c6fb9b5e9c50b5d8ad1b1283eea42e7058e37410d28e5f9fd2e27ef567b24a3e1f399f061607998e2c6a9cd343af6a4366a9c6416f5bea8a1b05fbe31c922235b7350fa077f8d020d9df58dd890b330a535239636a860dfc6664e8a5d439d90ecefc8d8f9285d7c708f62cf37b8b4e94d37571a3c0dc18beb5f9049206cf9e2e9602dfaf648eb79d7ad88b69c45aaf7a3237b170347bdb318d614bb111e25067afa4d214dae03803ed7d769160a580d75a605166220ce41c57dc8ffbc466124906e68d8baa304f4933620e34c93abaed37bd93b2c27d259973892d34f9544185a33c03bd65a0c1468023d19ce4fff418da3511d473820be62cf4a6399f70f79f514f99532493c46553d1e1a9739b25d89341b368caea2b7a7c590a88b6475999685d0bd3584940c3d05f7316c04c4f37c2255be33dacefcc74c216008f88199c6b1c2fc865abbb4aa8f06e3dcf595d6b9a0f1ecce12c298030cc1858ad64759ba78e573a78f823324f5a3279ffddb158f5394725e6fb067e7d21f22050b2acca19c3e83ac169fc6ddc8cd32d1a1d4bace8003977dede737b4bddbbd94610c37c99b8f423d89c366e348542a6b6c6ce05785e28685f94e1c60c42f5761ca9408cf0f0e894d22974f26ac338513effe7ed055f02ec8730c4f34cde1c4788c4e90d95cf0e5d79b2ae78b210513798952013f97a208af55617097b37e7c78463a8befa8a89cb7a9a417506d2db12162952b4bdd7fd7f4e108cebdfeba0dc15a1f5de931beb23fe0e3687fb611082b738752ad44b7a2c3370be722593ba249b8cae1bc085a1be3dea1fb6d4e2458b76127b794520c25a14a6fea5f23d14f37849b9ba9145392219d35fbd6fae710709761331e6b7e759919bccd7765c12e648b9db4a7384ba20d41f6773b3e2d4bdbc2f24881062149873dacb33bcd510da87eb60a2d3feae5106190b7097a3ab211407bfad38ec9dc4f02a58d36b9281fc6607a78628cc587a9befaafdf78e14438dcd0c52dbf7c000da4aba77fda4efcb9a75bda0cd58b4fa40b7b929381569a7e437d7863d6bc7d9d2c9ab315a9db2193161d6bfd906b4ddbf8141d738874839d681aba4e4a0390e3450e4005b91b814b5b697bc6889460812f3e997af8e5cbac1c44ae1994549e5abaf6c60516dd06f0a64935f4ff843be113145f7ec5f247b1665bbac66f90122dfac402c1e5239fe842b4d25bfe071c115fdc7785d388051f07787a535e5c322e2dc4574299b9c20e4cbd74213a581723e688d2054a62023930d282dc43bd7653104e5cc041efb50c378307191f7e41222c129851f23eefd53684fbd5c5c804bfff26fafcf908ea4b22c57af0620c8070dfa6398d53f555f27e88da8fc8017c92916066cb01dafd0f5ac929ec8d2bfe8ecdb917cd2b6c709110d1eaf117d842597e2b6ef026866d26be6a20f0767286ea410b2e8d06c439df1c2df9eb20fe81981e6a2d9cde8e36621af07cfe6b57f9002bc16293accd3d526917cd57caf367956d175b06fd9db8b90c0cd8925d5539983e6bb549e7ccd62bd2349c7805a776bea6e47875725b6f49836f164e4306cac797bebcd20e7f52af90428031d657153198933f4c4dfd7d01771665b6756db4e8db005e065dddbca988b09ad5394aa50df3ebd2c672992453614b5d0433adc45c8e1de6c5640babc9c0447858e2eef768da05d989b6587b524a5785c89829f76f9a0adc0dc26736eda3a49d6a8950ca97f02e6b5813c7966d2c9d6dd890558962bf37645c5986e8d0d9af9d82a7b4f2dc481a5b054e26b77737ef940c2b82ed316276f8542e59772414088568151c442857219f911e1f9c44d0812efa2652e3c25c4a38ee43cabd8b5209b65d5a6d74632197d32db79fd86431a1f039906a984b2b35665526ec8abbe5b39454652de0040e4f4b1d285b8ac7754589a1592c01c5d28dba47811531fd258a76d3a64b8723032cb018c96fedbac207ea44e7a4ab7edd41294e639a6587ad9cdda53ee96594bf8020e09c3d0b6158aadb88a038620d066febf6c2405e6ecb0626ec1d6081347cfd1c302641745eae4849eb2888db97046d2543225843078aa3d73938aac97e5d269097c71dba0a5396ce25d78417a6e129319e659ddd217dda18da7e0cb8326dbfe73fc156c56a473bcb51be58f1522a1b10b37d0e3d2d3d4b9e0cf1933f6e4c821022ada9251da83d965f75d40d5b1fb3862db1531f48ed951e07a93be4714e6c63bc91d443951a8a23ed5803fe019aa2f1090f638c13d44c0b5d7c12d8fa77ae4fabb814ea264879699d79989ec56ae599f84bf3bf75baec5bae6f7af1d670456f6675f63420c59ab2c2e318846a8a9998d5022c6750956517279f5bec4919c56ba366dbf3456c08ed86f687e339b1b29ff45f4cdcee4a8cc9be23061a659a477b080b49f4877b8fc44bcb44bc3d5326d14efb24bfb1a9fca744b445922734d6ceb2ede9fd79571fdafdc40b1bb48ccde4dd0a2f91cd7b79dae2604b7162a3805851f3bc2aa478598a3beeffa9d24e59fce64fd57a9a3e254e1659ac4f8f3c2467b44410287eec520caab2629542bbb380f642d87186b49ce93e3115db0c7eb0fd0760540dc5bb5ae2fbc30191dc37d8c72aa8d7ad577604ba00f969fdfcbbbb7687b76e5fb532b4d3475192d2f151a385015f2d777fa39386bff1782c42fd558305322d99cdd1647eb9d9d2f2f1aa41b13a19bbf366e46f006a215babfa32db2132290ef5b42cecedb1fd33a0531d58e7f6f07c60739156292ae6853ed9f5caf1240d81a0c07ab155ee0f88a88114dd8b0cdf6622308426cbcf62c3795b94f8342260d2d59ca168f2050b6c2d3994c3985876ef6cacf0c156f90cad542b93e366a296f82907d1c7492a6130f2f120efb572017aac893fb09cd705377e55161486c55fbcc90b695452145293343c3a042fe56b3f88c17d4e3d611e8d03d9fec406201dd6bc26ae930b8e73ed4430fade345c5259f9caff16c17d22777de60f477b5615fc0d574d62784e12df3ea1961352b5360c070670d92be43ad1590f60626175f533120666bf501d359fe74b6760a519a63da303d63933baa269a7b13eac3a0010b141650691dcfbd429e9631ca0af5185b92ed77ed8bce23ffd159846ef4612bc614fc46f1ee9b1b1239ad6624371b37aab09e0ba4d679d272e7c371bd65beefabe94fcfef31e4e4c29dbad3decaf6c6835d47dc56cb1fb11042fa02ae784d129c31c7e8a9f0c326dc8a8fa373e5dd3e4693ea2cbc661bc5ff8748d72edf35a0bb37e4bbec6a8b255137a68d3dcb1ec5aa2f22149693f94684fcc9f5e8a6670b45cdc19b80ac2329d3c22a56408e72a03cc9682789334f39d508c4bb10a9bbd87f4fa7ce641d624bba422a06e5d347850612d9b8a107b32c80e73142f3b416b417ab8e7ba03cee2a0ca3fe896cf0248e7819957cd13ca1efa0ba8a9fc112d7e48d7b59a0a1775ffd9789edaa285f55ee350fbb8056da4c359eb13318805f138dfff69a62fbe91267f3098e66391dc7b5355cbf74a9ac560ce01fdf0bdf9234d017664023b761b07ee7d03309526653c32b280092462bdf1e19f0bc69aaa06558a67ac34cbd834f9d367ad241d8182a63987b957d2530a3425ef88c8f4c7bc5e15dea9b21fdcda39058a5486bcd39923cfa9f2d143b19465cd2f1983a38d84b64a342a4c6f0afa92218ddb476bd09245b6e56d4bc139261158f26ea450d6c2a624ad282b4f0c9840b6e4a42b5259b460c13704c57dec691a872f73f0c69af5c715c466b26b11a651cc28f74855d18007c808b153be50d2fc5d69f0fd9d61b4127605b5d55065cbe3a354363b6d61c5f88277fd00f6e3ca49845daf007375576bae796117b4e5a76b40b7ddf8d276eb546e0a0eef331f647d5713f8f45fb06fa11cdb0fa8bcf1bfbafb431e09fcde9f6cb6d097b35d1948fea1ad8c0ff893b7b9a1d10bc46b5ffdb5bd3e13691cb7dd74bfb7aef48177082009db7be53a18cceab30a0e68f91fcbae4c72a41c6523985b3c554bbc78364480077ea98de219ccec8c0eef0c198d6827924f2afe7969a5e574c4bbf0fde51435a4abac1b55a232113e5c921f0ed1da97e9d4ea3b110a77f7a0944e21fcd8fd4d58f45826cc37af4ea4fd1f28516f24ee2536e932fbccfb49def6064e88fbb61629eae79691d054c550dad25b72acb958054c427ac6dc12446770e9f1185241f93f1051ffa7ecf234baf316795caea5dfec2df1f333b18853d08b0ffda695a256a982fd2e3d4c23a677fb669bf12e5685fd63369955e011a6063f5463c1934d5ba2640d81bc590210b38d934987effeabb34b0113a6133267e5cb7d6aca577817732bdeab40cb5914f245d4af20063804898e087f482531e9c8d882576003f46f957552d389c29d870ed97d7793be375b5e4612c481134841b500964b64e58b2b68a8591aa88808206624cab72739fdfc7584428b6c400fba3cc002df62dcdef9073acb54deefef28abc234b9c2b3afdd4c6f75d6266054bf391b3b7ceeca105e07c1a141e86bc03290e198cff80964dfb44604ae2c2ae76be1bc52403165a132d45edf2287a36c6a00a91e8f45e686e291fccce88b44a816b71627973eae323c5af87b6dea37316e6d5bf6e65b819696eb6d226dd52e9987d60a81b06b42c6012372693b41c315905128fb063626adc5883ea8106b97c1432ec032325f6cae83b106369fda0a9d8ef3215074f3f2b63223ff8bba265c7e4d3c7973585069c3d53bdfbf549e7c48a7232500eca12def376119fad2a4da663df5f973e254b3a9653f26c038e6822a4f2e32d4f142077f7d041fbdbc87192e714d6b46d7f572d3c5dc78a17af2b9e77f018b565307a9102b87a1dbf5a6619c0e88b704c7335358b3c12e3b2fd9a433db9e496928069ec6994804d26878e05bd67636e9426a06e43ef84e95dbb75e8091ed1c539b452887d7ab39fad5896da00784e0040644e8db73a1eae47e759878b45682a14fd29589f34c103ff37c1da8e207dbf5cff52ea798243e18c5d99f66ff2ac6ef50a5973cbe9b62835e5fb650c352719b2371b82aa9628997c7e5d0f286dd4807e0b3a97908a4d8d272b434ae01a9142e5e2cffe702610c7d03b6b8ab8397e56c66d77115857dc002f0dccc77c316c8f956a8b3271197c805c639209cca0c862bda236f4663a7832e1b6433b889a2d65c64800d3e495fadfecc4c706c375b78c2448989f84cc768e998aacf00c4694e5f0e7d027c4497bb0f347eea62806163a8b441185dde5e380b1cd462295a43d779ea0b8e6ee3b7a9fcde96c8920bd8f9eb0ea5c4cb00b72b7ee7c9f58f181fbd3d93ebafbe0bbc152f139d01b6cd236dda70f5a6dbaf9dcb81140bb62c58c189a5a1c606f2f4cdecf378b927557f87ab896ce67d7930e34d9478faf81497440ac8e4cebba397d9a15f9e7507ab9cd72ec95bbbcb9bc047c1ad06d9ad89b7b41d1808578ec5d86c428790d24fbe25501db136fec709186b64f930cd39241c48cf1eb4ac5133199ffd44d13c42cdc2bfbc03e970aa5d7148542699254e9aa49b59d7fa7ef8d8da444ed25f96a29638540c1fec6d172d5f1ddfb799c4b92d2812c3929f772b4e7f69fabdba8e5b320d113a8a5e49fe6ba4ee4f83216b1a82637e813f4fe0fe09f07115fab513f1c2e9846a2febdfac0f1ee06ffa1928c7b2a76a56e4e87b5261e3e6bb847e72bf9f18d67aec20c5f30ecc46acb4a265cdb00d2b1159a06230597208c106adda248007663a60e377f9571a36b911607d9e350fb93c42a12f54696fbc858ce6674d7da54989e1d66cec45f3b318dc33594ea52324ab8fffaef0eb6a71956a1fde9a52f6eb2f736be3237d61ca9b8d8eac31abba066271f70c4ea0541fe348ecb077345b9c182a022d48ce009fc2f1ce47bafc2a2130a50029071b06de3c60fb82cd27e13b2a606f53143606f5d7cb2a79f03d43ddc04e3982023699d21359cfbc63000ca339a1418df0b5ffcf8552659aa4c6a20dcad87ca595551775c8ce0de7aa92a17fe8d58ec1e0ef13b6d75c1035f06c89a0f8bcf122c326df4d2579333081ef33c4953e28582e18c2b46a117c6c47c089cfc8ee2ad331e1d971ecb1b5b8eba766742787b6c350621bed103c95a7bdae508422b9ee02035e1a453c182c4b52bf8e210355184462d90e8becea84fc0fdc4584a24c8875fc9e5329b3a5ff3ef0f0aa73384a6fb11e0bc56ee272317f429143f38461be4a74ac97c4c6ad2493c3acf477142aa9ce4c3694bcf2bb060ebcb5ef75642fd83fad1e027849583726f8d0c24f81873eab3293b724b5d9d975d128546871916fe03f31b4d1421a2631d76ffa58cd32249cde10603410c8c298375ad416036164f9f9838bb32565451c7205d453bd91cd62adaeea86a6ae93ac239866e4db9e76d1004e83871e45b2662cad2a15e4aa3bacca0c26e26c6244fd84f79590edefcf7ecf5b3d882f5e64dee4549809796e65b06596c9fc63c2790a82b75548910d3d769983c5aa5393cf2d1d31bda541f1e206f6ccd8031d399098fd8ae0acd0b202c56f7102d35c6eca8a65ae06d52cd58b8434acd2095654c14bc8ef676b437aa70ae89d0593e9ad4a9e8fa3c6c7593e136eb0e0f7810959ad29c1cb5fb4fdd96bfd5162a21c5ae926765a101d58e79fbc9546687dac4ba77bc9596ef12c641ec25a7d64bfc83e99794cfb522722a59bb76953b3056395c3ff0c4eba2e32739f1867c3ba88f06d3119ceee3bfd6c0315c1dd73fb522ce996a502521b3c155ae97c7e67da3352ccd0d7cff20afd6bc2dea4611f249ccdcfeb3eeead52a1694c791f39663ed4c49ad243ad5e218b2992e2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
