<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03f82d7b0472244bbf98ce4062431285f94f07f23329d16df906b4c445170c17b3f5b3e259c1e658f0b1c419004b6639d17501dc76db84736e605c44e4487096d90519cb4b2f7dd7cdae2433c1906e911db98beaf21a758e7ac1d9c6f8f49e64fbaca9f0ae2bfbb14e69c616528fb5c362e23a4cce026ef3705253590bfa32d8c0fb7c46a34501c56da013e89dffcc62ad4a1814bfe776c7b188f46b18c6b90a07615c4320637307816d7cd17d52cd50a63d87f4fce0ab1f4b50dd224990d42f98c52cf049b7e9c8aa4e4fa860fa01ab210279cb479471a12cee7775f44cce782d600abb572d5695d6ec572e388a51577414031df653b7bd854badeb98f70776f8279b1bec7f45954ce3676da8732d0110c179c511f5b4518bd86ce24ac49bb3ec533f26651f5f947b56fde007a4e5c0284863d41b07848b73e350a370200f57aa91cac00d98f86d88716a3a53ace0f20e85818dd74466f66b6d33f618582860c3105d6c74cae19c60f25f829ea6ea4b7494e82ff47a0bc27078959a9781f4090c1aed5fa0d552c6971afd3196a0ae41b9b79082a0e177c4b4c1f18e817622dc24e28e295c59ffc95692bde8ef5d142320330827a18efd1b19fbb0481225cd1bb11b4eaefc1063642bf080e8362359213545be2967824c2ed4868c3a48eee0b51088abd0e52774510adf17059cd67d2d47ecf9ef73ed5806af7ebec24d35dab3ec13fb2a1d042f28cabef2e0ecc0f01d44a180b6770b189c24701c8550486ece745aef4e6bbd8f07f1b0342c26b95bc2146b3e98e10c2980cc0d0aa0fbbf17234ce5bfa17bb5f3d7d1bfa4aaaa2f0491b09ec0ae6a0a371ea800db3e5c7fc8dc1934a6700eb2d943cf0a5720d8b84aa738e3f936fc726ad7794fe6fcff640ff73dc9a1fddfda8c9b601505ce9206868784f34b8755f985a06becb5253dd3f6684aa3136a8671162759597d5ab54cebcda8f47f8a710a9ae38450dbf0b53c6a6a011a904256ceb639a1361ca21c0e20d961b1d37f865770ec8bbb13aef380fc5c94a70067935f7677e64fc32334b06703f5d46dbcabaaac590eb3f645a379d1a266e7008060e7259f8abf2d2e440520ae721ab7a5d4bf30b5070b6b98ff9276881d5bc8c528fac91e44da5d7a05bc97f1010151e5a7d51e1bfd74ad3f434305d4313968fdea9b64d834a037b848abc0d39c1eae5f0d854f165ce72bc57cb8f88c5fb0817e0b080b4ea7c31def5ec3215a9dd0d2b2059dcc93f19a2bab02db0a78889ea6b5bb589336a62962e14e4d6913eac07536303f70729aeba0c7418b9977a4fadf53b10a4d23deeeda3cb2a9a4c4e2a48ad60628318e5b8f48b1f502a174ed76a64b2988cff4ed6f81a4a3badfec3f514bb46c80d6aacea566aa53bb0663a0c8027b31cae5894d6ebbc42b019d91d6dc08cce45c145a7cc989fa79ad071db3c393eda498467b84134d7d84b877c9f242ed844e7a3f1630b00bab6904f702ec1064032b0d545b6d35acb900c9777f300c5f6e22842d61c3d9d0346cd7b3db560fa29d646a78c96984eabb587448b4192a719b6727af6808b2a738b9f0334505dd3a9b43a1af2f49699e4a9fdfd1e0403f52c6670297ac791025437490982f93b4eb6d1f2290d903d7314ee1b0ab12be96c4441705537f3966157ee9d7cc54d2a0f08bda69dfd926c605d504a8d2bc9472fd172ec6dca394d3046e1eea66d0caae7ea908dfabb2ce76abe10e2f31f380a65568d534ce5843aff94780e9e6e093b216ba98d8cc8bc29be1cbd58fa0435c1f0193925d6014124fa8c779d0d5c1cbdc092cc85ecdd010062aa159bec416e5d9ec7ab6b8d68b0d3cddb8ef0cd98df7764509695c78b5babb845f385bdc5a3bad468fc3c90d7733d386ac1a5a028eb61b23470686228804cfb24462accb41aa6059d4c45e0836d54d158e263acf337f89f995a450d41bfed355b6c7319827233025b8201a94edda5409aa62c4e49f4b44e52bd756cc73103b6e466ccb332a418406c341db664a291c9142d2ea9cd01c03639577eaa1d1d7ce96145ef5292fdb4d557d61e1b4983d9a9a01d2e59f9df81ef61732f8ffe9cf22872af7984a1a343d266ff9104a19996619364b7f6d46593ee671a51e3ec2c0701fbeb6af18cde67d517e86cc0ec31bbe77f10857eab9f35c39291e1d366741ac785411b476b48a3a8a8aa6e01777363c6193a8cbf7b18041271ca074a884a64634aff481424f8af355a5b49c2964430dd74984699464271f501cd5db75b9cddf73f1c495afd8a7b9489c136ebf9f1342584763ab18da1466200c50e97da7fd02afb19d4bf0cc71eae3ea3d606aa0e7b54c2ac2224cf89ef6198f33dce9bd6182f7a173124995c1c17ce4addd1fa2c7fb440fdb3ef6a9fb23631f27517eb9fb28d68710275fe2fe909a14a677ae56166f73de2208085d17ac5e815c7a956d97d59cac8baeea8650d416fea85c5973bc6baf1c5ffaafdebcfdf9ab68fa19f4ba437685bb53c12967761866b6efc901ea267e1bf37c417b871bf8cb0290d934e8ce6deed9c7a43e1788980c2ef07204dc821bbd4dc3d16ac0cac97bf9b8e892e8f10b2e3abf6b359535f9e282f0dbdcad98100804585582e091dbf5f7d121d4deac9a705cb18b90d2d80851d07131185b3ee71041548ea284d7d58347ed6fa9e311567259f12ac6481a5149ccbc2a48138ef8f8d579af7f2c733c025f0505495652cebc4e8a0b0f34687dac7d595960a9f8717d1da741e099969953cd235517f5cd67bd5f267474880566ecbd00ade9bc9e6b21277809408fb31915c93474cfeb8fbcdf3d3561939f4b86e05d2ce3a5c2ec9590272592431c6758300ea94a0771c9fca9f524f5cc5a5810e85886eb0a0cb46f172619a56495c05fb1a436e1c53b641ff4a4f7dcf14c281c4a912637ca112f782f5dadb6be9d882b3f639d57f5be4ff2772b7548be65f849d92a24e18b54536dcf68ddd96161ed0fcad4837683f34215b8ae8209c6f7e8f2e478cb69cf7a29ac8632d2d9d9235633ec8a60b5b3408a85562f61d9ea53569d59cb8e6edc32eb4e4952cb51d53a12b5213085c41cc236a27d80185dee017d6509a30ed51124e1087979039f40ea31d819123ffb6ca1f3a799c347985b18aff18c4ffec1b4db0fc669ece6abcbbae4c41b15bfcc9c3b1630c47c1838ef666a643ee5aaae90d0999810cf168a2de76895901f09ee69a5497623bbed516690e42bb83d0c8fc1c1299a8c59df3a57713752b6dadd2b16d969984b9f0368a97d474a6812a853731a3dc4b672f445d9e7d2c79517b418564c01db514fffbdb8f43203b9a745b41c7d042f67a8546b29fdc76495c4f7dfafe4a7995ac573158b34a4181a434052814c2a8f3efe200ebb21de4fe0581e6e26e2238696e3d2a9a68b4f0a8bf8142e096edfe58cbd33d9e167f02878f65e41deaafaccec568f3c67e3b40eb1356434d4a8e4bc591f27ef487e3dfba86f03f588b56c3a19afa833409a0899ebb30f7116d8fc3bd3b218c161be3fa16416dd42e14a6d0ac263d7765ca3921a110804285314886ad31038e32bb3eaf34bc5ca6fb1e1da3f718a32c0b399e9e147046fa3650ceead75e78911566267a610628a33e07d9a3ca75fb688cab45b1fa2af904614e5d06b7c90d88e390bea3af069cfa5f56c59139dc60d0b60a379d81ace21e953f2c7a2acafb592d070f0f61337ca3c3de4d59c72a709a7392c8b26746006d3f2ef8fa93c14329655ceef44888bff1e974d5d5c1c931ab28680bc6d24fcb8c8d13f367cf88fbab0f2e34a44a2e09fc760d8452e03a93f15613a5bf70bbde7679719ec83dd0669ad51332ecaa530ca66b2906cb473c8ca2bd24f299b88c2edf4312c5aab39aa25b77a97285a3be4c900e01bed018f6bbf0c6e961a4c44cc51989a8aba9371b65960c88cd6385a1ec482adbd0dacb7cc0c45eba1b4c72ca9301cd4a2d712c6691330a0c444f744db3cb491058ca79ca3de83b04f725974a7f0781f971c108ddd8b50738acdbb276a7306679ff9295cdec4e048d2a94c9066dadfa29d89ae95f08f35ac1ca037d345c6f77fa7a7a9b59b00433ed9cc87581ecd8b4eda77b11f09ea494fa5ed841a3f75cb69b02ee540f861d1bb85699686c1e4800acf69c9902e16b37cedf175beabfd77272e99060de41e5482f394f077bb47e317731e0d9fbdde79eaf65640f17b92b554ee8d810391f02504c2db2edd4b37ab0a87027c505ee9be3ec29557207a0c1c4a17503fa75248ce2ed8dec210e413d65ff73829950f4c708658719bbe0cd9cddeea4ba5f620fbac9bd552cd9ebd7167c536320533e58185d7bb1dcfc29bd8c1a917c6cc1391a6be2a277de942f84964001dd32e200a1219f93866ff7876b34c1f30a6d937ab72ca25651dde0961be8cb46a72a53b5116466c92ac20d2cf8b634aed987fe2ad77946fe9ddf0f65c08339bef4b0c8ccf1490b8684912849e65f719926981ee6e113873f329e3f2df5d6cd01bff21239aea36d57bacf3f99e691f8e661db4229f4f3a032bfed450303c86b469465ad8ab9fe8e61b9746f7d72c05f26820c5b5ff08ee2b0e885193d8694b67c87968ea4ab0c5723985e355766ed6a1d181df2c17577fa37a4e3fc8efa327dc0d36fece339e3a31e48a47af399fbd3cd14d3475d947b4000faff048f30714643661b5b2c48dc8f6d25a43c0aa78165e5363096be0ce07da42b2bfc981588005df792fad3399ed79187639c0aeeb1e4df3c55acd7ec6932827363005e17e39da309ef46a2320b3ab0b0b88a5d035f4343f10fa01221650c709e8628e7b7e1a4f28e1441e45fda255394772044807f03026bdb6563566b5c3eb4a874b8eaf7e3874a9249ce2b4c3e70c15bd6b6ef91754081830a01054a9e8d677cf5f27ef8fce69ac7b60a982e41aea6a526cf20d59903552404f3bfc61900f8120dcd5004b855998bf7f0e5f49961dbd3e8d66e4ff6e6a25a17c5969bd27beb3521d6ea5efb2e021a0348c3a003ead11ef93ac26f5ca411cb41d3f0195e3965949b80af421120edc487c682690de52a163b28097cac7c5ceafcf44d2d797129e04643128b90bf953b04dcd8e26343c567ca664379012ed90f7dadaeffed4d7aa042932d7b786b3d7d89bdd04f9aba9a1cf769c76305bfbc8ac40b5ab756a08f919e15cee2d63b41769192a003406523b3e9f4e1614d01f2ab52fcf6e2232b1b247e0a2a49b2fa076ac2a5904e847557e35f1978aa8fe8cd1636d81ec96b54e0906ef5d421537de691b9b1a522864e48bfbbe225b96491bbd745b71fac29dbdd0d674f7614eee96cb416a6c7f507843615879a5bac011897836727202d66c7a18ce681c4170bb25928c45deaf4651b5c6d3812b8be0c1c42f87ec51f1c595f95b45b80be2ce6e6799b67e5d4342d190a2ff16039a7ecdca16a6b269d03e504852d798b2ef9068816f68041287af3aabeecff1bcb5b9cbf78364c4bafe4e7c78f56bd14c44116abd887962089c481b3734e71711a0e936c868d8f20afd4d98019a748f661ab68b2aa12bb9d34706aa4bb923701e0ad832fe892d649108ff4a934e981225c95ae94669547f44619c6f3fbdd63061078cc22f0247fed8040f5d80e2eb1225c022ec296ce8e283506c6a950cf19fc45e768981ee2485cd7056a7ec446166d30690268d56481a83452d557fc0fc24477cebdb8d896ac8cc4c17138f7eaccec8137b5f964cb2ebd43e707a6b3656a768b99d947d2716cfb15b426da9b25f39cb2c9ddf34dc22c9822d22e26d56574de060c707c42af99dd35b63a080ec94ba726f8950b7cac57c9b6ac424894f5a78226128a40daa4afe4d602533bfadf409a76f159103d6448cb53f4b697049b336e5379ccec8d1715ea28427400acd6783e9cb27ac19fe8bec66c3e40e18d43f0ff3a48f639d50b81d91f3a2696f02766fcc33facb0bdc06fe41c53a31c208ff04c536f64addc5c7b3733967df669120038f7fa3c5f6ffcc7ce242c83256ecf522a50e9a548ef370fc2e46f92a47eeb4c905ab5a62b90eef2a0e9acb6ff21d7651557ef582af66e9b25636b3d3e516141e44a7116670efdf250536dff686f3dee7a42acb4dbf32282718ef9c57f06a3af564b49496e54eda05664094d18f6edc4ca1835702002f83a5f6855d72356912fff27d6869c333bd1d213364851be71e8996208323bbb0fd5bf6ce8098291c588a5fb0f2b42f76bd72fb7edabe362fcc3d377abb2d21760f0fd69b35b9de08dd5e69a42e2b6e37785d0472504854eaf0cd488be68e6ea17059ac65f73e73b895b1b2e23aa4e1ba58e1cb8df83f710bd7d1d10fc4d7e3e4b9ca7bc803b40de7096861bf05a2c7664a611466dcdd22d3dc0b92d3d190165085db066c72f632e4677ff3fe45f81a15d268a14523c547654f9a897a93e61c0d0232ac9fd394ed76235a461266c66b9e6c8ef883173bb2caebd6a8426a69ddfcaff12e913fcd023beeeee36aaa3a28093e2b42cf79d6757cb029168c60713bc843f004ceb9e301f6ca0bf60dea53bbf327f867b3bafb5f06b1c98b1b7988d6d7615276aba079dbbad4c3d8485fcd4b145a8bb64f6d1001f092d4ca753c8f6285bfbd853a6493d5e23cd32ee5ed57c2c8d4c254b7460abe5a46a50f07b52934a2ff101f34a8280bac515d82f5247f42e98fbde478e2e4fba8dafcf7f66d873815993e0f069bfde3ade7ecd7970ba3dad2a2d2d8aeed208b2a3c5645b6d725c4f92123c647ef6c43f93d83c35c4c81b0046b07e68132fc19945efeec8ae0245ac6432186a3e61e869b8ecdc409175f901c5ce2a2915f80f49217f3f061240ac8a9e40790b5e5186c530ced5472e297f0b5fec862bb6efac41857bcfd253fb954b43a7bab26b4b3a9e923a6c05a1a67eab8deba82ad548a4347c0f9bdc631a85ffb15de66be04e3af6cd885083a0fc8af345739b75e0efdeceba332423566bd6bebb0c86a0358560148481df975b56f6767e6191f51bcf4ea7d7ba6f5657aface8666f29c55ce52283e37a5c1eb3881a612f0da24c54cd06b8489d0cfc864a7725ac7d16e6b6ad2cfdf8da947b16dcf94e9ce0235b230a81751be2f6daa96fa0915f67f6eb86389c50ec9cf8e0e127c3b1793803b84ea17685aea1330a948a72d0bde0e6f78a4aca570363532147e449f0c9ce28903cc7bfc0dfa88fe51bf0e6c68b45fecf632e506b9b3f54b6a48d11233fa231329ec6c0759a9b5f55b46983c405406cf784544d1030b509b075063def6e88aaaaea44c5829f004fad1f6ec9137b5e25552eb5aab68573ee457fb84ac26093db354d46d68fb7379443e13610fd52bf8da53ee4755d4845003e9533694f555efcdfb2d7f283c1ae0c42a7d7a4154b4110c85c7daf1a98ab01c2e6f8e9011a57ca50d68ee19c9f1a1c4d76cd5af051e651bc94d5cc77749c9b674ab7f77199107a902515ddfb6fe92a3fa773c44d661806f173574db83fd944686f9a976314817983f31c957377f1ec27b95603436860782f5eebca2a772fbf7765af56fb4017f73c49b9720cf54e7d7733c949a06cc56b0012dd61abb5094f8aefebe5c041d2feb94388886087204dce8b59bcc494d74bb1bb686a52f2a6e2d2d6739495ce2d2cfa13d24bc7ae617fb7edcf669d912ce45c5af24a7eba9c14bdbdf53a1f208c86466dba6babd27f9d0be16f1cff39b5b820e777c4aed858a74967b260b8fd11c402009bced8b7af529c6282c802fb42c122a346c1fc41d5fe18071f28851c6a7b7bdce585b2d2b6f0c2141513cd70acad5fe96f14361665c67c5cb01ef7d169234f3d892c7261ef41fd1c89366441218c60dc3b26f7bd53b71396927405313ac1715b59bd5952741a0952f4f99ded8613f635bb98e79500a452dad77e1fc5824bb1af061019f9b6dfef52e3204d3ed761c69e40af50363a3c5e7d402f8216169b680943a701607450b966b549c81f07f0fb1e6cd224090f60ad85faf4af49a775ac284936e5eb139f1a7302887b1bbd775228a38bb524fb006e9699845cd73f9a9a30906b8499da7a71475a1a7ac408709509dbbe73f0ead1a582634d5089155dcc5df3039487bdeb0a694b9f4eb94e0c927d5829fd45105917f8506a76391b2fb4d98adb73976c0d0a3c90ff74be98e9f121a8ef5ec1bc03b0bb8786182b0d5d3ad08191f7d70591f3eed9953de9aaf49abf9dcf62ed6389046c018706fe8eadbc736586b3dead9cd91e39ce7edfcf87fcd11e66ec3f70b94f4b22ddf2a1610141f2f0647da11e3487f058bb98fafd8794402f7512cc02371997cf41d5d2b7f0ff9d5e0ddc98c6d5012d3efb2697375345e1241b4ee404fc445acda69002ce711400db90ab105d9465e3b21b9481f13ea5d1d5f39b51bcd8cdb9a3f7021bd8399d56b4ba21ec91ec3457dea98bef47f55f4f07d8297c6d6431bb648bfabd8d998bb39e2d9a2a8402087d8e83c35f8f506c05d921a9304d6c08a365250635674400716acab460e7446416ad4c00c7c8c99105c0c367d8c7170b90917304f464347d4efb29da9c776b397276f6865f5272910ca3c2b9b71ea2a101e0c3f6fe678a30a0c1bbba85d0c291a0dd97e37bf3fe2a9d3eba418df6e80e58172c7551f1ca4860b38cddaf052160a23ffce222106ea865d2cb5975e9214b7fb1317065be02336a79724381ca9af62267cf35dad992426eaa4a1a79eef524b690970a17f7431c17e000a046312a622ed2c7fe8c8e9a4bafe9812481c3427b6395d26833d71726f815b687681148a9e43afe525784ed5740f21eec9556c958120b481362f3d373ebcf8ebd2af5a9eaef7dfdbe7168f2b04cce7ac8b3a0073af77291053e1eeef949434d1c0fe15389c984bdffcd77293cda5059953c5fbe569a83313f2c259d167db20da4bb18ac4fc808e5cebf1de97c38941ed0128e4ba571a05c3381ea532f290eb83857cc3b7ccb24c87c69139e589a8f4ec83e3f10ca6bbf505fec82553500f34cdeb65b85a013e015b5134a4afa533caf2066b907838167d48be87b461f5e794aa3f35b52502dda466efc123ef96c6fbfed4fc26aa327ce58555ba1e14299c9a29f0fc1c2c03421b368468c793956de9368ecccf4c59fefb4341aa14fa6004577361a3e548ad6e6ffaa873d5342e096c1f8a60cd08f0af03d659ce130037c3c95780d0a8b4fbb0d78c2216843ca094c26191d4b81f7bdf94b2d93d3e1fe3579600685dc5b262d7df5fcb216d154249bd1b46e9e9c10fc3c636c09ad571df1a45db7d3cfcef1502f1b99b0964110ba9e88d323f13482d0ef88644c9cea413141d6301979133f7eb93f697e4c0d42573747cb42b55f603ca7fd4dc8b28926c50c92e53abbeec3cbb7d0da2af3e78f93d26af1f8929f6357051915476f834ea6bc26d2c9d6f2cd334acd50d623433d638f99a4d530f1c462291ce0d4ff2c10c011c6b173090d1329e9194ebf840f55d7bb286d7097cde9b24b6689daaa378e4c3615ba519015a98856a5ebd5c0cab67f8e81c26de4e960d9b15102ab50911946c5634a92d888041fb71ef32c4a7ea11ee9c7587c9bf79f26b8f4dd2f74a59a26d05f1ffb6a11d197829d7e9cde9df036e2e1cac20a94a71fdbf2659e0b7228132ec8cfab4e3581bc2c8de2866d762ed17f8d641d2339a742e18bfe7a110f9327866da1da65ecac118e8a0fce94ab55b40a36e4364d3cc26f3ad8873161d480d9785a01d98abe257f79c70224bb73f880524534da501f6c76ca2db9a1a825bbf979e075435d3893b40070438e69cd57bd69fce0a72a087759ce33bbf0db22adfa40953f0d6abf08e22b0cab87bd1ae677036b67c97c1f648bd048ea64224e8118edaa9cb5b4063008402e5de421cf0da53fa99f3a6469f74a7e86655f3267c79906e862584c79ed34818309f6876f17dfa5b8d1c969823e53a94368c87031b677acaee367990327913bf72c1cc42e11b24598c071dbd300762ecb9585572405250df22677c1b6094114cae6a33bbb9ecfa03aed12a333fcf468eb73e4b10cb93b64dda5439063f5b538203ab95cfff1f709957bf4ad61305bdfca93945b878b83959e0cfb1d8a340fead161253343c0bdfcf1b9fa05f511d5d9cfae716328ee3361e2a3c7e9a1122612ba31bb167123d65dca05792ddfd3b306b387a47f76653addd3cb21121a3f229e48ca5982205e13d853608de8551100a96c13fa5721c64abb8e7f107975a00aa097025b0455340c6126b3e5e6d4a58a0e8b2fe8c4fdc94fc1e3adcc1511ee4edc1aec3e71e426fa0563234e1048eef4e2f5a1c25edfbbe9a25e9e0485e32fc9714fcc2f04582095d3b6e0d6b277bce6d2ed63db796a57adc7b945b3cb8c54feda90ccad92d44495d21a44af393cc5ed4e74991a8ee7f14f7b98eeddda6f05b20df4cb6a4193ef1849abc349c42e3e707b426b3263cd7b105d2ea79325a75fd6e93783e909cc414e1589c9dda346a699c597e30f15e533f196e6585c7201ac95f1b5f7cd7f28b63f446f07b2ea4b0888d74267b3a41696eff597ac93d91eb596dad4f58df02d24b29ede510c884e3d01186c16ea9e035c45ccbbf5b0f74442e62f4a02eed97c8743d53224f913d490699c1987d5abe1274417fe0ab07ddebe56afbb500497f7f82c75e45b6390d5bffe3758d1b23a0bb4e5b0068d3662b023877876f9f3e413a1b6150c01c476ad9eea8af22f042d0aed60d109b590327023bd8c4eababb6e2131ed11855ba00e015ceb31d272807518995cb6b386593e6cbf52e7bc8ba650a9833d4d16cb3b49a95faa8c277db5c2e503331cedbc4bf3fb2fb311e977a6acb4301225fc5f9c53509b9aedcec1e3c515ce09fd1afff8b148fe832e8d5af5ca0c3460af4b938af4bc00999c4992c390bb3597549a72a7d0c0cc0ca52ff8a37a62e8db0330144a4becf60780f9c7261bc3620dcb9c6ab453f84e5dbdaf561fbf06527cf093448acf290c6f5e318f101a8b13f0e8e290bb9296b1490be4efdf010388f4b8d1b0c92806e8cb79652cd350a60dc448a64181b3604fed5755e932795b5c018ac5ecb6eaad6336aa25d4e00221f042f490f4301cfd36bc3e7429d0d9ebb84f14e293b97f8dcb0810043c0921c9e00a6ea9ca320f16d6b2bf86571076338c6889125fd621613ebd7de71969f1b6c606c0574dedd22bd753ea66618c1905d466d228b77267e7a7bfd156ece04f202ca16170bba25a580e8f4e9d35d71afd40fac0d4a9f6b11bf5b02efbcb17f5288340a7a8f13fdfc9f2980ec1f4194d23d33fe49bc196daa7d1c719356cfdf37e300acdce524c7bf15c6f6e902a039e2dfc18b27d5512bbe4fe3400768487bc8dcbe329c5939f09900f3c747b385fcad1e10f7afe295b70bdd4c37b41b5c18425719d4997c67722bce19f8fcbc7996a6433492a9fb9e097a95da204f9c0782f11b690f53dff1649dac44682231ced038951e3e9b9e7e6fe8b65d13cc6b9337e1879dc40f26d8a77a43e2720daf1ad78fa19b8180e4c028b8e62acac7dd4ce867b675014","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
