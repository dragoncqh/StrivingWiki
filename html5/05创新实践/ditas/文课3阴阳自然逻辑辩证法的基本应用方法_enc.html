<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2291ec0e656815d977e193879654e9ea84d04f6e45fccd5e672e9a645392be991c2fbca32151726c72e5e1236ac8b70c8a82a5c0fe2817b5f02f69d183733cbd7b0b7b829fa5288c23524284f0dbb190f39bf9af53b112788316b2bae91215d25c285f7d733bf4374cf3ecfd51858854a9d5522f0385cd887eb5ccb7e7b68b88e476e8102d321bf05df7973776d84a17b7afbfd93132c4b66015bfbca2a161bebc29fa787112b37beb0768b086a52a58d7e57eab699e0b788a360593c851c5882760328729518f186aede123641854224016603a7fe4c73203f7a720db47039c24584ee05db426a6dd89be2e7a1bdb4199296ea531052a7d2395c2a27e94eae1395d5f48e359bff31e43cfcb8b9d36e5db561a15f185f0775cb7b4eb71c78ca66fe016d1c5798781ff03b8a61917198f2fe5cdedcc15ffb5ca0c3cbe630b370bda7a48af03078ff9e6ba0c7f9677a22d2aebc461c4cb915810a69bf2ddd69a43a5c54f333091a69505c69050ab95f44bd66f1062a35c1e5c33f4fcd9617edf91ddb2ddf4d734cafd464b29ab347c3cd6ac52d10aa2585e29bc28b368879c240fa508f96872a3803b5d9fd120ea9d0e5fb36e9397333b6146e99c047aefd2c7a81ecae2e9c77eaa7e23ef8afd1625be9dacc156ef4e138570de0dc702458e3e5ec32076125eee80af05ec1de7ef9d25aad4afa5ba14c3153cf42358d6f9cbd069e63154f21f4790014101896a60a0f12bbed706732c81ce59dc9b0d8b164905b245b0a4bc54736e132a0442657d9f4590302dfd99e3fdcdd9ff011f6536dd1d0d5d2c3ed713ba2726ce778dbc0830716d4ef0ad0182cfc69b35cdabaf608f256b24e3a243dc0bec414ea9e86b61ca1296e9c07a199f522a59342e408524893b71b95033a82a24c43c1f6ba2dc7012eb1b29e5a2dbc867d211df75ca580dfddf948a0da74caf33009db8aeb51c7dae31b02751f84ac0b0a7e9e4f176559599f1991f96d83ed8cefe53903cc4a283c6b43c8e8a5fd4eb7ec88149c0179a99f1aa48df9e39770d570a26484eff066f608957c7aed99f2fb3d0ce0865f9654bf281a726dbe967418d4303d3a6f155c3f6eafafd90389b822c18ae8eeaf9b8c8490b6ed2ccb3ce7e3fb6da37eef4940c7212066549470faf61ec3b88af9ab8c42c556a08cd59190716ec2759f1fe31501d2f612a9ca1d3266d2dc8223e1def96428dd00b247567f5a4f39dbaf898785e0ba07bc40eae0af1d3663e7e1ef7350eb89a6db79c902c9b359260fe0d3b3a28b57c9e72bc46bc09b0e2eeac4101984549d5be1b6c7e047db03b368efc428e8c51041f257de5c17d3ddca0e7bea8d8f5fa2045354160d5d4bcfb5a18924cd8e7ff27e09ab718880162e71475681c92ccdce59b3a528eae0c54db146beedc066f4fbef34af3a7338b96f9f39809f475389bf5356fd980498f0dd032135c1e5c6acdd28a3d3c922baa1ed6fc854b03c60d97904336143020e5492ee80a6b19958d18388abe383eade41475b30ae993c348dc4345b321ef4a9dc29b9edca1d9d8db5a08e8cbc34309b077f93e4881ff6899d7b29ef1f57915c5ccb42a30872fca9cc32140ffe6394e2077afceee7c4f0bf9682a23b1e4bf3335e430db3ae57af7d7fe553fcef73b9d734696d4bf9c1b1e2ed4d58a338d3cf43bc2c128be7983e637d3a27e62d90caa8fee7f9ee0e3a9f73958a9173d5b166d9aa6f8c9e89126e9fcedf4a7ef68b70ab1d2c26ba00d49ca818b226aa8d3d2b8550ce63b14b97a11416500afdfbd5d3d9cd3891c96b06e4c04b1f0c47680cbe63f9963af42c5c2eec921e164558f6ddc26bc72582e3cbf83cdbd307572dcc0a8b7c008b0d12fc03dbe07c8fb22b75c6f854cda661efcd38cf443621c8993350dcd9ef897cec51fd01bbf3a5bd28d88e3cdfd9886a24838178f262052970941cd2624890e052cba6e75e503fb3dc0620a2293893d4e009fd2cbe55c4325b4acefbf2521635aa804c0e1a80dd977cd2487eb1c44e95983b8f2037a1502ea1ef8c7757451aa0ae899da1551d50dd976ee4f8404621ecc74cabd41cc752b15c15f2e988187de8d62d4dcf80b9b71adf2bc2ef44cd3aa94e2fe907db6d794d8ff787012bfcac53e2c27fdaa83c225bdc3dc6bdb46edbc27b6544143560e2c90d2ee0b8c9814a3d6d2dfe0f352da96dbcf756a68c834d5c90855e794881f6e239b0fc10a2eba9b46b4dbf21ebfc2537a449e457ed8a9ee8ddd71f0314c59515fb9d97af905e31d24232617eda7553941bda647ca6f8fdd21056b3c475ee40c2c50145ca982a10958d2b9315e8a032c3d0cd8e1b5744bcb16a5ef419e7d15ddf7d050292d91795597179c62f17ed48fb6a9635088badfab7c4569e1eebb15eb8a23ae5e611839611cec0007e2fd5fb663c0fa1a586cda385e1f37f28954e05334356ee5975537419052c82672c01c9e4f31fa50b064145f091cf87e77608bc4004d63ff4b9229b88bdfb7d009a376f960eca1738f8b4cc65ba2464992553af774e02bae4b91aaa747458e6b0101cad1e27a24ed6130609bff26cb21975bbc074f0fb77f79f8da1eb8a72b226184924113d124383c63acc77373fad0a81520420493c71013e95b262a2d11a48c373f6d3bfcc2d7abf22f7ad94769b689906ebf4bd50d94e59af9746a4957c74d70ae40a51cf9c2e0303617985c62e594df70cddf8ae9c55a66186f5e007f7fdb2fb06885062ceddf2c8af299c41f2a015edd5c27ada1112603eda0176f7075378b90b2037bd8cb65903eb687d47a9a188fb3a42fe1998c3e9868157779bfe6d2fb8f596715bdb2c68fef8c108577288ac3da68033c4e5de59a1ec1acc52aa4b82f2d8f7a7944db329f71a52ccf182cccb04023c006a9ff0f9f979d8af8a0a59196e58885593cbf21d923cde667a48bc03a32b63949baf245cd36d7cff4ab0315ed661f1828dba3aaad118b72860fc1964f1aaf6b6919906fb73a47308c6670c49531d65fdc48f685779035c75da82777bb9726fd47161eeedd5ef351b1fc560403e847bfe3e1ea8fc08495eb874052f027e147c4fd56a7a067853fe233f3a9ad104bfeb3f775d24f64c51184449ac9bdf4fb9bee2070f0671dcf7da4157285c979b190078de8478c481ec234f00e76d280a06b502bb6702b546b2fe642b667802a8564e79a4338f97b6ceeb76e179d9bec79350f3d33719956a8a93c5db04bab604f1755d9593265ac23b149be054162c82cc1bc391b8a6b5202d1bca26c49cef9df96cb5aedee9082014d2d6cc495d815e5cc534d10866f4741d1881c3aba4c442ae63d404fa5700aab2434c850bb39a25acbe849b9c5c262c21c336e7e8e2d2675dacc348ce3dcd35063406168413ce58bfcc8ed84dbca6c0f6a6c3bcd5dd578c7d72899fd2dd60ebc89e91f938306991afd0061d8ce0a493e265b64257ced70ecdb9e97c40e7a9ef50d08f6ccaaee3e23190e8866d17ccfd17c31fa73e6b02a2a6129e7a24a8f6306a0f55c3782fa3ac2ce396318f76f882146b52f5f7b26146715e611b17ba6a5b83983f3582da740636a25f97c262bd86d022cb1b168be0032200d53f7e12ba072e4127059e8f6f4d01ab62899fc533b680b2a3b168d12697e578fd30af5cc9c49e5f9534df60b986329d10b46fa3a227188bb5456bb85aa84d3a8c2dabd6bdff59c2cbf499f0bc6383a7bc427dfe780b43da631ddd2364ff702f40605da2629cc4d62651791b3b00dd36497a8cf0eaa359fb37046ca3310702fe05585b5ea9be30d97643418407e3de6839b9b4a50b5f3b1dbbc1c42c582da07ae518952693457647b9cc69c890a0998f4cdbff6e1267ee1cd57c9e05afabf81ea5859ba1bfc877ccbf89a177986ffac23b30c7d6e0b30c8272e185936b68f39a79ee1cb9812d7d0f4ff836d6344779716020def51c3ce22aea7db148dc7652d2de5c977ddb352d52c9e464711128cdde46ae9788723bf9d393aab70b85cc6fbd7de20939293058b6bec62418ce5f4b66e8eefccd872f8e98a31da50ad9e04e45e726ea5f85fd0b675d2535dc570bb46a3353001648bd0642e795aa2a1202ce72df6eb299805ccfa61a8479989966788d7ab6a8bf23c299ddc4936677822755d111593d83e291f82c25cc595f83b8488411b0712d135a785b6324f54e0816008300b82607930faba71ba05613f28ba4ac84f4f5f912517ae35160696a532af98175c2b9892f7adf1fadf3ef616b88bee07841d96e9582a4d4b21b1637774850c0358dc9f62a12c78f9213fd0d2ea128cd767269a600100233207ba3a0ea926ab2344e0d1916606f19e69386a8ec2363b6fb29a0ac1b6f3187af82808910a6834ae025eb038c39139d0a75b05248701df88870d539fa99304a2532f16b45b5ba0c8d36edd3621c310f8df0be2ae6984a4c8734cfa6b9d9923605eafc1a3ebb46c0c7000f044e0a8d43d52024e9bc6eaecde07173d9e182a34a9bf6040b8ccd4a602b73a728cd661785bcdea898ca1c50ce1d18bef17fb8c3b5356cdb1bb8f099a6ac64b744d4bfa04e8ed8e23455807b48ecfd901fa1e5bb9b9ce7ae9548c37b95ade457ff4e24e92cfcfda1ce87660a84b082123e58714b109209264b0b918f6a7d65b8c7b35d4a8a35e78e9370e1696ebdb3f8f7e08fb57bee9effb950486a2db42d886d51271e2b1f0e0b7782310bd24b4fe92679783eee8cf1b327e4e3bb7388cd00876868d104142f8ad1fd6524aab6cb3e00edf51384e82dfee3b11ae337498ead0ca9cb20f5b09fdb27bfb782e11c91602b496f6b91e29045941c94200b7b5cff89e2f0bc95c778faa8838f30754c7dfc93b575cc56f9a25e7d6ab90ba65f66ca3a12557e87d3c52d33e269ebd7fbdd472eff3bf6a485a4aa81d3c4fefaa4f0e4c5d3cfdd20ad91dc659ef34e345d76186f00074acd68bd874b98d52c800362c851bdb9bf748cb28a172f34017c3e67a13b6cb72c1feaf9c0563fcf03fd186da1ebdaea48e066b0e8dcf867a2f3102d45738923be6e21b9bd9924a4abdc9cc9fbd3891550a43c217ae01feeefe74254424639b1074dc327ac47a28d935d4ce85746514da028617d437124fbc774443d5e77a929b25ba1e8f19b336a085f28c72b5e6cca5710547e9877f60785fbd7371fb6016cecf4e917829ef42895cea2c08eaa54867fbffac5b3f2c0fdd3fd5370be8ef0d3a713cf364d3252bff54dadc1232258b926f6bc3ec64b24dbe4aff4c6b87deb15dbc3a634c898c9f484d573b74b5d669fcbbf2bb185d6adfa491207e9cff219d2f7669c46fe68414e5d309982d6c14200e3be04c5657bfebce00f27f18fa18d267c9957686e9aa2f088b2cc51b0fc8b42f144669e2433b2d4456d7bfba9716c41d380f2e5f8c1621dcff288d92948b33016ba716f1770c22695d280e0fd26441ffbe78b592d48cbe56e7654ce2dfa29670c683a737ad331c28b1eb88218181caa1acb08933aa93cb6e68c7de490546b1bd9acec0dfd81571d7bbaebab2f54a145db98301d23257ba2a32e79a21fab8b8c5123abbf259d3cb76e73c27658b5c0b331490d058d0237bb1845d462d2bcaa1d6cf00cd3bcee1a4e4c26f05417bfab97786b0040297d026a6f301ef551530b01030026ebc75a184f4f4bcd5ab1f93da21b66d8e7d5afad6bb513072817b8f8aadbd263f903c6c1b91ae35a3579e2120919db686f4c71f063b2e765ad46ec531e0c861a23d88565415f12b72926a59f6120bd47831438b26c77fd08f53a5dcdc4ae6b5f6492c9b389281a604ec5a857a7f1366ecc642339a2521420a6c8b0be8200aac44cd595d82643fd54077565ea2c68eb025c7454a0d48ebc669115268e6bfe742ac7ea990b69f8106956e14547288b6a739cecae8acd810b6b0e26ab3212be2b6aaff6f6e99885131ab1736a94214b843aa1556e2df4b6e4efe5a468bc2d5cba789388560ca140f077242dcfa4acd6337330f790c1efa62f441b473888c95a37eda450a5b47876e0dd7d8c06d778587e5859f5fa9fe0934c076758c776a55926d57dcb51468fe8587a72afb90cfe86f4b368b783cd117d5686f2a6cbd8c9a1e6b1dea223363a53984f6ed505216eb505500ccbbf0f0c2c35a25450e6e8df0a4ea5ad28329b328e03bbee84040ba5595a11cd9a8b294b7abd4946861c7473704c5583d373f6f2b8d3454925460d2f713f2db8535fad0e8df645e9c669310fb59222dcceffbfda53696e24b10d61c0752c56aca2320aa96e0b5b842ce06b6c8330aa55eb9434ba9fc915fdc6fab869642c8c16b5c48ae2fe0996176e2dfbc397709c2820847b25ace9eee57b320f684c22495870b816d39595964d31f9fdb9f288dbf16460e2e643ee35d1d8feb45d9e7dbf3cfe6096ad59d9162851fefc4092836fa4baa73718e4714aa6cf18c603355e34e9ab60eb31bec2165a8ec1690cdd7f90b7fe53e625451802258c7564ea842293fe52513846cf3658c2e3ab689f12de4c994055bb37d823810ee14a3af9c9d185d0534ba9b7f6480169321d9166452bf9da69a798f494b450325694265582c1fcd94938ab1bf58e9fcccae2a8acfbeb8650b966b0e199e7a41d166e33b443ab9432423975c904ca02ff32e5e3aa9e1d034eff875b70b2abe228dd455f5fa3cd2656ef2ca0e160c75cd7b90de54911931a36e5de485df83bf81663acc7a915636b2551e5fd11879309bbf572c3921f0ef46be0b45164c98d7376fc178a6a59c062413358984641035c06a1d9244194933f4b49213153d7685d2b30929fabb658c900afbf5528f51a90026ab07a25ecc7c3e988f7660fb372a55aa1fbf31a97c6270fbad85fd4356630ad06a8b1856457c05c0abb3b42b81a93f935eddb471e187576ee13c1e294466205225864dff78967f0c15249f2de407afd6d930414695aded850b5a32e79fdd59e75c72d30ac188849fb49a615b05a94c73c6ca77a04ee362c9154cf031919c17e5f7c74f7271cd00678d22a2c1ffbbd475ac56d9dc62ed2d9d59bd7bd1d5869a0bcf8945ea5cbec80fa7e4f548e4756a6038a706dec7f469935e6014bffc7f92608139ab4d20797ad09bed3c03bbb5bbf1d5f1d2248941a099d16f6daa832ea567a3a1f517defeaec29f12cd342c276dd3dfe585ee17376a11fae3b5c23eaccc435624e555e2a4105d666ef7e1631bc77b19688d6cb5bacd2b9a516d0940fd660dc30eff7afaca8100c709aa9837db7b4924ad6b9b4442576330db7cef1417d6d5fc513e2a98c6668b7b2a8921c5361e6eabe570d671cda7cb2d7d411b7670bc03f31b35bc3a6c27c4d2a3e2ac4f96f94546dbf241aa4a093a28af1d5103d6ae9336fb7e86c440d7da59f634312c0cb609f418687993de3c5f68efc99ad43afcd81fc5d4b58ed7bacaaecd41b319ba5e4d72842aa43203345e2e8969b04dc2bb0b886d42efce208e55dae34a8c898e002f1dac66e0f5727785a160d5d3ce56846b3d737bd03a8338d62043d01fa0686f5bc4ce07feffa28ba92f9285d4943c9246f3cef16cc030096bc9fa102ea103490edbe68b691c7f3cec5c48bce403a46da313ef7c412dcc3b18fbbaec0a8c6f9a645914e31531193c339bc037448ce01ede16a054722dc0932f71de6414c09e40353b0d026ddea25beaf8c7ff29df99a89ae9ca0d08af5e79157ad07fcafc7af6ac02e510a7b2ad02227376fe99401fb270c47c1c439164acae33d52444d4b4f14b3afc7533cc60b017c7a87fb4e940b7bb359569cef1604faf7801905f36331121adc2ba7f3e49933c59040512db17e5864f3a9764091486b94195431dd14c7f735810ad3aa2c0c6eec4733bd68a5017946ea52cd26ef77bb994e05a202ff256bf0111821653fe28305e2595473d9878d97a1225c09993d97fbc297a80808d87100bda53d47d0b36bc3259098389161d1383647dca740dc92bc3419f836c0555f4834137d1e91ff32e0b5323cdfa4d7f2766460ed31f18f7d7ed646670dfcca4d263bbde722764d0eff46d783fb9cb4df9a15a76d4fa8f51300606ced9b8e1d5ecf960a619198ecd7fd1e6c0afd3d706123f057fb34db31385e81a034711a5152d419ae03cc6a16b3226a8b57c068bbf62a587432da1fe38c479ed5cccbec000cf550be60b21bb0a60bf82853ca4b03ed237ca3411646b88a2cbbb9fb252cd2770b04745d12f1fa709c7db99f418e50cd468339613d8bba09c6b80a19fe91dfec2f2a077b7afcb6696d78fb17a14b27eb027454895c943dff48c72002f78719a61c5579f115ce13253d1fdee8ee55e595df10d64d2652827bec280f094a6dc3000c81971d4881e6a4ea72e42cb4ab4cdb0847b9f821732a2e394787d5120a730c5ad6a2f2418b18784c23f393f96350d5c0158ea5dbc03cd0f89ce928d58120d5ee43518d18a5b7483aa8e3929738d2eecdc383e0056acb0908ade88b923b0f86bc3d30af187fb5968e65820ca60aed97ddee22f058a74d94e35ad3673d800716d50366601cf3c34b1df914f47586f32051ef62f3bf5980dc94888cce3edef80ec55aabe2763b040571e8e65f4077c77980df2c30b5f6ed06b2bf0c1f8304935119faf877d11d37cd5fa6b2e94606b328790e87ecd80949932ebb1f949e5d6577936b3698ae649087d2534b1986ece90815daaab16833b961ec72ec1075c8ec85c8a401db55d857ad30878870a55d23216951cb91a315a00141ca907a663794f0f870cbbd05554b6af2421f25d829dbd0f26835b9e7f0abe1f8e47a3d1ddcb9abbaaab430db5e8987314eef8bb577d6083e34dcccd74ac33c17281e41bad7db42885d645cf7fff557356c1fede1fc13affbf6c2a342c77cb84ba27a7ce876379918e3a8af792e41793dc476788095fd3ba0ce042814517feac6563020c06e446fa7448e5756553d048089d2720c61b6e10bf0990d5e849a4ed1f2c7f30e85ab4a46c6510c41f69db18e922287fad192e6053cbc7942794cb341afd66225df61dbed1f4e2cf9ffe838428b6493a594f4046447ac2d4f73a5977b30781870e22baebb270e8229f9315742aa81b1e1bc193a58a5806ab51d857252690dd98bc4de142fbacf6867df00249614db1fef2603c599ee74c5f0adbb95171f110bcfdc7f35e21fc60cf69bce9e6c01bd4685f15c6e5e82df15857ad75930b8c9feb6af66612a2533150e8854da5960e4f05ac8e4121eff8c76b2220d0264232b6b0479cffe024b7abeb652e12d7ef6f76754a2e895ae6129ab710745da749ae24fd7932ce624e6dcc61adf89aa562f5eadd8f2ccce32bf9cbecc40e4ffd23419895dd5b12ce55c5fcbadfe478cef6644ccf2b3f1484168ec8c26b8ed5ae040c54e316cfd9d07ed6e6580939c2f6284d0bed4358bb84109462d20a8c30431dfc46d91d79b9f93099338498a2de81c6359850fd2948cd841d5ab2401d5de12429c7b42b5f2a4aecac62e5c2a365788f245b1944cb7df4283c686b5b2c0f5f988f4995a6e428625f7ad1a7d850fde9e272150946d554a929fd92e85f89b21c25e297534992f6901fcc6cd2e7a17be1705c209ccb9acd2a7c640980d10af34c05b27deb0bb59e196319ceff18fc41444496540197d728dca75ce1246e8c79d856c874fdffb301931f2a4645644c6b52e47b06d636ea35a4a3ec3ad30cff75510e58034fb649f24c1fa9a9a2edef7481ce01a0dda3c0ff6a25602cc3ad293bd5f8e53d7bc86dac36626ce0083bb6cd51c4f7bbad12153b72f3e3df207c2679b1a4bd73af8cca3b3a32c3c406f49590dbdfdd034fe1f28e87fdef6b535428b041c7efef15c81c88a4417a8691d14028410fcdd9e3b1d7e2d52c873ba4a002364dc89ae0eff36cb3d9b0aaf0cb19c910a5725e2c13d6d232dd28f0eb7d3990b264b56320188babbc45ebac5cd52129af9389d293a3b8850b18883f35fda76ec6788c81383c20a4827b9b898719d9bbc6c15b87e5cc1faaa796674e17588fb123f838e9e53d8796131330dda55ad1bf39ae7a63af7ce3f8719d518206318ff80db575427af2cfa3ed5460f65addda605317005543c5f09d15da4c622e9ed43cb48dab1d3a233d13b1625c945fb62535312768dd4cd5efcd617ebfa04ddf5a1633c853fa8be2af892b47080a15c12c7e3719a14baa388e6e14d8c240d9193d332eaae2923a82d181bab40a0138f7a32589398efc2f74f3db6cd1a50f232096b3a96038a3f4808371a008a4bc0f2307cf158287d65015d20e270c8728bbd80a9035a7a92937ea01bd402798d00a13eb74f5bae53d59f345372c449dd29a1fc7f348cea9fed800729466e8cb50f3072f19c09a535872c5f7eb79b02d1250fef71e1b781996523be246cbe42f1c64702dab0b9e959fe2a25b2114338100cc91a51b9f4afbe717efbd5052d9b2441ed9868cc93cb4cbc29cf4c61dd4dbded25f4dfd2065ff1961e06d126ef5a4e69c0c1234908ef33bc158591b962bf9b78c073cc82fcdf1623bc9a33124fad3fd4e79a02ef3ece0cc15e70196589c27e69caedad6706c97469a700872224f39ee5a26aa345d32a8288110069e4e0e2e76bf97de40417979d661e3caaca821f66a0e59ee39514e4c618addf2a43ef0b03bdfd6d79624c30c7f7364b74ddc0a1342c30190cb3d71f78f9ac410caaebb6e05beb09e415a25e469af7e595ab9ea50263b44a3d94c9b7ff819d9e3cf3ad3659934fb25e8d67171fc8b462f6098f9a5598a0eea0fde621608cf9f76665bbb0f2c7e1ec42fc965f8dac6d71f19fd3b891af8e5b4276bd4fd7b0c24f82bdcdb4f4a528e0e56321318a831c490d77d5b8aac1e103d440b2591cb1bfd880626a28647d28809016b38a02e3d26963346008f24dfd71090a3de26346f758c917eedfa6e8112fcffc5729307e2b4d43987ad3db93a873b46807adda4a417084f3f8887ac98746d7eb2d52070ab934542ecd657bf61cf7b8c05ee7526eb5bc5d6a15f565cd1f04bc7424c90f51ce0227f00229dbca8c47f8925e03c866f673d90d766ef35422bf0b6a0014324797dfaf833c4c71b3fc6cb4847c558a4f1cd2b017df2e935fa61eede02077247d0dc3d4d3a2de609ca59569ae4ada3cb23bdf8c379dbfd84191bab89d90e02dcf20e05737f5a444b30964e4ba2a5ba6672eb68977ed73d981c5825a418e9fbbfc07545f97ed786ffd70a0860016272d36470f01584fe401abbc0439567f6c16500662112495a29a2a5d7b6b8f9e196b73bd5250106ecf6d7e68a33104aeb546aad36bf8474593cc32a5e8a2d560930a2eb2d10ff67f083b2b238f077af03d56c4534d7a704c944d767c295f3c331a55e949907a2b27138ccd8d989a8394ef1f7d92fd4658346fce4de2acf455f22e8562232406f1291f45877a14277d0a61f6f25d9cce94aeb37dac95c21c7b1cdb6b7819bebea624edc500446ff62f30796aaa663847178dbc5471e8b9a8497307a4696c3a4724eafd116e7a68fb74af3a47167c812b506adf77ff6b13a2dc98aaef78298297a20845faa7c566f4acbe5a84fb460a28b89358c6d43603e4a931abccf5e13fe381b13c82bc56ded9fb5fbda623a7a2a789fd55fa8ba021dfd0b542f24dc899349b80cd2b344b60b7d7d71ed6a006fd6036139b75f57357c094d2c5d916fcfeb105bdd38b92bd97087f796c6da95b717a74758f758fd51c66986bc57977ec5c4351ae9c21d96015d88ef293f1a81dc597d47c0e591c005ef9f4aecc7883222c9a2db697064bdbb931a8ded63aaf580fecb54219d472dce4438d6c5073c59dcfa96c7fe71b5592d4973c0d5f654adcc1f80f454a8b6a29126d5ad06e30fa6dc19d857aa204c90dbc8637063afe0635b4c61fb6cd506b6e372798d86a78a66ed0c0e5de359851be208af243e40e50ec9b749e638b380fa5e2decc7698c0e1a98465455c137a96ca01938dcbd2a0efce1a563ad9f7a8bf16526bf5f7cb16e22c7eb7549f2d3ec35c71e6ebeafaac1feeeb14008e270b9c3ce5e3643e2b03553b45163e0c69200c146f72345c0228d0b8b1e2488fd1dbc7c6b6bea5c7a361d70084b81be081362e68abee9d4428d4b1fd89ce018f51819e4844c5bcca4662ec019abd95fec354fd446ebb7194f7f4dc17d4a56c4f8ba57b08ada1f777eb4329ec8408da2b137b67ea2c1a657b8c6d13c8464d5e7e0982e8617300b1b3e66b3ee3a8ef952914acd96b4801d93d2a2ead172a328e741607fbe88b9c501e23396701810f7d7e377b2aa4441e9cb79a0190f2f6f54bccd4951a026fcc1c2a5c4d62cf01276954be815ee87114e796002400a578f659f525ee185754e5734ce74aa318253a4d07593667143c3737ee4d4fdd3baf681bb1b6d0b326b973471f1c1625a39fee597db17c325c5d17e7b4828249e8cd1ae6ae5b64df695f3057f4a4487718dd62abc9b5ba7a5eac7a55028f0f9f4203e39a68430c558362b2e029cd9859b1b1965ca9f786f893b900395272e7b3da0ac4377554d727ef5b40cc2c3a9e51d69b610b1c581ea45bf12b352346893af64b8dc1c886fc6db8c1dad8438bebc3078770d1007b990d8faf7a7293840f68182d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
