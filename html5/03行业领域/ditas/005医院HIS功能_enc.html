<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2351274098b19acaeca1f5ef05a29b5c847de8d8bc8584bfbdc54cc7053ad10f116e822d56a47871289de03011186288e90b4315e1af7c0e3f7384f1cc5d3599a82ba7b40879fb82a1fc6b989caa5cdc6ae4a16df1d9a1f6fd73d05efaa7bd388e51fd57a55448282972dddab2d99683bb3915d9bbd68bb001eb0c5740090d0ad58d4f199a4b1e3a1d8ff80cee52163f30fde008800f443332eb1be6e944042564fb499cbdb95ce5a32c699d4be1fa7309b25e62bfef69e90984b3fcca922859ba3a932337a4ea3fe7a872309fe315022bb147e09caccc6782d37198bc1015b8c7e4c318201b2fb1bc24ab80f4f50f3424692cee659bbce3a0be6d931394e32d6dbe82c6703928566dcfecd5c2dcc5a7c18fc477279cd419a21d418001fd383962a8a6ba1489acfd25cc488c21a31b85d5e54b29e6a4b112cf864b6d5b08d6d1bb7f8d8e46937c417fa8a41407e326c92a9c58e7010a49e6cb37604202cf95a7f823208a5e95984aef13b082294a3c42e2aeb1664bc46e2dfce5fce5c97c6eb713ec8f65f4884e2fe0711fdeb86d52a817e020bca0e382ccd913ef944fc7a64e4d23f6164ba4c1bec3340505818efdbeabeb79c5e0bc52bd3fdc38401cabbd27fc7ad00fafc52f1e5c7cd4ec6adc567640ba54ed7a5ed29ab34bf3e16991997f014c5eb1c99bf2a7a20574b699573b4139e551c462390ec8860e42b9937d71011f6577c082c03e6e458e0cd7ae51f293204b03fabe6f89507b6160afb0fff772c39f1aa3dbcf97e8151b023c462a121525dc10f2e1124ff4f65eb84bfdfb878ae3a06f9b42c23ac53b5a08a8c5d4f9c6f80dbd98494082718aede069c375b466ef9c0ffe897b414bbe43f40616ad3ae8833e3835bc1d46e6b5916ba9e2216f843340300ed72746e0fa46db1da93eb786ab2a5e05616e66694347b8dd71671c7e27530194fe0a8478df9bae4a2d1a0baf425c50207459d9c5fb3c9dc01faadccb395f71271f1bc2911b20582c944315b5418b2b2e5cdf35c7df54a76ff716f61b4b2e48e0aad689dd4ca7c4718025b99552ebf10f332cee25815c736f412246f3efc7ddd9007d7aae031bf374805bcb026134a0e36d23acc7da0912d4a8e77623d21c739cb3aab1c4b8d336ee82f545610fc37837f37745d2e15620b7ea1dc9a294fb13e71a93e97868bbd1a689ac6574fe242c6a8594993d1166a8ae945e31d4a8a04419184c2a99819186dc891e37118e93a0ca7c82db4bc1a83b6602083a4913d38846d8cc51b4a42a54618093ecb94e32ff4ebaf7fc6df3b40ea9c994d0dd90c9e5acb7b8dabedd50e69d9bf305e8e1a8f1d25217e82c9758b4122a868d8cc5cb03ad2f7cf79885f69da423f14b728427d4e9203a3546396cc57b11462874a27b4720e9d2da49d188b769cc60372544c12fb9c74efac28cc9f206736a68bd41a0016640f064d17a73276aa50fedd40cd7a53b49444aa4fde5d31c1c9cafe8e2d32a998e8df34f246143448c9b6d5613c6ef8c0e3a2a0bd30534a974de157f4d35abc51d628e34bdbe071bc02880859939eb8885c6ca848919dc551cc1132360bb73e01ce67b4fceee3a400483f6bfac31064e20def8106bf733ce241c018cb26bf090ef1a71de8d9fd74c5271585e71bb9e6972836b0e95aa72521a3e1aecf44a9320a487c38a14b88414c94ac1d501f42ef496b6948e93adabc2f12c20e52635bddf85f9474533033548fe1f48f8efa5d7b6e89e0e86e1556e06aed9928d436efb1956d67a5ef6fcd2f339b276d5b8383210993ed6f2c874852524259cfa9f8b342b7d68b1ffca908f92cb8d68c40aca9072a4ad04e1ed518f39f9f62f38499c8dabfa747f905b4ae2145857b270031c295a4bcb222a6c30cf3a89ca7e288c680d85eee6f398bb4012f2877d9aa4123db8f60cca692dfb95f3b711a14e7fc0c21ed1c0f0fd1fe3844a0cea4d58c9280c195bfd9bc230a7076028b0cc8972af34666db6cc1682d92b8349f3e78b0bf1016fb2a92fbc764065146e06fef40a31f10d1d57b8cd46e3975f21f1c728668d5b910114675292a9e13875f65398b24a426c034c77bd3eebb919500fa38320bbaaae911087a664f414df4f140232ddd45270a4fef4e6df535d264dac7cfb68febbf2e2003cdd9f66788ddad9eab5f2e08d3ab361d7a2011429b9ec7a2d9d37892e42a2a5803c29d88b5fa780687bb9b9389f1f05d8b16e28b3d27056605d630edfbe00218b7d0de98bb11b4b6c9f97e512b81a17d9e50fcb45d96e173bb823cef6b704faf843b89956a202519ff2a3961f50cdccf82c6843782e0dcf5716648b1f24c4e023d9be846191c47219fa5e5163d8e9b85687299ccb7bd386006297cd1e8f4caf3e98483372eff018439eae86801d7c9047cb0afc162919b75190505b9b56920eaa7acfb3c6a3199ee877919553a9ad4565d1394f4fae6a0db073a8c13ead4fabd0bf330bb05249f7716448023aaaa41574a5469fa4d15b355cac66661153e53b6696ed4917dd97d9665173fc6124fda268fd791d08b863837413cca95524db23217760706b4afa760aa73899be07289a838e0b8cf92d4706e89babc78b6162629dc631a8eda015e50ce5ef6c0e97a89a22ac0c09aabc579feb06cfb353d0ac629228ae431ca986ab53f889a836c9b5c69009c580675432826342e83b7d0e354d781f636ffbe6a844e439a2e9bc164eb4331df055fbbc5871d1018c2a3351d364773550d9e641bd3b07407c315ddeebcaa56e3cc2ec308affaea2c74ced06521cdb84f264885a5900b50650d26b08e2392e758b062b9a21a194acad70432d966a528a114662522c26261987f855e59f33cdd8523704465e678ca8fd83c37dc52689c161f8d618f1a8971bf85a3c5162ab4cd421f0c4991e4555283a3dfe0a04cec6fde55d4827d6467469bfe7826d0e5efffcc03b5b1d7f76ef9dba49432ed71b23aa4e5ca75ec3507bd9d0778dd5c1285aaa7003496ab9b1e1208c1577d37e856071a310872fd07d4b62a8c30f1a811c3ce1c8c89df06b6af8267a628df1646a5cca04796da0ea94ed244d363d27659c803b9cb661abe3de00762b0bc5702c85a40144c68729937ad4de89dd43da1e6548c33b832216734380e8ec04c778c3c82cf2e87f379575bcfafcd68df86a71ce40b61f4826fb5e3b2bec89ac8d40f194ab6789a4cd3ddd7a53584937aeaf359563e6b515f9f13d14aacac0bfc4e2d412dde6a9fc4c1d8c4b3b67e59b7ea18568d0d2df9b3c78d2585c0824dda57f0978eff400d69b2b9a7e7d30dd66386f5033b55b4fecbba309e2a232553a863719a43c9472a111a30cf16754db4ec44d08264c64f2c0d0eb8cb84161b15a1f7d3a02da098ea83abf76be1784d35ee2925ce3b14b5aaaeff5b8493f9a01fead9f95035c43780e7463c9a1bbdbe9f2758be7c4716564061b83b91a577e3d4479891af5bb3ac3edff66b4afe00f91c00d4696aa6acedf7038d9dcc62e26a5e461407d8ba9a9a68be6cd744710204c28c9a67bd2b002075ee4b665376635c74cb341885d773accebc73f9269a18348d27b2ae5caf0e16c812a49b2c08c04dd09039e28a7d3e1d8a957a51dd3cd020e17075465ce9fb17f1f7c14e771b663e43485e7cce6d627a13baf15c40e18faa68532f194eb7a6541935d1bd2de4a203d7e7bef1e8373b28c377a639821daa48e61021d950395723448516ab85beea4bcaca6d9b9e9434a0d74a59ed429d81e8d0b1beb84bf51698a8fd6d57c26d31eff6250b163d1b3b4002f1a539d73e5f95ede8b5a0f42accade4bd923273c9017e7f8a6164de94e0802cffa2ab58a7b17d0036709cd72523046be235b36d3b3b139b3586a32810c7011eeddba9f9f51459236d919e247d4ed4f72bf9447450b1bb9366cb7d1db9a40cad9540973953f6541f4ee4aa651d3cf62b1399f8bf9079ce99b0af089897f1ce2c1cc48ec795f39cbe9a6f97e712752dcd91735490d023fde367e796f5911015a7ee2645912486ecd1cbe2ac91fb1f592ff1a022fe084d108b048a03ade4f5d30a0bf0b381ea8005725ba1e3b5a4ec1d921f2d6159689d981ba1f60333b0896334f1523597c5bea8e1e1df10bddc853cd3267c1357fd25fe176be570426dba4e9c617c4028d02efaa152a3c2b3f47c80bd7b23a886b0b0c5ddbf82d4d7df29815e03211abd05af69f68cf88b132ab20a2a748049d25be27714f603b4cf0615e78c9c5de76e98a34ed6d7b997cced4a1eb26423668782f8f8d0bfc56a4c4628543c0cf0103fcf0b1231a22ad220bf24f998537fa20559f01e263721f5307ed69aa6f0bf8aefe6b28d592fc8c3a2f0af9efb77536bfa9e6aca8da0e0299f856df78c0baa75368657b66fbd4524493904ea8781de729457fd5e2f63821795ff359900e9e0ca491f7ccf4a318c80a8f607090a733098e9118c7f196461a868a7eb44cd8cec6b550e54cc7255750de8d4f7d256e430bc49f1e3a7e98e27d464520375ac82cc92569bc4f2d09dd7a6a5e3e33c79d0f13fcf4d866745d90e8a42a116f4cfb836ef2257a8e8361a1359f6f0e755f266ca5d021a225a6f63d299f8b6723bd884f12d35cef1eb621573a6be530f7d63d51f8d72f7bd51e2a43d4dc8ed3b644a10c84229626cac0bae7286d3cdb61c564a20f2d7c9a1fdf8e9890d094af3439184f1db052bc22711d83e8cf9097a4817dee08019e268c6b44127f4f439b5a851509664e3b579372483d6e819153e98e559797eb58d3451da72134ca35444879eec8c0ff85043d09a36abbf50fd1123d862a8a5d89aace53d4df4c52dce729797071add792fe5ca2ae9265341949bfb5c162ed709fbd7c4f2ae8a73b2ed5b663bbd0adffa1f3f081c5252c30fe3c77f5b3e14c43ecb8520561c69acdc6e4863541eb0d30ceaf646a86dcadbc5216432a24960b73b7d71541ef12135c5af7b765e6ffc0f702176cfc998077be86c1b7b597a66c8d316daa3b0a02d09cccab6c34793de9aecfc8b9121133e3e12c8988d98b9124540cb99c7ccc1b91122833fab82754ec0d9969ec955653465fe6bd54841f6610a4d73d1d146e5717f7859a650590bf6f6b8b745a3d2bf750fadb7599c9d43c13a51e9b18ea677774da1d3210ccd5902828840696df99297bc03cd3c630c4fd8735d19dd8dbd4ec271300e47e10a712ccc8e81df820fb63322a33581129612c450568df49300a46a1122520e0f70d695eda8a741d90b423cb9b53eab36443fadb8ef6cadf9fba7a03b8843824be1c43cc7c7f7fa281ad1d92b4ec93ec614c38c153c3430a24da10547dfe6aafa5920d19d76018f159148be3ada1748272095d221346b4844dc929987b0cac90d1b0a61a49459d3412ca817f6a3521823a03115340d405c474476fbe03574df719ad4ad4cea9126305114d996ab5c5bf6c7e7a541477a82215875ecab736eb47581f4064b2aac49af3be5b273ecb94c2a1d7d23222159e9688a80c8ce170f59e977d65027ff1caeaa67a2892bc40034ab8d8fe3880f16df100dc39dd80c79460f876c160e18334d3e6f62dfef988a630b73fdc0d4dd8235d07767adb5ae63cc83321c0b46765c1f863ba8bfbf9d78cea7a94802cc1dffad0a899dd3e3bf782880673c7992d792d07b48d092f3cabb9d26ebafc3f45cdba936aaf2f5b8e004744ffcf236abdb9c2a9265bd094da667870f83a9d23c895fec84bd022786fcb1972008cd62ea06484e01699d2c24f79f34ce38c8674ba1f710d113fb07c92ba228c7c9d19e6d740cce459532ac8af5c4476c64342cabcb3a9db05519cbcc458862e82f9ca8d665032b6975736331e396d9e9353381f133d10b8c51011571a0a91b5b1012f308df4f8075f3dcc852c67dcf54640bd61f59f2a506ba99dde901ca703f7bc270d85e5615223bc0dbaa919086370fc53fa7fd5e657709547d8ccc28fab09e941e7744c5ec9d22843a8c660781976e2697cb15d15d6bbfbb580c4aa4d2233650480eccafe857a39df8e9c2a496fa83caefe2ffc44932d03e5fa7446cf6e198ba872c0e619855657fc7ce6dd6ef7b58ad19a8c1c7e6bd42222abd05952bc9a5c83cde9fb267a5b559dfdfc8c1f93bb6b5066f8b2b7dc257721cf822d071ef96c96e40a6f1d64b493b3e25bd87b7e00cb6b0595c44a7a331872dbfb70bee66c038784128e22aaf3a01b17214bc0499ba11d270a87e7dd02e8bc47c76a44f59d6da7608e534aa43844236970d099919b940e90c67ca42f0d632931dfedaeca49d4480d47d81d065a44bb9ab93aa795fda9b1466c8a06033b7b4a003318cf4f2b3cd168ca3c93c73ae025fc7a6a39ada84250c08f83b31600b70fcf5d765e1a2330ae004e36296b5cfff6528007e7d2d29b784ca17861a86d4c64da0ba7e7378eef4db9e1752528b2b3a04b1e9701ab6c815621d073ed51b956ef5c223bd6c59162405e6c4936ddcd7243acf3118fad6489b90c6f9bc2e006df6e003ac22c0d7c4671c2f8d4ada4487896a94532108825aa7485a311a85fec95f82ffe05c0022bd2fdc739e8f3a7bb50b55f25c239f4905c151335c4755f8d996a27ca56fc8d9b90a3a61627c0133e3bedc5721c57da9d87e57ee5151bb6a4b8d8d30d8fcc8012703a00fdc1a1039c0b7fc4674f4edd0317374d35480a0ae21bea18645377fb0ecc5c7afecb8dcb3ddf570f6b5dc63cad247df235bd0265e3bfb6d763844495b4f7e3d8c4cb87e381c742b2550e3a5c5b45dafb0e0b5f6e05e94b8947e7c99ba31e8b79eba2c641e04d521299e5bba3c1466745eb7a963782d4dd02911db7133ab96645381a1f0ed144aa67097fbffbbf2edb7c6ad5ad175a8ef3fc9626763c93205e2106918a3997a970144b9f4c72e731b3f46379b7dd1acb066203231fe6e4bc3d202270865f0ce1748455009b7b93efae25ee6476e023c4d9c7a599fa24a01815f164c5b773302c45378c321576af10ef6b73d5793f355b828f1fbc1aba7b337a2d3d8319533dc40e376691a53a40a3f9700b437889c887b7acb17e07f7277388f39b797198c1fb841735b71c88c0486a0cd1d83043d9e229dc36a5f18da1d7b0a3ea48bb1308d56fc9f857deae1757ae73cafccb719c8e9d24c74b41012da5469a163b9bef3997b1483612569932b53978f81ef7d9e8a2a1d153a5eb3f32475bfd4012b3151240723526ac27bf1c943f186ca0916d74f70a1652f15575af8e25e43c79a127031ba866d7364164eef07eeaa7412d8d0810232bf6022d8010b03e2dbec75e3c015cf7ff7e81457cdd81cd1b6a20289aa447950586fd49b1261731ccebc87929b6f848b3337b22e0ab88d7107ba5f6739182f3d8f25ec509729a8db32de16fecdeded0ec611e0e682d0fff5992803def051c9e4977ace97f54a82a6c59d955effaf5eabac2c4fd0e7921241faf631ab66cc4b7b3baf607d7341f57ec3611eaf205cf3737410c76017fce313273c887c2871355ecca79579131eefc6778068e1e5109a06a21f2ee4136d7b2654b510192a3866de7c53e1e8496a34747e19c9efe720d83af2974edf7a7e4eed199dc7493e1ec066e755f412d4be7f5fd03abd235d93db0a170ce5153dc8f65912c18a420657aed43641ba35202b7ae6ae0c6794ef32de9c915f2dfb86a1fc9976f91090dc5dfb74ef36af389386ae0d11d0d4cb4b4ce7375beb46b0d286fe26f211405d0f9949de314e84c2b18b2db12bd340fdbeb170782198a0ec26ce83b12a10ffda7deea31d5fc52c974a314365c2c75da4b9d21bc7e0ba4b40ab33c7da6afffa6ce4f52c1ba3f91156f43ca15ed6d20b51be72d9c4db0c39b940a273486cd0c2da487cb06b03719257b9c7f7ea7cf2b895b34f4ee5099030171fd40f677870b99ff4492b9a9245a1e9ca75c1a01e8a9139386eb4ccc6b151fb3827b678d7cf5bfe54b4f9aa434f1afd55a4ab27a82d44afaa1f5c54d9dfa2a0e503b15934471687363c329d09b0405d066b9faa578f9ecb35b6c4f33b043538a1e70d60072bf917ab71c2ba7575ee1bd2714e96b9059d8b14aa7d7875338a80b516c9811d5a6e23ff883b00586bddcee69147adfae91c3a9edd9b2a5472f37f685aae8e956768bba3ef7cf8ff9f25d6d912d804fa74b00827a43141fd702a0f47242b3939ebbaaef864a5c77e1db0fad3603b3be3c7804c557aaa7a1fce954a4cafce53f065dcd963371df4033e0b162099035710b84509defd8721f8deda22e8ccbdb3e9ba352f79339c2d42a2206c824fba83536b3c8768ff97ea7c86dc6a93d278013d13ce50ff8e9dcc6f5344ef27912ce8ba7c198e402a7fc8af9ce4cd99a46461edcc1e4b0235c4a67334a96d1b227a17b494353f5fc1a7c5a048d2e5a19290511ef41d01076d7f510038f3285cc9e9539be920248f7e5fc6917fa9d6b174541e6f62b7ba9ebeec6d39be8449babcf4659319891e3529c514165c56d5747ab4e0229797d527df11be01e489cb8f8b102394100b72ab315b74f5405f66c5dd98339347f468e462bb21f957b5f69c101dc0b31a633ac7bec88ebd01a47fc1e9a0ab5e1738a322f4b528ffd7a42fc958447c1ed70b5ab6c6c2e6eb473fb6f7348d836c5add6b148e686f47f74dc091dae09dd6b0c6e7aad739a32cf5ffe6a9b660d9b6c7f6d0bdb2d7b817b730fd7802bf41ad521d6f04337fc01cd4c9ffaf6e24c3893bbfc06679453d84767c47a12fa8df09589841d7c68e0cf6aa7c994295e7a83ef0ce3f82daf2403d490eedf3feb7715bfe992dd5b48f18e7eb3159c5c34778d830fbf66d0d53d5626dc18a889b75afe7aa98c243b85c494640da69fbde8006766df1b64dafee55015610f7e957bee0bda97a204234f58feb3aa9d12c978f3f5dbd33d36fb91803e02f06b9210c949ac5d4648a18972a249e78f05377498eaf412e9ac7294ed375e9ec70e63dbe0a7bb459d82be8952ef45d1f6fd3d6e9fcb2a99764825c50d020cd86939bc25b0d5e07906d6e5e21b82891bdc13a3fdf206fcc839c629aa9f9ed277ca4b7ecf0d25c303030a650cb6134ce7b64af0bfb2982f8234a8f32a9e175c6db52c05a3d772f39e17d6f3656e59ef72a50da2cbb787a5dc364b69a45ecd6bbd72a344a0714025af8b16e7b086844d6f2d4db91d63425c5c97f2e2dcd055180bd1873f2eb42a6522a610cd81fee0ae0ab5f816981bbf5889e121724b00f2aa07b58b394f32f2e187d72ef79d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
