<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1714148510846e62931e80dd6ecdc6d5eba41745e9698fb758c13ad3a4bf22e52dc9f18b48511c9e47b969aa4ef319d41d866b7ef4b0f9fdc70ed9c9cb69a3f06eee47186c6d2846afbabd4345c951c90dbc6277ceb12894f3a773c1152a727871c0ca5dd0c8ff5351b6afc6e05b6c2a2d3f2417b3566e1b922569e779840593d6141dee75ec2ccb9b37d41c5d69df17f03dceee42acf7af4085701f9f71f99db9c0f349c97810d649c96e420c8fa9141ce150fc2fa2971935f98bfc36dc8064caf2150cc298e25b0e337615d22c4e084d7c0edb4e89971df2dbebf12326c043c65b52dbe34f4ffcdffa62f3dc37f52f9da6e5731545db63ce8851247ea46d2a4446150b3e135d98c4589d0235871b7e82563a4dfc300e0560e371132e3e5afb64c49f9fda4ae4232ab1fd7a77e69540e5e708ec927231064ae95e6ed5d919fe7f8229e80f51bf2d5dc8b67a1cc2cd7e16dea2eabe1807ebdab58b5561dd253240b0d56d9797e0354d81b4ba6239af4b8a3d4d17f37117509c0ac92125e1e32556793338674b57cdd660e61f24f21b786b404fc999ff0f8a1dbd85a7bd8b2b265350a547f1a79d2529f33ce2f9bf9c56c4e05933a1006179a76c85c66cb444107ea4e6f047a362e3f6cba7e05d9c44b73e849637367fa5a2c0f9f5754171a0d28ad365b980d997e6da3574ab229723a72d7fff33f47a6decd87e932d96b8d29a029cf937d32068398528e273cf454907cd3e5176fa2552d1f6af63f5113809aafa5ad30b6820c1508b8193f7c19543bc4bc86aae0b99b817455e4779f81fa6790102b9ec83a03de7196fb113b56ef00327b5b45cd91832ea6655190fd733251b2843bcb957469d5adf6a5e8f2758b0c326f93125dfec782aacfe1e7f289677f0fe804a57eed1e2b9996de85db759791c64707f5baf543683da10f2145e547efdaa5fdbcaae204b1bb4126190945ab0c453cfff33abaab79df2c08dd98921def6fe0e34931d303e75b2acd16c1513fb34196a59884f5b8c898a976308e88086f9704827a19535078c2bc1b08d0801f6e6fba6b9ac0f028ee4a4b9399ce3935ae6b25f2b9cda802e2a465ec42f1fd8372fab6be5d78145826e73899eec7679cd15bc7c75071a2c2f7e2717ccc6f1680b2cd0423df68bf57691193fc9bd65ce060b98728ff88772c9bd96c1101877120a275b88c50e2fad9705f7f9444d181a0394a8b26325d4e31f3ac2b41f4265db806cbc01880ffba00d1150807f7921fd9a8fda0c6714cbe6f861374020c1c8ec9f0fd74241d9bb773ae9b75c8583d854a4c86b7ebadc61455f8174e403f7a87a66e29c7af75f3e0943f64acf74d4a3544b3d912eb8735e8f3ad5ba576e893e38901cc585211a879727b4413b647a6c3b554c8b2a7ca44e166e24ac34caba7b69713861db47a28fdb8fcfc21f12795dc46846cf93243b59d5e67bd9e068f661b596af15e6d069d51b7947f7e8ac811790fd02e99f34bddc83f5b1ad936ac24ae1206011d88788bf2e10881390c49b8c235c6e7ad020abffbf7b3a65673a49f7a8f874f1671600bbab230864ea1f57bba501c3c954f0c721e555df9dfd2ee6ef9a9777c2367cc15bb783e52c3eaa9386e5f2e1cdee7028a533b02a16a3cffb10318b0cdb4ef223b8d584004c95e0029f289adb785153b6e19da52fb2cd7db176b8f5dfd2b226112372d0bf878614574c00c746ade3edf95525818f06d00e85b674440869b5f96210068fcda5285fbf678ea615604543f3a16f99ae0c4f32f3027bee651c28e985f35241a0b63a4e81ebce151b6101a5ccf1bd9eac713d4779132ea2e0d164dede3a2415a153fcf8a912e51d8ef141cf035e9142e8246c103d0a3353a6b651bca5f0c0a4c4901d0a9e77d63553c570f2cc41de37158893ef7b5fbf2bb114900433eefe7321aa3e670f28f7c1096769c14f73c671ac300ef812907e83b18eb72b66bdc887488a511f775902a4abe360af58e46bcf8b31e2122a3acd541b16bc8f630d63b93095f57eb0bdf3a60f67d38448ab95115031c8fb4b132aa18bed1e593eaaf97b826c114e8ff9603501598ebdf9478d586411394d4a04327f44ca6ee23bf796c1ff627a9791d846a8daed9c1702c98eb23318358c5e4e3c1a1af8da44d37ffec978e916b2eb30a3fba7e57332fb3e089b2f46639e8c2d4cad05394bb4567af7643fa7ba85466aa0d913ddebede1c55fae9a57141888b4d3be0505412fdfa6ed3e3de20a334c9f8549627c4e61f7ef1a182e2b2c6c51ec3dcb5968e0db8cad51e182bd096409125853db6851470db920760bbda47493fc18e537078196784ae2b0185f57522eb96eade08fd250ada875ac2f5203bcc4bb24642101c222b670141c610bf6b372d4da48dc917d9014eedfe9b5a8936d3235997c208a49544958e65910b2aaccbfcabae8ee7602fb5cade852cf6edf2f43c6c1513f505eec173f34c99a3e1033f6fe47f8e72d1d278cb1602e06fccc116ccd71a1d40c919bc003593b193a6b8f143572c8b85f5bdecb12da87d78fbdc883992a072fecc967092fb7c27b200cefbe58c5af5a38816c08b06e0bda59c2e718fdf23c5ef0dbf1831e02d72cc6b76c8e7568b5b91db14a60ac745ea2435dffa8fc7bd97296855a5cd0da9ec8e26c9d5455e0313de9984a8e78357e5e3251834856123b2e62246712bd2ba6018ac7613fc842ddd8327f3605c2d6246a8f63d2f9ca5e7354e5b99a46ebe9e322e533f66d952a9ff9ac86ab8d5a1b889176c29fd841021a1d833a7d5618f3eac3a3a928378223cb7df54a442bbda3a281bdbc60a19f858491d65b39d2e55af96ec5bbd4301dae7855131a8d70f287580dde617a0340e670ea69978e7b332bc31e2b2e01447b54c200bbd9595de3cbb864b8f1ac1f5c509396a95b886d15a84124b7968f23f957ec19158fc006ff30a1256e8a0252212350958d98094629cc39cd0c8087a33f2fa377193ac2101da51e0bc1f83bb43235a2334a6ebc0c939e45086639a6edb13953050d5fd6bbf9370409372a0f427b6918fa280f98912b7574bcbe826465f179b338582f4d377ff7e4a381983f8797e1e43b2ae4a934c67e8cdbac2056111e89a6f4d09b565830212801884fa5d85037c61ebe29ef610b9c80964d138a902c389b96415aa87fc660979ba39f7349e12ff210b67ea9050251fa96a8f8472254d63b78594a62799a0b8f50e7d4ee97eee2c6f30b2a67c9fcebd3c2833d8aaebbc6420c2aa71ae42edd3435c8805dc0d628305783b995b209644b52619d1cb0867fdf6c9adf05e93ee4bef81e866f8fcaed255ef366f002d880c7effc47f5c5f2cbba6118d5fe4f459cd8a08cc29af6d2eb8166686dfc28a6ecb78343328e551ff2030fc2dcc880d2b1f03c54b86d4201f1fdd90589f6b6a9a2d61be72d3db962648fc1aae6591833c0795c2001213f2a168d18b3b2a03f803d6cf4ae8525f2a9b6a147287547faf3bbfe89de3c930bfacb4e09fd6c1279c4cf7fe964bc94d1a024a433099f421c3e367a98012c553eec23cdb8ae5efedfc789f1bfe2e92c8e60047a8fc8e29ac6060a68371f7af50e2806b8e2bd80d1c490ed788ccc056dcde471119eec66925a8bf0eac47c09bebc5b8e7354c3c531f6bc88608425970670783e9f9532dd9f0ac26f61343d291eeda62a3d92eddad1601ce1a3b4244d2b99e66c184c0b78e667950ec0b7a50c36da0c7b3dd24012ee7cf1536098c6923635fceaa2f2d8ddcc3463cf0b3d33d0496fdf9bb6a8073cd2fa46d388d102c86a336936215de7ea495cecdc1d899ab1003faccbc804a4ec184d7efc3f73480877eee86f00cba556f5b23bec8e928c41c2067429822bb18dd5a8ebcc916e09de3de79ba54d67cf574ed5bf50ff70def1354feb747d840eaaa379f94e3f147925e1d5f41b30e37aad53a42b6b1b392b8f6fdad9320cb1a5a87005d4861c1ba9a9075ec73807d7bba5cd94df7c3c78b33d758c6b94515588fc8fa45c1552e642018e8591b0cc9ec081a29f6a8530d1e7e3b3d7f3ebe4b22e85430088112b277a131ffbc3fb46426b4cc7dd6c1a2b1d8205981f47dca4fd26300f78020b89e73f63a5624997151c87014dfa7352f20006d1ca2e76842abacccca63f3f677cbc3758716dda5262fbd79f1ce0dfddf7adc1b53c165b0c46889e46c224aca3f31e041f9b1c420dc825b9728352cefcfc3b1181d1c62b036f45c15bdaaf711df2a6970a3d8e07d78c9132565e9120b3fef3ce363ce55f872d9e45c6a05f2b4e2524e1b33b575be3c6950ea68aa8a9de5ca061950adc3c08b73ccfa7f8a67716d152f3129c0a80208ad15c2a1b962f3e04ef1b4b17f806699e400c88907a6dec7a5c1c5fb1081e0b6a9f0d2b0f39d1fa189c7d61939eba6e1ba4c65036d50dfa4b6486498f71342478591654232a4969da2f1e51500b00245cfa81174e768e6bce9fb5716d7185a2579a48d1d8b816013c616ae6f1c6d0fc4fb88c093a56fc8aad0ce74e94479421b983e9fe022bf413e6d970649201f6e2ce606840ea160fb4afbacd825e4cb6bffa9eb62021853e5c5c1417057c96e5613ee422245a06f006c9139a0108c7a56aee6f3925d7d7d9f0ce1001e1b6dc148973b98f087796701c61a51983f8ac3ea9edcb126dfb409309c330660b3b171410a5860e93a1ecde156b56d014e2a3805294a3f344162c11e032d80e5c71ea04900c83f6859aa5e6d4fa747c74a5fa506a9a74e8261287d56fe67124bd15b595737c05443ffc23159e3ba2757e1b652dc82f644922267b9e66b16594e4f52781e574ac420a49dd787e663256a7cdae4c637a882cb4aa03b759e290fec4535e1552ce38a69cbaecc1af88776e0411d2c4e82e3d899dd7979b6800c90e9844483601a1e4ab8907c5117ad446aedabddb3cfe3d2ec8ef12be36859e23a39c031e455c6e5f4c63fd405579cbec7f2c88beefc83654361f4d4a1ddba42dd78a1e989dc1a7995663863a909fc541e39e6a40222d13d31bb5a31bb53f3ef22ac7f43af49cec983f06d6423436c4cb995bfb2ac5c7c309aaefcf57a921743594ef34abedaa021fd1fc89d9f7f8f552e3f668aafa5feb3a1d4b71562bbe08de15c03003ba36fb7995822a0d72f48da9cf81a53a377b409d715c3c4d84526cf5ec9a8bdf095b5489770b36208f474cc009696a1c73b9f4a4eb3619b7db602c4cbcef5a6300a112e95720af29543bb2e21037d5e5c72124b9c14a0be90b8fe676206f1e5fc1ec043b15f277d649ed646a1b183d9a33928edf6f1772e756abcb2c46b1a262b2fb8ebe1161dd363817b49fb483912b496f8a51b67ee34b6fe97dab1ef3d52a5d3da0e1b5ef382b29d800374c3894083e6f6147839755f56451eebf6160a8ea56449299499fb5d479813989be77fbf8a27c796ee9eadb2ae4fa357102f54f802450c7fb76551b0dad3119265325cd20a833aa7d35892d81a44c33c72ebaef11a167348ba8ffdceca04827b7455fd9bc95bd2c51e4f219e8057f289f355640ce67953d856bb13f04612ba48ffb65c13ff69028d51574e3c315d788b6fae21ba3d551dec95be562a6132b3f567acc92ce13ccb01f489d1b09b3ef65f895c6f9f450fe5d6e8f7fe64194ebd8c5565b40ca50cda7e0c11eec590e15e94c86798ac008652bc71e34e35b8f9dacc0787ff8726a2ccfc3bbf2cd9a5a9c49aa253bb70a106e3ce855192942400e0dd3feb84659b399ca8609fef26a85a5f990e18516274c3c1202da11c9da8cac3a4b8d60042430f0edf5f754eeb73d701ff3511274f4e53073ef30fe0ee725658e757b93a106c3f6ddc86ea9527e036003a2f8a85b166db720f464890a9da7e3bf92f22aad40aab233d51aacebe39a2e1cf2fecfc890147cc74ea19aeda471506fb41c8761a459ebe526cc8b969596576f2a13817d2fb71e86ab755624f51f4a629975a49c212436dfb94821ddb7aee58a3c03b8564bd07611e88c5eef412b08207e494dda58d5e3a280a9711345a5339e1c3a924fce2f3d8b39774440a508b64c2144a309e4da59808944615f4fdbaaae382932e7e2895e5f06c72541e0d425093ce4328b8f061f2e8a16fb1fc1881f062cc2839f7973a37ec2c316e510ef60c0451c134af7df3da909c6064b15716fd75800a4cf23864ee0d21093c86ffd5e296be9d485946ba40f5f68e84108c7d99d777f7480742e4b6a78702557e37724ebffa448dff7385a39c00aa7c112907e847f8464d96e9794396f1c0aa8cb7d5cb79d23afb39f7deb9577d64982eea7ea9e41f46b165eb8402677a57788eb4d4ce88987b3dcb37ca066791e22048401dd09f711fed975fe6f3e28bef70af18e50d9391d34aff9ed8932cdcffdd48440ff4b50a3b097b762a843a46e91bec086fcb5db09a30e5cafac2f544bdd0a90811775dd4f14d78f4ad3b375406b58235fdcf114b670e907faaafd4860f87ef53cc0a0ec460f9c88dcb7400bb67c100663b15db2321625ae63c44a50af2c7ef9801253b4f9cc86d10478046d709f47181773cf42426949ec6d2d337038960cf29b986773bf3aaaac0dc3bda5adbfc540b2e20c38566f99e28fe7a4bada0ae6a4ced01ff02f6f28231ffffdf4c965179323329563e0b7bea5a3f03f8aad57257bf4ac817989a0c25bdd2939c46334deeb1707942b7f11eb4c1d3087f8d41844bf25b766a667625171b4fa9501f2653ae64943ef3bed70be8cf4b21b02a39488f53fdb28129dbf5c9aed26e0c66a8b11e441abb463971e2e9c98e51f353b78d037ec0e16ce267b67bdcd10ff1f34c9901ef64a9cbac1315ec34ca9089aa41fc47ddb760f08a11d6d8643c63cbb1cc317fffe341816f0ac2f5a014b4bb675abce93c01fec995d88918c52f33c36f5dc248e41507b1765d9cb1d72ecfba73c2040ac17a6ac28267e8b916462e67ea6ba9e0588e46c7e86f07f0c3cb99da5f48f3f327123b17e3051705a5742af78948d1eca0a553bf86f686352d2149bcc320d735a2985a0ce82b1d17b48a870912cec35dc5c770ef76f92856ddb641cdda63db79e2f9779eed51dbf643e3781644ede79a8dfbc2042ee05c908da0bdcc388a926b84c2a4e218f74f08b33997a514bc5f68cb0f985410b044aeb9fb0a114bb88f62c66c1dfe7c490a73bc4b7ebfc92d3ec85ea65066406c417bea16b2441b709dcf0ee35dfa9899c2310c5c5fb4203bd277b74bc2b943c40f5b727ca135e798f26885c9756acf5b4d03ffe91ca2e0d838fc0fab176c83c2be1c4a669c46556b179f12d2cfa8aebb3b64ab27a097328fd60061021c2874a48e7b387430964008e1fe2d537fe2926f0e439b602235019a883b36da8acc9a394e2dcc1923573c9e683b64ae7a304c1fde5dc5fb957c07aeddbcd3f785b0cb62715a31c5639e745d2c9b030f1a102a87654143ead3c24e7c49786e31c930b3971a88d83831c7043e3c6c3125b5c80b9db4af40cd63679ce010f5a81cc28d91631495ef2576f56d216c1b4b29d6d2979d73f4513f1add50efb2f58a67d5b29568d0a95e0cfc8645086f22c0c619a5d0be6a62ad22da6ba680d7feaaae8398f5eae368c19cda87e70f2d03a2729d5e3a5619e93545e4a64a368ff8f1f163191097e9c56d6e2a6a774e8a0fd9d84f2604f30612a62bf7d5516f22cebf1ad2f6350cd459d71e3f785a5df58bd996e8da0ed750232d80b2bb51676531702b4eeadb2c803f69e0edb98aa40fc6f482bb207d08ebac4b17a62f48022f7d1f47ebcc078e2a54b5149b968b4bc07086612522f2bbf32c6378f302b9c5ec6bb1deb4b319788a1eb06ca9b3b36a79183cc3a435276253097489c9c03a5e43a7badc71b3dde2f6bf68d6715a1562ff874f5657e183133a07cab52bf16593ad63b891b83399fece29ed377f6a782d2187f7d9bbafc286fcdf51fb7a74e38033f336d2d43fdc42fafcc201347837717f2448d9b421a28676d9051dcb9d45cea2e37daeb0a5de6acc147ecfe85d3cfa51d3be931291c30178678540eb36397f40afb8224a7d2ac71646ba9dc11cc92208cf8fe460c43667be01c4f4fe4d54aa090c5eb7da57e20b2a8ca94114b6f0390fa1f174955dc3702441bc88e5a0bda0b3e0d9965545f7d45969858b6cf96a6a8f3c44e97484a95de71e15b6da966b13a084cf7dde72f92901a4d64ad388a3c0e1f1e4eecc19a8da4108943f4055d194e45a27af979aea1f7642ea81de3e1d7f927ae0a9cdd8d2f320932fe44416d516738c18f30c3fd6d9dd69e828356575a8596bc8111b206f13efac2d0ee6ed84d3a08c279c5e662117d7a6accf8ea0be8d8771b563ab4591060fe47d2d5a850910507803cfeddf2e1529abd2becd5fd8aba05472d33f399297a97d56b8bd4345758b5c762be47f34a612f86fd74896380127684ec16111a53f38e4af13f2a3f3e54e8fc2f1ccf3af266ce1e732c7b2097becb33b25b9c46bdb828f0dfa36ac6bfae407d615e8ad29ab532e2b44a0995f628923be44d915620f9f2d201cd88fd6690cfeb592d8187fdcfb4fde5da246fedb0f53bc502d9ec1dc88d65da268e104051028361237b4f2d36e054c00d7788f60d9e9b97a404c8bb8021e6bf409e4b96b8307e986812d599ec05923360cf513f04d1fe81bf6b9152d820b08a3966db5016cbf171906993c6ad2cf5ed1a715f4f1af574c8f6753ce510a0ed65ff1d36828a8721400fe3968d7345329860522c7b9a0d06b32217e59c7c2e510f5056853f892f166c79ae2e860c0893cf31ed887247251ccc34ea3c9326ec5cfb7fb6aacb660198e4cf04a6c580a46db6169fab0a0d243feb5dfc3500b7a385337969aed21ecb936a53d4a850edeee975114dcf08060a06ed3690e78a9a08602fddc8407cf9fe36d71992559597192bcce75e7d1c3b589aaaa4ecf6bde3f745f39de3dabf40b126a87d66a889c0aa9d1a5af605f9fdc6dbc023944a8185075e670ca7f75b8e9510548c389947b6b46cac778d1940b8d80a907baf14817cba5fd8668e4adbcfc14aed3e8acb36df631724c1b0e76e9bfac36e6ee8b0c9ef5a0638fe5834928a83b5e42e7ae268fb01c47f17ed696d59b8e3c6b1ff785b72d5397874a7fbb3eec3c3239e3b3f81ecea3264045eba844d1b7d4c8588cb5e555534391e767c99f0db4027542cae23700f094d6b7aa372a80f8f3e3a6eb02e5d613e44a116d79387a1e92b4c5556464fe4178fa758d47675c5d99b82cfd2730bde16a0be601289165c0ba43b4695f6e0f048692b0394dfdc281ae5941579e382a0bc192e54db9b4856cec94713e6bf9f35784f9f1b4d21c2cd2477b136525d3c6d331fc1976e2a1b3d3bca2affc04e91d0fd92eacc860d5fcc339724d2477d5fa3914fc3e54da0ef0225a3ba9c32b5644ec262e7a358296f0de37daa34835528a1196cab3c00d337ac43dd201b7a9352ce1ca4ff7ef6bfc92194b202950cfa78f51f486640a64a4ae0fc9e5e0a0cc8a30cdf2926a35506e275b3cd9f6c057bbfc342806ef076b2c28b102f7c81b317b5ba55348f4f6866560ef5d09fb81be31cea2e5c2c71ffd6faf71e6c843fe7e687323ee5acb0c5eda06feb45d980ec3011b92d84530f3696f471517826d78ece3e96183f3117349ec3147a91a7e17099878cf79ff21b4996701e509b58fa04ee5caa191815793c08481ee249d066b82f4cdb02bdcad33e2b7a83de917825e36b430405d9facf2963ded3290d8b9ba907ae37e293692ef51bb30f5a5f4b0bcc03a6726ecedc49d31b9ffdff032ad027e9f51225621ee4309f407018d49f47ce8188d5817c1432beb0e7ca7c4a568f2968955d56030f41443ac5d2bcca181626e147b51f040055181b3732bca5a286e98f87127114b5f973f4f5163b7f7026f3ff8e444cd6dca345b12fc113c043968338ee03e01f281095275837faf85503d87e2e8e7636b5a02e368eb2c9c289b30cd9e698f9794397f130544ff06e4f0c9b91319a75ad0291bfedd2f37bc2c9580ce788c91b859c26c52349bd53b2afa65486767b79500c256cc77998c1c21f94a8009dfefb257190ed6ee8e6dd4f9affd8efbb90368e5b55e4e63821fe63835dae4a671cfb421f870910d8f0d23766bedeb8023d225a92de7315ba521e47e31210b18f6f20e1284fbee3967bf5c8bca6e1742391969ad067328c718d8b451afed4d3dbebb5e89b60dd786b1987c7752da5b450cea581639238fe74f0ec476293e059df5c5c7785b73e5e99f907f3949fb76f4bc763c2681aafbafb4b9f077a359128afb66102e67708b971d031dbeb060ecc410df189736d3cc961d835178c7d82520836b342682e46ada1fb6dfa874b45e83da5977c6156cba3fb0ee2057726fe9986bd58fcb8d51904afb4da7b1966b7d72f5ee0ce302fbd06aa95902627939eb9f2ff3c24f0da753eb99b989e67a9d945a0c3de58fc603d36c34fc1ac0b296bf496ebf67f2148e3c313c08a47570e6dd8b9b78666afd262245ce00b1668cfb4e6ecf48f4c1ecae42995afa78147791f7b75ba688688494a1c39a036c2e5d1f804c9c33071af010a11293258721e7fecdebc4eab623a5b48e42f2c5258166414f9bf279ca8b980bd37a311cefc9c9fe7d77b8b4ff62913cf418e9f8011f044472c077f2e38f56fd3ff3723b337ab464dba03ebc2b224900531dfd70723edf6b47837aa2d5c9139737dbcd048e49b3e2026ec82d8d3befb2bd2e2122c61b616d14089f644db286712977d8eef85cb618324aaa7800825279856e3d45fb7a66b45b0e5b444a7c98f47918422055336ede34066e41091fe8bae8740e7692ba44d4040ee842a3958dd134e4a548d4a2b8f22d67ba5ff5974a19d24ce2aea5b47d5d7fef7b25e43ecf622a65db0c31ff7137dfd39adafca1b25f803b1bbd12800664950943b2c35f25d9e4f69a7598a3b464cd4caa448f580976c828e731f3dda0a33b67c487e2e35f9a1b3c7cba1f439dbbfd566fe3eaea0d96854806bd86503909e05b8ac00bf00e2eb926568f57421374587eb098024259089dcde09f5625ac8742afa112d5056bb795c5524fca3024a2f049aaaf97b98a069d3c87cae5c81905b828be4665513205f63e69ac97cf91d2eebad7c45f602edc0f96bebfa3c024b90bcec5eb1489f7c6482de3c37acc5d623fee72b1e3294fe84a61b420367c5c408f61ff1d7d9afa20a3702a94cdd6d195a56fdfd8e90cd756af94654eb34a202d30e6acda30d3cb33cf90596b122e284ee935bf3487491bf2890159dea4c46f2b3c2d22253e0ef359e13756f5586b00ed0657256ef85c630268687f0bf808e303dddc45032ad29451c9177bb02a341be01b2b048e84fd044606b190c23317220ae01913b37735e8e2cb3bd15e6f4fb53c242be1354471ee32cf04c8c3e293ed846f55940cc4f1e740276ccbb644d21ac08d47fa4fe03104f2da198747be9d9952f42dcb5c82524eb74d455955ffe2aafba20598f138b2baaf7d4265f0dac7c17f5f3422fce465905c23da8981c84a0e603933a0fbb10c30ee57aace70c50b7af03f7cf7743617352f26f13b4f5cdd116aebfea868cead9eb88fc478c24a1d9597073cdec3988403b9886c4e6ece9cd2d0e4e690daf37c039d624e1030dfa3f686b61dee54719ea21b1fd0ab231c1e5e74300b7592c4ea0e003702ed17d6d52e5850a6d8e70d036e93dd3eec27f1812188e23744d2aa588d94eb0dd763039029390719a328dd641bf9efe068cfac2f40e99dec9ee56bfd930927f487820fd3c5ce0d7792e7cce3d1e115cd1909d5af4d972a460e5deb4d4e3598b7e8703163a08d484e1d15b83179ccabe089ec72dfd4ef8bfb21052b51435e2bb8afa472fced5f4456e65ef5bf26006804d73039ff373a6c31b0eedd13dd048ed1f474758f27b136887dbf957f9d089cfd811deababeeb5d3cd82f71e0819d0d31e97a5820e357cd4fba0af56879e7eef47d6bdf0d48498376f63c76288823c2c642a4a4c3e740bc4b15117e610ef2d521fba0f7cd4055ed9d67169b611ad399a6e1c8b2a0b46663bdba1ea62f96a6497a5fb80178b552363c0c3b2e12373c0b6e77799303e1d8d8f7dafe16b650b8389bd80f0629d9b6e1324884915cf2f10a54536c4a85d4d968270f646ffa953bdf72f29d6f7a61cc3ffe6ec79518fcdff82bf51c0f8d012e3c2bd0978a1fa06f3da3c8d5122132b086fde13bdf86bcffa3fa7335922b9596b3b6dc7dbeaa860a15e953d7de18e609d4aead9ae341c0ed3795b911850c50273eb068ef9eb7fdb7c9668aab3e9513f8d714848994d381d27134957434cfcdbb65516e36059bc5a4f751b3dee82608302de6c89aed76cb070e24a1324a7de1f2ccbf288a88ebf13fb2e5991a8609127b5433f6775d36f8d2ac5b06ebf6c5894ad7500f84aea6fd26c4f23da093e7ae08543f7ffa3b204edc0b42a3df2b8b84bff6560746c2058b62a25ac16d60737876320edd70130fdf0abb1041d4d8515406f24432c80c09381f1bf89e3cf405fa7b63d3af37abc2cbc22949a117dc39062f7bd89edd3e329fe572bbe2cae8dfcced0258fc12ee14b1374e1d66e8b016797164a49167e4680dfeb9eaff482dc071f5bfded51cd2b8326e33204f44c3fb0aa85f155ba8cb85513595dfddd08f53101f3624020b14dda4706fa0a90bc2087a06f926bd9d3536e7ddd794215c9f467bfff24deb0e3e6c682f23675626595635442fe86b5a7e474b83cba3c901024871bf0e063631ef152a012434e4cbe4eefcd7f4d10d23fb250d3d2fcbddc4e6583870829e098101c7ab1d65a14552f8825a102a2a671247d404a073a76fd22a5e2a1d466c99c8b2107cee5f832cd14d6fee6e04ab7574f7aaaa7ef5a44b3da1ebb954d67dfbcdac0756f2b825bcf71c680789c46966d6b755a6ef748c714a8ccb3b0495a8ee1dd402e9fe22deaee8f251b65f3cc20d6fda5ae7bfdf32a216a572be401f8675e807c70a6d7c050cdf27c2ae8e98a515acb94e40624d16a1858f58c6477030777a7ea7f8476a648f511237deb271a6a3bbf82a5f98a6c01c304980c610f62f8bc33273a6d58cbf0d8609134ba4cb0b8cbab77edc7b94a674e2a61338bc6da329bfc1df708192fbe0e9929da4674dfdb3bf454bdd175594715228697ec212c8d3d2b2c39cdf6801bfb34d06a67c4fc4e131e12ff695f5ff99c2ff88b7efd4678b3ba2f86c3f3f521773aaa40d880105a0f79125c50ad692a64f3d115304fb7c8611516f4a44e1967c1379ac429998160ededeace01074e189bb9e683814b6c078aec8b50ffc4ccc18708e27474e46978ecc01945dff1b945b5eef7fc04dde4fa6b4c7d2a1604347e9832df4e8525dc0e04c52adedaa2c1d2edf9371d7f7730da81f652f7b594535aae44f041d762d1adc8f0e172c7d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
