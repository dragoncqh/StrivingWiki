<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58e8177c2a24b57c65a37ced19fd7819a73462b2aa40974c239084307667a64011b9d9ea1c4e8ca899855d33b1a429ba5c87c2758b76a21baef78b9d6c9bdd56f17192888b2cbb6eb32bee0e2cc6da579135b075943bca3aeb675528caaf9a1ed50d897526dbf5a527fb701c5f1d9cc0aa90c1726b5b23d2efd3d5f87181116024d8557b5f348b99b7f8239992809ac675847688d1ad6bfa8d14559642eab8ecfcdf389f18e7702e429d766db1f71fc06a55e2c5627a03895b67a4918c480688a4b22867f517a314fba2dff18f750bad9bad8858944af2df774c09e484e57a44db04d24791e4c0449b96a64de6c55365c3297af40b5dfb1a9ca1733b8e03cc8ddf9dc383ce52d25e3d5a2fc870d61e498b78cb73fe6530df717a06252494364e161a42f2be60a8fa72bf085b4a4c20368130dee1ec7fffa6b59bd6dee9f452a463845b918ab348d4f4ab97832df90cd853d2058e1ebd756b95b0bcfc94f301b9a18979467e43377ddd26fe4f17334f7a63abd1576b61117ecbe0d57c8e0a82d9b85aeaed5025d13ae3d9a359e0a0ac1fb073c6edbc677bff608a2018069a44898f325c9f1343e3071efbd9a604978c9273e4fcb95ae27d6855590cea757a6453f1ab2c9906709620b68534bb3707d199be1b419fb5c1599dbf4a66b4339d62d97eef294673893266450df09587f3d9c06c497a18626e574cc12dfdf53078a914776566414ea34b1311ea4b5c6067e6e486875e67c87c5adb31ea4538d62d6cfde969d75a9d5b8df2706c016842346c575085aa01e8a66a15062a14c99cf4526242ff892d423f906f06932a04dce02b59755ce95b80d2441ffbef7d15d0a90e669e7a436ae2ab2a9f63c3c4717d0f1cd0f6c53928d669589ea8ecc2f914a98bbd74c86d2b15ae54e2bff93b24542494c6e17a097fcc6e4827662cdfb24d188ab7f866e1313346a88bd7c548b9d09524ec446c4cfe343a731b590110deccb7b0165d443a79e94f0ba9e40386f02508c9f1e5753403e748dd535f860b74567d3ce0e5c16058a0895eda06e026b493dc73b355df72371b5e4377bafaa97c2ce9172528c35487be9777cc4a046ae5c12c90edc0ccfd5ddcd4aa0992ac3022e2ab813fd0c7a8f54d3f7c869f950d070983860981fd72ded825c44534760461cc13f2ef641e37f975c522adfb6cf867d7751aee298ef13d0250c36df374a5a618e79613978b4ffacdd944cb03742be885fa10d817f72c6bfe3924d603bc7f784a0043c9c68a585fa07bf0b614ae4f2e159e58e316ee7114cf35249de426b1568b56a0bc60dd74b5dc6e42ea9e0923dfbfc95ef141ad6bcb5ef4c3b7b045cbf90647d47e57dcfe3080fb2ae1d3832bb53b385558f1300f334b19dbb03374a3f02e2da0bb773ee9a9e7da6cb908ff03a3933ddaedd5f641ac8459914f1aa1f8250ef232536695bc925b959ff0be5ad4ecec89defb441b27f8070053b7b425de1b0da2c3f1aa0ce4bb0029f8d2da751660f5d2c479dc7d87c52293e16ec6248d5f3f40361f7ee5042e24adc44e823f913773a84e427177bdcd45ce56e119f4b80190a450bcf841016a7d13a0bbe131a72f80366b4ddbb9288b2f65698afff082808ba6f520aa99b12175d3c81cedf08c1402db53bbeb3213cb94340aa8f7fc81ffbb202104b8ab4d010475a1c64d15fe8adf0cc30c2185dd315b0c8d20e307033374c026bba594b1255e65a3c42a56a667f47dafcb5b8393af64238d73f4a242f78ffdf3e6cec07217bf3942c81823defd05ec782fa76adcc23245031f92db3848e3978e70ec8f189c5b6b989737e4279fe07e91edbdc1f386722fbb883baedcc3804d1376bd76f3c691feeac49f847b088d4b8cf8c6b7a7796fa28790fa7e444f0f623e4096b0c3ee19e232970cf9c3fb1ee49e04eadeb4badac1e801d1d8e80751493489e053680de8c2b7ef7835357f434ddf4706d563a4c2ae52c05296497aae9696f00105988d31b2069fd1b98deca49a3ef1da31614230941fcf18c2552a6eb5c98846f100a19b3c640a604c2908c5fcc07da5b77611f1989553cabbc6d84d5661f65766d9fc9679a306bff6aeee8816a88f1190d1d9d18cfcea35e99eb178bc4cd5fc227323199f5c1e933bc2cf25e8208f7978af6f283a194f55e16e4074d173eaad28ba36e6000697196e7f1d93918a5ece09a727a8eac7b7a9a50181f9f26fbfd11854d9bfbf82452f65a9a5ceb3ccf6a588ea8200736d1d4edfa1669c2c266c5d6720e41c8d48db752791d5fe1e42053963f0a7e247e4a9d0aa0c93b811162651d031e6e3cb4bd260456a60a8fe3e81e913230e43a0507febace17b3a28c4a1e0fdafce8f7a1ebf6ea545ac26c07404b17b5b10f997d31503f7cb68da6813428b1fd0995e837c808f9b13073730a20a20c8100cb1598121feff9ea6a18a3efab0554a1ada3fd14005e105553ce9bfe5f526c44f48dd5155c347e2c22ae58e9b8db088c04190ac9c022cc5db521493c5df232dd7e29b978e06925e85cddfc85a3c95e7ff88b6bd004685b213c3bff5c1ad386ef439823303b461a9b0a7a97fb946028555d1493c8446bbe4d3a1e358b0330a70da5183e1538af31ff77c9594880fe44a41bca763712da2ec08a6bf23b4a875c06a72c218d43802db805b814c40d5d1958b240fdb345af497d86152011d197d6145a995825639aca6727e0f9585a2a58f1dff14d2f9d5b92c2b4b28c8cda1a7b3e0d69190587ec959399a6bfca2c9f4f63ea9d1251a686260f39e581f41355d1dd9063da62addd038201b68d8f0c6a66848aea1dd9e9bdfe41edcc61df9220bac95aab93130543e964456c75b5576699bf15757bc8f12a54f12d8cff5783e9c97f6e5b393a55dcb373c71a0cde17e48f0f0f1f1df5b92d6f4788abb80ffa10a69c7064add9067a44fd01bd6c356f71b62ad94af84451c8334c95a6c9df9345d9ad498e551033a1507607fecaabe736c8827e74f68b4c5c7588cc87835678453cee1e5fab68d174ad114eb51b21bfdbcdbb48a282776567accf842300531c7f85b2644568054f151fc1a3b8dacbfa355b7a8d7f18851b9937eb111e20c7d99fd992056498da2b15c65da829b7cb7e137923cefcea779afc1c539dc0300f0bb3336231ef09c8e2745372ba171d81810f934e9cafb917d078c36f6bb5fa623334bfbd35831dd741c6ce39826a00099c1a84ac36cd726b9d78aa01074b3b805f1e2cf138a258a3bc3d89c33c10e84edd8ff66461b2f3a3dcf10a22c7f21d59b28ca9c2778df99d6379726052028e07685d31f987d8c65a7259146bc3ce8dad5a5eddf4de1ac43d9a268e381ddf9b4d971597ccb2dc57e1becd05478e218495f74d7ecb4462490dfe629376a31a341d77e868ba761092015ace8a028e8a11cbcf02b50c9e4648504c90a8b8f2bfc122633fd3cdf15703f6c8e077de14ccd9d0833cb3b856b5a8de2fa248cfb51dab08100e87640bb4c49f70e9b7629bf3feaea44a02845f60deb4fe155e2ce9a605709005846ce22acbb02742dc8c4cf85b22e87739f0a0b8eb25e2fac6cafdc795c4bfc2f52219c5e9697d765c658209b98775739e06237aac57ced75ba6ae772a005f561b6701b079ff691fa3dd4bec58eb0c5a3f251eb424826fe127e60eacad37d55b668b29c9e8ba32da6597b696e44448e209fb1fc4e051215f941e108ae1ca6208e5abe908440d4e3f3727be9e438f4767de5a2da6c4d348dbc60e9c2bfcd19067c6a20bcbe93f97ed07a6403d205a7d10d28de58c61404ea100397a7c03ad918673ae1370110b550da823dac9b07c5ca24a2dbb1c60925a1aacc8ade8f0d9e4069cc60cf5acc3b7e60189a3bab856b3ea3560c819b6ca8b053adecef741cee142f5f4bcc1550eb3244feeeab4ec2df0649bdecd07f4ce371516acbccb3907d8ebd60361a8041a14f5c665bf40241d242b1da9c7e0607b4e810480ef541ea218eb8b798f10f7ef682022d85a9e6137fa61b13c01ec9f9facf282d3a0515640bc834cafc25bc7b41962a1efa9476af46f5cbdff621edbca4b2079d6594f0579f6dc2220cc745db7d3083c590ea8eb5b16568505dec9f8ff29e5f9e7e2cbbc879aedf4c8097a2f302fccea50a65167f45cd585457af021211b62835ef4604562632daaaf289920843221cd16014db5fc6ca50a202cc2ffa96099a9017e258acc02a0b44c00d4e19c66fdaceb8cb77e4102640e21ba8e14b6b2148209b4e4e56b161ad4b2aabd584a5fdd3623abf069d3ea4e6fb46d0f85f61f1c15f9514331171ce985dc88efd0ba1acbe2bfc3ef6aee7a4b87241a010e8947c78ec4a4fe114e16498da3512f912e2d0db5ae7be7209de194345bb20965aec89ec77103de7eb6e8ed2923974559fa413e2d2b360a3fb56f60eab7fc1a91d092e4bb17b92a2af36ba0f431bed52097a73f5c44a77503fb625b061b16880cc74b626fc1aa170990773de96e79d776f4431d695560c984ec92acf4e4dc68c612d8ae64a2ba2853e5a091ba20c347e3572b14673293ba08aca18a24c47a9feca462ed370d618ab22465a96eb3cf5a3c000ddbc64b1316acb92b004bea7a7a00bf509273d28cf4bc3532276a7db6ad5019ed6e9a78f4631a53cd350e2e8cee20bb248c1c78e9d46fac772e58d42b08291a794a15ba2350b69833901a9ebc7c3f684d8597bc2431300c9c1cb0d377b6a7da96192c5bf52da756f67d46ace4a32feadfbd176b11233dc1e54022f0399d32b6b1b645953212bacbe35b59c037d9591ffa8984f4f3204737181befe28df02c9f70a9e76d2392d49398ab11301312e419d01a1855d1059674f84bb6e1230c3f23055cbae3fa9a59f8f6c03c8f234289ae95cc02e70a787ef7899a5c28682d27ebaa32c352ecabce320435c36dd7841109a9e361d4bc4f5d1aea351ecdd4d574dd589903fbb1a9dea6a18c9d544233fb63018e0ba9df35e2d256b0d27ed0db817c5d11cd23415fe9810de139f40337a1dc5c7f8061f5b6140c123178d30a2ca5d69476e2cf2ac2e14f332d6abb52b9e385d26667c0e5442b96c40aeef042b1ef6009f51cd90284351e72a97aa0a40afed42696c2494f2501730cfcc704a02bd68d3e8375467995f7631f2182495584b4908b9520d58375255e8207dd8c970f3deabfb2593f67a6981094cabf25ec375c7c11dade9fbeb656e023a2e71781e49a62c5d1a14fe8e7724e51c583b23bb00eabc43e6ad0a4137b165b6edbe314c2e07ba2b54238687dd991318ea0acf4204c03c671629e10953ce665637df397261abcc4a26fab180fabb26d5430328523712421931f2c34b7095430563c78f4d61f421e640b41277b6d1fcda9eceb51954440e3d3686ba344fb87a6df9b05705c868fed8b6812ea8c3f4526cbb2832a54c557c123bd70a4c8b4c0a5fcd5de8af1c57383f13825ac834f908dc4aff59650233b930f730614f9e98ef3f2b22423fdbab962e615e894c220331e70058e469610242ffc4d4ae0bf38c335b55ca88c7df13d43aec84397974e822db56e61e655a4e9dcc21c7cf6a1b0589ad301962aa5b4806359e12ce88b123f8e258ca8d546497dedf4082fdc7195deea1d2419274c55e9832eb55071cffb54c92916f74f3481c95d6716544c2b104025ea02ef69a6ff7be4ae4eff4083ded5efd7c99d9df2d377d24f3aff856be24a910b3271b4f5c4f50af7d99d1a13e39e5cf7e43f513508af043dd03e185124c7bde7fb31f1d1bfb463cd8b50a30f45fb2ac30f2ac3da73779cba3c51f04c7d25fe9572435332cba37c1682a931d18d157ea6f49b29e2749a37ceaaa997a0ed892fe5c8e267b9d9d4b542d5a1bb659058bee48d847dd62c04532675be5259a055703f2483ca3f14c9d925b17213ca21302f3c2ad97bb20e010e0f86590dd78c82b95f8c725fd0272a8d6dbcfa7a48c44c2cb6bad7f681ffedfa6b877168dd557affbe792c8ac3c178327ba3b9504f175d0feed9ed5c225865dd5d91e3eb045972fff718530f6625021a0061db38c7b6cbe34af6f46dc4501510c818f837fcf6cc914660ee06c87c84683d9f59531f7873659547ec6e42386641e39f41da773d40e7ad07f44cf97ef2a1dd1cdfab5a056d15068355660199cea000d4296275109ab0a0e8f8eaa4e06c2967bb33af5d4b2f72ee17ea5fb3bf57af3436358b3903dba5f84eb123ecdb8e505ed89f015395c0a5894621e8ad2e5993a1e636de0857a8b142335249ad8277babfad995e68cb2964e08af7b6c31d320d41039cc5c1c8811782aee0163eea552ec8f6e44b8b8ddcaa473b3228ef0d1f2c83df407becef6313c3c4965e199921f5e8c9b2484d38fe3a8768999255a43a2417d2b3386fd88c7c19b2ed4e25079eb4dc67e0c5a88b17b0d274ea60d7b6e3bbd6c2bc70a5698464d49df610ace15c8a2c024713b18827ca9eb5d6e23b2b45320a91066a17c89a88fa6818d2dbc94da6ccfc6095a28065c9944f12aff2dba996f4a65562e8401bbb4ab5e9049b58e9cecf8f5881e8181000c4ee953d912caf2f3f2ce1b6afc97e78a0569b003681112140338dfc62afae13a0fa6459bfb45ecbb1dabc4c8e1ea0ab437853aa6c9b698033ffa7a830f1c22681d59ac208c0668903c5b5f441b864c67ff8b7d6f1ff8ffa9808b89fe0e786682058e5b104f7b600dc8c63d984cc5cc6bed1f6643d287e6d6aacbb619e06b902b0d4d6f2f2d96f47f773c0104e52eda6d3a9ffa9bb9b9183f90ae32048a87d4bdc7fe0d731bb47ba49b713efe507e04693ac91d27b8d417d5e382b1b9873e721e9f61b0d9cfdc8203fb73b910b198f51b24d6275f96b49eb67579c823442f9e2959c1d7c686f1af3d54ea1ed12072a1d98483da7f494f5bd47bdd41c0c64de1b2760308694dd8a4e51984d3162accebc6a29a8b9779ef0aedc05509b2fdedda92dcaefe8d70dcab51684a28c0cb4a8e19f3d10d0c4cb280b003665ac17d41d91cc49b3eb40b8580e87a191e693faef222109e6a76d220c89eec81a6d5e8924d9aab2609157ebc0fceaaff04a36f4a1f121a7911a8bcec133473de260583ab8abb311873d9aa90cde60627aa14b2620ec0622f669a25a06ec81e9d3de5c8afa5e2589963e1bf3ac8ceae58d5816b92df2a6b49f0cab3ae3c60140d8efd4a8ee0e89cf6457d5057a8d92f7e5b15979923cad74047b2375fde363cca2ca805425ac71462473fe75961fb62748140de63886937f669aae9450dedf37acaf04a1171419dcc072a1cf532e224ef05ff78896a117e61452d0637d683875c34f9f2b46394d0dcaba876ef073737dd73bbd2ae04c7d9241bdd4c76dc092e76cfbe9b82806ce73ccf8b0ae8a3a5ebf95111bf0e5fe01c8d38e801a2da979991cef54313c2addc83bb2f57bd42217ff341c7e0eafc66dbf73729b144b9ec2b577fa089c5c7557fb97202fdaf6f95d41679865b00c1d3e21d3ff9880aea96a0ce531bb7c53592b08db8eeccee121de4a49f74a595e48321cbd9de226739d37cbaf94a6187050cdfb48ea8cbc188076b02d2013ba3352cfb16cb19b85d7619f3fcb0d64181814d0cad9758515342db280bc9cc3168994d8f7768a48a0d279aa6338f811ac76acf6b6fef9023e89d8427c002a5e0345f12eb669159f4166783af9da11a7c891ddcfb1f06040a82e635d38824c1819146f279ba9851365561f93591ab6ba7247e8c6d2125b7c2578970a26441619ddec0e0f5e1293c989f5e9507d098d54fc46024f30fd1d4f65f060b5982a4f4c12d3c4d60152eae69ee5216100118f349d6d050a2084cdf72e9c769f2b7b48ca281298cb38eea4d9d6d2594e9cfdbe069dc78d95c0f239b2fb7dc31d52d15b8526c5fc45ecc7b9bbdc3515081dcd3271f1b22d66ab875ccce5ac58a97eda908fb08b217985ca4ee57851cf942973dc58783baf601adfc7662d3972b57193e406f6aee2bf7fca00cbcb9e7242e5062a9b54c7308742b3c6614934bcd7ff2b25eddd58beb1e626ed31fb152c15b67a4905b14d2667904c4f7a862dd6c23d170ade131ac0f0fec4cbe4a0d77c3312e4e786849da8a9a986bcf7db2d222c0017f92e8da2737e23695fd88b9e97b450b28eec8b2ef60782700091b093af8f3aebd74fff84cf0b90baec9f8a70f9ccb191e86701791ad7b13e856c7dd0a08a66b7fb30d4da3a191c19a304fb654af46c14208d7ddcf9a58d8e5bb780605e68a9861da1216eb5922af87eb2dadf198a6b091a67ef55047f44db18b5f417dd78b713a94654ce9e3ffdcef85da8183b0909ec7327489899f5951932b650b478dda5ca8e71ffdcec2df4521446a93a6919a395e9a42082249102c05ee547cc2cfc696daa6402916f1a2af08b8e4d5e0fef327d65c428043b646406522c21e161d01b74652d2803b0d99439521f513bb5f6be593c9a24e60b8b361265e30e1ce60e64e06eabb853fb22e88e947e82f02f4db57a885a0c5d3bed56b9298aab9903fd1a223ffb9477800f70f744cf8c75048ac909a8c6a0d41ff70f1a8f2856ee0ce3072d7d6ca621710f8230246bda9f01298f34d848d5a8fa48d3dd75c60360bc0804438e318f0330c56e1061b6c5bc78b488934e06cde964e3d0dd33940ad432cd4f8a82ccac11c057c0fe34970b219aada7c2496a2675ebfcb75823cd4af7bbe0caac629783b583aa81ab7b09b43210683532ca52fba8575cc3fd9db721f66c82e7d30973b5e6b3e8740239af2fc915763984d4ed3d633096ff8b9f7c8786b9eeb723c1129271dfd9ab8ecf7a601a45ba9186c2f0fc7b3bb1093fa81ddd55c4f8d425dbba487a246266766f17a6eab3cf5e942eec77452fd8b491eaf3dc93a8e0f71a9fddcd8c96aeaa25a586e8cdc9b42b1e78cd29430e57e7884c949f9621b376ed69ceaa02c6f4d212ed1b71c37f60524e5b91a8d521224a8c5ffe25273ccc56767184c6a815219c6ce3189f9dcbcede73be5c56766017659d88545c4cce4f8f582ad3b5104272a8b5305ef773e511937d03713bcd42b371eb13221f678997ba9a6b3b119e2ff6c49abff049c5fc83a9e7db57988ee24cb582f2c38a34e203370cee8d11ad43de8574a2552fcde197684881aa9f78e857886de41d9b391c0ca70c8609c2405db17d1ed77c993a4dcd4ae9f2baafc266df7ebf49d8bdc22e420481a79ea8033db91f4e1c78fb1934df8fd4524efd847ec829f8e3dd4e6183b50194abffcf0ac5b4e7d06c2ee9a9431ff3d92df9688ed8d6ac46e04857b1affa6c162f7749cf808475b326d8198be63a38576b7ebe4c03678dad033feaf074684bfa00e57d90a748b6e57983f32c25495e99ccb7c7d629d4da63526af53f6889f9183d9579d9fddb25c8c4e6b39785df05a4101e4969cb1b480ac4a0e26b50e9b7171afe90ebcf4efb614a618de8e0c39cd35336cce5870ad60e828e384843b2986244a980e847c5e2fc567c56e79042006d598c78774978ee18797290891fe036445869c16a64933816d59bac71a97909167019b4eb677e46001732c55a0f57fd00755cb06457e3c625cb2ddd280eaec6cbdadb576b2940d7c3c7d36c3d846d79ecb87dd05dc2ea39c6633b1d7b6af5e695f4f66d5331c3df7f952b31e0b82149b479b359ce81721e132048a532a4b55d74d2b6ed3723f11b7ae001a44c7ba7102e8beb2f75cb4480b8060973090481672a9a1bd9367bb5b06ed98c6b8fee4bfece32fbc7c9a6f283993cef6c35558da4a52cf7891e07828930671f38a85db50665f567ae4fa0503f0c56ce4bbd0cd55afa0b7caeeaaf17611bc6de4ee72820aaac361d840f779e24567eb7ab9724ed9a12893c7766fefcfa96b73eb9d0978543110ebc39b32be6533a623539c56b2dc0540f03acde641a7375a485762d256b117ce87a5c4fab9ed7a6c7ab98c0f7191c9b84d05aa8f1f65aa44a039bf65b71c869507910676f82def51ef3fc79009c02ae25c5e3e0dc89e767d3616c45a0a9e63e0b83f8543c3cc731db613f9eda3a64e5094fe0a41c13e2b30b8fe435207780e6b1b8772cc27a329c1ab21ab08e860bc41de18da60c1cb322a7ef86c154dca0483c1286d01735a3d9c727926d0626a301919e2d61182bb5a4ebea3f35c62cf6bd982a2efc7914f74f8937d264dc3e8760429b6c45f0fa5bb579ce8da684ed39f373338b6ffbbbb33f7f4401409ee3e2968c5641953b41546838ff4b8abcf4f34bf42fbcc7ca1433ea5377e495a348b844580b33551dda628b4f8159c80eb34250d0e5323b53cee8bb37fcf48c0ff03c95f0f7f9e66b9f2f9421d39d225a5ff1212af10440de43a55469838eccd265fd0be0a8509686073969e0e962be79e1d0131d8c0e7a0e27557a88edeb6bfc5a31dad696411570e3d9df55912cff39457303da05b1e09","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
