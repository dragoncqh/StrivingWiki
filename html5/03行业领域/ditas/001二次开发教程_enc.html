<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b956f073a666ce2080e330a2b05933a995aab5077dd0eabbae4b797aac692fe12d850be29a405553ac7f322d1c36c2ad9e72515fe23a4d1491638f893d29583b64c3d7547914c393f84064d2933dab0eec03ceb7c72b20613c7accd80caefe8019fee1efd4643a08c6e92d4bb1b917af17c70b6db99247eb1f0d771a4c6ce347b864bb0b1a383fcab494c042be839300a41788a43ff8142cfd661bcaceb6f46948fe2d3e91d945904932652d2d114954b76f59604e6e5050eeb5e7c830d79006f19355aa6afc66d94b8c1d4ee462a5619a3a164fe5e82877192c851d3e47950e2994cce88f496cab0a1339f789f8226f0aabe441ac01db6d64d930f19bad6798511846a31a23025e38ffdedc55185525011b891ea37fb68d51efafb403359a270ce0fa82b2de850c271aea66cc203937821650d4f25c6257e9bb0feda92d747d6a74552ada99bf19e77f673460aee6fb8a8636e4c78971e17a5a29ad10a4d9c77b4edb896bcd88e1014549018717152d24129928cfe568697831e6873f4fa85f8495c95e443773a5ede64739c09bd6c39dc9120a468af36b0130182611991b647a49a1c51f0f9d446f7bf1be78ee941ef4a6d336ef85747b6bb26d707b3034bec5314263d8dcce54354696d86aee6bf193e7bf0c697053a45948b3f5e15f3e75605e83aaa12817a37f34898fe18f72b1765aeb9912f9b4610cd92da65389efb481d9c5092d3ff597d83dd436235740d131205daca12c4a58f377502c6256123c2b4663b1a9ab024d183f0335f67aa7fbb05b169e847e0fb315a30e4034acecd2eade8a9674345aa420d024dbb621eca9c2a0a74ee84edfe3c91fdffd28a9570f556fbc74e18e01d24c78987d9163bf2f5d48ecedd28ecc46bfd4fc1c63c0b06fed741f65164b0ab132d2ec0b96fba5f23233e8d55588ca87e6e8695b65f1fa7cab59330a2975ee8f001c0b96d6625623e62ad2152ed17c72f6485a7338595b21bd88784ce92cbb2bbc4059313c4e4b8bf20a50ab74509c820e4723720b84e757701a49ff3345f1667bb717102617ebc195377e979a385529ba419e8f25ff604751e3a9b037f1dc1f2c2a99d2bbaf2e274e71ffb359a04e45c006a6c94eb1ff0d3a36ea7acc0dea3806127eda483f28c4f4b15c4f75853b6eb4ce6961f3293a86d5be3177325de22a686091e1af86cb050402da069985ab638f2a140cc0dcdf5b202ac0c081d01b612a184390880a13a07bf65205f06ab4d8f234cea120bbc229d4f1520330495575bf08ab6edb98ef4fbfd6e49e1f79651b2af17e729383ee28dd4789428429b57836bf230dc3c747a1c953ed779c3ae87333cfbe8d5ddb3842f3a4fb2f47b95393012f518aa10d61dc24e8cb004db5f70d6a621654f441d9f698fcc009a43e85dd974045bc21700759aaa8c2dffbb1e230903fd7b72b4b0b50c9d77cde8fb5b0f68d49324bfd3b792f93dada2709d5ac85b5e50384d8fdfd70d79cc48235438a21517413c872eb8ab808b14be2e413a9544e25f7679657a382eae8f1686e726f13fd85e0544fec0e5317651eb90adcd30a7201e8aecd41c844f6cf691fef9f971ec6397019eff152fd8525a23b00faadad485f61b6245cc67182649a2016d3988141c2e6e7e08f90c02d5db511b5fa84ac84c685191e5b06808d8499633ccda99b9634fff9d4c5f1ea3b136ce28afcf330568870039ffbb07e0db17c74e6ef76c2d3d7bcde7d7bacaf83890b21eccec6a9b48733590c8f325cbe9bd3c7b08c571d9f263aff418618934ef630d5c5e2002b0708f07d1446cff496cd2f46089aee58fb23c8543c9e10b792af3ecd2cda698d78256be56773935a982a2312573efe0a4d7e125780c00394d9755701e2097865a1174c288723cd1c851cad564b32c33f121fe4013680dfaeaed44371006fc98df4d72d3f7238f7c8975898717bca45b664374584fba51cc4dc88b013a9875caca047e7fc83273e91e95b5426a754b0d734c57ea5de570f80fb671f560adbbc6ffb6ce1ca0bc44f2f42f271604e7252ff108898ab6455fd29f66e1f8f8146d5991b607c52dd4f10cd7f038e4f39e1a1ec12a7c076a8aabf742517e6dae3bff902cf09a04512be216317bb1ba372d19b0e42738b85fc8782b85c18908e44cab5b3093fd99d828313c6f43ab06246f5b1553c47e7d6df327ab892d379ad1841989b17b7821eaf412e20bd262972654730a4e95bad55da591ecb6b42d604b5f24262ea272b98b1dc2503bb9cb02855909b3186fdabeccd0108ab0daef8e1453942f3b4fb05fb361c43b47706f5b27878148097ee769771dd2d93179fb1a70895a24a744830c5a8c7b327deada3843dd80de740888edc23d532b9319c4f3de448018d0b52b2227cacaefe7ff33a26374ec2845267d0c19d6c3bc53eb0d04a25e693670b98fbb71d1cdcfcf0ef81bc2a3039698a6b2b6dce118241d7be80ba55b43fa1d4bccfc2cdbe3e5a4a9a49237bbc59c9b40c726d68857f1ed40d18c1470d9e503f9c7e9732dac7c389bc4f84be92d2e57006c9ea436613f0bbe6b41371f98b6021d3a10865e54125c0d4be1b98dd25e9d937a044da53f8001852958b5f43957d94eb62c525b0a15d6d6090f3660d20f3a6ad8a6599ccf779ce14fc618a7ab204c9658b9ad45cbcd16cd8dd915aecfdf7ee9a3040fae74d89e3eb43cffdf73e9f9201cbd6fae78ea3d5cd9bdec8134b99a32942a8f02b8820c59b86cc4b11074ba69c0c782c3e38caba973405afab9a4c1658b443df12483c0aa37fd86fac6b72daa81de80f24752d041f3b78ad6f1adce7118bb73a35ef6e5265daacfca58c97cdc3dfb7f1aa51d0f7219aaaf967c86c899d48c48898a1692ed03bfbc192f4fc74449fb24c019d48db2a44658bc13c1042e1201c69bba913cd160c463b92ac02cbd4c1443a8deee4d30fb5436d12ed0e26e0e81cc4ebb70b54a726c824004fdfbf1ce01f060de5f011cc0fa71d0fab25e321a04efa09d04a952202281d24480c54731338ccc0cebd0d233adbef640380641b0efc4408ed81ed461d0771b91f16b7496500308513d71fdc2045a7f8d3f28b55ac680926bfdc49b2a4b024f8ac5e96b3e8b82b11d2ca14e6819489d4293e4a5103668080980c9ed77d8bfc4e2304be1f05697331168a7fedeb59855816c2addb09cd96833f496d82fc4095f9c73b9ce664407eff9dbbb5596228e2067721118ff937a64eee11ed9a550a807b794865c89e68e272289c4d323072751324f4c356113487010fca75ae27a901e83dcc1fb098c432eed99d91ae5358cfdae3abf65a55c7d1d816f4558ffc532bc71dc10b5d17763f3cde46dbba1c3f38a37b13bba1b692b24cbd30aff4020a0435b107772eca2c03a975b5aa5e287fce667265c968ec2fafdeb1183e760ae48da2b612924871a4818fb2374bb4e74acd56ba13234d560d82eecc19d48cb3d157e9afd4181321d045e7bd39fae96bac39803707f189ddbda13973cbd831a693904c0af63d9b3fb4461dd7b6a52d75911bf9cc164efbcc2238b40dd23d9de3583544523bf98ebbfcc81181a4abbc1b55245476e941fe4c45fea514bb36f82aaee3181dcaa7c203ec29de028dc5884b3d59ee83789eb8894efa391142bfa7136193d220621c560bf5365772cfccb941eff0ed552d20491629fcae815eebdf11c268a8ebc89749003bea3dba8c2e6574061576a32f4a325e7add606b021ea27aaec25ca1bf5634768d8f2f1140de603846950469bf7ae43cf52e37f13abfbac1cdfef42d28b24fee842437bcc47645746971e592f7e3af3d3f1a3ea361551260bcebd617489b31fe4bb6b89aa4ae822f218cba254a80e847361f9562f711812c98b70aa41b3fe93340ed2d2465974fd476dc201ea60b46f4b4d567da8b37f10612d7b6b33b3355fb0a9b6ac9eb2d9b9af0da4bd8955ca9f03620d0bf3f2d048316cb4747caf8a236da99515863f80896d25ef2bff2c656952856c5d565c2f8af147e534724aff689dbc9f318ea9b9b43250c7c47be94b34f93929bf89a36e91a5ff205d089f4a179c28e85fc750fddfc9452d353e96e73daecb9c4ad8b0fa1a99e8d0677062ae2fb8356a3a0ae5432010e2f26f887e1ec9c94c6a77b66b3ca81d9f77c5dbdeb98a814bad65ac76a2df2e990d9a7bf8fba18e9e70cc1f999811849f338e2c0eca92fcf64ec2acc2632454219f3b2c70b537e69d95c5506667708c505765ef0570dafa84acd047862de98373e3dc48d351f6f730a82038667111461be1c5056850b5d992a7f959e532ab367aecbb8d8c5175dc8772b86a96535b3aa26f47296c98eaf4e99d94f618c292716ce6b54f2bbb1cacfeb51ce8484ba8ea884cb4fb0d3973ce4c028509e1c13745fb0592ffec03970ede7b448c1d3cb78f878bfcfe868f7add48334fd1f0e1b066b504696fe9e40985885a988dab5e79f277b4793ac8226678d881995830c8ebcf544bcd1d0b5651e489143a2cb1ef1bbd6145b0a1ad6d730634babcd8348095f929a0486e571370e6db3b440ed7fe75d293d9b2469efdb3c584a2bc3dbeca580e3e3f375176557b7b824b1e6ef10ddc55dd102f5b421fbee2a30b5d0d4c8eb5525806528515b22ebff88c157899a82b1b40e6f301556e5062e46d9dbd50db29080718b3025671fee571b5de12227fafde9d77ef77520d85b0a9bdfd1d2ab5ec7b56e4d125a73ad0a5b1d46c3f880065757c39d4706346011fcd29fa85f197587d308df85c73dff066611503101b85e260658fe007b0bbcef60ba053963dda57337f5c897482a812947f4f946af7b51a15384bdc31fff2c1d51831d2397c38f37156e1ed15211e3a17d7cdd8fd3987ab5828e99d717608e1432d4ebaaa2fa1aba37a45793bf1ad5f1261bcdd98a1a511d459221475b43c27eae5d2aadd1d5fc8de24d375b15578e001bf08f16b42da4ed10f59fc0f9d5f19e55045cea9ff94121ecc7baf80094bf9b525aeb406fd1012c88c98b2003be1f9e558010e4b9eadf65f7690f102e2b0f1e2898391f8b1d2ba7eefbd158e01f561fd8be0597b3980e2c614c78d589595fc3509a86f82c43069c6d83b42fb07d7d3ead33e6d2d056809f0ec9fe32cd91e99aa096a7abadb3e2940e09a09937b114a237eccc1c25f1dc100d59e9446aa46531119b200a133065afca022827278f6dd505714d24920fdcdb1d27c57058c9587e10e1bb975883ff7f482ffc970b0e12914ee649c32ba5a9cce3e5c48989611959f1d8c7cddc2d36838b09346bb6bdc30a0b5e49ec94b2f6913e86d121a5b6c0690332d2fe8e851c97d0d8da1fa15956ea3695397a2f7c513854a2d1683b223b1974d726eff05921bb05e53ef9d00e215a19c743dca4c78485bd8fc4184f61b3aae3876c09d1b11f4d59794328a5bd70d5fb78616fa31c8e5d493b0b662c3635718d2b50b131be489876a2e7a9c25179200253780047f66de3f8aad94aaa40e0404e928f7f39f7326d0d098632e6d2d2083b2ba2bf051c9344624debf3804c53c456f3ef281d574d3fbfb02b2e880845b5422f7b4c514d209785b7e5f764c63f6734ec06b7054cfaefb6fa27c57ead654850cc9290ffb6a754855fa8048bae3c01ead9035807cc09c200e48ef833a3faad435d5b195e4fbae4d44b691c3666f79ec42c7688b527be20efa419bb17af4eafb8acc4a22a07479b47e548bfe12f8dd2699ffef740af3f1bb3dda8a7139e0fcc030b31f7429f50eab7835c0b05cc6472d0856e57a020ab11864a57ca16cf7c78f1de0187772ed9c804d78b761c2921485d07c9f891b117279800f9cc526354282469a959e06f7a24eccd71a9742b6fb02bdffc1e21624a512c0cb9c1d451138b9b0167d3578e190c0caec30f163b999d52fe9b6509002c25bef94066c70c349c8d1064f6fb245fa4396aef43d76fde4ebd08f5cd5f376d626adc363dda5d6c0157824d2df4eed4da132b22c3fd2b9e55c226899cf62c32b73b2fa00802f2bd96f81e53224470dec8cb85e15915c130af27da9f7795905539cab98d2fb04d30fd3306a3ab22de3ecb9cb36f3e0b6d8c8058a529149c95ba747344533a1749d8f55f3da5e94926433ad5d4376edc1e28218ce9c38ead681719fe8a2a3a2121d9ffeee3807c7da0e2f8e251e745417ec73a3d61bba25b03f453b0d754becbd16e0c564ce059d2a0a7b76dcc904a261005bf527f213bbb7dbfbdad5680174a0c24fdf663fb17ba5270c3b7b4682b2efe74019de2aa01eecb8959604610a5993ae0db0c03cec7e8dc9c3a65500cb29d419378a154f8a1cb8e7000e9da0cde620cf907330aae97918f50018d0ee6bcb80045801302f4621e26ba056500cafd6995cb0a3821a1de586dd885ac482c08b248127a0951b811f11c413c143148958a1469239a9720ed329ea66898c7f279037818423ac433be583517691d64439d60308cbdeb251e5cbf99ac41930017cbeb9aad224581e8655d60239a0fbc898755e58c46f1294633086679878dc502941f790b975956f848c64dd497aa4a84bc0a5800ded12fb71ef0a2557fd73cf6424a5f39acdb65a8cd0b8712db70e1b499cebb4fd20fa1ae2dfba4b0ddb96055dec7c3cec6a8395e0c5aa2eee99171c194cb690243362fc3b9133740b4d464bc65726dd8f0e62fcd6dff65461cd2e0a76962beedf2bfbd41fcd366565a6a8cb377ed2b46732e8818041401528fcf7ee3df93b7fefffc66bbacb8ccb5d1f2543aaf79bfbcea5663aa29c8446fa25f80c21ce0a1d0a62c42c820ddee884532de3b016826573d6c49691150590c469abd5bb6b5018bceabe1d339059a87efd7cb6a6da0291a1e903a8cb0661bdd13f9c66118b502badc803cce74c16a9a8607e2b766f0b26c4b19a46e1bbf28f0a3be48b6d7ccef866702df04ce26191e504a3a167457100ec67682c7fa50fb56acf0f75e00bd4e73146b5218fcba0e7d37e060b5879825c46fc0a2ce124c9ce6fc168e08e7b294c092cc62f296eefa5a46381b9652d3aa34c0d07687102c85d92fbd6279ac7d6fa8b6e9b2fee24d62ee842103fdbb0a610039e3f89f5747875acaf2a00ac9be466f05f607465231f979a4e6a620671c15dc23b2e2cd710c5ece539bf9f28a1f935e70dd7629b3ccb111ca90cf992dd0ad79cfb3953575969d414d929b6d9ec1d6a3e7a9feab37a86bcc7402e8c814bc2e118acdb88ee334ff03c99e93b24072c49a1773310ae60dc55f5c8f3af5f2c61609a1c843705a4906d9f21d83c0c0fc92d4d3caa2b1f9b8450106da2b52ca96e4a49637e8e4a9668bd960f55d86f367da3218debc73ca503d1d21eed717907df4f727a2b195dba9e9d4132a476e27a314ef617b4c96d40c2f02c1d53c05c81b0c4b2c6fe78d20d77c79867752efdf320dd1939242be5869db7c190d650bf2268d57a84ddcbd5647d317ece98a63dcfba4c1edfff9b748193a3220a4d30ad4da092dd6b5f5f09a9c6d1071664895e5633f22b620e18c5d49ffb51f91e4e4173460ad220f2d7f4b3ce72a85757866f3e1a153cbaf073e7d3bba599c5d23db99aee49eab8d6f4f2d589ff271056d2055198b71a4ef2aa73badb537e1693d859204cee2569faa84201849872fbf624e84f3b2d18884ddb3342d1ecb5627948f0737e11697fed1575012ce3dd27e13cda5167a3041b018e3de44a6eb459e1e63c6f7fe5e6b447ba68b0ed1f11b110bbb73a7be13cf7a42639e60ea588f8ff260d3fc0a58bc5138e23d4ef36903f5b20b6c14ecb8a608fee49f4b89b9bc419646f4ef612252664c073a85858b4937efafdaee045b6fc96d8525954abe76dc1e4c0727fb103576564b5da745de6c8bc4fb41263602ecb8951743b65774e7eea28f852022a3bb781e664d161f73976be07f349290db894297220e7dc61534a7b899da9be7d61fa3cf2b8657af242ee106f1841e77afb1f1fdcf53c7e76026dc8394b8e717f71a918d2adcca9a1a014b07f366f7e9c37488e534cf14375283f27b0b1ea1a5750b0eb5788fda4760dcf8bb333aedf65df26f9cfbd84a5d7d8f5f7c07f9e88c81f8c66e71e2b68b79cd2a2a4ca915de61330b16ece25e3f4a80a2561013ad038d17d7e9436e87b5da31b5d2f15a4a477a3765ba7b98e83d880cc9b0f0ee6f29f54bbc87172d709502ffc4e9dee3a82bd63439e9dcaf7ccd528ca59372b711ec7bd62cdfc3b8fe19445c58aefaebd4419752de1a2daac35616da7c98ff03ea47af71b0d72f1b70115a9307e02fd7f10ba1df20aa6915683e29c185a7edc377a50191f98528edd49d40011e275d2de6e2e9111c122ac7d9b9b50bfdb181b71051bd8561b45909fd5a423f7522fae86cf5999bec98c01bee5e60b24182ce2f015ac5f5c95f972418d1990cbbab515a7f79ad236f8941f55322b1fdfe4606806468c5d4793871a6bd241d72bd7b246e314c1c08a1cc4b1719fce5bad11be48fbc1c75073c73a2824ab4b7efdeb5c22164b56ded8e8da1e2626fb8103c1fd3cbdde54cb063584d3960e8360298d5dda57709ba4561fd06be2dd268a7c4c7053cee9d617e4db190343ef62b3d448e868696c412d55f0e5e9497799bfa1b835bbcb12e2b334b56b24aac6bd5452898655fd25b5cacf52494e934fc6a440ebbc957a20c86bbfa6c99b100f6efd0ff8fd15f847b924366d2cf6879112cc70737f249aa6724bfcd31ba6a6f139b24fff61ee6e7192b29c8a47a1c180d4631c74f59b3d2014a47bc9d0a3b4612e462090ae8314ce086d2585a2067e100e88c82ca0a15e0540c59a7becf765735184b134aa0586a88c914d97afd98f4b1708e3e2721986cf6acf3d3fc8a39fdb7ad0c1714172540389115f3aeaff62e67196cb44519ba4af9228a6b2309df67decbf3e8b567ff588f25de91c947389d6482a1c0fc350ef086cff85909d35683f4e274a3b041232ffcaf310003de6b937ce72aa7dbff333522ff1bd11e5ef23128a22e0ff2475520c30abe06489c71c5130d5596a383808c9d204e56c863bbabb5821f3106ff7b4b221b2b64d9d483609a34299ca62a6ed6bfa7776f4ccedc5aaa5e5bfa646aa0fbe7c14f35b27e29ed86c461ee720baf73e75fac58d66a62ada92eaa490c00676bcdc75796b2ca653d58422e8f50a8e0b13e45fbdc75019c6b748bd3583af9b73aeb69855efd9bea2dd04cb8193799fa284598efee2e0267b9e1c9b46096db4ac6999c4fb0c21d4ffa68109d2f12fb1fdec8a99f80056322390f8b406ee3375d99b31234665628efb866ec29c0cb26fd7f1dfb7ddf5e6d52dbfd693b62d4acf092f444f8868a549def74feaad8fec0e48e9a60344d775fe840f044bcdf72e843baeb20cf461db8af124df48a388e6e4e59894292c8d464773e419f3db37a6b1616a9c8ef92d914ab45fd5365296f340fa758a4240346fd378b228fb6c443df7933459bfc8e79af716ecd4b73bd93b97ed1f1f47820dfa66b06e1ca4574d5e87b1dd196cf42e8b57a22de58ef9aa757ae6229e1c4c30e349294f92a1ddf5dab4a1e1c9b22ee388478f9cbea76b0b58f76a39d065946207533188b74ef1c9934bacf234ff60089ccc0192066154a545edf7396ec0fcf49ad31b8e776f527ce60f679bbf12c228fd1679c1fa7db685fc9cf2894dcdaf59c54db47fdb87f3e4426ae8baf49f73496c468d5f0622994d7840f02a764797da6b17d2fc0ac8b658a914775c900fcab106875f38330afc6e0e97dd49fb1a7166a9a19248273b77caa9fbe1583f5d838e44a4aaeda10bbfbd8d0a5ea1c7c18cde06faec13f0ba329ea5c756041d454b572f015f31e4f0cd4ba90ace03ac495cc76ccb0bd71f7c6c7e713066052ed71f9d6383c28037bf12404234227b5460cc90db0c3a56eb6fc645b07f054e0a8e10abb68dbdb51e47fc3fcc2975f5d9b24c3c3dd9d3a7b500edd4326763b70d7e23f093a039901e6f39913e08ddc1a04b385246812de98c187651aa96ad2318fb238afbb86ea47a13397902a8bca83f9abc022fdc24f03f5f6d80c4eb044e640f9b0946a5382b2cfe4214808a278a19fb9988fea1ae8f5e7749f9b0c48a42be5b5c2181fff8ded203e6ff9acc665ead99c7ef28fccfd39f2cc70f154cc3b408101dfa151c2cd4155f4e42a19b0f9ad99969ae1e6ea375c9646e8bd0cb1c989a84f917ad27a38bf4d9c8bf9e571a19ce797639257a81a0b4f076263346c8d295ea0db801a958f5c519d890d37cbb844778d5847d4389d654269bbed177a5e2353db0221fb787b0d21b2942120544e412ec836c60c953baf360f2c86c0cd0d3ff8f18a588884c6517da747714c0b090138ad734b5616e02f0c328501207876fd794d5cf7514676bfd4a798cf762d2e95b0779bb3af5bf0375286a3a42d8100374eb57250983e3c405bd5c3aedb70f40bf556fa8a3595664e37cae6272eb608a04058c851f103053f2cbd7079c6de2060673cda20049409f6859458898773d28678e3347cf8c33a45c1485f6b640e51eafd8219f43edc0bebbc0e1b22c63a83e456c0d7840d13d3b748ee37494e8d8e8d2fc592765b019241954c2551b055a507deb001626bcd947aa9d543ae462561e75bcf5cef9fac2320edebfbeae9b38673175b1cc5a7443a53cd368736bbbf36f50c765cf8317827fbefdd00265111d22a12224d6282a0be8bdad1f9951d2e1571fc779afefb37af63a09c69df816d249fa6089c227fdf875c24f728172f4f9f864693c0eba411e673f521c51f14e7035ffd6b6f3c19df7cad17d4cb8d44075572d0bf9734703ab6ed1f02f00a21370ae463cc81d9bc658eadd1d7ef08293dbc2ecec5bd348ca18d5f41dc3d9c5beadb8b09f53460eaec6ca5f4ceb811a79fceb4b73d4356429925039abdc96fd223edb67ff641f3d3558dc22755dccf4ed5ec1980950aea9a4589e46d0fed8f7579ae0f288e4a1458b86452a4b1e1bfb0aaab4a2ea901b003ce4054aae9717c8e1d892b36e8964ede62d89e0662fb4477faf67a7ebac9a8df1aef2e29104063cc12bdc4c1e5d830fbe6c13ec24c7745788355ec8742e30c758c21ebf0927bb5b254dfead87a68d8b1bbf77ee8239e5e6cda756f8533c3eca6f4eb6c204405ba09f2492963dc9708d42fe3a1fbcf4ad595464b3a4e67f23113de6d9bf871eca8430501a98c83c02575a8f0b3774c2e5500b002f24ec4c25778c457a4e230a9ee2f045a9e704ed53c9e546086bae57a35b39a5cb5223ff5724e51315706bd93a9bc78c9399e27f18485a73475b1c47d07166fb9ff38595e6a44e80be46c5d2ca99fd966d6ee69ca1e2d0fdc051a86cd0cee387dbc99809a7e303c04a679a87728bbab3581c3cc1229aa5719bedf8d9785f2c98d04e13f9954058a1e23bb667411ade0009cbea8232fe961e6f79faf55c696659a04e1e677d0426ec2c49a4c5b0138e971dbde35599eda74985cfc5097d79be8d61c422e62f7403d30e6d4350c7d4d0459bb86b5634e982437cecacd3fcc7ea0da440c6f78c87672fe83d213138c43a1a619d4c8f1181e2a3a42e787fdc9ab3e716452eaf9be932a7648681b70a16bb37dbb3af39bf88b15eca53c8cfb2c1ff35c7fc8556609cd94acdc22183eded914a4b5e045eb09536fcae8df054b3357c66080bff227af53dd869b44d59cddbf234649ca36fb8ad938acbaa0b145383af0699e4c926b8c0f235d724896cd68254363733e876c8fcf83fc4b260ca3a6ef95a9005d042ad77efd704c1d7f21bd4e07d78ff2c41d87cebf7c5f0b6631c4a257888e15d2a65be5d7cb7c43d6f4a2dd5d5905df7109c580f095ad712f406af517a520724f7086dee2a7b0390efb4cf66d9adecd4ea7c3040ed13ad32253b97dc553ef440a1ffcc54cee0871f39a39cc96c9c9ec2e6342e432f66bb19d2f0a4438ef469a502b8e47f542ff1f6bca79fc7d51bd6e8e9cafa8480219e5ca2894f50003ad5602faf62c9c8bd9e54dd28d3d347751641e93ded088137a1ba06a4ed07c21cb071319efbf26aaf8e0365a735cb959873f845404022e050b9da2d4c365a65c51ae4aa83533e3bc459d9578f7a9bd2c8480bafbec779ad36e6e994297f09843cb6bcb7b4f51ceae2a338c08032dca0a31ab70cf21037ff262ef853486e8647255b2dce6c6c4dbede4be3f394a50cc215d698a28cd1e8710c1ed5ea99a0e8a9f2669888f9cb0c450d431cf328b433c09ffd06d594c35f58f1db0e75916b34265e97d5d80094e833a213aae2104cf3dce50f5ed9d76eb018a62450f636c99d61f1e7bbf1553263a764b2e65934a44d8e9e98f806dda6ef5f9951c1bc767acc9303d77aaca8be62dac9b421e82e5b901bbdf1b202033d8622256bb48450ff2525e9acbfa09356c10c9c5597cad28beff98957b6c38f72bfbead46fa8d9180c9d66f41152854f72ae7ca9d46cc35d9881895df6c38589a766e8e930859c0c568c71d277198531ad9295a6565e029602e9127b4ca1200191570a3bfd41dd1e24abf4fc3a066afb09c59430e9b957b8a78a7ee01fd93969300151ece8dab2f6f8e79b37252849c1af3a9bb4977249735d5f07ec07ff2f97efcffd87e615e162eac4614f12ab4eda48cdb81f2594cd0fd351f151c4535a557b2e02658e67dff1e7dc9377e5656110097442510d2f16cc90d1f7a75894dc515f2ae6c4f46366403d71acce5020948f4f418cc91c45c42e2057e422984621688a07957cab9ab52626b65ed875d8ceaa30759b522b7c2c25b8e84595f61ab9df3307c67bbfcbf39b540f50b0ef80b049984059fa37e73e502351da96c40380a017535057d641ead5fba1c1c90bd7cdfd9d547eed125a42f9730a527a5aa79d7255fbdffdfab6c2d0531e743bb2e247e594d2cd3b0f019ff600e5435698b29ced3d635a6687bfa696431b39b49b9f32cd40bbe7e7998d029f1e9efa8fb63a5ac23f7f3408da16a33bd0a4d3515c4c908a0745871acda4f9f8b8de4698428c484418d91ede42c26c0d610074fcefc5e070bccf2e9543c3213a2d4b8e137db562a6dd507df90795de01e54aa880fbb5008617da92bb0de1c3fc4b214c534e013502d70561d2a1c7cdef07dedf2fc7e183393f7eb46b1a55593f88f5daf7350e1129bc9e17fd790f0f119ec6c76bc06ca1afd5f4403500d07df66e34a69d304bc7472f87d0652dec1c2c2c3154ed81ce624a60d4979a546bf2a111f7ee6c9002ad372f48abf6bbec0c239403c53b924657ce719ca9997a4562bbebfa9226f3deee79c5ddd6d3caa781c2ecfbc5d2061c8c7eb350821f3396f66154dd7a283a6d4494f38d36e6a558d2347ba84ee396640d5d25a892e053403b657b527c95c862cffeca1a4d13fd25b6d9eea05259e9fa168aa0eb600c26be228dd29c56ed21a8e2051aa355df904c7a7aac34d54cdc5fb8e7f85254bd1893d5ca9f9753e2a1be80c8fc988c955ec86569b07b34a7cfbed30ce2ffe0b7b56d176f18c9f242ec0e0e3f281d16c208b211c4fa96d229b9a1f765675fecd742ec0cf91011829ee2dfc775c37c929ed69a35c8544193833081d4291e35b172e5bbb6a84b811e8948405d924aca79e3670dfa339b8d1884fccfdbcd861bd9b205dfbd3c8a703c8b91ae66b0c3e7f0b4cadcffc303af88649c5dcdaaf58c185f258d46921d9af6582471195cca085b946c4b4110af9173b6859e9f056ef725c6c46067529078c7346417a7ce165c397d389cca60cf7ebe8a7b2cf93d6808883a54db8e17392513a1163fdd5c754416720f919df6d67f869002c48fe51a26366ee13bbf3e305a314a6d5baccdc03f8beb381679a215f7e242fd65ad23fd3eb61221586652592c4083521335d6657e2cae7a6a2c96935a84b97b357a6feab57facfcfe78b32030bdd214df9cb5e0411a5374d6f34d35f12dedbc873514680a9d9515b3a844e0f94c561f61582647155719308da400aae65fd5e49f404377687446c1dc9b29cadee9a94a3ad74f4d22b60dd41df79b11c10291d103a252a64c38694b687ed1167db04661cfd2a2ddf78d8602159d90191dc88ca5cf9ba8612144dea6fc44a06681f7b356c3ae1c30d890c5c99575f838b1919a3ae07bb06c77b560aff93e3dce5ef3df0eca0db34e0393732c97a4b3f2bd04cf9ad94a8163a1488c412651ef5a786b0e111db3ed9afe08ce17c934b976f306d3bb3ea616f96742d90f4699a9d88f216697ba00e7bce867727c86160a7cad3541daa48659c7c279cebec2e05428a34922c8b6a7b57ce253b1bab19ebe6cfd92b2dae436058df7232813ede5d53c5ae485c6efa453b2846157037aeba7fbbf0524860ee89535f1e0ccc7e9001df7b63efe5a5ae88d0fdc9135d57d7511c68db78a9d9d5de0c5b3eb2cc77d93812de44ff1b92da03f90c151ad34a1b543b266b4fb6c32976e94ffa22e7f5872b1863f7bc121aaeb1a4ece2106762a43512b10e373bf4b325abc6b7984aaa5c01ebdb51648b3cd38f3e75541e3eabde35b623cc2a22bca23d99449b3dacb1b08bd8694a8483139dd3c12986e789f386e8162d0d3061372b205a86c8ec6a6400b6d80227d8ddfc4eeb32f7886e1fb9e4fcf04778327700479a36dc70f5dd061fabb31fe5ba63e88313ee2f0bd9f2b13d6990d3897464d5133ebc05c3a4eab41eb6d1c6b8c94710153c9a30fb911cb3d606f8ed7fae762e06f7b708bca03bceb386efce0133932c5ab057249e073a44aca793faed28b4d566017a77342258384e5a1f2fe180621945f6d40f5972372311010d9594d69d6c3440100db295cc0f3c847366c3c52f41030a5437c81703332310b1446e1581f263d1268bd9e6a38820ea91766cbe875743703acff7647f63692d5c29c67c6396951dbd08dc89ec57cb32e75bb6eafdd1adbca91e277fa1e1e7c144d6408541c3f694c2c43e3f5a77f53ee5ba6505bebf2128ef907e1ed88cb60f0d95bfa5fbd449bc61b0e3182e9b7df0b7645ed1b99d6592fa4663d694ed838ec2cce2f3c01618749d9dee86bf6f08c842720b469a1a6255d820a04db06d39a8de8518ca9599257aaa325d275081b5bc5c10a1869ff715bd24f323b42d1e946ef93aa92174d454a658d9663c58f4513ed0e126df3c9ffa3c85432552bfb96082d64172452f2c90adca5e587f636307450adf262830401c5efc92b1ec95a3f1b9971c4b2bd67aa3a55e32753facda60cecd100fec4cb2016aa3536ca907f601a1c00244fbab9c1b26b0949366eef2af4a96b063162f6254a9071b5aa35b1375085965991a2c2cf5d0fc09974bab56d913e64abc87579a6b76d6599382097b9c0d0df2692bf439ea665d4b936dcd09dc2cae42461c8cce3b097da95ea649d889e2ca2fc1843401aae58f096a3d90c6dfbf97405bf5e702d1b5a26fac07aafe9febe5bad1aa1114c54d9fab34ccd31f1123e2b2c0e3f9c54969918b94c1017c831af7dbb55f0604ba6bd3bcba2802f1fcc643b694c92405ea6cde2b69cc462ea1eba0b8eef4968680ba5102dba950cbf396593e8041beec031526abb0ab3505783d358a6bded26fef501f46a5708ae221d6edfdf8d847152df7e33a000acaff6b869f5435f2cb64e857c4e468f809548cff35e734b93da3e829a1f89b616c779907c14650a6729062995cd9c5a8e4bc493378243d831d0b819aed5bb8beb434e3b6229fc49b44386022103f6ed04550c1f76924a2d8c49d3867cb10efdfdb47925f6242bb00e2225103d1b72ac757004435a645bae6c985a3d05f49558","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
