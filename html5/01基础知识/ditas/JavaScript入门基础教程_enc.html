<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fc9cc57aeb3050668fffa79b560408806c139cc83febc0bf3860e7d7c5cb6800df457b9b309ed8a85df5563050a01e83d91bac62307f71a71cced1092c890c154b8649863e3b03037368e444f94949ad4a25e493eaa5b5516d6b7f1a05e60b6ef83a27f2468894f0540f8c519b2606091817c9002b1f4fc650e2aaa804026904f5f35b34b845e6abb7b01f8af2cb2a4f3f8b3f798a4fdc9d83b831962ca515b3082e8f13d6d3e77349c6eb81be0558534825f9bcc9e2508abf0b518b6a78a96d026e0b5bd8169944104cb0e2cfc6d62ba1cec8cb048b05fa988d1e46a79269bbb96c7fb1ea215a096ff8bf8fc2b0bd01e7104e8902b4732a645307efa696c60cf57b4adf76812d99e3e787f413decafe3ff41e7a853ff03ae64479b2235e92a17960d635f4a0bb97080946d0ca20656efcb922fbad5ea3717d43c5c1543b9c980b9f319c14917cc1051a3cf1de3aff4684b712f4e16c8975c40aef52646be85a431ac61e81f0bd4abd77f8638fe42d83a3a7224d0a606ee6592256c4dbe0481a565c9b4e6f47ddae1816ccfe5bffab31bc9d5fa2023847217def16eb283bb228ff768072d6121d2b19ae4a3e37b19edfa14242fab2cbf51428fbf6d61814e7d6726e286c950090dc10c5516b61c17d060eaf0a1a4249dce5bfba43c82235a63d8aa775e237cc00e8e56e3565a46404ebe07cc21b569ebd71ed2aa4d58f93feb559dc888823eade09c8165d919787f05d69e70ccb128e1e86d97e14f850abdb3ca88035dfe950655f007f81fdf145bf8161aaafa0377f5401b191454220ec0b7722fb45fbfef1513c9bc7cc00ce60acc0e19a636ab28465c60b3aa5c6e8c3e27c6b871e4ef01d62529ffb3a402c2e39a323093624f19e001b23d6a7096d0a08f77119bc1ebed452f426eb3537df3615ab924e30c7dc691109d39610c18ee3aa75ea8a7dd184ca1c654301618592dfb70c0c4125b72957db77d8050dbda919d896d0f4a08e8dbc4bf2d675634b7bb6664fc2a3a32cd33138387d8167424d17e8a27b982e2cb9e3ee53a18b17b19549d55a6bc18cf49a515244255f5cb90fd6dc07e0939b0c0a4b65e0505d57e427176ff404be1ccb3984f9a1c6a69da85c28446f298152c4325804b46d05d167b2cd5b9853265d2f3fde1f0af4a1ceea4da0dd4edc3021f2baccd5f05c09ff1745aca6ee5acfa7ea25ee27b31533035875923c297d616adeba7434fe364a823aa03d2f0691473c24adb6d13797bf28c74cf2a0acb96a31a9ed4bb39f172095924d88ce2c53f7cdfb09b87c860d30378a1646fe1e8a3d28d470110f78101579fa09646111ea6fbd673efd841afe3bcfb414ca39d0d5b0a3e285bf3389dc952669c89df15999d4ef101997ecd6c6586de5643a993203984d99586b1edac9a85970101c53eb6a98f80f44162f61acd83d917731249927c709c75846a8ba33456c844986bd714cd676ce17f70b8fe7e7bc8923173ac641fc01b7ea9cced6402df010a4259c7b88c772f8733b25fbcc05d97ce6faa6798030df7aa13d0fb9fd30f8655bfca0017e1eb10b27b874472d257f1388252cb0dda2d9e07ad3d096a8be0e595a06f20dc959048fb6796cfdd33de69c312c86e7342559789e9ff7de82bf4c9654f8fe5b6bac4bc191b5d4a2458d521f220d1bd3dccc3428e946606abf144a0be7131dff4a71d68c6544ffa10f4cd793f7095a651325442b18933d0d46b9b5e5fc6e1d5960adb23af1be38814a13ee15911c4de2e00d76ea205de940ed1b39ac1cbf9279c2a883155fde0d93bf9fc2bfd6030384fa5af18852926161e0fe5d5368dfdb8c7c3dafbc5884c82a60adc3745540dfe3e581211aef93fb6952e6f3a2558c421257633146129363805139afb5e317ede03e97b10d1919aa849751602b650e5cdca503243795f2ef2b0fb3aece86d9e28792bc3791afc2e1d01062948164709c61e8b680f8453e8066a3aae43db085c9ed7cb05529de7d957151287e400d7e5a2b75567c229b8d43c8000a5c21534c65d9ba79a76dcebf6d7f0b1b41825a56152c89448174c6e9a3ba147015e00a55b44ef864488a64a959dad3cfdea043f8f81d7a7015e04f283c92ea385250ce186ed1fbce4fcc842a12c3f126af503ea8d52b3902175ca110adc8d15e1aa6f5639801c5a9af6da61d1835b248c8c3ee7dbec92bd29660f191d652623ccdd8e702e5dfe3a5b33174bc110ee59707a0860311548dce5486de999988a392cb6245782391f23c5732e9be30135633425ca2444b6738e7ab232ced083026c42c95d85636f8f79aa0b8cdd33c9c822e0e1829845242f095e7aa47a9865440e8981d15ba516d4d872447f360145dee67c11336049dc7d0f6c64777dc08e2ae44fe46d3b66604ea463a779f71431159998057fa8ddcaab460da1d6b9dbefc6b6783d88c41dd86247f2be1f8404516c4420097c27594c38077e2b47df618fc9aecd5260e162616a2f7d88177504cdad43178e520aef3ffbc92dc222a0ea2b1f6b1da1a2c2bbe51c4989fcf1623d8268b78c167f1b7912ac76c27dc67b3cbda551120418587e23621d44d9905376e632a95420f427fd45e158a9475a998758357f36d6052bdb3591cd9c4d54628747dc85f54c2a60def2bad13879b3a5372301a4f15c015eaabe01ae4bb85af4dcaeac9350fd39fc182f3ce2318ec27e9b38d8452633e554a25ff9edf161126206dac743aa7868951ad4bee6929097989dcc8ecef3dbe47fd6d523617c481e7e54872c5bebec9ab2650c4ed54dc241cf4e1266b49ef7699983cd299df2c85cc929df3fb1752b7a83ba6d65312ef852ec417cd639d000da3bbee9824a084d5fc4f888f5824bc6d8ebf797c9e73c485b1c9074aa3b440fb774ce0e44ba20db51d9092a3c566ec07089ac7b4a8e1665bf17cb2992398c4c27b14fefe5e6924bd0ba5a382fc08248e96a2a795ec54e685be76e8cfa677982260957ad27d5067d09f98a043c13a0fe5246030b751e18427937ceeca8a64d7263a6754188f0391b0d3dcab04e0ae6c3e02298736680ceb6bd9e8fdf066c8fda9c2b5d0df328cec34c22bf024be5eca8b4fb661163f234a68c6c511313fb4398d100544e7a4c8342efbea36ea8a69f79acef32d9163be41bdcfc740fa4a063ab4e7af5b07ee9b204f3b61783fe8a344b6efca04449bee42e2e3017ddae7a9936a1f5cdeaa60534bdd02a894357ff0e0e87f7c71d5fb32a4acce29c076df8fd9bf5dafe96ceb6d67c98eddd06c407bd2a48e08add1ee561d597e8da26ec030c2c854eefcfb7fa3adcc6d3d0dbae0a63f44a01569c30af591d05e807e834caa6c930fc4363350a0bbcf7e519282b3328cb175f50778f28a71e416d7715ad46a9e47d69913e4de952c3aef42349e6bb96eaea611f692abb865ff161263812916a9b7f3c95abc837967e9c113920039c8eff4ee7008876a9fb8fed028478af8ed18db52286fa9e91b8978007f87fdeea0d6d377193dc5c2ef17f19f7b92e892850fb158475aac43d3765a4d56db76da49c157dd8a1922f2c334c437efc4771c66b66f604003ebe8d7c38c71b31e5da40197441b130d72510b1ea9601980958e3aed6c63ecd193e4c468ef7f76ae67ae45de01bc2f38b0ef59f8a93e61c28affb4fb3c9c4653445335cb2da96b6a0f478f67c6b9364bccf4db78e422aacc0ceb4259a8a757a1cfc8d63af78f390da36aaeb4de9fb6bdea82d6aed1cfde315a0b113cc6ae1dcb135d03cb3884ec8b64cdd6387e8670b5310c6c59a5d8574c0fccaa8d4ca2a418ad16cb388cff877d1ee56246bca7094fd61cc1c2be4c854bdab5f2988edac759d68dd72994f2262b0985641bf6c2b8d5f06cc8dedf6f933d5b012d22e7a41fc2b7260cd6a87b5c60d8c0edbbb49701dd0ee95d23e033a5e948d85baeb49e5cb5b40117a608e65455f058eab7e052a28f7a00e70abc0d2bd44ea80ecd387e5a77ccbf088204a0b5ce3f5298a210522cb6f5e9a7d2e66d8dcbddf20eca88302f7c628a36652431be999717552c2417e51f3ec5e07664ed97e09eb2b72ca13cb9b25f0b88df20ae108d57a44da5521e0e6130e236af091e62c1875afe19d8988d1d58d689cc224de63f312af3e99c97edb674f0b25cc7e4b4b050bd5a3a0fe70cc98fc3573eeafdd50ffbe9702fc3c30a5aea98d8ae6e0d2e9b1436607875a90515e2e4522fd9cdb34b5ef193fb8a0fd299b3524b61729810bc119039739c34f90a13fa16d30b74503e03a252870428b5e4fefeb28deefcfee3018f90eab8d6411822874229098dda51fb922b65b9d458e5c2d9172cfd8bf68676d513d018632143f0c1a8e67d630f3698b0971bdd690b205f3ad3552cb5a439c9b604bd712fbd6895ff5f418ac217c1ca2e47f74e6c66e052ee4c8d8cd99b431f5197692142a0a6f3f7d0cd8f7b8ae80242f16e130b92f1f1a7f89e12ddcf8165b527b83dbb92d7c17386151de1949861844adf5f37cfc974b3a18df1002dcec7a9882fd0983a7044d877c538323e476587adfa87e8933ed24920490cd1054cec4ea5ca2a875e193aedf1fd0e8700a1e6cd36be36ee1849e97d5950052dcc780bb62d83c7dfd26c193d6bb8d5707f5ca06d90140a4d3bf1995a2c24de47165653b0ad48749fc7919c4a507eb3ab286fcc14821b7462664446e092ba4e7c41eb39ab833c68648bef59f54344b1e7ba8eff46d5a4d884519d373c3c3a71bb4aee6c393d456bf82f0bab63546cf1c98da0120cd959f6ae24fc39a1808aa0e517ec7b3087b2db80c178df02cefdadea04f058c98d30c19333a5618f6b396d7d764d6f49dd6bad96d59ce41beafef25065ad07ce64b14db630859623b9827e3e8d1fb041d2aabb5bb7391e392bb529a503c8445fc512e6161335f80bc1b1553a645386840d83bf8f1de1447bd853c9177110ad64bddd09829337339a9a81775bc44aa96de738f1c53bbedbdcec813bc2cd41fb8c2f70a9697dd31b02236d4b543eb89bfb0cdff0a8dc4ac02d464f9e5e8a53f22157beb4d58e3610dc30fe8e0e8907f7f10d952ee865b83d9ce34697f9f91e5f335dfbf492e39ab45316ad1abcf39a9401900840d79298305f7f1039f6b6d15a956e09708954765f849e58e4b562455631d9ea7b08a70467d1b515f86cd178e1af88cc3fc4a1b865a4e1fa3ee6cc94c6e2957b0e83a3df026e6262393b823f5f6e5850eac07906507a9afcfd4a11f63109bc3673df9403d042626f3083b13fe879007fdefd7d1a2657e31fd6d8ebf14043e57c73b68972f34a06548efa968605df011c4ad19d3c2237f13b0d67d8ca7cd79a0586b817a4977c07f259d4bf07907a721205107492c8f0b345873148c5cc1c6f1df04031e8017c87e6316dd313da2dbcd54307444898e3cfe595e659e9bde04542c6b9266df6e31801e58f397e8ef0be0339cd4d3257baf49d4ce7cb2cef2899731ea21a6e548e0a801582fa8a1d47e19aec3c6bbe305185f3fc95fa42d73199a577f784ab41bbe4b6c10c987e52ac930bb9bba7543b0abbfc2abe1d48d90c79626315ea1029876b8444e05b4129830ad449232bd7c2e15c32c3cc01f64ae205e0323f538d78a4cd3b48fefdd8938fd575ca96c40ecc9b515bb73d1aff72362d4a3ad5dbab37dfe41c638b4efd2ed429d7f4029ddcecbe4c3b6138187a7535eafb8ad45c38b0c2a305c1d52258bf4a0e8d2750722efd239d5ba09ac2abf4c87eeb43155ca3457a712d0117d45f1671910cead2152f7443bd06e58cbc73bd2514761d808fe7d519d18e607ce173b5063ebdbb5a00ae74ee774dcbe9e374e19fb1d2badf4746a964380b6eeb7a30c5be724e5c7901e13ab0d1320ff03149e968954a6ad909f0a8dd17c724ae52608321dee73169707a9e503166acf94084397eb2b0614870bd57e0d2bee8ea9a57bb2b9155eb8c5117fdc1d9acec89c0827a26830ac4aa477780b945af655ac2dd9fd5f4e560b34d4bf8809c36ae45c2dd59be2c1ecaa23151909d8a320f97c4c6f8e651df982354ae46aceed8a2baef8c38c359de7b9d46c8fc9a9bcac0814cde1f1326447024f73de0806e1ad42040400988686d7f75beea44b8d86a68bcfceb1d2a84b1bdbc054fbc0ef165c4cf48c51ceb3d605c5add19c40610fe032ef61da788b3ac6bc7fcbf2f27df8a451d746c12cd02a25dbfc825c207986af284bd4be9e5ff8c093ea2f426d8ad2897e7922ecb8d302eb287a8607cc0e942236e1ff43cdda2344116ef275211cdd2538ad6f5701e4593b12e5ea6742c8db355f5f0f054f96209c6f74697d23b62fb5b6feadd0ed0e38622a90c1c8ae5c60f40a3de266305d822790dd116cbd6ecd94db7ec08b89c5464ceb45ca365b94d316b1d297fc0730f39db6534916b444deb3ddc80990c18694faee95a9fc93f63748674371fb2447768333d0dbf539e02d82b8497b52d0586a8eb521ea5a2a990ddd3f49fc3aeb71a8cd2bb7e6e0c2bbbdcabbab979891f931b5b392b3f0765156c9cae027ed9afdacee1a3f85abb2c109c63ff470302581d2fd1b473065a408640b4958dd11e0674d2030113b2390c9004a3eb39a5754f1e444a6e30063ec926d20d15feb99ce2e0299faf20f86a2735c6545d2034fdc287375733ddd61795de72f5b323f492caa71a8441b69aee9928cdfcad30ef46cedf440cf6bed29a1790e1ef3cc4242413bc50a2b9aba8af1435367e7a9dc03a8b234cc57c9d4457140a945dbbe1d50a54fdb86d17ac418ef37555f178d3e341dae15db4be39df0fc87e1bc8ded8d22d09226a5e20f8f217c4a5e32ffd0186e470e2dbf7020157d377cf70c71f08feeed13291e6eb1ff685cb770ec0e7253e15c0352126994eb2261f45543c5073b2c6c52a9e24a718a0b84815dc90b76a96572ba2ac821009ae26cd9913e9c0237d61a1429ed962c3ecf5dc1a1e5a7f9d05c7dac17d9c229ac898cf667e6823b1e6c076d3c4a84f34b006bed481326b675afd44af58604c41cbb35b253257472e6d84ba9631febcfdf094e8ad0578dda21c23dbfb27fcc9479ec91f273caeb69502cac377b5a2df1c660bcde93018b17e1ddb1b3362778c90bddc8774af8aa164ed9eb02cb3a1b93229c3098ac8d544ab12ec9cac842491a7c6592467049dcee1e95e62b2f620ca0294c04b3b28c0ed0cbcd8930d556aec547b3b485bc7dd393578a1a225ae53d4375bed344b2bda37a0622e44177c3d8d04bd60a2dcc0a585bb98a2235ee84bdb11f403f5ceccab7e00e353d5efe03b88bb2c7eabfd355a3753fddd130739dca1c20486c3a32df2f3950fb032eaddea854ad2e1bc8b2e1a9623a78f7038894fefba33b7bb8d97dc425e4ccbb7a15b1a08effd8ee72c0ac33952d9c9c83b33798acc29ef8927ff90d3e34f7c65af86e41f4b794316e0000656a2550d26571a10bba17d9396d699edd780de85fbfa62746590a8015e446b50dce9c30847e959aa07c45bb8a7bc092aad938ebaa4faf8bd1292a565d459006b72d48bd65743fad017b9de0ce336583f2edf387c969aabd05090cfcbd5ce11e55624f4b472b35cf201484c9a517ac14c77b56b1a80cc980ef2e6435bdf63ef54fa39645bc2a68e0b6718b28a541848da2ddc487f8cc872ab8d88167bfe0b653ce18811b9c1cbb27305976a0f4ed1a89f900cabd6d623edba84625878d06eb654e058076607666faf868687ac190993af7c5c7bb59352675cd0c5d76cdfa5bb0592e40f7e57fff98b9f992e20d79f73b5a0937bed12208ab48e25471360b60b3ee1ce94eb18bfa11378c3adb8f8750aa777ad0dbd2d18a843d87d6ba3ec4b5b7ee26be7e15fbb134c355071f49bef246b2a15b81cb06fcb9bb30251fce21b5eeba25f5b0da0fddf7671a6ce0179371280d510bc7997c8d092559c52fbf5f9239777c187417a9ce69fdffeacd6df083eae9a3e79c7c34bc60f88a48d7a35473fd26502784fa48c80ec1aabfa04002d989b8f6f322a61f48c6f3aaacf85ab358684d3e4390a4eba09f30ac0ef0186c0b3bb530613b9c665c71b948671c98b0d2769aa3b7fa799f78c7e0365a18185a7168d9fd91804fd6c27a1f1ce7cfb6ce92c3ff496ed17cf7ff4f73bdacdcadd570f369855fe0db709f85141ffe9ea54e2583ae46f59dc16c8fcff6811484a9883de1d2b4a3d3948ccbcdda8e4efee337c59e13df035e7dd763b80d0d6c04cf7cf3ab8070308ceab069db2351b9b793ab1c0c7de9bd7e83ff0d7778129f4ae4cd723338d10f17e43170c7fe6dce885033080a0c6e2da7d95037106bedc883e6fedcaa26e02ef35c4411fa11d043b0792e3b996056b24d7fe22cb4b614cd05c6abdccbbbb90053bdc8125581a51b88472014b15f7418832912dc9ecd309ac8331583d5b6f1a4167e358f3de7e6437657723a6bdeece036b299f695529b258a25a4a52311b7096d888de0fd1409823f929955146e03c329471befceb1d399547c8189e76a8a52a13ae3ac4a887284df07886d09dac7456ed5ec6ee21f870718baf2601b5bf0bacb31f1dcc47bab23c1c11a9cd2078950aff63775530d77e2dc7499d3cbdd658c2e15c753d8484106e4de982ca3185bb7ddaa1c43e90d84c6cf3d77c80bcfa0ce25f44a071b96abbb35a1d52f508c4b298059470f5780877073481c402e792617a5b1dfbb59ba376c04316fa03b606a5d4ab20a3338fac1d9c08de2b3c9c593cd9f39444e4d4fd66a87ebfc8583d6cdff45bb8a19dcc7d5e8f04a2679fc8b5c14503fa82cf6f24e4ea92a9574e46584869add257223bfd53c97a0ab53cfd1faf72fca9dd6f8189f19432688a646eea98d2e7c83f9f53df69d6dfa38ee83741b493d06320e09f9983ccdb0ae0cfb36fbe9e3a10a0fd647dd30057daa6861c29c92e453795ff0f85babf01d6fb722933b0eb46b5cd8a9cd1318936fb6f02ae91c6d08cb7a8ea1910636206c21aa8a8a91d95f1af78a4db75ef41c76acd335981400206f3e6cac2a68fc624100e33cbd0d7bc7103e5a54fd56526e2912c5372b10f14b9e5a41b0ecba147ac5e34357714819c8c3c1b175a1b8adf7af90288178167cc4d8a6c0c7c93ba9a7794e8bb5f21177ec1f767b15cd220596fb2fec06fd78d4da9feae61e268742ebe2df8de20fcd1fe0e0be2809edb61ff6a608b4370ee7f9acb64926e108ddbe3dc0853820f2026c2470614a5fd34ba90017eb1670934ffd76957f4c74e5de423b26ef2a990c44950dbcbc203a781bcd28d94d0584a6c70bf3b0a81257efc176e8ed90ade0df6fc4348545bd16c1ed08a47172b946ca0a0a9275584c4321adea056b440fc91c50d5bc3adfb97db8229ed49e38fda82bf90932b303e559b02181abeeb655b74040723aef49fe26e6b358c2eaf9e9c6c20b69288cd804be8bd82ea6caddfd4490f5b49942f7977c621d7d32f504190536a3af6e8fd406ca5bc5d92fc4949844c63c06adc2732322c61ef6dd02b3ef48d8a420c10afea07e5821b970885a47d17663acaeae8f491dc3ecf562183ea7023afcdaea82c2e272c931ff84b959d3c157b4e7f9cbc3d33ce70212bee59eeb955b750f016006ae7e109d6fab795bc277e55ce3a51517e4ab3b2a7cc1c9c94920cc535b5b429c37534cbad3b0d0aa6b2ff317d4a67c1702e2990db0716b6d563c950cb31cb743fb15bfb9379ebed2d7eb3cb0eb0edb431bd37318f621ec50a93ec783867916449cf7e277669068efed84a633a67790a2e32a1d4f1886b6435c5ffcfb59f20b9d15ef1c5e1d94929ef5bdfe054ecca1c8852b06e3c9db60a3530f45636799edd90d09edbf078612b7da145d5ebd43c0a16abc60763244d9fa1b200177a28ddbc5970a3d82de85f74d8bffe9347ac6e3e27c67ddb7cd56f727b3dd2f1a7618eff5bb7d78d4001a75041cfd462ea623d8bd3f1a24b99a3006b09c04d2952f5038080b9244ac23da615e09cfdf1a4aaf00422130fb7786858dfff70d3b060915b56fd5cdb577ae05784d2866b54d47837e73f419f1e0e744c19f5e84f102e3741c43f68798cec24ff5db4791b32eba95c3719ec32f1b2a4db71cb684787922cfcc082a5b3197ab41c18bc7539fd14a648851cfef979738a8b66c9af36d560041fa63089770389d06efe9b6453b7280315b52274b9a3a4cbc9ca55886d9a18b71d117c564a0766a30739e25f6556cfb7df4aca665d9ca6f68c3361c003876a3e0f284678e178ef88834e35171c48afe21994cfa0520086b57aac3ffbc58d95696fc2f3a90aaa563f2da19bce5bb88004a708b1f6e8f1619bf893e105c0b50f8715a6dc5753763957df5b8409bce9560180456fb25bbe0d52110a920f8dd36d008cca1e6ef6f699a99584964b6fddf2d073cb6e2c212486dfa8e1835af0cfb081ac6adf4dab3a9ce4f336ef9c7ba130057954c31b1edfa97226d1fe5676f1ed0342e8e11d597efea2287a90f6e7d3067e9c8a4baa30b386941b007fb1898078c0f15532806cdbba282678296b5cf907b417ce06772fb9a494859471fd99af05f9f7a405477d7691b483ca2c309955238147a2e658e6306b239d4e8d0bbaf029285939588399a403fc5d16272889a4676f3065cd56dd5114c3e47b3fd1c230cc5ba48eb6c82caf4fd58dacd7d4a596506f73b0c39cd9d9efd29140df31a4b4f6159bdc6f4667dbfd210b4e450445d544387c3bf475a45f35008bc7239caf9c57e241a434c2b61aa35eeb0ba49d5e8b9d8c8e74a853e716c8672f1be289324b63df8ae454094889fe68a2e755ccaa6aa840098ead601c30be4c873f78ffcee2c4556d1f5efba9154eb9f2cc82e30b939bec496fa0d5694212c895d130e7468d0b924ec1153b5fadd0dfc18ccbd9faa0e45228147f34b49831ecbf323957a39cd0aafd19cfcd7c9105210fa2659dc3a095ad0f9a869c7bd31268f220b4925be363249a1d40b4e841adaba4f4b548c2dfd06c0223ee5d8d66b3c30b562c722fdf1c2b0980d117a509c0adf3f99a21ce959619bd7aa5f678151697dcc85b6d2cad59ccf4e63146aa1afc7af3f386782a5f5a7a40053b86bceb658db07c0ba15c8fe166de47f225456918f941b13357da9d8df77c5c519cda8f40480c4569b253a7062809f25556715bc863eb7cc2b31d828e8082cf290e2ddadd543e30c5a92575108959b4a1a1f91f7199653a5b764b125528c2d9bf43fd0eda826a5e37d4852f6109f3c42b6687160438fa33a5668e593f4c5c915ced5879bb6b5d76037afa6d55734578c67ca55725810913ad0bff70f1b719ce2bdf8f097737ecaa1f0f9543d190154e077c465787ae4f257ced61eda942791c8bca2eeb4fd7e25283ed438888670e01947796e2647eac510e1898ff72b825ec8ee11169793499e1589de04d3f3c8f475b4021505546c8df6f5b21753426253cb6cbe849bcffcdd1f26c80718806ea0ec371f35cc555c438b99034dc6929560ae7026f88fecf4a9b384b0c18b52986a1208c3e0c971cc75765f13f743940ef721546c8d7cde43bedf821e84925c2cb093eac9a3ff535087b1facb71a2140aedd3445e33e6c5afd9ee3a067b3dcac8c2edbe9616a38f3af5c54f43864dfe899f88865fcc772f7bb43e996ae6ca487d989e88fc569174a450c92b6801a33a37e276467aa2c6d8565b8792a292190f7b03afa36a381cb5714b7384c964106292b7f043228d47b9894aa8b852e6267dfc0ca85f6b6424848c3a675ddf55a01d4ef8e925d52a9a0e9fbd99304f71c1e0e3ca0401227622fdfb5c696ce39c86353f8d43d09eca4df7deae52b0b13348e08e3d0b9dce492b9ead5187b0ad9f369323795ee964f4936640115752218fc2c91cea39f81306f257d5ec0d79d7a2ff98090338976cc753378b6764f0fa0ad2650579de1f4b3ab56af18bcb3207c0a88b10bc9ea85563775242e1edd567b38cf94c0d72a22193251923efcc8c448e4c954387b16d8d3c426e74641f6abc812025728f5f0b7806131e3cdefcbcf022855c15f74730eb56338da43930f775a25ad2f610008c3c077e187fe19793e90f026ffc24521e501fc723445ae2ce09c54f2a297f16ad7df7d0c532ec03f774ddd4ccbd986c401cfe8ad98871864993cde279bc51d05bfa3eadaebf0bb479aa500c181bb7ac9b044300a33f305549851d250e1da0765b6eab89620649e7c01167961001aa9e9d29356c9cd9057e4b923e22eec1292f3eac60993b6945b2414edeed7dc7271a8c87571a7d1d04e856677203231e622a04c450f5feb98437a0a5910a5d013d40fc9c5fc41d64cc60c1c28bf1ecb10af1ece219a4ebf744eef2576a09210f20acb924781245d12b34a97f40914b2c4aa0e555fc40e3c3cedf2aac6bbef142f38975997b9265a25f2fcb77c63bff51bd4caf17a265ace9934cacc0960570077e0672ecc1a4fe83a96a3518c20f83471c71655b9f8f592fc69a2055c26d014151166dd247fb36697968dfcd31d4e37473adc6bbca5b2130bd3980801441fc8d0de821b16f2c23c8d6964b8c834a618b4045e3a71912e9514e95d3cddb0158ed61bd3572fd3b66b3bceb8af34bcb23e211ecf011be5df0111c6580aa42c535332ac30c4da9409819b9bfff7acb65c8a1bf2350167a4b2f9e4b58d1e2dbef4f92d09ca3b30d4944e0ad5c18f739f7ff0d876df4f59b48e9d7b9bb39cced4d410fa690229fa3721ca5fb196ff961cf31367ef50f1f84411a52802dbb7ee700ac71a40510eb3821b9e817a538f26d7d6b495a1b5463593e862242c68a0489a41e97eb4cc55011432bca39f3086989cfe431c9ab18e7d87166871f9c31b95f4158fce7d66b787080149b40274d7a463b5069235415086b3e11b0cdaf8214d0e40d74583805f74940610556816bc7a8887985ca0695c90de8f605b16aaa196394025b1bcd681badd1e4974c9ee9719eb7120079998398ff022ec5a2874a1038ea4fb8831d965ef1f3a7d8ba25bd8b10132ae774294dda364fc4922218527e5eba615553d9af4f060bd552dcf362a65eabf9681972c0e7f56b944e7b6fa894e0af25e6a44c11402ae21987778769112a88cebf451f48325cce1d71758e9907f0a1347f711c544f4d24543ddd10113b3032bf5fd66daa6b5b63b8cd65af0b26e65ec596a02a499ef83381cb1b38605752dad334b28902e26c39a252013110141257eaf0ad7c6c1def861ac871f427736ac44fac433abd95d82bbc3a2cedab64d5db454b0e3644874e565aa62adfca467788c4070afce9056888b9b13335de8cc4dee384eb9290845f747876203ad011c53e097d0dc9dcceb4359b7075192fd938c27a3ee85024cb561e5eeed803a43968ee517a9e5df2ba5444b0212a3a329ef9e603fec4a1a5fa9e31700823de1e547dcb13f60f6dc8972bf70c44cfabd5960606fa8d2484c0f1fe96a9160cd5f15d0982e9f99da35bb7ff1c0bce20242aaffa42bb306d7c3f48d4570802f6015b9a0a080589ca944b6a5d93dabb3032e0f25f04d533dbe18ca65fc861c768741bce8670e182149efe6ac3195a1c0831a7d85fc294173acd5a15e7684e5dfad9026a84da9b239bac3c3fd00adafaf8d1675cc82faa7229d93dd32940bc790b8091de1d89e230a74b4af2a17c2374012c3a7f178c5fb0576950ee5ffc4977a3b9094dddb31bb809b7ef24a0e53a3ea9b0deb0542c26fab5c591c3e425b59c9c1ce3f49220d7a4bdddf9663c6115b235b20792148bd1ab6b881c6af1ebeec2099e095a34cd46cc36df34369a281c911fb5e23b9d0f9c2102ad9c03bda5d6df30bb84a486120eb0472447f539fea548cc7f49b07a7f98390557b6d10a2df0fbefec2569204d1c38a8e7b5f5dd4cd1e227d49c25fbb56496397a868cd501c3c23c703dab46d86d20622628777ebbf8c5c85df42d4d9d6683f8cf98613f0431118139806cfcb8520828cc859e2f74c52e9f1c91820657edb1fd247494043af4c6e14ec2eaeea13df73c572dc0dc463115d2da9b42696e3ec7edd807b52c40b8e3773afa675bf3c6edbe24808de0a2406d9a8c98704d5bf86c204a80cb61ed596d26bf260e38ee80126d7441f3ef800097069f7367a133bd8fb30375331df16bbaf88f5e282d9487a6e316545190cad4e857558aaaeb8353fe7d87993e419bba4fa59f62e2996b38e4f10f77dd0848dabd5d581d12bf5d166c5cd1eddd08c011906c65cac276341f20162e8798e40e4078afad67dea7e68fe5e8424ffcc434a45025714082eb6aa7f38d2ca72d6f2b76ad581a2bdd60dd5ce8b730932af5ab1c43d71d67e5df2b3c17a63539be84d5b8bc01812bc677fc853a192f40d38276bc9a896bd8551315a64b982209426290372ca5fad1f03c806ca07315b7bbbc1365b7e9000ec40dd6c519cc08214500b9274b3b89320f64d018192a724774afe00fb9dc9bd0fd1ad48ad424aca48a218ee39fd291fb87955423ecf0af0bbbb7e2736eacaa7b4dd98206763678714092ab848ee7bcf3ccd4113142163844970abb3954e597990ebefa4323dee10ee58579e2e282871c298bddbe1b37bb5be45bd70a094643a53af60bb6d26e5c02569d3c8b4c38b71b64e44986bd740dd609956d60a587d667ad02ed87dfa29f7d304877f32abc64a8da43f83f8a9baf45e8c7e4224d814ce11cffed63452e86feb950c8c5a29e385c9bec5d441e0cab26b2ed2e7dea58c4582477f9e1dc1f71498d101d2dd94b79ab7cdb2dbc605d1c92651f91fc08dc83c532d84ca9dc7d8c7c956c42aefe65245b2b66e8767b5f9244088a77dcdcf250147dc6da1445ffb014e872e970f1a6f8f74d49d31ae9d45f248d753f65383eb44760b82bd9886bf2b28f406f50ad815d682737f6909390417aec3e7654fbbc33a2fff0fd61878bff7ba4e66b7593765464e846072c07713b35f8f000af1b6c9e8e04a49ddb783aaa2f9eb68dd6618dcafe31fd4b3501fc34d82d9399f9386d45b5ca5eedab84c01d7264d911ed2fd3036696d9719cc0b5686307c9490aabccf86b80bd451f9f988786cf3725afe2a06cd192fba5ab2bc0c75298bd9df9749d2a7cdcdc31b05d2c85eb645e7929f04c239158b6623eb1b4f02a329636c7a509578b45062ae3da3708021735503164d30872cfd806513300297c3fed5c895dc52742605998c58380136d8a2e0222b4585703998bb94561253880be9a5fc93cf502b906a6e21070fa4c8e315dad9cf654665f14b0a69384b0239050ce4d3b6e94f8746a23d37f61b5495b548ab89627b2fd8c108cde115ec9fcfeafd848db9e85353f7098770a0016586ac32b0b15cdbb931d8299a6c3eae510ae8353c268b1e6d4762c6ec9341d085993fe2e743b5b7654108eb7595759fc0a3e7d98e063f7b1582d9d90f0feb597c7e619dccfd2d60e0946ddda5fadf14ac9dc74536c69733ec4e0f6410f591a59e7b10d140382c4c3d66f77cabc80b363814d7e695e92ee2bf01eae967f160d150be76c5a74ec794855309e56df3369a9e98ed0408b0e17fc02a79132cfa3e6e3c534bbcd5009768f05fa84c90e3c59063f37058ba38de2acb985ddd27866919e72e24f08bf245a0103da7b23aa6aff8bf320d717384f7dbc2d02463f78e569333064858cadda65af083f93d630a03af78fda8bf39893d06f7b6d0dc8d9d5616a9646b72bc0225b39e9d21d78016614c84ddbee93448c6dd2ac970d19eeef3dad2bef3286a291f9c59fe21fac0825eb6bc226ae90a4fc3526880f494a56d59445943c612c6c0d73dcd3615d07dcb4a2cb46684f86a4db6be86cac6dc7218f2ab3a7740a8104e6176b576b822e43d45878ffcfec8507ffc5f7dd5c02ded5778e4d3c093789f1d78f5d77d94d028f5ba056a8196b47014c3f6b0ecea543207adf6c348b253665b277643192b1f5736b46ff48d965b736947f97e86a62d706f20dfc82cf1efb5f5aa59f4d1fede4b5d7daee4515e171e854f633cd5ba46f09e238a09733936b9bd234bc2783481c99352ef0eec00130366648dda5c1760e94ddf2273b4930f9e4b37fe28424836f66eae38df3695e32a72a4489820a00963477372d1edd6612a82dc3fb568f6cb1da8a1e8d1880c267a0ddabd1e218c32c1fb2ff95d4706394897e7671180be6b65cbe63dc91ecc7b7e02588ed86a54bc5a5401d9cd56b67038fc154dc3cde1acba329cd4cf57e15e15fe156c17dbf7cdb43105cf31b8ba8b78ecb2359b1f02fe6041ed578b0921ff2cfc3db0c138740dbf31c7fc678c4f64cf1b06dd77103967c46af8039a74d058189d6f76e28a516c8dc29601e956b310be5d397ea4666abdd36c0faf0c99068d3554399b0a6addcf8da7317b0f8dc45a8bcc927d56c24476e70e4bfa57fcd9e1e8e5ce055ba4ee88177b30027dde6153156d27f2ce2a89d06bbf549b0da6065cf9b98641980919c59299550ea59734897b605b3b9e46fa166be05f96724d5ff4d92155f9e80b86c80572ebc2145bc42beb60eb491230019628651298e326c0b7b0b99a77d799c3130266c25010df9885d3ee2a6fb13b2fb7f6019681f54eef2bce8c3318ed61eaa9bf20ffef6ba6b06a0a34a0634a7373aaf73d1d1d400377a2d4451957ef9db0f0836e1d5d14bd65854a28f12011cff1894baaf8d396d7643cbcfb449d42dcf654c7448a51fb837a5b4398322785f1e8e6248278a8b77055382fd4dfa114c015d9d0a9b24e7a5e76ba8884235ae68bb8a990c41e29250a58e9083c93c07742e5c40bb7a607e64d2ae8a011cd35fd8bfa19305b32094e4c481e5c889dc37e99cba3aed4bc6c8347962601d8f13b581277af1ed1f3c164f5f2ef083a81ae5476e52f69f61a9f1e32662a2e72d1df57dc37adac735f09f933e2fe8bbafbde0c3d3bad093962d52c9cb74b9f694a9cf0a153ddabdac8ffee2acc0947881a37e37dc7182b02fd7337944fe815f17c6547788d5d4b8a987860b72026401d5f1f713115522da30dd65411007d534cb6b3af45c5ae930d18eed89f0c513784b69a6b563e29e7ed8cc6f4c4b8d09457ccf400da074adc3fa20422f46528c178c3af08aa10443a6268e732705d3cfdb5648d46cbff3799458f424429be9de6eb46b9d90d3455990bf4ee9fdeb2dff6e62b2ed3c4e31419c110822778a02008b89c2cea327599531216610207c712924a99025440b01dadb91bcc6a5192e0462a40e4fd91bac979026291fa6c048406bb41f5bdc98767ce3cbfddab1cedc546ac9cbd33316c74ecd6522687cee721f3534aa311497bc2b2df9d9ce2c2a5e8a49e9a95c6bc64e326534e666c8039087c3d06d992aaee08429dbe611376cdb11c72745802f029f0d49709affea3ccacb721eb98f683b522518057f541f2ca15f3dab1d0faa9c90f32f09c8d2ee937a144172f30a8aa05518af9f27de17225846362bce763844f20fe750c8644584fbe0a508a655e294ebc1b71f0efd6dee21c39df4812c455ec18998d1ece52f57724fb6b259c75269e117ce21d37aaa3afe423a14a1aba9bb1f06ff4e9dec3045a5e1a6d78109cde67f4ee48226d3a8adc265e9596c975c3aedd7adb3583b98d387d811c02e297c32b3f07201d6823e67558f867f016bf4f861b65f6bf2948b2c95b8740a7967a5e6c607cca66fdcb8a5f022db7612983722893cf8cb348d47ce963e8cbd66adf03af8f7bc2cad497e9cffda1b10f74e7d7114ee4c81e4790e5c85a2cfedaa33873d3fbb9af8d3a0a8b3a4932e3dc410767c633de8be6eef75f50a31d0508dbd099c6819285705abb13c15f411e8eb58ed0419d5a3c5d0f4fed551d683d8ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
