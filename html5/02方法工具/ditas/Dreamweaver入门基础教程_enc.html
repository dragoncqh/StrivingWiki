<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30ba84371f1df5f5be3048e87771e0b1221c4a3987675d60fdeabeb6b1e2bbca1e1d96c0aa57768c917b4b8edc2c5614293d26b8847240b019bb3e7c1115934f8c1fe6e9bd865243c616b7c11a14f93a235de682285ea96892c09bf1c1d769f68fe271cc0e9634fb88594f64f0664daf1cf7a057c03e5465250354b42662550f9a37c9d57e49c43adf80714b54c96f82beab0f1dee75560c57a33d0ef1f26a7993022375c34de640d644ac1e7a417031cb923dc7449a6f5fe6289b8c14c2c208ad0662a9ffd8807c8f73e78b68f127ee46ecddfbf4a14b09a18c8bbc63d2c9257ff39ae72615be10fc1069d40af993f67ffaeb5dce3a143a83969e8131e8dcb266c2dcca1f9f811840ddd60051d0c26e73d36d61a27428c4d2fc63e850101ee07189d7b186fafbdced9d9a2ae307064da45c7a414053454b21ab2ca62de0eb61d18c6032601f0761e44bcda1a72d0f1819d7a705a51ef028b66c2dfdcad6860141f8992ba074af1a4b62ebba197d464ef05237ca9ea105be928c00ba1f7983297f6e1ab39e0034a821861ee252a84ba029c72080e4e49183e496614c924dfe0e62b3b1e3d7291dc5a578c6fd2fc14c12c000a2f82d8400cbb0e194136e89a1d88da8bd4a635b0c36eebbee0099a63a28f0229d7d2b5c5d53fa4a3031b65e233efd30ca457e697a4c5caa8393c2db6d15879dd28929ea67621f10a0489919172c923fa50a67cd6320d77cb8b0e0819f4ce396dcddf408dde8330bc2759ccb1de22038a1f763998050a23d8cb8a10d62d988f62b9e30b96b9a95599cdb59ebc885fd8f77a204e594fdbf50007030d1a2a9261d4babcba9ccb0928764945f3fe4b62132ae32709708665bc55217c90c655972c906eeb679de9ada5ce4112477528fcc5a92b42eb1e211896af078e0f1c4446ee974e859e07fd8916d3a14ef8c618fc44c460a465f1e16c0f47a64b3f99e03a39388cdc534cb7ca7123ef44105677c9a6afa92057d3d1f6dcf79254de74909e1031f6d11916a8d028c62dca4c250a30cf0353a63d6045860dc88ed1f25e7f55185fc84661ab78a4730e29aded2f4668c2c4ed4a56cebf672d70602fc2a8738ac23075e42e2545a09ade05974a80728ab51552a856e5a3edf50ad6f0abacfa0005aab4fc10dc53b3040e022edf5d939ecfcc8d7945a148d3777804ceab53e6086f686dbfc9d7d4456d95ee62b708c6fc3236df0886d57cd2e1edfc4d00a70ec2f77ef3376eef668205a02f27a5fcb10609a86444d2615e126d58ad1b3eff2c70a14b7db212155b7625fcdaa50ae2db5173932cd496e072aa55d1b5c841f0ce2904bdebcfa016ae97d9520d1de8b820d31831d2691d4f8a7c5b291a1789dfba67504aaed6b4da410dc178fefe1c47a9ece5f3f6d0cf83890a009c8c8a8374d66265ae5fa758cfe6805204f8513559b2c726ee8cd5af4ffac98245a6d84d72d308d3406f1c1880e2d690bf36540fd3d2af4e5cbca04ba26593928adfa1e89eb24378e6861ba46f8931addd0fa4cbae5fcc33bde03526284dbdb44933774459ec795a004e81eef37d3fb9ecae235f71102fd22027e799d666a99adf56a00060315043f33a9038aedbe2a3f0e74e74abaae71877bb32ebc0bb7ed6348438c6904379f215b346e53e2d01e1313c2c23c7e10d950e6be0dabf3cc037cd56b92e5bdf5c9a8357747b0aa12f29a576c81d40b4749fae5ae88ab04a69b76a47da5011f65e57d661ce996fba4542f3f3a286e8d855f0bcfd4371fd429095046364e791efdf292d1b7e68f41f90ca3f0068484af46dd96563e405826ae14a623ec13fea79d8401dbfe616c5111328d01c8499131d88bde540f2aa386fe8f29dba7f5790e4831d75bd0908220a25ac8c6fdaddfc152e10f8af62c58eadec04fc875e06b4b9384548415fa9b1f281c69801bfe04d95b03fac29565bad41dfb79fc9c7337301f1981af057c8ab53ad20af92a8afa0828e2bb6e985e1c587f7c2013ae7e1a000fe32a79c91f1c88c18d6b921588ab8ef734646358d0fe503d7abbcebc89fc1f9e23caa60d136359ffe2dfbb97bb2c782e76058dde0cc9794d8d72fb6ae084bdf122ffbe140aef457e641a760c02caed5545e051a219f8ce4505d9f753a70dbe6d5dcb54636ad60f06b10b4c604162b1ce5e661a049d12d70b606fca00274510a9337ba76f8b5528e76529e540945504d080eb590667afbb7568e2d26a996dd8361f2ed5ea11928569c78fc4fc7b6206fd571e9d8cbb431c449673bfd973059c04215b2730034888c0194dac844990e6a44c84565b82c40432ee6fb47415abc21d82bd8eb0bd943a1ac0291dd3377c5927c8d3ac2effca4b588d14a8041e364691aadf29326628ed84caaba9385a3117b8cbae57127254b8499a51816bcc7ee8445bdab2091c79ce4b0f8074140d62d3ba648beeaf376f266ee49137e847b695e67949354499953e8ef35ff53b4dc9fdfa94acfcecc193b5ce41793c128d777f24b182b9f9dcdc235d6ca8ff356e9953e61f8d561119eedd68d4d285d71aa222c4537d301ae4620a95ec97fe81b82e538543ef8719abf106e9ed51498df6c926e285576998366049c9d00306710382cb5256c773dfe1ad0ac902c7dbdad08ffa3850d7289d7a705d419546fb34421bf9c55d465b31af79af3aba93a91520eb2303c77a29aa820536dc402e421f91c5ba6f3875d812e6b77afe02054bce4aede89ed98656324072bf23b8e7621800a086a80b1216b1936384fd7c779faa9e42a37b2d993ff7aa1c42a333859853543a0f2a9fe35a4ceb4990bd6d6bdde2db49733f5da9a11a65b081511f3aa3174ed9ac19474dd97a31d3654aa9c44facb2fe1c54090d3a7755613f4f5574df253f9c470e8b92c0321fc56455bd59af8fb39c1151cbe8ec636e87b5fa5c2585421fe14b3d37cdacf8cc665f8016131d21aad5eaf10030384cab74e7be9865ba9fd76f616437fe94e3540e4c05e603a9fc84da7d4f42b6d28d83c25fb4a066ac626a2e8f8213fc7144db0b44c78e9ac43a5a638f30d39af2ac33ec9047d065b15eb1f76bc1797800b925c71cca67f388e12102aedb454ce6def2c82f7fb5d86d6146c79571334f61dc0cf2a7a15e15c2cfcd60b04f245bfe00c12d448d524ffcf8097317701e9cca95d9fce4232c5c9c1eb642eacf41b78a3df83bc293feb9d72ef69cb72c2d6542b588e29a56496753dc4181e94bc167937b3520f09a5fb6fa6a9ea07b738a73b66b7f398fa35070c01a518b2285abad9ab12a4fb3f4d1ed7c728964363c600f6123ed4f5f154f30430a4a88031e2f8c08f56ce573f0b5222ed03a2db421c0921997fc1a79d5b91a3e6afc5f08c363a0802ad6b7b1cf87d26f8582e3f7ecf9f22b3ead563612b5f324760ef5cd3511172906b2d77d6d173ebf2e48fbfb53688a9e01ac631591996ef55ba679f9fa62ea37ed500cd636a77d79d745b50d2288f6bff14f7fe1291cbc4d2b7127c6e1dd349356cc3a0154787ee71ab0efe482efd1fd56012684b001c5b7c1061d0c583926cf120e8e79f15911b1aa073523f93337f8523a17a40fa09d7505c1b6b03afe1ff852cee49cdb489c7abfe4abd2442e779a07e7e87e3726215c87519c41bd9541dfb23565dccb973813b9fa58a980e2d1d4a2d668f5f5d011edbc9057e27b1c2827e7c2658b39b0e300942eb17844b97a6c5185062a36c36ad7443faeb9299ffa1964b91f8aa165714ff17acc980cd864a80da6f6a08c75ad1132d6d5cda8b111c89f0e7a993814904eeddbe34314ce6bf87d0bc55f35a8b905cd65a08a87223369a960c5207f7a2ee0ececb6f68947d3f561594029bfcad4519f8eb7990a85e8e27723b618653b019865bf5963c10756c7e7ce8a8903fa1ce25b3a4603e6612dcaf0c73d549127d4d6283bb79a39f6374b4eae4ccd6fc79ff898cbeb08a66f0695ddbec4c66ce435c5b0fd2b31638a5a58145768a380708f5c034d1a3043ddd027e2f89221f82c54d2c9426da70e676d467b9e6f01e3248149d6c4f003481301d288ca51a98ef84047e03877e98ebce3664161a8f47edae155c9fb12fbc7fb7fe02304bb9ad31112dede8bba26d255ed891cf9175a14de40eac21200bf8052f0759a6c867d97b58a7fffd1e6b554142c71da264b76ad46fc15dad2f0368ca896c3591fa7abca8047772700e57375710e8651ee7b2919c94268b322cfe2519a6a7295258053fcd6f6ae351a3205851a7296e4ed0f6be6c21f50c6170f6a34b6647f67039eaf5a85454a4dac41fb128b88e0b3b7b0f450416ab88b3f2386716aee67477a9ca2847d149bab1aab9444238fd0068f95a28248394478a7e718d13ceaaf14c06c92440ef01ea444500c58a80ef6aaf186f88cb02892b1d4dcf365eaa3f956d9bdebe0ba198bfec4b9b1fcc9e5c1e30af3686812c7ecb03aa6b7a48657f7533d456df80bfdf8a867a18bc057da96ed07da40ef2fd8fc3b2309b5b7208b4351f885cec393ea104f744f84c00df5d1bcf01d23ba2b8ad221633a8dff623be24b033538a585897fa5c0de28f3f2b6f62145be54276816581d328e57046fd17d758ce9e2690e1efc3145dd6bb28df672d9d41b21c811835962e6c45b3856ebc33aa9b8b989b0d7e910d6d7b9f227c8611b0303860814951cd6003cd01af4dbb97771b2503ca51c95a7e8802f281a8ca075b93307aa70b48f2cc0f96a3b91d7ddbc72f966d4df8f8f0818bdb95a620ca908d6e9d2a18c9689f0372d9df5724c64eb0f9b3e8316134852da810874c683dbd580429bdd79c6549cbb45ee0be1f2789205dc18d1f966dfde947c7855aac7a682ab5c37bec1ace6b4c560b1cdc4367411235599185badd0201e0b0642b77d5325cfbc3ba6de1d98435098317001fd2313ab3cfe9a1a0d177830706756afdb0e5954a2ec0477d8f1fb7c4745deaaafdfbd2166e5072be0d4faa11fbd3042a6cd424d3b36efb346a710113bff9219a91ef8676e886b3fed307eec5fb36ca83775c9fe6967eafe40b6ad4deebfbc494a589240a75761b46c1530e6f45b984022c2f4125dfc814a43165d6dc999c715c2b30df774a448071f4abb115b71665f00cf9bb6fe8b0e22b3ecf8ed38e64f729a2ca93125d3411e1a208408db73bed90265133f176a87f11ada788acbeee2ea70b2b3f683534937e11b77901b4ec11c53508e9c2f1d85d66d09d2144789fa721d706fcea57752245a61e0562287b1a930ba1576373955bc7bcfc62cd6475bc8725916f8f54b3a47ee4417680dcdbcd118814069e7bd4f0336d606c52cd41030430a31d8bb1818fd05510a30240e0addaa4158add4f6f5df847d9ceea9b06c5f32004528c1bb4a4f23f485afe6b758b948d217eacf2ad27fb38bf3445a5758098f489e49ec0181eb9b15785fc45cd5b1fc37698d9d61132e8ca79fad7cfa4270a0a40b5bff26309d952e19584599a4cd8221bdf3d900cc217c7f2b9d4a4f7f7f1595b4712025ec6debe4bdcc448dcb49c96fad60ddd53965ec229d8e41a9e94bbe5e18bd8f8b3317390244fcf39f05ef2e4e602aecc47dfa1946b1aa34d41dc544c605bb03005ef2154aa278daf44736a60b8531fc0cdf49595467e814129243920bc9c4a169f7753b9dd5894eb8c11495d1d54b21b306c39451067aa7c61c1dcf9d8775f1f9a4f99b03960971a5f37cdff8485499329bf367624bc688c5efc78c525eed5bee0abc82f6485b7408e2c37265150123479f62e5197ada898a0efcaabca529b9cfbf6b7352a846ec5cbc1f0166a4b4a6cb5223eb29408d5ed343a55da42029647cad27a6f47174a1ddf060ffdf962f8d4e9df04faef9a1dd3bf7a8d188107c148bcca6ef98fbb313e0f92434e3d9799816d92b42cafaa3cd02559977bc663b8791641d8fc26c7f4e1bfc262554b73fa4084df80a89799b4cfcbe2498abf8088088211e87437f40ca7ae661b3372eee1f198bb32f50943bed3451bb174e7386eee4c3eb7e480a33ca2bb73297f3abc04d8fdd59ea8bb01f9f5e8dd4f00e5a2eabbadbea1fa01502bdba21cb1589c117c2052211dc6f88a4ca566b2dde07ef7c434306cdccdb717a498ac13be136bbd1d7554dcd0c6a0eb5ea492dc5c6bbc1f86b342f31b96974bfc3188065cdba2931c931dcd786231a39010f63ef854960d2e55582551455e37de49347b6a372b76f57f7fb5f80dd1efd8c43b4fec91575c8ff69967335a82a7a9134bfc18322d688ffb25937ac20fbdbda960d1e54531dbdba7cd70cc3e61cff94f1eb1da81d60217b9013567107bcc66934824891c4dca0a65cc8d655320e84a604ba7a0686c760c83af9fa8427386de3a1d49b58c532fdbd312f30dc616aa7d2c1e71cf69ee26d67ca0f0fed3acd62dab14d31232a6f69f390d61ad792899b9ff27e4401de4e27fa6f442d617d7207d21a0f0f4abfa6130a6690066fc3c85000e32914975581ee52197edc268a483c1751b28817fbdda2de25690729e0272837c9c782e07d524bd52aa3ace79837ba73f62acde50d3751ddec69a930d0b1fa83e1a9e7f6c61f446f6e2e9622626ecf8c6158374e40a8501f3618c0bc603c95707109d597676b2331d850a9df17b1a4db65261742af60022c953d27b8b2ec8caa06be02dd557fbcf64f3b4c0de4c9e91344bf43ace4d995c02b9bb3f25706b805b958bec92c0efa51a9a3a76ab0d6f8dfd902e54c185786eb09dca663a9fb8f91017b79c840d9fca852e6ce25eb502cf6d6dc5bfecd6491b7da0e0d8f51cb50ab03ebcbf527051f6d0216fd71ca789ba67d4e5823da995f48bb1ca25690e3ff5781f5996329c524c9d98c476255bff7404c66c30911ea798a4f6569725fbffb4a1b52ce015c1659a6255f9a5e4b7aa37bd4f18a95428625846c581e172c7d2047558e399b4b8191559b8abcc0ac0f50a252615ad4cca7e300dc83581c99408ee4dadef76342bac94222aa5257a84f169a9b08f4558a922773f57d1fcef2da731bb011a4001aed820b0cba63d68c787660a0e45ce5717f2386dab7f4ea39d482d834463c398a58fa7bcd270a1abea0523bfade6e2889f2d13f48accef75db365b84cdfa7f0a0eafd2c1febf49b978ac6126e61e5dc9d79fa367714df3848dad4a7176f7a4a433bf4d4b89ba918a79debab72a1ee9016efef18ec80d2f4a0338be378b4fd4438483ec2c4f80285bd53ef79c100b71949db83e9a13d9507de11461ee0dd17dde6593568f6918678760817ce329193e47f24577d843c781e2c5049db342c9d358c9291d39ae29db152389b3244c2270364fb95402c1d35b17ada29aa1e6b4ddd182e11823156e42aa1d614e6fdb75977b0c3d4c9fd68447b5f6ec4de84f2ee7df7ad4ad340454f567a2f0d5aa2d3ae9cbbf1fb5b9572eebdef95f08ce48c27e051e2891aee4470a570adc6483a8b281856d52aa80d510056de0ca34c1ae648c5cb03b3b3ae47401e366ca4e41e01021332f11cbe6a5bcda201089c8f860458cce0305c111bc1c9605e0d3ee8efb18dcc0f588403a70441fa9d55397070c1fa63b0c77ce235439ea1066646180e3cd5ede013c9ea530226b36da6681a027114f5b85453c7ee3189530550196e0a5163f1426c38912eec378dd4c93e9129aef9733a4a85dc2dae5cf369275ee1ccb82d6a20ae9ac1e5cd492e3987a06b147d473cfde7872e6f4fe9f8b9b5f49bf0bee532efea2055f05837485645a7d106ac7a5b91bd5edce2a77d31d0954a428655cf9d86250dc743418fee1dc212c63763d5fc002b9ef99146aecb56e836147a5fd0519a51dc17e3fa2b21a8c11b12b4a018bb9647cc6a8f710cb9912f0324a3b572896baaa43c9b1fe7bd8fea118477a7d627c7116d6668e9789415fb9da2786478e56e7cf112dff70b438c9b377d800df4f8dc427d528a9a0c7f58c7791a7973eabd95732c4e58c206eb9b496066e2ec14eedc46e06050ccf60ee2c3852b672f3fecff1f10cbccb2027339ef6ed937dfb46ac940d899e25e75ba0ecc11ee9e9e82636e3c0590b3207138f69976feb82df5009473f554db721718649b37098ed88b5fadd9c7ade8893eb9eb533e2618fbe876916dfa629f75cb8404f71ef8ce0cc264e8b7e4c7105333a973262c1f1383031ffb68790449d1ca0f95a7580cd1ba1cf3927db05519515230f4d4a4fdde5df4c4d63b1b86055968ba15f1c6fc301c0d8bf89f58c6a137a47ca6d3802e6c08f04c38f80e8f234b6c179e186b3e8764eaac4b795d5f54c5291141b46d61146b53ed34ae44dc9f3df7205d63e15a966121e263c78e7b14f9cb256f25bf58fa8887a07fba690ff4513a7e674dabb6b26f96c50d82f458ce849e77d46107e49d13d93e89b3e52a18cd68148c2b573b35cbb215eea390deea3871b7810b877d6c07c8f5b6a71c091878f41e1e160121fd38c1fd6f85ecf6b1019c9cf6c5de5150034f89ee6defef20f3f4625d06890e9c609ca9dc848fe0e789d1dc115acd164d839ac6358b50175bdc662da553a03e0f0c89981456f80c3b447e25f79546df11bb6f334f779585d7abb017bf9ad6d0bee9a598757ae9f9ae9d844c95be3e66191f78f5ddaa10faecb09cf0e4546a06a89f77e606c73a91e5529cbb195a61ee3eb3803889fdcff2461fabb7c91ac51dbb9f501a990322d08e00220f569774b15ea3d311b41a7ca1b02a72e2f3840687b25d5ccba4cddbfd7474b0435f223b506f2b1335dc6b353ccfdab465523fd0c7c0ddb9a6b5edee553cfa66f9842165275d7149ae69b403fc602ed7bfebdde5158651718f8d19353c475407e64e13c24628ef656d385d7b487eb7a2515ec68a8b3b489f5cb5d4672cae62e77556d5dfb46fd37af2a850b1deef283eeef6d8f1f9860e821d1645f9908da39df785386819776f9be2994389eed5043fe88111cb8ceccc01222d294abadaaa6b5d7607842fdd051c90e02f1f09d55a153001bc9e1a1423bdd7dbfce0874a4668ad1839615287039d164693afc206091d601b2e78d3c844e3101539f88b9113fb85b9825e51452012675df36ab8244dd34411070bc6b68c2b522ade80a71b0441029f0e7255c64e10d851ad9a16be791d4609f42c63d519cdad8a605b99d6b88f1c4f20b5047571fa3073ec2d55522b4a8f3c4dd835a1dac3f7b0c0608d4c1ca14638e1a062161740571b3f184386c27352f8237ef340790d950ea05a8c5a8ca4b100069ca02ef1df5a960c18327b65eac721af091a2d8803594f71343d8155ec16abedc0f09d78972fbbf772738e01d91d030102d3aadf9b7bd7881b60a97add4037bcf397aac7a530e60ce26ffbf706a205007fc931b4c35902eef5d4d13d8f6071a4ca67303c85f0502b9decbac81cc28394b58b6eecd2f60194e6123a9491a968a9aea7fed3b891e27e63c5ee9e13ac1d923b3452e3629af8228bb30baf8345157e9d5572e95366c45e0160746aaaa3a6d32fb4a5f0da4ae52c80953afef2fca6272e1aebe912a99401241f9949063aa5c28c30f2bcc7b4639330832fb1aeef90c2625cd50b742751e31f40285806cdc2220f8de3b569547f465a52f36336f73b43226ea14e548b9d967943460cd6b8657863313f37d3bc4b9f79eefc77ff5f476239129d1bc27b949e2b04d66c3d37f7ca11f90c4e367edc77873529c9778572e25722759f2723d804942431a0040221ff1ff7168f0dbdd636bac8013c515fc84e8ae11a49605d567294fc6339abf32e291b794fae064e68bba210f993a6d7da4d33147baac754b847f8915f80e2c2244dc0751a4cf55ab3511d84f8d9e4b8204fec9856f464732149a297cd93c4a5e91e60d94ed86aad758070a97df3fda96221ba587c77d9af815777823ee351b2899a8e94ad58458c212b2317a86999ccbf03f8933db5187b5026e6c0775242bc36aa088d8f5c527aa06ea0090d3ddeae5cda3b048fda6badb7251ee98c24b232eaeaf2dce9b106294fc5d21d55413ac2800f71459f5e7e63f1d1e8021b25551fbe30bafd35244298b06402aa59461bc4a339d552047ceb91442ab457e3a8ba9a611d4184dbaaed40095bbbb98c50b3e4736c58746985213f0261aa3bcf40f636879b726cd4bde7e7049e141828bfe91064eaac056ce6c129a26923d9eee30bf2a98da3e9dcf435bbf60f05df0f5e1e8471f5ae2e794096aa21958e843ba2dbf65a6f8237632a302df64bd23eb43c2026a534bf4aa117e175241e35966078eb2478242f927b0056f71962d934b3a8399155678aeecc9733bf3db02173c6d6d8105f46368b9144a6769dabbb0c887b9bbe13571576956191368a6efcfc1a050248598c76abc26275d3fde1f756c42bd071af6e837efa98246d674cc9856c5f36c9bc0052aebcf9d901ec6e1356caf291346b541f22587291e217be09638efce80c5a558471396211936efc913a53f125d16109d3484901baae2436cc33d1548686429faa18e30d14fefde54c3c90686cd41cd759de9028cacb5e8fdc73934ac67adc2e21bc2d39104a1f926369d1c14450726c41f9753caa69a213c2dfb79e3024abb00b679375ffbe0e3e471efe5aaaa107da9eb61fac98bcf2d8242fac086993d13786f18a49cf469dfb203e6717e1f2a135259b156d0a88af683aeb409c211249e484e5e1c75de4f58d9f977592aeb4356b9ed6744eb15fab327eb1f9331b555cd962db6712332394991bf2584f88f31759c84ccad1db65febef4e6eb4544ca0badc0a53510af51f4f56468b7a64fe5575aca5f0a8d3f9eef45d3896ac23c2b42dd8b116f8a9d07bc64f5f5346ca108a503f0a90e0c4d3988ffbca79f91ca8d6f592e92e7608d154f181ff0e3967a523789e03e8984a2f0bb426f79432b18d9f4c261971e55b28109320711e0121d93de1a800ff306a9e2a028eda95c65841e22c263fc31722578ce51850e0efdb71053862fc964236d962408a3ee10af0b4d69407cb00d6b02aa4620e40c21a4412fda94ebed6eebe41bb35fb7a7927ead2f3b4b19d672137b2850af214fa8b572604289081d791a0dfd5589a11f9bf40e5cf77029b70e68a4ad29c97005fb78e57d6e27f440a3dbe63e0c93fe8f59d93600c4fb0bb0c4d83b5f80ef939ffebd4dc2efeec1f4a983ee3825efd555038aa8326785cf8e304ec9ca5760321010ac7cae566adb2e29f9a0552afd84b338e62e365c79ab760b00a45c0c580527a345367984fffbf95f6e4ed8a9edade98442cab50e1efe2bc2634df662207c7a78f1f9478ae2b50b09ffa25670b1b838812dcab12f1753dab2dc3fe4c00b4d59b720aa42a6e8c1186a622233a03cfd1a868048c15a4b32e4993567cee7f5a3a3c81ba88a6aa8d2926f8fbf27ab13a863cd59787039b669454b539b5de00f4b7a4d529f1b4a307cd969dc0cdd0e340e36e34b742245a6edffce88f1d5fc0162522844b6c8060086fe45256012a54b246a6cdabfdf2e9e46f0b3d94a79a91f9a5a97fca48bfce91cbd7b7cf33bc22bb7260bb3c035fde5a1ed688dc4dd21ca0671b97a258eacb5a8760787bc1e35fbe77dd2291c89cd542aaf97d391ccac04664dd058566aba9c039ad60694b9667f13ed2aafff35af14a91e1890615668c9aa1222de8359b7ce9fdc231cc402cb477032d77bc42cdd90409c05686410923d0520be0efaefdb399ee656b80d97b6c61c116221008edb0e5bcabf85b2f52d264057e9617f50d1faddf4d63111cd4c2322bc86d8a8232d83eab5300a821077b8edad972b3620a928078bc074fb88ac0b8fd28a78967a24cb418a42f86c09ef95f92a7df38c35d485f7a8a14d77d4382afb6b1db8d7b6dbdd945c1cdcb8efb3e1e065aff8d2439459713cccb1ebc2369aa286507559736abe7bd1c54b8cc8c01b963b495868ba27e9e8adbbb7866f16fa126c8d294f978086e07a896db24bb1ba62b0325a931b7b5b36c73f2eaf82cad656ea9b791b7b835825e88cba158b90768278c9cf9f70427fce12333560056390fce4961457a11bc7c6c46aac06f1625a697f1cf719d3e3f8f089bb5e28092cbf3bdf6065eb757d1d28e5dfd7cb17430479036aca3b18e9ff4c45c4c4b0462f83159a88ef7af40616bcecea3d80dfa3749257814c9183f27c82228e3279ab95160a9d4fd7d998c709ff859bcd9edc0167f692f99850b0d06d842b1f4789314fc76766bb5a05b9a31ba2750b260f49f1c9b570905bea46bb15e83308b54e671222578d37e33da54001ecfbf10a934cbdc835fe51129ec2d3cea585f15ee90e571bca9b9266010ffff9f09c27e1faf3de05bef710e158878d41295d1251da7ea64d37d1f7d18a34c8e70f2bdba7e016b32f9d8652a2b7aa88d3ff6b0959eedc5d5b4f63f9e94967d165824790bebcb1b38c766d66004fcef024f65d3490b5043e57a5981d96ad346bd9323efda54fa6924d80a2b058c5f0fd8bf305b1745e85f8ad8ad70ff9c2c952b1bd86aa50ef43ae01b2fc5e85323d839b3b65907f0c97f1ccda4e5b3606f21de93fd738d3252b4449629e9c9d3fc0dbae83941c7afe13202b9a2a484930e1acb9e5eb810c31cb6decaae1f6afaa5bb0571d65870aee68755eeed74b7d9ac64ee904db429689823d1bb9ea10f6fdb2424c5baf29e745d19c02a2e405fcdece0116852b5a2c4e9b2495dadbfcde883b3bbeb628ead0fac8be5f8cf0f7d1692453633538bbfcdc5c6ef0453f45226123f7343ff76dd2cb7d5e26ff70f5ac221e9e0f100263aa32007fd1d40a32b5cb03a37d4d0ef3cf3f7f6ec3d940124dd890a766ffe5d4ecfe725b935fbc9f667abff51679a332f1d88c4f02da44dc7fb1c6c188e8f9802bbac01108342b419d2cc323003c9b41f548c926c2bfb5dc8e5638984727a3848d9825ca34337c470e4f30b2a189c2b5ce6fe991679f63127000b1c43df3aab6db44f5045e1290dacd223b8dad6d30e913bd25bb16b1165dc292bac1540b8d0d387d66d85c51fe86a5b1fd58db9c0ce97ac5684f95744c1f4817b59cdc0bef0d63b79b0e7c5c4d16fb46de497d9d0515a53a5c23033a992596cbb060d45815b2ef224a365277e0b224d1e99e192d3f57e7bccc672da1fb1a700cfd15753db197b7de60ba2f497564cbe444c8c5151e99bb4076fc03b9278d8e02f984bdba7abdd603a7f8bc2ddb846c26301ff2886eab7ff218400cead9cc6e55e44662fc6cf35ec2b5ca279ba23c05d35fc78953546c021efa8c3b8ff9c767caba175f35a4132bc82b80923e31e6e57ebe3b433fd6cdedba037c9f26a30d36b5ad4f825d7c5657565d892d1ebeb5e2cb8b021763e52704720cf29a0807854722602f133393f167e287a0f260c57ab920699da8ad94392bd185972bc63767753dc81521549fc7e3c01ba6ada0c0ec72a27eeb0a1ec50fb0dbe0ee5e291e22712d65cb7da2c975cfe705f5fcfd7180c8f03ccdb10e7e10d4cdb9f536b9a713e2e8eca1c7c852a3e384c544c6e1e62c72a3391108cc51f7e0a508d6cf80d4ed65005818363a8e57221d581c00ed6edf8088a17e7547fad807a429d05b3cdd86514b0e661cfc59ac156dc55e9a1a6f52b15b15df5eacde626f9a04afb6c73c596f6a7c8fd4bbf12cecd78c77f1719596df6cec7f74513c13c690bcb5b91359e9114f01d71116ecaf87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
