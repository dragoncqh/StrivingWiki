<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"257930e8ba886723ef15665755bc6c9804b45ec1fc1f99949434675b210696ea5ec75374d58bc73a2574a6898b01a38c96bebe5411d890aab41d4523f9990284bdc5bcd64923ee1d5e0e3d6b317d6b977cd2031c6bda5c457870e889003129d18134e6d694c3ad30e190079be1f5d171392428f134d203e4b3cf79f7b86f2310a681aac1d7a9db4c68d4e345b1060b8f89e1787ef137f4501ba164aabbf51627647c109163455e98891b8c776caf8b227926f5e254ddb75c3bcb0ade7c5db805a57135cdfd9acd8bcb4c0f070291748dd1dbe928855899cb2de6a4358630c7af3c6e88ede6df1d69907f7bf83d2fcd35504cad8e5a451177b0e8e1ed52fd795a86c06a16f53ac87379db415a135bc57cc816049c056755c2c707099c330cf9d8eb9061ba2638d46a188cc70059ea8c835ef3a30174d5d323abd6130573c73d378cce0a6cfcd6c0fa1d0dd40bca01779a4047f8da62a7d1896f7000b1c3b94d4d69d3389d8694c27f6b7ed99304553aac25015a03d989f31453b239f837a0ac90aad0be970acca6ec0b1a893fc087e0e08cfb1c53168977b0bd3e59c2679dc5747a162ac00a681d4cccefba8af505e41c78356d2fcb76d9668865bda7e7b90e51592b4f32ce4ae502590ad7eccfb3684f56136fd994af6e0b234d032dd94aacf521b151aa06f4f2e3669dd2e1b2b8f0431f5d732f195e0ddc1299fff32f65ad6eecf6c60c0ce36ece7b14f2942829b047e651b323bb719bec4b47850c92cd8b39143a217f91aba44b849e4832048387e29194fe6bda2bd5e321ce216e23cd4b1831979d38007d3f12552e652c2027d6eb05b54a60f55f6c280dd929eb5cfeb5778b8d24e41f322742802dd7c30d0f3192239f4789d6896bd8baf0de70977d2edeeb4cac781fca6bac5c20612b4a940dcd0d4bc32fa6e70b7f56e670c41b4950510280c2a0f575d9ba64b80d87dde00c6aaa922579a4e01dd0d4ea19cd12c929de169dbc51cff3a2091478b57e12309c4142cfde9318a179034fe987c12657d6168aaf68d02d8369e8c64306002682b315adae1f6cf3b35d19dd2a8b47708eada415d56606a0391a4019896a4d45e17fd3f986e817d2526df1e42c147b5928f16e949a22bb9443db80017ce682713d60ceddd871e682563b2712a59866a7a4d50bb0f1820edd19bc935aed6091a99ae1fe3e12dca81e177d52fd64732a0be464b76ca51895e637dbb30c34e0801ca67156ef7c52c0a127b7673a9f5cbc615b4fb8eae98aa8feee2d42a49e0d5855b6bbec429a2e62055b19b35eebb3427fb987d9421cbe76a16c4a3fbf60677e5e7117eb350d59acba5587f54dffd3154c3216ed7d5c2f1d74892e51f6a6a021d7b4fff8a455287129ce25584d5e9f059ae84d0e69cef78a191c4b3d1d5e71da6df584a1bafca167c2cf3793b0691c76674e1babd6060cf27233d5c5dcf1a37a22e69bfbca643de5b82906c8af937d1747f935c9ecc146723de7e823a5b607e1e35260b04ce24a645038b7131b21d7b84e2b4d127c0edbcac6aac47447e16d4f2c3f789bb80c19dd1e9c2a9677fd1d4dd668a39967995122b234ca23759e22c8507aed054df41473978d250fda6a0f389d03a59801b866997e09a0db97178080bc438e87d1d24e9593a59cffa104e4dd2bff933043206c0429d5a172e0e235da30a9f5c3389094edf8bafc80db00b3cf0c08137054cc24f90220acb9995942e27a29d7c2c011f97e9bd50eb3c2f0e44ac8bd982322b32ebc131ba22f0eff0f9041f8ec2f67647057fb32f19cb89626f76693ce67c1adecd6bb2306ed06e4f57dd8d19291cfa44ec9e42a36cbb6f2408c3deeb3e3a83c1bfcc93a5abed88db1bb0a2f4ff9156ea4cf93b4247bdc3e5d2874d2703d9943f92b146c4df53fe97406ce89810a16463ec47b4d1deeb0dab9718cdebe7829476b38f24f2b1a9a7c2fa9be0ffc1f1e6cfa3b5b564482b44f5d0d88bf1fcf8c9fa7d142304d9b09980b4681baa866c4abf9e75e080981115318d430cc54e930774089bc97bc20569d26edd67aebfd33078ef2d8489cbaa0d3a89e469c04da467af0baae5ac7aee80431db7086a869ad68e386256d1184df45912bf0d071dfbb7504a5dc3ba4675e558b16d01ba3b6efad969ecd4b0ec29683d0a4aa7e21ad7eb4cf54b052c95d1da0ce9a6dfae559f88770cde7c0204c7e7a5adca39efd8f6a36d68fd3e04fbc204e7a60eae53ec7b6a100f241dc201d507436a0cca8cd5abadbe3173a98536819cf651de679aa00995b609fc0f90d87625d7318c5ed002f102b5f4daab30dd97c0481db0f29500fe99ec680de946fbd79fddb65178b604139550bca8e7463f26f8d829ee206e1232c882ee9d6cfedbbf947f8c7201c256fadf33e80f59adf7b06dca3d4c9c62a7dd6f6fdc6410e8a27a4b336acd36e06c83aa26d6372835fd87c70a5d4b42880f4e41b3a90d92d360bd77bc4a4b8d22319ab5ddb906427ffb83fd780384b10b29ba880625bfb0c8d5190cb86cbd53dde545b36844ee293670bebafb6b8973d77cc8595b7cb222d03a9741a0633456272c0eca761e8fc2de5e2946f20485268ac7ed4159415cccf6cf4b2a33476e837748dc1a539b1a4539fd2f73e0322b94bbb7f494e26af7de685474ed74f9b3e996eba49e3996bcb672aea05245abacbde8bdf6610822c7b6bb48d09b84af19fa7a66c48acecf1d40401c1161e118096360c4a49960d0faaea3068fc9a4598c5fe2966637a595972f2bfce17575951ac38f8f89b7b9265c4c27e47daa1eb0b9f1856f935adf712f684adc9b2f249a92de75aaa319f913dc3e3cb95bd07472cf4df716705ad4237652469e68af9cdd6fcc0a3ea95397bf8023070226b1fdb47cdd67f43d538009614ecbc5fa8822526070fc46600b242cf5eb4630a1b0997c126f6341ab539ebee43dc5a9bba2707a7835eb0e6e25bde8bbf049b601e135419b930bf7269ec6d3bd2ff4e67957bf2389932876a251e3dec9c67cd55b84efdc2c95d9f2bf98d33cff16bd0de7527f1be8da4d1653c0c60f1e7244951ca3f9ab0ee77bce9af4ed9703f8ebb88b45d5acd19931cd47f0b199e2285b803d8a6fbc79ca8193d76a530b335579f5b866f000d6cfbaf52b4f916f67e971d2116764ae7a1dc9f225b98927f50fbccee431dbdfc079b31d3361b17e4ce76dece07cc8af326e587a13441af7db9df88a07397fcf46b88db5bc5570606b17f401e17a888c9c73d3f14a8981433fce8cd00e8be89d95682482521ed5d0b16d5485fa322e146a83c529e4ff63cc4407f8918ebe3dbf55a572e869622eaa26827802f8dc18425703f67d40f8dd26e720958446f67d5051bd28d8221ef4cc7e65a7532300dae8912015c6b2a186d4780d5d5df148f6aa82946dadf9e041f2d3e351b3ece3d3872b2304673204fad57096d4eb86b75c0254bb19564e9a182beea8921ca08126b9fb78f30912d39593fc3da5e28c4a3eec2b78f632aa13b22104188c086c76f1fce31edd15cd6742a636a9cfc7760ed87c7a7da4090663a4b737c739a37569756ac434d103864a45c98ed3be2e171e58eaa4566da39033dd1a94b013f521fc465d99256e485056df2c8e852b4ab6fc80bd965e55d9085653ccb9c0cc5e766e5e86f52327ec5906af2720f4b4e3dee4426be70f2e043a175d9b9b0f2097e98f1120ab09cd59ae055993cd713f4993398b28bf3ecbbcdca89b63a936a79c52991bf96bb2826ee56e36e967da979fc9b2725ce5fed43f00744c2af2effd785bca531f10d1567bb8819b7aed7a066a9f307f739e2970223c6be3204f3abeb656c13ca8d76d002f479c0e2f4078e338420bca7e33199e6d027fe1e289a5f94760e3db08effc14e3754294b8c713d58cf17b05a0a17be0539d3eeb02253714df170cea74fd26b3df06c4ebb444c57dd97e541c6b6b895388ef0112d1cfe0657dd618680310f86a285c0a01367a97e88e3f70f31fbe5c5f30883d90002664aeb9becccd27d44556e646e7346c5e67395f2afd507b20fdbcd0d974672b3e1b35972d538a0f863e173d31c3ef4cd186f9e65b30fee8c23d2aa077100c516082212572c6d8880a2eafb31ee4ffd81334cad74717e85a95c9eaf26e221acea8d95e3568a320d2bc0900e629c660d9e36b942e4e7e8e553055107383291851fbca85170446e9d547eefcd2d90673bb1a51ca0db69ec38dbd3927395f9aa3bd000c8a77c4e0ef2b874142e96376a11e9475adb220d4d4447694898302d870e51bc5995260856c25c10e58868f0c7421ddf0c5711c11b4884c44d5d344de6f79d174a6dc409fe72e81e811f9ec8c99012cde87755651f0e9ebb894c790abf3c8eec6298b5950357a273074a1118126bd8a4f0e8926eceea4c976b4ee4257a95811b8bbe8f88e7f593ab61982c0ad182b5f4f492ac11b83c3dcaf4650e90dbe6a99e2d7e261eb5c196e2920244e47284a42466dcfebb2e96e494b58d8f612c2752250cd498394aac4f3181c702dc00807cc308a96d358c8727af84d04e0de9b37c1c7b46732a611583633eb41c1355f797982dcdcdce0487ca3da3addff1c64b017cc998d51ac35ea2bd18757bc24d1737ab557bdffec68d82e9bb49d0316e3c2604b33af530bf9a4e1b2868b72c91dab37ad94a44fdf21218d07c65e5564852de93dc3819365e0e3b7a5c00e3fe062df15cc6fa604c691b60ec169676836d85f50f2d022426a1e5d2928ea89479262f78738fd7029e7880eb986ac0a1f6ddd69b7bc7a65a25fd9188296b5244466841fa21a27ff177d6c8ca4f73e07b8cd2b74de7f1dde61f795268f8b533a08a8a241552bcde71c21d8fdbd71784268f529824e920473496119472f0a98a85c87db857f699541d61d9e476adf7e781a4719901c7a2ad2305768cde8729501745c51769aa72cf1155a9d22947dc3556f6d8b36fd0a073a5730ebc4842a9b6f65195e4c2d8c6ebad84e78cb9a35adf61ec9f669de9f37072bde6a2a63126f7693b5b9be5f35d4b24569a7d0c0ee559bd5204c18757e445928c30afd93d31ae5c887f63f146a27ace08af3173f08641a0d4e85b8f7d9772d80ef161b25f7d91df81c12d3a08b44fbaa3ef4b3ad1d19f16bedf8a5cf069699b628444d5fcc31f69190ad5515517101154c85421e23bded4cc914c584aaa6dda1c9490e4cf432c4fb3dcd68429d6ab78b73cde27ef558ef84c6c965aea5621f4c751618d7e749db7b14b7ced839605dcc174c50642ce4359db34fbd111b74ed14deb2beab55d79afd2ae9d2cec901685d09e1f9db6dcd7fd6490a1ed09329f3fed50539532c2f85240a34f634f52433289435afa5660d73ce8d04365d7e4858d2c5dc4551a54a9282165a0a598457d56ed8326d4ed049d87993ec06cda454441c304201bd2fc645fd7df0290ce1a778ee967054c01e78bc7b52cbe6105de8d21a039a41a07b524bb39750bb82a4609feed8600459ac3b98541588f5a671ffd3eec7955d7e88ab7aa6b5ae426679ffd1886624b945755563347e76fda6b7ffac1a184f58e26aedb0db167ea289043a142323ec0ce99f53d33a5fef4fa6dc631a1717071debc3936c94e9945c7dd19c45b5757e5f71b0bc9804055a235a4a38584a065437b468ace64fb58dc746372e0c8a07019676d09fbddfc545d3655995ba11569b20428c827521de6422df3eb1a9800806581a0c929c18d004df676ff1fe6a49bf7454b9710ccaa4f97fb74d1d34e80ce84183784ad779a571a5a7bee3a3d55842aa275a1b0448d2f6f30770a2a931a72176bacd22578b1bc541893c20cf4c7cd9caa7e10d674bafca8cac92a26f9a95ecfb858c0c93d6643a93d71aa46cb11604e1f9f270b04b5ca7eff1e0de00d6735e68769fc11d6e2d7d4a43652e5c3a7bbcb21c9aa8729e16f1da4b9008475a86fcb685801222dbd2e64726deb4ea9a510d569df698fc4b76d53a87d31f5101b28c8841dd513b92b3c66a553c5a1e576d05a36d66fe4ef2efc95f6cc10e3c5a8dba3366a68ea049d0942469c551f88cd3a1c1dde2ddd91f492f8121ad7e65df7b2915a1113a70e4603badaec2e8e2dff3cea4e23dcb930a6b59543b34c1027d0ebe0959d8018952f92da003fbabfe01b2cf9b2209f076a8d12b387d91d43be0d90ae69dbaded05cb875fdeb8ec2908d2b54391e3f47d952d459447aa2e848a8d88b25104fa67d08c74cd9598ef65d78112903fe0cdec956efd8ca2e3d5fa0674bf6d1dee160c41a3951a8dd258763ed13a40cd700d748c7e07a14584cb727a2a27520760ae576d8076f7a72acd3563713545cf909b19b8483cc1016f5a3f6ce267cf6e40b3444df635653926cf1e61e4487d050267fb6dcfa2e5534767c688af80d6e8d578f62e208986641a5306dcb0674fe53ffd5899c8587986cbf34f7977ddd065efc0a4e4233245f7797f35731aeda21f44861aa33a447f761aaf2e89cc49a2cc4126795ae9579401c63cb0772e8c6b5737444ba12f4225c867aef640df127f40fc8c22e7596cf6cd9d089fc2ab3b14675a4758176f644ec2fe8c6fd0805ee9095a09267cf668986c21c8226125a3b81e3efdb4ce4c52ebd7d91e8faf6f9497de536a4fcdc33b04e97b1daed66dd2385af621d4edc1dccee33a92ad8986f2a7198916172c6834069d5149ed0f229154286b916a8b38ea27fcbd2abcea88f8910494b92f2580c43de483941a628e7cf8c0f34a8dd66086569a43e8385e1025899ca4c46fb4846ba6ee083c7ed3501669c551e6e26ff32873a72bdb850c5fdcf698f4d094ed86c0247ee11a9bffea07a7230e2947b522019b962e9ae3ad0b82c3b94207f5ea98e26ccdc7d82add69fedc2e5dfa2111c6b6eb1d355d59c7beacc9d30fbe0eeee69a830a636e1671ccb67eb784b8381608b51801c0bd34cddef7ec2d385196536c0e6fa1a4b815c8f72e843cabd457712e3810f3275ae6caf9dd8ac9f233bbdc8a099cb89a16fd8729d1b6c3b74eb1ac3bcff0351557589eef575dfb5d78607d323e05a6569edd3b061d1c9a44d65842741d1fe68fd69fa952c1b1ce1ccc0cb3c46d5849a06eded5057fb9cc9691a71f01eeb9d5ef018af8c7144820fd278ebf12726f0e036ef916d3cc5e8e15eb0d326d55a50c112d5536c0cdced5626374f15e2c9557a451283324caea6d9f4d12181b34b3355f1dd75367e1a667a980acc762bbb666d74839f445fba933ea39ad6a78685c063fe83d56185fd7cbeb3ed39ac94d70d6f9ea3f45d8e8fca84db67c7d3c864e9e24cd2dcdb1b6446e2fd14118fc24b52d1ee64ed9dab3717be9d1c1ef037beda91cdcc2ac828f7794f03ab080420ad81bcd737f412b140f444604b363dec3215e48ffd88821ee07318bcd6e0902dc08648a42046c8f0aff95dd2a4bd1df673a6c31a1daa8c0b0767c7f1f7ad3c5f9797f948f04ccebb125d800f28bb005f5533b1d753a0c5a36d277848e844f31e98aa2f29f792669086700c3e74bf35f52a417039e1184d28aa92b6e130abdfd598076f2fbd4aafa49843b2dd61e4e328096b98a8c8a4ca9c68ba28faff56ca0b3d9e5bb99daa262093fc43883284343202f15d9d9176a9bfa451506b57d888becd671f607f09446d590dd133bfc6c5aacf60c3abaddadaaaa167256026489234e1bca703c6d7610ce528338935b278f7fb9df77830a7e3e87c4bcb466af9051d071fbbe04b28f09493f6c82efe4e256eeb7050e87beb200ad006a0b77bc0bbc306b3d101f1eceff248179b63f97377e87c1bb25bad7e9b814fb71466f16cdf79e651074fb844c29bf8711f5dd0e3f8c5da1f9f2ee5052082f60f0a90ed41eaf933f5f708c41ae628605bc86c0068ea3250c9758fb90e40700b453e57c1bd79f2a86ed9c48fa9d6739165ebccd0ea196b28dd7dd4f13dbed671bdb5ce3b6573ac766f149c08ebdef3f4d03036c6e8ff885eab7138ba5f7d2e7aedc451735d92c2e3cd11c72bd3d06d9ec8a30d4613e04620f3fe27e37aade1d683e042d4462d653344ebdc23272c7683461a17c1ea8663763e460770fe64cd41d7676a0b1fd5d6cb7beef827f3d714cde9e67647991d40000dd85003f58b411a5cb6ec98753ffe63311cebf729d64b1496f2d37e5e4e994183d18616306b830bace5e5168c370c4460d6ef1a3209ea272054780d26107bc99e548e90ac37c45844de612fc6e6977bd925c0b8ecbc8977d116d3082c7edcbdabaf8d3f1c8d02531cc1e76a68ec450af310493dab8aae232a3c82b722a04fab9a1bf3a08586778f949bf6df9afd397c88e770fd32aa316e685d2c584dcb2c62425205dd23d3e700a9ea73a8e85f3e464a2852c0403efcf3165fbda35cd3934bb241b6531bcf884eab00fc835bfc4ae95f78ed1be34ad94ba819958902f0859bffef97c55f98c8dc132db8de4ef45bda2763d7df38e3e8a722661a6f663cc05aa46a61dc9106924a57c5eebda6c32615fd549e53c4898e9bd4c5d620cf541badcba853d254fc46ac25393bc2004653cbe6d888d0c688f28d838f24bb841f99f6e865bb856d644f8428536ea11f5bd9f607e6da24a533ecab50797213e73aa40f1627f4d32b40338f63bc8db949fad56a22488c1d9c28e2c69424836e1a3ea8dc562d8d43cf7683bab88fa2805ea15a9428fdd213e7ee900b29e5d6e7871df10299cd221ba94a94435cfabe19ad0bf9976c0a379922563a1ca2c7fd469b43484a0d28b6e04e32e37cb796fe94430350d8fa807bebc24042178369379448f568cbe8d8eb8df51e2dbe33db3d808adc9fa3acd50a4230e25ee02f0c9e611ee51b2a9e674740ca79ed9229a6809302715ae368c30bbad2ee6eb5a2882ce48c01298dd007aa8fbe8451f6ca376c285a5c2a4bdf060735987b6cb62d8a69b689fecb2a7e864dce384cf01b4f64047d1a7b826cf08a2b1592399bc7119365affd0d5f23417525cb94e380f6444a258545ce55792581166081a4b38adf225c4fa81853d19d51fadd9d8d990c1662534ef3ba419c3147c3cfbc5ef977ce738cb81dea36d0e208a7eda7406db3fcf8d5e1d62ddfe48b0afa1cf5e503b71c0fb5375ca9484d1e22d12ff3e84c1794d36743ee7176237f36ff67b1dd9979fad2b0bb6cb7e7719acb1bc6bb3c6d6bbd1df9baa17a38c2fbf994cb18a515b47a7b745da1035c05ce4bf6250cdffba7062305e375b5bc865c7a3c5c17f7505d81c4808416cac5829fea14688bfda7ff3b9f2a08a5f55a51b5a9debfa482dd1bf187879284defc81ae936f6c01fefc92ea2e345411c3e5abe261528a44f83372d7c5a333bc0edd88eccb2e67c9afe0148adcf6781aab2c2f5f7dd09a8bb9f8e990d00cdd07a15d8b34a57fc4743602c3582a6d58bd881ee224d32eae9bb5bbef5447ea422974c371f98c75ea7a10d0f85310b8cbfba53beec7a30f743c7ff7f6dfc061fb9a38ab929d6490f7a4efbef56a1c69117b95718b9b4f36ec2121387316c7d37caa25bd7b7e22dd3c319f6659fac571690827d6d311046f277ec19536170b0c8673d6383bb09074a053d79c181698a3319af3b3a19745b0ebc2f73547cf0ef71b1975ca45a96a4405c1ee6841ed022943c49af067c3e65761d83bf8a789d5dea6e172856c5950a2f7b7954cde50ac657817cf051232169eeeb921804f7d48ab7c73c0eb9f477dfebc2d5e0f9f411c6ad86344982ee993cac34b526a0fe94a9e1adce8f5f6d619a435ace546f43d9ab039f5cf80f4f65c98457b6486d2c4b332dd90b134a7715f4f67cc6c6a8411bdadd70b294ab02c42bfde85935de7b884c459bee4cd41db048d897275f23767faef33ca3d7b8a8e550c3649122384bd852c42858fe5c0297211447e3fa0864cd2de4891edf76e8143bdb977ac0012f6fcde349772a0dda70d3caf8dbd85aa9cae2bb71574e8fe73a6d60433e0367e0b4400c50f2cc380e6c6d47268c82fe721a6f7bf11389834edd416b7932fb570ed06390fd6b09b529d399c5cd48e1a23c470df2634ecf8fcec3e0ba33384ee660e967139809","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
