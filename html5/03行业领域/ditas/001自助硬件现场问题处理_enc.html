<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7278803b1341069ce7bafff26e3f736af83af8b41a845b7e419dd98261bfc848eff69a2404807172727cf197204b35288c1934c85f957ee356087dfdc9e287d6a0137a690733c24c9b7a56f5059b4d65a1ace56ef1fe8073beb45f12800c5e2bb87dd1f8fb228e2ad3aed470ca3df420192bf49c7d46c80c1da9f776defe4a38a8a58988c2951b4ede227d217680ffc558fca39aadcf382d2969a1e0d2d59d38ceb065e19c2ac700f82f16b132181ce8edd5e74cff6fedb7d4e66fc37a24d810dbf5bc2d261299f6944c6032d2f2dffae0a3fc2a6ac2e6ea749d08f25b45f7be378743fdde18a4e98d5e0db1bb2e91cfc28e4ec5bdcbfcf2b23f90eb4aa6a7af45128e73e9d1602c0630cf7d7c3a3af2c99dcf790d42b431808789f8ed468297aa2597c162b6158ac5b399fd0c30e5c5639a7ec779ccb501aaab11ba0f6089bf9264a9a93eadd9cd22482da669a029748e0bcce74bf0441618f81ff704e956050e3e732334643e3d7920c635c1ee998a1ee09f1b6b3d1faf87deceb7ebe0e0cdece92e10923af9138ac8279dd13f9629810e3a1728fbe2d541a6d481377a680c4fc157f40ae51a99d1a97f2136679f2bcda95eb93fc33572657dc7480ba040a83f0df5f28a0f45ba8f6cbcfefae8e34c78297b936fee0e8c978e0c6beb86f70bc9dd7ae39544d0e3310488c887580512d691584df7b97dc7dd8125602549ed0b11727963b92725fca8f9faade224800248a0746ae302963a3354e6c406785a9d700f6086de1ddefae367f4fdc0d6b28812aa2ee8e4f82e98701c242c36fcc6e29d53fee2ac130cbe27b2596cddd07f5ee7777bb8bb6221e1943fbfd3e9464543f14e16a27453ea2b592910cce51db73c86ab147a4392f4b1bf07d41a94b1669e95ea057631e6899bb0e8f3f356e9cf40b74d14a956d46a5895bb633539c4ebd5df51df9a19c4ea3ec720ac619a4a3f17704596a330f124398e34f921720f340720194fa7c1dda73b2508d34266adacf44adcd271fa98179db0eaf71ec343eb361240be39f0e83701aa4f9ca84bbfe114631fe61ddac42b80b30db31d49c6c674fa99c76fedecada61014423a5b854d6c0d21e491a9e62d054db82c5698ed5a001cac962e986d98e76423f6b70a536e7bcd517555bd8f7fa64cc76d83f2b87c690d43be51d5d3e3da3421679e8126f2041c9c85179fbd75f3f628748279b6c33d6b29f6fd77acbf6d8d45253630228bf9109ec08437c1958885a8a4c1ccf85ee0d7bc34e36f656a9b379c858249f0c7ab1c9b512ba5bde48bbead9dd28dc2b274b1317e535115b4e7ef486424588c26f8d91150f4df85454f763bec56681c8f6f63747097028a7e9503aaaa670508513c502fe8b266bc074994dbd02f111d0012a7685cca5b66c48dbc3444409122247a4f4601fd58aaa711c04f29d1723ba52d63eedcce9018cf9de1d6b855685aae65803b9ffc04b551cb47847790c043270cbfecb3e7d3085ab913378669d363e55fe52a6aa4c8d981763738fd013dcab4f202bf95ae904fd736976022def4dba34fb119cecb7b1527ff7cdda129ccdb267bbcbb686ef6afd2c0817ccaf6d2c913dd0cf558041e45424fcf8d7d63033fc8ccdc09f20560cbb1c1b7f44b38a59d85f39b7046256c220e4c94ad2d2608d6752c8f995305fc212b1562279207720eead95ff38fb45ae90343c4817a5d49c8a6500911ad2c45e6ef297b903218fb4b5d59289bf63cd5d24fb604f12051584f693ee89f4ac465fa528b38e17acd07b406b6c57cc0cee9cfc228ad62842bce17b49d84c3129af96bc058bc51b65da40fd7d307d243e9d9aa2b3a4a2492fcaca6026ca4ecbd8c3e53e0dbd7390996c6a67aa5529b7cf4ed48f862b6926374f5e57b5a27ebb207e047b4ca0f5e892126fb196417ea1587331ac999c3c22a9e9b8a66154198e19506c089eeed0a2f985b6a13aaa5b51ad075fa67a573d35fe5a52cd18a5579ed5c402051d794efb83cc28be86c91d45b62bc244f4b4e73b1492191be618bfa3d5943a52fa1c9eb154d32df9e5aec11d5e0e17287c015f1174cc1437c7e5e8dddc0514083916ed13ed04ab1762e4fb0017a58379de42ec5392504d1fbda74ecbd4a51cd7d89b9c65ebe122b9bdb14a07fec6ead322bbecb27d2392ba0f06ba5587e3b634a0f51bca16d20f15c7bd2909cf4e9c7e9f9af18217b54bb785f988cc4384e9a6ea17a1bd3490751e835f58a77c9020cac653c1c33ed6815b2e90cfa61ac8e873e0f1593b1abc38b21b6ed735deb6de2c61feaaf946808a3795a64406f048be3b602a369556c511092096f3690a18d101be62fc70323fb8408938da4e89637b99bf6b954f3f5dcbecfd8f540f8d99e1edfca1cc1e4f403927a1369be38c4b89507fc0516970d867c1a24fc896dd64e9737786b69142785788ecf141df323b02c84f6a2936818e0d40a793ea546529baa9e9215ee0788fe1c6a5902b7c2b84cb5b0620c32d6c76f4be51de1fc534719cf2bc85ef58fb1d4dff9e74fbba5f01cc143628a60bad1b68b576b4bf0f3c50212955f9e44afe0bbe25fbe72d16e55a92c56dbcb609a31ebd93e43b76feaf7c76c3c3fae302c5066b04b58bb4683e09ede4ca1a3d7c9063c5cf720cc06bd6d333a1181a4323d740e2473fbf73b134569adea71dddaa6dc6966d309b9947f5690e697888449b5f3ed1a19fd12d545375aa254b31f8167934fcf7a6b804b56fcd3d93fb9282f197fc1b830176a0bff341a1f2232bf71de4363b4507a82d2809e7b7192d5034fa5d8deec5be38538d178b6ac00e5c4352570802207975af4f7c4b83889ed5805554c6cbd595b4ef5a3788399b398d67b24d0499ecb7c787da3a7eb39c4b1e28a94fe079c064f6452ed4792a10377141d835524538ae4b8e55d1e5cd76a37cbc5d3f7a8be2121f5c56b5abb17eb9f182d804f96c94c23b062cb0feda1fe9795fda64af7a286791983aa10b1dc4dda6c9eddab785526bb2f8397922c564765b99daec17653e6c5d66edbc7e7ed35960fbbb14d1a2f0246b2f5b2ec0e6185b24d8f939e8faa8de175403963a23e54f6ace9e84aaf8b0d74686b1f66032fb343d6da1ce01de70d773d38dbe62181ed97e81a96fbe5da6a73f9d3cf44f3299f1de0c3fd47dd26b4aa3453a99c8e05aab3ebf59a12c7270df8ce55d7454ab0120c05e820033cf38faa3ddf07e9691d594443f49567cbd364193345e41d6a5e374e3b9f4b9705f4d17b36e9f994a86392ec01448434549f703845e9d5c991a80b16162bd0aeeba3f1560646170a3e670f3860a60fa825ce1cd340af2a7b6466e40a640e9e6b3de4683d4d4e975a9e504209a6c56db471d510c32d325005130b787b41e2cddf009017a6ddf392336c47138a6da1a0bf7319922ed7225f4a4deb7451b72fd2d4c56ba9f23739e2d1c8aed870a9e9e6a11f8043f6e13f3396190951a13b475170a85a2e0b2f90719231493e4c16baa8ccb07603a3260b3fa12c8fc67f7d982d2573cb475a29fe051cffbfb11f254a267a8d10cbafbe71325b41745efa3ca51a90e62d581ba508b500e5843b6465a4517bea20a3d3d75bd3bf59798eec220c1c6f106ee112efab54aa27bf83b07a402b17df503b8a8a87c47d36ea676e38de78b579ab92cbe2a122e46dc67268a5322cf8d362acfad00ebd7fa6853fe76289c09fd45abb6b4155e445e677233f5dffd59b25021d4b7f001048e48c70a0120d59d79ac334413c851d20e854f8ebf74b6d3f7caa8b8f358d6e818b613d6586bfb514d109c5d0cc2a2b5824b7dbe9164178d5468e5e66ebad026ff0f998ce2a49e4be378c293e13c75cc9f9565e02e6f3ea3abb3b2e08027ae17241cb0f7e7311cdd61b83cd7e206438761cdc212628098917909cb5c8ba984111ccafe4c20a34971fa3d11b3f24bef8741f9b521a6114864e75f5f3c6a79078b633fd3a5c7bac4d365b78e19bd44514595bc972d3021b13d6b41d771ab96b69a0e945ffc22fa92e759194e4a48fed61c9e139c3cd9112fa354da2d76d967ceef8a96a299a3856e07f3b768bc1ede981ba25eeee9e525740926129eac75f250e12b097d209f94a1bb01b3bd6f46c3abbce39d8d075823360946e0410117e3fc08f0be48277e15e56ca023093150f904fedb425ab43c33227daba70f4132958e7585f882cee6c9f439f9174814354e23460fe591a1bfbbefe4c43aec4166cd3f8599fc2be6a9861253fde216f8046baa99f9711dcf982dc899cad7b1285dc3b73d39697ce45bef167751f82ac785415a73238f84df1cffbb0c7b828f90270b801cab1b116a530c3626633bdbaea61ec0874ddee5d3dd5add46f714c79c13a89f4d6c7927e8c736cba1bf252ec11a7313ac03ce419ab1c2032e78da2475c8939f4b4a5a7efdbb2c746feb33a37697c559427ff5ddef7a901e842428e600b8ae4918e0ffc1a25acb4e95d89ec450b25ef5c3a79b149a0807de9b400b38a99ad71750906225d1071e326f747f849b22aaccdf4edbbfdd731be00d861ba2a4ea1a79ec04c83f68434e85bb0bda1e58244898b718773e6ff9cdf22dcda6d5d70e89a38fc09bfba3fe156bab7f20e2dbee1a3dff35d4865d4dee1bd1350864ac247cc46e9484f2c663a866a8b5c141d7f997de660c9fbd1e77306606473d58fe4d71c99fe6c1a4320aee72a80be55e6f5e9fbd32b4716b37085099881a8cb8786fde6d9600ba29a1a8919935846c88565495951d06dd1d94858a6c25de3e17561208de33494687dccc53af10b5c42bcd999dfea2f00e48278525875cc1ce3d2bd29d606d7169d0c0676379d8ca979616b03bfa512087d0af067c5a27ac084a209702d855b499acce2bae28b7287b7af93687601f3521f71380fb5a5819ff960ab622e294d5114307b7eb59c11f5e7e9ed179cf3889ba674d553d70b029feeec21363a7e33f44dc02e8005084a2ec0c433bc94db03bb25b75cadbeadc7e6f1f4dcb3dac17460eeb28e6dc70ab4bdb637bfeb68ed0d5928a160494c08950ffa17c537518796aca047108a8df94ede543c4ae43592024ded81178607a05237d419eb53ace771ae67bb70b803940a2dbc9acfc9391d70f12cf3f9ed56a9ebe3ec89d6c1c3591c5f65e0010956e0d6c8109a2632eace160f5939bfc4cc75742c11e5b76fd9e7d5c09883701774b4c29c8a2f7a4e18005ab38c60f4bc780bf62f8e33e47e6a25dff8ef3a68a7797962578358f610a95b53d8f4adba592bd13cfd79edce552b4202d131efd8ca0cbca0e41435cc41649a256eb8853579346902d73e0c45e867c24d4e0aa6acf5c583f82dcc901d08cd9820671f7ef21dae3b057268252be81e7f048f75cf21e7633a2fa930423aa9dcc5eb9c02209730a52d7773790651da865571bdca184a8d6fb968ef2f82e0f1e29383c28d36432fd4be22f3d43f2811217f475b7e83ebfa5f09e0d6d41f905f101d2f8ed91f4c9c5ac1e7452b0220186284f46420e9c50a95c19f43a33381cdd0e1187627416005749c4d183423c6779ecdc37924ebe5377108f84ddf95595ed02bc84b408c7c3e25426888cd9dc9805e40eeae8f942511b42f8a4d73b33857af262a2f5afedec4101e713c56a396c58c12d5d09606a4cf59d3d26d2eaa639ba4b958b9448251a0357c2ea83c7564765048002fad0cac5bb3d2df8a3e63b1fdaba5a36bfa6965283f2ec1d08a323bd09a69f94df95ab603320d71bb458742ac40c5a2e434904d3d3d1f08ad3eb9aaf01284372eff6055d121fdab05b67cfad8a0e790211fd0f614d92bec8c31b304755771217dfaa062f868770a4678da5e603a7d00b4a69b06157e9025d19738ebc1285d2d1d58987089f3b80008ac174e65c3266450ca05b7389d35088778d5abbe925433082e964394d86c63c9f18fabad3f4a44851c5b93976002eb7d8e4d63783801d134a68c8df014dc1ff3eb0d05b0c1e6d326cbf1e17c1c8b6c7b4e4882ff3b2089cb2e30ce59fccc10b4b26d1ad0a7a7f0ec6fc6ec521a8d6806a7d49101f24c12ba88bca83fb252947e6e6a9d59cc2dad5a8c2b1bbbd866417cb6b7c00de3cfd7b889be315fb5d40dbcab610820f51bb43c1b18325175b47506152106536665ce3b47c8cd9e258b303b039ba6854c75c2cde942a5686f9bea1789f7da19954259041ba9c898df5444e1be766c581afb61a50942ee5b8132a07360de1def93ada21119642a50bae6fbed983b83b372a4ecb5248ee0b72e23297ce79d3c579c135a989d3cb5f70544165c43cdb4225bd7c0ae85bbe8d86e83ec4455d93c745d456f6cb7a8044e92b656a4a1f607d2754eb695c2350e4ce3174c62b496c93cdf3d2a9518337f8176bdfa63a29f12e0622e40dfece94e44f44be3a672e36ad0b09b5ef440acc5275d0fc40ca9c8fccfb325a5b5ec1f0854dc5fac8487abaec3f6102726dd0bdccadd81482e87a85794ccd57765c5c5014d40df8d8c7e7da1ee5d07e884be455d0059d72e6e24593","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
