<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d22ba3a6f74d47309e0c4a87baa4c6ece030b9c88a69db25861e180ccd9287f53230630ebad1dd5d8d32bd657a600844785c8b35f2e8a67aa4ea8d24b2102c70d5863d5cfe12cb00379073a9217788ea202c51da934c38e0c2b697a8594783c80499500ac51ed914415ac9485e07673b771c3b081ed0e08c9633213919444f7be59e7a7d4e14821bffad599035eb9d951cfe366af10ac4c54ea3083ac6c804c6a0289227e2f3ecdea6f59eb083b831b3f85d7cb44fc28aaa6de413e82f53676a0d0e9bd64dc0ee105d39de1faae206998a15a353ff056cca78ca5d71f13ab51226bd510fb52305e4f7bc4d811c986d85285c599f0d2b54049bea0e9adb17dcd2aa155a3879c8b4b4de97237dac2f275bae7b5827e7c465ddc2000a1c9423f68eba445d430e2b59388c0c9cc6372cb6a5ff0c16fbbefb6395c8a9970aa4bd9ab367eca3f8280337ffc9881148d72560b481f589ff5e23ac017f29f30cd26861b031a8f0e53b376821eebee627a8a369c4658c50a5f35904d9941f11935a8a260960d0c2f06c5769673778762f096eb8715ee0ff9012bf0e5fa2151866b73a125ec6d0a1a54443a04ec2ea5209bbe696d610f17ec7d4efc9d223b1de542bdf35678aa9669f0e16278cf807a068177973ad872c712fa4abbd7480bd897b30cf1af3caf8507966cd1a7690796f3a16493bdd1f3d11ebce93b1e810b8c120cbafa2a72b957c6469386297bb54cea842b2e289fad123ddd73042fd4d55cc8fa5cbc231bfcf2ecc9e458c0755ce7b26fae88c3af761ca931265c384f4b272171109e9bda823cbf1f3634db37a361d2ac0fc035214587191865baaa773bd69e5ba1e968790564c971179067c9b8c2bc668a71b35eabf8ac06f3bb30d71051e9c93d522b557ec65d32b1d8d8f1bd090c18e888ef300fede4aecca390f6a271f0b2f309c8c6a45e3dd0564f5b171aeff653ac1559ac1e5c4e8babaf16b3f9c1f776a1557425d0d553ba9267ab0649e66e7fba10a92716322de2fc734acdedf869125d3d53899da8e5dd53066fe80d92647ab4d411ae304b49a01a31c0d15e9795682ce3337a0203cc3341a716d9d8f5a090652fc8024a9e5b3415dceda8d87ca560ac141fa100fc7c4e826805375f878735d5f6e5d81c4f64362c93fab8ffe5f3ccb917bf6933a9c176e8f37e922975597f52e4343ad2b60c12220de70b6a774630e0c5b80448517baaab8cdedfbdb637688c455179d230c47a379c5f421a764bebff3a536703583337127969fd73a61acbf6d9db50099f9e1c56faaae4dbb6162d2a758d8f0f3b20ee53d9b5e2856bbee2544f414cf28ebadbd71e8e6ea3ff910675154b3b70eb7df437ca868f3f88d6ee48e70f090c891ac6051c67d240dc137b0fb3f1528d75c9402add7283fbe7920a659f8371fbff326a8c52923566a2dc2fbdc268a7f261566704638b934124c4f2468046680e04365f5161ee01283cc2bdc9c995d216889ee331866a9329624568951851e9afb3ec365ce0db8b49a43cd86890f023f25d91b66dbf5d0a5305ff50a3b0e3e9264a939354e94e90cfab3434563ed27668a0197905030c74ed9166b268833d2a1d93521dbd6414467b6a3e3e50d50448c2c1f39002d91e8d9b9fb120bb065ed061f8e4afd5950104755f55eb3324fe954bf5aafc08eb156c6b065f2b521a5f3f1e25c384e49aa1326ae9bdd11da252fb51648fabb0c78afb97b3c984bb1496123c6dfb472047b6e536df34dae85e1e47dfc9bcd97141dd7d830d828a87c82410c4f256e88114bf01fe3c8ef28e344f53d952539f56f444eaed4d914c37481c4c14317410937c82b9cb4e74975bc81fce14a3207bcbdce9e761a813a4fce7c37e30b1e965624f8ffc127c4d0e51a2ab5f46772ffe5374415daff8c1064489bddea8d44905fa1b846bf2009dd9a4f1a9f50ba57969a34b22c3f316170903e8e39bd334dbc878155ca481a0b2a295a04e31397bd18baedf18d6f4d5b123ba3867297ff478f4540a5bda660614f55e332413d391466bb830f69d84cd0785bb17b47fbb8045a2fd616f287d254fce873f0031130035ed74b233b56ba12d1cbe1f794b4154b3f121e73a6e0ba91dcd82a3dac18b26d56b03187293bf525f14b14777fb84e2fccbf57180e5cacadfe3ed25c2c3ad29dd5e567bab471ac0ff70ddf0679cd699b4115818a27d1301d59a54e0031bdb160aaad821e64cb768bc4ea34c329a0e0a9bb503c1b273e716bf1ebd5d5ca28d1cf1254b13ae4c7a99b5317ffd047b0fb5d94938b3cc74611b976cec10d685a5db8e677c611e1fd7369fa21ee1d4ec93d7ea5d8d55ff119167cbc52c35470bfde27b19a1c40b31f39130f93f6df4e92d445ce3fbce85dd5423359f09caf450849df3cce5937d260824091788097d920bacf3f1caef5e94194d3b76ce6cf4ac8351c14ceec004e0e51ccab765692d91f8a2c2ef8d25bf7d39eb204d94318adee087af37dd7963a15a88734c684ec0b760a9007a281c58ecc3ed075f3d74889752290d2127f4f80c98e6d0c31d4f2529666dc68a73e4e61605c185d7121baf0cc53ec6b25f8d51bdde09458b1c8631c9a45ece92bcb6a23682631ca431978e15b93378f34fca5b9c10023abad4391577e7d07287db3c2958b40f0e1d372cd66f182a7a73d8cf9e41ecad05c71d4f1f678761a3af533149cdb4e8d593dc70cb72f3e3a6661ecf187b9b875efb72910e2598b307939cf6b4399ee0470768b98aa6eb886477f07768902c1fef480d491cb1af9e85290bd5ff3b42015d05b0f925c05e63cd12fc67e40affc4076fc2bb33317c481f22a46a5c48b14f0eaf1ae00c790e564826404a3ab8046b460a894999a592f07b69808f0d4de73c98db599fa32943789cb629c764c08c6be7c8d8eb839c39b10c399faa6dba5892bac273f214fa58e49163bae149965cc1fb02102673e56d21c3c7efd8992fab57cf070b2ba7913e745d6e8ba9a8b2f1e58fea13f737518e5481f83b53dff4e7a26c42a77f1f3ac56315e6b527fe697620124d0ac134fe3576287399233a536b70905b4e67025adcafc279ff9d69675ae037fc213fb71b2a6f67292250b04d3f59998aa4e317e7b0db901d642a0229366ec2ddbf8989f0beae9b199d3492247a5d610cbd5d1eb10f6a2b796a2f522e834753e8eca662b8361c7691ef58804a0d376c8c1f595d205b593ddf5ff38a84c7c1f236a73d9dd58dbf57dd346d083001fbf31e01a339e3612d1ff1862787f30f8970012198a9b9f96c6bdd743cd4d18d6ddf8062c0d0ff85dcf5fb0a05b842d37655aab32b6a91976725879738315f68174d4ce503fa4b8dc96867b2fb7cf3fca16df033190199bd40b28daf27dab3cf937e2e021acfd5327927129c6e731fd9de2acfee4177194da72b325781d2e7e63009fbb95f517eec7631d6a509110790ba26b9ed5a5e4a764e1af4a07e954e3981fb25f55227144514cb91a2cef84fb9196fc24c8066faa46af396d6291acc31a6409f4396e1b2652d62df81a7eb9adf92047542679c84dda9d9345a570675d7ee6fac919389b9b1d0e830ac42dbe0a3b4ab0778dd586d27ae788572748ebca5562da8ac476084032477af16e4f1b815968d9a87674a178f738ff7e267cf64a22810bf0033769e701722adc1cd8750c98c1b1ae510d641d4ff229025d8680295ec7dc49a7a1b6fb6d26bab56a37839efdda58ff9ba3669f8e72fbea83ef476ff3876c4e9882a91012d20f3b2cd22bdb305aaf5810241745eeeb7879d1885df1dcc92a88e0f3f8a4ad2e6b97b712bfaf1639d786e1e9448307b93d02f3f99c7a57cb6dfca1cc027f819ca4c964a0c0f91bdea92df9ba526cbce825e0aa0ebeb08f865a3dd44d8bfcf52a31a0ed1102bb46e59c09f4d96d5538c60698e96073d7b9b555cfa9e6195d3964071331c75cf1eec120fd658abd9e57b731aac4bc45bdd203a297551468f66f5c50309abfdea50bbd30cbeb3f10847855c743d78748a6f4cf6eeb695ad7de17b190a67ef8a2c15397bdb148f852205361bb734a9ada9e84e3d672e94fe5a7b16178032ad5b65cd677f761d27ba350d6edfde82bde0c86e6165bfab13767f84a8ee85e4bad01c623bde3e753cc1702e68b5efcf616ef2211a4f9eee80fa04ffc05cb1ab27b47c1319d600b8e2376f1fe14cddbdc8fc06cc4be8652d686facca73132b3ae4e179e4eadf7f2081cb7fe95c97b2ca4744bf110fe83adfceed30f8ca29b40633cd492ce1207b806d929a8c6a519460735581863cd5283ad5340ee1b3dd838faeaa9736d950bfbabed26d3a33928a16170659c2ec1fe86b55ef95151bbe0b3f9cf636acf4338762792401ec17dd2f6d5de0d59209551436cd6c632c26d0cf3c242f75edf89460a5d2fc76b40a94c7fc52846160aabd68000b47896fa9669675803622c959725a08801a39943d2f58c17b19bd832674d30e337a256f236aa9007af1466ed2aa10afa6271d7aed565947053eb5ff5f8135ad8982d97224de5f9fa727f931fb1e66ab2601fce686b4a93284da2e306e8cbeb4902cabfc20bc61164893ca2898f973861bc30d05af95953809489fa6d8bebbfcc2209c64bb8432feecc2148199d7fb2f5e22a4660928de57aee263e083aab7c1832537ff8e7c8ce1c08b06fb5959c2ab8368a1babc21c716d80c5edcff38166bf90f72a1e24f043e0ccb27c6dc898bd4e2f29b8af5ce893c2620046abf33697dd4fcab5198bfc85b442140603bc634cacdf9a3662fdf47279699cc0ee3325ef72f2fbbeebb6df25a618ded7e680a16ed6685307a48901931a81f213e1838aacb3d4a3949719d0928a2a7d198253f17e8fd6c85c866bb35eb4f6eeb6f4f30b67408511894d55fee0d75e39a38d879573be48c113c0613a25a9a3f672e3e81f450484b1cf76949f479db8b938d2518640378a5b110f80aecc8981674b82490cd58a836175fb3dff9cbe6495d0589c1ac63504be1cf8e57a8e86c1ac9dffd89b4f1d50f1ed12658f243e8bf714b054c8ba53286fbe06a58c30c8f4980a8cd3bd43e4373b49796bee34c6a87d2e5751bf696684079e96cc08243af9a3065c83d24a64ea7b67e8c7aa70cab5754d36749cb92011cca76219685e16b58c6723fa8e609d4c004499e020f52ae536cb9042cf29d0637c12bcbe0652ecc64d0618ffd92dc01287c47e26d11a442598ad3aafd93aea0ace308de75a651afeb73137bb4c0201f9bd3a3ae53c759069ab75e01c98f53d85da4ac9d154ab3881058910b077779c38299157b24b431216054eb2e5f033f0bbad9799c810e3ef9d324d43480aeaf3821519a35cbfcd2c47813cc571899e8c9b8104ac792188f28578d6222011d5ae9f10f4ae4f28bd126063069822db3b58434b41d94a8eadc93568c4384db68a951a7a1c6593664a871e9f7a5901a8a8e2545ddfa5e75ebd4433dfdb8c31bbd974d922cad914a132bb1395c659e787133a6f527a3ca3b5322d5f9f2058dd9db4d72ad2660e1451a7e0d40c08cbe96c3d9c8dc482e32f775c88e82c30d806d3b1c7e9b11b71315393980e3c528d7adc5705f93b83f3240cfecdaa12bb37cd3ee9a29164f974215e41283456c30908288d5d144a56d5597e56262afa56a23cf01b82de114bd189062ef7be23bd64c072ddd1e1b6a451c86166361220eb82caa5dae5f7edbfa6b927de2519de28d997261e4d95ea4da9864b6a42deb7589381c21a9f3d4bb268c9a52227be9f949d7bb0cdced4da3f9de8585d4443c0739bb30550d91491bc6c4f925c67b3c5918d38c3779f23b622b2ce188c17c977b55a914ddb4b8e3eddd936d2719767920fe8a45ccb8a6e587fd6822dbc58dfebaac37fdf5d19dac8c5d2eec1176fb143a379b5587b8f70261b457332a9282575224cc8b8b11c1d8be2330a32c523a9747863294c01766642e10010230291169bb372e256df43b1aa8bf2869b8741e3d83f5d05942cc9d531da80a0129f1715bd6ae0a9713ec10e92926f9a9f42d020504128d6522f0a3a692c1bf95517173cf2f883efda4ceb7a946c5f6f660c89866ad8daac2e26f535842f06d514a30b573ee8953a110441e9dc8bdd5d679d2ebb993f3303698179c0035c2d23794554aa3b66405cdbae022041ca37207e89472465a98b9e8a48dc7949aa9be0268b76d899c73c25835040a31eac5e5b326928affbd1874162ed1b97bf072cd64efcadf41b5f795aafac8cebad2fd095c1d34cd08bbeb27f7098b2d33f3a9a5a7ab6c3c2215e4cebac7becd1092f63bb9139a165683cf85cfe8d9b5b763fdc6ad81a26b776ae7f2ac456ea0edac6d42123a5f960266854c3e06171b99acb4f7de1cf7a49c7e63a919169693b4f6c929d6f5bf1d4abccd674fb4af7dac5f1e6b95d9ce891c710892765863743781345ebcd2ce26a4aaa8becccdc71445767b1ac6efcdc53149562efa0c80c1ea3b26ebcfb1f4b235cb6875671499e9458ce3e5f275c01d3b1ed68660aa069dd0b2d7cf6b2dbeee41ca64bb4173ad3590ba095a6a86934d031175e16cc03878d5baf5bcc6c509441b58960e186f2e71d8efbc09413550a92c376b6ccad029213f677c48dd21af006333eed19049f49a36ee862c7a18111dd8de7fd56010f2ccf253e6671dd96aea687edabd50441ff35f7f190d8736fb09603faa4e1ce9e9ef047fc750a13b93011b3e4a8e7099799b9994d6b6ab7e22c308ef1f10fbd78622be6b04d19979d86688a30c3f487ebda4f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
