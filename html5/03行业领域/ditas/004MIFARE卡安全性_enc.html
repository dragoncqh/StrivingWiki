<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"695f1689bb46bcc981eb0361956134a4c2af62a464fe262df8e426177e91700dde30d774aa46533b1d255f22d4362dcd031fb4608d2165a17cb9aa92c90d70d860deafab68ab756bb9c31afb489f1178f3efb5f65ed9065657738f8799e201965730d1bf3df65b861fbb99826f06dd21b4d5e07038c61b0af3481445d57e2746ca7f4b82dbc65a7e243e061004fa61185105604cd7dd248d63ef5b12744d54dbe8fd60d3c7a46d0c8ef1c92309f1b6f3bdccb21b4d6cb9c127ba59ec6a9f674883ebffddfffb3ce35da527fbc8d33ead4ae21db63065c10bda2cae8e982fa86176cef0cd8d16c612998c5a09b48b3fecdb420b74c55c2384fd35231062fd753df0eae4439ad18d5d14adc72574d52082c9d576ba1875b2f1faa5f8d1d252165040b350d145ecd8880a7454069ba8eb68e2c9619e868e68cd027bc394ea115063cb9a803698f4aaddd70f57a06609081e75547eb38d54950ec40110d7c1f7e8c83fcdc50978be78137adaa706287fed276b094a36d7f48c1bd9a78603d650edc5002a6d41fce1cdc8e83ff303af9ac218bc6495b85a8df3fd190da2518b16561726394b172c2c421ea6f8f65e5c26fea855e6e4b8e6d6718ad82664c0ce61dcfe0c6af63d8a0b3d21f0d207a6e7e696c08bae63b54c2eee4bbaa34855fe62962f8234970af1f9cfb0accd96c12d29431e0e2d3164d3ab527c5cecf2e4ee8d1656f74c37a99ad798630eaf349eea78d7761c532228d98cd75572afa094a0b055c48aa3ba8655cae61478f111c126a0e67b59ecb0964a9cd795286599fc9f3db3fdd23891cfcee2992d90da02bcb961de9b559886b61532195f48528c122cd53cce9b0f8b9e6f3d9a0f27c5a88150bd60973bd4db5b7bfeb1e1e5f35db9f834d3c7ec199c5784315da8beff08ec833249d79be6cde2f52fcd674867e9b6da6bc01ce0871d48bd5a375de7dae787ae1b456454288f780d514d1e6d15f53c17d02c6ff4b8b1ae878380c6d8981f602afccc46c069a1ff49d638c699e6d1babcc6c0e7c620bf3faad961d12e61f9f230351046d9ee2593095b813024bb50122fe4220e6d7083381a786319597bb61b7c45de066c183a3503fc1762e8e3e767cea8277fabe0e50e9e959f64264401c650b33c6eb3528aaf9b56aab0b402ec52efa33db0ac1058850da6caba3d1a45c3788304cad4597e5aa2ac3d99e9e78e972cbefb7652c1d60206f85f8fffbb323b20833acb7f670d6191b2c1f7c05a8a152017a214990ed6c35235637b72ecd0beec0815a93a6bfa18cbb58756b1cda5affe54b2e443b6b150092580374edc0983e716867816c8b47b965680e9d925f0d8c55e2e3914162b4489d63ea314bc51cb129d6c00bf7d0fe68c38ba2625363e9373ba11d013e8e60d2d7d41f8669918fdfbe1c87e70202aae679f6055ac7bd0ffab9dd59ef7d353b501bacfcd52f3add0d0fd4f7d7d4f4ddd83007d1ef4b99e43842cc4bec26bb992ba7ae6dab5fbfe9a9860dbd99e0cc6041d7ca50778f3de11cd308347685c8a0e22af0b864636a437e1032d89e980ddb49209cd4382864e0062305d30d59ff42c2a858caa339c918d5c5ace5f3d33574f52e4cadf22da689851ee59dd61d7f8c29bdd2a36d92d7df522640f26bf1a7acc2095eab0892550c3bbe8ae8f2b5b5e112d0b2e18c3ec50f55f77037afc60de4cb873ba4ec4603ccb5e7f5ef47f6d385d23d3703b7d53d72621ef9e575d2c926ed2268948aa25add8ec4dba841372ae4ef2f06c6f8b0c13536c148256fc57c5d852ee79e0223d31c5b48f13a7376c7460c78b944cf8988f4a4cafab302af283c3595ccd6ba9fd88c6c62ee66fa7af150ca83c8d8f19f2eb2f8afde18d0ea58fa92000e7321b639dca219e95a3fd74342fe091834c532a2af586bcb00682c90b54b469d8d326a22806114280ed7f62f9b68c4369ebd8ea8d9cf4dd9753e0685f7b6a816cf0e6899074177405aeb53770e060a6e756f7cd9811dddcdab2fbb77cf87bc98734b8ff942daf5ccedc5498e6ef1791345cf1a1c47a6acf1faf1d7dd727a835fa756201d7c4719f4af66b7cedeca5ce2df95d99674e73c170d1c4c46dc24e36bbdaacacd48cdb84ef089665d429d2aaf46e474fa5dd4b903ef91c57028d7ed0674c433cad72de2898b447361aa8d7898e9b3aaf7ffe2ca6989245bc87f068ddb8d843cf780e43d805c59175108f5949fcb6665e8c673bb644c25956424e311d71d5517f8c8f9880d0ac71943c281a7a22b6f28490bbea47843284e4b35bcad9117ff904b136f2df6971b44c6c99c6d4ab5fecf46bea8ecb7365a0bdb9c8f8f706e07ee0583fa3db6369f6acf76956a7d5dad0cdb89f409fc9deef55749664d17a882c28e50e1209206c491174c65c2106808ff4f6392b1d4052ac5b9a5ed417aca114033852f318e4e89d150c3f5b96189642d6fe769894b061d3b77cfb86f91f09e8fe617ba389f7c600be3579c9a2ba95fa30efffe40f246921a1239411aa049811151163551f4f2fe9a3493d95db5b739343c5bd2f9778bed3eaecc355d654907076d57c70a5fa6f59965b727d9da1d779e72abd6aeb3d51825a1f794c2e31ed6c577c14a0bb039a63b2cea050d882eed7312552400ac74ee34d6fe1a41576d4aa751a642a56a946956466809c8377fe6efa9700740cf5575e87aa7046a8a71a557534aa6b6f9b8e9703b801d899972e9bb607ade1b933b75359ae3fde6b773590849cdb776c6f8000d9b8326ebcdbbe61f142a9a2918b467fae2ae6984cd3bd1cc243c6a4268fa06bad8eb80a30a8747962f20ddf79facd88ff1034d08a4d3d1ed8b3ab60f16d04a80f49045bb2d386df4dc344e1edf4067075c242e4da71f2435c21dd8f9d55e2957aaa932831e792d2763536f51092857a064a7e638035e8bf023db02fbf28335429de8eb880a01f7c20c45d469e01fa4c0ed5a79bb436a243efc1296056461c4006bc548cf6d1a474ba27f257923d080ccaf802f1de0ce71a3bca94ab8cfbf9688d2a9bb7f7e0128a95e4f85c8f78dea87aadc86d23bba17411b2dc09c24bec68d2debbf1b77f5ad9faa373b977680ca1d982225e65498f4a5987311a3d363ea52e013ca84cd93ce3bfa54604493870efe0e217eae8fdb5022e17eb7a14808d4b3b8ba1e3c064c552a374be0cdf9ad532cc7d6029714b8cd58e8104df8bd824a693d4ff1c33edf1e6f06b0199ef6a82bca7756fa66e77004467b12e7f5837b220f4ed63b88ec451a2d4ee602f2aca34d0a1634a080fd88fc1aea6b8ab1329d70c0080cde2508c31f22f6b45172157a881b7c4f5d76b82a91065e0235821064af6ee52e3fa467c8528bef2c031ad424391ba302c1cbad2608845a393946decb992823ae55f3ed49e6a07a97fae15321a81a97d3855fa1bab1d8547643850cc3325736742922f4abe8ad8c69f88e47db34878651f5d09685ebb5a10e57a50982929bcd8f8728182157d5e23ac6f7f2d1926b2307f3b0a8789c5d6c8d5a57c067fa0fa9914d18d6e6243b4c902af9688ac6b9462cd2129d4750c9dcff2dd8f4f80a525df6b014f4e34524fc97633446aecb39904da4a3882d4048d6cc3c1f494c1858c2774c2d4d3d66c01e6bcb8458427a6773d7132086ce97bb18a25d2127e09483dd7b470519a3060aebc1f99f4249afe03b6419b9f360d61d51c4367c15132d7a2e743b7ce053ec70930061b5e7fd50aa44a8b66244b0e0dd5a10c8304d0eb1b9b3625053bfb47e62f1fa2ae89c3591f7d31b38839f5bc2165bea8a8636b1f7e2bffa5fd29842ef56dce16933f1b88a8e542002dc8ae79a961e02401a8c5cc01f3b55c458d357c567ed9b227c8c60ce4f537604872325be26ee7fa8826f9b6392ef1cccd548f5c1d1ec112308cc3e8d4286fb7b3b2093a4423746358da7a9229879a7481db232129babd23abb9b1fce23ca665501ea5f1c06f3245ab394a0892ccfbfb099ced5ebface12771a67809a5103482e44f58be3455358e74afe1f08243ced9d849fc26a0cd192924ff6584576f3a4efec4164926a23d81b138aa179def9185a3b35eccc1cd6b10447a03478eb36c822f7e173d84863cb707ded670fc54c4b2240b434f478e16a327bfa8e43737aa26f33513f431ab5429821fd2aeebc266e21714ffb73f92c54cf559cb6a29b9500623a4529851920c3a3adac2918e49acc1372bb9a9c8b68fd50190412942d10af90ef8787ec7e77962f3dfac8e20b5f8bf00ce2b86ff5d472c0e7019133b211370f184452723327a50a5ee04ccf64deb8f22710e0dda7718052389b5419276e4be6567438cccbc85076e894bb5f305f156c50a8cc897287d0fad0ef1d116371a022eed1290039c3c56524718742869f6a9b306cbd23f95ac778a477538e399db3e90ac3d4235c5a9ace1730e91ff5873d226983f60ca2df0b8374684a60a5b941a0818c4739d47afe38dba412b937b147d695c90c1889d790843f41b1e4ff04ec83e48eeebe98cf392a3781f2ee8f2ea7a3a380dd35fd3ff16d535b0182f95c31d3aa29810015ac6afc6ab485d074b5c4ccc4078116fb4ab3d99dbea864c9d7b4fb3bc21bc7e856f49987791c79626706c93ea7ca694b20f6dbf3b8e3765bd7afee037b91cc153b65acd4799114c9a52df3573ef7ae7dc1c3a3e02cdc9c07920729882c697ba8980448a718386fa44d9a986fc9b19dc12a6e2226e3a34bcd9192ea8f5429605eb71f934c2538549cb48f6f6cd759fc3746b2a2725732ffe528ceb0784a516456cd2510f88043bd8c457ff2b2eec3fd72226c61116f8d69dc5ff262e4559e566a09c945afa1afffa03789b29f21b61e58f34d4490fa62cc5228c4c7a27704b694450cf2fc96cc51f5758d0f2bbfb8e37432d19a5e384316be8d5ae16b85abf701dbe55c04dceb918e4ee8841c418884a33cc154fbb628fe7629991044ff19ea954925d4ccd752cc4d4f31740b1b6f2d73508959e2fb536a70c0c3519f92d3be0ca808c9706d7f158b8f0e3def2b8b0a72f8bebbae211ccbe46d19b10a1d41af59c9eb5f5deda2c1876e8dbc903c9470ddb188051e9e8d593cc6aadfff44120c1972e053ecbd1cb88bbe36254a1fbe294bc2b6e2d9627ba251f440b0c97c6a0589e27a898967d9b806769a99a43f5a052113ef1fa2890a46e7f305c2dddcd1d2f5b928f2d6fe1715d6052f44bf9c026360ad837321b76b1ff3fa0f7e5c724e46aa96829ff6db2baaed40d8ed178a898874c85559be7f61e1a7206bb3853cc309955ba38c8606aa83a1ebe2afbe17970f051cb056f6d569b030baee5f7a9e9a25ee3ab108e13d75155fb21c89072530103b18c8aab2a7f08726fe8f816b4dc323417301d9bd4a1efbc04e616d7347832284a797344e5d4fd5ffcce87645f4be21b568bf954a490c05025f5c83eb558158d5b44c6b4e9adffe9e9cb700a7e2cfc36b6f0903a5012007f3ab970735b65bfd30c43da279a1939d7dbbef2071adef09e6e341520e3d6b0b9878ddb12894ba2b9f2e3a6ab79350b240456f9887a7d4f126995f808077da9072648f3d2794e42bf5422497e5c990663c60cea46182bba822047caddd0a800dc3c75f0b8eb483b6a83d7e2f5d5aa743b26f21bcb56496234b9e8cf0079446b46fedaedc94714c892bd3e90f7d11ecc45ce6e8122b387a0665714377b1c17d28e65894e8fc76052c396a33f1a172f2a33c1c8695dcdcf747cd95049c62395a82053ea5978ef1fc1953bedaf501cf535dd888f06f88273361d9d47d7cec2fe924ee40ba4640a18896e79eabdd519dc61fbc6b5084ad4bfd80b6c35b241ba407375411be7e8bd03a687989cf5a191e67073c7640b713b3479fe558894f9ed538e53fab9c25c41d043bd89074afe8cb46924b4f83d3781c27fd491fba1934c5652f4a5070035f19ad3c71d05e3af4ffd1a03f99fc2fa8cd99df4eb796c4f754f370d7edf1f91d67c498405c796baeb3c2b6629af93f85d0d37cb2080b0a1842dc9432859a8afe38b811af8da72d718b7fc5f6d4f5c79796962ca416bb5b3bf7ea5e49bca006d859622e86c8c37543034d996cb7adb213f3d3573cea23ef67858bac00b270765099e5567570746a12a7495c6d7d1e7c9adef68eb560368699cfb89a1146ae98a32ef07b2d951a32fc5d67e91d2ff172ac9542426732d67dbbfd2d285e16fd6af7ca91c72451c7402242bbbb4853572233dc465023f8ad474b41eacf8066d988f7d1c9d0bf157d66cdd44f6e8c4d6d5775eeba2c20edd99e71112ae00a5b7d5346d41f49e961b2a9250190b51e3509d67f59fa7979f0486bc462da2f4bf456d18bf90769062d2d0c18b0c283833bbd8031b661d9280ab4115efaf853dde127330b54118d6441567699ab3e7c55015257fc9fcb3cd1eb3d9c5c96c340bdef01dc33eb5d9c8d12a9d136b054b4e4262884271b5e445da12866b0952e5386a02cf344d6fcab719bf89fda8b07838d42a165a0391e031d9bc69387926c1d87226ade0c9cd2ae79aeaafa9c7ead04750d86a5a845da872290407a7b27da46a1f2c2f1a0dd5c0722efd3235cfe69b049085390372106ffc2de940b61b5422078ab12bb03741e86edf2086af037adcc450deeed518482f9ee98ddf3eb1e05f47c75af2a1ac7147e1cb4efe7f8e3a8d191d2a8aa066534a982d15d55727350b65cfa6e181ec3e370870bd11195fe27366e1e83ca171cd96f6dc3e0538ad5d38ea060817ab89f0a7dc11871022d3c5f4badb0347cfc18f6105c880140e2ed86169ef31d51b1d7844bd97c32bb02b378078800c958f073d7119f3b26209914434b87cd59e74ff18a47e6c67358944e6e2482c742b8981f2e37ab11603e67fbf022ce56b61581e9fc10cd9ffaa7da06a04fdbe20bd1177f5b31f1fd92bccaac3c67ccb91d02dc48f8b3b44d783c1ec109199c1f96e0b268808e2caf9e89993e6052adb700389a62afbe20b04e7347db69a1c174cc6a0e125e93305337c4daa0706ca53fd332323f19803ee5482a2c58ed795cf554e3f43a4145cbe0a1274f1d1a37a807189661aaf513e6ad0cbda6b18c663402ef26e0972edb5ce9e16f563577242c82957ca8f66e6a4e42666fb4593f1ce2158c8ca5ed397eda29ce2c462b3b480dfdf8c6280c7f8c622543f0e9e682776c2581a9cf0a3851bce0221c9a75a9d0903ae64b065ce671099cbed053410d5dff7d3c4579dbc3159846a853a066f11a19180e2487356cd20da26ec6cebd29c46fe691bfb1e42514aedbc1e3204ea9a5e1c2cf92df508a0868ff62af8e234a914c24a77c44da77cbe5dc8f5f4f96817364c394e5641d425c26de8936b33809d668c9f0aa0d0e4ab87d4dcbba5715ff78fbd36a7ad450b9098c07d3c640b47c7c61e14f56c02b58b5bb10b163f1baebc32773789ebeaf42b4a83761398028b42cd654c0e111ddfbbe81c4a294fc1d554afe84988ebfe54bb9373e8dab5718702a6c51a2809bdf6f2790de6d569f33d1e5cba8d1e692d2abbaca20b1025df713b3de0afe3b704931d6f7965c37159a74fdfd8b58498a25571d8dc8ea8220d35badbdfded7c6e09c59a25cfb2244cad4f74b3ae616427ff62b15ff4be46920a2feeda2b264152ec36b34dc334ed8041334c5e8b0c402220c1625ab07e70c10705cbc4ada0c148b133175ac945be69e20e6f6d49d212bd916ec1a6c846407850b92a9350ae9039a69125b9e7929dc7531a7e6d457258f3356eb8f1547538968c1cc569db2340251a5ba572f4a10ec9ab672912491132db0b2ee32c7d4d93d9d2c5dc2a3fe9fefbf2f927b55d61f646e1082e7d7c32026e10c1882e7d2444fce905eceba781df0ef7f6a88761b84603798a89a965ab3e73b97d5a1973d63779af0c3d24a1634b4c143ff7c480bb7493fad5d3153a859b51bd987328b370d7d2344b504a162b451350106d01a3d70011610b4fcca24cfa87ae1b9b829a9346fb8b59316b236f4c45b233db2734f1e85422783ed9a5515e897df45659e49497cd31981673d6e4bd17be879b77f3a50a4871118a98555706dfe7ed50f73fc0163197c49517623bb799fe73011507dbc7958ab9ec293e3997a4221eb7d3f1d08712cff6cdb5ac0c3d33fd86e76844e9060bb2583f934184ae8171d6c6afc31de0176456c44fc790ded13c369c90108d85c283d576997bf884b32223b4dd1b1b2ccb4aac411be9f2a93c00b181365ff0bfaf67b8a8b4f2165a27395466b8fbf78527133f9bdb134d7bc7c3146fdff3968a2fafe534bbedf04bc992c6775f308a43fae3b5a974caca2154a0298b2e3a9c90b489e7fdbe836f7f21cbf7b4ed406123207971fd2fbde953ddf9ce89cf004e735d5ab209ee65fceda136bdc83db8187288fc226cf5b12c3da51042474e171ee516d9ecc1b53398768e9ba83aff933015991e1c1a0b4e07bffaa73640632247bef922528920b975e654e5862707cc654cc591b505afde70e242f9827133c2535ee8ead8ff089f1b5f192fd8db33a2d1f6b0a7aa1764a2b1b18b7c59176f8173feb504fd32bc5b15fd22aed7d80c66513feaa61c5d7b591a639aa09c494967cd53e46ec5a32893eaebf63a09877fc1ad5df27f5342563cdae74a6685eeaebbc870b3385720dfc2ffd178c6bc69448271543648f5d102be770dd0dab935b2367206e94b38251c423dab58e95e11879daf04bdb1fafd4a8d18690f13f13d2fe774786d8f17c572417a9b051adcf357a6a59a7f16fafa911fb881d90d95131c2836b954db227ef4b5bd97ea564fc3acbf28530cae53335f89b4fc263dd785faf854a2d682089b0ccae11b3e9d0c49007be85564f9006329187143ba2b6c1afae13129769798f4fe0d9817fa4cfad7cfe6df67f6267d3d6be3f1632b9d61e11193ed80bda3e89212817baf0f9a845b8d2ce9ad78f5031103d7ef656644feb97ec3545dd403506d1add7828bb916b894d25041478fc3be050fbc2fb124cfedd2d35412577e426985f87bfaa29c0dd1a9a34d20df343c903f8e7347fb72f0397ee8e845035279fb578dd632993d7438248951fcfdffc180e7c5703968d741d524cae1e1c608aa978d91278b7c67caa05eda86f220a2f3e1d2d096fd37c9370d34f654d3ad2ca87ee662815f90639f6ba4cdb3d2239a5dddcb8d399c4ac9297297133465cce146754bd33ec23d48dbd6d4d001c747b222d6ce5cbea3060ee1764b5222fb9249e0a485292bab4793106a089d960c71dd2a2af0beba721d364b10483a2381093420335bbc8dc59b9b49ea80d4f1b7f9797cc088c565df430a7488a0329f4816772117ae05fde9924d708d2d821bfc351826611ac3e0b801f84aca4f3ea49c3c926cf56347eff986ef9606a06bf4954b0b9573195288cdc9a5757e5cf1d3d9aadb95367a53ff15a1e9dc6d74c1b461c15185358c682145d030045335e9b7f4d805979ec734d91433c9057600923bc10c939f1ec4647ad2de18ecd99c3d56dc2268c06e98fcd3482099fe0ed7f17bd78c8a4f868ce94afc6d472209bc03b0c7c89b72413bbcce7f09815aada85eaf07659ec68659573c551172dc979112a615063f3c6f6a8d92b4da0b1a8aa0f2a345a92da0782395900d5b9e654c989700e39ae32ae4e39b3c1398b62f08df20d5b13941ebca729831432bd3be44dbbcf81a65c72ae4f03eec9f368189643209ff6f3f4445edcea5f441a7491ba295c100ad7b75966dab3e3d38c6ae1fd6394164c8bb02bba628fac88a652b612dc85252d5e8b248c0b2920ef57ea98f717b0a0007430f6fcd902ee364e4a53a4450494c89d298e9a4b60eae6525d2e4cc05f7712fcca00bb6a5e17209c9d5429b59ce495eda23044bd64876b1d6a7ad2857434aaa455fdb71a52b56880b7fd035a5d4b0cd62aab6791de08099906d134f8b6378aa33d6474f27d30976ff4c2fc1e9ee4bd76ec5d18b521bfe38f2416e6877d78a050122a150625001340883b140f59e77e2a3ff5ef5a933585d7d58b1eed121bff5b403ec46343c631cfca27e88583e8cceb6358b690a41465c7144100d52354b154fd128219bba16d5a2f62055b0bac23202edc87b7b73d6ecd16b4d13b332dfcac85baedfcbddaf1a4504a52703f23921b77dc48b616f3f214ed4a56180e37209fac7b254279b5e3ece73e407bc6a29c5c0959639d6c790e6f50482562fce5473340dcce457a2a5ae54fb042acb203be1ea19ae292481d95155ddd4e975eccd61436da9274bf19fe8b454b3b3e17677c380f61d8cf8baab918a0c86aecd5b3ba2e712f7a813f3cb7759ab3b33a0a3d2be9d1d9942b208b00adefce35023921b40f691d8eb7fd93e00663edf892334841d2ed2081659ccb4690ae1ec027f9dfea685042d24fa4ae67bbadc9ed268245dda4ec551de437e89db40fed96e6296b888a8076a5311aa64c3d6ac07f2b1d65e0142d095c70385ab5910c8515dc0f79c324acaefa19234cfcfc40fc7d42e4f0eaa568b75be441da292453a4c04f9e94e570a8b95964189993db8b8b3b32729631a391ec9644cd85d68a6a969b8635b2d8b57c345cb7ad66b8f9dc9d6e2e8f54f694f83aadebf78a2174c5136ae0becb0187068edd89a9abfd55db414b36ac986039c45160279440da30360648111578eeb63e0741c62440f147995bb5d085ecd5cc5ad67ddc2602359ecb6a47576d63c06f371a52dd446f3078752f9ad52a2538ddd2706a597c1263b38a4e58f9adca6577a0559d55d1f12d8d00fdd1ca778fa3f09ca8254cf86b2f0c9a4bafe78377271a282ba0fadff7b4185d4971d58136de163c9acfaab99589f44b372e00696de4ffa5e4046931c05901436d2d99bc074fda79fc7e18d946aa6db3373f6a4b2b1820a381a7f3c006f9b4a555e60d68670faf0a4d60284ebf7d880023bef41d1afc67143f72a9ba3fa1a776fbbcf0e125c9f5eef5627dc3b06c0c619748dc681c00455a2559c16b8788441c1be7c08e038d6af2d68e1bf488de30e8e7e546e68907dcf05c1dbe493d319cc3cc9c9ca8201c1a7abf0445fce91c15d64685ede1c84ee0d8d1438f598360ad97519d60f1ce6974abb4b9e6abf76d692cded398087967a038ecbaf483d47fd5d798c4dcf9e4eab989460213753c7f20651314ebc0cfa5d82a75a3091ea7f388f593a46b95cf349095988363e2fbe114dab352a41fa173c79d99da8ca471a9a5e7a453dac07c45e6b08ad15a71d7186d0dbaff890033499f36c13a87d830c841d332be603732daec8c325fd8111d1a114dd93007baa5ae009f3e4515f2fce714c739e232473643d26f2f126dcbc14b1aa14de8c64f1a5d8b84db51ec3edc2ca12de175d3f35a245269b0be4ad5de8700221dd05209b6f0b7de5e361a7c9ed14588eb0361bccfe7f45d9d63ea04ff7d72a7d3bc62e47aafb19b8916204dd49b74c56af7e89ad1559840c6ebf31de1e90d850e284e4f0f6805fbeea3b019288356837783a0c361c9b9546d04473062aac8f96ca82395c8dec99e89e4bfbead9774ff98a2143bc16158e9533020c2b7e44469b511c07d8599b2a8cf91782044b0323ca73986f9d5b8f5ab61213113bbd1b67b09b2fb4794cb9aaac05c95eb96718c7953302f45bb7f8cfd6b40bf57e68e1719094c5a4f6b0de29347f7207a39d7d92da8be8f793aa37dbc8681ffaeca21745d34b1323eaed348c91d59de6be933c608553c103dcf92f6679605c7a96e074708fcf4020f41f66cc2697a0fdf6b593ed938a2914ef9a0d67ea0bd0c2dc675a499d6633429b33f97a89c532bd7fba0f9b169cf8078c817b13c78562c8774720f55d307b78b63e6fee79a8598af1f445c888e7e8e8319254887d2681badb64a03ef04b59d77d13a1ba519aff329d1dd163fb08c6b872164045e02fb6175fdd600506b76fd49b04ff79a7a57874f038d2cb9dabe03f817e6c45ae333d88585e00544eb98c830ebf0e64557cf0a3346965e01d24431f36725e11b072cc2f5a815d9410cf0172ad69b465c830b48af66e0ce9b978cfa25497758d543d7adf3969f51ffa3e1e4fb26bb27540de36d0eaa909329b1253b045304064a25e2266d2e168cccaed78fb2269feae8263511cec61ae6ec6e9975a9c29faf57cab9bb8fa75fae9569d15fbc67b1ed2ba2194764f1c85a47d9e6d8d52bf6c938b1eac1fcb9b9aa63d2b7aab5bd457e059a93a4bbc09be4bce746f88678ab820fbaf4ecb6aa8a2136f45ac528d45ca1033e5c13fc740d90ff6f826883eef3fa8f3fede6aa95e3db196e627c91db9d7d64591684fb9cb93edef54c2f3d7f786689b68fffe0f2ed970e4edb74fdfa9d9c8b83607490af9d620fc505e733c60b4c168ec96b9bf2e113026d1a2e29fde5ded7bdfa54731282556cbb8d8f0f583b7b531ffac94bff1abb3a233044a69a5593bb832707fe0705286496faa8e7b0e64cad3fae359d674cbda99ea49e90e22f81aa80b24237c0992397b288af6c8965f42ab0e5bb0c1a4e2260cf58595fd7ac6cd17842a25a504b67e54172939ec1f5097c8356d1b61e92f99203cec1f99389db5a3a529368f6ba4387c28d3ea0b603ba5526dfa0cd283852822e2ac8dcb25583df26e3d0c27245d45ffd0092921f29172ceec693a1da362e85f979ebaa09019d58148a826f89bfd4753ce1885a0a4ff21bbe3640d5e627777281bf7a9244441e0aef65a05b7a8ea3378c136d8c6572051cacd84c972a564e22e6f7e7d11cc2267ca515f014df4f8e6f45ede673d5092348b4dc368bd18610c24ce5b60e6b49d5384643fce59b48fee80312d275aba0bdc0eac6d91fa1d5ddc716a1cae9178c0c0cbcc113fadab1d7938ad014de585c1d5a41145241c73b25ba30c457f878cbb30359828bcf067cb353fd0a805ec4b843332469d584ca733f413176a79cc2272f06616ff2712d2514f0fedc01b889c7eff3310343277c2b64a42460fe25eff50825bab9facf49f61b771352b7b5e83a6b22e8441e5069d745f0817e3b25cdeb86e32371cabc2ee14e6b5d31b135405b683ca2453e555a2304daa5d8b58ea54c790cf06a67bd71279a96807d8aab214d66551e38b6e8eb286e4e456b70b9a5d4c38405585832b3c9921141b749359502c9a2554cf69d8820c9004a3d23929b4b5b4c263d57e9bea253cd48fa376e4f719937cd5153509e7c81d38bde7d53376ec202386c7e76b624d434c129952dce77765cda812ff8b7809e94d18352b5a48f87321df8182c126fa0ff5f04366d3beacb0f409b600a684a3ab240711560597d1a2899c1ac37c779c9973031bfc075d66dd4381ed2419b0176b83c40fcaaeb3a61ec61a2ed68b69dd72aed9c3682546051312987ce79ca50818bc547d49e5e5c00f43ea57889dfd875dbab5a01646a4a2ccab933142f1b467e90a4af185f739d83fdec39a8b8c9db5f06dbbd38d005abdd3ea5ecb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
