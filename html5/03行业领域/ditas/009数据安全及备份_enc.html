<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57e0d44ce1dc3225320e13fed17fc15ffac7426e3c2256a35608eb8393a8d36f17e3810d8efb0605d7fbb54764fe0f67413bc4d9f1af164bdff3271eb3c4d2f97454427bb86495d4892aac3817b7344f26b905b9c8396fc0849e4e993b3014cc3f1004fdd1130484738700bb17d745a5248eaa2c4bd942f71d3d60f62fdd5ebb0a3df6d819bd9a54392bcadc658759d9741edf9e60283499f84926b606cfdd690de5c7b9d2dbc170de6c17f4107fc48feb5d988b9b6f469e3ff31c0e06350cb6b74269b1f31f3acd933133ba13a699ed2171c2a2d8261d3ce1bfade25afe55115bbc3f5b64f6c10e9cfe627002ae8dd5cd2dc8ee3db17edc268b7c3ab80ac2d1bf9ebf9696bdc048d5f9880952a8382fdde8434edfe3dab6b2a7c4c2764b6515fe0535da0aaf86cecae0af3c519445fd9af0f669d98559bfc4303cf44e0471edf995eb5b60f5d75755b5145f1b94a881a81130083831a5474dcf0bb3a2cdbd405d7bce5ba53257df78d7d7dc8f3563925a930a72c38618c3e802edeccbf470b2534e0e75f6dccc8735f0b97c3b3840273fb69e7f6da0580f9efe7084fd359953e88c8a2eac907b1e72e3533f0676138d705a4d9fe41b80edb20948456b71cc24f1c9cb9e8b4de7d0f47921cda183bc629f7483dce8e3567068a13af5c1f3bf6a4fce65527df661361dab8a2b168ef93f4f80910ebfcbcab3fbec7896dfd0cfa85041c9db007bd9029a86cbd815573e75fd49edb24a768b9da4f0d6e56348bf0cd391b071993535620bd9ca5368d256c5025df50f02cc177d5e664991ab4603b96ef39832cdb20141dee44a674406e14ecbd42e46b8727be00499274e58662bddd7923d825ff1ed313f6d7c5c12275b4073385e284ce9e9eeca48706d3f6e5912715c9316e7cc336a8dd140d791fc6663fa53d2c4479bf4d17bf3d83b2e615e5721f5a232d330731a72fc40d88f042931e1d2c8880aa6e73c781ad945bcaef52b479b12b5acd966023a8e255fab808f873dd1c9eef86de5035edfcc3ecafde50a5a89d59a32e8e1f4473388bf0906422e8701eaf213499c3552ccc4129750d5dae214d864b8836dd46ab93167bdd09f0f48a5d1bbd81aa935f1c19d132a9f70fb9a648ad3a1a2ed8a6c48b4c9e3410e2c3cff337c1913154552d318c85a6ecd61e91ed81bb0c9c61ebf08f20d4f9ce8c3e9117c924bb520081c9edbdcbe8d53c11d2694ee2b2ea0d2d9f259d110b13127472a9b7d6e38252fc60aeaedb5f82f2baa4a665942c984d95660e52f7717146f5f95274f141cf3a0871df4578ca7bd0c837739d3b0d5b5d14a3b92f8f7e6da0381e5499ce8cc74d5125d4079d3676be66a02fd50bd527b64edff191f36fbc373d639e144af65caa269b3ac2102f1d6e529cde6b3705c513da9430f40541686e026c88263a4a44abcd6c883f2a3cf299b549fbf5cd999d395713a78825f9707692a21c1e5bbe5b86e0e333ff453dd8ad29a9b1685c6599492e44d67f8e94ad452d28b473db468a76c0407ed5050582f500283040c85a1db3574031bc9c3450068be5377653e6b18b7d2fcc2b789254838448be83b7bc3b02d0753ad74dc13e1ab10549d4f34602dcbf5647ec2291675fdb77c4364f1860509e7fcbff399333ee96de478216e101db7e75447fef7d573f3d10b8fc53ee200a03420773f7905cb10d523db5417fdb8e45a89ed0af0995aa1d250f74a7e3ded814a20dea85567104b17a6004c813089131a720176c8fe0faaa19396f94014a9842a26a94e3013b9252c81313917514d145d2339800befa686a33c5380d552c155dcefd629a0bcb51350191757987e626e10cf0ba571ee5f641d42149072dc91b264626f446346cb7309e2ff026cdc526b22ad92362cad9ea406e0701177f4c7c816d36e09375ba1782195787ff127e61c719ac00211d53fc6e3004b70bb5705ca1d44c418b323db18c405f37df377c6c72f94f4fc2e1a163dbea948d136896abf10e8748ebe5d9c9e887f91b72455edbe961ea13661de026daf13b1647faaf654d72bb425b836c7085f828ac3ca30d1bd73897b68f34470da5796397b0534f6529d2054ed5de8b149e2a23dc4e1b17ed3271613704fb419bef72d9910b53682bbb5f23c020a00438218884d7158a12b5145b196cc70c0ab6b8c29e668b72dd636846617c97e8c38a049dcd16e27f3ef880a8858864250eda7dc45c4e4c35ec9acf4899a4668dd65ca21067ad19fab573868d9dcd0ecb13e277e6be44e62f221ef0351836a2d2062f5d0c41418bffa1e818008fd9edb223824368dab48cb2b10de1d953356d3d2122a1ab080dc3a2aef8c41e5a100d4a20429660bc14f33686a522edde52894a68ed623893074a6b2e0db515db78d23a55d2b1e9256ea99c9593985c8c76c7da87815d5633edff5580304e063ebb84e071ca6dc80972936b4b92cf5f8eca719119a446876001b8cdecf968287c42b338a75a7c765c836067060b8c7970460070243fc6872129cee2dfa5434d89ddf27a63ff43f16633d50b51ef15a8fd3e2efe5e653ff2186c7ca8305c573bb633d35937ed8237d93834fcf23b688375cfcacbb182615326ae597f59dc8cc6edffa57fef4e33a8984635ab15d397585a33e312964a667954348aa5208df562813feb8709ac6e24b1e31aa1576832e719b05e51e424bb74ee7f0997c682fe3450919640ce7b105154fed240f516c0f7ee1429fc0be9eee1c75addb266b7372cc803183a922280086d6c1a804f969e464335fcd9180631716ebe2af1d69e5434fdda7c24801834691351dcb5081ad37b03847a234c4254554fed68f8694f523b0d61f3cd82e70762d2efdfdc347aa054730233633085551f964128f1eaa6a1420182b060f3cac395aeb0c34f73cdfa1f7bb3eadb74106fa327e269d9e0fc98c4b901d14c6c6cc72a5e0288bdcc4d9891b1f5af7711f3f3c9f0575a87a955a461b697f1e1b6f66d5890e71018c177a9b5321173b6092587c478ccf0986842084c963395ccc8b9737fb9b30dad03e0ddc4a351e142d21a200391eec8c965892058c530f949ef601425c993a045953be3740116bbe525a524ea899ef2bd3be5129ecdb1ec33c7f1180b87f16e44e1314a47a42f793b08baa1b31e29e411fee14db82c0370261ea602292b4610f5ac890866807decf9d59db74b0cd60dfd2ae8e2b5fdb007126654164cbaedf9779ad93c46e654b7e19f974258526eb3e08b852d17bd4688e9991f014598cabaaf0d391045b3575ed9223652dcbcec83527e58af5fda5526a34ec30e7299bd032647c797b88b92d4850cac9934e986d9a7e5265deab296bb759fc6197339ac4bae504a571025081c5af81c513a68ca567e122456eb126f0b75a5832e130a76d360067747d1779e7aa633a2e305dd18406df375568157889e860e3b030efef469881021d9623e14f2aba5ed88a8ef2307bacc2e3b1ca5d88540c92cf647256e88946e1a6333687df690f0a2df6b8bbebcc9aeca55707ae30d788fa4336d963e44486a9739ceb992f6998c6921a9e757b01a9fa843467b8949eb3028fdc8a36a3c3e7eea0976e7677132317e83f5420f2176d055dfbf1af5d6f605ee969d9493ff4eecc7555abbfd35d72496206b7bfb533ed7cf17b1b298c5417d11b426be21e7ee90978d15f3e492544e73e008567a3128d5772a28ab68f38347bbc8a40cec0a45f8aae52ccde8f60a299276237eb2c0b1a27e4e8476926ecfacaf03e3d4d56d67e6b5d57d1ce6eacfa708255560b78c37fb323314f292fdee5cea76640ad9921ec3c9ceaecc468a968418cb193678361cb95b88fcda63c08848b2cd139a6407c1e509180d9efe85f1167a18c482fb215b4c088d8c82b2ec050a5fbc0f9d4fb11702612f1d952ccd4fe415b18d2c27433f02ab6ff34f38709e268c8afb3a2f08497092c8c0fffcf8474ede6548f7dd6aa71a1b00e5aec371b181e13f0bc21a0ef9e7acd58a99a5d6abcd079e5dda356c23783aead3a839f6af9a689f5a04f3456b7dda5b8b79b0397d4119cc8ff47047f1dfe9dd954191f59ea1f86ac63b0bb3b9cdb976764aa81cf02283540bc74fb24d4ac34fe15c1e086bfdbc11ef3737d33429586dff4ceaf857985e5827281c490580ba4d1e03cddb0c52504d3422e278c3f7131e24307867cfed3f77f847b9691870b8abd259c48c11af656e6558557e46d57a07d1041e3853b42a28b4f37e6428960a22c442b65d420c56e3375778d21b91fd40c4b7159df5146b0de3f2eef9dd4ef4e6ca6abafbf202c1fbb6eedfebbee3d454d5bb5c7edf32cad002073916bf40b194653a51746fc60a37634c625d5d0c9f734a158cd761d44d3e08b5b2501b2668b50c20f4ba69a6ace721db4f3200c066d93548f482bba53f6eb79463b13e49deec3ed0a39998a4f94947c26206a0345d8eae62882b6c5924c90ffd194b33faba702e766d130e73520c436a8d347e181c440c67cdb4a787b398b5909f16748d424499b9f6c9bb8f87d7c28297a76fab663347845fc443c6c204835db2714d18ecef7e49998bcd0c08eb922e852ef5f2f01e5a31d1315bf8536efef02e26004e73b91abb4b802e6ee0decf4258c8909beea0a17c775f2804d2b20cd72cacee2bae6f399518d6a27ab583b2a14f2502f6d45cd8e494e280972b152e6dd25c28698fe0afff0a15740c282deffb57be47da5cf94b071d077136b222af49a19f0f69b3211a0faee1c2b2357ee6e9317253f0143d2bd7226a9b0c693dd818bdd62e34b864165be9ce11e11b1671a968a62428d7b0ac2314ad05da4c034df1a59f31aed2a6425b0bc53316670f6904aefc150ddb1b35fb8b3c9a3793c4b869383ffd8345b6564992bb241c51c9aabf0f730e64925eaf359bdf87db07d5a7b3371eba156b4f655b96601a70d3bdbe1944bb2d25e95009c95a54d0966ed9c7550f8f53cbc87b1a4f84ee9b8fea67b353358a05a4ceb9b639afb2be2714ae6bb6c0f15cdcddf4c3377fbad32a41da8c32b672d71a83a1c822b91e4af6e388ebb8c7419f6141998a3848dfc5c002992b3c9c3191e2467c06b998e62fe79ca36a8051ea93af85b3ad954655f22417dabf3f73e7f0cb7152843f5b335e3895584d8cbe0a829205438faab073d187919205550fc2942b7c80e2dc8e0e0b949fa34001b8ab32cbc569e38de7ae37deda509e2d96b103089f7f6ef4e1fdec4b6e31271fa95fc741a93438f193020fa3c592d2982a9994ea5abeaf6f6193c79a59bff716325ee2d1708935a0340c14ed7e9ffcfbfaae64eb66ff11fecc46e711c74ba504c8275a07bc3368341e13c3c333b26999cbfea0187a5f7f6fa10c87defa9abd549449232fa1c6c30d6cd1962776e866f1749bf55789277df6f6201dae04e34e0d542c8939341fee8f83b8134c64841ace748642925dcdb4cd1716bc9851c29c24c4f951f3a5088c2967c7c115ae6b235810d8126f59e4c396d2ff7f67bb3acb482f101b9a081169e132223ceaa70e30cf8daddce4e42d2b8ce8ef39193bc28038742dae440f161d08d1e95e8624dfda28a1922b12f383a3ae1867c927c3253dd278b9eae01bfe405f12337723047f4d1c71bf8980c78f9ed4aa01667e47b4286a8438a1e47a1a77479bf8de250c325c7c1b7a3a3cf1c385b5858551dd4751d339ad4e721367a302c7db532af01b1d867da844291975578b2de9970f9e0fc573a8dbb27dd797ff6e9a857a7c65737db5e05404f014ded3136c1057e4d8fccd8b0b78cbd5f23b2f3471687c76ddb0756d5dd4747779997bc05be4f7ac7c9bdc8e9ac03020c032e385715f3567b6552a31f0b44653d68ef6c9034f960bc348b3748bd0d8b4a2bca9f9ebc72513b605dcfbd685ebd2cbe2b62a43a15ac11c1894808a209bc4a259d7624da167fe34a27240630cae54ba30af3ca9ffd654fe95a1c8064090738dca7625946285b3ac24d30ba48884727b8f54299e368c7b506176a38a2c6d0c9f2601138600a6265cd4d8fc15eee5474fab6cbb0a197a691d12aed193bbeb800c7ca08f7685e97545571bbfb9cacc10f6f9028044c7f2057c0b0768ae870a8202b0afb2bbe42777055ba4b55161f36fc604e12cc7e3e42ac4ed66fe8cd29d5315eea1c3bd44c2dfd4691eb6fccd089f942f5064850a31ef6791e32598dfed8ea6115a07b643ae3cdc70ba5bdb01cf3d5f63030406cbba548037dd8a322bd46ecf8aab3794678a0773058d7c6bce9518d1d70010d53ad3ccde21715fb57bc32756a67b5faced6c0fff51cdd14cd87d5cc7da4d140ad2c259c8414328fb1a4b4e90f052793dd04735cb2526b0dacf2b6d33bd857a1ab0dd8a62babe027d81f8064ba28dd3f75f9d31bcb4c58bd55642a475965f7b9d9ee1fba2a7a68891fdb5ea0899428c5b26cacb3e48b1080ee61062b2f932fde15bd4428b19fe6b2ec14415d4d2559f71edecb3770a07471e2309eeb33efae98580ce30c324fdd57b5deceb74e5b40a4d81a21e6d94cc4b0a1d5f46f6bd1c6b77396bbe5c9e700b9aa95c632c9e7f3182dcb4e639b403f68b00d8b9a93dcf8c7af12f8c452d116c2cbea671259220cc3d3d3374a0eb28ab66ac742344aa4f2639dba8d599d962ccf93dafb475f2e9708de689c91fb4cfa888ef9d0e069bbb5832d8597a9f78c02264a63c9819d212d11fafb0800ca4b56d1a33f679bddda70fc7727e9d0391af2eb8801488f2a884ea6093e605703db52cd587e8f3f1764692be32911a669b1600d09f1777a8f6c9f67c404dc834db9c095d9098bae8f46beb38b9ec8534ec163ecad8f77b8287afdabf350acbbca0cbc332b98984ffb45a77041ac1142828693197ecd26214978296480d8aecd1805d917ca6555e3354110bb20c6f87e8568beaeb4c50cd45b4f4f3b0e819869c07014ebc0c28ce40adf65d0cbf0a0701b70a3e39d5a1a5233e49d480f44f8ac7aa60dcd91e51c57b225e4aba3bb5738267a4e5a13fd6ee126d79f44ba3253b71f2f6fb118d81c5984177eb4cc23d8e809c5b373048f150d8b9ea219888074cf59ba5b9b3a1b8f3f3d9eff07719b6b1c8e80d95268dbdea86d4f08cec2152e34b5fc61adfd139636204c62d384064edc01250dd504afd1e8a393e2858a07aa6ea7849c889384f82f310cca3019f9ff922e68dcef84098f1b41211f5fe8e4570c80e31f0182585dab5c0431c89902019996ceba8cf0f1fc3cdda36841607770edd96ecaaa421685250c00549e22d2a9628161c62d97e9c5f8dec5ae194e51f00b618d725ed072c129e27504b4e9d6c70e031aae94504b789ef94d2ab17edd52f10964","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
