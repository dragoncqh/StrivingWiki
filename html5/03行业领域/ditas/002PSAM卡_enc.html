<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cb30dfb0d3e3b7a7622b7e1b4bc00870a2e900645396ccd25bcbfaf855c70698288712016a8d83a9709479fac3ab52a37c48943848a62b61eba4e8f9de594abaf1706ab9d37a1cdd83a2d53db6a7fe1fdc54cea2d4da7cb80b9eccdb9c669925cbe7774e297e2166339542aa4229f6239bf71f18d6d66cd14325a28c014ede66f9178f5408c3ad1730e488f9477f294f8974dfcabcb236597ec5be9a8a2843a308b9d4a42445df81e667c7302297554de2004b0fb2c8bc86a1369fdb0c486f59c5f4a478ed760a6f46bfbad56053e42256a1451d9618aa6637fd4c06a521efa8fc36736e3303772b2af6b8940459d32701ad17f5c56a9343e32f434a48e093f61537c088d7f469ad6e8da54c6de7ae24a1feaef7b1f972cfe7038f3c9186d322b9c234eb7f7869f7a5094d194c0d34649de3de44a18bb3c22ccd8e7ac35902587c6ba6c104101938dac376168a0cbad25d3975b0f321056e81831db5d21caa9698b941310a4e59627ca1f5888ecd755b245a4eb157001b5edab8bd550d2478783996d52dff8b8735b49b03932d582e81e470063c5e74295fa15e7c8f32b1bfbb24a652d8f537b87d83ca9d772f35222de0daa85bb20e88cd27fb0f92879ef4f2a80bc89e0e82024a2e9b5418685a9b5744a303389d860aa09376bde1b688f735a590ac164de61cc0ddc96590178285fc09a03a34873392f2944330c0269a41bbafca82bf508491e62214f51ffe2c5c43f909d75f0916162db7e384d2ec3258342860768a3d6d45b98325493a04e3c5301e8ee828c5f0476e2f0b15925cdc2932d42787285254b34d4f140ef708025183ba3e9a4cbfa27195d3fb62172cecfd3817cb62882cd4aec182e2e64a7898d9153657a7b4ccfd7d56b23f676881132dd443d710de6af6e77eda68abae79ae0a2ac59ff3da9e229b36e120b78572718bb1c9686bff09eb75e0e0a55e46782f6887c12dbd5f3b1543738cf685fe5df89e766aac9149428f47fc624571aa4866cc7fbf6c613d85506e43f1027970b28b283b6d83cf116979d4fd82c6ee70589ef7e0b2f857225cee1133e76a973649fedc40718efbe2fb5041c2bbb0da0068c141f0cf9c8afc3a5d775f583dc5736e6bc0dbba8e7cb8f8d26d18c2d61d3849397965c2bda1384e07c3a521fa5449a429f2184c01fc0ea1c7a061026b94e0a817cb528c5c5ee5df2568d5c7639df29dbf4bbc089bade7efc7a51c0e4a7dc4650ea6a1fecef28951771d4256b85145af6be113c5576be268cf2657cd4706cfcd30a9ea7af5cd9496d37a98104f72d702e6cb0fc8ab3e26f14825de65773e6a4dcec98b3159c01c9c376bb575bd4e380ca3e76f1d0e62539a8a254e9b80ede82e4b01ba3f2b47659802ebd98c82616128d9cf271255f9bdcd8ffbd0410bb62d951469d05d57d0862719d5c3aed122c5d0c59bce14fda5268981f3dd850c5f784de7297c653076f5a155020b6f75ed30657a40b2e6c85ab5128ad3ed1324395159041365a3302ad4cda8d3a9c93e9d18f3774dffc29f5ec4b699327e885957a668c5f91ec9a74182c9396a76aefd1ebc4e7a360cdc43856737934dbc71b9b6c38626c294fa73b8dc4fbda23c4b36b2f4b3108c907817eed43bad1807a6718acf5f7b8dcafa9ddb641a17cdac79b91777aafc6d8fffd72e574b69f047db963fd85fa4e382364dcfb96b56e9c1b1d10c1f9eaebf8a836019bf572c6d28f87f7465c674b78c60039ee8df19bdd9436ac99c640ea246b17190fead40aa60fe149778bc888c7bd595cb6c761cda1fcd2ce176438e45bd8889926ffd717d8d78f5d3a0d2058943177df3c1df79362e13bfe80e69d8fbc539378334074f8b271dfa690ca9670578bfb095b1a4441b66cc311eb2a5819d0b656ce7598921d091c045352ad7ac04f8999ba4d69c412b99ae23de9468543b25e2d6541f5944b0d6b9af0823b1efabdd982f33460fce4c8753515271fbd0a6f93e6892b7ebfdafd7059d397b57f7f23c80f00bb29126f2615fa81ea155d49983c2e136e188317a09aa9a28e40d5d28e7fe78bfb6ba2b2712eb57f574b6d39ce68451060573cba9faaebd826a1486957bc8124a57210810215de33ba31c30148bb9c8951113fac27a084862e368528f80abb882f9976ace0b872251016c16940aaecbbe62b274e8384507bed3fe2865855fd448536c0df96835d3e3aa689d0cf7d1eed9a26847b22ca37b922dd1d51ae8e4d1dc75fdfddf71997ab9471034ed00bac0b7756ee22d3ef707a0ea8f4caaaa0009d874e494afbe090876fcb2dc73d0e6d2298e2f0ac5d9e342bb62ee8f9ad5634a2140b50f4b02f51530a5ebb1a5774bea764632eb1d6c37d4ae1c2bdfc6962925e2bad99a207d9adc73d699e95581dac1aedc7b6a98b235e87a787030e7d595aa576ba9f5fc2cf439219b5a9885ba620a249651858e69ea4a30b46d8cf699b31c45acb834c968a2c1c8faabeeeeb467fd74720ab00a9cf1f7695bd9a34734fa893bf4991b3d911d01b0112989e686332a7613dd8a065c170f982a76fa987740a86b1ba9f2859101a27682add5355f8aac5fb282da5c2dbdbf86f84f7a321a17118fd46ed778a5d4576e04e6efaa038667b8cf3f17379cda44a8491e1aff2f61c78a1f58420ce0b819f27d3132f5a049fca849bdc245f7d29d03ff4797b9a996f238cf99ce4eea27615d919d839a4581ab37d63dc7513515a09fdf078da8fc9e85c939d3f91c893d6d7f838c6259bb6462df56c22ae72e755a4a7b4732334f7a19a1c3376dfb27516579c2ad827df9794b1b2cfd8a0fb5992cc0b48d6d46c128e8a7d58529ca9c8540292f2b9c0e478486d6dbecd668da224420a5b970ab0175eec24235d41125259c48bbcb4dc646eff1994d2340f3b5ea5f5210e9b639c7f2acba393934b5c06f5d99aa251559938ed9ad9d283491bfe3d5a46da77809c088b052b8670eae85077ed7aa4040d1aeb4bc933884270300f755f17459ff822b30152dc89750b41c3607ba87ebdde8d7c89e98858d7baeb132a67d33cb9e64a7703f5efeb426791a3735c3f4c676cf5f1ac2215b9fec1142c6268fb448c857fd2bf7a914b93a98bb9fb0c4a47dcfc7b6d93a091d18905aac4822e98b868be9721f2672ee45f407a559fbce422ee0af04c0f0f79f2f547755c27be2d76059bfc2f0461ea117698e05fe2d28b19f24c70f052080116e0f2aa9c6dbd45fa540e72089987a24758a6fbba8d5a5723455d9913eb1c96829acd41c3f16475fe3f8bd6353c84417de7757084698268a477ef53571bc26712ca7596d0fbc7e622988665ce4dd1844098b7ba5b07505dec0cb3ceff81d06a7ff29e7035639093c1878c82007dfa30d781edf271fd0c5764d6c507e13b517f22d5c7dcc16bb49a8ce76ea2460c57b270e70cd2db4b9fb09cf420f5859fae84f9176c86a2378a082cb0929323b25ee5099e0df9f29826c22dbb900578426db10308aeea1ea52ff6152be21b7f682e2fe9747e653a8ede576de9ff2c5b3daf7995b447439843cdef0e7824917b8888ecb0b50f7f82f33d4e7d62b7ebe6ea647c17cf7adcfff40f9108c4f53175a80dad6e3cf3e1d98fb9f4c1766fe1fbf215a56d39d8adcf596ba301be3516cd4f49f5dad8e75b05845b6b8dfea8c651b9d05874436b85cb0013835b94e1b9fd7d8f6c8163bed413cd8410918aa0a6999fa90fd54478f548555ac28dd83d00fc76e9193dc55428129755911df0c9d65e0cc0b512889ed8622009552819fa423c4b643e2aecfd7550d2b9afef32b2088c1f3f3cb8ba5a9a96ae30c957fbbdaeed87082776b9415b6f65ca5227571e008ba24aa4c416f5ed47a8b1c6a084e20204033266eb97b39f1ac6eaaf550aaa75a80e73bb6a74263a6b78048fb29c4ea681252646e4db6c071f6ebf0c6f000dbbb3c7310bc6861cb03626bdc07329588f5885427008ebc5c9774de3923f24c6983cedfcc1f085e0ec9ac91c726bf34ad3c5b852119cba15057127cc382cb9ac34a2eed67310d2ef14ec4e8c99aac93f6760147d81990d0ebbcaf539cae0ac8b904fc790c7472efc748c4e537275978f4860118d150c9e87e0f31c943bed9a37c09ffe9934b6850f777a5e58fbacad40d9dd631d0c42b5af31c3685d6e91c24f66495ed942bd66c067ba0eb88420c88e09077f4546e22c578ce09e812c8c23829e43375982c427d0528af44276cf0c28ae28e8f7cf94420be0e1233abe5b0917fe2320a65e83bc494baf130a772e278cb1354db8f1a057712eab94fceb3e42404a7df0a7cf856744c0459cd94d48c25bf06913a651a718737b369a53ef6a996a7876ec69142204cc5acf510af40301060a87bf94e95c8b80a0283062edbca8f5f4f4de53b7ca29cedecf03ea9d87e53da87d27d00c39611727a1ef36d11ff6ca616731b61b1aebf0cc213c3cb36721961718a676d0f6ea0feafb6cc602f18aa30c03640250816514b793214c82af7b09479563f451e0b6526e2853dcf11aea2538df8cc712803689d19abc37e1a1b5cac3cc5bf42fdf6e03528f95cefe6f946165713115899131f2e0a3dcd6ef2ec4609e8fdecadcd394a0912e80f7a6ad47432c9aa94a79239b73dcfff212a32b8988da14ca7299397d9b12e93d1d99f0c9db54f8f78965e94ecd2592620b4ac7b93602f4f8326f556504aac54ed03f8d169cc2120152b09aa0f5f0c03ec584abca8a1e513816a100b1c8e8c3bbd9fa1ef4f896082da1f19c25265d0a994b70be07521abebb426c1cbfa4c6246aa7671d622a4390589023c746fce9babc65f0ee3b5e55cbdf8063d37fa7fd8b9a0c13281da3dfdf917ffc6307474ebd0b67de04871788890b9abf00d5fcf08febc843422782b85ac0dac4479e245ce3ca11aecae9f0d41b29ccad36c1ed47fea71f8bfaad0283fb09d539cba9b0551e0c3ae8b190f1cf025a7e9d4d2d4049f99a13b8d3f9a86c5c1907de4b9574665f3cd83118862cc5b2bf8f554893511f25e48ba45a22778cb6b613be3ac436fb79662549262ad06722a0e8b048043edd7e474fb0f52d46a9ff0e2c5290fcfc3711f5faa32fd94e2e5633ec6e483f0415a6617872e1ac30ee24fb644165916b43de3223d306cd55ae5cada85bb2b97149f575b88a16277f6c2d91303d5f643cc6ea85ee7dc6e48b5fe0631d7c88d15ab688811366c07d6277bc3b38919f364c06bfbedac39c5c6d61f5fdcffd499899c21f4fe73d531f644e53e9e91a2c43a170e635f83a91587bbea40d26864346ebb4ed9702e3098fa2477962ca868486b6d2188cb68cbac84d11ba65bcfbde0435c3442893a77b8ffe4ef71d87b75d664ca4527457c231e18a1f8471c4f68c5c68c9c974e09a459df208d3cfb6a49fd235b656a6e9ae0af33b0feba0a833f8d16451a6af0183e626dc3e1c2656f2641dc6a8787c19fe558dd7f993e82e8f45fae0705932496675c6f226a39e4e0fe74db6cdc8c9fc2540e91b5a65595d22b6769e27c14b52843e12bd9d308cf683d8ff3f9d2cab80f66bd47f8b519db9e09ac0d2fc259095f7406cb9f8c0420300114b3ed9346176e9e02f87fa77b47ab901e30d1908e820b98f91262fa36a5b2056abcd7380379cb6c4d8a78bdf7abbc24974fd7685ec6d7b64d18ca8618c3fc8967fce02103357b3a1d850827417a602d09a3beb6b3df4521b63d084d9662fd490eddd3de4bb839593f4e965021a1ee92e2bb76682f9078c9c0be6f90745425475706ec0dc607c540d2d0c966494587c28f86ea9a7880cc82b1920ba27e72545de7b5131f5ef3180bf4b46f47c3a5e436c70d8857ca26f24d4f084f3da499b5a5f480515795549fc215e90b155b8ac5761e9c27577b833455560f3bbcc1cf50411f4926aa1433451653ca213a8d8678c14c1c611d35f72a119ff3bc4e9d2746034602eb882ed6ac2265c6512573d7e34c4029d1401aedeed35aff8de339769b3545b1cd519cc0ab08d973f6870da75e0a55351fee56692be7084e80006d6c922bc99c6ce6609e09de14d2265b004ec801fd1e892ce2480207a83ec03d095b63b53ccbb6f4342813b453c6c8715764cbca31cff6156335fad610519269879a49fcf6ec44fa55d4aad7a71c69bd22036ad4accbf7fecb8b4288c2741ed63079a384ad85459e5e748d36a4b5c27a56112755a178f8bced3638419525f2235ac74a8a56beaab7fc3ef071fdfbac45e927bb696c1d0521f39911cae5cbdc00e8c72a59307af86df13cfb04aa8017857490f3dabec18458142b10291e13d8a1d92708b8816063a50c60489394afc7e9aacb09026fcda6606c88878bbcaca37838e761aea82057053d8cba00b404ffc8b3d42c89000714b008679419f1e933b562a18e2765bb089e88dd7050c2cb183f363e9ba2de31b8c1883b6f92a9fb1dc9ebac4634c11408c10eb827b62307d0d1ea7ff2657988b4f294db59a14be0140e39987dd0ccf35d0f62e0f6dbc4ed5bfc968df400da79e39b4518f03d64a047bedb2cb022cef4e53eeec79c9cfbd3491865f7ed7e85c22ddd9b04d9722d9152d3a5e955f5c01364728545b3468fbd417f7eaa6f690327614f844b88aeab5725c87ca22fdc0de5de480e6362a3352734a7bad67f8a59c3c99178cb295dd9e906be624860d1885cab062a05510a07c00068843e276acc2f50a842eb0760a6b866a78111c63f37397aba03dda098b77bfbdaf9ef056e6c864cfa080064864580045f2fe16c70c0691d3f7ac878dd1a7374e37829780f11d785b0ee44d96c22be77ecc199c5a0a12832b801b3936267ad705bda9f175c28dae5318f24e3e17618e2f4c033d4da330967c455fd2061826a22391a31f152944a14902cabe9bee36b41bf8b72417c5480b986775ac013db4dc2acb3d4d57ea65e9c72f37a94105ede501502024e0a1e65ccc18266bd9dcd81d4f9ecc57b8d5ad65ada93b5e83862fe445afae7c1463aa916ca7abdd2f6f1671cfda00ac8a7940f256eb09a8fde9d68272061d6a7ffeef5d1c5d8cb24949cef7a60b550d5e286c44c11662619dc354e42fc48a54f7c2ec282d3edbab0965e7c37dcd41aeb073fd7f51922309d41920ba13abad2362bbdefb57fde5a7429bf471d20160146ef63d28eec39d2b7f67f761d686eb40817076450e35d6e6eff8f9efb115b113812cc9a5a1dda0751e6600b11a941c7a772ef8d1113482c03a3d56797b06b49e0f6f795af00f7afd6125b73629e72c1ba17e29682bea9015e8fb7681ac3a69b8eb6e463ed7e13bf6f7ba8bbee71b7140d7bbe4d7b9685e44cc06c25148e3a0f34634043f6d7b8e7abcd728fb3c12d66da522bed8d7f478a80cd636a4fa7ac4b9d2a4582fb9083d8d49b96113da316c13784a62d663971637980b72ea9d02d9def6cc3e5662bf68b62127d0f171cb02e0678b010bd8726b8c5480bafd5d9e7f97c4629cbb26c8b1109f443afb454aa3a4ade29a64ee61beca829a5cdc564d87f16f6dd17a495ed5fd9a2816c05ed8a7c64c78cf7ca577398e2f47f83149a1c0983b792c2d2d6aa0b69ca61e03b437e1a2e67e774dc366c7019d458fdb8d953dd7a972b2f9e3d378e67c586b4076d9739625a74ea2ec66dfc8647dd4e9a03b837669b1c4b723dc720b4624b1360376c5e9c653ffb5e3ca6f6fcffbacd1dbfc9c45db67549b0f3d7ee1f34505a5a62d9f9ce0c8502bf495ba4ae0fabb45de172c6262f0f2b373e3615524393a32055ccb5c1ebc25701717c43c3e903337b37f5dd21a4cb4c7a50efb9207ad3814ab85894a2132153aa3dcc4a5e6a108b50d024ec0b33c8b3f09d1ec9f21b02d4ef3d9ea0673053e16ca03efff4dab95f605d04edde1882aeae60dfa0a46d81f4b746ac3153817fe02956599b96bbd13ed26d442e09a2ab3ae0dfecef2d5c4141eb39271e19a16887e0d755420cf10febdf3681d2b68115faa8efd4da0d0bfd75418983627a584fcad1643d4bc01cb066b245d3bab2d813433815041b403f9fb888afb04afff590f3b0954906aec4854667f70758ab148bee4e9861a1fa8e78fc4cc111e448b012a28b48f6fb633e5096fcbe2769e9af5f8208a8486f43d0bdf0b43b3883ffc2ebb36ef051135c003cdf84aea351b3d4c44c9cc30da8700186254b7e02f0fe25a3dc8fcf1d74b13bd35fcc998ea19c58919e1e9c976cedaeb3e7d2be0619a84f43a0f521ac96a9c8b977e2abce23b297e0c1da2ed737d0c2d253af49d5191bbf1c0cafac1434df3f8e3a42949b10a9a40fb8bd5d35e1df4401fdcc823eb2bee21595596c6d169c821928ab9bb9de869a5e6575f9e77f0c9a0e848135e3d9b073c299b301937aafdcdc315b30d4a82991d20d0c0cdf54593215cdaf5a442532f65bcc418edd5f2ba49cf41f047b6a3e69573200e252b792e319d22e4fd608191df77b3e1660a6e4d5fc49d95bd5d633b83d67fb6a19dcbd7c85ac87fc3ed8f8245cac1a519a1c88254f50c09ee9769d7de6607e294f3b0e340c60eb95efcb6d5824b82cbb4b78e1daf0d9c9561479b12a12f71379dd9e92dda2d79e62c190d261dd4aa7531ad0c39eef194fe8f6663b03adceee4225327b0e4bc5e6b0ac38a3470a76dcd48b6df5e89c7afa76f65cab6065001511c91511d6b1ceee28f230fb46e5a5dd750584ab7979b195d4121715a5c9bd68ae962b4b6cada602ad825b0437430da3c224a6e0fa331bf255564de97f04cc63613a8b3b08c04cb4a76e717f5eb52715e27c68786b483949f4bd20714ce49961670de42d00caa8d5a4d8712907ba13378ae999423688bc698787d042e43c45c319ccc9281cb106c815ced340426346d08e91ba755656224fb64bf36998d21d85e8e465954c79b006ba329a9915cabc49d000210f2b345986cc31dcbdc9eee2ce17cca7ecae62ef5287372adb4f546151eb0556a9b2b7dc709394b7fe7e7c5284b6388f265ed8cd7327ebbe467aa02c14ecedb3161f82aa154ccd0c6f1001655c17fc581aecbf4d802ba71e9b62306384d42a113eecc5dcb6b5b3d7de1d5f0ba62c0bbabfc9ce0595c6b53b88934b5e5ff94d981b235c4b9501030e2f421fab2c01d2503eb234dc3c3d7bed9c5422691430e62a20fccbaa2c3b85ed36e68c8fc5f9c627b7f257cf64e57839a16b16f2ed9b209830eeaef7377620422cdbea8469db83b147ffc9eaa901ea84631660a5fa2e8efe8d6baecc9e0ab9f325ba67200bc5a7cb5421f5ca6dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
