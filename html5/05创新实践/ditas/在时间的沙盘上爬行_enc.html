<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0da8a87e8a64f8bcef1eea7df9ed8d07d74f547451b0989f894d3a734ad771f4524f85f5141f3d797a3cb012a191fa64461724945df4adcdeafaaed6c411269f910db0ea11b78c118278c27b533c314d0f3160140d19325e7a689307ac3b3037dcafabd98967c11c5bf2657698f3f54700c91f55b294609b3f7c6b07babd2e2bfcc13c1b93245690a12d23ea2568921573df9c4cce3a0f036923c01d0d9348872054c7afbe3ca9cf4b3d1646a03f83788038aea491b2eac35184de7a570d1986dc1420837fda8e486fb2e8d0c76967dd67fcc8a7270976f25a2b75bef79919672f2fc65143f2004a289aed67b4ab0eb0e5df686ee48e2e189793c9cd6c770fc6dd2b5373f38d8b9bf6e0c5ab258b5c16fe556d30272d1b379a83558fcdcb7004fdfaaf0f96cb098f47d768032232ff01f8ded6fb6a97ece3d63b6e6426a97fd9f17a38671e7540baf6e936d7a6c3d122425d882e402df22c36fae6ea23a2fe9cfe286ed46e8874cb6d39a2e56add1c338bc333f5dba83df537f7f722e653862652c9c868d6e6e24c74a5597345ad6d6e30d99e4c16011477bb7aff96b1b989baa5647a45261b30af51f72d2b3f59f18b6aa9639ecde4ba3a4ad064a027a4a91d091d338cb15d93503c860196187e6bdf8bce4212e02f278770079d73afb3a6abc456d849fd2ef45b6d9ae9f24024024fc860d30ef7e44be534813540211c0158d8c41014f20882f67407d26fcdc1b00605f9654c0b1ea29c15d2525b5afb8c87e51eca11c60d12e6052b95ba353e2c49794fc511fc904bb0dfcf10fe6e14771a9720fbd08388ed98b775147f7aa01216c2c6721c5f910f75e065455db655766672357c88167e868bbc2cb35a541c592dd0dd76e7f02306771cad12508f3c941d51ba72bc517a94b2bcfbfa7da43372f8c85fc672c0117d0682cf2ef8a648a54c7c237f6898d428ce642a2699bfdba31a89e2cfb4d275c4ae077b74d2c8e7d5413b4c0ab8dcd1839ba251c39e1c9c2290b1e238b2f483e19d0c7a73ec36294cdbf5a0be9a2072ba4506d8ad1b459b1be02111e3c3cfb06fb65ff3aa5b4f9c32f5bb416641cac97f57d91dfecc2d8ef9e705ef2cd92519c0876396a85d3628e0534e0e8ff7077ecfcca43bd7b954c1e10b0232d25f1757505812aa1d42b6fcf3ac3681500ad3759bd0c93f5522cda079cf5072b9ae332bf9089269f00a53165d88778a721bcae55a400a27f7ddb58eb71afe7573d365807add56621b11443ecfbd4b909f0ebb4d51376849093bbb94a0435b2d3fdd62a9c5ca2632ea29b2d923ae06ffcbe314eefe49c63976da3ed1a7c6cb78c2e5ac4309850e3fb727f7f4ed048a2c7503929d99de1ebaaf770ce5ef533b90735610c5bb22f3c7cf9d14580a79655efe46973d56ec1ec1e26117cbbc8f3eadb622dd61bcb03dd1912b162808f2625cd3c8eb0e0cc0597144df7e9ffa8f7cc2b566b54e2844f67070529fcc3ad933bd3329432527c33316e433845627ee1630c244e0758dc965724d48545ca9323b2451afcc1aa4dd83de1e5df64a0eea0b9da6d4e7f1040321af2c9c6fcadeaeb768761ecad00e35224fd2c558735086163784abc1dcd5e9ef211c327ca6326f3a75cad5d63ba0c81d72a90025ec6c435fa5138210c2f22f05ac1588e03d2d46a73bd9903b1483c5d3c1fee88ece4e9f5cc7ff5e7e9cdce707e6fd309ce9e30e6fd58a286bd785efb5dcd1dca3b11a6c5654bf7534a1e1c6c90d9158bb86e7feb6f86a5b2b39a0ce0b1476d96d8967c92e870e26c489b09270008a233648fa775fe76404855474a8d0adef84d84f1e5de88466bc25a7f3cb6afe09d404e4abe41bd9403fa2d0fae9672d3c420a7dec10961b3e109d61ed03a75d075ef7caf3dc3bc91cc994762dd3e9c4b6a8bb864095f8cc095719471dcfc92c6cf7646faa8c7594041d8b8e739bb8c33cb1be774c3c697d0870125a5a65f9672e327bd50812ae41550972a549c83a31e373dc584642d0ed56435ecf883553d245d29ec1a4f141ceb1a1c9ae67815b57bd305345e1481e94c2ccbb8b9e3b4db2d12d47f47d8d28fb7e9233f5764b423f0b111db2d7f91457900a355861813118071203a35de3c2ab9adf1ddb0dbd857e91585aa1b150c46ae0e064b49ec1faf5265632933a55ed37bbc23ca32fd2f424bd597f351e47503899a3a6eebe457b3c3b4f55a45fb638632cd00028e38320b21214cb78e091eecbbd3c17802150c30d5aea6db32b7cd778bf8a897f8614f0cf93b55bd807525df430e818f2aeb92e96fcd12c9b578d458e3902ee37e428900ac617943fc579656bc0f3d68940d6d6770629d112ea62004931198577d20ebf2a4419412b6ccb976c93ac96d1ac10b1cd6fcbb03b6ed2263e1af26e236a1d0f8d30eaed461b845e69576bc4df7909497ee8bd197cb136d7947b85d62cb3019ab1e487c7171b4764bf61abe540a4f5ea0f99f965cc881ab695c314213dfeebdc208ecc5354cb40e3b9926fd0167e05e8559aa9c03212fe5d5df250f6f5c004d23a08d58c5b47314a6cce0ca669ca54b835e131cacc8ea63383f9d4c3bb2fc215814150adc5764688b048647e9a783260634506077add0f0599783a27b02662062db97aec5a81ed1fddd2fdea789558b0e89595aae10f26a010b744f87293521ddc03ffa74766dc616e85663bfdbe2850c4d2681e7110699860e2f706f5a84abc9e5dfa2fd78f11fed8faee41b1d2baa5c60db65d158b5562cb79186ff27890440385cb0d2a2691664181c2a999c4fde19a35c216eeb16f849cf0d59d3d11d5e384e68088b1adc798a242d3e2751e33dab3c1ed393239376897db86f64421e0920372da1424713452b50c5a5bab5d31f8383f56e853896f98c2f2f72c0e3ff7bb61f6eb3cf25f62e6a144f4663df2b6c4d512735a2e61634c953e57955896a888bd0bff93ea485754d5988c1b008468853d7859e06da7c542a25e944080922b46f4e7cfac5af084616e7af7af36087bf02f820660be8be2d681f69c7b83e6b4b95390185c500368405e06495f117defae6e5ff225036652608bea5f64a3fbb8fa55339bce0ef2090d6d8894ab05ad0b470eaf7236be07621099474cdff513bcaf8523ce018cf251de1bcf42ed4c8c76f50b5c4b6cea42f35ebc69b1106eb486fd4159de17f14b0b11ffd6b8add3590021a263f26f58a668e5620fd026d6fed0aef0f0a686a43a222f30b514a1a39fe005ddb88b818c4509b5c09a0c4a49781dc1f903eb3defc435d274d1b75424322ef9d04237f907255b0775b9d0595d61b151bfa1a299749a1c28a47422cd71f9a677e3e43773139f57a39042bd4a442d2f44e18633f29138719a3a09650ab04466fb953f34273630bb6cd722739291dab6e4798e72e8d503f7b16c21412602cd953eff07882e389b49b2f72e10a8368a2d421bca5883894041229a320130491c5e6b8d3b587340eea81ced7d233f28d500e9146f5921a4202cbba31bbe9e7660d473bbe1bfa36c6641c7a5fa9929193e56cfaa0565671de15a6bff8ac9204724f24d55708ea2e947316a85f92e32159b6dc5b28d246a4b963cef5796fe0851669b4633ba6dca9e8003b983bc0fe203be14bb0010ab9d9df99b6d303985d59fef52c1d78ccf39697ddb8b7d1a96809b177d2e9db852932cfdf32107662a41e957cc11340c338cb4004972fa8a68c3b189365e454ef4005efad838284dfea1cfecb633797aac2e219062c7ae4992790af6397a9bb8b61097954642c4b33a3aae10d269458d844828341822faba2a7fcffad497f3c78d486d29f1e097d65cf6e13d94948e65b5c6cb0bb67f170554a4c45b243db1e3ed42f403c519fd8e925dd03457194ec295dfa2feefdd6d0ace3506dcd589d2cf10005a745ae7196a9687060ce37de51e5837aec827071db3b61af214a4a6ae0f81af2ba06fe4b9f913875d8e22797575d2db05bb1207610f25833d5e930e0a0c3618b200c72834b269715b780c49eb070aa5c7e41894cb6b5b1b1436eb5c649f8e867d18cb344022505967f9000dd310edce9edc74b79ae67a83be0faf1a861070f7e0d753285f891e591ffd1520d569aea4664220f405e0b6bfa6542b80a448c8263f1557419c5dcc02c627efe49916d5dac8d7b8a3efbf4c926657db4e7a00d5191d51d2f2c0ae3be7fef1982337609c49373f89878f9214c71b1d78efc7d038f8b643a1b8e7e0d4d819bbac85569cce0311b05ef9a44d6ebccfbd949c7a532350e385e5b211b92f3bad79292289f371f177a60a152404a0afaf647670a101fa41cc97eff3672bef6d3c6820ce355028cd02b14147b0e8f9004a259bb37f6de1e53f05fc410e5aad5bd6b880193e73e1b8e8ebe8c83353f87a03090a8ceac3960af70bbcbff26e6117f7ab4855357388ae57a3b00910af8a682a411ca290c0a5c1f813616b32dd98f897769c08ddfaab8579ffb33c16dfc4d0cacc59cd98ee085976552fab07c10677fc130a0c8e7ce8546b52dcac6ea73d459ceb85207107ea00b753930569a452c5f5805e259a46518bdbeb6e1287215068a946869bd3e7c06565d5c6b58dada1f7e73ecb5b00531916e7bb05713bd788fc4e21fef268fdbddf0a2be64b93b5acd76a587fc88977c3993cf5cd7db14eba391023869093fa8363c06e653f8f9c69d22b550367aaeb030d15f0ef0a7062c2e62f0e304137d387e79e638606b7c947426ea80edf8e1f02b5eb95a7d9dcb5c350cb46f2637c5a40036b8853d637872d9baf4c76f82d4bd5dc740f4a0101e49fe86c4d22ed1f2ad5661b40349963731e039b9245febbaf28e43c1ed2ec5ae4c93326350aff952ea52f870ced2aded41096777a9fea119c7729c8edda2afdae782f0a219a14ca54a638d862f4a4477fe62fcc82fbbd24addc3a2aa9d8b01a9a3fa6b2d1ce590c10b225cac58cb17b7c83c7c3fb29b34084314f9db34814f8d6b9ea26bb1aef7b825cb32c4114e97c1526fe25a5cf4e2bb9860a40263faa9b8753c0d7761dcad75f01d5b994acdb8669992e5444a58d30283368f7a7bfaa2a642a3149e388a7d20f86b9c7f446ae3de1ab46c7017010a4e0991936c12dceff38fbd45b05d084b7f39dcf1d02eddd26392e7562dfcb73bd92a9f86fe8d0270aa9ed2a256ad0e3390301121b6e1353171d824f8f9a95e7459431ec5cf3c7b1588c302396dab6711ab5bffc87e87d83be787732630d436d845ceb0a6ce37d9968bdf3a8767ae670d3092e5dd020c78c7f3382361b2aa864f00e5c4721a2e0ce7aae793a14ed6187767d4c3530be5dad9418c416dbbd02ac93c2cce3af6e1e716c3df20b650fa913845e4065ed8f262e39bb88b662360e51c80866d34ab06b58ac6ee7a4719c85c4911fed7fd7fae19b5369d1074b5c0129e99da9ac29d3d4478288a1d85968814b994615d60b0b5f2c5b155d23729c889d1b01d0366008bc3a245aa0b3bac54c404a6bb6edea7e10349b0eb2c9904a8bf83f35af6cd4e318275935b46e3fe0226a6d1a2fd46faced3152c50704c43d5221b86c6120b9c98d61b2175e740465dd70308818f4e3a7b711021d0102b412a7b34e3605d32fb244066ff9755e549cc4c3c597d75bfa1d95fc32758ade921f14d2fd20785a4dcbc2ef03566dfa37893252f18bdc5d2345f33bfeae185df7950be44c8cab9e1e3667e8647afb78dffb3d39a7aa2554d27c9f197838c3a696cb0b8039550588060df48a2fc30bd728e41d3e4145383d7cb54dd981075851e5c5db0217c5df21c23ace5515e1f33c8704fdddce9ee7536128ba08243a29f1d0d095bc74f21feb39efca56ffb68d5a17ca8159893ed9ef7f83c3078395cba97e29a94a9574261b0c9b0895363abeb7a635823474d13b067c48af2edfa5da101fd8e3b1deb7c5927088e14bc8170c5af0cb4f403740e9918ea3d66eea7196f550060f6ca8dba8183feb2579f855dfd7621395725c227ca0c0886cd7378b3f3335b5bbec53673686e8e6ad976640397629ad3c9269e37be537b8f67233e321baa1ce64f69eb31e15e9500f5259b0b05d12def293a77e4df06909fbc7606fcc41e7cfa0aadfc7340467c3c87ccf88e887dad141886efa838b184d155486f65b8777fb49391ecdcc93f865e8f383960bdc3f78ae98c2dd5a5348dbe3406fecbf2e0785716d76b4d6826db16b7f6cd47e591b313cde1409eb01a99c0e3823ef3084cbac576424ad90ce10a272d39dc617283ee51366bc9cab29be56fd3da9571a528215017e7dcd16ef025111c920b796292cc7f762b0a6d866336d7572a71736a66138606823671d468ebe869d9976765981fd0d22fbd6a9e03b219ecef3eca17131d9e9edc33e3e6cbfd69440c1a18166f152442b74fcbb9458ed56e8ba7aeed10f415e2ecac5b0d0d3514285708a6c6d07f68857f42745432665ea83e163bffe5c5eb669591099cf23ea96f90ce99d14e583e8ebd8212fe4e37a2e555e917b932865275f77ed690642bc4cfbd9006ba08effc9645f4f06c84170a91791b03ba8ed1cf4f802c5d244a84962a77e7b81c83519b0525aa41efd7bb8de6d5889bd56313362488131565a44beb51af7cf46a0bc9fcf98b0ab4d4225307ce83e502355284bb2cb04ac16068594fb6837f227d21a8d21576d77735780f98bc56e47d44ee9e04d5a1aa9a826399049183adf42888b50848b666a36e97db4e1b0e1cdef3adfb4cf565bf24ed31b013f6811c9f0a416d1a626b16bd49b348892cf509a5e3c7fa663b9bc2ad15199e4c31cbcc9a7f3eab0a90997939f9e02ccd667fe783a26c37d6171ea2855ac397eb275da51497c560cbc858d52598190327440d255290d5575370221934e23a3fdf8e318c62324f385eebe9ce8c62ade15f6697365572ad2d44aee68161541fbc162d64be74695a3dcb681d96aab9d862f5f5cc62510b1578cc85eab0dba800577283faed351d9f8fc3dd6a80a59f53a4e453532f4a2361b1eed124ebfcc9125938227191f90c5aace05ea9775be803b74705cbbe3ff6667283b0a3430f898d8b6db740967fcdf4029f4be930c83fdf30d179ada558d5f6d8e7e6c9bb62dd03a5efab0240828976404feef33b81ac576b24d17218d0fd2db5089dc0b4035aebceb6754a74414a69f13dcad107125a3f6e093533faa20f8665f9bee5d233e8483c2f3b5f74f6139caafd345c31a241fa3b3c66ae1dbf3fc18fa3caa82a041b50b07018e283cb4dd4528c406a195c64591e1ecaccef9dd2ca5eb52758ca7be7b05112dbd451225720516758de72ca897ff6abc0fec84b77451436acd8e6163b4e7211c58e9c88c70f8176fe612372c11c61b78420da6d8504f8a678e03aa44ce9926a5d4de1e53f41e87a3e1f43ba7d6d0393a0b1027c40a2849794e963bcfa7ad117461c4ea88fe017d7f448d02410d6949369b2a531d26e2a9eb1374182400913f9b7ea2c12c1e5bef9207f36cd3c6b840d0a20f52bb3b499a638c78d1b1d4cfe5b0fea4a51bca2afd49dc1afe3c76a66a1eb5fddb96415bbf0bcdac096cf380485ea6e02ded5aae7e1999e763e960bd7534fbe5cc2f233ecedadfd4fb451154b221da6b8fba456e0c6d5e924db2368bfed38351f27dc6fe60f3ab22b987b51c3f94ff7073e88eda37c3fe7d9344fb600d0927ac96b6df0459f5bf53fe0a82d6c1df1ca6d71fc2c1ee65c78b5123cef38964eeed297c71e53df5294e3b2bd42ec8b1634ffc7476af79d0c121a6c0801500cfc1151525eb1dff1ecfd55e3f6c67a6087b18640a1799339cec4630e3485e063219e44cbe538f39c2f0ace8b0b2b9f04b0bd936179ec1e8b1f20f282d400b858346e3f70e93893fc5511badfe69305bda442dfb7f5be6f017d4a047874647a46c1c61b2b675ed646d3df2d6c57a44d493260be17993100ac4d025763f5b6d4f19115d89df8a4a46107b185ff4a42a5c540b7cc2307d71cc2c8362f1e391b5c4d315a090d954040aa275a7f36b7a88a13486417f0db952b461d3aa0404242dfb2dd255df959c6ab283f032ba836c1be514f32f2a5eec4d2d8a7b9a9cdbfb3a3535","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
