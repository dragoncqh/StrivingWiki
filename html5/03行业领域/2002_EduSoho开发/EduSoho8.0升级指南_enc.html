<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df5dd0909fd83d211e7f7e90f54d393baf0bb2399f95635eead265fd95437dceb830d42de2528d38b21f57643acdeb93622ceb1651da06d1aed13044a4fb09058da660ffe6e6df2a7c2bd81da9fe9d49ea52b096d82b510951e3c9c46416b7acc0cb4407866333e4a3f42fb6ae00440e9acf23eb82ff0f6bd71a528928a4efe5f27d5bcb1f8683918bee6f10b569defbcb8620608fd9e4869fea8496bdfc2774961f9edc2d7167de2a9a0269c2d20926a3305c4a61cb293f2055a9df55895550dbfd42b08e4666d6a839492eb8cffb27a5c63f4d9eb7e7ff41e0286839b9e4a2f0c78c327e7a098afd1eaa87811721b45a8e1b5ddfdf27490cde98a9225c119bc1521d8dc1a10f67e07aa0356bbd2ef5e1d61159664be4aea13fd7a3e8f20f598513ee489c2328ee59088bcf3e66bc954b497f3765f326938aa6c423e8d7cde16d3c3e89ea90acf735b5b83afd687b7b613778bfeea63eec68be73b9a9b3edbdb9ccc64c38cb0c1100945759e9ce20b464d689e9d5abea1f6a80125bdca7b1e7805e66b5db4ea17fa5ff9e8e9b7bbca549cdc4c546ca2fb8a712ca20adb2659d21f74677d0b578196728be8189eb12d33dddf4efd32892a42fcdb66101e23245c31ae7a760ff48b79c68679d39dd64b420b13619016b3035833b65a6bed8e5bf78b358b51dfac8127f6618a3148855a453019312ef4fa478e128c073a278357ef7c5f95035f9630954362f284652b1b9006a15d5cf75f1a5feabe8091792b49cd1bf545405a8412a3f26502ee68050df562f4a151a5f4bd3087d6a9e9c05675d5fe339f56823a6e715e334c8347fbb219ab3d62ed482d60061dfc1f282f9d370d2a6e7394154af1c820e6bc1be8b3cab177f077d87d3de74f66ccd7ee60b46f1fcabdf68d1070156504ef5ea20f1d4af5986bf4f225010095d621c8dba318ed733e02052d44c5d7f1c07b478172d55f5ece4868f93eee95896ac133fcbfcfe96012ddbce9b6a5409a0bced6f9f6eb86512ee0a1c2d37011a3f5f0dbd99c4851979413c4e6492142c0a833242d4bfb33832fc3429edd0e78989b5df5eb686ec03d4f349e14ed6f9c2e6ffacba4e15e6274122c0fd83a7c40a3afa9526fb0bfa5b5def15b4bbaf4ff45337035957c789126bfbb2ee63480de0bdc2831b4707576132efa1f0d7a3337f1aac95caea9c6f5b0afcea522a2ed5777986790db611dee8676c8152189744e30408f26ff42605bfc9c9ae925b83cda1203d8649b2f92bf0efd45cc3d9eb3a1b0e8e3fa817da7c4e5cd721e0f6e6a788724adcfc2a0e7c6e4862084f27355f584aec12785dd97d360934ac493d45e3149d9756c431df7d59a0d003835687fb867369d596191b5373db1da1c1fd598c9b7f58d96f5773d57f3314f2b3ad1cd53159bcd58b4c019c970b04c79b687e474a4da5f86f5d9112a5b1f8717eda8ba0e4948b223f3a86ddad7ccc8ce4c2021f5c2113181594c4400aa25a6ec90cc9e39ec548d0de719aa69791567dd8d931c678d0241228310458fec62e0f8190c5932b30cc535050824539912f86c55c488dd1dfa6a410434e230e6fa88329ae67217977590da7c6bbb157ca43d72c76d20dc69a93617b8239aaf88c2b0943d9335b2b3d9334f97a793789fd4eb88ebdfc4838f5cae067aad74ec96a63645262f4403405e095081d76e6803c932be0d0a4c4e75e657f858b6e7c798b4fb4187d0eccc17ae1d0bb2069b4584774b2a1bfc90252053c6b38983127fa43aa195ed97c2ebf07fea165e19b3d3d01b70beda11a7a78211a99cca15d7141532ff57b7c109d5038f48ed8f3372aae45e20343dec3b59b6e71d1cd505ffa010f3ad5efcab6268140ec806917c99873f8113dde8587e95f49be2c3bb2c492580c1670cd188ffa75d82c65254e1dcb7011fc3696d21fcc5eb1a95cfa05ee61cd88def6006466109e2f18bc56a9775b1ea3728a106e78443ec13337852326ed3bd4e40cc2c744ef3fda1d361e958be733efe44c1d93dec46fb70c763a352a5b3ad854361e31ae8125d3deac922ab3d584cffcdf1ca7727c7615c61614683209ea763eebdda0a75ce126e6e4df7c4c3295781bc0d74b87240691899562f0c6393c07c3a9b10e70b66267a17ac2391cc94cff2c0872937520bebe62e5ea8933ac6fb35da46c44c231a2d1b076319be8f47903c30796cca0490cb8f0e09d81f0864f94cfb2187b6d5ffa5b596e58f5b27c21c0009672fe553fe4f2be87c3f1582f12a9f6cde61b5f8d16a11b221ef78a853c81ddce7548f38d7fa8f08ecfc60f948af87fd41c870fcc7b312f9a21324c27c7e4914ca2476c74d6c610419e045f67fc6e8e42e15ec767d7d3d7a7e48b4d8862557c4cb0a0ecdad1fb022c351f11a03440e8ec2d50cefc45508461ecbc6e66213ea496bf4c5e3f11e28ec347a9286c6ef0e6fd2a5778ade4ec14948113170e5b5038803eb72aa7c50351a90fa65cc46d7e31eacc32759dafe8417826e34de32a122d1bbe77a7fd678c17ff9a97eac717c72987230725fd75442f7196c4151f530525547314c08df9840713ecb7eb27e105d57ada964272518130f7c6ebe0b26908ac8adaa67680529ebb2338ac36612ffcfecec43756fcfec1379c2aab67684e442b15572cc3ecb899a58621a7a0376161c29df47b862fdf727b53b47de837102624b3545333a9858714d381789199c4c1e6112cc4398a9f58a89d5d69cb581a0b82c4a6e70bd07b254ba2a07eb6bcf2beef7c81545aab466d23d50f27776ea609d80808e385cd643ea879132c75eb3547ceb4f617624eb846ade6d1fa3b917604e930b9ad11cf6b4261ddb01e4e33b2f74f812f97c15eaa6a621e4c44f0612bdf50b88894d3765e98422dde9bc9e48ee9008dc6173c205847de0172f5b541259d1e2313e7fb52b89c6b8ba57c7ab0bade56e907a0abce2fed4a5d177f8582d8d9a41efe51300d6dcc65ad60131952312b355d404a9766e830c60660ae063616a4e3188434a2b9f0bc90320b54ff1d7f753907c934a74f20471380f177db3a6d7da673d6f5b176be625c539fc46aa354343d5360ea8a9d59d797f16e61c045fc9d8a0fb7bb1c370b9aaf848e9d701c7ef1b1cb3c6b3c6e6a64ad589d677b7152e554b663a667e9cf42e54ab4f91dc0e1069dcacca5993276f41361a35a77314daaa6a908645585e63c8508f6957d7a02c10b1029957518c1fbf7a93368355957251efe573bd2d6f6402ed9b698904a7ddc0468ca9b31711b49b4703cbbf93878eaa273c3f64f0b169beaf463a9d4d98fd4530d72ec4b2b489ae32be29648a1b1c2c510ebc684e586724d427738eac5c569a95e1e02ecedaa1c710a647364a654d92c8b71335c96f49f47c617e19a5f95d91a051c3139f0f1624440e8902626d06fcca21e262b17f93f128329906393d09b5952d1b8231a302bc7b076cfdbec4ec543e7adf5cdde58853b6dd48db3d04dd796910693953986409ddf5b9e4ddfa88bca222fccec55796709c7e72dce6edf9674f21402387bcc2d28b32bd9b52eee017663ea72fd0c85b220b3c8e33a9439149d425807a5848fb5aeaac34d4809d92c566785fb6577a7d0f1455f5185897733a7d2b08ad76dec9c0103657ae49f77063a8672b254315fc58409d387b41d122f94383fa092c2dcb3aa03d2419e1fb9772c086a6d736a84a3d4516832c09e9b1648e4edbbfd500412c4a4d8b73bdcbbeaa1a745b9a3654fe4c44e535c2e8aa5f473e8de6d8b2afc4037bbd974030770de6bc7a7b9d2b0b9d6ca2a10bb130bade11a6dd73b381530da74d28f34003c6dfdd7445ffdeeb3b88199d223623d7ffa215c9e85df32e1cf5aba0f803694225cfd98ab5e3bd066ae5321dba7a68decdce3a4a4d63abd8fb9456b6dbe7b4e80556a746a86ed0a10380663801efe4d30175b650c8ef65a47f5a804844573c138fd8e68472842c4c07c0e7003855b89a8826d6dbfb0418ecccfcb1f8361ad2b59df772b976b69064692a36b32e95dbec8fb05e41637546937275448a9c3c89ef6e29c7c9c5a2121a6497a1b9dcab88c44ae0656f225ad7425e051cbf1674a6c53d592b8bfac70ec36d0c9d58a75e997898a0a9d00f25b226fb62f022c577d0f485fdba9a4017eac701ce68a05da979c95b573985e1f8e11532ada51453e239d8cd922b55f8f2c4d088420f0c76622f5a3ddca1eec53cb6900694081568b7f2696717718892438e95915cd6bb402b247303f9eea36cb2ee9e922539377abbf057a6ce30198d9ff5fbfa22814112c0a95006af1f7ac51f6949efce9b423fa149c242e6c71c6a92e9c452b9fcf1100f69a086fd153a8d3e6a1ce5ed35ee0e4ed7139bf32f30fd772b57f3b6abd6189a8b45a2d689138587122374c3eff2aba7cd6f02e6dfd2340799aa8f8e00689332ce031cefd501caddc1be7328dba3a745a6a03b3f61ea758708722e013776fda14f048bfbac06ff49ffc7f91a71394aaf075dd30cc114ba537ac4c362a08ad77bb6c36a63847a803b5a9a21a57dbf8428e3977cff07a92360d741a0c59695d47da0a811b65f43f6b42b13fbc309e62327d6ec5e9db1ec57ae042b74d4be0eb8e23f715c29e6e086921c888d10281770f7e64de49ff19fbf7e04e2a927520ad61041febeaff82f22e1e92c7142d6b63b47fb02a430f0eab9e7a91306440465f92e1e4b43092b219ef60c5727f0cc8cfb8dd0673f2c1a2227aa022364c2ea95b6b8e781d7a09830d47a6646b1b34a4fc5b080b2ee8465a934228ca3dac1a7103bd6736c2c498a773ee560ccea394f2ea1c466b4adccf1771d8cc4848433c21f20405ee00d4ec05e0344a81a6b0ac6b6d0a6806693a30a1b86731d95fa1abe1eb9cd75b49ca233bcdc5684c561d1ba2a791717f79444c474cdab5b43a96da6fdf1f0564c946c4e6ccc9923bc4d0519713f2cb1ef78da8c0c7f9b8a7ec0d9260c5a58e27aa301e5bb6e265383a73e605a00c17320a12b1bd0168866cb01c54a6e7f30dd8d7db57e7335c5f6f3efde587c0dda230535a86430fd9c5e3b819104aaf4ba9320d4bf77c1c0dc11b24a7ded9927a2adb64de0b4cf97d5600fba2ddb0a8a2e7126fc151a0601854b8321c2f54c79c23ede87856f3d5c1c68ed1f72b0f17a582adbc7b757643d0d3029146c668d6634efef1f89e6ff5ba0f8e72f3edefb6eab4c1cdceccd5a15608aa033d3689d669dc18f89438204974a78fca337e6b601696b2a6a23217c71f2dea0d9fe42fced3172367e25863734d397074b6f5f91de0651afdcc5651b343febc835af7a99bd6393c07b86d5749a1f9598ec913fb574bcfee380dfb3973b97ff63db17e9235cd87006c589c17707451e9df2a576eacddd7c3cb4c55283af5d542738463eb46efb058a29d53667dd9c99685a3a330356b251826f5c709121ef7d2575dcf883f4894bd709dd5e4e9361180e7ff731cdd04044a51c2e43565819768e6e88ce0357af4c74d460b12513a77d113259f45b732d61712317df5735d726d5b58e8ba83b037934951eee06fd906f16072cdbc5cb1cb37c96fb2aa687ed713d64b939406ef6d711b2d17ae93b760e28ff1aa109916ba0c568453891824ca78f477e8539f687b69f64f57a6a4c469bfda8e2c7a5b6eeec44a3ea559f33b28372e7ac574d7663712cb589217fe10c25fe96bd7cf36a6ab0098b8723fc8f6b7011a6865ec5e0fc625ef1ce0dfc85b08d1c499d7513fd73cfca93aa68fdc9d2ebb22b84961dec5660e588a2840ea270e2a42959ef3fb30b6157ed413aaaabd7339b87c8027c994aab4198967e1564ce8abec9173a02da1ac11d8c5917b7275ae5233951359de2e6c9bd5922497ea491f78525a689adca1ad86e26309f63dba0fbb4bb731f91e3f8ef98e1d02b20b76160aa0f57ae73e53853dfcf4fb2459350a9b17d1d535583ee927860283bc9e6b426a7fcb4e071e6df3eb67f412231aa7d7b2394bd50715dff81ad395915bea689863e026905a60ef00702950ac1e3ffbaaf5792a0b1be9c48995ac3c883fe4e545d19b4b15b250bb1b94d1bcd9090d54cf647e52f1ca98699de91d5144a798bc61853f5f28febe646813843f20f98361cab57df1babb939031e2628c733beba1bbe72bd856eb68b90d11b1e111165cea85d4c63eabc277def9855124724538ceb4c097184dab623a81830216919b9a33ca862ec725cac1fb61d7becd8e6f92485b647b8e3a9912e9fbd2f8ad9ffb1fb569241d504a1c112f32c543008ea01dd0251dac42b12e9d723777159c4dbd7b0785efe188bad7817443185fbe90ef33205bd7c8dd365d36807f4c0de8027a2c29d7cc232a6fbf7a6419774cccec6f32aba047c83d8add463b8384fc4e2151daa1f80de05c6f80dc27c16bd8d1ce012f537751a71b20973b0bdd4216fd3dd0f2b3782f9aeadfa08d13217d7e775f4ab4609050c91c47704d6be3773da9eaf60a579652bb62ff001b3a1360a369f0957865e8fe42fe5c90f010882ebb26214dd62071601ff1e2705bf890e5e8b164b079fa4d93ff120e72072cd55046e61c66c8a1fb7589a2c28788f9fc6ae9d032596f6a58d97f07ba051ba302d34cbb42daa697a87e36fd6a71e704425c8e2952eec82e66af2e541558fd5d8ac68f128ee6a3bf1f44832acd4a76877730b2eab0169a0731341d4c3d72dd82e4d8bf5e5cd98590eec5e70883200bc3e921a25714a8312c21695b54ccbd37439682a69743bb612f99a8466c05a7ab4c3e4877f26e01fdc01d35f8db9127625b50c976c87fb6b20641942140233923571d26bd8582edff6fdbfb2b5c6abd55c74dc779252beccd1fd4fd258309e1ee6eec13f649e3f3ddca54ee90444dbe6a6285df8b3e23f5e11ebdab819e0c650e4924d12b265d1735e101b96b6655f622faa9714c33d582027d450a458a1c9aacd11de11eaa34116af0167ebd6cef5c3c304ad9f1307825443710930ce96a587dd0beb6578a7c4d9bf33eff66fc920870dd229c53078bc52dbf81b7113742a021798ff84f2c82f924d31a5d49a09f9851a0414fbd6174a5bb4518b4ebed5ad1bcf2d6ba82ce834ed338c4e56d48725b05b146b93df796ae2d0358f182ac56dddc29aff072d6d590d5cbf3c35129d40e82048dd7f5f723293f08494727643c7034f13efd22cc6d82dac64c39c425747fb1a98ccdf2595610b48c77868339845eb73cb1b052ccde4d9a19f44b8e791e1827f47ad0940ae0a8476a1c43c21054f6aa8a76f6ac39890abc937d25b6ad585a284e7d27e20c098d44b8def9f6cbee565e29da29cd9f3b2b63116e10c9d989bc26b34ca5c62a068b9d67731751d4ee9bef6dc895d6e001391155eccc1ec7e665074269fcc700a3b1dc1c268079158e77de86cad5abd2505df587505455e9add5b3c7e97e37cb75ca4a3502e742566f5c2322209dc8b94ad058073d992245b8b4240d32620cf0a03a515cee3178fab93b3938d989798b344805491df77cfecdd363c58918ca989d886982a6116888d2f0a8ea6df99e91db3c98c9ada0834ef3c2cdcd97626c4d5388787cc2dc1b2820e3c29e4f663310fcc2fb359c9707c49161f96446d4437f227b24eaba7aa84ea8ea2dc293e6b4fc8303323e3b03668361a97870f4bd4e82aece1d1b25a6f973465d89b1b151df828b47ed97438aa177c1421ac31665b7a9355e69feef7cbaff02509dcae88395efe169862d9a1e63298b7d345bab9d17dd28c037586e06ff9d4f10ae65c79d5f3a36d373200444e4bfc4d9cf6546475b42333ffd3627d05586a3e4a9bd5da2330f96dd7590841a8c60f496cff9e630f6dca55510c9c9b9a042f76337de3ba929d8d4f92795c04ac1bb73da26af67a39f0646aad7c321f3dcf69e855d0e49b3d9b4b51ef675b3f56e461ea3ba8db23a004739dc338a4f1d835727ccff7a0a5a3a2e65507f114dc3a05c886f3fca4f05079b110829e28441e0cfbcd97304baee53044a1ec12e4883b25bd1d2b1fa43ecb7dfb5a1a8a74f5eb0d4ff88f7d3f313080d3febaf1c033d7dac662057f565c94a828a421e1e587b60a85f4f6d022827f63e8198a64c0426bd2f92f83367cf37b53134703480229849301ce8eb0b33886e65a11a88c83fb13ee33c4b8931e9db2b5c864adf3ae9a950d56bf11199b06aca1ea4ca02a345ecdc4fa6ebe6325a80deaac41c6e32e24374aa0ae60ce8e147bfbab4fd283054af10a142fe3cf70b8e15007e62030395e6000bd66479ada31f70efd82df0011b5b31d12d7173e199d71b4d11284b769c95d06cf9bd0f8d3d6f071d40627f0dafa63473ffd5cb0f01b5703f4a2733e181decc3284d83af85a375315de318deec623541988697a00a70271765e28556232e041e25b2c8c59fcfb3352e7b4f4919984a6e4420d1857814bfc01c3a252be939af4a19575afd3c1a44839e8c14eb68e010c08f43ff9963a73f618f08a560b768ac354b5caa061d21d5dffbd6715b335d97d4ed9ac9dd463fd36b64c7e3a166c14f0f3b21d725599860a98b47a2c29c3eb9a26f038101d9cb3009fe4ee60e4929c27ab367252453c65631b11788b797141309a8f7ed593fe269e06958dc98ace843d4b39e7d3cace392ab7a3a562ad69fcb615e2a59eb8a593681329dd200bd1d3df14deb845f281555c3e4a9012bcd9b8de42a705372423cad8ec06974216a16634274955fc521e1b5f358e90a1adbb13305bfb424ed79a9429e5ef9968284d0f589aaa4a2cf4199f823cf33285f1d6371af873c309bdd53a1369d5e167c1440f62902a6045bd9e06df5f3c30eb6ffe157931d93c05cfcbc438bd3eb9bd9030582e1b7c3af5a61dc21048f01abf1366694a88d5a0a2a8a958ef18100c2048727359debdd58420a240fd7772df0fd2bcda63c5235662d0dd8bc61b6d8680aa91f717b8e717e5e82bfce1beb26dc46d02fb65e4dc385973ae1469691b5e376e07c51ded42a8cabdc0586233342c212f710ccea0bc0f9ccc5ec995b8a8cf54230371e3601d16b9273586f5b9753bf0455f4916f6f716067acf89bc0e3f408c83890ac934dfb4613831a28b74268d7484439bdde58f414b7e43e7098ea950cf26249edc834271c197f707e8fc1a0462c89c0e5664e8956d5a8172928767f6895fa16ae230fb8aa0c7a7d4cc5b8bbf0420e6fb1e72f2cd7d408de5e40dae45ecc05ff272bb15e9abe5c3ee647b656287199489ef0c4d90d855fe7b1ab77c84894d83e26a994ff9b85b0d9113e721bc6edb520160dd0507ef83b289716c9b39384987925f6f61b002652e30b83de3c3aea7e1e6a140a415e594bfbd5c300c9ea1bdd65e70a379cb766552d0bbac4c0e6fdc7cb5339fad61f3798dbf3b6c4c8db93b32d5284217415117fbb6774ddf07198d8d0c7c754e6478834f3c63476392422e03fc98d5e266c7a97254040377acba036eedf3634650666a2a16ee58ed9982630d0f97ea7436b0f6857941cf5988f31e60cb4cd9f5711082fa81398591a15016c05606a030bfc8c3fb45122638edd6a504b60819750594083a287ae31476800abc4e9d9768866fce5a985c28e58a7edb988d1c007e982cf666096793edefbfa316feeed0dc41efe74ead4451bbed5309991c41d00c3213c5a19391be3e5a6e9efd68e3826b94d9fc396209da09698907f8293610d8dda0ac6d8504cad3a6369926fbc822bd05203b5ebe622d56aae396c3d4a2503d34d53783becac3138c0f5e3b1121a623ffc02e2fac3e316ce06ae814b26339667a71dcb39025f55788f8b9e99afea35cf10bbf092475e8424e4a79bc7070039c5e09a76f4e24e57f2e89d7d0b857c53bd2ccaa1e20ac7cce67395c5824ff143b7c8cd0b3d06e8ab37edad132c79945b23684552ae3d7b73c3137ea569fc3e2834c8d6b34d9fdeb1dbeec3d09b3e10262ce19a1a0cca1aae833c54450bac188542582b6c6408984e4cc654ea859f71263ee749fd1fe82ba9d715b39eb57241bc3ca0e0a6318fe19b4cb80aa66152d84923668f6e076cd8ba2558931243d119affcf5c2a23c482da6906fbc9267472989284386934066bfdbf045074534018e88f930576c271b491a9c07bbd1ecdaa180cfa5df5427ff9bf1a634d359770119057c31e433801b118c6b638a17973333583ae5716a390ab422a0242be3d839294c302754ba8e53718463229c33ef927b36bb411972c2441cdbc8b1cab0c6de97271a68096f09c822386c312dc547b285d7b5b8309194c4c4be8f2e978db690c1a947c9b8ee360bc14cfd50a617d0546e6486cfc06b4245df76feeab19720f5a3f020e10f272c6f7e0d66eaec33336c8f7007b3802f18d1fa3cc9278c35997e0d04a57c6c9827b946731cd7717a3e3c4968bbde3f814c6645be9cdaa63f200389d0881ac65215a434a449085c043bc5c52537ebf39b15598b7402b2b916df88c00a58e8a8090bcdfb2e026bfeb947cf7f0bf0c69d8e7934e55287d25a6885e339a9c183473310dc37923dc86c29ac0dd5008a12c0aa755d7dc09cf2842237041ea7b748dae882e081a36425dfea0c27d8488fdeda2b1809a30170ffa0a1d0e28a7a33b2b786ae5bd31c9240780499209a646dd0eee3f12c88c2f4f16a92fdce2fcde546c024c4c9078a7b4d2f54af4dadb5baaa43b75706cab4032f7162788a7255afd77e920581b7385413a5b66859f0985a811710ca572a52f1fe094d410c0f1f15605b34a02d19bd17712818efe46d5785fb226d4c97072c48806b8210244f709aa150cc9b7a31bccb2581f4f2aa23fe719306e59fc33a73569991527745d992e3b12917ab37a2492e14e22f90ef69eae232d29f5a6f128230213dd46b5f9294e828bd0fa167f443ecdbc9590226f42c5d577d39023f296f640314a52f328154d4303bd298d1fda50b97f4b9606aed1377bc212336b275b34dfaa8a07f546503d1ae3dcb9e9ba599fdcc87368132d11216a8b2705be0892218e5f092893ddbf853f89f745c96a016e2b567c65047c5cc65400fb65ddf857d136fa12b7cc49fee1d4a2eda5b6399df787ea148d9c78f52bcaab59a2fdc0edbb254bcb69a9221b9ec44303c562c2c83186117f22f03418fc96cf3200e249022916fe9b82bea24418ae9f948c25832625f1f4f36a726846b4532cdc12375b315415b35e3f860e7cf9f3ec1f9b18ab11fb682923c3702ab0bcbfc80765b1d21b4dc60ed413796d5e599846fa5fb0271f98f39041a06df808bfb4c033734d21326b8c3afb2a52528ad912e44b903089acd3a26d3efad08455376b1773bd2d004a16ece4dbf56905d861459495ddb5c0effa24f3fdf140b519864a3483413ea684188f714938ebf0679dd8078a59a6bc9f952216d41f5e6affba06ae9a0eb41b0f6ab1ccf84381b33d2a38fecc6b399a066c0d1ccca8df6cee7e2efa29848821845c2d4e4fcf7a1d1f4df1b848ff87239eaee69bbeee6bfbe44568ab8acb5d9b26a5471343179faff479b6166c6bd766699bce1fe74e6f37b784d591cce3e27e15f104d8ffd7ed63029099d291c0412f06a5227c7e3677fe0c9e10d7ea3fe7319180d7702ef0161c41e4af2d3d5bed10d95dac0108f3399a9328577337146da076d23b38794d4f97c63c4f2f1992c4845f3accd3d2d4735a87fc000ec46517c5a435fc65e57faed3c6ad1dc9e7634e11a11548e269966d2b3a1659e23d6289efb48b37818b839bdf105f6b412a8139e729fc8ab22e75133d28565bb6adcab7590c300ee3188c36e0448adfc4f2811dfd187a64decd7fb44b7499042294255088c5de9c3695b0bd903c469b8ae2a434bed6c069d6f1e7668a6e7c753880507ce61c436736de5fa4055f5a0afa05459534e630dc94522cb616291ecf473d1ba15415a86f9f0042301dffb8ebedf8a60c002e316f3a164e1317196d9abed601493c975651bc6edc11964a0d24c1ac48832e5a94a9ffb4bd44a3526c226f6076dcb821e86ea84b41b6711b07f7abf3a82d02bcef707e7d0b27742ac6b674c946fd83ee236c8dd7d267f0482fd80f351fc6e40d9587f1560ebeccd4cfd030a61e6cfaa58d4efaa04e90a8d9aa1f3f91bd7430b4c5c4f68722fa3be33be520847d2512378612b4854c6d14310791e51d8d41703e6ef06603da245afc87450010b8e2dbed025509c0b7be9cf376ccd742fd62d74f9162cb7260af082061462daeca3dd6ca9b5c84169a2325ea4c7e6427921f65a5cf31c313ec98653db6adafcab8a77f0656eddb25a0ce59e5899b8a9502e19101004ca6e3115b4b3f7f215f4bb794126e97f4355d4f783ae558d7a93afcaa5c1a8a896205b727bcae2863c0376d9e8735f836983460957bf9d0a2147ca942c75ddbc54abfc55be57042aeae1e5c499905b0632bf88a70d201afc66272f5b8315d36effb1c84f94fd54cfec410e01e2b915332ef1be2433b458a6834eeeb994d0818946aa627284ad5b76d28ad9d9582b4be4d61528a8354c6901ab7a7a477ecc6e81aab86c358c8d4350cc2d95bcb3acd93dba16aab327bcc0c0b289b134ecadfdcaac2a4869f3d54e4cfde5ae39b697cb6217f2b7be5d311b5d5698a12485d98ccc4f2104e8e51c5f07577c9ad617756b1e2e89e539c3f6321244e8df5cef8cdc83a6b225e1cc3f03bfc13ea697ab6fc3cda84e0e5b2eeb7fe515dc8718a3fe713c797a7cd5e7346bce33242b88b9b3a23328e6c9859c32a6ab03ee3598273b3d4b6e4ab2d8e91c81337ce5b60e68659b87809fb3e16646c7af504bb81dfd0385e5c006fba59712a2d0d0ed060fcf3c2baed3181cf6db61a72f756808fb0ba6723016e8e795623e5b6d1a1a51b924278f1aa6349740d574db4d95a5e2eed043b7b16df2823e1f27b843b109ef60b591976816af1f669be3588207718e7efd3517d1ec3b8851595887f7d1e48940480b5deb0815f3c66a84ea21d15f1671b0d91a272bb5d6651949433a94735f5a7b4245495163ff10ded085381bf453f85e43b17367092cecf2857ec5a12f8414d3e81071182e5780d8e0793f9a3afaab4c2a77c3752c4bd6e2809b16dbddc337f62c2da8ef58a94230d603d1e2765774ddbf0f7cf06d69c93ddbd7a6936f5be8d489dc97e09dc1d4f290ff20d6d469853ef2a135cc03a56c36bb8f0202fc45f6f62c045dfeb48fb4a6da5099a7048ad09e0f6c6500d35b45410e1e7740bfb4de9b1b951ee766e5310b5bebd70b4b512d000ee4420ad1cec26adae9fc52871b6d9e5866308b05b2745348547594144a08e8c8ab74df5e1fdef9996a14b83fe3fe8b9c8acf54e3c6602047581eec97763934e52549a2054518566dd330a6dc8e03f15441bd7a8216ae242efa699d634e085c52f47f15a828de4bb57f5bdbc32f5d41c0897b63771e0ffdf221eac1b2e240d3f489fbaefec1d384581fb8be33b61de4adf727a006870d6ed7fc701fc6326bda260a97a99302d42bdc2af7579c03fa0f074cda33363e14c95359e16c6ce7dc20e441e000c6b2044f97e85eb59d1e33fa0d4f783f2758f10b43422cce1980d4848b54b6175d57fd981eecd0354233d3eb660cb789fae4a8f049d3ffaa0154fe3b4c1d39ab6ed62a9f96fe9e6e3cc0a1560b743ae33f2b53da0cde2b114d0072c5373fe5fd29e3478428c8140c775bafd5b7df3cc02d09fa0f43b2cc61e37484ac56dd5ed7b69e7568adf2cebe09289373ba5110c639e34cd280d7fd4acb5db4a837b1b6c097edf9ca08eb0c84c8b142b47359c5d05f145bb8a2f0bed3cfe00335a9cc2539990879cc90d6615ebebb01b1a0fcfc470fd1a07a4138376602373c128dab813f5e2c001e2d76ac53816f95843d325247425607a711a89beee4ed4e3ce5aeed6666933c32b26448f0136bab8614b30cb6b07f22693c26d0a1e36e0caa06738c91b5ff1e1558ad96aa5e8c71656a4771ce3ac571863daf4d94ba70c4dcd0f49f496e5d45906fc369ed1c9ee224389423756a6a7fa62c94df4191a905fbb39e32d5356ace24b48606883d60e7810ffa3ec19c3bd9ce2e32a9c9ba1206bd98b16363213fed0f89cb716aa7770747fbd69443d0c1f3d86d80aeeca906ce4c31b30c7c4dc985b022bb3fb05c9e800dc0fa5ee58d93746d8e47998b0b73885751e71264d4b700c85eea4500b4bc33725495e5d649ea48486ba2830748571e77774ef5d7fc7bd01ca54996b34a5efdef43261821755bf0bfe35a89cde55d516b3d648c6449ab3fdc33c1a082e4c24adad273e4374a2b9c9d723a2aebd2eb864ac37d60f6a6d504741079fc2e9eedc7c927a27a46db0551799f23f5914b61d5476ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
