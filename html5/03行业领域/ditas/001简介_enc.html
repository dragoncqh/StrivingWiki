<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b27d9d3f56b56988201fdb1e0e179a7ae5ae3263a0277cf346f585f4623171414bc995921ee596b2b63009ea9daad26b5ec43267e2d36da6d797326bb6572c70250505e665ae81f269fc494f727d3c6b5b63a329c73d9909bacf3fc432716d3f16f532649ce36612489f2be1ad9a16a72ba19cf874ca1d8893f8943e69d29cb4ede4d4263b67bdd3ed942c046a64f4bbcd343712f10448a764b8d43d34520b3e98511dbaef27b0b64c80ec285f43b4ec93b8911e63de3dacbde482f816f92f4c689681c48ab306787dfde2aa3451b912bda3d5512837383cb87b2cd15129be6fdb25cc04af6bc547be05e96aab00a4dd879d6f5dafcc72ef9b24a6cc434087f80b95aa856edc159e2d72f76ab9a038d49ca10fac76047aa641d95676a2b43a7a558ebcef2b75fb509f4c1fe05eadc7f9247e45cb10f97dc3066eeb3edd9d0c2ffbe00793fa72800afc37624892e68d7462f17e0970b9bf8541bebb2a57a3675ed87dce43f33d2c4f46f486770fd6f27806ebd8fd75af055287c28075aebe0649e348883d75c6c8e48bd69c7936148951e1fbaee749b0089330783f9f729033e54bbf6ab795806c23f90a1e7ec9a6ee096ac3e84b59f69df453cc868114f2fe1fb0650849e1ec71e7caddd748986841e1bb283d9f6d23eca806aaff329820bacc9d91c38330bf5a6691126c43e1c21c7667792860b16145a88605b4b9a463af10f478533afbb67ac3546e75cd494f515a891cc237be0b73cb37df0efe0dc15fc57603d30dc3f83e16adeef7dd1094452bcb4ba1c47b0d8268fe819ef7c57b02e7bfe77b90038287a6688d17e7c3601392eca8064dba61158745855d889f89eafe567541274d2d8c306df80da1683f542ace41270191a104037e6a82787d704367abb9193bcb1f45d87fc0dd8defad4e763d866b7def3149dfa52d59599bd5aa3b11cce96b1354f0409b3cc003591ae554f4f085babf5539d93b8fd3b6815caff5334eab72a80b03e763df4dd845531fc0ab2d14f156bf26046684a55ec255a9cbef8a3d0be61fb111e925ab5da689754331e0db63f3e2efd430af52eda72433e882d867a83e971fa1e7bad8ec3627b94cb7c1c167c3dcb4d91df4e25e6d0c8fc87814fb5e2c6fd91b82c18e36c3c21da161360367e82d13ea68105c01e3b149a8107083a93b9b4e54a92f5b8a639e98f0ccf84fa38c4880f6137d9d3ba0158f69dad0a578a131683ae5f61e5cddce54351f560cfedf269f0053dde3e569d8e8db7e54323e786a46fb34766f18d693a8a20afe9ca6ded1c64beb0c4e5405c1076b15f22d99f6f16c1d6c84fe86961546520e9cb7a05b2ebb7bdeda3901cd3a99d118a4b0a4f60f52dedb657a1c9d1ef684c41a61fbe73295800da39fc933b4d95811d2a553e6085fb3784f325857b5fdb5ce2ce7822a2a862572cec11d7d7d68189ed5b3a201426f66281647cfd3d34fa0161be864ffd19180054c2c960cb66131dcede0e543c8fa8f485c3594fb03c063b99255a8787c4280314a358b56d10b817e82b77512d7b801d2051e6e39eb1aa693df751e44f2b2372d3edc48c6d85043700b6034ba27d016be094c14257169d4ba551c44c04899a91cd168317a30d8b5aec9f02060bc0d6fc35eb9d30813e930940576c051267f7f8fe9b825c7d39c1906b897288d16c56dd95f7066e4a22946e213ace9a0e41c553e89fd7d3dd2bd8cf73655ba103409fb062acf2b247f640ff2651f55e202dcff225bfa512c98ba5c7f125d50d796362026b6687b0ab2f3fa6b6b7b1821890774387c8ad73d341e4d2930be352e9ac21354509b8fc862b667c04891833f1603262fcdc7a96cd72e0ee37615f1393c8447400cf692369d49275af8104342bcd1ee99b92acfaae74b13f97f309c1609350f6cf39b80dba336c0d6947e2bede03a1b1399a48965e98cbcadb26606f7660fdf1464c2ba5626fca406bada8fa6f898ab70e8d680b900b920fff950cd62be80fa7573646b664f34f10b9127ad3a3d7f1ff1dc44706031f3fd0fcc6a12ee4be1e7dc4df20eb7586131baba6e678da792b29e53dc5396bf3f1e7eab65c16b0c1149edac50febfd7b59437fe1422f4274cf48ffb2dab96b95ef7e9471b04abf85b93fa963881dd3517a47f2c24fdc905f887ef8971b93110e6868e32ffa03787a6963e2928e3a1e2619ee8b96dd9889fbf8c0085d41766b591e9137c3fcd4ccb8874761edec185ce7d2d08b665aa65a99652c1b243110b78760f5149226c708e53214c0328bfd2e3641ced8865777e8d03cdae43b7d30afb2db4ed2eadc035711b37db38b57274e53ed033acc6c46f3706a6b97419995802deb8e2c3b70eeedc35035488f3da8369ef2daae04cd8979d9b6eabc0ad77bbc56980e78b29688e515926264bc220751e348ab0353514da014ecf025034595b4c5de8f73a89d879a055df1c745455dedb714f99819644750217b3398908b7f7791c1186c6db60d5aeeafc272893475260221789f4d0703d0c4fea65991cbcf15ed8d626d96c0fa2c26319d8fc0ba2ea287628a4bcd4ad979e23febfd7dbb72167d1df33f05d30dd5540c7a9c1db850a16a2e1b2c7827b9c740286f84fad10aa0d21d180e5ec32bdc5f9b8feff2ca07f6324c978bd2a916fdd865e72d76b107dc2e05684c2a8f1d0f2298b28537beac6d75dc1d6292fd70e29c0ffd52ad408d4fa6a8a2c1bb1ee3320cbd40e9b10af5f54beae6af2e8cfdeb24946ba706a7c09d33f2547d4785d217aeed0054631a354fbf1fc006d5a1698e75c2de4770f2dc33ad21255657714cfb2149344d69497e45d661839ca83ab86136f56ed89b6340e14198e78d54c12550475e476a076687223317d1d0ddcaa6a797015ecb2192d3a856a3e3b0ed1e801faaef54be20d57f36bf9ef6ee34d5ed9ec6927a657c2cf4e9aa69e94ddff7ee4df49dbf0b74c7fee3b26c91a78bc898ba9c563a79b4992266d503f1d9df3ffeb8d484c6315b48ec365ef647d3fe5a19e6f16431da24d911353f9a7c1c6f89369ae3aba26cf321093f7ed223166ffd50d590d354bdbdb544d64ab20bb96e90f03bec5685e7fecb45a6bab03cc3a677c9a2abcf6af54dcab54288d69a914c26b56957e3222d89c7929631a8b2ec68c8ff30c2859af0bfb11df404852c237553833faf48f3f1c3b8a7f951a6161e9fb911bf5e5b3833f6187bd901eeca698026064dded4fcd8e05603aae6fdd82a43675eee525f21af3d9a21e543ced3738389c5bde99e298c213ada37aac00706ac441c451a3c4f2a00977c60198a6cd9a320b93e35ef149b32f7ef863f9031e5db0024ea60fc07e9dfae5748837fe6ada04b4b52ffcef9dd59a05727b182958e6ce0b4b64e4aecb236efbb48d96581b8dba72ccff249884976d0f90d2fe241d41b5739bb3946ec7c1ca84b82ae6eff2233b6dd85f40f3e5e4a67175e3acec920a863cd57635775e33592abb6c083b144fc5be2d7598e752b3fa30008c74f1ed8b4a9b220da204edf0dc8e1abffca33338606c7527872ee0700349b635152d348dcffde9ff1dc93e005d27523ec637c33fc0085cd14e758483defdc19fc07e68f1bfcf099dd38b615378dc020324b8c4ecf48cac29ad666f515f2b3c04b663f09dee358f6fff0554f1c4dbbee48c9764399ceac81c6ee4d799030677bbfdebb2f853e231744524f2e4206cd17a04af62caccbe6b42b57b97e99e43053fe0a3ab2c097baa13299c1bd365f04e79bb930b599e90cb90cecc9ff19d28b87c5f393df76323ca8de7a221c6783b36b87f98f1ab2b6fbb18e1d9506e426d9413acfa5b8a59348dee26cae9d3971563b0c3d2afcda92d100e49f244b2e527d941226fa9db1df68d748b855f9a8c9935c3a8c8d69c0345f5f1be3b15b2942a25e02e0b40e80d85f10438074ad2c47f7535ddd036c659cbe0f3975e16b2a488f928b29f81b47b9a2e170bb1aa5efecd4e7691ab1f85d59102acb75bb847b9664d736c67c15a6d75219dbedb628c077d6bac864b56e8f5ce174f62741ad3eda9f06fc7b105d964bc40c4b715ceeb9478429fcf48121c1d39fd3939454226082359e9e65e5668b0c62ca72b46a885d195d891f29b142378710d39e8529fdbd41166449c65050dc719c8719637da9d40cbcee03a8011903bf1424e59d7ac093ea3d98db17981aad0c47094c19ec64c2a66132c1168d9425e8b7e948472ffe5db76a5becb6e3aebcbfe0378f0775f769dee401a5253a2a6208974b2faf4535f38befbe520e6c6b75603cb9d63a6ee39c11d45db02e22c2fe5331acbf5697ed20a9ae6f64797bb59191cd68a0342e338b40e50fefbb3954e003a152ef07f69f5a4f87cf0214108b1beb3a2454cefb34bcbb2070340c90a29441880b7e82f7864b0b228269e54b15e42da6e79e0102e7919e9b852438fe70f8bd6f9ebb32ea04bc5e4970299ea1050214ec2bbe91c83bf297e8c2666a7a09d061fd6cec2a3f9ade5cbd0d2ef1d0dcee314c114ff5b1bda0fcbfcf82621b7c9803c5cef7fd240a5adbcdcc8785ab238e76e336df45f0ccc1f703e5d1e013c9f851e162a38901c13957b62aa378465ef84a5bd489bb1d7bafd07f88dd947a0894f01947f2552410752a15604feb94ac5530f5a1c3c38994280b50a7f2af593f11eee45dcb0a8477594b1b8fe1875eb672f11a7af7e46e645d49293462def3262aed76c83fcd06052596be45d4233855af68ac4688fc8f2aec7b771df098f2c6adf437cb9fd8c7c7412390e18bc364f3cb0f53b146e176ade0c734a5dcc1afa1a613f82eb7327f8647c78c32a5e8a1c6a4d5ad55b72ad42c074c981ca873e660f91520e5c8a451bcecc05e9715ea3c4a380493eac0b5158d2542009f2a927aff384d7855cf73eceed9940bf86cb4b23291d8046d5d88225367d6bd0c3495ace123efb002f46f4b80df5771c686171fd5830d13ca7e9d9aee18e6224559ea841e6710b3d50dd353de5152bffb7a30ae69fb4a92d5c8f59736020e8576f74a86f07b52da7773e53937d9ecf13daa2af13c8ae70e9da900c6a7603bf5391de6cfbd0335580e96d67e45cffa138e097699350130df3996755206d8d6719350d50563008fad69c9f9b65716d3ccf37a1d01a0dd772da706c0a7225f21588e30ea83380db39c5fcf41c686fdb65ac004cd41e56cece86bb7425a6eb45c6cd5a6219ff1cff1d88a86630ad33c147cc0043c5c1e06c8a2bdba6033bae36cf4a2534dde7077cdf44a6a16ac53e8cefbc6e30c2ca0eae71e0d3f6fe25931f5a4cf44a7364a9d61539d7f50c656c6374d39b99917f42e4a44af75f0930c6e8281c04a9a2297da6306cdb51b82fb26d6a2fa1b8b6c4298c26234e51cea2b1f41180f15dab8aedf7d04332da1c3742e24329107094a7469f9717f6551e312d2fc49920edf1ce5e793a2626b48efa7d030282d1214d9077cde45a7f7c5c91c24b73b3441a99a5172bf7d42214b6cdd3aa6dca1d7b022f8d9e41402a2cea1997477db1ba9b9815ab2e654431ef5d8a6b6c810040d9851d585045350399d85229ffa487bfaab2215d1c0ac16c9448fac9b675a47096c0dbac7fa26c733c45c17f391d2000f9e60fac324f231a131d484b7b34de608d2701f207f9314e17524ffabeaa3b4be4c3c3f4f2e52d90299ae674a8f7741102a88c6408c40f977708e01feaa53c34782db0d871e1c376696c5d67128e7c4a7bdc4039d5dee6ad40904a06b3f64189897b1a889bd0e0a6a45be9c2e805778c86c6f55960029628c4b9052f9a4d055299af943fa7a8341df52278785707a21da99dd32a3244999f88e9019cc541367f887ce29df8b9ee4700710569e07fe65e975aab9642dbeff3cbecd61d1404e175731399d3c8191e0f336a9d41cf885d493b48f1294f763dcccc1497f0251c1a8d1508a5d595e801bf21f5853492f34cba8c5374d28c615dfde955fea56d229103559502ad1f451ef59d166b5552f2f364ddcefcf7819534f2570a28d870ca70356d563e5a4a4053e7898eaa9f9819296b21414922ec15afabba0466fa4c576291eb8bc7049499d5e22663cbbe360153cfb0ef86fae6b4793d868a18cfa8e481cfeff2140c7bd393a5df78271e7381f9bd3d90c7b17e73af0c366c1f2b8c6456b8374bab09568503f031c0b25a6289ac9819390d3a1ebb087970129f9b3634a61b30808f10394bde6e4c8cbb6805f28ee61c4c6eca7121f553e0f80b8b20476f7b6584492400a78134652bfc13cbd647c39b4cbc4b005c6cce6c3d1bf1b42c0f334d204c6a040124972da433bc0890e2c4063685ea349f263c02a6860200de52bc30c01f7606be40bbb1ae4931112a5fec80aad87a4b36761bc03cff073bd54bb0bc49c79b8f63eede7b9f03f6c5ea3888db02dd220ce79bfe6c7e24492c9261fdcedb5a1969d107f1ee7b1541185f65b74b93ed0c7bbd179157e08550de16233e2ca34aab7bb5321119c0c6ad6a484ef632080bf60dff4bc8cfef0f04c220ae8ef3fa7f2b3902b26f9601929384641d472108df77fc1d1e00c71d9d20dd802e16f73f3a85657423c3ca002da0ac211e8f6cca9ab783013737736ae168fc4818ae59903155babcfbc8dfcc04f82323b6591ea3e2a6cc5baf0553b0a46ee8d6750df06c1cfa98149f6e9282d5db010fdcbeeeb2fa37ccbfc3613cbaaf389eb0285d054d3c0c8cc22610f1260f9777cd42a5d43100c849888f7bf4fec10d1e28402e178ab47ab0a67ea4fe06b5d3b99c0adf69a7f8cda787957b5eb31b61e13f47925b839e23cf0144383d18e04be97ca4edcd54a65f954e3c1e332a81662ca6876ef192391f3349ab13b909c65463c7b27c8b8a6edfe9edf934e0ca5578be79eb68ef9721a09f4aaa85ec10b8da779875d1603e7979ca2c370a96a142ed331c4672222a795aabecc064dc1589222caafc186e4260fa0abbdfb4b659f0c7d4e84184fcd8bfb19f830bbe4a0a5182d6c79419fa5eeb1af8728782ef6ac0f5d29a875468941f02945ea410e4f8c32837a14ed4ad3fd64f4a2aaec5530332d72462d2d8890746be520c5143b119de7a7eb08b64425e1c95f355110cd6890ad25f4bfaa7c9c2d7ac30396d565b2c4d336afdbc4da4de6766bf6a89c34a7d0493cebdd702701c87f8a729591b6f201578c05cda338899b7cd9cebbc2ff51b0c6f90c80f2de530d446811687f0c3cbf1f6060e13c90a4349c45f8298421a27ca761848038092286f16b13178a368a391a541f5730dab0ba37fe2f2b8129ee950c0f396da9f924f09e9c40a65a613d469bd77b3d861be9babeb1614ce2c0ca5ad833b932055d372c19262ec91588a6f47f6c45bf5aa742e98d73b6a51055b78813ee546a0b41b159a855b1e01ac1fb3588d6b09163fece09f303efd0e7ba6bf9522124aac5c59ab3cafb33cf47fad4cd2e31da328c678cde071810b2d733cbd5717bf800db07c95cfa2f33642143d7f4add9514787a73b553e6e6c53291e5e3ec636f08d5978ce1792bbe32584c1a824f60ae5ec11a842522ee4de23827c301d5bc9ee4edaed261dd19166a44879373b8e5a6579251d11874faf310474a8682e97ed1274892d8f23188e89e30a5d627d667dfaa9f914bb1d4296827cbe17c30120a151eac712f993cbe69fe77fa5354fe705e397a69c3bac6ca64666a585f5436bbfe16bac4cbf510c08ce38a5ff31b71c8d1e965b503ee2dc9e7a4bb9bd87af4ab36ef8e23095e00b365e2c2ad040c61f9f2477d82eba9d75e7c6d8b66b910b0131dcb8a66722cca0b52aec064323d7ceed3b869153fa1b355621f7de88403a268fb684890e6ae012babd43202594149f36195cffb0874e993925460cb95389b8067ae80119dbf840a105256347a8663f8d965700184fe592e7ceb1037d01c044df324c0e0c55106a9acdd19c39a0bb4ffcfd2567e40d9270fa467cc902b98d6accd996981641adc5855d27cbf8fcf66ac1304c57bd8e9965c494f92a10ea9cf61cce8ae7b27ed080c4e460915570557e3809c06830c7d9770a5392a449f3e0418486ce5bfaf95c728901e671d3fd875dfacbcdddbcedcf0d17bdcb63838282de0177376f9ad8f14c367c42937cbd4a33f1097e7ecf814a4857b6286f7af7b2470950f607505de79a5feae4f8a278bd8215c9dc73f80f64d262a6564f2009b5a382a5d150d8eb71dcd71fe9c84bb92b1dce6e672c732da893484c45bc534bb0b531a3d85a661b730d6185a6bff347937cd6f403940b534a2a363d809d9da90ad28617c09e8a7c58fb884c396bd15c542281f220952eb87251c5f278f7492c5557757615afb3bff9ffdabaf01540199ad7569e411eab6f1736d7ef6db402e788deebe594ba7cd7cced136b0f6e3b004f6a601f779ab6cf76a926db46190fc3e6351dafbcc9b8fb2d6cc956f09b8a55d421895d9d1c41a3c874e20d1b88ce13abd7e660edde2f9ea8b0b24ea7e5c699ead5266952623cb23480f32e89258550def18f0e407a7cbd7ecfa57902580deeb104534c54bdebd737361ff160aae9a21fc95386ac5298fdabf5f00c8fd1135137c241c9b818c6d87f04e23765bbe930ffb033b4f43fd018cadddd870873b1969cf22f7e3e0ddfa9d7e8442801d36a65dcf8201eeaae1c816a4f714f2cea4b77d242b3d39b6c76a7d6b37e7aafee18db5e5e3e2178d5699b628653e89d6e3527bd09a15f69172d7ffa868752a9ab9a807c424c9ee3e8a314665d2de4e19a61786d264fbb3f1228db9daad5e6b9e986f1b3f1ec22fdf0814999ec3622e5161b580a7ecdc3c1807fbc81614936b6377169e9e00f2d521294bf8556fbd04f949cdca87a399312866d21eee70d3137e079934d3e16a589ba1caffb8ffb989cc42d02a78c777b9785d91fd9dbf0b2d9c51d09a1a3eb1928f202cfb1e111f4eb5b0c9d2f90c24d6b977b82abb24f5214520c4f78d23a4a9b2ebb160516b7d118250630268e2c2ddc7d76333fa9b65e7ed4b5b96d987180542a6bf15b92cb233088d273ba0a494c4c18081efce7e531c83da159db3e8b2987cec47a208eac8bd5320da431a165c0a91e0e927b51f4aad5e9bbca44319c3ab1e2fbc020985fb0f36b98b406917e9e4c5d4628ce485422d96d323d85b91ff6e461c7cdbb30033e8e5be2839621be7dd16b10aeddf7ba551e7ff4ab4d2244ce04196cc198e01a369605cf339eb25584acfe3d3e173fbe7f5011c29f2c30b18dd54fa56b6cc999472e523c6055f89b4079a288a6781b933a314cf67ff2bedf0b15752326b7a4f7cef5ab89fb7647b4e195659d432d10c18faee82c692fc963087e186301d0e1ee6934f1991f360ce7dcc8475ac66db00eb269c5c8cdcf85f544e72722d40b2b6a50e61ea245ff03aff39a56d5eeb088838439684461b29fe1887c7d73fce33acd2eefd7a306a9c4879ffd2469d5985b66512c78feded62f25b18388f52f067daceba763eafa8a1b8c08a23aae6c9fef3928ca2fe98a72e37cfb53653586877d6ea1c0657dd6d41b82d6eb6faa0a7bcf27af10ddbcace9645ac6aa8e837f241d108501bf333bc8670ecb5dbe233cddfc9f3efdc54429b00f193261159dbbb91d66ec50ba44e8c25e3560e40c72a20ed8f0fbaa4fb18b84d942e0656058d0fa74d584eb798e1ceb1d3fd224e083432f882f1afc54bf43837c8c7b1d1856cf33092958a9f123c1458bb7fe65d6a7595cede68492346db0727867f19bc48341772dac203eaab6822ebbdf84e723651068539629589ff9b446f98dd570ace02b13342006cf12c7535b9d75b22c527150e5125e2582668101aab4093c077f5237e94ebb36bc74bf3a04e0efc0e5873ee0fca681d5180133ef31be57c5b786b6f956823c9f10d788d661d68cb84fe36c60535cb485dc92af8aa7cb15d62091767a404fc8285b8f9ed660fd21473e1e5dfcbaf7496a4a248fd3b6d673df7493bfede2cb765633435efee9f354bcebf23eda1ffc37d4396c1d86c04a26ff2629e40475c4542830ac0948c224eb29bdb8f5c93793eb41e0374bab927c001d97455f6183996ba889b3c5f20ae8ead31d083e2df944b426a69565ca58f5ce426788365ce1108d6c08655cb878e56f2744789c852897bdc50399672bb6a10c2f79b202ba91775f6c54365b9372f09e946aae4985d9570cad3f2f7eba97d1fe0aa520d7958a5e6db136b54ae9da3445f3f258b998cb61885d9742dd7378dc1240c1b8bdfc770498ee383b67cd1de4af54d52cafb6a62dc9269040fcb6580b4986e9f13799c323172f2b865419fb3f6027df9076c431eb751ddbb3ba3e31c80a41abfbbea1720e30f0fa8559794d7cb704f14bcc4f431cbb0a283bc54059ddcda8a149ec00749fbccd78f3d73855d0c7aaaf6ce999c3782adde122ea6fbeabaa2254426df62a769ec3375e6090e36779d729e54920e5c2693f155b9f4f62adf66ebf67faee6c330f373baeed6e21efa7568294275a224cba03920b3321008e77536ecdd1767369712e72eb5883314c68bd7685d6914c8f6eedacf7ae75bb00d360ce536a1ad962188198adf9cba131c0da825009ed12340720498e0003471d8d133f6d4ccf3494b97385b4c68efbc2221c639dd5748f1ad9fea874d68e43d539b1f1ef5ddfe6569286fdcfd6bf6c4911c0095581ba6685137bc80f96925cff92a1eab38305bd09dac8bbecf13af3b6b27ea1deb89865c2d6cadbebb09ad5bb2f743ac8aedb9a77d47d5c33f8a111e25b58510774024489ca21dbed63505d051d64a47927fb1a3abed93bcb0727eed3b1d5a4b1bf40ed8c8de24e901b96bc5a24b41d25eb316bb6354d1c2178e7dfa7279605f6cad156e2ee20e65a19f1b6953cd5c5b41a3cb5168771a48802f06093dffe639ef429b607af496a2faf1878d96e367a4bd94138d2a8db42f1fe39009a0ba3c35233f7f539bfa804a0c43d780cbc400b2f4ef8ca98d5a1d744d8577156a41e5f2b0117d3c5dba3dfca8f445fbc61898f8fb258dcca434a35e98b903ffa8c888df21609e0d8bac00cce8419ecf20ddf484cd52edf9f615fdb5166943967831f7d270572842e1391b3b60c76c2afc4f034e2dbf9facb07fe1cf9c7dde9a024d4998f5bc6cce316712253d704859cbf8ebf1f171f99198ca969037c7d6d07756545779275a2412afe0947619a06c810893bcc9543ea53bbaf8cb3a3b7f32d39ecf24f28a4e896ff10043146f5c6f844c5d154e7fff02b446ffd6b29e123763cdf2ff92f0c2f66b0d7c19dd0dfff0639155f9f467ce048c0fcac62ae96c2c5f764ad77e4e6b89973b7aad81f8381990ddac4e3a2975e0b2653a4253e96d57e5847f2d6e53f37b23a041cd2b9331d1864e9bfcbd789db99211de40fb8cf837a81f503deec89de7b39a4c540eb60972b2c41b9a85b2b930b041c119465d54822cff69e2164e6efa77100f3dbe75613e11dd5cb8fc39fe9e617561acf02839727d2e64581966296fb07d2b51e0944223c15fc59e270d7e60d390dd429278d670d35336fef1e45456207e50a4c4eb0ccac00772333269fdbfe0740e55ed9773d54a7e78ad3e52650e97c1ec42bd4d7a176ccc328ec27145ea080eee1d709be5cd69b88d43cb38bde53c3b8203362540c4c244a34e3980e996522091a7fd206d1fad1aa4e0f93bbcdc6c1f68f4e7e2e0680a45b87423ceb3a841ee5bf5b30ddbb9583b506245a8fe6b440b3a06f5956156799cc5dab7164d014ca28b66f9cebcafde57713c9da23293711f14c5055d6b5e216464a65fe977f1939325df965ea19877b354d8d1c0bd035565a8c6de0bab614ec5325f21e3b8bfe86de57258c6ca91cebcadab0aff99ece6acc6eec1bc5df581f01a62a148c409d20645a66bb162ef22dc6835700fca845eae9dad8f77f60e2a3c027b019fd4cb555be23cafc09a7d9eeee32c9d94e98b727cfc4e2e8598526d7eb9c16decfb54e05e0f5093cbf47c1b7b5cae4a6c39c8a86e58fad702b1c7f0c1032d215a38a04b914cc4ce610eaebf58f0143b1e29da5e85fa11be505bfc43eb2977c6dfac359c860c3c881b85ea4042d62bd4b083f206a4502f4cbce5bad06b1d1286550052a838b564258400190e4c3aa4cb4263b80403821263749471c8c565a503ffe9a6491566545b0ce037f9890deb11dfe016a58d9ba2644c87d47f43b76e0c2cc77a27dc093138f7676996b66c2aad4e462c96282e7ff0ea562a0139fb73ec58bae7ec5a01e7cbd2658c479c959f317c00c027568299f9932d5485fd56253105a3b392ce9a5b0a20f9f7858c0fc7e78e8c86ff0e8fb982b7972638c4a7fa4d849cce542ab3466c176851315269e7ae93094f78c85968a19da00b49deb272652d6cba4e3a53e469d36195816f15672b16e8cc22fb172b75643d5b14928057f9f60150f3a1812c76200a83deeb8ba038c95ac6d9b9cc5b104d616e24d286ace5f128ea16fc728d433a523e1d732458db3147c6271518b1e4c88ebfba57654c17a4e88ee74fb5d539f67e3e132330176f9898f87ccf27bbafeea45914deae4d5fb2c188e47e11810eaf33aeddeda395bdf4311ed3e7a0b2c7c9e57b299a89075de47aa6078249643c8c28313fc8e6748e342ae9d0c3b9117a6306eaa0e08a7001a666315d04feb251e86896c8c1e1a69a18c54cc2568ef2513657d3ca75abb5d4ce0142eb25aea2f586a7157f25eaa0469664159cdf3fda3ecfd088b81f9c6c2cb4156724be88bf8c0950b9e280e2dfa47cd7793faf1c3fa297dd59f98e18054db3eb95f366a7cea3d33b73f6b136691cd82b76095833c4677505dbbb4cb2bd193a994d113d202ff0c21ca3fecf5ce9440218747601fa6bb5216f974fd970c97c43169e307dc43424831e17b07a9e1e3de7e0ae9bd5ae0d4303f1ae8814a9b4b864ede9e39252d591dfc61d0a5a7c0e0bc14a8f2f8a5c36397ca2a13d1e62d2babe0dbd0525d216e7a18f4d7aa9555a3daf8783cd0b757c7a2975138a170046e9ca2cb64366dc64e24986fd88ff36088ba291664752cd447c64edad9acb1bc0e9a10bd16bb4505dcf1be117af736ccf1424aaa8fdeb6d5295e5ce9052f015aab7944cdd1c07e5a550c37057ff5b8711b5f5c7551a0cd32b110bdd841e6a273030aac12dcd2b50e35fbdd812b498f4988fa33e616dbfd0a452b4ecbed9db0189f51f2f64c331392940067e8af1134ba04f4de226338c478d77f2fd0a30355402d2c88eabc74b57d480e9ab75a4231d580c6aeba30d2ad400530b9ee540a77a1ef9797a3905c4440ab0b9f540f07888c97d7950306d22e4e3967bc0e2d2cc80d354197485f49a8a45031addeb4950278acdba776d6214769caf0e3f5bed0151e79e887fd2a80e55ca71278ed67c2ff1aff8df90f1555a26b23fb2470f86e84cdba700b38351d4a8041ac2910bc20f34cb0254506a931bc29c9c818e205694473eaf8227af71ffe0bb5101d9e42bb2544a586ad47546912a0a1bae47a04c633772d41474a38c8ba623cbf67f2e4d550429963eb728a4b40f1295099d492fa2085b61728b5dbd8ca46ab462e651d20c70045924f479acbd8f228cecaa6b0fa3273967609263e4bc0e153e58d0c266a086d741f9debddb45d7f05d10880398a6feff2ffd130c34353e178f4442dc4f2f09b567a63fe09cf1a8b7332fce9b6d9db0e4ef9701386a1bfb5f0c44ed32ae5b4d1f1826d1037f18caa065d478b7ceb5e9212ee84a85c6a9d40cd772efff4c5abe141dfcb11bcaf5697f5cd176956bf7d8b1f044db8d3a399ab43cc0c608b7851cfcac6fcc4fef25e34c2a0de8d72426ea006049e8af0fd1fb555e4b0478189fd5956040fca56b7ee73168546f56f35a1611322154ab3aa30d8b159947b7f33fbcf665919db127c32715b10d2b46e101308b46583ccfcdc3210889373093644dbf31d0e53762c57549607579231b0293e6548eae95662a623e0e7cd2ed860d253c615b5eda0ef3576c6d2107f4b61e44f8387ca3db89ac4ce137b308f4fc02850feb071918c02b1bcba71403dec04f3b78d4507fec41b4f2ac4998121a0bd75e6ae3b7a554848a47a57a2c64477862f40226714c1fde159cf4cb3b49024df2237fcac4828d9d4069f09f67e68a5670c8fa87bf6244c42664b408512644bcbdaadc26f8a96d7ca4a1ba68f9c310777226a4d84b1c44a9ac0221e83b3a1b505716230b029acd3462e29b4067d9c2333f86d22bef9047a2c0b68b8069004f1cb0e0dadfa5af7c5606440591e377f2a7feafb7306abe40e1c8e49fb4230a8b073bc7e7a3e4871cd9af5bef5f47ed6a185247e8d9fec9a35d7da134cd66682dfe22bb5f245aa7220d6271e434a2ea12b1edb7949027da8e098da09956f216de0584a1949851626ca3323666be3095055e8daa9f20b2bf9307ae28ab4c9ae88c0f22872b4addcbd1ab0bed99712fefaf945d82ac7653090dbad40eeed529f14f79b0d3a344c6b3a20286f92ad680e0292f40317738444b817a7c30ef9c94534d291a45fe7b17e388c98150e98009ebf487866ff98f164dbe7c64a02064d7eaae4d2fa70c603dbffafd70d19bce5521bf65670c7efe9d701bfe8312a13ff66c897b0aca8d8a84028282ebfcee6362416141e068736ea040711efcfa9ab131eb873a5d9894b9dfd9d86dfd69e3e883a423521c09a5ed4c60aca4c25fbdb8680bc369f76406284479cd4715c114d42c0fd0dd7307960586ab55b2e7d168ad52a33351979aae63f1742824fe0e072adad3316460c5f42777be114cdde1ece1b88f17e95f7ab8717ffb133185474e3acae05302a96becce5b3d47d016778421d17af60530f96d53552e53b14a6c4b3cb49ba1d065f3a7e184212daaa17efb762c73491176a89e1b2750d81b2046305640a3a6f7842dfdf3dcdbd6b91278fb663c6f28e2f3f16ceaae541e88d493ea8aa38a2680fc111d18cb81b24c419ae2e9bd8dce91d29b8178aa968e9a8b56d4ed5de108497a8b55c8db7c74921f8dfca8b44e544b2b677b4f50d4c84b2705a60e3fe854809c10855fdbe84f0c0dc5c3b3251053de9bb58f4a5071c5c93c2f89ce220f6e967ba89338d1ba3fd6238eeba02dfd6ed793fa37736b908c4ce692f5e09a495bb285ee613f9cf7f57f211c7997635480a1868356cd5f70dcfaf059c86858cba25472e1414ae92c27a24c0c0b49b84cbbaab0b0d3690df3bd222b1e37fb40170d9e105c9eee283e059fedb5bafb88767b1b086d6668e7dc7842a9afcbf659c13d9db47a046537bbafe6c37753c1038242f9018e73c2f5182797a49adb47f58f49e2b28bdffb9f2dd9b76378308f733e90dfe40307be5bdaab7ba28d5acfc39e16974612fe877aa106e09d3689e51b1c1b9a94a45973b36872c28098ea320d39367de580ca7945f8cada76fc9c5a9c18d49431f482ebdada01ca4b73072e40b6853af313123f68a052e1181cd5d05b20ce2424447054f9d1e246c8f51ef72bcf613392e80f4aed974b8ea20f74f39f7d25f282e44d02c7dbef648f5b624d6c0021793f567036dc783e139f217b5b7991efcb6d74b883b04308336aa3564744ee1df13f13898521e42675637ec0717946a1f509a22139506121644aaa0fa5128854e64c0997eb43a1eb7365c608a8289e135b7e56c86a52d72fc31bbe97a574ddfebd58e34a13c4de660a76b563241ddcedd3292166e460cf2f4ecc78cfa2742cb42bd1b56d54dca168af34f4c7982a7576f3e18738ed672e65874be221839cad350e45097d1be69cf784a4119103900ecb40acc44ca762ef500a0d2e9e772aaddfe6f1b5a7ee485fb6176dfc6519a8e94735b2e8a275ad56365cd1faad0adb0cb0c19aeb38ba15efb9555acc92406c8c00fc3f826e03ff335bac80601b1acff1ac37203f77787e16e20c489f8db1d18c1b284365a80e1f682f816bb1dcf04a4c50132cac3c2a53913b34cc9f8b7f176df6cac71234bd8304b3050dbafcff99d6a6337a25abde8f78828cb7f72bff846f6a740452d85367565641e84ade366e94f0b69c0880b8e665e99e261e1087c891ad90ea11dd7f9f8e15f5a81619c619cdb3e89e5b17af27769eec7eed5eb0ae9dc5aeed31e508a2857816ef78173b147e3935186b3cf773809fc85e94336a1ca5103e822aad57b852873a6e046a8e7a95e9545300abb452f3ed56c0b9da4152e5a902719ea2940838e3863e790e7b29612e4ae0d3cc79528110a96207fe42a75f772d7bef4399a0e306faef8bd0a2f6739f1c083e549f6b40283452149d59f6bcece3215232608fa52402e952a2e2b10811e7a8d8d13bb374254907550919cbb7e76e9c720464514e33ec0925b50988129076d6449f626456efdc5b61bb48c070517c20f8b2ff0708a2a4e0c23c8cbd7cd9a0ebb7123915b0da265386625f5a0a15702e7c499ce0fd923432c3343c1000f7e054545e3815f9301355d2481e2358c12e280a6785ac947efa0206590d20f9027eddde9bb0625eaba02338e851dc8ec684d70627aea60dbf2f23b00080bbe98ec24f6f1b97d55338d53bc1b787d0456d44ce8c53659e3da02089711d2693044720ad732bfdba7b1d585504236cbc3c2dcf16573b25e92d098850834f5277e052ac6720b63d35c0e98eb3d1758ec3dc42e710cb036e5cb7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
