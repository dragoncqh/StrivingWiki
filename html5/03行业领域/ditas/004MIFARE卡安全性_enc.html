<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d735e1dccc987d5d38eba4239a3244776bba018e902f30ac54175c704d4dc6a3f2332c2b19c73c31d2456e47289a47d86d8d428f2529ee182b7748a679e5830446b51900d543b7919e65c441ff649065a8aeafdc102a8827c1e022ab2aa158409a969ca17c6eccd52f56c9bb655ab7efa3ad59cf65b2b8fcff265717831fdc5156057817f4f4668372f5d2f38fb5ddb5c5e586390a2798b1c6757544b6a709a447c35470bfc8fe15129eb7a93b7863de7ef8aaf36db067ed77f107704f3511847b0b59abed9da3dd58588beea35964649bbc29ffca060527cd174fcb9ef123fe8f49d09b94744247aaa017efe72a3eec1bca61cd2b340485f0512f617f9c7039f00dc0c4041ee8f1a34e71d66ff3822dded996ebb247470412f099fe5678714aa4a03eab8163c54074a622be5585c85a21086b3962ea66bc84d400320dfbecf89bd6871f89be7ca8abd55d02d9ae428820593da7189d142b2620192582ffac4d4dd2638d060887cab98bbf0d43862dad05d8493a4097a48ca063e57db60be763f9eef8590c7e3a6f298a0cde9339b6287229a5acffe9b66fa826ee30a968ac4232cb8c36d785479a228d720a862327a8bf605d2452ea816f2c59497bfccc9c27a6ad4c1f1b852fe4bcd2604435ba578301cf7875781e655beeaa98da71c5dd50a59cee35001c55722a9f0b290fb3a7bf05177d172110d90eab0c3dcaaa91a5b6317e28640903121aa6c47186d7d4d608a2099e1af46517582943d68f7821d0016999b2ef982197e7b89a8fd4739f5c0d7dd01e2cc8abbb0c9154497c228907e54ff4947c422f6a1c319f5e87b9954578060d98a567b48a77361cdfb9f90911f2b918b8543eac9e797e9cdef5770aa1df8668c70af9d4a5a0c4a6678822ae2f6ae930ff1906c77bbf480249c37b91badc9d6a6521e1d878c4cbda1def34457034d35437b5b92db02c3746335c7bdf142c0a7107c43c7b4fd24bcf04b79fa390626a33ca685e4b6834aaf385c5b15718f0540f2ebfbd650710ba96c5ef06889f2741635c0b2f96164710e2ae7af4ca5185d1232911dd4d89e4b78259b97ca541a8f70b09d3107a4a55c10410c896d975afa0267cbc747e8ba85ec59ba6808f644a6e1dc12e5ed6dfbd5a2a0366a3cfc85cf51053353ee517fe2e9e8273141bc3293795bf3c42433513013f2aafa370e85d54884de8dd52b9570b56be72a7c527932ec2f84b8409523d67d8a26abb0719b2c31876aec41fa686079bd91627ca5c69e8db1f8f158c8849505cd7b35eb8337198e8445edd1471b8420ccffdf4aff109095d5d4f2563b6ac8d4b2b9fca9a664a1d6d9683eadda005161a20e90151ba7b5fae99859def83127eccd5cb3a4c24b66aae8b38dd10d3978acc3a472cf23d81b91903cbba2bb2427dc0d5b648c8f2d5d9084ab990e4805088d7d4128ce94b7895361ff7cf7fd26044437b7a603c85c1117e6b14f0341a570e02dfd9fd8d3f6c9be84954c31e5872aa4781ba69565f68baaa58ba3df4b820864406fa07a417cab591a1768758535984972121cbd246191204dbae1415b9175255e6fb108e3e7566206a8eddb4a8af6fb17e3ba2ddb7a2fc845a17b259111e4b258dc152b3053d3915c40cade52148b64a46182c9618c8bad268ca634a74fb207010f1ea45f7888a657af103335caf854d0d282b949d5329ff8932affe7bca00032be4b7f6164e3e31a77ffd25c946a836c1c32c02530e09c0009773e934c495d5d4cd4477b329004389f5eb996b5aaf28ceb3c35580d26a1201924a45a6d8faeb9a29847d0f32b53ad3bd27b79d6c3048321bb8c4f57571f6ab8fc6a546f8fb9afb37383d5c245c1945658718461017741289eeaa3924e45e645d0302c5053d2673afd9f8b3a73d514c35c5e6aa8c0878504a2c3f08b8b21ea3ec43f97304d0c6d6a985997898d626afba0987182bf96c3688d9b33c8a7a1c8cba53af18852d15fc487d4093c0b0ca133e22067d7949bdab05d599210ed9057783a40e7e91576628bb931aa20cd9051dec0a177ea49dcf5e7524580ca19af1d77591b6b4d9255221c69f075a0279d511e09870cb836f78ffd453c73f90e2df95e42bfc4795308ffe1b1a0497916ad5d43232cd9f61f1046834bb1a29735ef5ee1323c82dd276707e687f363c1975b9c2c5ccf4e698349460a86d9594931101d8392b52910d7fdcc10d0f8dadf32d90e1f358595c2f0e5b9af3b2ef329699a0c4bbc0118b6c34a1a448645fce6ec7289b5f7aeed0ad810f6b563a9f00844f22e045d51a8070a3ce6afb85f0a7db45042ce423a87ac2bc8d323226f47b70768177e0af6abbdaa21d98a610fa61d7ebd1a08f56a3b02754540f4d89157e564d554910c8266de49bfdc919120262a6acd25ecd574a88c9ef55fedf2443e9e269e8efd3104210177f2c3351da4d6e6e77b30a3574203f1c026ada5ec3a207c597a61476cd1f7a6cd76b3e79cdd6485a05a20f648ffbbc18659244f49a8845dcad9f7de0bc50353e5aa74ad3822bdc6df7d0ed764b83bf6b4bb9ba65662649a19f34bf3a87b54f4819a5c685e03a04fa9b5122f7a4092d2d1bbd8ba2bd599cc7df63145fdd53d64ce3b441609193a291f8db05eb262ad4185bea030f0e09dcf10a3112ca57d0a1acd13450d7e611f32d689ea3e551ab55c094ceed4a631edf92c550f2a6da8196ff3d63e18e5176eef58d114da6c2eb2e50b26909fb26af173d3efb26b38049f0b265f674eace034ae1ccfee90594d7de12417ec25e3410e6851813bf53d403b384380c5cc6f17dd5e23b97e5a22d8bac4748f5cc9ec989c537f5321a404a7dd9459f6fc341cb7b10f6b38b38e45f4fd840b8b1199290865c41b575334fbdd266db2d570262e3fd6526e8b6165fe398c856913b83e4f8ced7c8944bff3b8a1c0f4449e99c2cc6768ec305eb522e21877e62425dccfed1a9f3ccb80200374ce274078235888b4005c471e5016aaa81575bb723594de4c0a633c0295ce2915254bf8a528c0d6dd06ee7a4f4a7e71b6ec04810f1c0baf809f93f77c7042194edd667a33891125bfaac3be8a7f4237fa5d53d4b808c8cfe512d1a0c111db4441812657e863099421ecfe6f8c276af62f109b7394a159f15a29a5d4d9a66dea83cc481ba1c1ce7d41452b929415e9ff182a96a44d1335d76612bd1b4e0f42659e874a19ac638ff53896e6d44c7e78dd04b60d987eeb0c3c53f1286f166bc85bc4497abe2c8427a9bfd8055da12eb352234422fea6a05d9e0c3fc004cfb6866bdaa8351d11d8b844d012860c3adf2354c9d93a81f1b0fee66ed1cd1d45a1fbc41f2fee37f204987d246efdb2aa9b6ef373123ee9f6f15c7ba11790070966b270f7619379b66e08d25f7905c59b8497335a580a3927131ccedf2cc302ad20d1dbb2238366ffd65f769639113a5d0508c06043a86d726453fba9896ad3abd925d2291906f35decb241fb2cc71ec522e64443c78737b0d7f6a6839d6763eeab8aed755cd09f80cabf76d9fbd12e025737a8375f17eadeb624f19f2ddce5abfa773ff7515fc5b803195e41065b4ee592f65012f910c60fd8826868aeabf6b6612fbf53ffbf2733673e76a2c25647f2818aeaf60c85e69f1306b1f0ac63b282d9af9a31c85c1fdb1fdba8600b812bb5758dd73d03d9068a43e2d73c96da0cce6117817a0f31c3ffc79a2ac6c7d75082ac400337469f00421176665d5666da96f5da82555855fb44f23dfef622bc361f5fffaad9ba97293ecbdf99ba3aa15cee5e70eb1af84be4fa247b7b54c91e82a3086cdf69e457fb30ea134f7b8ecadd92cf1bc10a0979fe46d3a22029882a1b144b9b41e0f7a089a2ed7fd0330fbbc3990228367147660196df877a06c18a2c49ab3344cb7e217515ad078fc010e60499fa6911eddf4eda662fa41ada0afc615c71868058fa924c78fd049e6330680c1af5874810159893539da52a6e036e6bc07b81df47c7673027f75b67bc8f98515ad7cc5ea70715e537771604b3700ed2b9faea33d2d697339f67d6d7f51bd81cb72289e0e8ed90377f0c4b782dc2fe004eea139e59fe077667f0cbc20067c3b8c75da8a4f4919d1b9788150916551b2740d8c8e3627c7c172a1f89f958f6b8eb86c8c066a13473492710e33e4c29c53dc48bb10a643d9d433ad5712ac5d60b4a4877d7017828bfa0801ee051ce8b6b6bb31fd48abc81159d1fb534d4edb577563500207fcfbdd8239e743b6f39ccde927777f05b629dcc132abbbfdff66a99ee4b37a7a064340f362e9c370fbdedda690f52628bac5557811e74ee192639f291a2835282b60e20a0b513c6ff35e56fb1a738f025c0db9e1b15b1cd6a61cf78c26b6ca1a806c18901635ef9b3d9b5384b56f5cc54c8f8785fd0cd8e4c9e2bc00606619a544ea84f7e5f7212e72f62e5d54546d5dea555d3664834eb663fd34fe4ede28fb71885edf2a9209a83d8888551c1a752ddb04217d36e0648e135f162d33edb9a2a0df3d7ea736ce3db1b829943708b6c98344cb4a83f83e00f0b24a86faf588dc8b18af6fd514ad3ccb0ef0f4130a40ff8550a33ba9ac2f0903f45b65d4cf9c2f5956332f4b63738bc6f454da53e22d0c09feb7c65f4c3f88bc0c4ebe7e1bed02f87f6c4714985c1f2ee0499018f76572c683daf63fce28318abf596198ed6a1b0a25566b36c512d74bbc74cc2f3016dead44699451bcb9c4cb74101949c9853157febc39d386d703275a350f6a6fc7df6c2512e7ec1c52b178049df876770b855ded5362127abd1574b585ab8ff916939dfb833d822179a3af6c2149c902640218a9ff41ae8020e1994f88e6d7aa1fa39d710450ea15529f40261452c218b6d6e8d6d5465f5887230cbbc954f13a21a7c9dbdd6342dc9f9f85f511c9df339f4334d13db321619807e3ada04f130e4a34c7d353e7e9a385917df562bbb411452b7cd49b7c0392af0df16513855ec8d163d5f20307c2e6c8752862efe250c9d9d819dc965ad1a51908a3cd3632dedd8081e1e1e30c811351289ba3b853934aea030f05f9d3f38caf67394a681470c99fe0a4d0e7b3402261628c16f2b9904750315228b9e0be30aefc3a862733e6521775ad17a9810167278d8a51c77c2cfe010da9b183961413ce69c3f5ba938abb3ba7af3c1e14b88c6f8c337c2128d2fdd83f20145f3c78fbcc2ce7eac716c1551e2f7706a1403a3444c81fa2bde612e98c65c07692f7f470e0b167f7dc5ac52b163a43b172f6516b32ca02141afa500acbbff580b76ffeeab7305ca8540e3a5500d0d570e9c6a1414e404560aaec4d9a0fb33237281812eb01b03ff1eb1ed592756d56c9abadc13550158271765c3fbb3f906c1d9880a7f78ad984b962d474e4b61ec4af3c50dad722adf14b3eff454e8508986feda81cad21ad77e23a48e83510196992f1778f33a42cc1a0cd95adf2102ee6b42f1e4b45bae8353168a5b582f1b7dfb870506c2cfbe4dd49b70953257832674c3e9d6299e81c08e80691777dea9d828cf38760c0540796117e62db3085a014a4a093d713c454afad8a0ac2ccfbc0a3d7a3b42a6a121728a083393d171f77be2cd2206becc736da397bf59a69c17d226bba5eb167d14018d255b85f1c80aa5fc76a50d3192773c0243feb38cf4a430b72523c2439d8a4f49ab17234993f3a918fb7f663a1eb0878ebfd14dd59fa90c0ce2aad5290ced2babc554ca1f1f76479f32e20abfa4831b162dc84d8ea6bc822f8a4c2d52dd5e8f09b363ea16f7248e9a5522fc74bf25893e1fb804667751aea51ccb5532adba378cab998041e3cd7cf39f83b3fb098d1adeb1a35d641247b3d6beb78a1d1ea7c43a9bae1a0758bcc17878885c7fb946c811e2cc84761508612db281d198e729dbd1468aa66d814a67ee8cbeab539ceca0d631e1758a63720b3bc1a4265c4cf44212e31c012d1a74248d0332f443b2692801bc0a1eda35af00190a318586d2686caf22bba963f97abc2158afe5eb7ca87dcbb78475674f61d3df6718e5c6907537f7129d7e80b202b2eaa1499f8bc38d573a360eba495e6127a2a83aeefdd984ca3dae632e50c5e3f0ab20bdc3d8668172b713d13774d6a3fcbae7405f50e14ace3b96885e99b7b7ba496a3cc09ba172d11d72ba376df477e16463684cba54bfc7087c34728b01f8c15bbc693879222743dddc8c8bfc90b85c2463af965653e7194bf02f4a0a08a462656a2fdab679972345dea2dad7483561967e4fee2033894b575d479944b2d33ef4207e6a9bc2bbedf1e11d797757abf8cc7babd8a220fcadb3815004b7818971fd1c127cb4c3daec509abd3d1035e475f04b0951202176a965dcc064560f93bdcc9699819ce52d07b06ea87aaa8835b80f32f2bd9cb6b1c13ddae45dfe60277f3c0cab06670914220554699df65d33e5cede5fecbd67bbe1df19b15576e5849527bc81a573f7fdbe2c546b6340bcc26dcbe640688965f00291f7493a2e9933ca0a6e00ec4dee69da7e70fbb267da829c71698fa615e0748894e4a38cd08fa8f7ecc48f8a7501a1b7d61d5ea32bb4c0030c988bddea133732a429038f91a54603b7c614b0c1ed0c6a6bf467887e687a0d8babcec9797dfe9baddcc19e0cf861b12f81d7574f63ac174d788c3204414812bc9b8a4131fe170ab138b97fa5206b24a37bd583ea536188c39079fb0379d9b3103a81eacda2e5f481b461db05d1bea49e56b0857c972035d4830c33c7b4d9d87dd386688193d3a1946877b4a6b83d965c6193182fa9b89b5978af8fcc180b9ab70dd54d7e99e643c5dc4cb31e83d4c73f4351550209e5fafbd98eaa9b9ed2e4fe6b7f5398f751cb419b389198069fc916d49d0fec2d0cb6715d54a64d9d044345941ffc302e6029ebabf7cad3ee3c1dc5575811a7caa47366c7b8179c27dff287c3937e9e2f10a2329aba7c1769f065f4655f55bef22a0583f87300e9bdf15ae7007e71844a8991ab38634e1f82104a9eb2c0ca401c19ad6774d0db5a4b76ce21f68adcbe29723d132d658cad152850007630d206a4dd255e2e38dd530a6a678441224067595cffcb8377e603560daac00cf37276170228452748ae5d317ff8e98c7cd76d0d0e7915fd38d8fb49b2bf30765ca445f409e0d9f8443f5aa731e35876ce44ec8049df1d8cdd573e96a1c18ca6025266d7ae34ff867361846d90107c3451990de603a24c3b39d17671706a9036c355794a94f99ced3dc0ea761dac989185b6874a6fd5555592e8603ef35ec0b006ebbc6b679bb7f6357742e29120f4d04620fb9ef1a2d45cb2ae42a9cf98161cdbcf201b6fde322e09739a6061ef7a3a89ba2a04c373b27f97e240e494cad880d29b9ca1a27a2e3058945d0515139a2543531b6393de146226357af4b89818e8055aba5a7f26805ef5f632deacf6ad7283eaa3c70495652196a5384afb4b1cf885f221d5fbe74e3a109c27540826e463417460f5189c8020b88e496f8c0bedc6ab8ffb93837f1a38f762047564c261fe32e4c4bf3ee5d20fc2e86a10314e80ad182b5691017f007f20075dc35aa9e47e4c6c73607c244afe967e732147ab9add8db2ed7c4596ccd209ea15e5b0fa9beba0b4c8fe4d444f809ea39b3cca9b0c11bb14e8e4968c62b1debf7574dd4c6076f585212c6faf42e0c4a4941f95dcbcf02c8825954a832553a5f4441dfff4be09c6fdfb1a0d79e9fe94103a94094485713dd3c26e3dd362a8ec94e577a5d164d211070eeb0863ada4bf52d27912c8f240f7cb3533f48c97932513a8765f6a8bf30329e7bcfb0791cbb89ab52053360c3a8f5a6476d4b20f963380e61d2b70a532082b85f4a4b9c2c8c13ed26b49505f73ca254e389bccca4d0270bbe2ef28c92221f0d0814108b0472c18c854a1771adf73b60c0070633507e8e773c8edf25bed23cbe18f230f506ef16c963c184520b11894099c64dbd09683cc4ee264fb975954f1431b125fedfb0984160d50bdf51216b11b0790a5ab10ffbfd57004e862294456bde1e7ed0e964fde02fe36782b3577e789b6d320740b0b7a21c6f0bc60defb56e814043d266b6c9e1379c6939093c4735e34b798f583db0a8a4f8a29b907462390f5c2b981f7e369253c4dd31aab2d184eb1afd49366e6e50a8f150729ddc161e1519f2431176df9be23934902833f55e1b169ec6de24f9d231de88555a059817825a81d14cee32130597104593f0298e130348ffc86e81f4c30d29031c8d61dbb7ced592006ee3750433a3e0919cc51fae9282732d15bcf4dc07fff85bbe922cc767ea87d5b6f97e92f6c8664ddf85849e5963d81086fae97e38ff419d4f62de579d3acb1083142b3f757305e436d24a0f84e767d2297fe5a801e60f8e141a063427d82faaad117e4515b89672f5a20031423126ab708aa8fbab058bc91ccaa13bfdc57d3afd2dc0055fcb88fecb1f5cf51e1b805f595f3ea0cd5e69c2b653b82759d8ba5f9f91a70a2da6ad8d7671d782ff85f300d3ffd1cd7a650d58f0e7cda57b1dd77d2c1f1e28f274845d6d752d0f40762f420891e50016c1893d6757bdad3e0ba17005f34c2da4d01a313a95715a524e8c73e85288fb9693c46ee242c8e48ab560be078e3e1da56ab5a396f06ea3ac9789a5801f58981e3bb93ec00550babc4ac45dff6fef10156f414fb581adc926021617a89505569fe02ca596516edd5ad412ab92f705ae848500210010c5b6a45c0837804f917c876fa4f32b4eba6732ffd1be4e29d6dc8ca7a22ed2c7e040af35dee03af20f2307190b1c359a1a617e425a899efad235ec6233e5fedf3b2c87141c7e3a48d40166b7c2411a55303aab525ea7a9fd9b51eef762d11850aef28f9ecb18021b87f190a34560d8dd0fcb02d904da7fbb4800bbe3df86bbdf58fc0d2782f027e04822d68bfefdf8c37a0924681c9ca30e94bdc8eb6f8e6802c09cba0604d4fc0283b7828c43ff6c72815242fffb7711294e8c5bb0b1b505a111359886cbadc7819f7ff8461216062663f68a55d3e0e84ffc1b4f7f2ff3d10602d090f87de2052a22991a58ee2710c73a29664a5ce5e63ce3dccd851fb506c9058726f15830ec7b0a55ce9d3789ae8bb24633ea949e06bb7d4506300c139f7d6cd90b776fcd948592353213372686531352e145a71980cd9ce2118070b555d013ad3661beed614b55c8600adfd8b2769506d4df6e6c4f1d6aefaa058865de5da2c165bbaba824702b9e35c2b47290fb5b0b00cc0f5fa66bed5d7bf42b5e67cd972c6bb141d7c21898d1df6c2cb3ccb592fe3a02dd824300451af3864fe1bfe6479e3085a17981a46ea725341514a3a1e90814e69d8e7a6a538124bade7d1adfd5412cd1e527aa005021070d599752e25c6a747758a3419e3e67727b85b40e5a1efb084e326c199adeb9ac2aebd482af54ed3ab0a785e5d1a32ebc6c6171cd77043e0998e71e22ac13240f52289bcee0c0e6fa24b2977ad2b034333aee05f2a9164ca350e67aa42a8624b86ca257df9c28433755044b9a4f5f82621405323105b672a180b8e17bee98ec91c9c5e8f6e202ff8f762e1ac36bfb2057f0d8c027468ab9278a52e4e0f7acc068300b196af5c6459047fb217d30ae2bfc07ce95263158507edba4d481a0e3cf9490b837d4509a1e8f887a4f5d150d8461aed6364158e322325801cd18959aacd5dac3f16463c5c401b5ac2a4f5e89dfde50c475ac8255d8bd76bdfeccaeb64dddb68d6e1786e319a27d17822348a983c1cd610a9c67102c69c41264344696fca1524973192ebf66f5e602f3c19ced9fdc4c204464fea9166b3b0860052bcd784669c01f418820512b20e2e367ea6ebece9c434a93d86155e77ff438de8c02dd96112b7d32d1d250a1795d1f76bddc8c6fc1eea684753886bf579028b40a4e444d82193bbb5ac88562a9a703a151d3403cfc8e02a00d4ae70db6bd25d607c54b05007bee98ebf82f8914fc4ba856463cb202b686d7ecb12ef9604b1e0675427bd8878d7d450392ffa969692dbf72f046a61268e62a45b4934119e44eea18b3db0df6a72e92ca4ec66a6ca6f232344f5cb4569c269831de57502e2410717e26782e609957ca6bbeecff1516f16d8010064b22cefa67ece67f095c5f578d0b48f442f5ccad1b676885e897dbe0c10f14dd4cace970c51e0f8f42213401692acb81b6c39f92f75eded250c171062e16676f04f111caf78938172cee85920baa9c4b0443d04efb1a15c610f1a66665aac80a23175fe7f6f1928cabd31abad1adfcd1cb95239f072297c1ff42a5ae98079af90bdc558eb97d70d3d8ec7b5439d69c563bd27bfd3b8b7af0e26a5f6ae4c8e2f68c95744057c29e9abbb508c486ba682e32e57a76e43f83b9fc86ffad433519066cf0bacc6f3dc0015f4930f47ef004c91d037b63c95ce6fd71c8c600dd32dd130f289386b41ae2e19b173889cd0ca249720ca92852952c0161892eadefde2d3b744baedde9a6c33762293e1c582a7da49a128ed26d42d5941c74588044a6d9a48cf5b2a1bc6c92a9530381a2a118ac2e01c5055f680a6e705405f68141cd02a33e1dc6fbfa0e1d0dabc3320ed20fb5ca90aef7ce29d3b145402a8b2e7ea792d969e005cd72ca1b37a955934c7ec2b64b476e1930a161781d9f4e382a0fb330a2f5b6638dfc0ca76997ef535f3e46edb6d4a1763f611a4b32fc404cac837b6f18222f818a409b3176c74dc0fa5f8feddc32ad16eee9cc4efb962703ae45e2020b1374992324323e06459b699604a21936f2a988d01aed9063c137a5df24e9cf9ab11fed15e7b314e7a1424c6e3bff585147622e54fbad60497661d44d325f685c681ef9511829f9deb3ed8c571bdc8a8aa3fe0749ce9ae5bd612289ec923d895cf7e541f2748a5b3e0f1c9d0c88a7131fca8ba980188dee8baf363f24827e330dcfe37838eba9d3893751ed95093a197600ef986b1ad76e6ee44198a07d64b39006d4187f5c6aa404d102cb8044b3007060460a97640cd856fc7168592d98bbbd4efcdf8855dde0fb53e5282cd8c056657cd520eaa790b6e1b63150174a629cd15fc260ebd7020a32b2379ec137d92b9e65c44e4c194afdd9ede05d49ad413a2ce1744fa429481453ecc3465510ae28312a2872d8db6141a09839432483e33ed358c18713c2c90a7b1a33df1c5b2583c6d34efca56aa25573f2dd6cd04233c2aa20371d84fbe2a5b1a8bf397de054d3132133db68a4f8428931b3825138a570486ea6499033267a00d8a9dc9b5a0be3e35f59e6dc73b97c96d5691d4ae492fc4c782ba2cf5fd17eedca015b4d47f8c029d84144751839b2428bb8d249dc8718f637d04c93083fe74fe3327410f898aa2bb4f2e593224fef2274006c430b49545c7df96621aceb0566738aad5eae99b490056cae45f55a28fd49fdf3027ffb7b0f63abbe2f67f7b8326222fa9d8b9d4f3b75ed716698d01da5a403d0f7044126d8fa8092a2cf187fcad06bb34bb596f5598fc129720c25dcca383a2e94dbffa54f95a3426d1a06d01e5ddae5e51f2e1aebdd82c7a87da1ff43abe659b2599a8245f3b4207bd63d387a76e8af3b85c0828e30261b191709800a3e74b984aea469e416c5f5287be0daa158a19603c5878667c357611281f7041be67714c7046d532ba0e0ed03398b63e9f7672e8b1e4554435a622569b3553f0b0cc29bdd19a0d7fea74fab6fc9e3cd6926860ac148f59449b105e6fe7bb62e9e00a54ef2a4f5976563dbc0c119ca9785013fa0bb485a1675dbc4c19699b8f72c53cfc77cfc5e675508482830822cf1640e303fa415ed04a1c5b7e0733cf220250e574037840fa4ef0c7ce37a498478412661ed3b24af2a8be0997a5db9db9ccf41a79a0e61d651e7ede4b4f0164c8fe52f7af00542d17ef2bcf921829d27d9fc13720798df98b880cce2f5c5dd47abf3f1e7bddffc9a25361bcd35003f1039f3c09bcee9e4541e96e855798d2220a05a973814911093c623c1eb92e7b8a37ab962b3b5350f36bce7ef7b39617232d5d517ce0507f2ec5da0030a20ee66473bf3e7ae3354f9e01d16c97c01639171c0173424a9f7f6d733e97e29291fc34dc0feb6eb1844667c5bb0c32385e56a2bb02a5efc1c90aea1d0b5565873c575b7ac63e0c4c1c4896eeb816a938a02d6a37acef47a86aa84bf0cace16c9918d0d10644db1b4167ac29ca0ea5ef984027af4376c70d79bf498e3c9f15fff8ac6e7580a65836a2dbb0445dbe06867a475efeb6f4632edbc8688991821062896b94ff402ebfb031cd40dddfda777201b96478edfca993e9bdbd607fbb92ebee831264071a2780e7fa86c6c8d7a8dec0dfd509f61b85ad0f64dcb6ea0999c1de725ec122cf3cd83d1a92ccfddfc497c6d68a46274b0ebeae226f42149fd70b4bd30278ce1c16633a1238bdc444353930674d126cf5fdffab62eca23159210a9659b23b6435c26076ddd4df6a22367788dd68f8bada18499f36d1b2b7e4942bd75e0695e0a1bd1d83d60159bc7e3cfbef351be5e3c650e77e644855a7bdd708337dd41a8594cdeaf2447b163987cd2eff1e1f75a13241ab1575f3ef7672ca66a61a850d9cdada716ddf78063da431003f981e858f5dee96c8ecfa458107402282699ffc76cb720c223d50c247fc24a34cd52433aba5b9f7039e60d0f78cb7021d8f4ff1a09aceb6de80198747e7c1b7a1cf175096b9b4c6cdd29d16c340b801dcadf5ee10dd63629f924dc6ee436636fd01830a782e71df8ef94251b7150b23bdbd995c730de3beaffd5e8c7019a46e580d285d2f14f575a09f9fdd2bfec7ce4c030e3a405d86b49ba06316c04304048b8d6b99d9daaf0cf7781e9b853533c9f1e7f4c7ab93e71cfeea0a7500fd7c845cebfba1a3152ef012ba6347b6d0aa1fa0b937e9b6c33bbf623333ebdcf2fd77012629113b92e1c3497dd8d08833289436ba5ea634f997bf6965070f19dccb4d9a130888fe77bd516845649dd59b6db0638bc6d4a9a25700926aaf626e012696742d4e081c74d1044b6c0fbbdf5a08154a3fd064600853dc2b479fdb2b29492c2228d50deb1ed3ba5ba7189eb2b820c52e564e7a6064b69cce3dd82902540ea317b31164c98f4a0d9720e0ab2b13b0a300673adbb137eaea8f7e918ad65e801e904c3582d148e78949416b4182e5c6323eb68c660b5ac62b120f62ba89b36ca52766cabcb523735233f22bb0a8178182397f53f4eb4b5ced97b2315e40eca3c5d84c6951ab02da7fa8722e85db806c159b0310215fe9615027eba6a6fc09083b983954c6ae7853157f01a288dec1c315ba9f7c3b444757c300df45b2e4c09e79e8b7a5dfa00893f6129047c2ad52642c51ac91e770346565682769d56c834852ac65b444859eb4683a2e9976ff6b008463e1254189daf3ea40b39160b0beaf135e6bd3878343afe7a67568fbce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
