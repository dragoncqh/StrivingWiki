<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a94766d3621e2f3855ae7af5450e63ae1b1e749354a597b1def81c7c0343c240f014a8c6e9ab05b7604fa42843e0e1a696885330e9ea5322efe30ce5852f3604b2d26e5c6ad39b6220636bc9daf20b124bbf27139427f1cc65904713c78883021516d2539937603e44048ad3506b60a0ce7765d8f5974776c375b396cc1b317403f49631689dd18b3d942c1c08925f94afacc5bd72c854f39f74e9f65a25f5aaa423274743ba6d7c9bb82b0ac0de5fab7dd582dca2082cd6956800626f4669e9fde8f4c7f7f0e1d3099f8ec833cb77e410bbcdf67d93bc1b9733a380c5d630f7706b60d1c4878ff4ea8935c360993e91654aef3d0c918a58b531c7f615efd341ac39e3a0fb2afcf3139462c36b27c40c786f53879c4ed429db89054b581b6d367c107b26a2c273b3093649e3aa291e5437dbf312fe850cca678e7123e92349c3fd1a221307c9c0eee4aa8c6951b4072a2be8a94c73a3e284f99201839b46e87899b8b745b1cdfacc1de0b73eef69bfc896ba2794954efe1a17021f4cbae9b8b849f775b982ae253bcb5f4bc8562f2ecd749b80ec8e888ef76025e8f7b4c57f264c43cfb87e92e41c21bc0903dacd4ee2af89e563a4a78674332a608fc59d8a831fcc355591ca51e8c081d26012b5ac56e631626aca96545afcc71ee527a4569233bf1b51afb07404ee2e2ffd430e15ba02439447f9c9b621af701f125543a72c5ee0bd177a28c201148dc2a24c405f7a572cc34c2ceb9b9fbbc1ed1ae2dfb89d91294ae7fbb72ff5529c3ffa240b4c2de0e7cffb9a4b67bfed113bb33b70717b9016dc0876fbd36b62ad3de9f4ec537a820c356409bac46045ddf23436d765fb8f38062ea0f382950cbc256709c9e7c23eeaefe10df9884e401f861648060c04984c8eff429d310c37d25cd6255bcfb4d3d43a105164eeb58ab5c6ec9ae122921b7027c3797c9bcc83f5f9439f02c22e7224f1d96938c7fba2d92ebb3cd64c55ddb2aed19314766fd54de258c3d25308775cb7943d16a4dca95bf09bc8e84a5d003a8c2ccabf4c4e7af6cc5de4c17623bc65e27272a38d0d81bf7d8adec87eb9c399e188d4dd281713e4f21bcb2b9bda8e9cbf8a46c1c84cec5da2cffa362d64f5ccfdae7908e1676a81773bc75d84501eade07ea6dbf2f2d8ffe8f764d60129e1c9ce31b18b77b728cdec25862205100133c451d5d7fc0e644163b21a7d9557eddcdc65196b834b2f6585c6bfa9e07612a130b5ec3e8f733f62681ed1217390f699c3e27e6a80922fd8cd3b71cbfae1d0d0e33d0056ed1666bb8514026dc23fe2878b10170bb2f5a7b14c4b5398bb46b008a3bdffbfeff5e472773086593f7c3092093fadbed59e50d3f784ba4f28e31b62ceff0b83347d9923f6adf5b2f69efe799aacb26bc50b64414434875be3082f6f0e026adf6ca9f02bdafc158ae8363df949e9fcd767f81044be3a7fbdaa67c5253af899642e4ddc12c649bb10d67ac92fcc74245c3e142a7103f90215af1b2c3738cf0bfaa754b58007aac2a79755b8e382b74162ffebed3fe7194a9b4d2e50bb88dd9e5fc3f7729e8038ea039712c07fa2d48fd2241da52e53cec4f8685742306ccb808f435bbf8b978ebaedf559baaa279154ff1bc7d0885b57073220df2ebf0c5f667e709b009a5a07bd6b9d423e9e6a1051e57d513b75d22e966c1cba4544b247cbebcde6ecc3afd422e7f3a64daff19e6f8e23f5c2d936aa8c5c9f0636a631b3f46bf8b2010abd8656d648fea7ed1e4ba156460242fef7a23a61b1cac3683a070ab4a1af87037dee45c25d79e4bbc7fcd6224ca4713aa029aa46566fa4f8f517ec278b5bcb0358ef39dbb3372e120534130b49b70faef216ef657fe7605f67011603b431866022eb2233934b79a0337be954163e952a1416cb071c296990b37dce5fc3627487e988cb80796f1750c3877182f473fac17e7219c1406a8f71a95fa561aa6d758a7fb9e05ac62c51fbfb96eccbe0f26c2215687272891d9ffbea0d9f74808ec33ce7a8dd36f58f3736ea35bc9aef1b50b62e79c481ec43131ba30f67490d079778ad7a2dfe7267619cba565653bdd3f17664732eb1a32764c9266f11910a173262eca5e947788dcef1ca43b3f98b66070ffbbbcff821087416876a7731c8f5eed09f0349b94b914dc728452e82f183fbb0924fe812b069f69240371009789ca6471a3646029dcf4adf3cb6ee1e5e4057eec335b7ea6e57baa69b3e56974bf398ff2f5b922c4b93a68abadf3bc280d92b085e57fb92d728a6a42b511a69b1a398ce737a8ea776ee7b9647c8235ee621f7d7d06ce69084337c3ff7eea000c5f87a449f923389ecdcbcb934ef4c518548670575eb844bc1d879b1248a8af8ee35756a548c9a228b3ca1dfcf6cf6ae3b718d69f1c23bd08fbce30604ddfba3cec02f03d412a7b5e4918f24865afcd9c6e015557899092a248b50ddcbc8145f80df14dcfa0df6ac66baeab0dfba39234bbfa37cf17548e8e13cb13d7578e1bb0428541a0fde8e2505dac36e8daea52930d31ebc79619b20a441cdbb5ea33579fcd0be00b943d7ef811cd67eeaa89168cef6bb4d20fd08361fdcca6bc2e5d9b63125ae644b9f05ba5cc8bc5d41c8584b7167a10bf144a44c152238535165a1b7b61cb3d1f5793ab682eae05b5ea86db2847e70fa4a18394d93ab5a022ed543fe7208e50ea22fa841caac70873588dfec492fcf8ad660342942c4038556b93392ed3db82299c9cd2eb22160436e6be00eeb0704bc0f48805486f47fb41cc619a8c747b4769d7c5663ccaf79cd9b2d9af9df46dc05e2d384da30e9e8fbbd8162b50346c87e15af5199c216ba1538d4c678e92eeb682ceee464d85f5b336cdb7c17235ae2f1c75b10bc7188d74b31ebbfdf09d19970d586da4e8b491391df71eee49cccc62d76fda736c041979e0b370f254ae0af0c2e3f68b4ad80a0b871e4669de7ef94c875021031f532ecec184b777df5abaf720e1bcf19bfba9e0791da35e17bf9fc0b0cbfb385c04c3b514443bc8d7f89f6201ac889160a7a555acb3a90424234dc48e1bf6bee604510103592d5b4e4874c22bf172dfad3f75c0ff3406dfff1669c11ee2e88f5963762b9dcfef27d4a6bc78b62efc3e18e575d56244a060e890ebf6db6c61c051892f729e0de143b083fe553cdfb92b9b94c99fa21d283627de8278a379990380f53c2b35680789ac19bf6c244d3dec9a05008f583b7e852cb3ddc530ebfcca48603886547777c1e16f1bcfb2ba54ea2fdd59aae5c768c90d64c00d54134853d49d1e58c94eeac5dfad12097f6d2d5be210bf42b8bdb9fe3add1fccd52d228555c0bea78dde69159d6dda0fa89053f0ee66ba3ceba5bee99aace7516d6d89f4ab3d6c1d9a2af8b3d5894b273b4543be0b2d15bcdedb741c75508397195055d2efdd0b79d538d2e680996ca10db6c1892fe8aa196e0ab57420b24a837672496c6c4aff439bd573c5feb9a648b55f34d790ee51d302fa24388789840d5a54630243d77321cf85a317a49063e77b315e4c8e97964753ad0df9b3787537804916c7a43e86dbde3cc7174659644c0441cd6a3f11e467f9c39ba8471058b21936e5d769df24bc5af5e9e0ca8de3823be5acb03abfe1b2cd4eb7aedd41a571616f4166abd823cdf311b5071eebcadf8c3c3165c1ef11d1ce44a9db571efc3d512af6db00aaab3fb9742a544047a3cf689ba676d1b19cc322fb0a1850221d447e4d75ed19c797d31ec7656e9f054dc9a76a4c3ed6fc3a063f6c829e26c1ccd37db06991c85e610a93a19253ec29ab616dbfd044339c1aef688a4d70962f0b0898aa56aa887f47a8a9b633f60efb1fd25e23caaf7be0a965ea1780cc46cea85cdb1f7b8ab93c84ad11b49c105c80d5bb5e3417de7ad5a19741307446f24484cf5eb5a20bd002f17e60bdcfd0f38b9000428a59f84656a7a1be1dd896ac8c99d1d6b4250e9974eab241fec23fec17128352165b6cc1bd77c7135a4fbea27139781f50c00bd0fb9bc31139ff918d59a1a46fb3be87fd71d629d682bdeda855e0f71ef86c51fdc6d6a74a604bcd2ddcc3a6bda57e9649a7a8c3fa9ed26305b3fa8a3a76d1425883b2dda36acaab3fa283fe43ba7b0321ec368e66dd29ebbc9aeaffac5b30a0564365f9a294e34e86577a5c6fff5d71ad0a1cfc7ca9ed32f490b9b3285d09d2ad8187639e026aed1770c6a6a1e513f51655c4a588304f62577ba0ce9abffefa8936bc5421f3c2e1db25729bb10f6f644cf666f2fac5051e76952d74f524e2fb6a0422c818e740749e8ddfab0a3dc1a1bcf78c6e68fd8eb31fd136f1c942f11b32b7abb817dc4c727e132f071c767d28e3e419d41ae665934c06bb2cad3c451a6a7d253e8ebff60ebc7a599791a105bd08c7db6b36ee6ae85cd97f4220e6f52c10656ee40a0476124fe1a01246d1543bbb20dc2f8ea0050561b33819ab4d82f79846dbf6e3990f1574cdb77736b72433ecdf3ba72822f94fe0dff7d45793e07a5044c2153a58e0f7b19f1c6735317e497001e91e1c99dd6e598f5551eb120cceca5f6ea686bd7413335044909396bb68c548df4e6e771f23cb3a4bb1a8d5324eb60ba96d7662e6d89dd21336c5cb83098e913d57013779728c512a776b37295f83fb0909725009544215c4d628d8b628f694831ef14096d7115032f9f902e483d72e40278007e2d0a39e8e61c82ac6fc265d58afd70cd2260524f725f750dc00f2ae0319b6e42e5c9368c9f708997bbdf9cd20588fd5452b7cb7e4dc92d8ac333f675e6a7627c7cc699d610e0b1d7bc83560fe4ce596e69cf617b8c476967e627e78fbaebb5f59c39e15e7203241a3ce63352b237c31ac2f2032333b986cc544f8f52f4f22711183d3938dfb3062eb7826a14b9f2516651cc9872e6fbbff48a8357a63e6e73da40c9f01d6d896a10f390f0c8959e14407123222f6308f602c0f469639e6b952fd3c42d880ad9f8aa8bf462053b0dadaf8d0b3d613485f427cbd82fb0093bbb40a04b2c2325d2077271c6f83729a05e0f13eb93faa47effc9a3e73ebc3eca47853de9b23dbb5fb3cdf936870656d8a0e803cc664af490f4514c22180b859aef8ee61bf394edeab55a16da8200cbca47dd1684ca8e854bb3646207c2a3fa9504da5a262f1f5172a8c7c32f5d3307925fe7f09a3bc214955a68248b9fab8dc284b00a52e0f701eb621aa8163b25775d6882d6f13f62984d10d6775d1c35b767cc52578494a1f38cf8b606c455f9be27acc7ab72569862030d60a674891142efdbb287b818e95e058f152401a22b2ff480c4b591e4f5096dca8882f4e11e1039ce8f1d75b75bb8d7c901b4be24c0653bd2a5da368438ef7f5dda1876ef35ced26697926e0b376f94eadd22ea2b34d3f665344c2a7cabdb8ecaab0326adfd1c751412b2a8c70ddaa33e6ce5697dc8ac49b3da92f449bbc9f0d0c1ed08d11100ff15b8edc6388c957c8b0fc078ca98750e660e3575437c9d3ea1836200c05c454e5b5e474f6c0c5e69c86f11a25375dc5a2feedceeaad53177a20d3dbbc58a3a21f7b0afd2dec3b4e5f34be43924c867ff681614f9f11055e56c00c64ccedc6dc0772fb61b3e9a89f6d95ff194642113d666fdcbb43e77406511f2409142a37371aea031c6ba623c2cec61803323a593dbba018519a6c02c416a8758efb96bcce2573c728f9205d9c936adb8827d113cd9302a3fb555909a0488fef466529961add8bb9bef6b8345c02342b3dad59e8752d6844f76ccc25069baedd7615e9abb9e6098edf2ff6a1fc4b9f94ab6eb4162b584c5565f9b7715b51498ef0686e91939d070932066da0b67548cb8c75651b47fd1bc5214a5021d8e4d3927d8ef9a4648582da389a73862a1f0187992dcec68e42cd73c85a64f5df0fd5272efde2a5efad317d9ea7c6a8061879ab90df66bd3d674116019dd33ee685ae96d1775f4547e16d830fbb011fc30b9dfbeff5c59596aa54d25ecc844b01eeff76a1a22265785bf098e4a3fc28023e5444a72ecf473fe553b2edf52347cd10464d8f6e64b5be78a0b4e277294a4d447f303df260739dbef0bb4795e68b2cefc0f8750ae08353dfcedac280918b624e32e0a9cbbc4c2c961f00c9050a0f73805f742aea24f846e63deffca2fd7a562da3567bb884c2429b7bf3012d7747c243933a361d5b68ea09a165e666652a28b13b3ff7f75b3bb28ecae0b1b7ea312fea52d28279b22b66b9787c8c294c635fb5700e4c294b97b157f4406ee75e40f07d3065c160261c09c6c30ac7e06d1018624c58cfbc74c3776b6d048012e5309c031238dc34c2c9b2da86b6e263d3fe783b4095a63be3e76025f68d98f2793503f268a66236bb1b427c77436d8f4c812f3966ba8962df1eb24203ee8dae1041ba416e850da0840e20be1139dc0ce6eeb7ee14c46346480c21a3d891554de997716236abfadb2ec50b9316f579ddcb75e223312a35b4f5f53365e1324c937deb3a9acedb95a80fe2ef31186255487467e88f635b04addda267dbb2f8b406724285a95ec4ffc7f2455882baf945926f184f23668a94273d1a027ab89884936bf6049d4d786eb3d97f1333f77e505a9d161d087490015f574e9883567a3c9bec363344abfb89d24facb03c9c098b8b6a079645698105ff86b40d351176454ebf2a692c0b9372b156b501a2518f03ec0d748d52e1aba88acb67c50c0873d6f0977591944e89cea03a622f799ed3f0250f7fa3e733dad8efcc30240355c7b33940086942582b3fc11dc6c37892ed7977883f26561f66af1c9dece77edb77ad36a0a253b75d694654c8ef0a182a1faba074f356440ee47e64b9ecc533c248c79162ab60be74564d169bbe09c7f8ae5459175e096738e09f5c437d15c6c18dfadc30b0b05a9861d477f2639d092954393443c08f6b4f054decb8b9f1e08a84d080f3ff54ca66c23f50533c5301cc205f2b2db84dcfea1dc60566619e5de70efdc0e98dc6b1c7dfbb1b015669a59f321a7895ab94e5e23ba59cda7ed18e8fb10f82da560fb12de4df829d627a860bf247c96e2af9b170d861a7d78ebcee45414eb0f651d8427db79db04bf96880a94b74162a097e17945fad22cab9a933ad1a72ba6028d6d8053429cb0518063181fed9cd1c71117bdd06940dca5c36ad3b00066d37365a0b02c94ca7f3029a8cf1b9adaaa43f63be4a33aa7bbb74804b23012c55ed89b8e52e2232d86328d81df85c1f56b92896086c5478b9ab7a5407a56c618b34ae634a918ff87f10b7d2f6b0b59818796f4e038a8f18e1110dc8d6e835d5e988dc39b020af7471bb8ee2cba0cfb772f5d6d9bfe28affd3e3c2d8344793e0bf23738bab45b784124fe96b7f7ff0be64553fddb8ffdcefc6329d6c4c56b8c25983b97801095c0344e780c5af7d2bf7548028a4fd6c57434bd706a10540e8032ba71ea88e0ead7fe0694ce13dab747ec7becafe286ee2311b899ebb0838209af6f0a6948bef905fe03fecedceb597a0f2e78aec8e944e4adf6e73b7929d97d1b0ffe6a75db70f76571c0b02d7692c7819944ea42e797ba2a5dc40bc9e4dbd7369a585b5c844965d41e792d1f5fd2b51af6e3db101a476893b168500c23d17ef7720f02c3a01cd482af0463205a183f8a9ed0f66dc18783b596ccc7e024fce3dcd6ddc7abace82b6426b321bafd7c0c75bd1a4f660ca72e2f0896ca17ae6c92cfa2a4feec582e86ef1d512085dc0210e64026443e6cdb83efb3d8448b81460503814f1cb6fd14dd250bb18145a374ecc1664ec792f0184d445564d00becda89d018ff1e0fc764de303dca4841c2038ba1963a65959d824872702061bef16807c9420c4734e8770fc5b6443540fb10d8bd81b31454ba5a6f0c87b6ef3bf2120a7e8ce093b1644739c553afc4e46235095b8237d06536cd44da26808e31412fe81d781900ea9991f6df652dfbb151a072756f8fc21a1da5a469d2f9a6c05099169a1d7434c5e0f06e7a9f15912e8c8587c5768f0dbaeee7d2c81575efa119693513cb0689374a9a987b82883e5f943441941e8c3a4b7ce7c742e67740320d4b119fb3c4f3725b2ef195d9fb8f7226f9ef8cfa9acb02968fca2da778a24820a03607e7c699cc1299b367801930a54a74dfc6168232e976cc22a9d5e258ccc6b5fa52304fe303dc60a2457a8f8d6398f54dd87ad1e58e37d882ac6f997c351172cf8fe081333278d08c11f378b2d817b9c5b907110ec714b772c25c75a5992cdb8a8cc1dc29cda9086eb1fa62b8c972e515fed0902a2a27fcb0ee44f607e4bd04b45e6a0a2534578486525e6905abc37c0efe4185f4a51df0f797a762ec54bc9130bdd9e104931310bb296331d4d4af0d8e9a02e6f7f9e9ea977f4567fdb8d569fd8bd16a1f3a7db177aa5f3e77f2ccddbb7fef7d6555630c1888525fce424a1592d1f9eec0dc1fd7c44ec64e1adc5b437b4213c6c30eaaa5dfee708ed76d4850cb3454357e94148fdfa058377d8040f47df890f794947d17270199260797c02a23960cf4b6ac8df4b69c5d8779ef3618887a431345de0c032833aa3b896123826f7225361f08e07ea5cbb1fa8d02cb22f70142b849f86bfae91e02fb306137d6c2c2c474b33784ed540dcaf3c6e702011b331fc5a4a86baa93e96a83236b5f2c7058952489ee99bb6b79e6463a42753e05b605c881c84587c5f422b684163279f96357e4b5b0f258e470ef494bba25660b8a8d89908e48d02827fbce737ffccc0f55371905a2714b1ba2fb41204d8ec8c39ef504668a3d54ca1a77c1d53b693ffd9676ed337311be1016809fd00bd19f4db130e0d5e47184b77d25d78f822591d0d777cefe361ede48d98e204aeab926e34fc3120c609290094b34cf19aac9a43f0b71132fac5b4cf69a6db9bdfaac9a77c5a3b7a605224d60709126333d38e8ecd5d071192bf9d602d13efa2e272e167c17bd0995fcd0e82c4d529a99b8d9ed6cb2f3cc1497905ecee830f857a9fb4cdf0e55c54b81b112c1ef01d61984836d55a5bfaa5062bc2dea3f7a1e527eb5a44c4596c2aa088dd5d435d718bf17ece26387e5ae0708e76bc77e3c3d8e58af50fde0a6b80cbcfb1af87fa37f95c056b86a1527be1d631dd0284f73de0f50f6642ad45b3ddbc5071e5df1ff9212668760adfa492eaf8f6c2ecf61b3aa9cfbcda55017d8e1f5a5b424af0a35b51c8b5b9c74b0e4e5b82b2e364f537d0dac932053d20cebbe46f9e7c36f8da1cc2df1f781da744de9279b11f49f7dbcfbba1e2e93bffdf2c7d15ad7bbb87043f6b2a0aa8a967db8e3c5e2ba8bafcc48b795b1462fc45afcffd87648e0da3b2ea2c0e3d81ca04c20795ba4e0e24567405cacb4994a69a86f5e1b16f7281cbd180d6f45e99dea40410d1579acddddffeb91d0e977c3e8d4961b24fb6f43aa76c47abbf0533dc1ba14f4c4882d7622d17abfa75c2b95a839856e92c63ceec636d6bf056e998f4a88e1a2907948e17047e8ed5a15fe88899a2becd6cbe666817da6ec496352495677e0444c50a1cb00da1738b1ade7e5652609904bd2c08b9eab0eff845c66b6885f4a0bf513a74ee22f15714df0039ef7240a048a4077f9b002b7bdaa4d16685b9bbcc08db4f9d80437e496bd10966f551b63469f3e17f42eb37763024c9eb30db496927a7b8cc5f1645cbee8c201b8dcce1adda5f1a4208f2d3e3a1656647c49936df0528eeb87145781bed2b53dce1126f7abda70c69dcd2057631a52f888bd6468397aeb9a0b3c7b79544d349c74ab618cd681b6dffa113134944401f54bb8a4f705cea51bf7877ae21c32c710581e2d664db447363aa842fef44b3a8da5448ae854e273eb5f64c229423b1a379a47421dcff15c4b1721c2f424783a682a3d0941a7a155434a931324f2ad6d973449b2663b9068c6799fef2e9ede9334d67a191054723f9d0284c43f0e832ec48d4c4e30a4188a66fc69cfdd5ff9cb91f5a04b545750a650d9f6c09d4c1e3f5c6c08182f12b11b6849dcb4984e7f285f17d91ad5b21d7896e2c84f7669230b547e28facd8137be3742974f0c4fdab77bea2fb506b8188c07463e372dc7447ad8f26431f4a07ace3ccc7b205076c00f45be1b326f06b574fbdd048c012eeda8ab1e8fa1668ea5a379eaf26da575f43bc06420f36e8dab0eb79f287311b44c2ca15aa941411222d2dead9d322ad4670ffac5aca2b28bd728c3b8a4cc2be2a71454a20e515acea1fdba3c1d6ddb781356cac80697b2e70246fe389e6687e58dd60919178cddbcb3de427ecea8b75391485d74baa254800086823175c42cbcf059d6cee6d3d2291484dc6a6ac29615dfb21064a8736538f263944ecd285e2741968443d1df7f4b5514360d562d5586710e1655a0433c66f2887afdc1727c265c5bde1b7a31a2719f579306b6b3daa8a5d46aff78b60cb003f88456c3f31b5c6fe2c7a48e92edeb9aadc2d9209f3bc44432b6b53415c0d320b5a2ba07fb4f64d1e7701cf968969f031253fcd1733db83114ddc77a781e9ef35b08e53d96aac8be78d8472010d19e9f7e9a62d23ac35c72eb68076296fe05d2debbdc91c6351482851624ee316d36d0c7c7f8294df0caa4b88362cf5d728e50de3e0ebdc2b6a99efe39410449283bceac0bb9eaedf3fe8018aaa18e7c3e1f9a74657caa3fee5a91fb982fd0989e9337dec03977847fb8078f495930b647a2e1de271b9fa0a55a7f6404f40413569e698dddebc410cb819e65edad4b9f64940bbe2838f9f16606d432bedad489c9065062db0758dfaace8f7c7724a2da4f464f296825770287c6a3e6a27530f12dd7096e113806ae03aec6adaa1274cdf6cb7a0aa875e1553fc1de38f0ab61001c2603e41e3cf997d52cae458c936b87bfd880135cbb8c89da48dd16319905f611bf9d17a15a559adf40980240eb11e6dab350f8bd1aa0a752c793e814ba590740aa860f4ec03f54512da55571d4bb454c52203828613aa533906d0e8baea59c9202d84cb162de2769236b6886f77dc8b18d6fe275773b42ca4ee273fceffec65ab2c6994d4a89e7ac92c861446abcf371fddb04432775f7c0a3bbe300ecea717a19f7f994230fe419b60b7bcdb3723ef1cebdce638ba2e63a241a61d545f1e470ce5b0ac1aa83b03652ed7192873adcf0d99824da70c1322f4b371e88942af1a9f2e280d6dd6e53cf056a9f4411c33c58e0e2393c3f441e9933e6c8f2d48f1ab632546d38c95e617945e605611878008322019f67b9340f00f3fcaa2ab7e49b10cc5c1177ad9338cec8c72fa08a30d7c60c6fdfe2668db2811fb3f06b74edca0c91628a3484ad9d850c5535f00ebfef8a124615b755185acce3b5a3ea4e8fc2365aa8ff831acf9cf8338d4e43d84122c25a6c2da6847da9b7e0fb1452de7081dafd2a3bc6d08d71d88a8c5540475b54ba26a030ecb5893fa87dd42d3173c18d4d11319b8a0d289dd33342e5f65442743ad8feed46f56be9cef4547420f08192e83a2bf86b22672c74831e350794441dcf27693daaa61a826cfc2b9559af045beefe7c94b5cc3b0012d71e416532d396eebbfcc5c5fa3ceeb9b0457837c770d4bea766f82a6c9c2d191773c1bb8db3a3116e3005ba6d6543010e498c9bd1a14197e8c850b6ae9abe9cc10b95320e9874c5a6f7f09b99e846349e6cf86854f227900928e0cd2662316b69c8b0daded397426a8a567670bffe5b87dd4368657cef6d134ad7863c9bdcd0db580bf596d32a1d13e82d24a257423f8b596471493cdfe8accd32d4019c520727584eed2a3c46acea0d2fa7be4685e4a1aab924813b55ae5c5fb244b20d037267bcd1d54bda0faff044e63f7317a1b9b593a825b51d78ade0b48b3a9ae33e72e6f45cd36e0bda97e06be8ebfd29bbd0215fc45df03000db656f626dde3292181a139e59ea62bb19b20f887372716436b8be25218738725e085930e97b2ab4df057a7e552743055fd8b78f507820473b639accd5e10fb2660a65c310ffe0a80c687873d4192b469c5674565e3d61f54184a68ebd8a8079c5ee73660885ee3133bebc6f10f45fd14b4744377c83aad95b36c6f1603db6252aac70c834cdb1c5268d04442d9fcf9828b784b89395bc6b61c5a6b098f18f2bb11cb55727f41677ce2f7045b362814fa87349235182249844aceb89a7247af80dd1ca7b95138726bd3a903c3db1a798d5f71fb2f1dac8f4ee39ebc6e74ed5dbed11cb4d1436a0bf69bbdbe1f92ebe5ea5cd6cb5cc91db9005914a66777e1ea902fcdc8f006ce22972efcfcfc72b44a1a2e558a5fcf9874fbec09beadab793eaaf18357b32cbeeb545a9cbcaa592a399d4925129c2226767bdba1475abaf91a5cf29808a94199c7e8d843c01d55edb2125cc169da2e0e6bec380f46ce2eefda1ff89284cb002374bf2526ebc301fdd159a4b092588603a9927f06e00e7838631409d3ecee8a6e168a434d79e2d3e6920b040f030b45dea81b57ba9fbc9a1ad2ec93a7810d0792ce7625469459414fd5812f44e2220d1cbc4cc2f7703101a9b0bc1155c02c3314931fd88a886c793aac8742c9322e29c881d86e3b64cc3261f6047ff55c5bec140e2c006c787243e653ef478e29f144d1561b1abc4351fe4c18c7ce9b6f6065443fd732d5b9d5b8cfe2e4e67c91b4fd850c5bc3d8d3f045fd93be639dc06caf230f7b569538f05fed280533f4966fa5513b6f93e4fb142e35a240736c6bd882afd39931582fc344a340cf033470ddee190ee6df7ffe0a0d9df168b20454961885f778ebdf11053fbd8228dac7d0cd315504ae5b0e67c99e6fb159e02f902c1138596426b1e6dc4f90214588e244359c92c71a91124b7b202e1d0f84bf948a375e6519e3099b3b3b29d1654d9d9fbed01be9e246c92b078948c394477a9f949a15cd22f911027b72aa7f177a849e7de9931ab8095a4d962ee3c3e2b5269b3c5185099005bfe17d6969f0ba641934f232db78842fe0b267cdc1fc02b0e353e3935cc215fa20f658282adfff458411c9fbf72760007604e9110af21553cdeed53922bd3e692206190fa5ba3644b5d781311cf3f7a30799f73620100b9fd23301b25bcfd7815b7c48008b0dadf4f1b107e0d5ead5bd665a1908b24fe5b0ce95d7daa37c35cdabfe3ba5e701b9f89fad295274cee773bd31124f8549e1f4ce23b844abb3fbd5221eb46d50d89b3cde8b75609104a7f106c93ccb7cc2dad8fd6cd0d89c618a339ea220c36258bb9e27933b925446449518d8ccbb396e7faa0a98891951a7513fd67ed43229e812bd173b893bce5eb4ea99c1164a9a7a6da7120f3a81b3bfb8b56ab65cb756112907318dce0e50d30cd7dc78f3358a3c2eb3c454727d09f19a1a0196c3f58e48b782aa856a4f057a04df5608e614b2c73f0e372687aaa803bec049bb2cae66f1f7a2c9e7d004bb01c018701959f44ac5d7ff3fdba102923de49458674e946c0b96cf2196de178e1e58fa0abd730b345a7f8c8903af78934fc23f4068605dd4d8251c90fbecd87f99c6c87d05f4a3253971356d911e8953c293274150865806c0108d319e305d78d5c8999caa86976e2243deb39b991a561012efdfc565e43a431abfa05b4986e7d66c93e5faa8a4691d29e279cc7d66c03c50f7de07d379765fde58f11769dd67cb7a5540a24fbbe9b9de9757b3b7953bb69fb7ad603ed12905582e41a5540a7f5139b1678b5a7873a5256e4f110fc779f3d5bc3c41c46f745e0457ff11f03189dfccd2ed4db54f7cbc5f74e4e6a0903cee7bcbf98985ca54fec9ee47d7e3aacbe08933d4598f0dc60688708e52a099146eda6b1af6a20a16aace9e7b735a959132a3242319dcb421c775fafa45b23bf903c980867d9d7b69cabfa5f6853bbbbb9a43e426a821daae0e23b0cd4a0c87ad07c15db8911b16b658929a95b23fff3afc156e4db796c5dcecd773fe535c7f52e161b2751289c57da1107faf0dcf1fbe866195c7bfb704aa85d81cc4b0af8ec9fa24dbc289333b3ab42ee4a0db2331e5c514b2fe43f5e6ada77a5839881e068e09defa4682d8bd606653f2b5cea0068a6975bd1a1354ec9b04cdb3876ee67da6d02278fb949c036b8a480693a06a91aabbd3e9d35293e79307d99fff93775c7f3b05482b97f27e817e768a3428d730db0328073514c2f68f4e1a247ff2d8a5db8fc5dcba2f8d5a5179b3857d668c2cd4611c0ca125e15a0884949c036233fdda762b596fab9cf00bcf879f96d2f27939cf3e2baf3d32cb31cd60cec54ad48c2812f49147c0bfad47c850a94c7ff1172af42c5a0107c27ec0b540a09655e705db457bf2860014008b169a94883684c917665ef31709caf558c35830e51b80b0d8182e0ca267a5a14a2d5bb727e37e67f36a899cf6cb70198af9164f39be664b26bdaeec7a392d63dd6f7dcf0afacc7132169feeae8b097146fd524dcb0515d03cf8a9b0adb589380b38df68a0e0ec2cb235a6f52bab0d9dca559dd969ec731af3c9dc60cc960e8c80a625cfe1b7f4a9302bf485d560e6aa39a566ce1be4853432914f147224bfc924e3df78b49e8331783e85b1d66b4ee89ddb1376fbe307bf3aff295dea0afa5ceadd21552518283599553c109b1a7f9cebf7606a8605ff8f81b3c3bb9fca5950f8a763d048842344c645fce9e88eb337f7a99bcf93809256b35b88bf462a2c53f61a092f4b0be20d3edc8175b60e236935555f915cce946b3f117a97fb142ce0b1641af9c5e2335e0f575cbf4c99ce3795130f21e04347cb2449305bf84668da5fd8f7bcf0564a6b79b4c5f7f4b77bc83253edf539a21beb87dcfcb33be7ebb907e9496fe8d2eb94ebc528476b6af3d912dac4af594ad38f445525b1bfb3323b1ea74da52c8ef67cd71ce887ffd22ca2359b2557951ebea9ff26cd2df44d6abdef75965deed2646f4dec707a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
