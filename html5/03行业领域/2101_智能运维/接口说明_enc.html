<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a79cdaa775956180dbcadc4d3c532802f524b2e35162609247e55ec65bf7e8bb5d1ed329b16ea95992516d33dbf1161ff066b27a0100c5e417a6666b0e9ac428f366a3df8b813620feebfeb070bcdb13b5da6298318a7bf895fb2c950d48a95c73027ad3a9e8370456d83ea136da9f276c5b0d0e58be5c593e15728890fab18f036502991b856980fe34a70ec0e8097cad0fd20ff21ecebcc7f81d04b78f87bb2677cf190eb9db59758196b2c42f12d6ff57ee1add4cbf76726f62853465d213e2d8a951d547d5521b53f6632bb3ceb42e856aeecbfc0b0f806305846480ba8c2a13f6532a7d9aeff3b53e6525ad660bbe274d7e0b92c4259292714ec7525a11faa940d7bba02207354f89a99e165ee25a5977851da122f5f9d556ead91a6bd3091cd5b007d5092ad50b632ca5c8dee22525724d79c482cc47346f40bbae79790946bb5b2bacef6912f19fbda37f328e534693176a630ee46910a3f37bd9919599ece1c43d8d1e1af430dbbfde383f104b1f92de29cf3c65449b2533ab51c5d2f697c7f33e36a87817e9e028911270ef8ab8fd6e5991c7d943fac26aa51e230a9d5c2973d36b8d57d9176884c1341aa642640b775ae0d82e2842ee81a08067a2065db883f6d552e2078f6e714f286cb45db4269cc3b7b9d157954b078a11245a19c168dc312d44f36461898c959313c0bc2ce747ca9caaa3b924637a5b4c060a0f898df00e5040ad96563ca329d1cb29eee354fc159eed56800a086f8d40f3b47c6d1ff9f1d53ccef6311745e42c7c4423e28780bc1205f615d7573802f4fbcd09e77a81f0ac0a3ece111394e9079dbd89f542b27e47f2888cf794853a59d4accf5a4c6b17bb9fa5d56cc9662b7bb947c55d8d88585a5f5b71cb12a9809a4e1877dfc5fba71d4135f931b3c743b332536e9d78ad45661cc4062f432b8f509bcea0a7bdbe0e8848ff70a6470b8a0084f15278f2ecc595e07a1945c10afb6481d84da4421d35bd5a97fab228ffa3a3d109b2232488429fa084e4b7284c3bd504d2097d2cb13b57f617f32dd90c88d2d2f0b8400a42df54021e05907423f0f8118b97ec0a3e4282a37f8a2966cee3ede76dd90a17737449186d38af5f3fd142491dfcd8ac094d486a67e73e5f4a7ef6540edca67ca2b3ac50c798e67bba7ec467fe5aed98caf12cd4b15bac5c92d578fed598d464e93549b545361cd709d2be8b83aa274fd23374fbaf3195d579cdac90d3467fa9b1effccae5efc2d40cab6f6f143240e29131d2d0878c39d6908ea4251bd9eecc5908ab10584f6e5759e04ebc0981e4663d36db272904ae637c666e2bd63ec095717a6dc94230fdc01ec58f6b5a8e9d44e70c01a4e5cacc17278f7843b26323c0dd6dfc0ec6e4c8952e718a5dcac84dc35ae1613d3e60cce0a021ff4eb61371add0fd388bc47643d84383ffe235d050d3b78183b7b3841c2bbcc8faf3e781c517770ba16b56238c6344516d29195e83ec1a3df8d592a12b6f2e534505352b4ca7b8daa0ba98a15e505f7876f121bdeb3bd8d2adc8c424821c36d3ae314b773c3800ef5beb0cdd9282ab6682e5d6086b2659d51e02478c1283c2bc026781779020c0c54cedd0ebbefea88ae90c18d595dd1070cbf0808dafdfd5afe9603eda573f4c6103d0fc66e8df36c15338bc45e2372ac719157182934f8dcc372918f97a2af9c94f15be580afa435a90f538533fccceaa6b7e0fb3d77d81a602de52e20c0c9d5079ee3b3253a36d9fa7449071d667335a6a3ab139f37135f0a2980becf5f6c16b628e3ec54f255df06877f093bdd36d602fa911e4576aaf8d7ae695501cf6cecbbbf3de7a1dd48936189e5ae30c847f472367ad57262f027a59cee2218e892aa893419b671feed2ee02d9b90a9c13425388fb328bcff8ab0041ede0bc3b8db1748f22d642ffee68416a63b8ae07830ac5ce0b7bb61be36d39019fc76effb1a65bd4e43a14b331102f88ff135b11b79eda266e49002df86cb44a94aa48ea2bbfef65d758029dfcc30f83f609d249ff2c5c40ba4f947bb92b29f4c6352cff567a194430ab29c2acafd52c6bd922306d70241e76fcffb1ed409ae93cece522a877e50706582ba452def8d2393c697b0ae9c40f19b58daaa662489d7517bd13a9c6f9e4315d6cdd47bd3d9e72d842a806c790cc1f1a599cb1fc1ed513575c53cbfce205314cbabd35f40c67368e5c46da190305ed494c47f701b54f45bbab035da14587f95441ce5d8f587b7d47f2326fe98df46cfdd61279ffec9ae48bf3466791478ed40e572c80899cb8955326a819ca0d345fe0f069af1d62550b5f487bd2f5d8e4e3452eebab714f7412df57fd2f22d0707baa73eb0c9caedb699f6960d1541c77697d5cb8bc2393594180e51d1490a66530411a9a7fe5737766e2eb724d38abe780f173ad6faa8f02dc16e041141f06cbacc0d60e6d7c27cf96c26d0f70f779c98a7ca9dc011a5bf8129143ca7efa84cccf46a063dbbca3abfe7c45fe563a67dd20928b882649b19c24886a236047c3d654adb2ba190e48a5fb15663c8db55ae2c6fed361763be580627514845a083916461bb6c7824458f3519753f1a27e662b43bd760d88d956b97b212067bc176b758a2245ab814a253e490edd88c2b960d3c9fe9e1106238c917c323156973c368eb23445ef9655a0847ae656c22e84f7d6cabb7839c32005f4dbefefa3ca083c7446c9629e99a1a5232aefa617a8a1b210fe4a2b765c6816f760d9d539ea2ba152fc748b631e41e18df5fe83dae75e4b269dc91edb2cd3c026277df27c2989b97b7cf1704600432f3fb2bab10e0cbd8d870f7754ee336c69f018839a9d02a3a82ee921a90cf0ff6cd6256eaa4a1708a49d8f8a15055954bfca1ddcae7d1674e0c38bb9ac351c0a6d347786eca4c8f06bb25f97755f824dde9a2aef1840edb895f21d33e57ab0dedb1d0023b9105523954fdd9c1d3772ad05c364e5ec57f805457c8fa20e54c1d29ddfd53847c798cbf4d5e4156da7fb75d6dfb4cf16f3538281fa33360b18784ff52612172e0d604866315d980d65212d8bebec788145c517112d320f15d39ce002d3367096b58547bab6ecd093c1127e156791e32daf4f30979a205e5564fea4c36893405f7596c9be3ecaca9f8cb25967c4d9b27cc3fd9c5621837bad30ad1e7cc68a406e923801af279ae3ce9908eb5bb481fe202e6a88beb909d9310f190dadb151f4e6d9276ccf596e240e554eb6afd06c9dadf32f8be182592abd558c82f20449f51d92bb91b8f5cc7dcb8a8e4d04fa03b12f72c4f38ece6cd55489e8874d7b493a135989af8c9207f59d10979758e2ae937f61030a0dc69d4afd1cfb332b26ae34de066dbbe4da97bc59fd55991a25472febb9ce1f4a0e7fb568a27c4a891f29bfeaf772e5037d9781f2ec11bf6c65f70476e7f417284c612aa9adfcbe17c8d4d8d0937ef8aa76ae41c2ccb3f97ff58beb8a5e5130285fa619516d17ece3e5c98eda044700d97ba828b8c4a74523383fe1d0f2800f18a9299801401e4d3cba083fa3660dfb60cff839f5b46d1515483b307a23549c3d0303da22c636b6dada2d641a07e7ecc5cfdb62b68c7b50553f3697c756a1ba1c79cc8d8b31688b9550e3efad1d2e7f89294cc2df8e4ef3c7d096e6ad37785ff89f07522b3845de064e31579e5da128cfa96059fa7c9f2b37c20c47e929aa04b0c1b7aae1121efe43478bf3c5078a093c5626595e2eed3fb8016366b5bc7f7f5f684368e5396e7b026451fa8e0f96d7b8bcd64c716cfdaa69d2a9bceca5193b5769ddf4f76b31ea112502f6ce0db73f6d8d6d084bd7cd7de56941f6f12837c7d06c8cb142d6d04564f2e64ee3490259fd429eb362867ff3047294ec875be36d80181eeae78b7effc12fa027bc4632d6f23b8b1119fa51c67ffdc8254aafac7c4e953ebb74cdf5d23f6381ac75a5929e12235a9465333796154ff7e17dab2029b6d3610cff4b1a0885e72ae337905865946a1d23aac79f81c21267fc0be31cb556667b298986a1a7a52307aaaa92bf85098d384b7c13ab714d39d7a4b437b6aa572d7333a8b56edae48957a03f774ba2bc422e2e20c196e08f931cdde06498282496f30f6544707a849aceb1f4ab39dbf1c619f977f89bda999485d4b3d5bd53a072a4dbc61073365e07024777facabc56e412680fed77040c7b2114b0cc1139bba4f4babf164c4224c7a1c11c03869187a1bfebbfb6545baaf12ea17d86e794ee39e5b52712732e841e10f4fde46037006339b6018ab7e2fa2f15007259ba54de22f05e94bde249277fe4ae957d8e01b6cf2309ca57d9c5c545aace85f814bd421740470bf94d83b42c3a654065cf0fd0e6a3f8d088522f50257440b6f02ab677762abb65b3d19e19cdf391afdb04abbf8c16ed39eedf68c67c4c519af6713d78323558c5f79d10028202e431b9cb672cf36e45d57c167d1e1b536e786e48b75bfa69283b51cf23504a0194a68f3079e8784633b6675650ba6e9504fe3f598211b8174b7c8bb3ecc19ed6a13a0d14e95fcb1f2fec88feab1304c1919aced348092d6925588e7f9d13c9339145a0e2e8a34214ee1065b9675896002514bfea6fc3566cf55beb60dca73ff26deb0b8fbe67870eaf1c2918fe1ffc0a40f37ae2b7fc0bef3b3385a6cd97706818ab21b5795c9f4325bba66a6aeea926dec978d7370f46537c4c7d747c8466420203d033504f89ee2bcd70961017bc0dd53ceb75d756231a8f8c2e26412ce128ad414e8a92a806a3d39d8eb4f59ebccffb680932d59df738d2fbc176f8696844ab0de5238d6d7d242939644e4a6d1c9618fdc3dbf1e3c185c2bf9d1989ca17d6e1ad9953c2e0a48d0b8c4c5bdae9fbe9a3cfb4234d393220d53e58cc82682ed18287844e397e4f4d0dc0e5ad06ba58cd0d4b5cfe2bbfe3061b168713417663fafad0978801905da27b5d0489614e9d255ced4d27a2dfe68fc5c67389d33cac6c5bfc5ea4deac6a8169534d622740ae4aad583b5d910861a847b5acc4c418d9bb48aa7f7d6255d1ac2f5ab1fec6b224ccc8dfc2de66ad931207fb65791fbae88bbc0f1113ae3029ad5e70e1e9a85d609d0133f9953d56fde49d4b90a87d4480fe0fcec0716a09df028303c2b6395d07ed8e0135b26431026d19faee03949b1c489d2133c6f83c089cbb8f98064e1bf39231fa757161288628635fa02f1f4c1fe695d043fe43b702302524cdcdac245ddbc4f4d488a121a051045ccc62c43b3da2c4ecfb6fa8138dd9fca5daa28a1f928dbf5723ba750887dddcea91982073540913abacdc1a13b4f48544046792c4a05ae3058abff4524212128e1b83f8a6a96bf507c81db5fd553d5d64add61781e89cd6a489ab75083751482a47fe8407867229c65326e2a98e2b27ed98f9f45b41b70324238f82447e8779595d391638886f87ac8aa335ba50c7828467ebd7bd141de67b70a45de25cf4a4e6c3621c8c6ee55d523265ae1c2be9a5b65357354a44a657683ff67d3b03492283705ff84cd08e7626f151177165d76e228b038c19809342e25db45d852bc48c564f5b08ffeea6a6601bbda773728a0c34332d53d853fa9859477d6bbcb86b947ece628e618a07577bb2a25d13a4cfed6dd1094a97d8c77771642c8430e4eab3d431da42304c41cf4a904ef35c886152f38f79062694e8bb2b977cca2d1c6dea384789f4d24f2cd2925fe5603ce3af2f4ad334908f49048f17d8e7d88acf05203a2dbca9cd9f9535c33dd7bbe5e97676d2c22f35587cafd3a866e92cf5a9f2018a3c80403685e810b431b0e98d74e2d1916d84682149709bafe42cc33ed5b315dce2c89ff16d5b1d58d61c54647196f53480c6ff680a0c542aef2b5523a5876d378c1ac002833162605de0fec988d10eac2ea40a8ca69b03f525141c5c84a7f39d56b4264c1b657def926e4994560b5c08ddf81cd1e55b49d5b2369d2880e95cc7faf7d64eb1e120718e46c0b8015df1de8506f220dbeee5b89ee064654099daae83d7fe50fbf1040f150580c5c51b3f957780d1012418fdc4be4eaf7e3cf6004500be3199f8b850783cf1112255d6f54973b284c219b46c87a5a1fe898e67ce9a00529d2cce3a60f2f92efdb335b61effd6fcc40254908998a10c589f0bdeb178685fd27668f4f39af7ea21333669b112b6d4384e4325959422b74f2a06b07c43e57d78beb0658599aaa478df479f25edcca2e574eb84b423b971270ad1530233b946b1b150eec721127d635388275162fe0a685a49dbfae3c2fdeb17f83cc5169775be9a3c1ab1af0f0cd13df2a965c72b7280c8e4d607d39f851aca4bb4e741797ed3f2c6a4489dd8008fdef570a958a183d98ebd816eecc2f5c5f2323f4d9c182220dd2aca655334beb3544221781e822271ea992db93d14e8fcafe762823abf713faf7420f12a0bc7d29e1471f836eabe8a2cd1755e53b1eac9154685fd4fc2f1572f6a5070cc016e51802452037e30f4306e7c7b24a9bbeec1bf8216abdc9cde8198f87168056860f4bbcf5e8653459851f6a808fb022a870cef935d5f044ff390637c68ecbe54ec9f3e5f26b18c348a725e29980c988bcb49f1af30fbddd8f728ba4e338aa18b2d899bb9b89bb65ed43944e3b3fd3f7ff87bf75b3fad8356bcf9aec48cb033b016ecf504d640130b454592775928a931456b577441dd095dbb182c4d4ef97652ce489589070029a4268ca07832b3ce2c188065de7912b8b15c6894598433f6c9d6b60a63c5cb6c22cfd02f26350637d4a056547843907dd31f2ace034deee42c82881a78596e5089f3a4a39fc029a11a1914be3de6da127ed1af7ba44fced78586991d213b32d2db11b51dcf17a2464a904b3dcab21fac146c0f3c465d764d1ab78ecca8bf068cc397f07b6d6b7800c68ec64612f3b05408d3581005fbe4169b2933edaa1f1f2ffc22d1ca25068c181467dc21adabdf1629d639c84cd25a103989865afd3b185e4c577e2d69fd99daa6099c1026eca4529ddee7427f9c944b7d111c2cc967b48323f7139b1f47c5b10f5b09d1b32bfe36f4b48fb03c60238b8b12e64aab9c1fb90c735730de79c2005af61c5f634fba030ac24bc3b33863a241e646e9deeb6f3d464959730d55889af6cdbb2ee50a3fc5f0991c8965dbfb35ce1d4b79b897e09176b6b2440c5a5fcd5d8ed92bee23ce4bd5f8bea19b64b26f8277c96d17a4a5247bd5f430dd758e7370b46f02c63090599da6dcb2f617e05b6ed433deed7425b13dba7a60e5cd6c739f0b9c2e7853c84f9b84d5ba2bd451e3ad7c1a475ca3b2b3740c6d6b8a9a793b0fa7a3772b31cb5dc6090690ba8177666c1a6cdb4e9d28312c308d0d3a81b1aaf4b8261322580026a6125b2e3aae258343fad0538a2f87718ac98ac4c6cdeebed9382ab19c7dd99bae47d1c345a0e48689f9f918ea1b14d2f84a5d19a952263ffd73bfdb4568bbf6b2567b4616df73ed81e05a53a79f03a30053c1c6f5738d505b4a1275fcd25d120542f3895c6e486f83bb95e453516a1ef8c164f337e420b8cacf5493fd6bf1b23c8b10ba12c60559bcc4379f2c5f75412eb913d25e454da3458103559f3f0745fea56dc23bfcd02df99e0036b59ce3b99f0360aab361a6cff2e37cf653445ac64dc50bb0d4f260c4d7bf1eddd32c6a91c91acf24ff1e186bcc9563e36bcc7ce4f22b134dea6cc98d6f53d850b5cebd8e5e58f5163114294c583e5f8b3efe489e9a131c182d4463831ead45d0b7a80136fdb1d353302c369c0e48a1ecf954ada170c17c27f55682f38eaa4f45fbd5b5e32dd929138f714e053f345d22cec1924a227a4611f20492cd758863db18d08b115f8685f0283dad4002d0fd638730607e3305430afcd6ead679ded3062c7bf97afff4a700603d218106912cf19c0e4a9f405b7e4758024452996c610470d5f693bd0a27730ed3b067b17b4a44dd72fe14727d2e4453d201a5bd09f3894b19ec5f30791539b704ae41078f38d9847ae4654a74e54b0a88e31da9640f23d7622c8be3d6f144eeb63570b04268681d9c7aad6ad910a9841802bd17ca582ca4a27a5eb730320e674f49b11bd227268e0c520f119afdc37219d139a8d529ac96c056fc3e48fe12bb290bde1dfb5f5466ee298a84d3c99f48f329bdf8f33340b0fce61a9a2b30c1355d57908ab6a6f56fe4cdfbd01ba4b5687fdeaefc5f99bde04699b5b5e2f67c17293c203def4737209c7b2753e3806c1af844dc383cfdd7eb372e7f54230bd6085d2bafa3d50e04001d8150ca6b250c60d4eeb72429da1e7a23a55359e8f7bcd83709566aa71266848b123a8aef6bf581e9c433121d222616191971fd4087123f417f6c7dde2be6c876dcc5e04284ec52d2797f48ae90c28270956f8b3234b6ac4a799974c2a6c51f2b219cfae90a2f53728cfb786ef1e8b67c36d8bf92eb6391b1cc95ebe76252084bdd61d92661ef4e1f51476cd21d6ab0791b9acc49e62002ad683ddeef67a95350607848aa291f3e8471cbaee5c93463e0c4ff61d4bdf9ccd76ec74ca94ac359c1fc7836b7f7bb60e6d705e58f1bd14c73f9169fd8bcddab18d53a8c6a26dc890bfb8a8f52a6ad877f9de92aa497b6efed81c95cbf77e8cb7bc83f17beb5c404da00d183c24ab33d33c9ed40faf3c985b863ec6dc58e2bb95cfd06a1b4e518a42505bb9f841812c6160ae96cc7ae5e8d28519d89f1060f8c0cc8083a2936c73dce217338b4e8ec41cda17550da8f7caf73dff5e3cd949f4dd35db34e82b65f21addc7b2b0dc7a9b5cec44956519148e074bc0a92664c70b36edf1a21b3e9fa2cca78a0fcf5b94d10c447c63166975b4942bf9b23a88e2ac85b0c0854fb28ef801699ef5ed6137da4a5cba03c1f5ab3759f7f4016d49fd3b0ee7c049812021961deb97931de3413056294d02218119be1608bc9514b6d5b905390e9db09d319d9ba4b32d1e4df89f29b7f39070c05152006420eb86eda0cb55b163f5f96033045b66f8230cbb8446978ae5e560f197850bf3276534a2a861ccd217a249073a1d405afe5251656c2f6ea001af30409320646d7554796cf25d55073d4e228a27298548ce74a7abf079a18a2bf9d70605dc2457bce5bf661352dfa59972bcadf0d5e0f8693efd8ea81cb1936fc7b199fc81d553519d16ea9b0148bb41b9ca6ae3589a09f421071a04f6a3ff91499eb75c98eb7f2ac2356eaf63c95eb275c8a3fc6359e5dd7b7d74099c56e5a185c8f15139fe1ae610c992d23d5b1aed50a0024a6ac1fa00a4552770f24a9ceee5806f215b78590ce2ea262ca43698f692a8e8ae7c420edf92ebf029ef9e73c129493bd67b9717a2788b5214f6a66fad3f7ab67b0f6e0fb38c675530c51c3580231db06c51b99b9af2162ab9543a4fcda2a08fb19c2b4f04e239ceab3416b3ee01fa580f4c834dcef17778b7083498e9c7eb5e9669aa5ba1f61b0d51ce5d7b296e605f2b3eb7e47205cf3b37c3860f8fe1c988d42b46662770344983609aa2310bcdd774ab5279dc4ce40a7f726bad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
