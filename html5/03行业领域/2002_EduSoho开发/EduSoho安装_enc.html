<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd9bd216733f63a39f9f78ab1895469d2cc84bd2403339a816e9453f0ca225b2a3c924de46d7735d6cff6b2e0ef9a68c27702f50133fb72d5e7bd23f9e10a7e1ff08de8cde8b4ae3446c353214ce704ad89fc5d4aa61b902de504336c6dac874df2257ed2be5a51dc4e547ecaba7e77f2f22fab47e78807f548d4ace1e4d791e058134a93cc0ff9e5fb2f1b2dedc91d28895a82af7fe15410af4a5c173b3841eb250150991e982432d89dd2aeb3a0503fa826f76397fbf15c05aff21f3ede3d5530a931abd1e3c9a5d152c4e28a78b6d3ebf2f6c78840b612b6537fcb215162c1e5ace73cf1f651de24e0e72d6df5a8eaf74b5a4688d2b28b8a4649b203f333e0f66a469733a749978650eb91c5eab9f9acfecf9e926e44cb8a4c7bdc2f53eb08a3f136edd3aa523450a8a35ff1dcaf47971f1dd5da7bcc12ca6880142dac3143b049b3075ce91796880108e94088a1fb5801797c98b54291dfef8f64b6281b792b1085633933d2eeb926238e87f7d363c5452c9e3962fdefc60d5599c9f410321777e41167ebcf86ce4cac1b1496baff803f84095b72921de3b072d8e0a8fcb5a456bd83b9f9b963c06558c3047ef54af7c67d8c8be6aeb88fe6838e83dcea6f5238605fa38b8150a9e5b03cff126161b46a16bf5b0d8ec416533fdc037c1d8e8bc1654ab115fd277d40bf42162e0e75c6162d2ed2175ca2f94fd1664fded3849a5c84424155bf4c4ec38bdc1598f6c778b66a6d0be1e0ff91e95530ff8530519903f736c09e0b9b9e1116d5459e97052f61e27b569af3a39cd090234f04ba90a8b1e8d4b531479e1db86104ca4176ec3c3ee63a1e24cf12868ecc6bee9ca3f3efea1a0cc45183d109e944f198bce7f3f9b470a6a9c9bc823867ca3b098d90f43684dcfb68d721ec67ef0b1359c432ba55fade38fecbc2de4987a3b1f6d780d0592a24a5a76c2028289ef06c3032a5032de20e7584912a2748b01127d579f7e0c2dceeb7ec5d1c7938a7e6892c21d717250204f33a08b311e0ff768a1621b834bc5871f57dd2977b5692cbdc3a6b1a2637c1614664429e487c3f5aa4596c7f19435beba9565813c9f8fd0cf9c19d302e4215675b8a767d78eb3ea22e495c2ba707002be0639a18e7396b2f048ae61b8b4ecb523d0cecd033091cc1341a4215ecb45167ee2a96ee12da87e65a7190709f4ff3ccc101b47eb89b957536e25adf5574ffc4cc4de2bce4da108aa0b0656852243eff1ca75699d248817642e739843c6aa1be2811beea46a54a40d89e49a865bccc30a90fcb4a64b6d48ed13c23eb65d6250bd446700df937711fa4e3dab0dd862f483be3f46cebb11935fd8d8a92bb19cd2e16f0b3e813801aa1ed3acbd963858b619f522bfddda3bd801d64cec9512a65343c397b5ecb5b193a23027e8a777bb666c196d1c68b9d0ce3a3a6bfce26b93316d36860ba3aca541767967dfbde92c582add5ff1ccc7adab28f6cdce3b91c790b970a42d5f06cd4b3a07a3ad220c392a55c39209e94f80183680153089fb107e0494e057bd948917f99d3d92f972658c4f1ed67c62e3bfc74bad4194b5a81ca5a27ea695bcbdee0f21ebab85d4223feefb9887bf9ab3b6cbadd16253b77cd9f705e2fad112cfc3763f893b9856541434755b36573dd5e7e3e2b05ccdd039d3181227878488e3a984ff493670fc840a96b5765d4a45d23270373edcadf5ff1854f7f10a56af6f2d72a9d227c383f1f508d7e02312cb43c3d8a854ab89fb5af8db1588726eff0b468e333d401726bde1ed402539bfd264058d948c8823ada945b5b2b87179a6af8d99e86cbafcd105b8906f8189d11d1ebede2578813974577f72ccfa2501e6e0bc3b25ad41dd92c54645c1c6832947021580203a77a3000c365e8b476c7e865ae9636f8345ec2de6281c5467e97c2e5b446fe30db7c3ac5f65e32a37d3ed3fef737c2af70cb5e6c490b11cad73a69e1f479bbd0fe51d419a64587ec9b14a84dce26e8dad9c46c3586b2cb6a71f2a8c5967ce2d4a4297f6da0f184b92248ebaece62efd6f9d41d555336d69cef6f055533434ce40a60cf630695a32805418f5a5d31aeeb7d457c266069402681e7e580cc06e6e4f39ae47cda10a87c3402d3ccb3d4b6ecbce1225f4bd545d9f7410b4399ab008d7497d2329b08a94bc37b2b54ce1e92e0f1aa3a5a6d2d66e66bed749253ec2eb5f6ea6754504f98145918fb701d434638129dd48f9fd082f798f9a130f0e4401f3c417388dd2bacc63e148849dd68d57cc4af94605dcabeec23342f14ef5cccc50b94c81eae22e8277a6f400578c5d843646b77d9bf617be64184604500578815a0ae4219f714e46d7b51b89bfc66568741cefcd133a93e8b7805e6eb04376a1525eef65a4e6853cd7468dd941b450f2d4f0e2aa684331493d76ca172f3d6573d4e01d2725dccd6dc8b82c79b872687f6a93b8870ae3c625e9d187ec5161e8852198cb8bb3a8e854de14bf4ea93f3bda7c411e5860c017c4c544991a4464dc84f00f3c9baf5474a231be8817f70a6cfb28339c8d326254cf5ed5c520f711d0fea969e216d38a0a7715b3aa412a41ccaa63e47c6a09c8475359067d255ece0ce8556033a75a42a2c9e61da2336ba75ea66c02a51ce19bdb09947354826bea17a2cf9b3c6fe128a23b5a7ce5b62ad513b2597b3a518bdf47a33cf3e83b30082ca86043d874cabf8609be8d8e778ef857a5ab8f6643ebc23bec953a6edae76b0e3527d85f0ce03505c16541c211c6532a8b889fc662e34f4d76712f5ecc7f07224e083c96f8c0f3a9aa8a86792b2455f2385a8f6bc5252080ef996ffc680d092ae222e6ea041297c11fae9e2c0a4fbf7a968147ac184ad19f2232e483b2e7d4c96e8f3843f6e8ba1b1d1536d9047d45eb331529cdf6a7718fed0ebd82ed3a241094435e1b9831086a2ea3cdb9283a1514f9452db8841c76317b9f5eb0c633db1a134d1b4bfe1e4b978e25410b1bfed5bfbb6c54a6cbf3f08c3367647e1374987c73af967f99c96e2046aeaf38f46b25f3137103a7d7aaa616172237d13821acdba7e8ec3e7ee8bd4523689a46d3a4bc39da7ad81574a1dddd226605607b4bb204f67046d330a3453f13abde96623f601881549d63cdd47db1e9d210f36b995726108a98f6fab342c2af514e52e05e70d595288397ab1d20a5bfc56c0d994cdf588539ce8599c419222e0c1034f102b6e4235d3796bc60ffe15a2abdd62275a6b10879e91643268e4a4298ecf3501a16948c6ad4fd93db678c97966e59061174bc7cb30ad8ab86dae934a074f171db5eafc78535fcef4eb04f5c4bc0f44f66fdd8caad270587f8fe128e389e20d3c8dafd5d997e2fcb62fe77cb8fb7406bb93589da6a055a750102725da4f724c825eaeb25c93ac2ea88a2147af742042fd3709f957dfd7692cf93309b706dc69186e581b9ec7458ac110e42e8bed5cd12f42c7d8579a5e65a6c8d1383ade914171ce6c77364f5635ddcc0f86d895789a69efc36d71efac6ab99ee7baf0ef779e5074ab22a3a227e4b3f3fa1a88786ac463b123954d832d21d3ab609e980dc6def2ec4907eed0fc84e55745cdbb28ca30bd9db96f0276aff770f9d0a6d69464da3dc91e5f2bbdbfb73a642761098eaef7dfd3496f2104d2970ec3523abad8f6ea5233e3a89a1a0b8ef5d93b0158cc1ce94b72faa4554346ff12f16a7fd3af29b5af1151c8c328f520cf07739eb0f5ea9b7ced3644bc19fc29260c0679ae549fa9efcf1eff2c448d5cc4eb52b2960d92a63ff1c4b4e9f0212f88866898d9f277bd4fb9da0dc31e79f9b64fb271075aeb1e8647fb77e42d3a8d6a50df5a0b9c54f9fc305c2cdf5b924ae362d218e4ab696551e78a72a5e5754fa59bb4fe78474ecfc6d793e8a27a476b97a0b06d3d0d91a7a84b2787ac410c6aa5b78c303eac1422268f34a5753f7479d08e5989d14d4826273e7c7a06ac7e88bb19af599f691c5264ce41dfc721c5e27c8346a14eab3b7a98a8196d93acd456093d5f2df4f8b47f2a52c9783464b2d2189ea80c1cce253fe99102cbc8e69f4c200c8a183fcdd865952f80cc72af09057998d8771496162394abb15ba5b7bd4cce2c11e445215427347f3c3835b3bf79a581c1c591bc2549b1958b29ec3d54352d72d2c0b53f7af8ceac2f8026fa7df661fefb4d1360f1d72d58b2fcb7b7e4d7207820e3a487ba47768362538efd15d3b88665ba99e9c4ee6f51ead8b2532b196d02cde4c39b02efaff69dc7a2db0e2fcb24525bd6c7a4505cc1b828d162acb90a61cbd90a7e014baf63e46c1c6d465d8e068d0807d622feab247152955774d7040757185116641badec5d68d2e33848aec89d4cff7717bc1cd94a427535271ef7e52c7e8fb908b782c25a0f3423dc5234423a17622ce3636b3e05d98571b5bbf7992880dcb1fe7b1cfe70138a0ef5ff4daf7d6fb6982b8eb09f707dbdaaaafdc39840749d9109f223adfb687f3949584f4d24727d4f5f0ec457da6f81172e54baa562f35be54d6a1206cdc56cee8a1d453c6c1a590abb4eb553e8a425a1e1800a4a6109d252aa84bd737b9ebbe5f0bdcd567b31e9ece61b26ced7d1039ca8efac9e6c379cb7e039dcbbf7887cfd7891c485f95f8ed7ceaa2e9a5d0a8e589b1930b748c81d22c88c2ddfa42c5188f664ded1393c02863e9f574d3c339c3e6fc7b1e73fb3d37b8bf05451b498a7820aa42b8ae87aab414caaa9e4cf0ec39e0a38eaeed91f84662da6878ec3ea8b3c320a16982cdfcd9f1d6dab22792dbfebf92a81e7d2cbaf541f55f0bef66f41346fe9c5f00b26203cb475943e3d1c2251cd3d1b65b5dae194cf21a05fe4ecb5ccb72231b5e066e8d3f0f724ce0968739aef7ed5efba764dbe1e1a9b1f562c805538bf9163d65e05fd8fe283369bafe4da54851ebccb2dc780256584353134db0f8f28516cecd7b3b6f87507b349e7460776b31c24abdc6a321af5429be47a371f20868d4e8b3ada6c964103d617a4268a48aedbd4d2122924289c24b2af2ed94eed947fe411245b1a833030edba57b3dcbf9b665466a56b2e5f3ad6bac512500adb8dee12d59c2c5729cd0775871641a27823c60c4ffb4b5f6e0c7d7b07d5eb2bc31dfa50883624773c11c3e4ad9397e6f323487d3b60529b2cf4af1dbb73149ab4969919083d56be4756667144febce9932967e4ca51b89ff5a27a0017c32bf86b090c57a476902b9a8e01a3f268406814254ae475b55acbc1701e3f9ffe2c683d9415c530feb278d9c6bd4c8e55b7335b09cb232558a5bb94c62bab06e158e1452d25f8e0b8b4c8bccffdf1689e52945221a4d3b820f91126ee650cf9d2c3545a001810fafe72fe9be876ea0652b73174584458800f7e211f2e45fd698ea408a14a1d2704fccfadafa94601e52363e27b1f7618dd1218f9e1ae878d49483169bc76c38988f0b93be6bb683c2bda300c7e9f93fe3288d0d9fc6be62b7902438ab36900119c0d72c75ae6292800a2378df629e0691299af8732a5369caffd33d559db4d7f23e3156ad74a6f0f39f5ae4d46a783875b2ed26c2092b9a7868820b03811ba542fc3f60a984b054fa9aefc31c53eec52cca944a0d94b5b23f6d52b50a0e6e8c1d595ba555888f2d4352b7b9c66aca7548b046700218924c5ea0d091c87b93ea657ae210b02e7db3d2b852d2e3f14c84aa7424072872aaed456ca9accd670a168791fddfc77db18e4b163beb41c4093b36bc1018ff8918adbfce79f8ee90c5a8caf6bebe804b1cf4e404999c45884876248d2e041e345d48ea74188a02cc5b65a2c9791157f7de68e05506cc9974dcae29a4e15543165e8eba523dd0e7b40bb9abd0e340c4656360c873255f9f5940e45aaba1608b1f90f057a78b6f66446a6ac8035abdf6b5e84e1f220dca38af7e3008333894cf8057b9b9082766a6345eb77f6d145f60fdfc358b864d1180b157fbdb50392ce90f6645a8c0048e8db27a0d91851a01e61e7474069a746b737ec7d7f578cc76b634907b1f4c9666de0d5af1847406d59dd433a018823a4d7ca1f8534e2811aac955dee482f935d8b6c39fcf7b93e11660ab0bfa3da779615ea2ae66f87220a56e465b73ba669f824e51350c35b5a753773024a13ffad74ea4030100515658b5d13413a881b12971dfa23ba8e76436bb3461efcc8a4d07a506ccb2c560dc1cf85174b8ae3275e9d0ef07ee97d9bba5b7850b1106ed9e231cfdd0bcd276cf569ee84c74d47c70e4073b8c446004f63a00525e7f92d80566248572e0c0b4547a46b00300dd6c3d5a30e9ed8dda2048dd3423864b34805b51dca1abde205de7415c9a55492cd5c2343be03e8796bed51e33e26bf019ccdcdf22a3b3b03a3863b3820ce418ff623764ff2463b0cb6ac4d53d7ef8725e91f60e45b0d3b0246a3d95efecb39551457ba9ee1fdaf479851016405c180c565efaa7ea1a0502c4a7be332e16bbb8de7da81f9ca90c5d9d89341b76142b538853dc31f888f1865d23699e4d768b2423a3fd7ba448a1c9a6d0f3f676085cf8e4dfe140e13411b9daf678964c4023df164394b9540752f92b2359dc19b10049fec0be81a64f7757a545026930a5ef963cdfd3a6db90032baae0bfd43f73925c5742d2c6bb472812a89f18a1df43390f46db240db0acb4d8b694d400b7dd20f7c9c21751ade862dacafd1cc8fad87c64e31c2a30fb79c5612b51b3f18c7d3db009c46bc0b1b4fae2a4b87d3005e7788ae4185b041d6bb6d2fb8b365fb9ae529e8dc95a93fb5b82f6cce37547fe53e4dc2f6342ce5d2915a999daf2e28a2da505e9b3a72ead28ca6f49ac6ce2bb795cb47ead23eec0f930c4433cb56722f20cd7980628563851ad70802311986eb0497b15c4e25de27ad40bbe6547e903a499c2d7ee2a41639f2c868ee4705fe02d15f9331b19e0e431aec7344f2cbd37a66b32ca7460110cc82c32d60fd049caf2de9aaef86a6797e6c40568cb661817f62695a6197bd7dad9d5a574c553e1589f395740eaf59a2ec72331687f8f5a4537839516b9f93b8c851c334fcea0a6e0eba93e473c4369e7bf70ca1a3643ed288a7607f3894d966a835951eb3532584a3da21de768251babcf13e6fd2471bd039051ffdad0c0315238f19dc2680a96f78240dc41ae2b0c66efa1f0225fe651a339aafb15e102cdb92d26b009699866b57a9ee35a5c4e30ef187878d4fdc026cc3a2a1b55bdcad1141130b1534c7f4bbe7911cd42d33e43a0b3eaadc4ffdb28a20b60cebf7510ba581ca76a84aafdac2a0bc14750698a938b534b4212f31290cdadae2ccc1366dbf88aa5c36dda1cf4844b4146b9c6572fb51e0e7e1ee9bab26f9e5b38cbcc672354fbb66f20d5d627e1c67f138d8fac567c273c8f6be125617f15713733c038004f7e3332ed01d4548feb351f0716d1681f456af7aa79754d5575294a05b44f237ed083c56745eb6bc394035fd71d4cf66043b6c74414044821192b8a545a6c56d6ced377f480c4f9f0400d851e4e19c7afe10adc99f6d6cb845b2272df34528a07b056b3825a686745bd8bbb889a92ef4b6703b36a96c1d5b876af824b40b189c46163a836c596c6a24050d381146fb349f6cb0423429510ebfbe02e58ffbddf73e86bca3fbe4b8a0ff0c7b26536b6f2d1d24cbbd30ccac9a02b0de8fc6ec721c83ee004dcf0acac81471d83249b2c268e23deeba72b2b25d22bc9ce1d2dc2b7e4d5b5338f11fa75e8aa70d93d40ea1f1ec346b24b1dacb242acc28abb97bb6c6568accc34eb33318e258bb2fbdc4bba740e1467b5b6a23f905a854eb2ef2433db0f3478823f60b9eb8103c8d013a88dacc15a01294f57f5b0aff2d9d06ee7baa0a4963515b2b3953dd8a9969761b5109e14934c527fe0871679e4c90437d0ed0908cbac4a6f9d34ff91364338dde61f3eea7e5a59a4d619e016abefcc75bcabc19bf594118a2a800897c0f59c2b738e153e9817d500879d427205f545c45a3bb2f9c841c3a926a49da5b4a4eb23965ec21b98b1f37fd8abfbbbbb3210ecdbe51533c6b0899c87d90e151383112d6fcadcb5c9ab319512c4da8836ac58479569e4df679528ee68d4df3594d292a40e00427b771c364506bc5e9a61fae6d7456806292f9e280e519571b44d1353bcb6018168ce1714d1a84a88c3a21357cee64a8a81dd27a2ccaf561f1661a3a2e11950a52b8ca410388ed185673c148786b0375d7c054128e7fd685d01f76df7954ddef31e7fd8e94ce04723cbd079203c15c67569525b5d9512ea85cc65b0e8871d2b338f6dcf016206afa82256974986f726d4323a8b0d2b4a6ae99310c6ca97c050fd30d8e33d186477186ea97b16b0eddea8201c2ea8601a05075fc52f47fe7f9e259597b9901b9e4f1233b58cba22de3f77058d80b36ece2dac53c9ec42c66dab614bbb71011e13326b8d86c99d57df09201eeda16e069d34b10ff00e46bd47ab607f3726b328022b6b38e5f9f63cf49507805089ff1d1ad22995dff022882a925c74d663c68a0142ee8af0e6ef1d95426ad22426810c09887ddbe64bbafebc4651b79c11b74c4c228235a5249de11d7087cff7d634b23408dc3bb3560eeb0565d3b3a1470d9133380cd7b6b60afab9b6f09d0d60435f59c941e8601dea62b813ad577e3225eafb4b25b14bcdccdcf4a2703ad0af1daf5b8bf4c276fba713d0ba3f17a275711a51b7b7c68f8e5d22cba365264a4378eb9b785c512cd41acaa1f482432716f1c28935c62002315c0e5ebf961abbac7770ba528052634879353d8f74aebae20b842080c3f154a255b3c33195a8c2eb5a865fc80b048ff0783b1d497af6b345630e5041c9cbd2b4a989c8de5f55baaabf9ad07f924998d23844a7a51ee35df878453878795b433d92354239bf3a4ca71863071ba4144ab380a931fc0eb68089c7af830307cbcb02104ee499ba9815c35faea48fb7355e2e37418f5d89b36c96139838586d3a2c248aa89f5030f1c617ed50664a97f7aecd0004f848b82863509daa162c9d93a3924e00d8ed96a314155fe717c20fa5d83e4ef21569a31859602a7f55a8929ab71cc48e8b247d931346b89e8252fb4c09a1b740ba24e94accda44bf30196d47463d646df1f13baf15612dbd60b2bb739fd0727d6c726eddbb14ec47b45dcf75655d7011324706f48bfc698ca860b85cf790df4f3631109e1dd77c828de6186c4a6de936121ce5d42f19646927d0b14e9276cb23fadbe5584a3205b6a70a85cdaa4492b33ad0a89530b06a00d730683b32bbaef3f6c8b8d4300d8fe0b5437cb3dd83af3083b1622eb33c41114f785ac21ab78165e799b97eb72da7b42c4b1475fe2c74eb1a9ccf7c756ddb0fa52f97b7ef4c7261707a10f4de24da5dd884adbf8358430207435b63c1cd6d9d4d1df4db5dee6d4e9a3827d448556900150b4b86439e090cb5cf1c78644298a7d207389c18599ca6b45b55f02ba019f3b2dc77313bee04c44d488b5da9d38965b5646493450a17735ac630f15a5b351e668345adab39475b1bc5b1494103f3e61f558eb9dbc06d1aba1ea7f9749e5eaca139ad22bf7b7eb0cbbe6d81bc8ab005b53b5a4a450a86d3a098fc078efde53c9011167d3ffd8140d66e920f4aea0f1f991e3a011a99c6048ae27330765b40b232786d12056cedf29ce0012c7edee33886d4561f7d9e7115fe46ac23d567fa975960aa3e902b0038f3d2ceacdd2170cf6d243b9c6f83be6e1fd1cbfff75a77f750ee60d2afdd10ac371a1aa5a5479835a5b74fa984ab9836a7af6ba4ecbc17773163ec4763b5baeb27bafed369c6bd0fba71875e7b45b9d37a7c362a7945ee610a8fd289a8ccba1165491843d8e05660999ed085b76830b7e27908f28c579daafde91621d70d38fc070c73ba63da72934168aae5441611215ec45b01dc07d4bcee555008b9f99037f735f3a53ba9d043c613548b866629ae6bb58784456b3402d15d393f0a4cd22881f4779c95e211eb393d2ca90948572a5468e1a2665cc4f3926f5c67f8a92ba0d8d2c4689ddc9b5106a16b8602eeb59c5a68c5ec14862ab5b3275842aebd97a45eff394c26757e8619421d32a2e5c14e9e1581e75caf8078c4a0305b95ad24ecad63dead4483c488eccdcaa4f70909ca91b647546744a64801f78a00d0e3b644aa2bb41daa3e2e31cab121f2cb95185ec2cf06fb71660e76468a8672618f92ccce9e1a55c92f481571bb6ba40a30a9a96ca741375e3707668fcd5de3ec0b5d24954d9bb346a6a16abe9bed7df25642037152e69c843439bbc6a2db7d0eacb5cb6294bc44c64717926df69bd26f06ca212dd8451788fce5de3bfa78334744b840f4a8ed71995955758fade91491734567698cb64c3d13934d1e0affa64753e4caa9681687866692c23b517db688baf5608c3b7a606ef42cd29688b0ef46a91bffb51b535811149aed303177d1ac17f911854d30727a256cf3dded05d2bf9f4719a88a1628deade56d6df21632319bc19d1c2d045f56646aa0f243a9086c2ac65ce71f5317b181c5bb6544b51efc6345fd525aba20e5b19bc4b7a1225e771621c0281353ff350da63fd92c28d9a46644bed54a24b9d80344bbd6b30f06e2a2c0deb88fde5e34bd97598bedf95e13b7138e2f4eb9886c58d33e3a59f8077cff5410826c331c15ca0f931e315add332905864b8750f554eedcff840f54f440494f01f027173cda1376dea3fc7ef37305179c8d46804df21c5d40c8aa780b5503080464eb2eebf1d3f87abe6197f84a89b81a3018b21fca6092bd67df90f7476095fccedf008a78ead60db838f5a57e5260de0eed52e7c8362ada11b2a560102ef7c42ee78bb3a0ebab5847f68a21c005d684887fec16891f449610d405fbfbf575894db744e6c42cb23262a164a4741ca37afe44f5bafead244cd778ee920d2ef3a5b3c42c5b481d65f7345f10d1ed5f38356b5e2b0979ebdeed623e35e03551186fd82b18c4797f8179a3e1aa9587f069f1d91a2b2e08d5e01f6e1e4aee0baf987cbe114ce9975759528a2502ad2b2203bd5b7a056f3e33e9c5945a0a55dd994170bdedfa4c3c168a5d99c7f8813f29ef0f03093e253a36aabaa010fc3f355f375f03b62115da1401e82b094239ed3e07913d44b21149eeada4b6ce016d7c333ece1050fa28270c8c76924972adc57c7434903e4ad524c48c8e484c2fb7c7f36bf38b007f1db230025de3d9fec84837cc7871350199978d1af5cff3cca04b803a4a7640d06a1729a16e2ddbd6fa619cf743d7e81b441658e84c88bf167faacaf85541b99baeccfc04689f7a1bbe7163a7c52b4d3b2844d6209fb45fa7c5a97bfd39904c0f3ec5cdb6eff0d42e69a66b9b761847ad076b3e8d6d6dd6c046af85de16948d3a3c35bbdf58a9c95cce29a7bfe576517fef163438ef79be4997bfef92e26ca449bf5e4d14b6b2beb8a67cb12fc15c03c8d6cb55b6debc696ecc31b0fd5253a216ef0c5a2ba2e399c88720552ed571920111167fb923cc36ebed36fcfd640c88cea6182afea24a7ab975bdbe6b95221cc52d406e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
