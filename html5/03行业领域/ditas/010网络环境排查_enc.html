<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3860d1a5ad3db0c3352b28aedd749a9fe486f36f935ccefe5bfaf657da1300d4db7bce2636a4c365a172df35f3f2e22dbef0939d4aa1eefab5a31a5d37ff30c1fbafa0309bd656f222448f413667eb61067b847246d73b0bb3beee1593d5c85ea8c51a68fd23d2f922175e7356e358467d7b1d9dc03d5d59cdb1150e6ed87418322670b4a8c6dd97b8f9fbe6a4fb7ed4b54673f9fcd2e72e4be20a5e9c6aaf6d59d6146c27b792b1f2fa60589de182b9ffe414458b973e8fe12f01c0d81fe8b27153c4b24c97a649f91c6fa6d89a3041b679e6e283283e93fe0d3d2a747632a806f8aea610585d2cda568738763518cfb2dc47d407781e6cca1d8191b6110321e381d764da25cd48206cad458cccf24fd9e254f1fc865b2c4e1afcf4f3c7370e6c7f6efc9041195eb7192ef497c61fec16e5ececb265bc6ffa02bce629d05d99a954604733476efc053f4387c1c9606045f6d6d4f62e58732d090993845f818056609a8b64547721957372c0a96b2e543ddab31c094df63e04d62eb71c5ce3f877c3b47dddcc98631a5df2a68dcba3fbb63708384da4b8029aab19150c542d09bbf21cecb0866af4b79436a5f3c15ae7235b8bafd61a7ba2a13d0a2b9dfd599864f3ba0faace72d6881694d875415c919c0a3e72165dbaf414de8559b52421f6d904c9a269c6bd1fd70fa3765916dd55c910625932a5bfdf4794124c5efed62a34a27f0dd97013783a08023ca253779f5473ea0a9c607bd3aef854270b44789a8bca4ace3e5e40fa70606c29fcdc44350e6106d8cc502f19bcbe588cc921529727964625c88ffb0c83751c9c5a95a7b8eb112c0147a63d232c81fa2b4d64fd7b76a36681af265de70d84755e26d03e13357ab04412279c71d75e4b51301a1ae9afee9213ee6ece12c6011ddacbd26df8f698529e7e6905449f9e3e833e0e468324942834ce6665657e403b6972b2ffda6d4ddff48e8b971ef6146acc7fd7260370a3eb68eed5a878d483fb8617722701ca6a7ab1c63a5635437f822c53e23a807515a042cef0063e201a58a28ae6a98d0993cb043e3fe4de7e7b13701d4f9b84687968e21f21c36459f9927ca7471e83523a77e26cb256f7c6883092b50bb353f048fc43520a52af33b455c96a3bb4d5680ec6819c7357118642aadd5611041d7929cc07fdca67106da86c8e04560ace99fe7663cfeeeda9b18ba3353d76d86e6e4d8e510152457846d1a94b9ac2e3f8330f9987b5651e19ce969018b21eb66830de481818e77c5a11d5a888cb7ab31fb5458e3c8b4f089136e7c18cfbb67bdd2fcfb0afa3fe46a256a9af0f816b62f9e17e345d0df01b8eda149e0949c26a40927a2a0dc33413723438c0efc10b27ebedc0cea49fbc0bb9c318e2234cdf4b0222741acf9b5b67433a34b8797f42fd0f245d5cf277b004bdbd045e142a4f45d93fcaa9d30a2b509bde5e35004cef4c26afad49f8065be38efa83668c18f1720206545e535393caafd225c324d3f91208de2fabc35a49f7bbb463afd35bc03da5f4a5b5bbbc65522aaffe103e35f31a7e56454a27b084e10d11c2963c94839d56af7bab26774ca5ce7123a2ed8277bfbd3c1c8b8b637bf269788f6b90203c6ae7bebdf076a1d18a7d78b270c04075d0a9536cef4c6f14ddea27c5a4aa2bf6d16a14600c08719cc2e2f73888e3bfa7a852cf02388a0265adcc1a119be57be5f37bb3564bd02881faae77968df3f5a2e2b07f1bf514a5f41683052aa5dc0eccae10070048ea19ed61b153c6ab73c25e4d3a3875237285c45b43864622c02340c4ab120fc8353d6b538f84ba172e9d6be5b99f17d7dbeca4285b5cb0cc4fb855ee09bcec508767b81cd84205d1a2d1fcca3b899c4679993a036a4e88f21f00de28dcc033962f40d13d910db7980d6c44a3167fc6d78cc555443364d9b73f3423dcc51a44cd5f6954da6894472d594fe5ede458395fec21c1a4195411637ee5907a24fa7159b5ffa9a58d5f4bb251ea04b7ca66a230f6f70efa49cab0a09239550bd8850de84bc7706c0acca7f235d344aaa6e6b9c879c1ac6224524f8e3cf717417bb608fd26f27ffc9bc5bfbfe555abae90d832e2c067a07a27eaaa16f954a4f4b8ec65b6914cdc3650f18e55cbe73b7a499ca1bda5660cefe23f00bf0644a2c073d47dbe1c02c7d5f59a09660186c9cb0458dccfbf38609b95fa9bd8b2a5dd8da97c930480c4eb9a2d978e3f1866fcddb3b7da49d4904c2f1146415053b596cc6ae3e6f6d6c3e4aa1dca13bb3b63379fcddb624625bd45ef0a5ba4139e5c9003166636531bd498ebe05372ef4a8eed43feef7de9cc0b770879d15f39d2f54e7162f7c103096a2d9e886e06006c654fda6e532541f996d67c688bd0d17adeb7a2f913a6276f2acc9ccefcd5de00806536beec8d44a3b4cfcdcf9da19bc04a76af223cb408b681b03c6540e80ab84bd0b2c159c0bb5e564d1067c3fdb3400ddd34cca41d31141434bf68e78a78df4cce98b34e959daa4df1f8c5a69c2787be562347ba1698c604d593337a24cc73f85b530c6f21c7538d1c63edf805f349f1c0277c095eb6a3ac2624a20b5581ce837ed14ad408723c8d405eaccbc3392f1b9644717e93fc033c6484f68e13ba35c69c4fc3ffa0e964046ce0db70478d98af92ee0691f7807814d547cbfebab44a2ae981375551265b3a3f76945b58702bed1b0cd02f00c13c6ea1880508b13eadaf634a77bcc934dc2f695e2ae21c3971d8392e5335488a38348e6478edea6eec5121723221e5d654514ae8b630d63b435fa93e0065be01507d9343e2b45f52e60c23159e02caf27b9027b77eabe657ad0ff638dce02e542225048b3debee308521017281b3358ec04d18c1f12da1be2cf82dfa91ee0652d83cfc8c4ad52567f9c2e006ce55ae8caa449c6779f207ba3c5b494527128eebb648f0b33c2f8030051945c436d99af3921afbc7fc9488d50482d3f6f040f373a2f97ce117ce246a98b6b8f7655f8da04d7e49350ebdc7223ecba49a23b5577e066aa597556ef0a4b984277461d9c2944bbf2b0c489be55b0937ce604d021bb9d15ac3d2c0e50b8b1be2c1279716ba53996113b27679966ac364526b30aa7f6ab825bde4bd89c4ee180a3ed76935a8ecd70df0b6e2bccd6a35c636b6be026bd78e4ef2db9fb7e07a934580745925383ac10ed00b65679ea736af385cd69a49e5efbe37488cc855e0c8e0f64b09f71a117d9ec8cd4555ec05f91ae63c9432a05623079576a25dd5a9c22c14bc6f8c49f8a6b0474f702198c099bb377b75b6376da2c51218d18779b1833b2417add5c962adb91c456603fbbca5b52ba54e8dfbbe5dde648fd425df393412baabf69bc17311fbca5a35595a72f0250573b7c9fadb0dc14ae95ec797fbabce4697701f83b631326c8e6bb27025d5f722e43e957b9478ad87d549a417b930b610e612e8a28a025413935528f33ec2e45ab4b64c981e8986abacf6db22191e5601168a7f5857bc5a8b686608cc9002260823e28aa3407a5a1daf3534a81b15311827f1a2a50dc369649f4f62bcc0be27f772b18cab8db6e0313ca83db0aa6f7533bd3a0a243abdf57254f8ba3e460480c354e3586c2d31799093452d5f991e8aa057af34fc251ae6e8ef017d0e33ac901ea2e5abf6413fe33ac376dd22a64b06a972dc11d2c15f74347996bceaad898c1d5540d8a42f489154eddc9b20d25d361aa67439a00b4823510e83bc53984829644c93bc70a137b708d801482eeeb4fab776b01a808a3e8af3f221823047bf782cb8765499ce1d26285e8cfebe1780e32b657b1457f4619cb2990ed128743e8becd29b16ffb21463f5175cf51ba2c2a33955403ac9f54349c27cb06bbb8e3907de29abcabee3f2e44f2022d1217ff4798d4eb6d1912f9b9e95248219b45db03a4d943a16f4a3474ecd0d6a680a5afa8ec50fdd7e7f8c94714e78c016f3ddf79d3e9fec211da5880bd5a8c3b46bd922348b1d6f6f8b752011ab2f483cb56b6bba6277f904d0ba8a012758544a85898899d8d60a8dff94dac5bdbf5056c5e857ff200e0489b3651dc97030554a8190f30b6ff414c81ae2cd2b6c16af46abdf31e58f4419c2dd19058fd14511b0011709eb9e2049b10f72082acd7fbe7d375bba2a5cd1f1301aa2563c8fb7307f23f9c65c67ff734a51c22a50cc89e6790281dbe23784f98bbc638861f6e35f3086424e0e73ae8da885b5211ca78abc2d1b66acbf140a1a9595c3e1374c27f86296b3f09d9ae7893a1ca53f7fddd0235e6402b8e47901b086d46d642ceedfb5965ef80c05a8fca4897d685f1246c25255b56444c5fee948ea9fa52c22d252e3d8c3a19fe6013aa422b231e2da34de39ce3617741c83ac5fefc64e01d99ce2ed27f6b577c3fc62509d493ec21faed1be048e17a4bc9e5b2b8a16a9ea6e177582375d023804a28c098067794c29e13383fe04fa29bb9f93f36be7f687a3c5e49e4d06be323e65986d12f9902236e627174fd16bb9208fc7b236a8650299e6a2ba0a450f7e6be20081cfee56e6170d934599b7e5cdd96240dca007958b26891360ae22321ecf63493c12f311b5d271f134a701cb7bf0923631b9c27cbab5cbcb34cbc5a955a25f95fab3c25c97ad8c7a1df2c09bfe0850b8883e0d43f785529beb037809ecc9f55d68b46faeabdf446cd7ba73737bcef6e2790d9c2c1f3567b04512df8d59b3e4d3f448b877888b89f15cfbe46033229b392c157e33c6fe3e61af6a76b3d28b63798ff41bcbea9800690f040fe5ec73de370851b14b4048e6cd014125e895680af583668c260f8ef452d17958ef29a6c31da5baeb25ce632dfae707d2232e12f87da602c58f036c5c134cd79e482cc97fbe9a3de2fdb3a8f4ebba98a2f6710f3a8303893a1f340802d12cfdbc4b99101a2ebf27c867cd0cc7eaa3db4385fd12f9a3c58a3fab431abb4fce8f4fcf8481d92a2cefd8e3af6b19cb18f8cc0fcd488a684dfbce086d32e1cae347e42b5894b57bb63c84375d5d971670a0a6b226ba1c2a80acb0820728a0043007a88f92f8b64c0c8bc529c3e824de01c64319f2b602b67b3f227b6c4da4726156f35b5835563f28af886043df3d4ad527a994544816ef739bc2e52a22393df5e01f1924b7b72ab5c1b8da10f18c65122fd223ae2f3009e410728e12dd61e358bbdb105367414638ccd0b79350389bfb55e76b877ef7842af52733c3da7906c5a42982966a5f5cf2392a12e4dd52fa5494477a1af5d89cfd05a223da64115c36a9958de8fd3df010d4f312ef990fcc6d6c755c4634e260ad3a4be9309a3a9f2ecdbc083f426dd6eb6da690574c96f30a94834c6908f3f64dfd9250f9f4979833667b48d9d697edb83d8321eede9884aee2f27cac896fb12b3506f0ff312c0435c965e9dc7552e79c64f4600c9e0d7e2e031dea5492bea3269c09a8b66e49cc871d7796924dfd09a8958191a92c787504f3577eb3c44941b37e8b8dff9abc46d55f04b8de0c4a13541a396fd6cbc4c3937614dd36f9c5df9388ac31b62b27ab283616ba0bcc0948c8fe8be366f98eb5792c4cdcefc6d608a6b4c6d60dc52b97dcff4a54c742794969e5e15a23a386c2081ef03d5bc9a4cc2e7eac89181046a1a3e82cb310b3873c13e3c7659f63e839ec13dd69118216034c506c8219346f6640a3ec21e2288bab0c0a7ce57facdc7b54319f6be895a4044e42ac3e3e89cd919e47a38a73710eb7080c19101146e9c9059009876b39444e30c917556affd3e67ea2fd72ebd6327a5f4b9236274fe5ba0e327a2dc9d622a58d6febb07aa72b2a40b0099a831b318970a11613e2891bdc707729ad2d37dedc6eb06e763745f27b62dc7e60d8952d62509f39c8504e7b067a27adaceb0599497f2ffcfddfa64fe52c1af969f6b6ec97a6c547c584863d341aab942625778e9d521bda5eea821636342eec96fc5eb1a8db07dba6be647216d5696865a33a826da1fb489b816e199239b2cd499b88646b50eb739a63543a9e04b54fcb96bfd7fa9e35cabf7bbeedc3bbd88b8346cb431acc8a6684c79f259dd08055600a53535faa8c5eeddae4bca049f2f0c9d24e39b31d901ee3e8a6076b796777b282637d10caca17a55cd7e210c1ac90bd67b453ee4d110ec89d6b92c6727a57874e3f171cee5dc0e5b4112b85013da5f10d97aa62bdb14c027fd82e1730fd4522e7ef2e674315b116065c2aad735b32ec9591b04473b88b7e9b9a2b7613d2b3706e9fd6418bc1fff9b4d89743d7218046fd0dfd9be5ef14b38222a11fac29d10cf70588157761cd714353b1744c7f918fd0ec4e177d6147a53b4e1534880af9ca6247f5844711e930004123ab09f751126e77c066b0d81b16f7ebd84b903f6553336f136682206102677659235a2632c78963e15de5aaed415305da219949d5e62a954848ea057162c911eb609034d9615c2e2b21421668d33c956ecadd78f810cfde2900e4e476ae61b7761fe62058560eb3170b7c3a482d0c5f32c2ae867da15c114d1706df8b81d0eb0e0bc63ee7ca1d591ed306ca06d719099a0a8560359dc23fe4a8246806698e42161066cf68faa2b395ec760e3c16209f2236ecc5f6457725943a809441a2b39f1b31defab2b5b7cd7f335ecddec99564dfe721c74516d2ae0bbfc6877d7e70438e8a8ff8effda483e79b2b7fc30a2caa488e0ccf575ed5cb0507683cfd89ccab91b0d51a08996da15834f22188509ebd71ac8c60c1d70583d1a0f999fd2ec7841c4dfb13216daa404d11aacc3eca3a39c1d2685a7de6b0521d513a3dc8aaf93b83c070b027438118c15eb93c46e39ca7516d5247dbbb4a452bbef67defd27551fa737ff64aa76dbb04b59bbeb30d3d1f0c8b0c15d81860d205b333bd81a0bce3147b0655c526ef245716c3965b2ffb4a9f1fdb71992b7e6b9ea0ae55063e641b07f8daba92f3927b15eae45ab41004212ec854144af51bb123f78099fdb265924ee03994e363dac901a170134fc8e613c5f4716e57e71cb41f7b3396f9416d83dc13241020b2835312bb596071192325a7f9846d0fbe1ff08efe31394e0faf5e95639264560b1e259f716cdd642faf2bb754c70414d4525a35d9d681aac23cf6424bf0801772594cdf79785d1fe03121f01ef0dcbfa5d93cd9fc3d66ac5d5fbcca16c3f79f3d30852e0c5281aeb7872d1db222d544e21f99972f924f9a283f5e06ff57cdc523a497b48ec8953f9f6707e12f0dea8d781a64802257561fe2fe9d3101cdc2565b63a2033c72a537da7d5af106ae60f321a1379cc4ed952f157af21d916e20399105e55f99718f6c206a85c2f309d58464ac3dcf708aba57c41904712bbed6d3441dc6ff0f44ef302bc5a2a377d61f116fe85d782758ece6ebf0001eab8b072ce4002d8105677ba6bee86cea83f5d84d25f5852341e79f47aae06eaedf9e8e996873876fa52ac087a7d2bec0a192ffd56b0c69ad775408a9439980b0411f8c109568fc08967c7a3a9c2a07a3278ab54a8fdacce397beb33f0407091f605744bd1e77704205794a760cf0cb90ef2fcacc4ddea5872e55e53bccea3ea040a363e405f173ed5ba74044c24788f19548669f3449f5adef18fced27abf52739cab4d963a40015730ed051e3099e83c247f6a413a4ed3378b4e4780283e2cbcaf52b398de882d96361aae1a01e6c123033be584cde580ca6f705b8c84be9597063d5a336cc4acd1b6817783d22824b96c2565488404efa2b4836dd037312416bbffdd3c9f6bf2a7caf854bac1babc7b524e3d828032da582991a86f76febbea043f62c25be385cdabbc5f16555a3f2a3b4451e768346248149e5a3cd68aac997a757b9cf3c0139dd7a6e9b323e86c7f523ad5507ad35485b8583d7a02b571359898ce0e92fa6ace830fc9db5d1da7855ca432ed5f4974da884dfa43d49cb9a3aa5b2dcff8d8c5aa497d9dbdcc26f95a741f6ca5900b1763d1512b4babdbec9b4030287352fb6541902ffb5a7ecd3aac2233db1dbbbd3c22799380d6557b3add5aac2113a8673c542924cbcc1147ece5138c812c8e6149c50a2531dde8cd8e031e40c7746816695e5bee7b61fb81082c0cac82f3c92ac25eeea0aa6d96c0fd961933fc042d6cccb0bad84182d92b604ef02cff3efaedfaf9189f6adaf0b4388eb928dff22eb6bb13868a4f49f2068c91b9cb0c884bf4af21fea37baad203976158cca3d50736d3511c367a9b49f090accdb7a405adc2cb2a16bc4217267417fb0f9fdb69595455bbf900d072765a46a440d5d1cb0e04e94220c8473df772715d641fbabd19192f5db54b5373a5d729697b94483810c2096ee0f75e66717154ef85d157088e901f59e46316bc99dd8516b0f5ec3604c8643b15e4912e94954693f1de32911afd111f39a7011efeb95435a60776038ec9014793c09c940054db5c1ef98f3c0e8c3a0790bf6e4a481bb695851fec6199d4356ee27fa12b5865fb316999a8ba36393b4c2ba16ca2c8a697c7ed045a31adfdde0d8be67a787a53692b79490ab2cbee7cba5a0bced75177737a57c83197ec5f561354a98ebb67e714f7100acbc3d591d735f8a9fec3d09a8621b33f8c5598da9a95cce579e59c3dd1688490f73cee37cf30f49e671de06caeb7dad6759717d55028a5b0f78d0ed70704fcf741a330d2c21c0049b9d469802a0086a8295ddcdbf5b865b685e6d50f90aed93053da251678ea39a9a2ec0a4794548cd8bf26ab6d130416741fa151b117382b70a1b189770cef74496e25f0c116c1bdc0a258bc9fd7c797d046761dfd9ac9e223f871f495a6c4af832b5ff53ad71b065e3ccb4b7f14ef7f7e999e835f6c6809f28c0bb40450e1fa88eeae4f5391a343a98cf99a046116c3d82019b92e35202d63969be94adb60c9330a68e2543e946267ca6501031009113e398a99c005f6d66f7e2e008fc4658543c1ccf1e54501ad2c17f08f068bfac12c5ee796370cb40eb8ebd03e2b9a11217b754dbae969df44bebf4cb798e2b2cae444f894f7411d39614ffc3d87820b2ac40af039295759752a95479abea643d3f5e0605b2cbacb952dcee5ae7538c779b3cca76461a2382c36116296bcbf6033f7875b9c4c092d8726534a0fd7bd376bfcdcaa91a3367f1cbe12d48fd8c65f3b377cf91563bc6d03f164db315a86225af20174b220489ad166052b2cbd55f756ddf954c79d928e5b3bcd99bc7c4c6460f37097ef9fae739f5283afe0e5014acdcf393da72332132d9ded57ad2cbba528f565c93397d9cc8f6d3e9a8634b7bf28a027dfd87c144eb1f80dfbd9fc744738218230cb0f25c88290beb4c2e011bac64289194c8511417216c6f4f10ec50fc05d89b36e98f138b550fa3abcb5c20fc700d5d0b65bcd9fd36c2f3fdb1f2a7cdddd6be37408223604c9eebbc0e1e7a4800c8c1796384cca7babb8ed22b5dec9f1f48263e2f2368c3461847a1b259c0a46c09a8c10db869fdb9669e661a6ab23d8ac13c62184628c8bdd6df782fe9475f38c844a2e2dc90af2617659a15e157f2a1ea449bfb8d9d0fcf5c5a18ec658d61f9adfaaec7b71055f616e1d4cbbd395b4a712974d9a61d0d1871d19d10ef24f973256f53809160c3940a033e37f6eaa3798c9cdde7bc1297e084d58457a16c05cd925ef8d6e0213ecb612f6c106755b1e30dd098561abda18525d79513761d79783ed8c63e88be619022f4913b1989724a8c9f88bc6bb8d38150120c769cb28a03f533e0b9f09f5047ccf30235ffc79b56f4d28b96c91c2f04eaa5e23d9845593cc42c794e4d95b38a19fa1bdee64cbf9cd2c217ad847bf16f176427dde0ed934e20457ab3a5a723f952dc0d9cb835c918aadf2420f011c5325ab20deb72a7c6e3eaed2ee5e35e91f7966ed86f101fd838d17445d66b4659cc6f8a01787933be2c668b0150b3fd4f0cd5e0f59e1cfaaf9371f2c6d82a8e5cf64526ecbad8a0daaead8c7b89e05183aa65cdd7451f0e7abda56b18181516fb4d3e3aac6d75d8abc962ec6f82adfbd0aeed93a5644b3a171065860c8b2d970482558e44c787eef174ea5a98c3223a2b83ce04276d91a23f2025b73fd7d9fe1cf63e05b670e8629c84ed74fb557d279dec56e03b7450ee956a87e8884428a178552b3a8981d8ef9d0e6e36ca8fb7c8e0998ff042e13dd8e9ee6148352cc4061e43de89b08291950325ed072ae84d88dc92685c2dfb52f09733b9b847abf79f58f4660691d80a9ef22e47d5f5ab97a629502f396838b79bb6436e9a1ad9ef2ed7609e998fd619e67e7be1382d106ee3b0c64ed709aaf912d90c0c335f09db20c03724eea4c76bf0da2e7fbe683efea246520ffc12fa897d3664d98e9dc42b6833ae4ff223fac7438868148dda5da3991f3e112f0f1ed4a7ae2738a4168cb78556af2d464612c0c3b9432c7a9bdb2d682d5e48559d7779480d696e4fccb6033b12e15e94cc1155e70fc9860a456f39ef464e96150a731b5485d61504cc31244695d47e32a0482de350f7d38f8b59afffb64108e4ff0a98475b9cf5ce347be55ff470654f7ea7d94e23ca6fa6592477b80d1bda069f247373be080389c02b2d920b03455cc9de908f5b80f3809eee2005d4e6b76a0024c85431b4c8934acacfb5fadc2858ac642c53064f1e2fa04c3c3170898f667568ea14afe0582b7f86aeb6bb97681fda147a53f48b98964754a94d18f918a73e57d51887967b873636c28a757167271e198f28f9e60d28929d4fb0d6689ed9bf92b290459bc1a2fc2de02109df67f8ff47ddcf46f31922cce0edb857913cea379f6c2031964c1eb6149f1f2229e6b39b84d3135c34105dcc4887570f711cc3e8784d2ad03fd85c831f0084570f019d2ac60ec99c159d2ff7cc3db61e3f791d5119d0c83b8a490b82d6cc1b1c24cf4999fc706a69e0341657b3cc01cce7509c2626815bf7a4790458d09cbcb72b7ee880148fb8d5db350e497bb0828b75034e4917c1ba985d2fb942256bce83acb745faeaec419d4abb9e599de0ce0a4ab0235ba92750a336e016fb26f2f5e06dec3ab3e7daa3e73c566e15c21955dce7511581e5768c347ede7eda5ce8d8f2fe4a02e54afc61d270f676c621fd31a8ebb23dbbfed8ef1a11460a9bdd3a962c857ad37444fe6da4bbb6db1a7049bad891a714b898e91ffd199942506f2968f30d71234513b303ec6076cac27f803a845716390a9f482e7adfc68f925c173d12c5a0403be45c66610a2b337c1b50002bbf2e4c05e6f0ec772755efbd20ebf31654fa8b4a6c043a19a78bd5ca1ef37002fa02ea5e65c97346c7370aff6411f56899b696c2decd16869bf2a07c0604f13b02ebc9cace71f5766d3e859836a9c634d5b6ef3eb503829928aec0b1d41086529b1116ad17d77970968f7fca1c8554cb25bcc32f1f8c9442c1c4be309b7b4bcf139776c94726c511e0106e76a46bfcda770ec4771b5dcd6d0c1cdbc584c88bea08ea4c8727dcc7fb4d56c5582fc0759404274f52c616b2059d603020ac0536fbfb35ae401218fa22800b89eb436d9f0af384b7d782cc33c0466185c3a2d03b8dc3ce8f280c2eebd2b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
