<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a931ae35b3682967f362560985d7d260a6f1a6a798099b298603eb4f6936ebc5cea1e9abb712e02ff6acf4f9a3560ea84b5cfcd61d1ea71d1706dbfed60d5f67a589a541cabe317bf0208d0856706ce3da3581004ff5ec4e32e1a9f5a7917dc526b278ae4c12d31d14175e8e32c5d959878b961af91c308333845871deb48c4c17e4704f518d0f72ed783776f1c2b8f1be589fd27bbcca0bd700132ff4e5ec417a0fcc8ece9a0eeec69fa75dcfe05e9ae39730b8b1700c41aa429578c38ceace9e9e1692ab869ae0bd23138dd3ca434112db8f298a8887b49517806b266217af709cd642a03e6fc556b60ac91b7ac3ec0fbe0fbe490446104968e80eaad4a7d79a81f602c1fb13f31866314840adb8bf30d5c1162532361ea2439e6b7e222a2ce4ca76b832f0d717490cbf683cee1b347d466337de16784e86e5c80e7efe0b41bf1ba423a386b2073fb3f0da6a63d5fa7cef09d0988884d3423346c8e58f9b688577dc44fee9432d74100139e3420d9ad6adb9b8b8a8b92dec23263cf8583273ba7f5e0f99e67ce171aa862dd34c5f9cd3dd425c765901814ca162fe0a18a18108bd7b8fabe98c33b46862296325cbd0b1ee34fa2cb6183ee0f842e314271ce2da01205503af6a138c1d0f41d0d978a14f3e41706dcd67540c584c51e3a28faacf65f7fa312ade94f56a5ffa95dd2097362b7b8325c910a3fbdb82eb5c5272d3ade36374b6a4e0f43d70d9249e2b13ad45b532c513c9317392df26c139658115f9bbfaf6523fd3310f914ea646e8b8281a80762a229772cc4e401055121aaafad1ee1ce25cd0365ac07f187249ad295349cc08baeda1b01769895db35b22fa30e2cda36c2c3010ee49a43b3a38cf5647bf102805ec334cafbb2a1c2f8d23b6366fbd9a5e10102f5ae8e43883e59c1ca1131e075667c9f7cb586bf96a4160fc2baf17ac2c39e12550892383b51d2ea96a249ecb039ffe99eb892800a6a5fdfb816870d4e993a83f8cd0b2afe699614782434b1574429a6cca0512cb5b231b17aa6abafc8e8d6c07c302d8eb89e1787b1a64c515baf553c78c05887e808947b04b772fab0b251cc4a363dd5d47a9e5184eeae20ca3c22df13b351cc90edeb2048cd31a0edd032db8027301086e240077556688efe850a845a5a927a361ad72c60239c5665b40be8bc29bec8835c067327fa7f32d9234161f518636ad81f1563cce81f3b644560aeb618edfbc8e977c292e35a1370f273739e5f16c889c1834e6dab19d65ab36b10c7a29c511b81b3894f12286425ef85931844b86d25c04e949309b3ecaf6777b7050d88269028031f64bddb1dfd79958645160fa77103cffded100f10b18be7be4fd622d4a65e082e644efcce38f47bc5915d21a24e618f4806bb0d307b96dbd9c418ac7d40cc29253c4127cea922cdcd7781539c74a756ac3fa2c2e45389e641a92ecc570d9e201a2f4a4629996c899cb4fc5e70b58c810ec3180d12affe03bac9f08e5df527862543114e4565945018c85297f12ca498f32b55fafb54de97506c8f746f75fce4d65e378b145e97a6b5d263bb415b4e50a5890e7f8bafd0b7281280fe42631f7c8a7eb9d477190e42d4156046aa184e3830b02cd82da7c7b3b62ade07be25da5abb9a2babfbcb81a18677378f0b97d545bcf0de959551adc275fa6d5594940065be9fa145a491752f9c19d832e9f0dea6b8e8b0e350b568dd1c6b604d781bf6b8bc95b47da9dacc54929e40a1cc6885754ecb7947d7fe8ab390f98252f8108d58762af26c995bab75134767ebfd20780f5678d5dce5ed1abc7e6a83b01de02fc5aeda3cb19089752630a252973af77110189feead8efa97f5c4d3cf35d8f678bb00b1c56749f8777b505e99ebf01e73e3369d594da0202f79729192595960089763c40d23b1e1a0655215257fd78e5317cfcc82080f74cf4c9cd06d36f48216be8baee9eb6a99686ee89af7076719e5df1aaa600301e22bac44ab456658d262b1fc26cfbe2421f2749d73467415f4ffa228c9ac4a4f88b5da0a118ab40a4116d6ee4a8d4a5508c6656d23ef331ae9e7224f41d80ce01c0f335e2b7f1cfe6a5e581a3ee04de3aa822d1c106731daf0d8f49a48cde93f79327d02b3645a8babdacbc75281dcb0f93888916ed9a60c2c234deebfa8d54d287524370df70c9a28d472fe025ed115df1dad6c0a940ec8da8dfd178457484a13a9182f1b2f948429f7b952c6b7590b6b5dac8e433a67e7534cce16264e260a8c36704e08c63c4c61e89ad8404644b6e6df6f60ba06bc17cd310d004e65f7a836367fa01aa7cd067ee5120d1d569bcaafde73f1fcfea436aaa22b33b4e12c4f99fa033df7bd5bc37a3befefb6a097395aed09ad02f8c48fef7fca1f5bd9ba89ae86cc89e776db7e111770b7bc8cfa3e3b11cab4afabf42b143ece7dec644f378b03838c9af987af985b3050e5883812332d2caae397bc978ae31c070f4a082efb01bc9b31739a083063c01dcb71a2c22931ae9e2129b2dd72e8abd6d853a1041bbf630f281a328418384a264aed5b3a2ace784aeb0c51cbe2cb2c942442072966a5583b48eb4f18d3a7959eee8577f8443fa689c1fafacc8e5666f575942ea5dc4dc7655cb15514c21000211c067f2e75180e907bbe750bbc6c9ac1604bf480ff5833088e9c9a93a821128bc35a3823919980c97f8ec0ba43cbb09ca729661be57a4afb94fb7e5fda1e37a6fbfbfe17be2b8871cdd89ea193364fd8ae42a31df8dd39bc49e224f251a08f16460a95144fe4f2c577c183e304babd5f065f5147a7dfcf86952bb2f85bc1a3563da5617234a5c62d2ff7792b295e018d509f33a45b1cc9ea39f691c34be0024a761f1206660afbf4ec4273a10ff97a44c63bcc478f0a00e4fa59d2e9a42dc64b611c9083a142b58381f30ae723b7f502dd3ce8ef69a32eaade4fc0b6e44d3ccb83f8ced76e86dc9ec3c0ed2bedad068abdb3d0d3b773d6dc71541c9614f22541f1a2a9592694b85198570d5f98990859b241f3a4c9f4d7a03bde6906778fdcd9d88b133d1ccc6c061f741597060be94a2859d8ce6beeca3460b0eac63a38c3e457895b9bf258b58d229d99487239284192e678db3e2094554c6bd1e48fe965ff2faee759aabcbcd3f0a9d11df35d211cfba1737d95be9a2512c6159e6b8482f8e231a94f3babb45aa15edabdda6a1d53a8e343e491e0978ed03718da471c2d95316d6132c5bc3a34862dda979942b763997e428a8d8405002d940cc99213e5d541a1d2e666623b9656e707fbdcfd6fc5f5c4191a4398532a74e6b15275d8d326abdfe108c6c91184bfedddb18c9e53aecd0bc64e1a4fad707e40db2244c0bf95f6dfb7ca66965bc00ee83a8507621ed1a784d11e84776c2b8dfabdff12847831e4a4277606b57146abda76e917fc6a4a1bc89d704f90af1c9f1a2a9213bf72de247135bdf35d60d8366fc20bed3e2219dfac51d911cf9d5b3d66e46bdae6872f0769c83c290ac84e3622374092ee313b94b6f3334f6df53b29efb15494af1bcc309526fb281cb963a4661901e1c2100012190b61060a3fce236efd7cdd247313a3893e182391f3435e33b8cbaa7fe2b60f95e16fa5c72ef84d0f86b1d866bd280004a5c0e8951c24c7aae730ed97cfaef6c3189102c736594ca954bd0f5e5e1945c6ca46ff8e27564f52d2741c7ded50d4d93ddc506c56cc43f84b76606d103561900074c21b21e480da723efcd6228ed301b055dca62312a8d576be59685f4a8ceae8b369fa5a9899730d63e23746b0cdd46170ed1bb0bb8425f882cb1da29a596a865fcdf5d14d2c680d99e6c7318d774577a5ca81e0d676356470501a789a66732d80695c8bfea323954a35effce00bf9ea68991648094781821646329e768ddbdbcd59b08a96b3e439893bcc32c22e1abcb108740fa7dbd0d7e72910aefb34395b9eb6f2ec2c0eed3b658fd44a8ca63671e0b34612cc3d47b74069cd5c4108d5274a84b9826f7562b06b50f4d4c9e5a64aaf1f1ea65a4b1a64004133766b909198214dd25858f88008acd79acc0c745c3d490d26077d9d22016538f48795f92ce75b9b1d67cbcdf738e2031b149e7a2d9c4a7631000c2b6a99e35f2c5ab310063203135d42a2fac79250ec836a3d1acda327e906a0cb289926b277f2e17db65bf49e629c0d1b00942964bf4e07d36095369bf57edc9c01c699c63e97af83e8ded725cb4a7dd7cc4de72391719dacb0df1b3e2f7863edebdeb85a13762f288dd8ab4ceb1a58984004abf653b235120d1c49715bd06e8ad6a4e369f893853363e0cda70d3b0d5c411fce06aaef99d0d95481c7eb4b3e210c79dd46d2a8b05878cd34ca7246a15ea5827757079a47346ba2a8a16087203074709f709890608f67ec508f5d2a299fb0003a8535f846e14799a449ca8baaee228f65d293b4d03eb0c7c676b00011c5ac25c49764bc23b8129270a9146af53a66705c754b98709f35462e3923e07ad1be038eb0d662c5f3d5b4c7c5813a4d77848d854b1c46e31c0317bbac8b6db42c049af4bdc15a57678e5fd436e48054ca78e3378f6a8121d6397336a3385aadab50ec768b0740f8dbd4d679b72541fde470fcf6d41538096d7f7460a9183c992dae896ee9193ef4e1c695be451653e600340848948ebec348737920c30fbdbcced1fcb617778f577225216ddb9bcc5cf8f23ddcab050f3c55117d3015eecd8bac55cdc3225de7d61cd5f97f09cc375ad840834e1cf69b76a41d3daf48f26e2d3f5ba0bd56c50880eac5805a8052260fdd5c7ef25d50c3c50cfc88a74615b90c4b16c8a51220f34095f989e353c0143227461f56e80a7549c597f3f2a57249925df4fc15d80ca67e6c3f0fd1b538d6a6600d7acd40db9886368b240f02843baef131dd2cf644d72d419c70138669456850772170580b6b47ee4fb0bf141a3734e6a7e2bd79dddd309e3b2ddabdfd408632acdaf5da77adc276d534243699a8a695a11eb495d2da4c460ea38dfcdc10de611254580a1bc8a78168769bbc775bd591f2f1bae34bba9849413c90e392e0c347f259665bce99c3085073df98b166e1407276911b71d4e8fb8fce82ce0552c9afe425eb75e62a08b85eeecc1747e4a1d3aefc6042bc9508285ea940d2bc8c699b4020ca3df71434495fa73cb21085fd69649ff4583ce2e5a21c4877ae90fd4446faef332249cfb90ae48106685e9b71299e31b9b57615c72c9cd70a0cc033a84c6bfd6e21e64bbcaec0a1715f3d40005e639eeca06a6a007fc4a0cf207ec29914b487e371491e4aa85d4d1838ca07e6012bd0b3effc13dc0ae33c3eee28f229b82e1a5a1370337d1db0b481a8e4a433ae59a733f0407e21e7791efdd60225d684ac7994bba23730028c6b663b99e68ec8b0f3fd639d14a433b6db45a48914d5ab71416970da71b83ef87a3313699708a605c6191b43071773a42e4fc29b0f77463a2414e4e9409875766f4d44141cf1fc578cbee3186eb3eb4a48ff460e4be9db9bbe9c06468ff329990d9314d2f889932d6cc8627715780b81aa0d499ee75e8c622531a04750c76f5a83b218c28a4ea66a4fb3a7b6ed943fce8ccc61ed84a592da15a981179895855e7a25bb321c93345724eb46cc3a14dddf9a55962c675b01c819dc7c2967819d306f5f01e950d5e6fb9a0aed977f71c1e279c34719efc98ebb5ec36c746f9a659df414616ccd7eb3f2fe5e43f205f17d8477775d454eab4c7a540d3b59aad0c4d1ae61e06764b508c2bad28dc0a31977eb0b51f0a7235fd497dded70abb4170c26f15a9ff0801d294ad19a389ae1526326dab40d41c00c73e6066d09d5c70c5f787333cbd82de67dbd2eedc7d2711a6225fd0dc4aac4addb6d121087c16b5733f2026e263c43103de0b938ac8aa4b404e3fa763f2377f72dc1a485629648212318876b4d0944652614cee9fde7da8376e0c4190a58acd3b38b9c7e97347afbbafda606c9c9951bca7d24feb97ff0d7620d15d1cc44415a6892ccaac67e81fe072eade42e823f2354fc78c03cf0d1b5d2c11c008b269cfbbc544c8894763474bc6fbb6c98ece5e8ca4052381e179413bffb0271341188e6c9738bdb458bf94a46af4a5ae7e67b1d894b651228d6921cd9b6f891ec758807f3f07317eb2fec38566fb855a26c38e089b8a61ddd4fd05916ee3576fc2f9ad5844e7784dedcf0347ae899152d55bb2244a61cf69fc9ec974429dcb0dee1c7845c66264f5e16b1d1d46da71525e90dde27e7dd90a48acd533e236294f9b339b276979aa1922ab9d4a90065fe060f46652ff385924d267d1865f79320f2664c48effd5e5b4ca9d41221abf81342018dfa2f2194378c00c262d8d77737fcfadd5d0c76e454836dd94f54c5295b6350bf35c5032deba8e359da98cbea22cc0cca280e1c80fc23c527c3e10244a17cee94f5f0121768fd39d88507b7766cfa183888c0013f652f7c29cf7e9c4530c8f7d10b4e5cc8e96082eb2ad56e3ce0a12062393aa42992dd365441da0c5f359b2e368f20a522d8580dfb733fd64c2f075a2103c531aeec246e5b532041487f69fcc4603df0cd5b5f7796c3d41b8ef4b0f3b46f457e1d86b03059d62bec96890ede5c6ab2a42f6139c66a46bc3568d87e24e7943643781564d75668c12bb0ebe5733563941bcd58b60b0f23faeb55cad35a6be2878ad4edba54481b13facb6ac9983221d7f9ed9439f4fc271b8f56ce4dda1ce7ba6fc1171bd5506ee63e48d410d3469ddc98db8bbae468f0ee8219e5126ca1f3f2ce0c417064901b1b54bc1b91644b5093537cd2219cf71e9fa79eaf04f8e825574753b323d049f69d78241439fb2c3194cf5d2fb0d467feda4372a9fe37bdcd3fe3f77814041b8025bab58bcf01209b055beaca9b3490c56c0e15891670e415140d07c5b65d727653cc6ef4006fa0ca9acdb877218a19e031cd092551b37b31cf7089940d6de84f82ce2df7fc4215577b733e334c9eaa68c7b2aba74fc94cb698a1e5a8d4ab8d555fe22143d3dc12d16781fd8637955e767db510b144af8a55f28f08530c18611e197fba028373bb869d6e9f8c1fb2b075f67221d2a1643061c64f77d1d3695803ee0ff8e6d4a34f61d5ea6a642df99dcee550a39a211928a2901da182c7dd33c83d621df976d90d1c1233c45a86575984646d9e5546c6616fe300de351c01b73359307133ecc03e3857c9d443a3528e6c190277b1fd1ac3fcdddec75e7731fdc78e84b20be37d60002dec615d730c029e2c526dd23aa59ace2c47965881a7a701d7f56e6e6f08c366df40998266743db6acf66843c6f985414dd5d84e26b54cf6d0b40c36b0586a9dbc46d223571dd8d09592f9c286835847fbde53efec9ada16b94b30d72273cb7c48612d37895d43e9f4051c3a16aecbe2948e8a78f8a503461aad57ae55040a2921d583ad0e0f55f10384640cf9c330ee75e3a958d28c4337bafede39a7a132155707f6db54f0cac3dd87a4d1803cd8e7f8ffb20fdf51f4680bb2037489505d778fda3156b05ca3ee7352554e73a9ebbe229195bc77e10dc3f9070bd93ecee72d37fd89bd13e3eccb11fbee1bebb9021c921b9dd770460569d56259f0a6e51ba410c9dd0ad531db4a798971694d7a8202344ee4b3e2cf19ac8dfe8552c297d30329c3f2b7f423925ca23c9ed6425136700e448403c2bb34a42e84f24e729a0feca4d83706578dd66c77ef0da63703ae8e17f53aa97308d88c540a0c115a207d1b934b9f546cf88df62c8e2ca467a04d90de38dc566d6948a2f238f9024a04123c8cc6fe021ba9b9e8d3da371dfbf01f02c7faed2f14cce99c8b8b924dca9947cfadbf1af0357019042a06755f0a4ea0f268d60be841c0c72f58b52d0ef25406cd5c9a0a51dbe36dd2e32ca48407c8455c6cf430ab1ee9613cf03262d6c76359fce9900d10aadc5fd5efd3fb8e65b923e96912c8af9414d010ee25bd29712e4cff3406505a2d95b308cd3f4c849306171bcc41f76cc0c42357b6dcca7078d5df526da1bae4b9d4f29548a1a5e55f4acf04eafc34b6eb58c072c380ab1414e4b1e2385c4e4b6eac99d63ea66968c4f1d0520cb07aef2054c92f36c67ac29123207d5130661168580a5c4491575c860b35aa53ac290b89a44613c819d4259d15ba76c536f94d05be28c77594d57226f5c2afb8d0a2d6d06cf0991fc1ff3be1286dabd8948903099adf3f8ef2e933da327f0f902edc5f8356b8dab1adf18e98e8a1daaa91c7a57c526314818692a13d2c35c30537e52297d733bb376fa4fa91c73be49228d5cbff26173451998b19a499ad3999fbfb5559b77abef206c98b7b85632e1780bbffd73d930fc637da4235afe95810f53a3013455d3d7b50a2851ad45a2a260b34b03412605bbb6df90fb6f4b3978109f1fba30d5f655892b6fb9f8a9ed2840a36ad89d2de12e4ebfa4417114dd79b2a9c44148ee0547a4a42bd058d7aaf399438507514c1c86ad7878f4b04aa9fcb4313441e9de54750b9c3d8193dd253ed03ebecedd379e8a14a65cfe8c081c4887714ce37a2f9bbe836dde3d3b688cbcfb522020fdb878f9047b070ee1fd388c7de5328e221169e55e6a40ddf2b0b1f499ab0be84a8452dda9b1649a70d311ef42070393a08ff6eba2ab3dc8ad170ceda24634343668b1dc24395846b0807b63d434624f566a956005a098b8336d0dfebb6a517482d99c48e4b8db476bc1ada3b625c19d6c0b6a08d032126500f50accfa84b3282b7274b94562571b092bd0d78de0eac599577c057b467ed5da326f31958d4123cce828e48931b6a5eb091b5204f5695fb19e55fb7a4fd9546ee38a1cbe99d1bcbcac203f346b350e3618629d88d0d4415b471d10da3c1acf84701c6d4912bb576e0e724902923b5b2e82338bc94474b145103ad963c95989acfad4f6b32e3084d6aa11707ba41a7501fa8fea8f32db3a4b288603b1f520c97c8245d369696916bb465f06c3e592bc0d8cce69bb9919afc46760e5b2e63268bae2bd25dd0802985c4110468476d7e70af0ac1b8cd86e0ebc5524de36bca7cde09b166e867dacf6cbf00b9b0d85e5badc7c780e40f3f380a5d5b97d67762774845f103f1740dab909f98ec35d6eeee3428be5da341645ed964c80f9548e8d9bacd200e8d3c887c916f0da708f0926a98fab70c5edd58e817a2688020ba8b0283a1aeae21523199c81439f8463a1bc816c5efb00248aa62a37e1f7f1bb34234b004d3cd8b58598a1b96626a117ee1bac028dc13625d7da77a2cf96c638179c9c06bc8fb6cff5d57530caa91793f892f239bc88082d2fbe9ea2c86230bfb0ae2c04a3c71062b5d49c4bdf918b1d8bab0ec8e4c243e05d251ad72685330453d44d2d0209dd661f9e084127aa26df67f4ccb750af6e0a068a8b25840c979c5fc2c0f916ed6c41d0c21976217e8e9d52fdc0ac8aca14e23c9a054a7971fde80a6d8c3be3f0f067153f87c59ab1b36f28220f5b581ead9185a017077e2ea1e96f74d3a419752cc78c34f709387e924aeeb0f544e4f98d3d23cfb8ee0ba4e1fe67515811733169b5e76e6a7fac0bc05c16bd6a4965102367567c5442974134502bf2a0b56c071ad02102f5c4ecb2e29f7979a17ca166553a6a96c23e929e1f30cbd70a4b60fa5652fde5fdd6c7ed49d44e145012ca3a90515fcf6ef0b037b6baa18706a85c085dec6c557cb7fdc3ab4a95b60819a66f1b76c1d96f04ff0194e4809767e53ab939aa3de2c411b203a6576487d57a7a0449e4dfc5a02b02a1b0dcb813e474753818a264cf1206e67ade3414d44aec7161310177913decfe97c4b6e2a228a04708666935083793b9ed74c1974d799c3686531b4d531445df90aaaa6b892c834ef7483236cdba261df91c96b0cab552fcc23068f3e15d2fb13248a77f2c114d91caced7b83b7ffd39fc1a78cf8a53ffc19392215996fb5879c8ca8cd15143fa270f6d8c2b154748026f700b7fe144193121e90dec3fd525e87bfccb370b7a2737b44e6e27ada94b41cddc2511bfc3c7285dc8631d5859c8bbe6cd6da5494ef79fc3410c65457258a1e841e29365e27338348fdc94235ad9be9cda58ce7f60e3c3a9a8930aac257320b7c873347232c753d3ac31c064f869a4f77f999ffdbc7c96887e7b6417cb099852b8f13fbc9377896b9508f467460d6f6d3c097be85f1252b28ae3c1cf237c914ae8cd98868bf58ada23172e10a7decf42912da4b810914d36e336cb7772f34483fbc25f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
