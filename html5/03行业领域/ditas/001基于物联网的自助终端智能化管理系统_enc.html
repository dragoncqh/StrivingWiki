<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08ec087e65c94d6dc473e6d16d48fe7ed272fbbc0ac36537b3094a00ee10f6e5da4c684ef8dc8e6dad5e45637aaf378c8539abb33cabe0580fa03e11f3d465f76e8ac9384f15e0ec562ba7772b462d127b1375fd1ab504359b269f5a61c1cd23648c583a6957a097992ed5c4e7b16e0b60cf435e3aa44ac2850123f5b7c5904b743054a678d854fb802e2f9e52719bd420889ea7afcd60355fb4e5d50f8380ee9bd050df1ed6c9ecf686e167d58ac342034046935bcbbf02250d15db376ac601214813d1edbae898eef54f0bbcb310848a7f4779987421315d327e7b694c0702078954764599e44fe81ae1b4f5f0a3667d0834735cbbe64d3dca144b630a5ea04b6396087dcdd799fc117b118249c61ae02faac8598f1ce6beb2fd3894af4376c604389c7bf9eb2de0ef9c2e459a81f205271b54829c42d8b432e149cba02f937188d1dd22f3b1743252c31467b6fc6f32acaa4fc0655b2b2de48539d5d76efe2e8494c451ef355fa156593e9aca6f9fba1469b74033b8eb1532640b378e8d14d6c9a3428606355119f7078592c5f421feec2b3320c67144c9c9d42bb1ea05b77b25d6db811474e71ef5f114f08d0ed59b9785e6ecbcc088aabdf20b78fb44ef9be0d8fdc7ab3db6f685be42c8c48ee18824fb4a531e9bcfd2d2d41f6eb46af655f8fefef1bb7c5020b9c6330b950126f67cf7252a3e72ec38641c304de18b69a91680ed6fdf477cdc19516cc0c0ff24fbf0692334e520731b1b0b01a293f2e6f55dbcda92a87c7c373d1f3a7a9d8bfdc6537d583a986fc8aaff0fc48b1de619d9679668d4038b4247ec0da2c883c37a322140b8c1a06620bb786ecdae577f7c80e32132ae71ec1e13d538260c7fa6820e6cf9aee7628c0ccbefdc69e9bc53cf2f8dd4bd97b6aa09b07ffa22ee1bd4f83897b6b101aea16c2a3690883d12c2d4c57d561fb344c6da8d7acb84f0681f6e3a1145768e05aa25dbe0c6c0c527c41da59233f1ab86ef75b864eba88eb1dde3bc32bbf0e6deb0c3fce9ab0a3bafe8fb6e3a841eb910e5ab90fe2bfb8165095f81ffcf30aa3e1a9574f76ce97faa71e47354f958d1365269484915d6f973475159e6f05b77f032b1359ab6393336197309b839e7647d3ac96f8cec7607bf80a7e1c478002d19ab05664c13e529b6f20643bdd69eb048a23be083cd1df0183465a8eb2b7d1f5de5f9734cd426cbc9de1c37066b4805e9a7b10b95bef5491c4bff9339d09ee2c7c6b4c55c9cb8b1350fa7c540afc319dbdaff258ba3af0656ccf7f1761ccabefc21723d1a0e176dbdb9973ca29500075a268eafbbcd192bd32158ac31b058e8efacf0fba867ca49172f633406f61a7c4eec49bdec2c82d2eed88eb8df4620afcfee9e15da7dda3d17f977f56ab55383a4b547e7ded71b9795bfc57644a7fdee87c0e170cb1b0c9efa2585597f95eb758ce51daa83fe93a36ba8a143b8619635afce262a7ac779b8bdbc0cd805ea226a1287bfb60821e9beae5b6ac44a8ea4a366ec5463d3a426663d0424105be7419126d4fd82b18e6e9c99f1041ae981ad515b76415dc55ee8e754e026c47508fc14358d4d2b83c228a3d9b81cb1b3d5fdbdbe90d94be36fce6605dbc9494996a2f70ac91540ced0ec06753602bda4ed0c371e3438f87e4d43c08a00f6e7a8b1d03ff891e4fa73f81e1674ea51d07469891c21cbd796d673cc9327abec1417cfddd13045f2b7926d4ff0ab31be900b754ac9f236735799e7c675f44cc5f47c9ad45a1d14079f9e87d7c477ed67dfb49e31b4a5ade532038e73fc801e8bf3e4e5d6cf71f6a5e7466ffa18571b389a67e049b245881c090b1c0d172e3d1ab306f859cf5a7c6c655e1f4a392eef999613cf4157685b931918662d1a608ecc220f52ab1c8bb533147bc347f19c315c8261c4ebe7092e860b551addd9949400e1db4b833b051692d506e1b02a69dbe33518d8ad5829664957e68e8b9df2a9c1db0c6a41ec9979dfad2996987cee0dae8b9d91f22f6665f1d388479af879b25b7161d589e62da8201d291755f645bbebcdbd27d0b1426ea875a11aee7ebe7a08e31641f2761696ed9794f7967d4f01295d7789380d5b598ca1ef058998b20b223a4c23741623d151e3ec7706b657464d66bab5103b2afd7df4a47d993e67c714175f8246e5bbf3dc2213003d88cf89a23bcf4eaed41256324935c58e88d44a0d447364246fce906d8fe3f120ff3759194d7e861bd437e419beffd0e8c7d3ae774c1c791b6e8c687f0cb77226017d7458b035ae77a8e2e6516a04d0f7705bbb0759c1330721eda3ca2db84c5b6f5db7c3122e59e08d4bebf080c424c4f33d592b3912d7ece601a42159d25c2d2c283c3428880c5d65317303067e0db0d7e63dc1dd3c21c3134634201c70c8d36cec74a761ff42909c61cee32e54e3ac550a5e1fe684b354055c24aa285f771b2bf4975278779d05c6e605d807a2357743e349aed890daa3f9dd3d598ccd6e3e61fa5dfe6301f4d450338fea5ced96702658c391f4a5161f0a28c2c96e3de44265e1607f92ea8b56ce2bd99d5716eed3c989f497a2ba3154cc0c60da32883002bc9c67024904096aad1af6c78875c2a8b180bdf34ff4325eccb9c371faa5a7323107328719b6487f654234e9ed472bd89c0a3b2eb3b874b1bd7ff7b9abccec90830f65f7dffdc444ddeadd1c5b17dd877e4f51d34fc5ab91fa39ae580df2529897175f569cc85e77ad123b31d03373e58e5b3157e6a47cc67dbe3b813311dea7c291ce6b4037e6feceb1c9c1a0879500a2349df4523302b87574a28792eda9b5340f78f0f86478d9781c11c937534ce17663867b9b519a8dac5bb5a23cd5a67fce3baee4f5f6453449142034246b29db9056072681f796f9a2228ba4732fb403f7d583a7c9b5084f44b09a7166dc3e7dbaca3580d5e41bf13d9df85cd63e9e9d52510ea1893983c18bccf869b086a2f816d5f3e14fbda35a0bcb9c9dfedeb910fb96a2a11e01ba4133cb29b0490608755fbd4729f84b74cd5f95b5e709bcfc670095c89c64d3c85f5b1aaf1179b90792efda1437cdf69c3c79b79704d05afdb3cfed11793606948b3951d440dab047e1d0a4550c68517aa2bd380392883179c4abe977ad3cbc1134ec224165361fe0537cfa3e7d81d4c7aa0f0cb935f320efb933768915e987e3e37936200f4e5f6db956737fd2cd24ce44b4af05e525ba2840f1a883c8a9c335989956cc35b7dabf9d5564975ec89c34ba081ed42e8d52cf8347866d8de9b50099c8d126c826c6fb7b2e09ba3c62bd83e6cb402580276906c489bd685db86a205c80429544f113117a1ff26027d221288d2f379e54e81bfa3c861fa9c7590648b8ecb86f7085a3dd9831287bfba71f18d08cc7a17d970bcd2b2ba6b9d3f7acbef0b39a9ffc231fedb420eb79b4c6a821c491d46fbed1d85ad000d86e3e53bb313424a85a82bea8fa0b48c0371024aad7439d67e7619574761b9894666fb4260efbe8bd99b4bd59cb5c7e3bcbb9e8d7c6fd363c2bb88dae638bdd7a9dd41d5c5828745eab671f56d612808b133cb919099357f4914c8ba8655f74f01d237c6b81f7cc2b375b387bc15f9909b02877002bbb02a58776edd87216418e15bef19d9c216fc6b443c11fce15a317bb12820728b1b4df8d2379798ab3a89268407771de8dc9eed7803d3781c579e06457b9b1c1da37419637f8e1ec21675a800d082e174c63c327f9ac58a395b47b3b59e6327821de61a6ca8dc01a0b62517aa04f23a3d4d1b20b9f63c29a904f2318d53540631952008e2a18b50b16b8b5e1345bba2a276981744ec41704930c1dd9e841df32023aa62f5b66fd8f0f56f04194b3379520c28fbe7df2df4330e8879d40083017dd2eeef1cb60b3bc2971efa337f0c053a91634347ef5c9f5be9a2b8d3182255ca9abbeece0cc63549ccd371140b0fde5fc8b4d5482ca5842fd149ab27b542e59a71f6b9648a607dc865d0c99243efb1ee8ad994003e54f551d6a6e38dc0a5ab0371b79187a1f38740f235ccab842ed7b1c021521ee1eabb4fb8042db045f593c972579fcfb2f2c7aa0c583acfb4069b7d11b7874638c28a2c304ae60a2d3dcfe625350bc441cd4bd33aac37cd490bb16bfef4ae029ced1f7a1ba7585f3c4d6d2e42dcbb9f9edf019ea675b6e6b36a470a2e1388877f0b59a41ddba1e787eaf923ea7991bac6f5ca5112811ef1b8cfab2c6ae9092d85a2a724c7ac6f440722f2dc1710ace51a84c14d57f3e2ec18b4cca8701ae0f7777816ade5cf9192da33e5247b4eb402ce7011964018f9557ef6bb4378b372106b21be87bdbe7df5f2b44f2723b00e47e5bb3f3c9c4b11330526cb00d430c11398506de90e855e92db670e043121bd58ad5569d217ea0b97f992ea87a6aaaed26419f35c47ac1b47106c77d4022d0dba3865c1bb76ab0fc73ce5781c073c3b96a7fcd448dd07b04adba9195a7b1a516b709d3e189f72b6849c6725b8836fe8343b375ab39e27fd5f9bee5e72a109cb0739b7fb2caf58c6419f34865f7ffd3f55f0279165efb7eec1a6b343e30e2646efcdb0739e5b29113783a885da496fb4a9f7b509c601ac76336ce431dafcb09768b8729c78d5906a5d92ae42798fd074f46de620c7d709686c91a2ba8280a327ec77cda5e8dc30fe4e1057d788986a080c859e2752b1c3e810535dc6f37ef3d65d554edd3fcafccba0f0aaec9f47f5d0c8af612d48ed86cb0227efad040f4484948d60bdd895e375d0419f722810b397af26d73a80df5cacd0d9a39731acafec62f7efe72fe2080d07dc9a1162f6b67b7b5ab03c3659e85cd00609219b5b630830681952ef75c001e0900695539c6db3b775aa9924a5ac061aa0b1979f4dac54ce409eb3b768241b608a4b5b2af48e26ff8ce7e67fa57fbafbe870c64c0e98f58f4c01e6f001a39bcbc3549f44c58ba6310e2dba6d889e3e3b99fed5e4c7c7f7d6ab216e9551ee9b14a91c04c88ae2d9fe4c5b194f0d560ee47c265d6c0509a3018609baec65f140aa2f3bdf991fc98fc8c89f312e6257b3e0f3fadebbcb13f98fc37343181d2393a960655de3bb1988bd99d28c7517e593196535ab7c91b621f8337a66f83bd3b9ea9a569f5a440f6e2ebc76e606cadfbae92a5a805bf07f0033f9bade846e2b73ebe7b615224b262419ecdcfd5898f837be2c6df75c9e453b519c6e32bea4b02f5165de98ff0bbbb435c7270609579defbb60356591a2c96f80ba8f88aa6c7ce78acf03243bc17ac9700da9c1a9c6658cbbbd161ec6ed58630881df4a10bb3e121aa75174d76c3a654974d6047766cfe87ef76c265da75c42db5b10e6ac2ca104bd5f3e4454f7e728863e6824e283facb023e08c3cf6b98588a6234d1be3e4dab958d42b21a90c27347f95edd03a9072d3606acab81819d2ef0fa8fd1e6fd17e33b66870edf43a5d111e6df05a2223ac9048adb83d9762d1339fdb5e5bfb2cb8711aa53cf329b40ebba4f7ab79ccbf95bf5ae66ac71fe89a9b163c553f103a596f864cb210e8e145648e0e0dab3ad03020544d4b0bcee5accff096247b624a382052320973d54ee054d582326b1c409775996d99dbee3cd6384efdd391dbffa16e7ca056cc8bf9f3d1476a0dc6361645e5ec0649cb3f4a4781722623429d6ecc896a24b970ecb681ee2735838e5aa9f45a8a7d5b290835f372b8481613fc5053f34f7e09e45e90ddd1d2166ce6c651e3d8596d4bd88b7dcb1f78b45d88ff8a8013d5358e5922c7a5b06a2d3438e583fee90c1aa697003118901c3ff38dc641c9a11979f2e6862bacda741a5d323a8c86f027ab1626aa97a7c74e164569335460a0734e884501de4a6ac16c7380cca4fbf48cb0cfba6777c4082a3802a8bb453928426001bf0df92dfb53ac4baf38d37d1397931318376e985e11e015939a19d6d281b5a04da27345abf63c5acf35cd9495a64bc49306b8b4acbf88d6b864a1dc5f8b650aa44f2d56d7954683a3d1b90930935d7dd7e433dc69fccfebff24f15ac3333666cd42420af8ffd6fd450fba59628a9ffb2bd00d7f756ae931121f9b8215f04e4f30b0485b3b32662aecae846f247d421f46d18cbcc0514d7a2831af9b66b7cee94638d241e68d105eebd49760e7621058fbd0c48e37ebe9ab024f728d655620093a59cc18332521e796e92cabf803cbf580d2867a46b46e013a1147229d8861016872ca48ebce05a452b415a4249f6cae3917527c3925c9d701d559110e9708173b0058712cf1db65ac26116041d70321828ed16d188169fd0ea4186cba6f9ae1ce5b784971118e6d1472a62e3c886e6482f6771cb9a841d6c6cb5eef6fdf82af7ca87e280607407aabc8865be47e6dec6fead323d3d4263c97675b8ca4094a09cbe2d6efbd32f215542dd6131a41a1504e01fa85d6b080bd4e31ae63564d734ad30773e2afeb5a92a3d5fc8dfa99f83c78649a0897fcd35547e06a0bdf6019e3005fae4a348e24fe646979c6a71dad91ba02ee6d8041d0f1a0a127b0c9b970101a61e6cdba14d3fb64814f5d14f32ecc75a8542b361041a95508161b40ee1ef4c93d6c498527f1369ce6e1aa2c3814207baff2c98640725276623174daf69e9d090b1d94c7f02330f3bb2249cd30fbabe334dbc5a643d395dad6c3846e9a33ba14d87cc1e20b9a89465f2cbc4ea1c52bacc59284e989694757bd316e96473fb6c5ea0b7fcc4bdc40286f30138676d12bed56ff7b2f26ca79347945631be0381fcd8fd4e2e53adbe51c721e87e50f11d5c5f4008d2f291dfb027111df5c23dd2d11505447db343b80a327068cf3bb9d4248ede715c55be5a530efc77b582c599222dd2c9811491e00b32a003807720458eaa9d685d09785c0874bba7f87c0b9c0bdeaf988a597eaf6a47a0433b4da52aadc639e28cf3419322a8b9a4cf29692f3d25f94b02b9a69bf3bc52f3f563375823643ab057b5b84fd36bd3e2ed087f2be258bf1d49f48a530b2bb96aa6420c4acd169dfcf71132b42aef98020c588a5d78c6731cb0cfe9de9644d75f1177b86613259e5568883e4f365d8f35d56573478248a28dccc5c0ac79821b65833a72294ddb84da80caa4d441952c065e04c9a8c4a2d95040374109437d5523af25a05e1ad535223b6a76e763f469b1ec7ec2f150e7abe1180d81698f259e00b4730abd76a8f749befc049dbe45e31accf35857862c6c185b78f006a7d87fb3b5e5eec343e6199f4e7e3bbcfae0d2d59071e9148d8ead0b8ebab61dd3ccb233ce190bbf05d28d6a443844e99acc288a49468907bb8bffd9f26bf952e4d80453d77a8fa38cd8cda3a035acc76e14d6430a89564dce3bf9e85e69b6c26d3340732a57fe97c0c48e3034fdbab4bdb3b657f5abcced9904a23f2252e06f24402c30545262e1a2020045c828ec31d2c08974f3dfc479ea3223e8adfdd3b0d666338f407d58939ff36db97de558fc36dcb4c593b2215300502ca46d3ea3eb5b3762416cce31bda005bd471a547ebfe3310becd4a0afe11095c36e8bd8e3c0fd374a9f031340ca936f9bb13db2e4e7a48bff05cc9b5a313dbf9c98a78390f80ea03577bbce9da26768b2d673dfa66ba43401d7bee2df099afbd09c4a49d8f320465848e410ef4f038e2bfccbf2898d76b320a75497f7c286271ba0f1b147d5643365e4fc1705f63c0c4a2ae4d6b2a8f440304fe2bc2e7de2d92b2abdb5aa0fab2c479bf4412b2f9257c135b370dd5ab70f6ed88a7d6293afc437f23e68afca7f96b5aef5e2f83bc9bc5a34fc0f1265ab0afadb57c6b83bf49b24f9a1239693f0251c41e4280a0c7631bebe5fc5d7ebe4a76e4d14c38b996a8bfb50d12cd86f4aa07ab0a66ac7312d711cb3857562bd74de9fc0c307dc0cfbd6f91ad48be7f1ce1bd9e324f8786c395719f9c4b3e16bb8a8f3bb7619916f5e9866323ccea55f96fee3ce1796b153e1be6dc3d5869dce3a9b0f7ff72e3acf6d78097cf78618fd36369574f7faac0991d564f245077f1b1273a9a6e5b0f88af6199895dd3516e32497fff904c737c0124da67c2266b2e40cb13019d5620b0ca6b33ce5f100635b53655f986aa2948bbb4589ac11c52173a4855b2e4f7357df94f4eaba2ef549a30bf6ac42366fe055db797224f672277a036e5d58872b7f28e8f2a168ba2eb473b77ae2e98c2e5784c009b63e576c7578f1fa552cc27d813e5844ed293ff8beb0b6e3a52b8a6d1e109ff9e2d41196325e7b933b83793c166efa11b65bcb1522328032a3886954625073414debdf3657dded04b33dfb62e4185990c7b0028fed5ce9148608d001d0b6094493d5af51c1012a3cb306c824f74f105cb4d571bb9ff4502afef90a0bc64f0447e79f476cc7ca2b2d73b3f54f8bf58f2c497741a101f3f051c11cba80f6c06066bb0ac42b8e85298eba57ba3ce7883982afdd97428efc54f1b2b14043b7f483a3595167a0d68eb556363055313bf0a85734a2e7707a9476cfa75b1e5bb1565b6edcc04f8b602449efac0476b5994c58bf8d833b18834c418170d443017e8ada2202d8933c740b74e80a6045a2fdb2d23fb4437ca95033316ea8232c43bbf634d25f23dfdc27c9cee666145b075439b43a6da4d4fc942ea5bc5f63a384ffa459801a134cb9fbe0afbfe0cd073ccef4c47953731c1bf425c8a2056ab89b0753e4b09f8631780441dde0a26fd98b26f2023cbe4db29504fff7ab09540c609d5285a6d0b58b4e2c627269e9cbc0528508bbc9871ac8b70f2bb0245a2f82cc7afb1873b5553d6b3578acb7543f13bb7a21b5149645fc26a7703b3be7782d76dd625439d6b2059d837a96950d1c77120b66154293f09b312b7402b613e0b368cf53164fb6c7e04d3ab9826d6c3fabfc673821aa9a1fcb900601442cc0f4c724ce705d7693454f7ad22f70d9b02e82bb955922addd2c32695e4e0717a57a253a4ebb984b86e48156f09a9df47d7d8e4a4849a0ea2cb84cd750943df5467e9850e9eb98e15c2d327dd51a29f16a9a0a8bcecb8559463c0fa1b6be4cddd1c8ce0461d0eb1985257e9f48c15349e7f04fcf0b7fafdfd0137ebcf21194305bb6bc74728c8ed2f1a0603d90b6552abf17fc682f7b80b87031cd4952e1256d9051c9beb0b236150e27d74371b09979c7cd365a31d4501edb236fe0fe487ba9032c6f1f864b54202be57ba83a2917d0df0124dd46a4e1c03cf601ffef6c4d332d8fb75b55f05e24a15e823cd2e7c98c8c78855db04f158155ca36a1bd57417ce618e57468ec5fcb421a0f3d5cfb96f1dbe1066d2fa3c0d4185c3b9413caa646863d375acaff2ecd7651a89b5b110418a09439a7fe575a9c139f40f22d1f9fba568dfdda991b22472790cc58186b39918ae8f8cb1b9f10b37913cbd911b71c85ea8f61df4cb8e7c8c83db41654a92e2071f12577b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
