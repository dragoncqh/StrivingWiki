<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2ae49e54e6e6a6daf24eef94813d57121d560f0ef568cd9b76adea41cde7a1a2b3872374b2f2b02472428b6e500485164750c1d9305807b45a9b50d158c897e2d0e948d1b2b08e242ff7de6cda3a4599cf7b9576b2354761a85d03ac1184a48e5ab3c1f38ecfb106bedfb8aa7b51cbb8b40eac8ee25a63fa68b9bc96fff3d01e851e87431cfb35dd649d9537a647107558aa7b95d85f69bad49e6493412012cc8252255e1cf16189a2cb486781b998dd6fc536dfd0c03ad8a3c76163e1773186bce04334dd3c60be542dd278d076c724ab19cde98de057f98584722b8235e419b4d1eae89ba20ef2728f5beef16e7fe408f1068ea3fbc8e68958f90e2345bdf0e238be695a3336a76172136d84a76ce1544710f27f5bf34f636598fa1620ba11ad29f8fcccf8bfa58645fa83b1da25db77975fd75791df18fc29f8a261db48eddf1e6daa870da47d19f1547993645c4e480ea51a867be9e5006450ec93f8c7d222b24601b387d679ad643c1d509f01e47f16ecf84a1cf91aad19e33638b1d6fa59f16601f5e69a18e44b3ae4ff765c8b750b0d8f460deea27b6f992314e589eae383f88b74161a368cd769d9dda6d6ac5ffe789feeaa05e2c9cec4aa222e3e1ae6d53111dc2434472d0c5778f58e604b4855d03898367399f84a3ab73160dcaffdb16af360b24b84efd985a172b086c5370abab2737379d0564c253ca847597bb44bf44f2ae7a9ffa0a68a8c11ea145e0a64ea4b96831e32971fa0ff5d06f5078c20f20a5a2da57cb0d95ec3cb0e279a9de91a9f08a32f5f20c72127d3ae342e91ffc13ba16e38af543f2d734de1bf86ed5b2b033683af763537da7815d6169b51e39db7dc4b61609b9136637a8caff666706fb34a187d04e361c03ff79904f9a506abe818f089b816a272c8e0bebe18bcc1249faf498c9b72c3113cfc969e0a7557e72a9e0c39d66e465eb57444351dc76559cc996c3c0076bceb69741a446e77322473ff01b2895483ab7cc22fcf9c6e7f482724d53c0c09c503ce572125a8999a47dbedc97b4740a4eb1df78a8d072973d08b1ed5fafcccef4cd25990842dff652b04b0eddddf09b9d665e5b9c9cbf4751e33e1be4294454a2004ee3dd35acb739915dea945107d6b8ec4b8fac7b91a9e961ca6dbd84782115064a9952058fdde8f43b99c9b2ddbe9e6f918e7fda40e0579c4281a968dc997e27738a12fe6734b97ecb75662cb2c990ed6dd5fa2c3113558e778c6f6b2e878b202636840d5a9ba111c7f3a574530e2181b8c9a7b8fb8900000fe278a9f2841a09e07b54acd76ce344ff926782753486d58735960f4132597d42d4a7a66b82a4e46af77a0a60ccc19a097c2a4ad749fd4faba03e5ef0249bd94ab91395dc253c421b1e4c280801fa7a39bf5bbfe5b8f0cf2e8bc2592491e32ff11ceb9e72f4a684d768db4e569cc7d5d05cdf0c6fd98e1fafdd493c0c3094ba2b38edcc408a1afd0f3b4fe6d11263714ae6ee2df5d64abbe451ac7606252c255821beba99a1ca21a1f74fa2b85a73fdbca6bcd2cd2d3acf97991caa87898cc0c17121fbf3bd233c83954eb2e678035aaecc7965da7f2ddeff9a9f11d61f142548b979034919df1dc899e8e31024fdedb623175a0c61f1588d7e2c07d501db1fe2eb6a59388f75d2bf6816ca55d532558b9c3788a22158e22cecd2a5ec43e378bd7bcbe06cdb1e22cc6e1c88332feed88057e822c8dad7b70fd7dc8a723cc3946b655dd9994004e254bb37ead68d7c2b83cbaa795938257d8e153d79eccae6668ecf7cdafa0edbe071da7ebf925e5cb201c26f15f6a4c2031d145716ca5f2d703cdaadc1125a828b163dd9f86e4ab095f65890d6515f5d1a27d6d523293b54b9a3b9e3f65a031c9a05806d4600fd0bf48f440592faad196c61c6c8328a42bdd31b09653716ee24aa2a4f5830baa7aa44a16859cee383cea999ebd19955cb29a8e37817e2837cfb9ae03c67707e420aab3a75c79621a5dec313625d83ef5656b2cd292b6c5e97af4332910a4fda5eb51f90c64976da4924764a38a9193feee2d1b923113841ab04b2b10497ba5015dd824bc7a788deba1be354aef748b7a84d635e55e771ffccd3c1f5edd1dfe7f0e7313a61fd0193be1f9fd175e9aa12ef729dd02f3b6ff35f18d7997bb0af528dcd6e351de767688b4bc23fb88b39cf1b43e2ef5e2695fbf2552e2cac2be8f3c0a6b5c8cb8430412f26b746e1b9441c3a984a5559bf3fa22dbcb9aa8985c94acb25c8ea49cbbfdb3eb537ac1bf3e16519a8c8abc80c516660868d20ab587889d340461876abf54e5792cc2a5272b2052c9bbbfedaf2a4d82243fdeba872d6bf8f227a7cc0971d896bfa9b24394acec0469c9ab0cc8fa3b1dec2fc2bb9f6751c79011010f010657950e31769e6bf61b1a27b6d46a94c01f6fb4ebaaa950618ae4e34427ab54a317eb081c35de905baec51473cf42eb98eb5ac0de6b240de07c69cc7bb4fbb7eb7f375c88284c23904ec7b382a0c12e45e32f4a6c3b729ead6365d15a697856e51b7c790ea09a5c334f6e1dfeac15f3610a5cae2801b223f87f5cea266fba58ccef0bb04e96f644e3fdea71d73377b879e91dfbe3c6d8ccb323a1e572a1aab70182e6404134f0c7300c67bac3c5a756349d2e3f045350089c3be8898096df0df32ba4d567f4851cb1c51dd811d9c814f08a3fa2f9f55aa39f0c16f7ffc5817a8b9ce6570cce29634ed1e4e3850de1858f2b9285446433df3bdba32fd78840d6927f99eb8aa5c4b8cc1bbbe76473f115a4a2629dc5caf06cf23dffb3ddc43b913758b9b1744a0e0100cd47a91800aabd4cf666f083d26d2928f024bbd30417f9b09925e09d7326498d3f85c923fdca92b36f150c4b0011ddfdf1323829a30fd3bbe810eb369039867ae8f717e6adf9d8d1a6967f70832ebfeb8cad8385c5084e303dad5d7971899704d383b3dc7977930ec145e5fe5be9bf1c4d85be504581116f3be381dba8131182c587304e7b7bacdeb29748e721c69ff521807bc7304c2f626b97a4945095c8ae71667f508ed6477e7c3b45aa55df3a1b7dd476d53120e6f43683a9a6e381e320646933f7d5da67fe89e0ded53cad3bd1f100056f2eed1918b40d76f3649dc72ed8db384cdb9f749fe62314bbed43a57b2bd6c3852f05333b9d917b3479f8863d4a16443b36f1fcc378c2c922231a471b2ae2c1e0e34e1889e15b741b9f5991e9f07709dbda2795c1d523ba8d008870f08a183410a945edf536c400b41d1f4fe1e3267e689c53387f789949c68b3f7cf3bb387e24947190a64cb58ba733cb78d5f91f7f41263755465c68d5a3bc2cdedb98ba640ca0f6752e448b49898896f393d4721281376390e7499da13bcba221f569b538abd178f260bdeb9defca5f93e3ee2665082481481c84726d9fce9902bf07d1eef0da78976fd394c0051414e34c3b642d8cbaf9a578f6e450fcc509b707c544093c9ad53ea57fd846a84ee6ef78034f1977f0eebf0f919bb16443b340b5c88acad28df525b2e8c370efd597ddaa43388490603a047d28a2012b61d47a6bba130450074fdc386caef9ef27ee8656c52cf03f3c068d12018c89ac158726f121583b38855d03f094e5d71c5928d9c972639f69b721ef5c079b4894cfe6b49083296a99061170ea193c41242a3d0cd4ff2035225ee6f00c6618cbff3997ce7d92b63c4c8028dbe91f34a048802d50af7850b50af0de400e6866afa700e8e0b455fceda4a8ab0c5f4f414c8809ac9c8f9d327c3d16e0e593cf62b1efb93976bc520c9439793edde937b772b4ea33a6bb9f007f782a3b458b275252b6e16a7ce0fc16948678612177dd8fba34bd2b4ad775da1649729ff22590625f232c196d920661d8b1124431d3d44af828b8b48addc654495c069885242a92a864f3be5480765a980ef3bef827e2300331a7c431dd21d50f954bb71f5656d51ba4a5e9cb4ff235d1137ce38486791992f769e7c71c3df0bafe199879cfaafac28a33252236e9083c81a0a5b0556e9d4afae881a7f6be217bc0d0abc0d4a061454001de5560341a79e91c8304e3c2cb6fb6cd416db92ec5a680a4716b44d44143dce8a56cbeb487a578dae3758bfac83a9bd57dbae066585fea8b7bc6e37c7f727d2134da97b68412470aee6997499aa77d4eca7376797b61f31b217fa8bfe1b188c8fb340b3b8b3167cf96cd0f8c1d27b182e0a59b049577eab29a364318fa5a9ce356eb3f792370e6dad966a891d222aabd494a34fd53384df08e254ffa7531a88ca2698ec72376f630b2b964924ed10a06244512c3115701f1657270e518628758ba4b483d088e3e1161dfd0f0a0a1f776aeff0c9a1b6874442565c9ca1be6907b107ba991ab2e55ebde46b13a114f23dc5a88f73c1830c9bdb38c417bb42af11bd7601d8d212fbd755ff7383a1f309f8309d6b12bc2090f5f6e67d4437ff3e109d98ed39c15a450c3f22979a4ef70348fd53198ca71c94c5760758d5c5e488eb05c28af41174f66ce2e572bd54d13d164215090d766091b7fecd5bd30df60f00bf014784610cf0bc5829ef260f72649c575f0c974addc236b8f665d1e78d335908ac1593ddba309c11ed08a3d5552406973501604d5469994abee0173c48503b2802bb4745e5b39af269eb5af3dc33505710818428ee02e92792b56f9ce949612424d8ff86beec2880447184264c0f4e123ad53afa2554fabc5849615b242b3d9fb2c6a8433b49627a0e84b0664e3c5d72281221e35fa9cb02e1ca95468f4df2d077a34d2033e288e9ceeab907f4af0f9bc99feea2e4359f34d7172ab56e11c1b68f793c67784a41d846e2d3742700422a9c5edce50f47ee047910f6d98faf5c5c44dc3f7eb4426a418c6467b53d1a4c419024b6b07f640301f32afa82a540f9d8cfd9d6c518de1a0b8f7e0ec6f5859469a91edda2cc3dcab2f273c5bac34a61421fe78716e7a0be696a7ac86be5c1353ccc7a88c1d5852112cc5962d660f97de22681a6767b642d359b03c349976b7bee0e38634f944cf3e5dad1096cbae05dd7214fc34238a5b7b9c91ccb8a4041f916b1a2b4c9ae1be84abff6f7627a2ce9e13bc138e94d8f5d9643d68671fb6a59b5c156da8259568c440b4cec1e1bbffc9991ac999fa9d04000ff8df80d5c5bf76708fb3f248543f4f33b30bbb722494786c9f04806ad272653b7d878f9f0e2ccbad93485afe7aba47057697da6021c554f1347ba661b834a0c65c61ed067f2626732525221725820f7af032555ea1e4c8281c753207db70055de11e9aadc1f948d97157d744caa69090ad48a3386111f8ec1dd235cb742873f29d307e09221dce40822157f29acbccaf962163e352fb92a5b1dc3753a9b0fc6c672851fe83fa2465249f6235011ba2acae757d4e63bfe4c8a837947e24bec651a644f93e1a723954b3bb12a50fe3459220cf314736fd5b88eab8d7c33c479ee512fbb3166d6b14da4f99454ee92274513a9a62484cd612e594b848b6466ad1fbd6c97089b8df8654a91a2ca599dd059276ca457f78b5c4f523b18c43e1b1785521d221aadbf31f2a318d66ede5f8a38b207ba6e620b5be2ddfcf618ab85dc9eb9daf5ccf3a9ad1a87df36ddc3f3936748126729551dc4b5073a08df5bcd006fbdf7ae7b5054e1ee2aba37e7a325f50545dd2f08ab3bf6a4b2c2ee586375f4e307c6d5c39fe82bf6f0562da4239f1fc0ff0b9d7ff21e1915eec2c704d0bcaf969b5cc81637ab40ec7a62ece06e34400780a903d40c08600884c507e1f158bb57c4a0b37101c0154572772cbc6842d5b01d49f78625964ad0a1024a4fbff8c71aa7c0c5b34bb48f4b06ec90ea7e83ec426e8333911690905ce4c18e540b06d8fb9f2611fc9de0530524b6ab5ab7c8a75c1c12a796111f52e09128814dbd30cb20048f72c38d53ae43ceb140655705b1550149a0674eb019ba3b4d1f2c3fc076d3bc44c77619378d05234e947db201e2f65fce129a6977eba3fbce3bd2542be9fc305370c8e38227fcc7d7701e3ba2ab53bd673629e90977e30c4ecc33905a2e38d41268eeb73a592b7d089ba464b19a8b8ddb972b08a72a6602b2b05d75e3f545f3c4a4bfa05f16e28cec73924b56d76eb4899a4996c17156de84b4a9fe6c741be5d86040880292e6d10b9060d759d054cb6d58bac0db6c7608c9e9d518617df581b669efee141fd52a9f0e88c70da7ee38ac041be2893e1b7a5fae0512d781547698063b357f21b6031846c5849ecdb6ffd884e1ebd53d2bdc15fb4231a933f77b7627923c99c118649ac7816112d7c5b1f26ee793e0b86b01d06866fe9883c42eae2f9ec2ead2992ccd23e9a5ddb359c89f305640bf22d8360f18b03e939cf4c69c6d2f38d45958ffdec0d9cd032e667fd3b24b12964d9e927ee255d2a63128eee9ea04a9dbd6899556a6ee89000d67545a8573a5c1850ca1b1080981f0845f84c3979fd86cae0a1cfc1006a491193a6464502e7e17efccc82d4fecc9836dd0595a292e865565ca67d673a98e1f05f66a2f9b751c192314bf4a74c7b3a690454ef2810236a61a3f837e91cc55c47ea6020cc3cb9a3559bcdb88592b9a842b877a77e3c53233442b207003c0e731d0d865164d3bb40423d97966e59fbdded42e17a13698aa95fceae876e9f40d5105552fcb33fa169ad026e46d4bf0d083ff4448c40353db601197574010696ddb48a88a1c990bb8b724899154f0eb64814ac379db54abe927caeb05400483eb5435d35528a60b0e5d38647c989505d2adf04f52614c51746c194a958dec07379e3b11c7ad57a716e5d26b91c8aba785d4322ba14de4e844a917e1188668cbdd37888189ef704b452cffffebb155dcb7beb681084f5ae59337b2902b3eb04b713380a56076e468649317656bde30e00bf5bd84a169bc567df03a87089351e820b96554bc8a5200c54ba38a2045df8ca5b6e1a7aee8cd1be094272a449d9185af4be6a5d3780c1b4a60b70fa73343190077b4b98f54a898aef9eddb58c9d41e62fff8094848a0ab670fc72374303b8a55121435eb4fbf29b9489e21be8795b0091819b0f1dddbd2b9a027bf3341eb04922a3ec027fc3bae697fccc572e606a994ba8c7c3bcb00d29aee11b5f2593d560ec623c7d091bf56758b1cfaab204cd635e7201a9cc006c187d349da23d38dda1bd1d4f611af471fcb182fe8f750edd78f8a903205ba094cd20c98185c1edadabfb598b454c48d3a997a4b5d264a4e4316ae803c2fec30e8adbef4dcd1793cab51ba6c5940294a00f17336f48bf1f7a6b7f7133c5bcf0956acc3810e4d1452b366303be11cb4ec0ef4e7d298e7bed99ac0545ad31fb367c7b0afdf213d4fa0927197c76420cb72021aa8d995f2d088645d1012bda1f1f07bc49d11bf87c542887efe5319f317aeef478197ec0fb1b141ed867aca90adf413cec3a7ed538d5d4ec9ba9e6a58ca26f1cc7b1040bcf45a7e8753ac977e8f83cf0f311257b45c1ab16369b5cbc3c9868360e6398a3d431e1f7b6515adcadf2a52d77849f3a1bab2903c7db9411f0d8208ab9b22acdd786d29dab54d29a8bd336aa5e302d143e63168e9e890a56ee3f483c1466c0af9250073daa49d6de2783cf109be9856638341ec58da5f315bde2025759e0f504c241ee938ee01a07a427067a5a9ba1836436b9403b76f6a06b5167f5814a4d47ac3a713b9cce497816a1470b4ed3b8ca2ba8271ef4a510982e08f626eb5ebc377ec3961d28789cbc9c7c847664453ef757a04746ce0ecbcff0585742b0553c14447a0b78f12468e2290bcf33d155248240e92d555bbde1e1eb16e2498469738e0e8cba5ce131362ae0fda2ed288c7d20b67cb2318bbbba6a220dacb9f177d30cd55983afba0437a47d7b284dfabb68a6221d7474a864e8fe10abec6aeb504d1f1c7f077a501d1e30192fe9c2aae48e8d7b323f630e9cce874e57d3fd0741ba61acf4a7c5d9df01369e7191a3bdc7f6f1cf606bfd6c6211393c423078d7f0aad80b93221902884f5efc4c148d90ee8ec88120fb55ffec31285bcf76df50ccee62ca3825ccfc8d12944bcbdaaeaee1d783034f933e44632e9c10b8399fc4947cab87ba95fc44e6e6b7a9c9ca548756a1d47c19b1551d16f5982b439d7513564983acebb2e404e3884b8f45aceaa452b21e8f4a86214ce8c36ab50cf10e79579577f0114304c475e63c233df164ef5ce5a8129a961e855c8367ec7323d669ad29099caf5f69059f291e70cf5b832dc49ee171875ac374be0a16b1ec605606b2b349a96828a6075dbb3431d9e622edd8d1959582f59edb2bd004306ab03fda60604f2063c26dae636830391136b0031fc6bebc24717ba252a9c048f0c210c74ea4d3e7f551299ce8f3e3e85e26175173992d0036deb29c2a5bfe4aa13c608eef6e10ecac5f71ce39d808afcb17543011c289c0334e29441131ea54d12568a6024f61131a4fb1ff1eaf85758c348184184b651462dde359aae4084e54e51712d1ea3d0657f633ffd50467a26f1acb6aa8e95e48a4cbf49704ea2503f2ef90ac155b0e951bfb4eefbd79015f380e9c63b98d0b995768de24ab006337cd11e485923c956c1d5bb3f428d6efe164cd2d0d95f1034e21eb88bbf40d6dfa08fe3fd075cb1ea81ecef29fb9688edc636c8e32230bc5317be49be5be8abf160d137bd61b1d7f8fa5aa094cbfff413c139cdc5a92dbc536b97caa875d9b7d81efe9b1fd569a1cb6d3ee44015118d707d2799730e5fc9fbd32f1fbf35284cdc9a87fe9d45ff77799657fbe5e0de0ecd07200b2c3ec69750e8378c903e34da986b9c5feafa4b46ace02979770ca2ddd95f01a66f712fa1bd5f92c7b7d07483a2e3ca66156a51ca9654e5a34f2504c3324335bd8cf92acd21a95e9cd82f4eeae54ff7775bdf8907808aa7997cdd4e809c0070d1632143b00b0750ec7038be26a476e1de14bdf1be92bfb262eec6aeae63d31a72b4810a2df6edcd89f2337ea428ca8c40485693806c659556ad28c1c17b96b4783e5094a8e52b554d6de781e4b9996b1d74ebe70b9cce227cefcde4d30eb5bd7426548750c9e559ebcb7c939a9acc92fc99c6101981eb9db8182eae00f4caf72424033b694853b3cb7bc3970ca86dda1f1632e7180700768bf50ef89939d312e9d399fb1f3ea42c5fb42c6c258753b3083176dbffc94f0827997956b4b1f885d02f0405de3a7428566e1b1cdc6684515cedc93821c61ebf3e2a1eaa2a57637fce549905a7a2058d7d3e7f01ec6edcacbb42a701de8c5d013dc7b24c3be29bc2bf0ef84846aa537963fc4d4c23b69be2d3c8db3fb8ad92424d58b0d2a325a57e584f3432ee20b601237d66f39f726f22040ae6b1ec5c1d7d206c80962ebb41f432a606a1893484a043a6513f111a1cf138aabc7222463fd8e6bce0970909882bb83eef5152ad054445f8ee49b7dd2e91c30e1ee6aa5291ad47453f2f49e72d23f7d652ee3ffdc20ae3fa475aade6e9464e8665be5689c9c2d46d45113858aaca82172cc00bd7ba0f0d4325ec0f7d2bf37813ef79894fbdfa15ff801f6012a7521f2bec09c8edff191c476aa900cee6448904e0c0bc3f42c6439c2ab262b4b8b247ce92f672bb47323f86fe900ba86032e682f823b9e725a4085ea30690a78bc72a81b4241cc4a4c5826cb24df47972bb0c78cb2aed2109bb138f5fbb584a67633e67209155b115005c5eea93945c0e54a3d81eca1304e75f45e31f90a3262b0622d6f696fb2f64c7d3fb1d90d45bed1ad63afa40398c3f3681c922e10a7ec67aa9658d6feaa15b28bc4ab7e27c668bdf070ea9f344542cb9c90c80678d7fdbd5593fb0315ece238afeeb5dda2b09421ddfc096513e73173b2df254c50a355856c286f110a7cbda508e79294af7816f15d247cb419b9922353f0add3cf28e753a407bc18da97bf710fd216e6c9f8cd44c19f0bf565c588d6a0a1028e4cb2419a5a8ca32bd5570b2a30bddaf3cfaae14980291c0025a939d3a56d69d78b4e9528fcf5bc391d87771af2f28480eb1540a02c90aab7d2537d487672d0920f058e0da822f8046eaaad77ee94f03247712ddfcbe085675554d73d27b1a2f0d6d74a730d6245f05326c1ea01289c491d566d6dfde295167f70b36a55e73e0786469eaaa4cbf3f946ac5e6ea306706bcef7a5c6f39c7ddd4c2cbab40c9e2a0b85d8188aa8aa409219c67119ac66e2a030749d6cc67db7381bdbc7450b0a9c85d0416a8c6cd01e0387603b74ecfbf1061ede2649e0acfd32dec61aeb23b902bbebf6fb2cf00cc11440894b3bf038d4435ff7dc9ed16b600614d6d75f09ee5c71cee2be89ea168ea75c345a1c2ebf756bc0dded2e7ccf904d7a17d6a3040b0451490c374fbe5235b76a1c806cc4c5eecc660b8325e2d3b8d0a48b01c564d24138a21c83ba108774c21e2328360dc3429eed5c571c48b4ec45bf76c20d246b4b29447d30a720b7a74c03308a8dd59fc7737931ab1c62550de6aee0dc0bf2c84666903efcd8fee498ba9ec08ee574573166ad36260472ecc448e56176681ee96f4708372027c62103c6b4dbbb963ef194e8243737c7c8b06a9bd1cf1de27518b3deedeb2f8bb71019d8fad87b9025bad000df10830150a0de0975ed66d90f9e859b6eafbac634acdcb3f5cd038c27098ec07def88fcaeef5f128d944174bda06ba53b99307dafb949689ed565a7c1fa9ae023a24eb9f2da300b83f6dd6da8981ff3b3b0ab919cb787be32ae7e48630f237d4468be2fe35efdc384851e0f64c04d111847bd684c1991ba613fa90ea35c4a30ed0c47596a8d080790ea868461619fb51d7b858bddb967f342bf568240f74092b94d0f005cb37628e1801d330fa9d4aee90c7b5e308ed36896f3e23bc9565fb9537f28f834b322cd59257ca6c49b5f531cda546591246f2131c727c5c66bdd3e3d1ea48e3e83e538e3505808fb5e502a4ed1b30b05a724e0100dbddb568426515c0f01e613605a149ec82e454914585ca72b1dae7b3f52df3f6b8f3724d04e896d8556a19a525af991ab9aa3a0d49f9e4bd19384b35a81e915f30eeaba529f182c434a623fe7aafc7dbbad5d8f1658a90778faa93de4aa9071bb2c3369cb848e6207464e3a0a1d8cf6899b70cd4d90f7f3b31eb8652f68d90d4bdfee714fea98e8a43a385a827207573bcefc683ea95ac933e9c5b6ac4760f1860ed1f31cbaf850930b2713377e6b7ef1ab58c590393be9c89ec9aeab4f98f5afc75b557ce38ee62786325147166a37371084e3855ce9b7cc846825fba0cb3b200bfaa39b6a78085fb608af36cd8cd33cb427fdbfcd8a46b48ebf771ba267c569590d74793c724c1e5360372aef1914b07c289e50e8fded33e2b1211ccd8d684be717e1c702b276587e941201cd59215b2b39e40b1ef3533ff4aaf645ba35ad12c2956597c5223161a6dd20a797b8b0a90d927554c5e8faa4bb5197a32e8613960cfc074e8aeac3003943cbb31915d7f124154e8c2b70cefca71f2525d4d9adc65eb92e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
