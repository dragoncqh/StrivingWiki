<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cdd2d3c3a1ab26d51f3b694b93d1d99b1da3ca391afd9577590b183281cf3ba503c977f895bb2c41c4aa1a680c386192ef089a24ca306799ce800009a00fb18f5595db5caf343f2fd66b75a7254b11a57ea496090e57dfeadd1dbba23475de989bed6d3055a732169840071de765a266f3d1dc3838c5995db19f84259624a16e492c715109c7c3770a17f77191fb3acf8fbce5e362dd3d9a6a327574f07e24705a429599869ee5c2471d69ff056733b32629fc8c9c7080221030cd4b482605179297614e78e0fba4fcd4fadaf6fa07ec8bbef273085e3ea89d56d1359618f8884a30b19756b6ae7f37223c71a67f185453408e944970eb1605e1b8f7fb70d624f214e2f8dfb3c1c03c13f53bb4d6a7ebb4b7f9438bc79b44e147f56f77e73d033fa13f5d68512ab1cc3c2a8c94167997ee4a343670c1f073441474b75f6a9aaf31bf6337e01f7e3689d6d1ce9b3b8ad7f8599919f9e93a8e3ba6b3b5a652aa8121969846f96f2e619ee86fc06ad5191b77f32f4ee95a65ceef7c382bbb714c1ff761be141f7cc95321c54719c3a0a1a0e9e3ac2b5ef865e49c7f45b74540e5e1f0846feb3cba07e8e9b96a3c7c5c3bfb188a30701dfeee1b48722e979fbd4e8ccedc2de673d68d25989ca39568e3231fd5cdb96b35b468e6416db8d5186bbdf05d4a78994bac91653987c26248eb162bad840518a1c96861d0d57f35d3b22c9fd4e362a5ac9f7ae120789509ed94d0b66c784ff8d7d2fe7a71dd13cda95ad7c68c35998d6f7e7959728c7903552b4e838ee325dafb51739be428044401b7ae0151d77814a0f309b27fb5b54f8f3f476330458057261410d8271375e57b251cae10517c7e5c4b8f8e704370fe9a0a67e93d4dcb1de72c038d492c4d2d2e2c4bbed822600671a427b92955341e3aeffb1f95006dbbb34f42c4d47e1f98ce81869c1f942eb288d33908ca8cdc88287af2e02e75ca1af98f5ec34b641d4c5267772d1b1779a6ad0b16d419873156f0797df19c46386fd3a7e6ad0c61f81839d4614e43183182280e425934a8477c6e36ee9bd901bdd26d6b1350e04abc9f57e7adecf0ba4587373fbac34fa088526789cc04414c7709f139eb3be0b3c3c0a34e7cf4654673929217a774fbd547ca3aa3af5fe83cbef25ebdc2f350532b2e741d351c2e6e772543b5b9fa46f613de6a7deac0d887f0f1c299791984e46231ebe1cbbae1865774a465e981688b26ce84dedd5da988389f8e5377745e7a9b3468ff118598b927a73da38077e0e7cd73b3634789f1bda42de174d5ec18b352f2d2b6b4e64a6625e532207a1ffe37efb1ff19462860c8e8f15bedb4e222e0f9a8af3fe1a144bade48e1cb15c0d4325a1108d7c13bbadced8a5fad36f94718f26eaba8b8aa2bc7a2b42553fd38a3046e562ba46fc7d8d1896a2cbb11eb8f1ded28fd8531a4e23d98b7c4c48cb055ad15b749e671764122aebfebf2d23e7706d81f43f762ac9e048f06ebdbda6faba769fa05ea8866a39b67da64c5a55371e7185431ef2af2ccaebc2d2ab8f3d36cdc9eae7f0948c58c42f26737a7d5a47f440f63986aa05369862082217bfcbb4d20f953ceacfae5813c47c26cc95a911e784f7a795caee85a65a5b63adc27860e6a949d71677e35a23bdf0b623cda880edaebf43f5502f88806611d3ac666e485a4bc536a4a7af813527acc7ae8ac211dbde8a507baff099015a0d36920edf1bf6eb33482da1642902d850ee972363ed701df749bfa34d466e4fb89289b3eec49c67c8bac7ee0c5c28ec69acb7631d43040c4a63d3816c13b78948b458efdd0483e61f276cd27950c3a070f49248f121397b73c1aaaaf27c83d6aeea4f387da3eb5af190cd9482800ac37d9586ef30d9219dbbffb77b47e5268715e0d9b1b8198284d0907befd222bf0e3c241eec1dd9ec020d865504042a98105462341556cecb5e78571aa1d33ae3aeda85c0f7cec42ff00ae5d031e0440b3c522dd9dac02e6b2248edb0f892a461f34a6bad66933a762c7d8a2bceb9996a9484b892edcb7f01dbf0c96b175998b9d0b2f08f26a68e606a38b070ab06226095e024f8df7e8d6d330e6fb0694cf2b9231f9ff232137d560178f7d5937a20800654ab615798081c58ebeab13ec6ff865d651acbac8c20361741bb4604cde3343c8ea37cabe6a63caa472521a7a2b265faa08d3ae91664072cf3aca3d99382655861594e20600131ff5a86ad7609fc28394c099ecbe4638cbd76c9260673dc47d51b99aba1ddd109b6b2c1f74f3ac2124a271067a1c1789cc73b7c4c8efe3e1d5fee10e46dd1463ca85e54f1d32591d51a70fd955573eedbad384ebbec0e84b411317edf1b5ba6abef4f501120b12f85a501c8ed6601c63d5addd49450dc33c396ae3e7babb21b97da603fc3b52c1726132b4ca93d1e7e1ebd854749914485a9bcb88d92f9f3d4c6df0c6025cfe1df79c7f9d6523a4e7e9d004082e07c95996fc8c769e7d7e60adc6430b591b34590ede1cc6e84ea48e666215337470dddea80733a59820b316cec080fc62ac1a85d63352d45ba802ad5bdc11986d3a761ac08be80b967cccc36f1759b728f90eb920bdd791c836fd3eade040a858286246fb582e5b680ccc18f04457b4ebdcc8bb057c1afd357f10e1f57bd64737a9cea27de28779266140fa83938de496b175cc76be170f527827b1ece804a248e718bc98a385c0c151ab8a01cc16e71bb2cf64ab1a7134a32ee33246c0f103b493d0293d01846d133d4beef03ef11352ccff80f2518ec316729e56b483ee7b498c5400bca9237a12c505e20acd5fd9408a1e43b7835f0827abfe36bfc7a30f23962079730af1f240656f23a1ffe6526d3cc942d620b4389dd5c810dd0a1a027168887cf70ee9e97d1f625536837141339bdf0c81cafb781060c405aa669d17c4a3ecc9eb6922d91ea6d4d4b0846816efe340af616b95af268a382193f36f1ca36d267fe5a45c3e0086f51e4f57af57b545db2a772af298d5f86b8a7d0567f33fd7116ba0a2bf03524d96b355bb74347430d3fa30f495818d1c65b0c6cb081f9293f3b43d3fa3a2d00517f9e893a9240221ec2078fc57d3caa9aa5253969a5cac259c373c89e1b948cf4481cf1d38b4235f4d3b1937250e4cd829e738a7bed5cc5ef1a54cd44dc2bd15b8634afbd85ca9178e6968fcde6c721e7758b3246de6d4924bd0c1f6dc4e2635bce76c6dce3a6aa71de881c4f2aa27efda6df11bc056aed4ed247a4d2ce170d7eb4d8e613ce63154b7c44cc92c48c1ff9fb7bd17330d545a7a9191dc554cfc742d80bbe8d8702c8ebfa301e353755aef1caa480065913ad21d63a4923752b5a65b2e8646de8de375d3db128faad1dd14789993e2335d224c83b7ddfe8509411225be3ca9722770c2e93e588afe7b9b3aad20901c5ce1cd5946e912c2d3ad116a2c20977e463a42d2e54cbcca0f2c8696aebfcb3ffcdf4b38a6554ad19683bbd8b66afe153ed97b172aefed495e194e601522f06a845d36a3482d6d203be6773ab2257e8c46dbdb65e0e428eabf6821dd7f13d3fff99f28cc6bbdb0ff7d7e8a312c0e03a488f54e9636a9f4653bcf6c421a8108d7c3b839dd40c4692c2792f1d6f549866cf56b68be278d9012c707d191af5903b2555073ebbb97bec01cc8f574a5d78563845cc9cdeadbac37617dc03b41f0cc1298a2234d07adfdf12140eb26bb4f4e097f388b6f120fd4a1278f3cfab6b1b71cc2caaf099fb4371b40ae61063a7ac279440f9aeb2be94392afcf5ccef1d650b7b426506851a3b4fa1ca6371b0190cc24536998a26879858a403820bd839fbbaaf3e45103ec9917fc8d6972a998883274e9abf57dbd7c3abac12b5963bb9b3aad54c95194c50ee07a91c287f9662cfaa30b9f168dcbf1318e9835d2d46fd0bd2b44863c1ec8cfe85559ec9b2e1a29c59243d42dfe3a3fa25c22495fa8e9fbf18410665c60f957e062f900fb97adb4c3e4a6207190d2382519d107a4f195c9e83a7a423121df8678b97f20493a27a94b7b1383c6541be289bb9e61afb63d02f7a477ebe7a4ad675019f64968989fed0e2ce3e5798d4f7fa5816c532dae66a760f61779db6a571d65ddbcdb0578e4f317d57b2503db9ab4eed80f429c5a330bcc5e63c3438005809e56c6294cb1c1f0567517caf85eaa9ab181605858d93281af4bc2f75b4c604117521f4230ec85bfa9054a9a7dcd68d244727e8d45dbd60d4a530af118246db6c89f483508ea49c2e74a503f8b16d9673e2dc349bcdf6bfb0ced861bfe1af9153e34b7ca6ff2c08d3b13eaba66e833aec7c1fbbf0d1ff8ecce84fbb671857712cb3cbbbbbe08f047faca286d7528fdc6190b69cd8dc9d02c414f3c4135986831b32192c75532b3d863c6985e7fae1a52cb0670244e397851295c7945739b5827a7a4e96f96674b60eb02cb056852bd9d5d0decf83fbea454eb38be8d0898efb2bdac1bbc17c958ceae3d5c27f2ced2ea7edae10d431a821c08a330fe923ad6a41dfbb9619fe0b07846dee3f81f3df6c0fd574507b85d1c5e5151dfcc9b12fcf23b814164f58dea08e52f0c23454fa4eb29182c0c40804d26b5da016c9d9532629bdf96f54f7a9b78b4def0306a24938c015f6b7588237b7ddf7479fb3fc8ef3c04d125a87d8e8dfaa685810937526828b8159d5b96eebd092e39640c1368a5ebf2a0e895dd168b75d4c433f652ca202a73592770ff72a10f81bed751b595b5353ee65b9b17f078884544d372eefe563ea4b0d392703005c177a5499031bad531a64bb907fff690c17587c6db34243f3518009dff0411a188a415d5c45218fba332212069e2be64e2769b798237fc77946abf63ecfb159d11c52b85b02372497494624d2074212538102e8ab9726c37ff0b3c5719259c0310f85989aadf9c44ae67e1b3a5195078ce7c9556370f6631f1fd51e951fc7c666f5fb731622fe30605f75dbded9e28163165ca3fb5ca9ac746fc539c045df1a255e26527e24225131f3dabc02d8580693e984e0bec9a30b944d115fc5a9287e89836972033cd2ba85c33f4fa52735d9eb9551ad0dc9afe932365ec6c08bc15f021a8db35e023b4948004d941c0d41c29fca57a77dd15dedb1438175db808192eb8f8f9725f0b7e81bbad91d02d05b998a16ec54106d43bbd9c6cf892813e0688dc15cec89935135f1d9a1c0ba98ef7add973a6eb02823db9a014c48dc635d625a51f1c4208cab743050cb7fffbf7e743aef044f444dc89697facbbc31c68fd3021c5a8c7cc12c5499bb391e5f917363f1c8852b7eba6880149eda1c4d33d457ccc78b86f51755ac195995d0f25ed92b4544ec96f639e45ca2a5d89bec58a48cdfcd1413a6978e832d94b67c7998fe1da0ac3209dae49c8d727f4155fef4c32604df4ff472a666ad3a6c4ef2842913794af52124679d4f9e4b2685f15b395f81270c45daeaaf6c4c706fe3190490d5386edd98d66e02509f927d6b55f559685db0cb60f3203106c416d0c792a1271a76a43fc5a765d8ca7d93efae859ddaa860617e89ebfb02ee7e02e72b591cfffa13bd4321268854799abb91ad329149bfb209c9e7e7e1eb78e13bb161a047b7c1d162de9c4925f502f57329a461e5480c5bd3d05ce629ed1f3a57c1ff7e446a2e8238be65f625776b7c30fd67a9ddc0bf0a65e86f328e4bc6f0142febcb2a28e82bf711241fc5afa9027e6980a5f29af09bd75491289e5704346845ac62b9883c79dab1b8e7e228e905893843af1424fef582213f2170f025122af39d8f3120dda5aede1c592da55e80dc323bada5b87fbb8cb6d0f166395b26e5881193c51a1df7cbcce3cbbbbfca97c61d553ed43edca6eaac5b4560f149b5ac454360ea8198cfd84d5e2b5db6bbafc832ba30141b7264909ff3561bb1c7a6c6be4b86a99f4a7b4131113b39d8e104c555c3b4a53e4acc4bfd7a1518c24f27742da75ac7896e28cc9fd58a1c1a176ec19707a8b5e36c4064b5b06868715307819028e0568dd46520cd948ede7a5c37145dc8d0aa8f346070358ca5d71c966336b2ad73286e1c8657c6536219bad829708e4b40f9a2240a825e2971d5dd66198e61d36cfe5e0b21565955df11f198511a9ef6c72230eb090c009b72d969deb9c0f2e4a87c8cd342896054b38e17daa55ab78e24a86a136b0b5112488a22a2bf3a522b49132514b77a2fcd22b9fd435089ae3fbd5c616f785f25b6cf5e0c2312fc82ba3569960e577f79bb6e8fb7ede9099d3887eabecbe80a222b3f589eab80d3ba78188a8f998858a3a2bc7be0dd23f99e84298d1e125824aae87aced73c229891a9ef983fc48b0b3db97bd19824516c2b54abf54f2554305e93195e868257c270b235b197aeab76089e51405c93b6982a25a8cd77ece3e2b669a9dbbe41aa555d620873ed4b3f5cdc18fadb7d9ff7a8e82f8cf69e39b3af4bf7afdde48703c52dfea80b0cf3422572e3c4836a438722105c08584023d2860b4978a468ef91ae6e0f491dd972b58be17e837ff6645f3d3eeb224cc20ec61bc348d51f8e5a4bc0229561d5f49218203eabf9412ace450c16e4611cb649dff62a09a7ae832d7f348d15e4c9aa1784b27fe779cad9ce1a07ed70bc6c146a7f77fd374144fe0b24b4cb5acfbb41ee65798c5e73d75f08ae9de39836bd3235653d7fa35063cad3a9b6c9b76e8842f8ccfb8ab358ece068f539a73666dd34d53620418020809dbea1d4c8a230d306b6c35b70be667216a7b7c09cf422170d8b3d1f64fbe4d89992a79a5e4f8a28bcaf9edbd21ed55245ed1d1ac5e3686382c9612d08e79b703cf3fbca1fde5427516985562bab6cbd4cfad9b8a6f29118d016e3272ad8e92fdb408d5e7ded314b026eda9ba5f26edec4324f746fb6ea1114509ca46917ca450037de16a165258361004a7f3b12b742019a6bc92a4f2efeb7ccb9188015af5e44a3024010060202bde50f3fb33c93f1499e7fdecd09c5f14bbe8b7959fd47360f6897b1b3d36453fe9c613551066249785fbd974ea4f653aa2494b9092062ebf177d62f4037cad7dd2ecd10628c1fed7bd4dab91f2884bd93718d1ee7a755b0de33f43b4174b605d25de8c634a11d704cdb8e603b8223fc7c79dae0d7c5d7c4f89e9716559f7eb3e0b22bbc37629f38e8943e802113bb4e923de683b0677911a47a081dd6f4cfd0247d3a8891ce633898504cca249c5b6c08fba9ae4354df66cd47b7753f9ce29ecdbb456c8c02134be836e63541a952f20d59c80a6cd7e2ec4b94998377f3d23567803f6aa4df62644c43684d6f9f4bc8d91db31fe4b3031396c14b382521ab45c99e101a386005d30d6cf0388637d5398e2d313834e9db4f8fd83c6ddb727bb16a7084b23037e831a67d7ffc57ad819ec8f906d02de9d61e91461fde9bf2fc30d36b469adde87aef6e1d78afae55c43fc691301e19296c824aed4dd1f6c3c0028233cfe1773d2b7dfc10050e9a033d798834fba31a37e24a2574019dfacc4529e1032a62d16b34ddec3132e6a100dc3d2f68a3c92fe02e8865f8892b05b41fc8d83c892aa342c532ede21162a5147c1352d878bb36c473695520fee7c55f228cc121249809e86fa0c42174502f518f8cd5304954bcb841d00b7dab98afbfd5a35ae388d3242a6751a7129e13916668723f618c4d1d8166ff5eb9f18070c404044994d504ef9845514ad0657d36fa82208f025d69803f5524544cf9a414642199a710b6a3af09a5c80432621cda7556555f8112ddaa9e70e0320eb37c45812e8296d08d3f6277e882be6a4aa56d0c64a9cc0e940ae249990271a94bb424d910fe178f464a8e292b36c18cc72153b128cba88b1b012295b87c825484e39cd87e72011739e690cb579df217da8f8e4fca2decd0ec0ad721908baa484a6ecb6357bd9e45fda4209ed636ccb79542af353fa30a3ca5a69e8312393eb815dcafcde1501e37ee79b2d08a71843a3e6169ba365f34b184355bb24bcb0748750d65874413dba8f8f0f287cf809f67e4d20edab90d88d6b4897055e2420599b26c1a8c4c3171db2f6865f8576c8108043ece9e1753031a99cdd229c68c1756515f6ca945c7715d2065723d808ab19728d5dcb01a1b0e5ced5d63877392362c6057fa7f1a035659368189ef25b28d485d18f5c5e64efe5385bfc413bb3e8e533c80d4ac99fbeed47adeff61d6b3987463e037a49d04813dbff54d754d2ebc08e7f254721182b915976b879e65830721337107aca42d19df731dbef25d0fa5d24e77086420a9ffe6fb9900744a0f5f32d29d4aa18c0123dca1d4d4f0b8a4db3cc92742ad92f2af14860ee7f3c6166f02a0207e420ca5da63b6a3d656b79d943e359fc5b24959362301761277868202d8b46948b9d4048f7e1f56166db2958d42799e6298a2d226cb01bb3f0e2c06ba0f1a708ff84ad14261f1ac42603a81f4c57ba336af21d818bd8d61b3943abdb82865316a9370f2cc320a43b2e73af2823d9a4867f76e26a07b4c79a0030f1c146095d51ec5e9fbe7c91ad6f895e2b09d0cbf11bc1684ba2394851149ea0b3f16d05f023581ed82acb63737e01c507e9abe3f7344c8ad4a3bdd63c7c6722d92d52d17c56ddcbcc1c887331006c0200b9efb46abdb610dec3006bedf30ed59733d8b85b05a9211ecf29b7f3ce2eeb30bb4243117dd20183857457bf437e36f01f6d0f84c0ff603bfab2cad3ec978d5d91621207e554e28dcca67560f346c99fddeeeed04412b5475a1a81678764df93cded6f2c259ce44740d60f8252d71b0ea8bd422a23a86bfccc6e10b70f71ce5bd33215f81dfb31fa1365b7700308056c4a4aa3961b98fbd6a2f6aad955b1b1b9b70dac763455cbcbbf0c60a57e3bfbcea92eaecb151f7bd36e4c3b4969b443d3dda83e70cba9fdb24e9377def12b733da57e9aa5ff0ae9620bd72b2f5f1770bd9dfc8833f040daeb8e13631934e938f95798872f21c3c7ca61b8e8a9c143c83871995e84f077a0e845814a7cd8646469fe23da9582cc0b6ff03d69d23f4f5a57b8ad5e2797098a206e3e19e99c601f34325f8c380bfce3d34f4ac815e8f7ea34d50f84280911428c16323d0942e97bdd794b82df7d72d70a254bc1ff66e7573b3437fd220e4879d6a167c58f29c15b79ee2d95703a8b597ba7345bf4e228fe22aa0858f4676b8aa87280914cddcdae7548f910d6252d5dbbe4aea0b5e21748073b206c1cda0386d014e6449f383b3d0d66a2bd9787f6815bbc66b9ec9af3306e6efc98104e79a22e8a580762e6120a11b1f321fcf809c5609d56d0f14f58f6dc96ed69ec57553db5df95d6c743d2ce94f673a05eddcce66d3dd2cc501441dacf6ed92f4a4ce6d2a7592bf80a0bb95a84e40ce4be72a18899369b5db56943d251951efe4597cf63c5c8980ea8c04eb54c1d100c32254b8f2eb37a20baedbec18be52674a345e6c091cb605763f668aa9386d3a5523e066115dcddc07281e45568b6a3527009580e77a32dc87ca6efd8b8a703bacfec11b23eabbf53360d7a8b1ba203980906248006ef67c23d31835b2d3ff444a0bdca3ad4aca2cc249aacab01ca205c5e6615e9acc0452a0de06d5158c7dd05cce08f1a39cb02c008c2e31a82042e74a45d5d5a78ace6995c61d0497b9c662b0157491961106f9aa85a8522b825ef338f50f04f90a1035253c53c610bd4e15d5bf4848f2c52303fb301ed64f2896e36d0f2996b176c184512acf9242ed6911818037434b8b8c6faa748bd6034a346ce2a0aa1b0aaf334a8d7095be967991646a042269713026da42b9bd683ea2e8f14678542dbd4fb0656f186e10cbf58fe21e988283dd3b9d9fcb7b876331a5fdb67febaa0c2a6b9e10b4c210ebd9739ad243307995791abb004bc9c875234f3f2baae7b9f202d95c6e99178737e397136e6fb29cee348d1ad91965f040b32625e9285894a1752c31ee4ee45fb52658d1eb70bb331f15eb3b6c32573d6e9cb7050a7601669fdda15403cd848f93ba4db38957aa21b70ab4a30bf660b2f7fa3386ffebd718478b3db7e05d07b2119fbacc0310c45840dab079d63d5c83eb1eb4db20cbcf7342797dfb1e1c33ad45cdb40ea58bca7a029b8854eb1628e3909490fe34429ba3316c71311a515be75b04101422101cf08b3cedb5c2e0e090c5598472946ebb85074a2e5163286cf4b3c431dbc123973bcde4da9a85d497c1fdbb89b1ebb8b33a58a7e52faf560a7f724e8866ae6582aa1afe1d505c42433e3ec3bf46907a5a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
