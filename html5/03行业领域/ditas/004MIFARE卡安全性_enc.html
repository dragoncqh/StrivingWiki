<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e5dd3e713ae2f89ab53cf11a0fba997a4cf7f3d34b1c6b8068cdc9532942bdbdf516c86b1100ceddda874524dd8024c4b113be8f94a2de3412228d952e5cc88fa6a9e309439092fb447ad38f4ba0dc027b0f848bdd6882b13821daf2f059839ad53de34c9703fb5bdd29fc5c43105bf1647050528960be131f9b578abdf696c62b060a9a7426c1c43ca77ab3c6daa6e1e9c1f74317c30b96063d3543029b60b9b1bf5241917d4391103f8b4e6756b5971407f60ce143199810866d5fc09b94c0d49d2d99762ec360f8439d533f3f6e156a9d95cb5989bdd93ad8c3d5d135e21c24929b53a1813176aa39eae5db93e3ab9c042d0e12a501d10efc59ef1b7fd8f7328f17e2ee0bffce04a99229284e3ae71f9f8fceaf276be0acb56de7d094816e1eec71c72824f4add8827431ff83aa6f62679dbf09e90c05e5a5a0b54d5d324bc24a5e0f5ab180311a9b6ee7edf82e567441b4cf716b283cb89e1ca5a31b80659d9dc23ddf791b2f1c51fcbd977906066096f0615f14358c83f353f7a1d63c6b14212b408e6b2dd268be4192fa88607b94bf45ceed687546cc41e087b3a1a81ae7f6964e533148415fe5e33ac02ccadb5c3942f8ca2cc5efc8bed27b92db450cd4eb08a85e2f27784d50b1d293c6b7ff25d2b4d7e688a05dbe7760fd3159c1af1cbacc902663bb60e83b975fa11e5d5b4d687580adb9a03b08cd0c63d9959f3aa628cec601385dd6620747fc492494e02f790dbc83d8a03e311877a6c9250c7ea8ecf1d3e53586d63526170d5732ce4d6e85280ce1c73a4f950b3f45c6cac1848ee6348db34cc41d617529b11794eaedcd70f0d126074764077aaae419ccc775d9df357032bc22998614501a0aa98764931da3742cc41006f29173da9bfbb8959896a637a633a230ff4edb2d65d18a8bd1c6548cea13a817d922f05f90def22f66d0d789a58fcf782e376f8b61bec3352982b686826872c752af55eaa21609ddd91b753b821a707c1219834d41f4c3f0c1f5f8903c6ddd7545323c43adaad0014f489cf67d02ebbd5ea08ed40a6d70e22e88e221a3550922c8c8df76dcca82eee165c9048c07233113c59fbd6c8057658874775f58b9b0276fe5654ef3ef2013107ebb093fc9d9c698b7a9daf5c32cf7910ed300abfa8b3a8e74e3e29d7852bdd6f24e19c361145f4055e580db5386aa185135271ee1734c6b0256a14615314bf6eb7699f41f5e7c15ef36d2746b78e1e06192353d1995682255049903b05e5ead751f36333262c0f1ff06ebc18ac4063601f6c618e3329764091fa1dd24979648059617da6bd2bfd282d495e60416cc3b44e80337c90e434ea0d10e6b7248f5182aa4db0b90bbf506d531508aeca0cc8b23d552eaa5011098cee0321671088ab5368ce25d48a49204bd66d541c687b520e6c214df61aff22f22ee96ec2153af828dc14535bf4df4ff4de1d5bdb1ac24159060b8fb29d0e928d2b8f8cad634c4e7c09ef34a19804c177bd631fcd16722d0a5fb927028f826273e7918ae28edad63ae156e693fcd973657c11f6aec391488a3205bb19ecb8860d85b930a65987dba99be5366025ee6e7ee18fa02feda5da50ad6a45f6e4238549add8249d57d048ee585c6cfbc2ffc8807fa50ea296fe4662d7875c48fe571df70cdab5418d2ebc93c14be6ef3b522ff6f6a3e960819c8c3812ee63a99ba49285317baa252256b35292e20edb0af31bf8bba1ff61c551eecac4dc7b369e380773ed04124812d25593bca576587271d46a58e93b4e1ff82735c3be3addafd8ef5a72ea10a8828562e9c162970a3a5668b7e1806cc88fff20db9f6a5b1e01e7c241ca471cf8e55fb20fb478fe18d541310d906a77e6e9d6348793dbacf17b483a9a7ba2e3b7025e32483925e3c85441e76b1fdf1714a44c30ff527122836dfc734d6f59ef3de8d8ee02a475a815128dc4b5ea3122251b958ff8bc6c085c918efa47b164d3125b25d74c1d25d12d3873333b1b684acc15f65883dc08e455989dc66defcd1e51d506a9273e91c967fd74c423b1f028cc44d5e1d3abeb9808501f7a3405a772ad07728341e38c9ae064629d583d045742729d2c7fe75488cd836600d09298b63390bbcef89a7c527cb12e4b98b6a4475fb79a5f1044b020dda5317b516e4a933fa19520e1f0ae5e671eabaa7fb1c50e8071dcdfd70abb9cf9de808b1b58610d8f509252f54e5974a0a1af149ccc60d0c794221458a47f1d318451d2f59b34ebfea58681c9b0ee72caa2dbb7975b40b0158656897293f1f05dbc0c570a03c9650074fa77ef24c30098ac2282517ce933a9a453b5d409c40bbb60c62152f1e27cbdc17f2e11eed2ca8917d043bb29cd5f368d85dc9654caff1d13171204269c1b637ee95f8773ead06b7e490281966dc391afcdac2afa0e53bc16db9c9e9caf100908f2e438f1379b9d5eaad9d8097fc2909529521bdbce35984726a42899fa19e44bd6b279a72592c11d872d3fdbc485b974b0b883a1091fa10acc563830d17a4232e0fd3719e4b0086653a870db329a5f0afd52d8c57f93b76e2a8bfea413afa93730085ac8acaf3592a21007fe858a68ddd057a3378376c7c12bead5330d02a9d1b4f9a457c22864273527716c3327536dda5895a12d83bfc85b48060e1ef9100483949509cd0b131f8e11795e62d9177d7ce42ad82c3f30b3a8e4b278ea80fb2c29a99042548323f673137f24a0f6c85e7a5c9a3db87470f783ee84672f8a7a2ae18102ea8c9b777d437a8d4ede6dcfc71e1cfa9c8d91900275cac4dd6fc6a647d89a4c5bf7cc60fb57e64f127caf92920849bbf98f38d3ca2339554a93e4eb98c88af58e26dfa77cb9794d096d75974d3236a64308bb8b0179d38bfd168b8274695aaf707fc8f997e93ce619fe32e55ee76c60f94978b5cf30a67b2126dc6364edf22b9dc9637579ed911e3288f723df30ac422d8d80e38b170e234661ca3d8f8d62ced3d72485b878a7f51d1d991398da35efd30cd7d4f86fb67d6af4294d4b4a6c191ef2e88b3045732256f2d6ef157bb4b30fd3d1ad1b1d3b4671a9bfe96c187f06055a9361f9f5a2854fdfc1b0f8b97ea8da1ea39bb1f9f85030240050dd5d0e0a8e70a86961f6d8b4c5a7b47df135dacc4ceb5368f7364efc689b463b181877cfbcc715ea1d4f28e417da594cd3114304b9eb98d962111d0013a87018ae36439af785413dbc6345697bf36b3cff529d460c4b76824b91c3bb60f9d0a32e92bf160c50d028f3047f0a605be63e83d77675afc0bfbc8a1925a0effb1918c08049ddb603ebee4481c653ad7760e0ecb543c9325484a329578296c0cd30e55394769d0d1d59dce74b02a5f8c3e8c9254ffd5699bbd2e987bcbf913c0fb5ca0b90e30b426854b366adc23410dc6ba704cf5ca09b700311d495151702fb20ecd95499bfeba3641fa3506fc6c127bcc1c336272443acef946e9aceec0b2809e4b3e79642b9ad461f4b94dfec2942e408b933353b83d95410ef1e6b4e99161c24c67ea589acccf79d1a4d500010865882ab30989eabd364955d6d312f6a44125b202bb17fce1c2c9c4a0e80963755fd67372b75b5ad9f077c058cafd9894f17ccba237fde6b6a1c5aaeea77f78cbaaefcc34bc41789af3e920f7c263da2573debed4d94db6614930dbae52ba94cef704d7fb8aae1dfd9385947d7d9c89968a7d009d72f2d50e04af57a65b0228899f2efe7e2d841e744773f207999f4c5566f6be523f3677afff41e9a877ff31215b653bedc2c92b92ac50498f473141f7be9305437fca2f779db39d5a95c14edd6e67ade2cebf6e9a44f507c43e0026a5335ed5816c073502abbedd87479053b128c10e64af1217aced277f248a00f884cc4e875889d511ccdecfeacb1307a38280a83b3fdf2c1e09469e55db9d17f397b67d03add492e22994fb7aa5ac3908b356e462b1234d58ed640b0dc442cdbeeabe462e0327dd962eb7d0313b9ad3fd7b4902fc9993a34be2e345839c0ec6c9f411373e04945480f578037cf38083a00d7754cc90395d0f8ac9d985519a8b8f93ce25e497a4ea2904b86e4a89ecda6f10372eaed81f14e6d47e4c7eb26d3c865103f887d69767a95071096db2e47eee260773dd0ad2a589254adeba773eefd683be91d7cc2d6e7b55f78d3f7ee82d24efc96cecb13950c5b91c3b821c233f576f9f1b9f1c598fb700b83483550a52a2364f79b2d5e9474bbe4036114ab7caf39d6cede48f62ecc96eaafd37e09b141de81433994b145f035827be243f7fc3ff688c8efdd2bb9100d2cd9ae9505785680caefe3ee820006c29548fe4cf0b3ce4e54d0e89249202a4562515d608b34ce1d77afd646b58849891dce7cbc86ac935dc322eeb387370a95e7a8841c378cd0b512c9a9428a438ff54c553a5f3498ea3070499284bef77398b6f790c62f9b4048068708c5ed43c2aa85f197257bbeae02c36a7add9b7a8184e95a6d883504acd24a4cd44b91bc4df1cee1f03da072324258c2f56e0a994a23526a3c15cdda7884a3e121cfc210c5b8fc336e94195e2688644ef97b8c29b4f40ec98ffb8f05f5d82725ef96979db991ed7c5761a94026db7a241d4e68bf504544bd0e80cbd9a0a77e4e0349c4a266d5e7e60e6720df2e1e59c86a35cf5bfea30775e8bec82bfa44dbd7f362ae4dfd778a045b884f8f7c4b3ab1c9826a9b54b7ee01fd558c654ed072905438261409f802d6c62b83130f4cf4fdd00bc6026b53183e00651efeb1deab75f5ceeaeee57fb0116bb5e2002154450c0150ac73b00edf0b5a3b4ae7f98877784b8486d92bb513d4ad04d4d7a3bb26a9289de1f6abdaf22e82337011216cba4b4347b99ecb40079ee94c809c1bfc6e7f8c15030a8e2512f47660eab3e7ca9b1c9f9942d536064ebb86e274deaf4a264d9f7551a650106087ac187de6d21f19aad9d0b45773865797287fd695c93ed5cdcaa04b82d57406639eb7a9c657f4ff1091fa29c6349c71de51c3d4d147804bad960f9b6d8a01cc71ba7dc0d97e23ba3e6391d71ba0c22160631b5d32be1e5b772eea52ae86562e8de6698c3ab11b2a9701e049ec5a27d26a50146825bc48a55296ff617466b9c352b37f5a534fc589e3b64aa5f0fe2c9162990032c1b9a8e4498fc3022c4dfdf1a6ace2c0cadd383eb99058f2a57ea91989127acbd06f5109a04df3d29f2e29ac10c8f4d60a3026aed44b9dc07d412188093de6863f47c4d9bc6ee81f79dd19496e0b725c95a0bd2c8dbf01ddf9e078be9ad62443e84d189069d43c4839ae4c40c5052cb2008fb6801be838ae398940501967bedf619e737a9c5937da8cf54cde5ebfbff9307a1dad72fb6701494b7655d0f44cf7c01c700a67ee174e6d5e53c9d04489075630858ae5694579b2ec3682d6686e4b9b3d5ae90f1fac7539a83e656b066b3f0237b2e03b80faeca27eba8989e7459c808d8ec8b470ef330861bde2fe6d2aa8366c33354bebfb77d3d6274cfd54813e00863df5bc8ebe31d1d556f33c27ca9c8f6becd6575e7ff3fe9396bd4cf3a895807f9162d0616c489c1897c6c913f3ef69a6fc29360d9639c13a685837a585a9c3049925f20f181547aff3c28418bd2f1cb05aaedaeb2d092e871ad0fd6e4cac78e9dcb106daee056d5747d34dfa9986a7683d9ca862271f1a944431de370a7eb4358d08b3ed7c842704eef67086aff36a1f71a708bbd6cfb2b7e8e6cdad0e5860b6879cf16d2e7f60e6d88a12936d257e407c16a79c4342fa60e7d3a2525c18c1c9e2e1b434ee37ff04e5a5bda79e3c1cf8dca10f17abedf262fb42472fa9d0bdec8941468f036f0558d4e3a2a42868f11c57ca79ab27b078e307abb07035fa40df845f67b88ee169707667972e3c227d9259181db839de50bff26c52191a92fe10cf340588e791bcef34cb6d693869c3f287edf61a3ec5da8ed981345e526811f257982862f8cbe253cef004f3e6c660219eda13dfc14a637fd0631b3fcbf0026ffb47697f11e4cb37119d06c8186330215226e0c6efa5bcaa4277c391679d6971c89cdccdab893f8549ba258b340adf82a8d2452c8f88463502742631259fba5f2ddad518675cf2eb29f327c287731373f15de1a0be4e966c46ad24a48b49607490ffa6fd57abed40f01e77d8730de4198af6d7e5b4b2277a9d24d02fc77557f71f27fe7b8eb71c3f354e3485a125ba7067c1548b9412d4198babcf187ef8675ad507728c20e33626d9de302c6b59a9cd6fb20274741109be3c6296ba8e48916e27d48a1fd0974a549a69c7b286f7e7994df91f282e265ceec7b012c4be3460a3c111e1bf79a98538632e011e6255098870f1c76fc0cbb7f6e4a70de587de4c46e8a43d1ac4f60269284a6fe7b5f14db04da0ad1f5c59fb013296a5d84f97017ed1e892d0bfe4315d62c87ecb6e33bd99da4d43388447e4703540ab79ca475bc2d2fb53b2c4d2c651e47ade8c55fefb08cbcc692e463e8c658234acc533cbc9cd51939a6a3db3ff49eb6213dd5f9e4f9a167f6fbad7f3fb526506baea8fb03f5e409d2fce2cd1b796101f5bb65c8655f7c30041e220ff7927ae2f4fc99b23865fb31cdec17553327f09b6820e0bb8289fb7b1164f08cd648b974c3f9eb81e168607ff661ec2accbcea2df743d0db40b698c12d75de980735ee417f41e6567517eccd011c88425423629e169c0b2675f1f996b4b434ae80e662a177d64a80819781dcaf2eb40d6483eccec684bec56be231edf1476d7b45648642401cd8b2fb5f68df947a025121e76a77673a3653488ee50a757925a21acc10f89b31a5f63261df4652852f49f490ca478083c999cf819e320c797e86042ecff7f46ee66d05ae7e12760eca95de40facee2eb07a04a8daa3d324380b4daa32f2e980db2a6c6ba4a9b4c5c44324b56b9c4862fd59b02760a55776be4f37e40f2a943df5ce2e617c35dad53d63463f4046539ed12543628945bf3d4f3cb7639e87a298a4e3c85dd910cc12d0febd6e8a2c853a1befe9c472349fab419e5deffcdeafb4327dd344be62e2e254e81d945425c614d2fd58bb070b7e87b4943a3e872e234a7b23df7ee131d2b833d1dd93ea9909da0625d23e554565844146ce8fab82ec0d04090e588d32bf02672c4051368f6e379eb5037290ce438634222ead945af6526f683207dd2fd591bbbb190f51772ef1f32c29d57a85c2988cce929cbe75f332ff703f6fd7eb6744412192aa69c1ea4e7d93e2385561597ef40e7b8e8639418e3e7da1af4558c4a55888c7abd0960f881421ec8ef0798813901e76dba6bc7d2021612ca26ebe9f47c871fda0c1ac38072b9443bd1fa33dcb62c6f9bd4fedb6d7c9a48578091d621e650f88498d795acdefe299b445652f58fad1f329bec238b36ca38decddda67d41f0f2af693bab935928c971e34dc95e47f554f55125a4d3969a2200d108bc44e6e47d99e75ed8e642d07b16e24b589ced0e63e7769cd73cf49d1e543ccbdd12ec54e9a0ce26f40958be230db4816ccea97143b48bb1bb65d654ff8c11e9b179da7d5ab386dbb2ef47a2eca731ef44915f1686c6a390b9bf4cf671f953605d92d2fceb2a443085aed6c893eaf38857013710a11ed8aff47ba5eb5599b739cb89cd520524dc18002094791c29db7070d01ee5605a8161ffe8a8bc6346cf182e6adb9831b19587a9deb33a16f808f25fb745878ec8491f09bfa15302baaebf39fd13991bcd484195af18c651c33e22fccf98e1acf143a72dfdd18c32771101698e183fb0fd9de65e89e0556e2e18a2b19f25d1462bf1b9fb9b5324ae7bf27c84d956c6e6ff2687cf22ec13615c02b0f13627cada8898d55817999911e89c4e4b37c0a45a9901b929d8e2a171604cc29342d44972bd0eddddd386009101035b7ad687a86a1132497f7ebde10931021fe5783ff5ab69f2088d10d2b97d0bdce38a5d8859a34ffbe74757611bca1e2ef09ce9a7003873721861c05da0686daf298995d953792608c74b5044e17051e30b8dddbd2afc03d362400985f67279ec9be67f3dc6ae76267c10a67883168965d3fa06af8cf3a5c02e661c007b96a807a0168808c722b333a747a91026f9e2f55c3c6c44bb4b911f3f3865e4d753e26d9591cf11c754d1eecc7210e736a4eeec35baf1232559d8db95aff0cb34397ec7f7d05318b8d191fd209f6f771e25a5adc40a3a572cfc9154de94e77d2e363b8a5facea64afbdabaa7ebfadeb2271d19c91e54676cf062f2717813a68f50088230a50a00d967c57154e6e96da44ead7167997f2256ea8f837c1fe6a5b5149882f45de8f1c24f91e75f17da612554fdd11b323f63c4b46ba42781426b50dac56440ba31220b2d0c3335f6d205d974b53b0e03534d261ad5913f1568de4a8d6859ecd35a9dac03c20f41784eff3aa831a32f7d9c69479acec03667c041d94ce16f9a4af3e5882803d8b5e46460a729c08c4491bcb65397761ae9413c3678c7da2485785a515470eecd870b09dcccba6646fdac75d7be92b0d610ec037d096b3df00d257c7b6d93c80c490139d04f70d142325d7b868bf5ffc98c4625f290bb84121705eed86a57fb9306f0049ad41ab4ad1c20197c9f796b6ef32d7bacea059c93c5d16bd9b7b2b575e8df716476e480846774e713ad83c53adc408dd9eff1cff136b570ba983657669c693d1f2c886d014bd66eeb986560d09078d3156d5c8f5c18f8d685619fd73377e43af57759fa2c59a96a3472d75f061fb6f0aa9020d3162d6d0d6698a5fb17fa1706f70d76271d132c750e506a0bacbe90cc517ea9fe8a5813de67a78ec7ae3834adc6f115c2fb9e1881913523dbcc1b55925c53e181528391b1cb39db78c4998a6c2dbc389b99f13eb45843a2fa2990942480f9a1cda48a1d6a309f8ce268c738bcdc078c51e60e72fd1b37c47d686ca5d87e81f51cb0c09941721b35f2adab3276c00a705246a21517db40a6262177ee051f01ca1aee0a17c9de6a9b3510a1c3fd109ff85c432808937926986b4c299c12957983d68ff0623578aa40c18dbd1c1db1e7762088e2c4b6e505af5946c599d02bc2a77d7dd11380d4b05c4e3734d3eae36dab7151d0626d6ae17da8fa6ef2c53834c181dddf6c016e77f767e0364eb33e77b1147054ba054fd5736605f71522c6027c6f63c2f67a8d2fcdf22afa75a69be5ea1ca79ca9bdaf2d0fa87883cd8f2a75479c2235c6a461dcc48242692df0cfdc575ac63f293ff44756e29ea71e76ce9d7989a6d37a0c1b62ac68b1e28364dcf0cfa60610e7f5707f9a3e2b8cd61f8d4384834bb59dc03a333572dc74179aac574825fa9ee1ea2fc01b239864502a981e053e966c2ab6812dfb3bac83e5b0911ac5df1c5aeb56fdd901d40cb8a7f2d9fde056bd9362fa77b98029fef3ad285790c84409d21c7c0d4d5902e24d148d84e6398cf1c2c77f0311766f43ee91909979f5609d61adf554fb8a86c9f8efdf54eddcca4a7a06ca6f5e2ddc526a9b2c554369267eaef05f13dee36631cc3d713ca6699a6d1d061544d7d566a77d3a2d3835992933d07ae5f166f9ef834587fbbbb80b1b1b225cdfdc96ac7cd040c7e9fe9d2d55fe0dfe87cd303386012e4e0121b80eeec3d472df0ec43840be90d04d0de96318bfb15b7bf126c3a75d81820cc7c832a136b403ecb516c816f8059d09b997b1d0404ff781b8c1250544f2633e08d433cd13c48bee2930b9793499a7cbebc148ee017424751f1b8c394cf8ecea42fd24dfd2f5838531ee49de28c3bd3f1231e44f0e2718917e441ce9fa5b3c8830629893118f75f1beb16c1db0e043989b64af2b741f1090deb76f90ada4b1e6405590dd274b15586ded0b719d68de087d351405edd6954c5f20cc571f6e9afaa238abe34d3eeef7815c134f5cba3a0e5cca52fabc1ad08230adfeeb7f244832feb2d569ecf7f48edb3a1c6132ab3e70ca6033ce5786577cdc588c1216bbd98d738ca74a03532c2bcb01fcb54e56189e8ebbb3dd3c0ad1497002a23bc7b9faae0111bdbbd38b20d4ba90f0ec3e0c525a5aeb9040923916e8d6a180e0741776a0b8b9f8802f2c6b2663c2c4d75e676d63961fc60e31ea6fac7f8f216587cae4be5f17bd2cd44c34c546aa4811d7eccceb6753f2cba367f751684b459f1e17e1dfdb203053d0b086ada83bbd759aaad930da0ac85e103e411ac35691ba61221c9fb652e5dee7a199b7e59191d3bda8e008f738b0600e1de848bad1c99b4b274810a7a86b61770fe2c9467d876ad44628d4d250f89dcdeca7314a85bcc16741ae5ac499ecd86a62b43906bd13e5188ade5d21f2012a7f50af36ec9290f1b7b0aa24e9a868b747538b271056638b66f9de084bf5ddde33a8d1557fdd74df4799046c7a8e0a512e2d9b3191c2e00f2d9dddc21ba3dec6e9d9e625a26d1a5d3425c559b2950108771e1f45bcaffa626e3ea925714166f0e9fca940334b85829ee6b2e7ceed723803c25513afbe3aeea8be17ba5a811fbca7b0e640f684a88a427151ba5fec654ad468bce4ebcf7abd0278dd301acf054ef04c6c457969d71e93550367d14c3005f1c77a078182fca619b7f9bd0c906dea162d72b97d55f52c7b5abb2f9e179eaf91053469f251993c95468b9d86cc46282717d947bfd75aa3c7c75cb62956e28b8bc18955010ca6232b3952837bd0c411da321b73d159e4a69d7d66eb9e40fbfb36af611c949fb409f72140bc37d996a871729d342a81d0721fa0dc21b6bbe1e39d48106a0e4dc7b03ce094eab95f9c7dfd507bb651646e2eb1cc7304f408b2afe9506708d9df3eb9420fac7bcc654e12e570048d38cf52f3fb9dd3125749fc5c2d31b1b2cb740bdc83fc0c28dd9c76d1fde539cbe3285dac390143eb01d55f48f60a49c44da56bc6dde2aa50040ebb7f6dbac7c87bcf63c368d6146d502a35cc84c66a5c029b4cc147492e6dc99f8cfbab0adfccd866635138a3a2dfd3cd7b6b72e68d73c1cd07b62c9b7aac1f0dcf6d70ed1497175e662fdb11299c32b387a29d02931e66af12670bfcaa25877449e7009e5af22736f7ee983748c3f825388c29415555eb0bc42af3e322d3771f8292a92f6d44176e57d338082e9fc7acc5f2de6542d6f76bf4d19c23b7c742ff04aa967ab8aae58b238830dbf09ba8ed27af7b8876f5a7a91b28395e986dbac382e81a941c441002d022f5fb74f675465f3f8c64a78aa517dda7fd42f4ea2ea2e6d6660714458c792c37e11cb31047ba899a5f30cdbe1492a9bfa6aabe43e40ffdb5ac08c876cc66f2b8b5973a7656ed25c73f087f47ce8d42aaeb889b945218f918b8fed6b7a5c4818cc79ac8fdcba9786e24e668a8d55e368dbd9833e31e042456e9075d9bf0bcae43048ec4e375cc5b7c787740e3153c32238ce876bccc16e855be88501a5b1bf5ff037cf54c3fc54f78742e74e99397f21a17639af93c584fab6a8d80c67567bb34d010166b84408ec94ece38e767a720fb856ecd95b3a1fe059b39a7dae3e3c66261c80dba70b8ba33097a57f5cfc88cf20b8e24b0999a22ad18ad3015afee3f67b7f9c8d661545fb114dbf2d84e191ff061d7d18d5ffdc3935ab46c354f68709c8409a42d6df6dcc9d02ae8ee0b2cf4d0e5b2faf124add32d54bd3e6eaf11c4df04eb585fb8aa43b7539a8353736696d51c8ea7cd1fb5c5e419b5a6404e8474470f382654523435f010d417c14679f6bbb6ae3e5e2bc27b16310a3000517bf22eb8c478e8eafc53aca418e0f91c2e39ae154bed9433d542ccb581bffbea1274a410fefe95c55832bce8018c037e1b43a61e98a9fa1ae87bca0c93f3809c93f1d182ddb79695c7748cd6fd1b7168d86d9de835c8a548ebd7f655a0284e32e1ee8da31a0c69811434ccb8864b680b13ee2d59c17736757be6aa786aa1084c8e48bbd910e2b2bb7c952e34fb72c0e845f4c136e9dc8f6e56a4487622706e3443f210e70609b1d02485ec0dea3147d3bd3c153e0f10a1848bca30fec987bdcf8f235dd87b634b97e5d4dc15044edd5df513b779f05bdeac310df88c78c68953fa15d8cea40d6c50cbc74bafe14b5f0e8192977d88929ac463c6fd02799d6da4ab539854b012de6b8649abd6bf935ccda9a507f69cddd250af342b9784a2ddb107e370bd2491c623389b4709113a4bf872daccb89e7f736ad46b362296acf348b7001cfb41f3c534fe2a7daa7e823da55729526bcc05cfe61e3b5337d93da5f7e02862fadb70b7786cea9b899432b97f409d31f4323939384a039e457c34f02d4be8fc10a209a480eb461027fc28c999b79aaa80a823a6963aacca3db7ab9172448cfb3e77a17e905b7cb6b0578bff985e5375df28ff3e4632bda46f38bfa9a915aafd5f2ed12b036255a93fa7c2e51b0820fe11e27f206d185c86aca319b66d5a231cf815cd9f32f8c579518838b0d81dde0b5e7e03927c0b1dd31b9b9cce2044ddab4cd5e1b5cc27048373d495f3728af191fa315c0f297ea7c3fae9816565e25a822ffe5fb683394056d8a5e07a0447efacb3349f4af6890b3141259fec28b3ab9a1b1633d51c82ea2c4f0ac69f2d489fd7338cc96c4e93cc2effdbffcc0affbcbca4f64391c532b67404f85acdd742abfbda1a1d0f7f61b141cdfe1133c6bd24beb01652a93b8b648c67ac5bd123cf95fe1d46d36860a14039e1df4aff8a5e6584f7d1e35d55f87fa9267584b65f2167eb4158eb243637b0e842c54ff8e335acdbf5bec3cb7d5ce1cb86dd4fae1ad6e7f0d934004576cf376e2cf2341b99afaa6345cf5396fa7fb3291f5e45dfafa9beefedbce58bbd081c5394543a591a0333f364629d73fa57bc92b7c59c7d92e63a2954f25f62cd64d106ae54d49790edf0d248541cc1a1058ecf0893896c7b4987a5732cdf1770228251c714b254c3a609d5fafb6c604a52ae306884d884442d937037ebe9201652ba793aa10714f7ea5ca9a655a5b33e3471c71984a3602e0f3b1d2087e910d076c9fc01266f0f9aef4b691f287e71ae56210366b6181dde8d8e968894f495bbd81e5c37fcef203beccbb3f57f53f25f88cba3c781b56ea54fd49bd8e604a6dedf2c85fd05b08f9afc71cf20005c34d6a6d3547da9790702646ab5d3729ad82ce3589499c4d9e349cc65a25172d952fd5327cb588fa5c7d227c97bfbf2b4d27fdd10cb424ea483f44616f50749b59da80463651a57e2671370e4ac2f11c94b4170e67adc9c0eabcb7e33553564b30cc2b3e59db5b0bf3aa96288bf5fc057a4b876612214b14aa9d9b1e33c689b6300faefbe6dec1720e6de2e4d336f4e3813c04ba5daefef62988e0c65b01237fedb813240f6559dbb04eb15bb206f6e6a92bf1f5a969947eb84a9bb40dbfed859b19032e21578a035bb9471eb762f0a649652f438f1db53a3e74c951deeedffe2ac458b52baba175986319aa435","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
