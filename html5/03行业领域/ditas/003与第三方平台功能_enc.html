<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a87326153863b48b3d41917c8d808a0c5b1d7358f48e9813d8eeb8fb20413904f34aa858a0aa8a95ef8ecf13e285549dde982b9aa9425c2f0b2da24f8e8e4588323d9a53df1be81ba79044ffac83bbf60c30e0092bd45a5539f00622473ef87449f7d6fd0332475d0b191fd2bcb231a26addbaad4bb2a834d60f9788277b2c6e4ed75d12ae5e83d945ed551f79bc35b5b9ad34af790008c5055d5a6eeb9aa578dff7d2a3e15b86d5c698931608f95b5ed550ac7ffe5cc7fc89ce407bb58d5b2fce028a35acda4596e22f105472c3fe979fece3dd83a53d383595df8512838db1eaafc64fa26bc0bf6d5acbbfd6a46a134a0048b07eb94e825d414948e48762ab8727c379c1bbc243b764268f8105041df2e889455e35e927efd7d6a2eca9964c02f4134325cbec3cd4c5a2b8fcb611624a5a95943c14117096fcd7f77dc3f1239a2db3eeae375389f44ff6e4512239cc0d6871fa8742fd5dcd9a9e1bf844ea0008f158f088cb42f8d6f6fe1505040f158b904e661c1d6b0430d6830e20bf00f256cfc6e6cff600b2e90f9c62c5254e8fd80fc860c1002d6af1d8ee87a05ddab645ebfbf982bd085850538056d9977890c9e6e697f15c6bf763b90503857a2f42fc781466ea6233ef2fe0b3a81a500e4c090e0f3311a8a531b686a43ce07f9236b84ee552ebab47f2f04b5b46d6daa7a009af932ee617d42936154a3f0a88108591ddc08de99ac05034f791002574a98700694baa4234d4853911a523cb0a3c3987fc0905bf00061df574269e710d90decbf8214115fbcdffac0ada78be544f894d37ca6a77bf33ec48f100609fad6c8c0c73ba6bcd5427dbc1e95ef4f9e7e259cc43a3726e0599275fb5b791d79f3033740f80e68b476c228049cbf074e10c1ce609c5c55286489b136b72e15f3da2c2bd7dd05ca25815726e32b4a15eea381b236f68220aa561a022157cf9c9421dd3bbc338ce161319c8bd051157fd5eb39e277e84c8e4ff7b7537d665cc81f4106944c88731d22f8fbe01bb76a5888a264bfcc9d2232c84df2e633f62f65980cebe8b2e25d7c06a3cff4cc1cb6a2a27db314866392dadeed3069b142e6ab4584de99484cf51a0cc66ed303c55e7166d332b8957f39d59a002860fade502926acc79aaac1e82b2303d29cb976f34fdd1d4dc93dae825838e6156611b59b72c2b3de716194a5cb18e11ce07a658ba73954a05dd9f735eecdee31d884c7fd858dcfc841e51bec428c0879494284e8a8295c63dab011bf095edb31b91693e7d7c346d503c2c6a94d29359e9dcc62af68503ee97f0159e0dd0b1f2cda2d86df1563935edf537493cb225cd3499ad4da7e9dde8a4983e6b6cdc622212419d5270a0ff29897d37603c9d4741f978dafe64eed6aaf0a845e122509eb20c47ba35ca3b821bd814da1eaf00545d2929f1f1d8cf62dc3f3905222233c8b42c5d6842c43593f1fb68a975b1f2918fa8e0cca477c11e61db547c591eca3f9e0c880e50a4ae88234775254bba894a771cf07e8d5b87a72fead8727d36211166b82542502f3f9d76c0f8028d3a3e9d08a22f9cb5d2d9caa43071cfe52b095b8b0237164100e1ac0e01649ee5f4077906a4049afbbe636f1d91a72c0828251d60528b1ef4a6d2c719df64008b8347284ceaab5ffe1933adb9076365b3518a63c6348a79b73d6ac8f770ecef73ce2aaf2d69d4cb0bbf08510f4d324dc818d2943b2a8d63482e9202b064804d3e2832e1d693d98daf19b4315b3dc202c6a5ca2ea8071495b8996522d02da921b8477155711b1e7bd9d324b15ef012868cea73cbb6c64294d345d077bd5248783fc9e6a9599e2b2931840e023db151d3a1dc86acc814a4e85643ef4354cfe64c1e366f97e8fc9511565128c545f9d118808b4a24ff189f07e1f74980b2b286fe127adaa3afac4351bc33fba948584db1dee2ba148a2b59ad77b33f01ce684da0f25ab48edfa481086474fe5d09bdee72fc8cfbd6b7ea3fec70905e5b672113e89360b472cba84f8fbd280ae04b9d1052d9ce5b417f1917f434d9883080658045d3a6c2777ef84454173271cf756e614075ab298ed72ff26b0c00952d07303d83c065abf5aa0c91d6b58701994c9a000db6985e4ce072ad98005b43a3410742142e6fba52c2d7c90c7f4308b41d2becec75121b2455717a61da55b4053ac45d14feac31c834b711c2d11a42a5f3868e057e1061b00a9dc4d01e58a8f3030b5c822046abe1cd8924eb9677642a685bf052f2bf90e5f8f90e476ffad449b6e01f482243316055f80cb528be9b76c265e6e0802faff114dfe926d75aef9e8875381c6fd94a6a01d77c4d9443cbf7e7786c34ac3bc9336f1a198d2eeefe0016ccfa7e90b43da85967b78f338581d3fea4c3b82272a72ed7d2a79c62639f5e307cf2f7ae85691fb2de153cb0aa5ea6d2274e09e25eb8b0f13b6015b9ee34a4608a7a64577681124ae5e34461e5b35a3318221c482d4ee4fa25a24cabc1787992e91d757a2fe5f8a419b572471e676d2bed3bc93a0a407c067e47eadba74674d3e0f70313b99ae13355a8651433d1bf3ad7fc0cdcc943e2146c3924b9c57e1cc934598386340f0952389812f6919fe334fed41cc92d4d7ba13bd22d59b1f59cabed8b12b008691b061d8aa111f568c331f03ca45dc5ad22589f0a05db5c9cef8ca5147ce61eabf3281e54ce99b8518eaf6a0de57b98e87583ec7578cee491196919589f44c14077032466e4389c1e22aad6358108b22adb32191b7581735cd9167eded3ab36c40e5b783e771c73c04b2323c691cdee4bc7dcc70768315d137a01345c348c83105bd6db298ac3a3f2aecf34d090bc8dbe5608b63ae0b727f2cb67058cbea9d74412f41b94926a60b75611f11ff072b4be1b004a46e58020b0db0756a95150e10c33a6173734fa7636574e1dad53d4789e5999a69a8f4e5c7d31c9b71e5b1d28dc59c5a7fe46e0b0e66b7c84ef42027af50a35dd1a694f433d687f4110d1019c0bc8636cbd2b8b525e29e486558014d8cb69e585d6090d24a05cacfdff1bc100640414f3e626429b918cfb5d1628bae0d51498b6110986ebfe413ca92b80765bd4a6b6fcc5ea27dedeb31add2cc2f032a12e9e74eb9df1cfa31568b49ffb09e91fe8ba6c66cf976fcd997b5ddf6f794bfa23809755e67affd50921d489f1075b2a75b955cb7c269dd2b6c89d10b4ffe6b07d1e85cd08aecd8b52e89639915736cbcb725a98acfc91d326b92c7c7a8692fe86afbb30c06c04b51467f1bde21f763ae6ad4a07412abb227ee4562dc2e99fd80567d0821f14cc813363bf5ab720120f5ab9b46fc485c7c2dfa9f1882b65b0f34237bd89de5e11d800d13e0786ad53f6eea05a92a1e0a6813ddfeb1ef63ddf99d83a78067973488ed1049222f3f664d38f921d819b9ebf5a1d8a4463cff6013aaf5691cf5a21438f7ee1ca23ede2720002ecc960650a54e8213933527d8cf01a06f63ea9c276b99e57f630288b9b7baad6da97e5af9427f4c5a1b271f3ff7d848593d0a845a1f297263c29451a9930350995ea17e5816006c7be94178619396ea6e38cd9fb350379e46dc04de833184d846584be8d00f6e08363286d1a4ca384e2a4377185acb1f22ad5fca213fa003a68f4dbb81ab148990a64bb3895a48fb61e82ab052cad322dfb9086ccff643d3836dde20e340f31ad708dbc16c08d2b28bda5ec04c5f116794adc55d974c476a9ca414aade3f2e856df74d83045e53a8a889becdf40446a729f185877e55c631f43da50d2eec14fd5f0c09d5c45fc37423d9d93c96706128205d8d4916ff718ce807c47e010c006973045d706b2e953e7bf15030ceea75ff51de9ec300f46279ac48730b5cdf95bd27f91267de5f14d4365a47637736af30002bae58c091dc4e3ef2720ebc0d7d30f6cd0cb0637a1d122cde80a2778cfee73fcd83c8f039a730ed53fbb76808b48005ee71886e1b63053de87c4ab1b303c9b5c74fe365b08226b8bde62290a8f64a213cb4625574e9bedaca7f1d1c30ec4cc886df4d784bc8e8c7451e9f8b7b6c624dbccf87df74ebeec292167a4c4762993842116d49fc6f44be7bad95ebca551fb28b5940d58e71313e43c4e7084807f9754f256d8d2cfa06ff36d2a11ec124e7ee8b7b1a32366d33b10bb95c4cc5e6dd9a4ee27fada5df15b17eb746d6072a88172fa80a105fe74fa8f354a6fe89eb860f74cb6b4ad1934eb05506e4085ba6d5b81ed014900658062bb503cd81f5e6d9aa59c8ca664c7e56f4a1c9681eb2f99ad757a414df427913676ea24855741d9fe7e8e04d559e5096f3e4cf880486ab26dbcb975f238de6346cae0b683ff0d7f1ec6959e589e82ff1164056a7111ec16fd69a9d21b1a48c5f0e04889b770b3f430ff8370430e88c005827ba03594731d2383da6c84bffadf0c2dea9bb50146030c6fb451a7aa6640aeda13064ebf1d5a5dab512d78f4c41f481ba56ab01b3d98715b74abecfd7dc4f1d1aed9792742cc838dce2fe48b209bea4e3acfcdfcd92c82eb5ff5eff5b682149bee0fd23658474e8f2ea935eebcb9e15bd3b80c02ee7472c74207227dfcecb3aead87da7152601f42c3f7b6c202f1adcb985df123c4363d5e35d596f7d53c6fe8d6cec06d56581c89facfff9f0e30ccfce39879fda04704898b98d7e47eddfb78f864737863b12863026e78b1099dd71d1f0e4c2ed63fcf09232011cd19fedfc9fdc71203efcd65c0d985099b78ff539d6a623be03c590e077ceb258f5320cf26fd427706eb49964a8b9ba1487c905d36c98f716cf71642f467c00b921939fa0f11a35dc71cc8279d3af8e4d93c7ce471345483790757b27b1359ed3f3c9c7c9e0712f4c07e2c17cf719f5cfb055e4fba7d75649f57ffeab844c023f0010836df05a138c643e838d51b90f5b17974988c9d7b98a8f38c46b73742a21e0286f597ee10b5c29ab70a318df18a7ef133c24008b6e080ffa6060d65aaac65ff7881a4fc07ccf0a410bead7528685e2460fbdb7500ae7a54918772e48702d08f9cc7105a7dc35fbcd532f935fc95eb3837e4edb18c42bf2fdc08a28d6afa81022ef49da0400ae850eea88d2272aa6327c5ad59fc6c937baba0575d94fbf844cf44032a741b7355a58dab5bdb90a3febef1ac316375beafc0bb1915fa587109c591d108b0dbf51c509279d1e72bcaa0e4e13edc05039c81b267127f81bea89aa84077ad1a7778af6264cf7ef40ed3ff302ab7ea04f9069d61e0ceda5fe71ca56cf73d1c241266bb02fb96a68029d1e8f637e27095b0ebca11c37e5f4275bd2900b30c6587d0253cdf6f8b2c079676df5410e2b24de92a55deca3d2217f5d9cb7cf5a7a30bcaafbb351a81f761a93b5a6bd48efea06ee5f12412d01ad2b3f1eec4d30209f054bbc1b8bf1776e136304116d3a75317c5d1b7508fbd7c346f9ac873852b4f2f912c7bf20a718ac9c074d5d371b2f509d08473137b12a7a1a3651de524e73fe1251401a542df1043b04942d798198e8c50c441510f5bc54829f3258022cc2de1c496ad0b5fd2e25c27c0098f0d7ecf0ae371ced1280401933fa2c17d33659908a5f1530a5bf049529c62fd957a4e1c508387430f3115ed6d031f89db62d9072a29f7303f6f9fe91bc801a18e2c8618f081e99ee696f023d7d5b9ff88e430c04d17e04dace29dc1a394747acac19c7d662e1302c71b79a40a33f921daab95f013f90883bff1a021fc36365d3839275c06ffe5bd824f0026b8f211be6f718512ef3ad1c7029e641b4cac3fcfbbf44df13f4076682c19e028e6e68623039a5528d60d77b4c5d41c4eafa8904da5b1fe109f7dc6cee24908edf8ce24a81213f7d9624a03d91f2e6456939a54afa0ea69f45122bdd0e505ec9db53b90606e8cf4998a38d9506154a1f2b34f5b8fd18a77904a5fec271bd52ca5e57b7701413e2796e18dd38b77388e38b75a7d58fff6a612338b8d5405885ad75340d74eab28977e83cee01fcf16911cbb953742bfbf4f7c578d9c360c2f5ac28a0d8a09edd1e6752db73a4b2e649ec8aae0f40d996d0fafc825de27494bf674b47ff31d0c5ec369408c77cbd659acc29165228ff7437217f002c4bb6af8ef4632db7119834fd7117c879ff9a2a03f6defa1c87c9c89c89fb8c3f2a1eed38de5c24824e7208fca222e8adf22b009ffe2512801bc93f3fd1410db1bb41c87f63b230c3528c0d3e93dbc2cf8f95e3f1b324732a5f534a6371ea729a9dec128c00fba6667402d6e35c4813863b8be386f1c48378dcd8dc82203b8f8f90c175abe3ccf4a444865dab21c4b26162cf4d9a1a359b92eec7ae4eb55d607c55fd2ab98180e5fc0f2e6808175f770e268ef3cdbfa8e53b15d417a1dced1581404e6d57df31f0bf2375b21366a893fd9199ae3b601cef35874e24005fac29f60458187ba83fb252e427bb84703b7c23d8f68fee8a0d9f150b9b9cf931be426ce77cbfc91b9eb89a82116e577bb4517abacae493dfc28b817ec92576c309281934c6dbf8ffbc0f7defefe5a518a02db5c3c4537edb47fc6473788bb609950225f8d753d07a26440b0d60d0da5afbc71769221d2e5cf6616b2755af3a64199fd85548b076405667f2b326de3e494c686b9e55c239fcd8ca1b10469597b390b5b5c2d01060821a9e5342466b38891dd86f0b613302be1db89846ad5454e0c647960cd9cf521356e39b72240af5912e5588271bdd33e4b42007e780b1ea2787faa698e5d825e986d2c38bd76f62ad11de4d47dbecddabc3571420c2ead50a13d59c9ce2e0f6e74c2b789232a20bd1346b33a686ef1ac1ec0c028380c8edd78dd0b585a7d3b2644fe1436bc706196ca958121c00dcbb7b8d977efc30cb0b3ba456caa2086bdb0147fa8ada954a27fc9a3b14ea6ffb0a691101c7f181e876cc425f844b2fe36973598ab9119bb1ab4f273aa31f51d80f582a1681b3aa6a56b33acb17bc59932ff6a0b5f45ed14206ebd362b087406f7db820361233f5806423c4554e3ef20c3eeb43e546fa71f1c8e8a82cadacd2587346244fa87988ca77eb719db55938a36343d8d5dbc850dd5d207314ab7861a06d0c51830f1ee00d2f58d974e9c02bea4933d55d8dea6b8fb51c4349763b38bf59b9041d1bf7dc96922b3b0db5ebef3348b8562f4c4975d4e28fda69b520b32cc7de6f81c4eaed317024eb30793af0e1739bdea2c01a9b8b43544581971ef195204070b1cd9bf90fdb2f3e0f187a260047b413b0d9d1c686022b8698d3bcecfa18f00405889f64259e80b4e7c73dc833acf7a94bb59913dbaaaf0217608ba331ae17f1ad5d22b3b60037e1307f617f428555ae8342d5f03a47d1d8289e899ed80e889e9c15caa916c2c3cd26384b49fc952ef26459667dbd8b3837c20b2d563ad1043ada1a955a059c7dd15f368968b32d0bce7405cfa7093b567f3cfd0fd7bf89f0d13009c0816f82cb7391a7253a4aa592a14105b6af503c46a7f5a33cb621da52c1213c7c9d7b317652905d59300e3650b140c34c4e0bb40c802ccf93a3f23ac251a5ec64b26ed4fa60849ce7d3d72453339b9b9a6d31a2ae08ef2dca254738c6ba2442f121c66513f219fdf5803f28218109c96c4b4f9ad342afa3087f1eb9a02f412b9dc2c53c71551b5478cbc30c1c560884c9518614f41cd0e657cadfd0da62babcef4d5c27a32c4b350ec8e390059ede645ae10c38373b7b7265288e5f57f1bd28593a84267fcee50b5eab5318f0aef18bdb574da49aa2b7fd3245a752253c2711bcecd17f2dd4c49013d25b81d7699a2c7557660cdd077347c39bfdf69fd717ee11d1dbbc58f32acd1b0fd7696f322c55b17e8992a6994db7e1e884c913bf459afa6340955f4d2bd457f3f7e3ed7881b06403d2f86094eaa12640c02357a7755d3b674cadd62326f089b9bdb254a2e32428fdf701fd7be139e9410dd1640c5080e988074331beaa5ca05715871b4cd94baaa314ae6dbe01f0f0ecc261aaf38c3213ddcb8ff8f055d1c34b155b12f72d9bac5427f7375b15d67e043ae7e07708da10c2bf51dee1d14180f80a8b90a1ffaab86537ac31fd72a555f4dea9ec46e29071461bae0e20b30de90702e73d3b244a3b135d475b5aaa4d74ea66091aaf948f8a6c1ed18fcf4f00bc7f58e7edbb4b77aef6a472d6b086ffcbc815b9ba6dc2a1bef23a9ed0d7937aba37e1a96ee81d185bf04a5cc52a0a43cf68cf30580ac5a1acfe6ea86e3d49d642c243efd03aee8191400b07664dc0557d7e48a41e720377500cdfc9ad42e569a3bb5cb1399c1c34ca400c4164c606b31f237a3048e481db86a483798b1b6e3c872f0fb77359fb66ea0fca496f08ea7ade3dbfcc8af4cad4d5b10f019ee02e60812091142171aeff2e090989a808d2b97aa6f46ad963893d7974b675925844d46d8203d90d758bb21d07c37f836f63f76aad7f88d45dbbfe027cbe25878a8527b336992fa6faef4cf7749f3078644ef9ce0981093b4e9fa20e2f47757a35a701e660238d1aa0cf9bb041f234fec8060e1b5c26746138724b966ae4b444a9c1df8970269ee78378c485bb220131bbe8e44a434e0ec8f7cefa892f05264a931edc27f65b6130dbc79b68da109a1a0392e618072dab2ecf837d30d43549193185df912ad0fdff46417308bdc87477902d516eefac6499b0526e2a9ed129271aa2ab9e3d866409906057b59ebfd29e1f19fbebab82e7504bcbc8ad3a0e572b062ba84ff674e8ac8d5c7a3f86bc0b2f85b1e7ecfd1fcd59c7ad091ba142d406e6bc936926001ea8b704068082f00441cd278f87110a78664c8faca78e0d886233f935cb6426267960143de81f33e5483bedecf5520fbb919d79698addb722d2c736b6919b01927ce46f793fa8c59efeb731f632c6e70e45bf4e8dd726881e35ef0e73ee02813bec566f879f775031a59ca9d2fa543f128ea3aad24807acf4d1691efa9ed0c5156dea881f160ac326d540a13142aaa39d88dfdd5af61c9b3f55665450eb021a723d170900b2ce2fff36a958138e40148046b5d576735ce131dfe24562a63ef4c6bd1b1d72e22284f89b6ea3d69ccfdd8167f37cc845a0dbd43c5e0fd9cbcb8e92102bb89cc4e1045a36306ed04c5c71d14ec7be4f8bda2c2cf6196c4d6abe2a9ecd777b6fb8a30269e70851ea19ffe6f76f3b402f5d41792ddfc98f6a907512d70528bdba6763b7c2f856a3c260a6bd427c2f12cfaf08bed7dc5d06a03ea09b144e02a7dd8efb4f78498c90451fde07f0663711210329a12afbeea65e9d60717642137b1fc06f291b4aefbf49beec15f2080545d403c96d6b5d27411233309d97dd60cd1e0842114ba0f478b36b3ffb415785906a47d07f1d4a198242771b4c9bb2a19b3dfd00d66b7991d3d937fb4b9ba39179728a731a588d6dbe739f66fadc98d495dc286645403a5315835392e3b942dab0d4f0819d930bab33ffca856a6b0a8f2173967e8be4b9291e12ac6d3d738e37ad4208ae6081925b4f8ad546866b625ea3b02191a4048f86e0bb960a0477f146bc06a09dd03d8d99a75dc074014c83cfc2d3ea58226c0a09170a719a33cb7528b4f61845ab33ba19950b4e824d6775dd7c659219760a35099c25d364a36509eeb4ca19f1609ddbf6ce9bfef838c2be908fa05f4dc72d85b90ee57551802b38538bbe6bf928af9e0db85ab6c274a94e026d4171a11bb6d4095986e86ae0ce3997660d7e610c9b29cd5b27bd159441d193a547763b1e16598bc3d2ec843205f46e46a43d27e0e885f9388bf82f7e860146234caeb06e32108ff821c261c6df1424ad6e51a6e69ed0adba42b225d8dd307e2e91c3cc1140d53fb23db2d03351e2668ca2527fca3290aae2e1d42131af76deeeae20295a6c885f39e60f69aa0dad240cb07f9373c8f1ab59b8c339b70ec605737e0a52b5b68fe5b2750cd1a11197a4686f83b183c23fc04979f2a1b7a38a787236d9c8ddff4c1f41ce4a3e94eb5ad6d4348155c18bf41c3beb6e0819df0418b064c3019776486199b5fee950654e5e85f28edefaff6abd28113c57c4c0e0cae18668e959f3788f1a1edc635ef66ac8f21fdc9844880d110b27ba3484df8aae2d54e7e50b06663fa6250d919e61033e866c3e32a9dc78ed6f4fe1bc9a62c4bdcc416a17def4bf96730f600d4273986d17422576930ab051c76d3f83d082c538544bc49bd7829adc5814de5a39eacb5d8c0980926dc546bd19563e5870ae7b5f6d386d7b992684412c9318fb1b31e735e8a8211b8dd15ba6eb87ce72d44ec3d66cb89117a373a1f895f5ea8caf50edb1e8a05f55cb57cc69ad1e56279664854325de0b88face12361bdeb898697c49fd7be182a17429d2834dcbe8fe28b9012009ef3e4de8a301cefe71acc14b87652ea2f566637eaee5f9141ed6c79772bf99190d8886e8fc80e9a48ed2a81d14c1a15ac406167ca56fc4cdc72f99d1efc541ce6c80a985c416c17195534da48351a76e8b39754e440a31cfe0b8cf9b62c61b2ecf87ba6d72a4ce0f35143463901e9fb56bf694c2a79239173da7f25e3ae7044336ac95ee20a2161a7b597de44881bbed774763b5ea43616d480f354aff8b19737839b91e8ebc4d3138144b8a0848bfb4bd3f757a976c197d24c8bc5229e1eb78845bd65b524097e66d001c3afa4607406d1b25e0839891be98c8a3ad24b424fca36d1eaad3315faa47f79c4b72b617ece825c1cf51686376ded9537a438ca37f62d0979c69dd1ba78e1fa2ba6fb24ca0a0649b334ab889c96e31b19abc1526df2cff8aa35940a9265ebe81d293cbd79d62a25e042c02141a4d10517e8a40b0df35e135cbb99085f4001b1f71065cd0098550acac6401f1cfc51e569264e96803ab698fc785f8c1cc0ca191de70a8900694a539068121d6c61d5df180587a81f80083dc8da0efbabbe6eb6323771c4896e13a78767576ad9b793cb31db962b001d533062858d456d7e39eb367c410ece6707606e25b1311f12da90de27fc7f3ba75c0962bef563361f87df29761dec312867c7c0ea3a0fcfc361428a7fe92694d730b4d0d579a3a21790b34fa01c2aad2937a9c5bafd6e025abc476f02288da0a549db50c2807153dd3fdcf9d385140208339d36163c76233dc7edce74907d2a3dfe099d69689719d954640e3ead36d6db8134a8030046ef2c786bff9a6487427527144d65ec4763d125c66cc31078d57ea25834a7ca2af4e9e812d4d527d6fc21eae0da3607966de7fe100251e9cffbfcef59e9520e368db47a5a1253aa2adcfca986295cee128da815e2102b214f85773fcb0856725bcda1c1d29329628aa737b67d5495f66e8e9929db1eecfcea4d5806e69dc4cbd57c9e2217f50f32e7dde462edaadfa812a09fa9ec11723d8ef35b02357a7eaa968b53addb7f19009490d0186747dc2eb6ac8b9a0762a8290e0c6610f8f89cc8dd2b50cf19af15000567928f1fd18778d0274a2625ca6da077a9d4b7f9bd3954a87447112cf42f82a1c130ca11c7584bf523b72357463e5de514af20c0f87c4e50de3b6c60dea0dade11368ce8d54de48de6e7effce5ed78729c848459b7b94d1fbdd8fef140383a9d520dd1ec6363f48faf198782103bed475d1a03ed29bbb92eabaf036455dca9dac424871c7ec06552f979bd654e7c0ba335bed57a537dc4039b445985555fb408d776375b023ff1a44460e87674cb8be176aee8b24884fd648e2d398460f9f7b03af37582e6e659e8f195042ff73349bd9f584c420b117b306aa63def60600e14a37f74537cc539673a8b5c47e8c07fa787cf2bef1d5c68f73f6a657e4684222af9172ba01beb295564f726628a2a005978eb306043c6fafb37c5ea9a6c475b93b78f21aefe04a78b7ccc6e36a35d35f24ae2e293fdeb75f21f563c07a8d6c6041425e7115e4404063664ec97846b8987d79e2060f475df6a9a443ea65fef0ab2e479a4af66df60da040c64a04d73de5d4a180ba83bde8745da424c144ace5618769625d364cf1332addb02a07b42672343be69e0b415c7dfa2163f815185ff8c26bed488ebef185967b67093318541594e269ad91ecc008366d4967e52b8cdcb44bfc95650fb254b796be68a11bc6663ae0ed9886dbf1eb92457ec70bcc208fc0bceaf0195ad81d6d15f0e40090413b27c3a0e14c46d13ff847868277761d942b8495836f1149fb914dfc143379eaa3ebee4ffbe28c7a009b2935a8594a4e44e86460e49f8199a99c4ce66069742d09d094ab86503fa0f41d213d01ad5ec3b0ab4f2170af6c8e58b8c6049adb61d6e0b991c63d8fedf84725eeee10566ce1896ccad52cad76959913846193afce14ee4fbadfa727e639278e79d77c47bc2f3b84f7e289ea7c9c2764a2d651bcf4783d00463a7833ee1f388ba1d09a40b9b834757be5a5396f5bcfaea5a9ca3871f1d6b75375127435b5bd2a6311575a6b135abce8da7201c29b3d2ae54bbd25bf53d2845a6a3ae745699d87d27fa4722dfd26bc5e9f872431df398016dc63d697883b4c6d38857e83708c779fae1fb3aa8a7da96aa2bf31b4aa53cefb21cb9ae303799c301eebc9ea311ab71eb449a02072f9c748606d99ff420cea645af272ade9be9a9c8efd8724c1761c7d2a268ddeeedd9b4038b9211555a1fc729b6a6b15ce1c210356c7425699c55070b6247d6ab96642b99abedcf18764980b6ce3d71b2bb6adcc666ff928d54a74addd7c6c82bbb6f7befc4f0f8489bd8d340a78efa592c44ccece00037b5deeb43ac573dcb63a10f13b3707fd7076d7e7c0389d06288746723c1b6ecc838ff6133517496eb9102d8837cb787e7b32bac70cae76b3a4c13e0959fb2f41d0012a0da04f7750f372c1c4c31a279f0ea332723527fc13a9f73cf2ff46e7caea82e2edf15d00d9f9c7e74be666dfa0dc45d597ea0025c51c33f64cbc9e45246d9986bb587f30be427f918cb05446a8f296e1e215c43582c97b3e5c9d8977467549477b623fc2bd85c4aa12d9f4e209055891e7bd6681658f4647aba302e5fc0476ecca7a3977ca8eda9bfcb9ff63c597cb3153279a2fbfa5445feedb0e02f14051191f7a4697039c6f5abab9babe54764a6baace970828f0b3233899790a52bf8bf4cf6cc1aae27d161136a8b1cc4540a621d7c4f1e6df0d5ce0d39674416435db3c6af1456ffca8c20d655750bc00d8a514b91102f76e5c0a93598d262ccc0bfa2165eeea23b4c8f8b4cdd3eae7271a3c73ff4939db058f88dbe79ef329f7bd3d701db1d045ecae892dd42327dd40b749da67d73d06c235dcb1764a19a5b583a8993aa2e003c8ce101d00401b75184fc9c3628f3ff6d8627eb705eead6817404ba78b80cdaa93c7e7e825290a2bfac4c3e4ba119a681a94b93aac15044f463324b77467d4d31f337eaa82b15fdd11ce3fd47a3d737a7814c5c12268e813693aeb9b26ee7f77fbfaef39626ed9f4ccf6c76ba7ee82345d26ac2432e4eb1e0798231be965173b18f064d8e798b73ab2d494de6573f65422a5b1a53a7ef812d98c16a9647b4acea5413f7df666195022fa047a1b73139ca4cf366c651a57fd9db5e98490747789e6ebb390e44e82eedc75941eb9061c6c5bbf97b6ff3cda43bd5a741389bb014e93dac75600d80f55fded2d628e1b8e7bebd7337bb50c09bde8041eb7c035735d8e158354099fd253852f7cdae76a69889f7a3aee534c80ae4a077633c074fd8b6364f5e358c38eb07134cdde4a67d05304e30ae20b5960cb024a16f3ae77225d28f12882cb8742aca17bc0131153ed580286647d074affedb8489c988657b2c540fc0dc801943fc54af4bf45008b4f70c8d9dffc1f4b422edf8b32e31b9c5a234d26fa962395917153e31652ac54139a57182e30fda4b25aef9ad133147ff8aa46e5db00a8529c399e8839ab18a587f7ed0b9885e2fd73f72069c62151f1f57aecad778023a59b0bb89561902969d2187e232def43c712a725584f4451a35906f9636d38ea2e9963f9b359f541b5c1400fb63da421ef36cb1e1692e976a085e6ca2dcdd1ba0baba84d153f2ab796f3fce703830fba0fa050e581574561a52580efb4494acab3a63b0fabfae56bbdf6bcc9084f60404870d7e258d75145f0a1c692b4ca22262346700b52c64c899fc89c9547d48a1c9b7622e108f920340de5c7c2e3438821d7d10ed2dca7a68aeaefe7e91437f3f759f27dd2f6e22f0fe4639c286d3a5fe3e5a377c443e9a6ee35d5e27487587acc8d149e9835d6df3a0a34bc3d60d2ed4caeb34a000baee2772299700e497eed2a9c4eb6d9c96e2961255dc8d11efddac9f3d4cf2bb2c03e2e0fcb5879c8f76e9f74740704b3f9d8fab997c603577f1b13fd10e90a04e2b53611574134fcebffccac1bdab530fe1cdecc58ed88d03952bbbe1859d5ab462dc572f0aba7cb8a71564512eed40f39a1aa325f694aed2c68a2a8b046cefc26774a9f29a9b005d06e3c8d5d2110797afc0b9f1ce278f345abc1a287412b59906c84291633963ba358a5e5f309af06d192ff69ec18cfb62d4431e9d48faeaae110e383033dfedf27e3b911efd2f7016c29fbe9d264a3ad5d6af83df437a11cce7b831084a116c0872985a66240f3ca680494b24109299e4fb4047068beda80d45ef324fcef67600dab8ddb5943474d16281eff752aa372325df52aefb31d61f8cded264916917eae5e4d28392e61a71d8b27220fe70540810885a66c24b229d0a13dbf6d8ec7cb5039488be49881f54a1b28557f1dd73866ddefa8092611c10590fb43b9dd503060efcb9447fc5954454d51995fed5b2939e4c8bd26c32c9c597192c89ec0a922be60f322322cf9cdaac1c7eddddfcccb9a8e956cba7c6214e8d089e4704c3881f45d8b6398ebae6b47d3b0ab5d5e0cfd344e736f86c4e78e419a961813eb0bd18a59ae786f090d1b7183476eacc70c98a3d2364d491d2ed889269c81110940dde0feae44ee3a8bf2e090eae8def10e591600b4c73ad0bc49a28ace71fedaf820a6eee9f70815926e6a2933c73b893ac21f383764c56c43bf7b96e987754b7e7d97e2a25818bee2a59dc6c03d2ba631373c5c62b5550eaaf94649fa53685a530df2babcca6ac7dd53feecf3a74be71c40328d7c41f5fedffaf3403ddf30fa6aca325c2666542e16ebf9a464dd68730455ec96bf8e7d0b9065e58cea7e7eb14434ffe3bf949ebfae24118589a1956c14421a95d7d7ed90312c8c1fc36fa97d38ea0eaea38e1285b2414fd924e17996f79fcfbdba5d353cab81ee5bd91d706342a0dce315ffe463fefbae807c4d765fc54c02d2f53f79861dc66566bd1be26fc0e0c983e6a9d45ff44815edee1f63a3464d70a324f45be9afb9ebade6d0d61bae81d454bbb818e304179c960043f823e2300f04155e81df2bb73c0fb77b4f38a5c01df1f42a341b2806e03d210dc6f01c7b847a753f3dc5c322196036e81d66da5a3932b7417a32fa6e62aca4e9b09454a2a9abb7ffd4e02ba5a2336671fd51298086ad64de02012edac2582ffbaf28c6c1b1c0deda9ea73ab3b744ee289eb4f464d66d3d747adc684061cb1051883c48e909986266db562c875df682c4182a0300aa3ec8ec16d18ca22394c47ce9a0a7f06382080baefe8244dfbf0fcc5eb32ffa101667a7463f9222bae2f92d1b7c0d1cb91caec4ec914a070638c88a3164731abca5f96e3f225ab6a8ce7dd90d6c66e9e056fd86e476f8d92c73469861b2e5bd2e1720504201d03c08317abaef24f2794a454d94926aec13b6e81117c36b5a9d280d033ce9d75d1b4637f872da804f3bd73dc39f4e7bd42554a0051c72fb05652bf0bdc45d4650ad94f7f1b0f74ddc945b9a6f1bec8748e2122840cc362ef07bf9e58d35e3b3bc2b2865c43762f4d5d3d9fb87f6d4b3168bc0342fbad5c42f58cd2d36ede3a63ea7f26affa2557757c63ae6e08cfdd2d050335cf934a179a53957b4bd8478385ad2b996aced21b395f10aca660183f5768a53422127c97cbe7d0a379f728c83d4f8a28b85107fa73d0a970ef18c5c71499b9447f52944f3caf45ee44f90e7fa3d1bd3098527365a7bf22f83298035f54b53eb45f0f9f1995a949b2ec187f5f6639a85e1fb87f129ff768ea16fd8321c21ec71b123b7272d0b47a03adc2bc0094977fe6958da9b42ad2615ba16c9851a2358fb13f6ae87461a463780064667f336682afbd7795fb9f9209025537fd14c9576e235e5ce11b5d609947af0a50bfcb4c49e8ff173f2cbd6ad06dd29af0d1f4917ba87ad3ebd3152d08e8f5ea1c777f61088d6e724f812db94a67d2738be6fec14dde2e599098df0f93abc86a738c5d69bd7b245ee47bbd8420419a3a581ca998501609cb5b65ede25aee6ec6b9097f883e78195e735c47f0c9162464edfd60b0683651de97d68e603c1b6745e167828ebab9a7619553ca3d51790ad50c7213cd2e47a584bf9be2c9155242e9701a27affb051e79073e8be9e89895f94246a30f6624651854d01139f5a0d28e1b3747f6fe6260cb26e89b2f380d19e44c2334e8a36ac0603e78b6a7507338cd637efa545d97d7a67ee92b1625ebfdf842cee633d90285e18588b4cf6e62f28341bc3779d1bc2cc39760732bb51c9b9f042b37e21dfbb2215a64b1ce743e769367aa0f7d933d1e4ccafd0825f51f39db5c8c3087de562987a457c4e736e3d25da0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
