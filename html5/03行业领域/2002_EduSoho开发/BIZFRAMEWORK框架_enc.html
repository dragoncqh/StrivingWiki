<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"880de6bf6d8561fb054812fb8149054cec4d3a4690671bdbe85330472e6f4af2db35f11cc10b1a2187c923679ff7394788365dd6875511217e8f451cc1efc60051b055a4d2850020d91da6574727d178301adbc8c98f7d7dc405e89daf3e034d38a0f1842330928f86b3eda46dcb33c9a4bda2f12dbc579b5f7312ee7c7038e56020be47cb0f2885cffea984d5876a9d5bf37a460b11bca09b59fe24ed6a651300d06bfa861b0141ef4628fda8c58ce17c1518e69c5a9b9de750d468c73cc3fff67992bfcb14c90ffa18aca593d4c95b944b6f4788fc618b3ddb7e644e9e4460e0e790cd685ee595b701f7ceb9dec4665b2cb45ca8623a849f5134022d8425bfc7816ef02ab6481e7730b1fc2ed56e6f60395190ba7574a8301cd9c1d6423cf6ddee9a2a7a108c873b5134a454e2458b9dc9405d7af7e6d55e238ab64552ce1b49e2bd7135c48dfb67f37858346e2eeb9df694f911af6fa01e9e03e6bb6d94df2bc6502ee70cd4769bcd2f012d5e1a09e09e67cc78a3d684de3f13eacb16f3d823746e9cc146549ce1b46a2d5f7d5a2ab840604b73de6fb80d19e5d594b8a5c63eb935c51ead55f2c222d26c3a51a5d5b0afef4a0ed2f7819f264ac3818c31a92d339c8ac310dc58884b976f1344fa2ec8bd902c7db8fad2855d8a3d1bea6e9d6f92e267f0a11650610cc7f225b4f4267ce8147b70b22826264da68758e506576496a03114cb9518a43f7834259577073fc25538b1d3411f074e5cc50eff92c5c5c1bb4da1390ab4f8d6b6677ca89de095f03e193bdacafe705407bbc5c8be3de04e68b884036046a08f711f2627ab57bdb39b06b36acd53c75694c5287ee1fb0b6e96f89bb74e364d93e87b01fee53aa82a7d4f74d777f4f1cc6050410b35b72cd4af06cf882433de74bdbefd59ca4c357850b390db8ccfeaf76e8dc587fdc29537ceaab91a9936604c8ddadf391b712a84ab90e5a39d4ba2a337b6c868b425ab7cb22fa5dbfeefc94c86824de28122242870a77f691078a8dd18554de4a65b0dea3af19829baf41a0d6ea273f2181c32ac3f579871fce345c20b8fdc23ebdc571cbef1e651ed489db8468b1ce84431026745349bffd28c0103bc69bd955d9ac9ed4dc719ba467ff0547a389eb41fe67e6269b8592355b614a94fae5af9a876e2c08782644246d63836af9504ecbe914ce5cf33cc564bc3ad537ddd1fcb097f8e0c02e7e2e2572f47be657a492fa6c48f50ab639dd6bfc117c0619de8a77b2bf02b5b966366a81803ebad784aa61b88d1fa48033be4d1889ab05089c54877a2576e62b4fb7186864daa41295832cce66955946fbbfdad8a3742ccb8c3ed561aa3759c7cfb9b9dea77d1356f8b8e4f2e6a6e7875eae54a875f9058b41262faff6d7050f77c0ac62b0166d57762d0245186642434c561d1d4e774a8681265e84d786884452377b5b33bec4b0a91db70aee4faf02dc7d0e38d936f7f7d52375048774efa1dda3434e16ac09b137c8cd46c6b8ce98dc9f9583c7ffb88d4211e77ed707bc4d77814eff648568091c4e46d7c0c73c046777c079a22ddd59206c2fe56587f9a13d12597458972dda2a5a92432d0b453faa2bb604f2832859b675dc2082b0f9742e0d378484e2fc292ec3d73ad10ffa153acfe8d6ce4ec01e8cd031c5eb8e9ab49186f14892bef9a13bfe49dfd00a3fef651c497e1b47dcbb983d52da263e895c7a96387153d7c546404f6e89c0363326edba380f9be7fbe33bf2af4ea4cb7d5807271ecfad6a8eabc19d5412a78a11ecbf0ff2f06d1ca0f755d1b20325a9a50d56bfb0e5bd0b3b47c6f90e1176d2c59eaf46b40184e8d53c395ddfe44bb54c6021c495a22bf459311e685b904c24629158c7d79f71320af8a5384ace6e1600dbb690a36f57c640b527c47257b1618855a8ca23a9dc628958f9d4709546c95a70d749e40034b592eb54654ac6fb8489773900d5c15799494af1ac67d6070f3838659750e366aec527da55efde41ac0d807c2c737b59aebe370a848792c29d74281ab5a4b43a8b16c6d9930ae4a317943e1db493eb3f8cc25577080bd3d51c4b1b80ff1e604369e55f620d5a0d91d2d50d264fe91d7f6f043ea4bb366c7d6ed0034f09b94537e1a7a94d0e164e055cec7272a4e0d00a7876bd615c694d0cdf66c600226b38e8e4be888f1f941d970a26c94e216036592ce08a87f941e44221ff0261b2a632d94a7f9411fea32790dfcd2936566dff29d4951752d93ddbb42fc4423a3616cd8951f4c15a4afe98aac046fdb100a4f43b9c45258db317638e16c7682a8aab80b9cb68cea48d7a661bf9b0741d883c79a981261740ad4f96385ed0b2574d9fb8d690e8f56bf9547b8f837f135b195e25afca86199ac1954806e35b8076c98e77f828597dcecfa54dd33da70d11814f9a61046906bee7ee55c222337c5a8d6fbf8d380e9a546bec9bb924153a8dd328d04384f4a4b1e00de4ae763d8db69119e703bc8c42d4f3ae448478bb2dbae20bc915c2bb983d0a2d68318faad0cfcee91277571b37f8d25500d0780ff52796a545caa243bba6fc13c71c53b3c86f0846f2cab4c7549cc72ebcf289d63278819358433b1db501cdfa345e0f0007ca867bbfa94533c942dc556817409d111a6f5df021edefa09c416de256f80113ab35cec858c3164b0a4b026980507dc7aabde8b6491a5c71dd89c5cf48f00ae2c42a06003ecbc0ffeadc481b75f06a0d5b5a7232de0ccc858f03f398e955118c9313fceb64e0414b0440fa212339d0e2bc291f279deb5b74211e5d117bbad711880a46358a1895642ce47e5ea97908218089a76cff95d172cbf8cccba388f0258b9aee6d0cd3dc17273d8b0c574d033a0e58d1813ed275ee18c56e1ece6d9795b9e1e49bc8ff2e36a21941ad0efc7219d26bb6850ee78647b57766191af4b32c4b27689742bf3735e0168bb2d89eb9c7ec57c4af624bbb64104043472bf1378bf27bcfa5531679301145036a343dcff7156fd6e0df91579a4bdb83daf818deb5fab6c3268cbb905effebc44921ce491cafcdfd67cb6a012efdc80a5be14cc8f87f0a3b18e87f896d95a9c5af4eaf8121bcf99092e449ca7c14fddf4c16ca1d1b8b1cbb2fc5467a47f2bd14036b6a8c4dc3f643d1581b0669f1d43452bd28ff4a1ceca4c61263af522a38f0d5214040718e9af57cf3e302918ae46bc65dfc9e58d152a29d3dd14ac6b6b3d14ab92257bf19b1122b047fce2502a83df06814079ef0058a055d79d26f256972c33fc7c28e4eee334ee373d150f1fc2389e8afa23b44f8aee14a4c39306a12504669405568f411677e11b16d35e5c751eb7ecb412b8969a354365b0318e3ec27ae8b8bc2212c81e63b2af646b817815a86172f8fee51c75ba0bfe1bfc70e8f4affdabac3319486cb4e7cba5a5abc3b80dacafb41176dab661fe2b05ca2d979ff327180fdb36375de8c062c29de94525866b98d58c6abf75557fb30e7e26eb39ad289a3f8701e4c9cf94311f024b2e2ce5f593b5c1aa60551ccc13ff53b73ce0b21af360d3bcdf556a5f0a8c7d6caa0e22cf5bb797db5b418c7a2a92b004410c4b6d3984f3e2c23ef6071c0ac3ff80a72e3681aa5240b4c894d6a6b1dc950c1772d3db70b23204fd8ca6fe8660f45d5d9e2d320c13833cc18def9c341cbe9131f68f97df516a489dc9508dd3ca460008200448af138dc2b81af2c38f73f7794fbb72fe390c2dd048bb113bcb042b9c5fa75874bf743434031bdf4b7ac80a0643750a0439717bf641174a1d22501229d155d6350abf2426f5d38ed403854aba1f9fea8f519ae0dc110cd1b660b6685f661d9c06e5511420f6219c78d712fb26d7bab7a4adaa7c05e45a006a5c2cdef8d6b0bae5901236a5be1f2caedf352f9010db70b3dc20849b14b1f4ea7b435b0aa5e4a06ff664250a82dae41500a08800f320f17a93011619d6cb7b715f5dc4c5ab7c116ef80934bbf719019e09bc117b005194039822ba2159e952e5a7315e37954c8fde0f43e6494e1a51987e5c4ccc2e48c13647ea6b15d8d992cd04efb9e97f88ef7ec6448edd921cec6cb4d5b7042ea1a90388c0ccc8c09f00ff71e1fda0c3a2717dda20742077f591f89a46d15f79cf076edf8a1ce32db08d0566ae0b4e7657fb6da3203f280678d0e5f92b0f79292e758f2296b3d2539c64d7c3bdb04a6b9d1db2cffd6c75dc92ec25ee8bba8f23987ce826ad85752997668ba19748aa0e920ed18d9bbf4e9406c65c4089bda0dc92670b772cdb1448aa70548fd794a8e6907a24875e98b475c85b8d507b8da2cb40666702fc4b032fa1cfd481447f70b582582c43527e35c5abef555a303844d6912f93bea0d4bd2ad231c4f57ffaaf31ee5e5b88bf6c068ccb5ba7619d666c9bd4c14d9d51eda660d8de2aad210f2cc3283637fe0cba5dddea60552d5faa4c283655c4c28a7f9443cdf7909280924086855c9f73865d76f10f7113abbc4b3b3341b734f71d581282338621490a369c2ffd521d90fbd0ba467bf8b2e7a489afa92067dc62928a56751e9571fb0682e77393f5a99710d606df69f2a0d09d1a3001131b7c33f81b166cecff9bade36bd9ea98000cb3d2bb91e501c589de1e348598401696027b7d5b580927d16eef376e2b873de0dd23c6db7590a668cbb998ba065d72aed1892a21db326e8f05115c92cc2e026ca66e644b73f6418ad87ba8632a0de130b63e7ee0ce8d15af04d9cd79a6d3f46c6caf66839237cea30da2d67bb0c6c27e21b8e876e750cf28bc868929abc1b0ae2fb6739a3f804d801119598d0046cac236267f9e71606ce2d9e8db0778bf4c7a8d66d94464d526bbf924a6871ac61923e685fe05fceacfe7b59f0a29547c14375789d911a81d78764024ad0808e91a6faded9f2e24ce14eb1817ce57c6cd18055505e8af2b69e50960e5db2b1c7c8ff87d3e0a34e049647f60f1a920370697932cf54e89cb174893d32422827035146049ebbbe8762202eae9307d3c865d6fdabb90f4fa6a29428e09e1a96083f94cede67c600649d8d0f7cd5bb702bd57e4dbb832d667fa4a6eddebe25645ef20f27de8b89ae8c1e609c834d2f4374be50858bec4a7b59500c81f4d928edf5d4ac503922d659eac1ae8abf2cd6c6a8389367fff76859afbcfcfa7d38be8bf117900baf12ef7fd1bbb250da09ff13c41ea6eb8c1e24573a73a751a6dde2f4e98ccd45af78f65e8ef3bf3d7c32f147c22740dded3a26c85fc4035b87edb1652f447d8c49b088ea11770a0cc867be62ec434528e6563269f9e6ec163c673f57c6aaad266e93ff74d2e7b2dd46057eeb89a6bb2d9f8321099cdbe714fb93895de8867f07c114bf1cf9e81784e6ff643ba984314cbe0f48c225bac8c7aaffb7a628018eb2a75e2139f57a94e14f5e6031bef2e430dc67b79fc2e99fba685f8794f5341b96f8e6448c984d20f6329b8f5989b1e8405b3fc46b53167408fbbd700607987bf2ed56d0c94b8109db54812b7dd877802f47eb9ad914e948149e7eb5219c9768e38c013cc444289dc2830838260f9c1378ea7f58d7e5d4dfa6a827a9c7e915eca39104e40437887afa30bd3689f48e020fab350466a6e78a9f0d965d2097517c9947d8853d0ecbd8776bebd135a81334f48fe9896e9ec462f7f7af955443be161b379840480c2646f7844d80bab74ab8ecee32204836d76bd805b749794ef490619a8e447157994622bf899b1ab79a9e1d68af017a87e8517f92b35e3047ce1a3e8c2e8c841990c08a277fa7ff12470df9594c4fccb506e848f80f2dfd6006b9e6ab93a16a2a36c3a9204eb94bdf62341f0ddb3856ca49aab49ff759abdcd715ffbd521393b0b5001f5b421545ec1592b154018b81ee8e0152a4f24d07941502f95a559f27cffc52ebd9471d168ed4e5ab168ca6d2795b056ce7a187020f4a095bfee925a5b0795fc8b2dcb479443019c4adda8e28ec1b8202202209092258e7d0f1b7947ade827b1c98b4a5e1816d1472e709f4d15af4954a4147f37a84979914d28857fcc96aa34e1cf1ba70f02fb02c8bab69c652c580cb50035c1261cdc42d2e8bbe8a7e2523f680a268c2b2783038db407377d59785e304e31ec874e50f92c62186526c1992ec36c969f6b5a54d23e0f3293dea49e6f6bcad72ce861d7fbb3ae846c520b11f0976e563a003681cf1c30511411373f598b24658b2148b78127743dfbb89cb0653b2db57e4e85d13e167df16bcd924b4889002aee2c9467a65d280e505136253601f89819f07d09f7c70af8f9cbafa90022981a788c55308f921cf77da3d73fb973493c699e8ebbe7dcf60415ec04044062e671b4fc082b5eb9359698c581fda6f4b059c2256519e528eb23d0e9726b6aa2458b554782b739b31b232a84f3a9b1dcbdb5b9a4f49928619e06bad2792b86762955299b3c4c0f58d6f777bc999c32d6e20c5b9c0e27c5323100ee5ee6e373136e49e7a6cd05ae8e49457875124855dd09cc83b50ffb5e47109d097ba3471f57920bbe640b76da66a9bfe01d7793638dbc51974aa800a9cc5f998852423c56f1af22b491484f4629c4138732359e4d043afd62facf49d8dccc0e33ffcbe4733da2c33cb47201db4445e09006e31826fd4eba6a6593ffb8becb2baab82732f4ffd678d605b5d0cea18dfe62a9b88bc6883173452b4cafbdeec27f8418fdbf42642c8620206f7fb77670ecdba66274ed8d890e215dbb53022a862bee9731c036f5fa2daf37ad060ed8483e40173d906e3b30b918f54381934e98dceffa816be1ff7ccfc5e1282aaf0383fc95ea177e91698452a678a2f321b56a5845c08d89dcd650b4e3bf47b77b819f6fb415e2d5cbbbfbb1b1f91e26c776f9b7c2cf6321437723ea3d124694fa21478fcbbcbd17817c528806429c3c5abc0d211223561d83980ac3cfe04f70516d22d837e603a17b771a1b766098a1ea7f2047a041762adaa6670226a03caf105359ca99bb692101fd5f89c1746718b42578bcf6136ce771128d0d6cbbd83ef7837da8c2428e4dafb944d5d31fa7b38a61c1f9569806767164dfc8f23cc420137d4596741cf38ab556b2b34ceda52fe2ce1eef8a3a40772474530591ad4a05b33fac6adf5cc22f2adb73ba11c86b70de1449c382fc8ab5a88f2cec94d21d072d950708977c3faf6d7e0907eb18453919d6fbd9fa2c4b252a7efc61f4ed7c1a4df5646079414d8a7cb26565718fe05aa9f9e6a88c338e5d5d5a38ffdb29f3b223e4113c8ac63f1caacb97462a40168589abcde81eb0d2242b1f0044b96b4ae8a3cb9062020d9733faa8511113e31b689741b078b74d2d14ff4506e9ba0bb0730276cee3121e850cceedbffd13cc8b5a53d72af496180a77f0d5981462f80533fccda5052ba15a8c8268302299823125054c93763a5f63287efc6a0ad3817a90e052b714e53b1479195605579acaee07ab2c38b1fc0e18eea30cdfa64b4cd59f060c6b2b7bd5c9a352173766e08ddd8c64d26a63d52d4fa788e8f8fd5f2b5de99eee5fc881ca52ecb8ae45c2306303432b826db2b30fd9efe7584c070603a28c5b27fdf2901dfc8f53cffefdba85eeee713d5cca75e09d7a9c6953543b8d682c12c20e073689262c6b9a8a0780d4b16dacbfc0488d2a06ffe46d51b32264c5c89a5d346429cc2c977cb06a82f09fc09142e6eb5056dc30148454c4f798fbb8c2cb42ab8f4269aa665524120460183501a3e04d41855a88d464b98023e4688513745fc5e9a7cf828d42335a1078263c3cd7e09b2f1bdb6fc1aa091f52bd95f2ab58b2afcc3b88099b37d9653407d4be95dfaff1df917464ff5c09ca8875e38c01e55d872fc26328d0b0b5209d684eb12de3ed0fd04f38f8a7a52562e0529399431ea765e256a6b17fff37e7766cef532d7267174e77c5ed442d6f3cfd0f9c969c62420a9ef6368feb3a81834672bb20dd142fa942554dd2ef2b7ec5c9a9c54a1ed9e7e113f1f637ed0558b376502ba7c364811eb1bae225b2b213a19957020daf4fee6d18bf4663776ae67765d605249bf9754a68c621f82f0b1d169cad0ffc5f81d42f25aef60628331c33c5d43253f9f5a83e1ca312b1cc902ee266ddf289ac706b6731e463725b469a305c519791bc4ee3c88e29168219d3672f238c69b73d3ed517ec49f511c2deeb53f7528058a5a0de912421576afa0ef647ef22b6dc26f5a264a2e88aede0b335ce5c6c56fa989e60a695db15f70e929cb5ab1c7ba272cebcf2d9d57f1cc4d96ccdcb9748760b76916820c5d3fb2075c19a598b1e5726e13f52133615933aa2b4b231973989a126a14b42a5ed47d97d7f7193828792df8ff932acc56602c8ebd7d85f96a2f68ad6b5251a28d360723868ec101782b69261ec7602027dc610a13db2b3c09e71db33a3373f3e0964f73fbd093b504b23e949f83c56ffdd38ded08ef026f88feefb422bd281adff00c3964a169d10b0b1d6e692c1b8cd9ece4829a70844f0cbac14460039971d6e952ae29a650eeb63750286b9920f0858af126e3ada394e37e0cb0ee54ec059f2cf7050ce00d88435e053922f7c5f448f1725e6e62ee87a3fbe2df954a1c13923a477c3637737d1df8cb4cca6acdbc45f06b57d69786317e02ee088a7fe56d08bae73d08aa425effde09b6dae59fa539638784e9402aeb2efd0d3b6c3935692fb8d0e0cf20d94ef9e02bb0d4ac77ac8ff36bd271a06086c9dd27d3d91789f945c2f9a8b2156e370d45d1d578cda735ffa0f1eb679085087929670bc8ca1bbe94ecc7582d2eac08bea517977314aab2f60e7caa8fb69d09c8fe246a27aae5562fe93a15e2c4c9c6df153badf8e289339c740b44190cedd1a9dcd0ca395fc9d5906e216bab1dcffdfe77e6fea548eb8aff109627fcadbf9a5573059758872eb1e5b871189f86d5a46682088621bc55ff7cd542d137335f9d66823bad8d34621590455cdad0d434bbadce941333bbeb0771467a38f4eae8a83663853fb938b91e2b1a1dff47fc34eef3dc096a744587407f1d6c692a6cb4155d73426a6346800d3c01c11e69fc4559d7fa761ad9b3a576d7b4800402f6dca7084f04c72d7ba27d19ab1f1962e82f035f23223969fe6ff79fbb3a4b6a87e8c46b9dee93ed0d519aa677698fbf5855854c19a1d4fb241afad26c7a51e03f089503ecd3a8f35ad46db04d895da438d649576571bc51a631d76b445d09ebcdca702faa0d48e81e0cc820cdb2007023c017c984f587c1148d7fee302424f0945029e5270c1083454aa96aa19d630efa652dee58029da5520f878b0e96eb0e72985d28b3ec792365876c53e2073ef09f6b365b87e07830ad5bccd9ec99fbd842350d7fcbe9119d3cf946121b13a35d43514d54de7adb2d8bb79cab4546162c473604dae4dc79555e8312cdadd4fc1141357390e7be2a2494b4a3918a3accf68c90fc413f19f22d042566f34009c4be9092f6eb390a976b8c6c967e356d003a36b88d6fb5f64f41c08ee79b26bef9af5312ed7c83c0b8fc0c7d992989038c6da243ab77faa4cc84f9b04dcc21ff1800f86984852669fea55242ad6e8cc5bbd9d31bafdb82265405a7c33efb72ec74aad00ccd906b716d817bb2e940136ef49b1e488ad7fdc071cb388b9e7c7f896265b67a3c3b66a9e130841718130f50bd615348576de5743fd592bf883cff6936100de3785c58bdea4f873cbed3ed81b3a4ae89bd020964ddde6fc908888341b5aebba59cee2fac89144f0a844352de8dca6e4836601decafad4fa8e2df9f3a844641377c98e9550637d44f6af7f72ef2ac68d5a952d25206058b645488ac8604768771da80ea09bc00bfc72519be364a49b6e5e0e1993fbb6c1a5fa5aa226dbf699dcabbab2b399e39e023e1d74bf52522ca352901b3be79727f8001532b755b593b7ab8bcd43ee4e4b56be665ac7a7add6cb869ca8522bccef2aac6848f97872b78c50fd7ac594783cb30638d64cd242c962d5c24d67214fdd1f6e21eac4fb9491527e557ea9dd3f82d1863729a52cfc9ffcbb27b28c867107626a64f212840f2758a5f6f82d410526766b2aa6b1e92af509871d6f03668fb53af4ebb829fa9c574f022b28b36466c73f5b1137d956b9c0dd6198d0ec68ddfb7f46152c2e77334d68f784e2841d91b41f3ca0480fc462151ec4a7d91903f64d5e230205ecf9aa3fea5426a1aab95a0bc07901992befc7738ee36402208f4abc5171a4f0fa7696c35ed8e52eab92d814483273eb1437b7c0ac1fd268bc51eaa53e5af45eeb1f41a5c31c935a67a12d311f9a6dfef0c86be47955e1ce8d54451eacd693de1038dbc0d622db510fc8707efd3755050976bc2e25a864e446d7e6cdf15dfca49429a59a48d870a5bbbffcc0818365a4b60f5de2de5631b8000e4ed1c917bf15ee6aab36183bd25f5e6e7f7b49f8a14d35c9aecb1841734062426b676685f136d05c7ced31496f0386b85b9b9236613c463d8b01dd9acef124f4b808b5f91f94932bd0b9db428250cfa65728a86790ac02f868f88e8e0ad4c8c51c5dadbd193d126b41a62d0be5a73aa31b2ce404becc28b3c4fa24d8f413a15d145bcabb7a618f293f5e250422d18cac89afcc32e2924f0a62dbec51dfcd7e76c56abfb60b2ab59b763ffa127d657dcd336b661c753208b3a4428d24dd8cd327f08f90da183c764e3f0e193817cbc7e18b80baa9b5a9030a6dc57deecde576926818ef33ce0e42a64db391301f21e46974a0f95b17560fb7fc71f667b4120f263a1cb0f5085ace08e26c37fdec52e826deb98a63ed42a2a2638264246e2c87ccd1936e3e575c60ddf6faa5804a70a9ed0a4e20439f30c25057b9db351e2c7e53a0e0777bb91970e63fe6f3e1b18e57487c2f66ee6786482a805cc77e3a2e9a81ca9338ce2160a2e9d7cdb850bf67ccdbbe878d960ab14ab4f853d52e9f6158965fb1a14ba391b95f71422b3a3d3d925696b4bcc77c67224186da7ce9066a360ae5254116859c57c71af46c8bf7e50c8c702203d9f70fbf87d8d7f46b485c6342893bc372f7b2f7a6e93b3008e29f60b9d61a5db4a4937161cffca50a51a3eaecb5254bed005d704942fe7df3d1290177a1c49bccbcea42b1279c2a49daefc329017ecd1f4ccda80861ef5523b6e0cdb7c5855165bdb63d0e64863a3c27f1bcc6738ce867657dcfe64f264a0bb29636f5138935ac241d82ce6846f3c8b4349887890d3f07ab689f489669bf53daf067aaf9e04f2697660be5937a265522684923725cec880dd80af02a2ffc0346ab3d0f78142e63c487ae2bcad94e86f0004c5ced55906700fc8980a9f612c911c9cb05e472aae6f8c30e228edf4c713d79eb7499ef9f44f8d05a6990276f992122c7f702406b29758442a177c2cdba9dfd351021c1322fbc0f91e7a17b6f057df0b05930b2c40f7b6a7cdde3b6f05aef49f3fc62f52121c9e837ba1b1ecaba199073f4caf45db3b2a10ebd7239869460bae282af4e973fde8473387bcc5282aef623b7d3a80da59ab8ad4d8baf736ecd39b19fc0498e8ee85cd73467bf72ca66ba73323acdd719bffb6e69b29d0e53dfc5a88d2130e853052132399064c74bf570e8ac6d829760d26396bf4925e68bfe073ec7f903b911dac08741f33245d8d192456a811c120969b75df282f4101b6dc917cf92bf287ac5484b97b52a8345c037c78c95db802ee84ba4ecca14da4ee5782ef57b66c17e5ecb5023c35df9aa7b59e5c1f26f8c155676db2eac632d324fc5e27a28a8d9b9bcef962536ec49e7866f709c549389c78072bc4afe0c72adf005efdc806208645ab03273d220289e4985b1eab503fd2fadbb6a42b771a8404d3221293a7940bddcf193d7a1f7b2d1f68cef39882536c27a6d48ab3b4a25b2630f732fa8a5563f3f208ae06b27abf7d3d3bebeb0fea10454e1db081c9b05ac7e1bc00a841d0f62a3b338cf348e5eab020010236136b707f3bcf460b84a235ac87c55451269738b57d8c1430f48e89a6c5b0c950b3191e8a8020b8150f2d270d61d6e2fd9d14cc9a444d3d6414f2517d03193cafb4d8a362f60b94c34f4b0d16e60a4b91e7ab7f7efbe86e232ddb21900b514132d9cccebe91093deb662abdadd68af00bff10ab742260ff544a96cc7ecd445ebf2fa927de48e90c92770a3ad55e6beda304f1aa8992e846578a8d84e6b92942e3f99676e3babe35405b429433a36de57f4d1dc5e7892e43fa5ff3b74857dcb11ad481c800fcd3615f882ad59202f0950d93ea3f5fa448179e12d9839a87a90afd516180f0240dda812a40430736e9d7876e5fb38223ac40c006725ea87f5bcb761657a69188c33a1e808499c8720f3a2ea978ef6abfb35ed0db8089f32b9fc2828379b199d20b7c383347cebeee7e5f3a1448039878deab8c39f3486bc2290f832ca54749cece11ab9db815920f480c12300c786e1a1f61d23304b9bbd1d90ccceaab1376db689dd07224395bbbaa1e4daf6afbe5c642f737fd072ffdb6d5675168d3161030912befe2ba1ed7178c2dd6f1c5b38f8939aafcfdd7b5b38b95cc689e2da098feda96631accecb3535101638da7e146783615b8b3ffa97178a9a96fc643d83578a4502345c1de9887813ee42d48f731ec79cbc1407a37f3fd2b90e7d696e2bc8c6dd653dae88757ed0e837af17d66c4013683fec84df26793ed132e4c04fb856383f19954d4cf95a8f8be90fc2c34a9e82108338e545d77a1b051b0c11b5e56dbccb52b9e2454ab6216bc9b1defedf1b3a0225141c840491372c64de7fa76e299437b21c2d6989832091da144aee490ffef101ea722e73fd45e40af7968ed39754e09f236e8b067138d695e66bd9a4d2e61847563923a1b9a9dbebab3ac1275e3b5f826a3f4c4ac37f6c73088ab150a26b01fc4d60cc5b995e31ae2b169dba368735622a4622f7c25b103363afb96051d5be2311eb346fbe3a2a9638288565ca2ccf87cb9c04623c06b3005168ea1d90faca24c6f0b8239ed0469eba81148f475edb1ab9a03a5e926befcefbc83ee4b707517b6e00bc58c74f06928efc1b3fb871157ff5ab01eb31c492f9fd8ef3947176f4ebdaa36fefc226fe281d68647afd65a7bfd40e14195a78c2128c4f3982cb5827d9d1517f5f28433081a921ca5ef2e0192a609d1dea528dd7229c283af9fb83f0c323272e5f27aa157cd04a2362cf07846ba5ec4136cc2d5a8473d5160ce0c4f6df78a68f29b78609cbc7e5386d55ed2857f440232e7d3523a7e63bbae0835d7947418dc590e5fc25358f853655ae320d895373212020512cd488085265ebbd4627545d81c4fe1d438b2c8b2798c8fda8c35d67094df353eeb1d2ff55a89ecc3dac94f43e2df404bba54ee7ec0bf2930151d9c735ab511feb0b11987205466f12a39831c35676a8582e680334c8cc2405f8abe48ebc41c74d6ead9544ee997c669b5a8dd590574d343efb7feae27dc8a9294a86e90d57ee06108398466908160bb83e37a568f1345772682226d21986ba16203a4181e79c6c42a5e3e5c17dc69acd8e7b533268448d30c2c4b6f5e9a748dba4a8cc21a794cc82dbe0cc41f09e28a44d4b103c066bec9b3374259ebdd1123f6f78b9508e3b268a93f1f289e2ff0d5d9eaa1917f8780a37263a34ea1a450ff2436f13b7337f5b4a34a31e7267b724217b8df2341f4ec6af832062dfbbf92ed01857549dfcbd78196636111249a891452195b81877b4a3522e29961f4440f41b79b3bc36cf00a4c98b22b38fcd9179ecf3398369c069ff02092b6154463e6343b12df274e72ef69ad611a3925fc2b0eb861c2ad8329a51f96e1f89091d56b742ccd417d46be78665d3be78e96fa288bacdff34bfcb68ba0d630874379176a81ae33158beb82a6ce2697e805e2efe2756952abad8b6498226cb00e1dc1bf54ed4e6aecc190481d8d81582e4c9ba6f6f00bd567a925ae4df8ef431d0a5da561394eb04ff15b8e5003b90403b36dc1d8093f05916d846457e13fc647b2cb17fadd346ff4e3e724eb4920658da2e47c405af02cfaa82ad44ff1a0b9f81031b3037a1b8ffacca4b1fd9b22d66bb009f8e00b5dfd4d283ffd795d3ebbe1f732c9cca12da1d2f7bff0b11fd520a6919c6f1e566ba3ac549b6449e21c18cb97333b1f63764b16f3e0aa7646371ed0f9ef52bfcdbc86e628b7f987044e75f03a468491de70872981ea037eddc3c9a703b62d42d6f97667dfd3b6559be82d8c1287c31710f7005276dcfff5ddbe401bffc807ebf9ea645f0c4b8581d94d5029cf5ab435698b81ddd1442931f23809bf305e233ea774016da0a13e354d7e30f15bd3605b7f04dc6c593ba48d1b0879f2d1dd1d348bf95e86554f9cc84ff960d6d7df410bd1e0029c87631b1f3ebd4df525a7d1d79532de36c1859817f3f522db774c624587208e9ea3d6955ae47dbd3d0087c91be2e81e4def7c43a279f51a07b6511ebf600a11f12016192982dd13e485302b043e06cc23d75210814efe4cd2852c3089ebd4638a96cdea7d7c4ed9e235674e80ddd9b933028f076aeb26313340d0116323408c9c401286ebf91c1a1857300169c90b710768900be1242cfb9fe468ec5e9990dd6f954401bda8bdd1aa6dbb645d86dbef5f84a8369d461bfce947e836051a8c1ca9534436ce27030a1f52c02876d81cc5c6ddcab6783a13a1aa603f421608354704e4ac9b4dd2a9e095f3addf70b4fb579e0007e79106efb368f74a97ba9036d2a63775422e7816c475bcd7ecd7ca1ad442812b2ce5bf28ab23b1dcdd6740d35584923f610c095df39175a566d593a41b4b834939efcf49476a0374568a80b53b895cc72e079283c0960524362c856e41093419a726bb3516f2fad39e581a16b06a87ae705b8c604019f1158d451c25481cd963ced84a35608c2457b85b4e7635003b4e4c87972a8e6efc221d3163884543bac05ee041ef950f6d68a223953919f9758ca3e7648977a9e0952fe083850facb4c6601dd84ff9d8147b3a71d31df36bf22c403b1eb992dfd6a4c099b556b12890d88bf7e8f8b03950d8532d9003d66f79e437af5458c462ee33a2ac6f2078c5a1fba4720d30966ae4570c18f3686815e30a24b1857c973d336ebdc672380a61049e12dabbc333b226aa0ced3c12fd4775300b0b1c344bb25fb235193bda6f194a1ceb4d28effee60eeb08917f4e69ec743fdca7b23d6e1f54121cd92a37fc7fd2a1b665df94a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
