<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49e4975665c87051b9f04deb3a087599e2ab800b428c30cb586b993781ec0783a5c881acd0fad43ae11b0669a4e302b0462882d2486e10f67943611623db3b92677f8eb045b6cc98a1445b59c3faeacf0c517bb23f229b2b42fad30193257cfdaedf84e9942cdc4994d8146b2931a7a12aae51cc74df609ac69eff8abe5c89fc00ab203e29c24511e1e12d0b9741f55ade150ed0cdc54ec4287ee1dca43ce76d3f9e2fe137e600b0b33eb9d3ad39a0b28da4d51cdad552a597c25894ec5f1dcb507d736949e16ab05b777c958dfd62fd81d83957b6f58eeecd2399dfe612e934852b1b8c3f9a7449dfc07b2f3794ce7de1d9ab0da8f4b91d3517a1d4e23313b563b369c054e77651ffa3dc8266e0b8da6d28bee9b77f01c653d53d69748b045af850bf124d1e5dd105a0787555df89e67aee0e706fa13d80e7457e8701601278fd414f31cb6b29b10d4559ece78f76ef1a774728e41560ee334e2d9bf3b5095d0ddf898e21d223e3b11d27d4b855a80de5eacc069369b0efc075e083d1ef519c8d75363467cb543fdbf6ef2bf92af6c2e4e121cfd516488015d5f3aa92f95ce61dff80b616dd90f9c87f83af2da6a693f53ef3ee4fef954bfe612342297526c5c86af9469b1198c06ddfebe3ebdb07701aa38d4f73554634a6c58fa103487f30cf930f0388688f95537fed2b42f1ed8053d65296b0c7eef2e516bf49d5b7d32a3c215eff65a1106f130e21f0acf07a362ff879e3138d09905665e3e8c1c86593dca72b2d4eacdde6da8d6b4dd9901a87e292f3329f0668a029954d4222b10814c284c0538d02c6361c70b67cec95310bdf6f0bebd28de6dc447b5d37a71bc221f1d982d4c406c90b6f9ff0a92d2ecb711867114631244dc18ff4fcfb8b7908df8800b3d9fcdd79cccf2da7eefd2003dc37e00627492a9ff02a2a595a4a0ba9b0e86237f3e4628f5db555842eefbaedc7d647430f57107bf6d7de2dec4695f40c1b686360378477791f0f08dccdf370c4073327224c2bf307b1634462ccee75a41477ba790a0d9fa769fb557435a219515c6ca9bc269c42a1447e1ff9b172beca9479b1ccbfc683520adbf24aef954aa664f764a4a24e1662c7bb0a69f4460dad3246646680939ed7e45ffe1741f1d6cd2a80c195b4b46ba96a8e3d4a1b42195abd62a7c2a43c7e53382c5a3516ef3f591a0c872c46b4fc4fbdd2c4c2c5d8a9c3bf3c0ab720ac2680c6e4a575a352f3e21c5514c93e3faaee4f3cbbb6b4f2b01b9e7a620e425d68ea49277042370e18631104004891fa5887d14f5b1507ccba182c16133a5fd99135139e8a69e8a270f191df5c2df473438dc9e7b38f4c96416c3e1c9edbf04b146ca1716c8ee9ebd5fd17182e4facfb113cbe158013406a7a2ff7cdb0b94adf8182e620b817e837c3ec85ceecabe6d823a3c43bf3fae2725ff93b399e768ffec3d754fffe85173dd2c24636a0ba234cc87152fb5523ab54bbcb70dcf4a57f46040ca372a4ac209c5f0231524e166d7c3b3859d2ffc25d88da263eda9116d1ee7cfaea6e16b7af708d54c8e82d10990b5673538be6bca02cea951ad0bda6c8fa852a39a8730faee34d6f326c1390b4f21d2a5493988d9986521ab5318faa68066115493305fdffb54772a26f96453dc10952ce444a5460e9fc2c79263d6cd4bbd6d421683631e9f3c29d70c0632342375c3e8906daab390650f86a1825aeddac9deda871e58f588160b20dd3c630019ca70a7a15584cdbe0d2641e570564403deec2b4ba17a0c258dabf537203a934e6f580c11df46e1e7d618b06827802a444670f7843374b6ef270b9b1fce05a373919dbb23a53bb8ecf79fda73f66e8d0a9fda8098bea87b2d4e6543bf16090835cf3ba508f592b4f436a34a4eb94afb5716774ea0d8f2a0d046a63db2d9c08cb50ee206bedc5dcd4b429539e30921431b806f63efe912512d2896a5989e289c1113b15fa3b386720954311fb7e393b84303f06d35457009cd44f1903afaf96b35e35c94519a4ed3c02eac7015b9dfd66938a71433c3e678d68e7bd864e353b332d6f3c2673b27013ad2cc78a3ae3f5bbc77ccc699c9745de686cefe770b950f6faee51f0818b05e198023bcad31da2cd5655131f86a3b1a43f0cb8959b1b09fea5947e324d71f2e24996002a7836aa073960146692f450b3419377d1517002a04c92d5ec824c94989fb1fd623cff58d6b4047164ecb25860b785569219a8342f3c76f0d58d97bc4d7de85a1d05633315c3b054d6922dc16ef9ef4d58669a0651dc7273d206164f151636e9cde1b48b00258b2e08923ae6579593cd9258f4d85a6a94393ac3740d1f8c3a1d23bcbf3e05c09bee9a68e35dc48a53a3d0beb6b13f17ab57b9758b7c47bfe883c24aef1947a306a5488b847ccd39c2cbd44b7172736cca29a730b0a6cfebfa454af66b6e8dafd079acd4c744267adfd04c14fc1044ad4995887b901aa57437137f7f2ba9e7c6cb78455b89dde9c7e933a0308d5fd522b897a5f3e494e12964b3368509bb27574c17bb2048c7812499b6820027cd91ba4d16c967c3a8e008aa43637e44aed8d7390e0125f1dc69a6cade2644ead3aa16c3819fec0022a88c5fc5efa644a002c1a77c66cadd48b9f335b97272fb85336e4c941d019690b5393e4f8ed6ca66ac1e1500e2787268c139fb38e801d8a2e324fae095f4ccdc352b2140058aa830c4e69487adde565680e2eb573a3404fd521b1cddf433b39952abb6bbae7b1a18baee603f92b43a17b902f09e633b5be6c0ef8cccf592252feff52a469cb589fcff8fa787645fe8b181c9fe1242ed8f5bbbdeb278c853e56a0883bae430de1eac1aff0e42156f5a34530d6f7eb9c114473482230cec236a79b40ab098a9d2d4a1cae465c6c07322856d9e92cc8e2a18b9ea93df9e798c1a82d560abf426df9a7028d9d6140b3b335d5cd9f65f2474088803c75639ab155052ac7a75ce3c124e261e0c10651059d530f3e7562c22dfaac49838fd8771b08b929f520bc73e81a3e9e3e3d9947c575a7a64c2ee8268c169b1d37788d03fa2a03fb4183ade5c356db9a49298730b4344ac702ad5cc24c1f3c2c3b88e57109f035293622152948cebc7ed98a00a39ef08f852317857245980c75f83e8dc48d6f05eebf7a3a85d8b7f06d3312fe08f17817c450c1101852924590782d761373d7546d9188375efd1a9c27d527db4e86574f8e6369724747f59dc8797b5e779cab636b8e829556919ce76564166fe9f3b0124b5b4231aab0778082110138a5559658fc301f2d9e19cb94b1906aa4f4f247f9d8637332066c0c152ab4e2c4697a36e3e1df49ce7351e54000dba3e7a194490f04ed57f2ba2ef496baab0823164f69b4ef5018b38d4f5da225eca6e849986296d8ab9a2011ea4d1b021fe63b151d101b7a1cd159216647ec04981fb254e76f9e9bc2c29cac99e95487b51c12af1420f1acfb66e34001fc764e6f91013364eac0a2f938b577c2a3ff4f7d0285a061b74994ff63e145603bbc6b263162dbaf5b5c91e6d0833f14e0fa7de3f9fc420bf1e879c2bc160cb17b5c9fe4fb5ff3e4cafda64ace048cd66663f0c954e52fce25a8af47452d65eb28fa71401b427f43815ee531b1f6d439cdedc7b16879dcc08169e38f6ec02371f5925cb7f9a3072f184d6038eddda1a32960f71a4913b68563bb8467933d882c5e64281b4ddfc540147a9b0cbd6ffaec11b7c066ee95f6294629f92001371e401950c022ef45c5a51287f9727d78cef3c350ceeb4fbe1acd8409f77da8912bea1967a0c0df7437de853bc2827cc2786b995f57cdd7d6b8529f0eb0a08c2b8869c32cd49a4e42b76666865f5d1494e2df6fb8efc6ff88d45bdaa7dc99e65642ca05c2c2ca7798b937f85bbfeb062479bb128d33b7bf40f20fb2c6ff206ffed79cee3f6725156ad765cab50eb8a78e8eda6c5f010f2d9dcc643a690c59635d21982ab947349cfe7dc894bb71b5c17ef8845b236c4cb56710f9e1b4d2b9037281ed0e2578b014cb268f90e639fae7d1303a899fcd4923fefcc69c08a8ae48f11d6218164c45222eff2a56db5b551b584ba0a21185a83925ae55f5dd0615074b9e1a187ebea93e26016023253e2bd381b9714bdf5d8010db345c4276a6a72d23cc0bab7527b982127b6b3d0ea8806773fd835256bd0b85899a7a5b6fad12f26f0ac57ed124b0041255e82df76e192aa75771e73a69b0ba40c24916c4557c95da6618e48fe1c96e46278dfa6252a3ea2e82de1f817799dcfb18c8e9d5acba67f174d088cf033a905501987d76d27dee4825ea8f75faae571e011f60243ece13382c4b97fc1fdef0eb5c3f9506a41e8fbab25cdd06e6d9f9fb610e4f9d89457062750dc073325c0b6fda8d7ef375348227af81c51661c6644f261daa2b6b1eef4db5a91d751179cf2bb6d9d0580e772430aa08684f4f029368c1cca1cdad60b8fbc1c0c1ca85dc891675e6e7b1077b8ecb26deb7ff24f0769b1b2fc3c5b739791bee130e439e005c2f76ec337636025733c97d20145206130ec25e48a82c59a524163f6d130c449629ab5839bdfb05997b8bef67a2057718cac81e3a0f1717b6b444474df08383f2d264770b6d404aac4c87dc3f2376c60eab805b8a6ea3b39a0b056fba75356bfcc0bc144d0cc30c1cd517b68aacdf3f00201a4c6d4a1a5ea2925d70b93cbddac97aa627c782521d2c23057ee99949ca212f8bcc6c055009bdfdf2863805ad8e9024786d8577d5adac59be4e365471fafcbb1d1ced110d153b01fa764b05c21eae41ceda5f861258e6406c24e010e5ad654d6122a6f4c0a8e98ac10ebf9108395d7a7d1446b60ef42dcb6efb98a2272cde72bec31d211ff6d2afc582322a4e2835eb6878fa62569d5f40fa1b42c2135ce67972097780db67b925cafb85398abfc9171fc0c23c8b0dbbe2021128037285a619c97567b2d690b11671536c1362f2a72b09211ef17fc2dcca4ec264bbe6503922efe5867fd72edd7a277bd6a6832d676ac2fe7e6da4f9815a327991c5e0a8a6f87c03ec6898a71f09ff16ee69c08978b55bc7b33d1bb3cd1bf4dccd8d2edcd7cf3a9900bd817c0406220c4ac476ebfd5afe7772e118c594fec643a78ed214ab212ae1676681295bbacf4c51b6f69ebf8ef92bec4689f5567edd4652ab2d33a63d41c7b36a916a72c8e185e62892dd718d193b7ec58aa8548ce2efea0d5015e92241c206e1770dbc960bc85f5180f3ca3cf5f30fb8b182046bb1fead55551ac399f047cf57a9210a674b730d716adb1a07aaf341eacbc4e905783dfaa873c446606bcea591df6a953d838f047c427711b4247452584adbb961fb2d3dd4f66a342407be3c2d2392b5a9413c7d5b85d00de2881523bf306d54af2124e01b50f86d493fe3ce449723a34285f33a5fd4998239356d0a24c35e54ac7069d7c8563a08b789e94045a1b649f01c3da7dcb7943d6b91423162a9c7e963d45ea14d94fddbf71fabfd5a2022209dad0135855bd13bc7a35e5df5ffe14bb55082aac678327fd5532b716e516a691e7e17784a5c780b9e38c174534004f4865749a6aac176e73c9c7f39c81f7e6dcda804cc0d64dc06ae4cb6d7a195f74e91de362e41df034c0107742cd47637dbbc03430ec8de8efba8e9442b0bd8b5c32b5c066e41bf9520b7179a2758617deb4a04a6619c66b0af6132260941341a00320a11c9503c5a40e19ebeaa372f75d0a7b2ff4cfd4c0f392316a92f0d3ad68b668b1cb72aa543ed31a298517a42afed8b95652e687caed333c198007cd341743390c1dc016fa302ef8e198fcaf0ba586c742975851ea8f1a76103dda6887a78c642e9fbbc157eef80bbc443988e71fe28b28d17895716cd40a67f7637a8d013ee37566176e8df87ba2691f42464743a29fd5a9186d2ff86fb98e0670792e811f3cb7e2a34bcc2a94c076a9bb89439d836b0085d289791dd066d30211a67e33d3fbd8d68c3a80701bafd5327f288fb5b4311246d0488915566f466dffd34baad400c12864c3067ee4bac0980eed5ac2e803cb8c833cfc3a8d4e701494cb91535f8b7a2b40394eb9ee8b3308c2342784be114b4110cd02851d2f2256997ceb0b86dd8fd886f846fb26114cceb692ffa2aa9d993512813fe2127dfdd3bb99bf05c80c78b6a0a318152a3adebf4b241fcd520814fb1dcea310e647afcbd65442f3db7cfafa86edab676f5109097d6994d473556d00f2a7b1863a79fc87984284d599da3784aa20963f67b41b28221e65661cbc630d1f1240a8415c38e9ac8f8a94c81da000c4f24b44b64439a0a8a9855dcafbfce4f01a6b5bd744facca347bb2869fa40f42b6fa8f014e248e31fd3de04bf682cf2d1d02b52385e1d43794ca6c683051f11cac117c4b8ecc80960eb85013c006aa6a7036b8ab97420db650de2c05a3b826e73f192a1cc705c6d12188f87dd7fa618147bf3dc9cbb967f045b82f12082017f9c5733e6ce30b33b49ef2296c2ef07f2d63e5af43098dcdbc7aa1acf57f8bf9e3fb8c93b30d8f99f1b20506fff28af29d8383db129640d72522dcaa35c7ddf6c87143a91901b82f4ef4ee315c3046cdecb170976671d5be3a9c396e6c8ade8739685c4994e00258838f8ca0bca9506e87c754ab6bb9a9860977982f0227a368d0a319e6f4eba6dd2448d0863297b5cb84cdf31b240b171bf544ef5719d5b054f244f448b9eacf1c1fb4a75b65f06b9a83eeea545ab2f3916acf0d20b6181ee77b1294117deb622b5e7c9a6327791bf5cc4f2e598091e81037d766c618f4886ca845a5db43078cfe79258c82fb6b1f7dbd4ea8c8032721fd0354e30ff18a791f207b23ca7d8c0767c57987fd810d0a229352cc86a0f1cc46ecc98530b3e184486c4f192b0534009913598064d65f870777a96e45454a0589ef2d62188982f024708d30a862becc47338e8da272fe49b8bf3142c8a22d49e221dd93211214b58db6c81426807069ba8748ca59b5e19df704cf41943f5c80a87d5df6152b067b79d14b5a3be167ffe9ffb3896245c8057bd1591523f6e477b47b414a3effe7a479c0c7526592cc8ed5e4689e0f195d6412f36c2e1b429176c1f689b0c7410ee89dae1187be7b5f583629cb7b572fe279d532cec013afdf385e662eb336bcd0184000c4073854561511f6004e136ab6f76fc1182541503da0a611e00ab9f55925f9eb1060b662591feb3a1cdbb2ebe26887a3ce2848fda25241a5a5421ccdbb48fee67506d09e262b187704b7c207d299976f66a6e7faa1081cbefb5ea9c1dd0046e3011e2bf58226f05c851e3d1c5d7e9337ad6914cc968a72a7d6fb7701a2bd2ca89db72c76c290a377c37bc74816e1710f1e094f1ffbbb5a6b288721651e9e2db1d623f81feda4ba80011f17d48233e44d13a4dfee9dddbe6df984cdcd890b2061b975246566615b21e49850ff9f50d9a6bf0fa9ee2a87f37bc3013c3472021ec248fc51635d0869a91cfcffbb6babe08a2edae883d5f1b0a2e1bce39dd60bee6b1056df71c64b0803061f9ef642bc1d5cd771a065013a06f35763d648c45a3646b597a9328ee8fcf1c35bb251897d8c1c01642dc7be16bf1781f0888ac1a964bb13f4de4439fb524bd03e0cb79113f8c64f4ac14d7ef1b50cd7709b80e82d4c301c764b6c940acde9463d50d54ec1e996482a890967549e19ff7e3a26b98056ec931b7449493ab87b7a3d71f264c7a6130222388721ec455ed177dc53380d2a9f8a94cab9d39d54c310d4553bd85729aeb4fc4fba0b2613dde82c9c6284e1cb839132a528f5acf2f38349caced04ce3b523627a391d901c1f2f3847550f5869c6ac083ed562addfa934ffe98f53d23726541482a474950466a5cfbf1ea00499ea0fe4ac379f8f9949211ad130a561ab597a0fce1a8a7af0b2d79a2f9746ac9a04dae000f4af5ff8f0cc0aa593b5bd270921f79e14e54cbe59f564212dde9b177b3ef72b0590085e0164d05c2d608352f1e8c61bbb9ad62419d20c42fbc8acd5a87b8763ff6e34879c0c631241a286c47d2b7a6e73e1e2a30399a282d80b4827cb5217cecfaf9e9a9a74fe390af1ee9308f780cefb8e60c6b84e39929674a5e7393efdc520e431daccb010dc2fe2a7b52cea60f0df2822826512cd6a014662ee8f1c26e61f11ab98ed07fd4b7d5efc877e57de6465d65bddb5cc4f389e23554eb6a8a4100e542b56ef6a0eedb31a39ae93d20e2f08575df83807b453e8dc414138f990077d6e7851dec49e35a0c57cf13a5098aa19a3debe42022dd99e021997aa51c9cbf0a8fdf1bad3139573c69dcf181ab22598cc7e9d7775c986b72f89ac85b7098583c8adad81816c80f2f2425ee77808091921bdfbba4c9213811530b94b1e65c9c38788c2a9e3646947fe490a45696846f85338b4e47155b68f970b3c8ab70daea62d11f72a2690bda215dea3a712461796c732982b35866d6e5e0fd327b362bb8b5adb64849bd008ca1ce3e965af670fbdaa70204a420b56d5d847a338b08b07e3e81b588da3ff9805e0d34b3cfbaaade987f4da3fc1f6efef8fad118b4351922243c21cc41cf01922c7bf440c1187e08a6a4809440daa80c4455287c612aa887cebcbaf6312df67501b5fddb90f1f7e701a3f64d6fff29d76333e6ef9fb3a404856628da322b31e22913c5801a580e8c394acef10a8197d25a614029b51a68f4e176b0c26c5b7d4a0ad1598f693418c2e083bfa5ea848c6aaf9ca7eb5d820f77363658f6caff6cc8748aec170e62ef7e34787e9f658e3df96c814f313294b5845640fedaa9ead868895c115a7e2faa95814cdba65a4e903410f01f7011038171ceab6d8ad86e2ff14c76a2658beae008bc62e1fb7bf2ad7532b1cd1a1f66d70ff5ea73aa22927d1e64c4ce48d46378c7b748453197cd4f431e9b5df7eb8c7982662c9f52f1b4e0d19fc0d13e9dfe0052538293a06793b71d9c715e2c295336d1218255e39c016c0771be59aeb0a34e8775a608e43bc39001a5f1c0ec2da81544c8bf10d379a7b0702f487b56f14011408a848118a73ada4b2f2d7be6078dda15d80bad5284bbb18e5ecdb828220ec6eb589074f4cbe73a3c51c0af91d3059131ac962775324ae04ae82553dc319cfb37849ff4945a492286da19e5954800fcf4be865012c83fe66b6a0e77d8ac2a02ba82a5869afee1edb78cebbc49da978114b5a841c37b951cd535bc1ad72eb19e53c2a736d9edc29d880ad369181b2356f35ce1ecc28629e69fe5524945d3458b285c9483472e9edb19e515262b329bb34de4e6e4f7db45d997fd298d81303df29e31f01e1103b6f34cc8f41f9dbf2f01f090a2169d00ad72cddef76366177faffb648a4c58688de58c7ef035dd68bb2ce2acc7cf5b062096cc3af99e1935ae19b44ec73a97fbbdbb1283135fc71ad671727c3f8a1a7aaada2f4ff59ef90f8ba06cc8220927a6f21e69434c5f76fb263cfb5b930d31bf9815236ab98b8cce396967f988366d094a8425219dc7a916fac2a0c5fc7821ab2bea3ddd988bffa3ca6718909955721e4a47969019515ca692c544f5122b82763b35721889fd2aaf6c8dc76801856acdcc251d8aba5404534e7b1a4259ec3d6a08c793ccf351901944565f0ba93e998b5b9b05b47a6247616e43e4b23f834fd3d68d3f68b71976699e83f0db8f9feb028f9a5e4b516825405c454497aa9c14b37d2b271ae433c23793b26200e8ef1b90f1185df23feca7b55e429a3123285fac3711e939d65763b8ce7748d9de085dcb7d1e159a46ed539a5dbc75774311f3cb7ae6155efdfa2153997cbc9f57665f6b5ad82f496a3a403810f440f0bf7866fc1971061fae021981f1a6a804128f767949884d2288ff7c2a00025af692e2937d6cf77b9794f858a375fb38960330c0d32ca2b9c5a08ad3c32fc07f07c05c472ad80a974c70c6ac37c59cd1005c79f02507670edadc16cb575430acb0eaf200f3c94865b2ce0266ff63b621587f695eb37a7536530495f709570ba7bb441a8c97ee0cc67d929a58b80e765d94c250f2b7fec871c576911b929c94d26d2e08c21658ed17fd98bbda5737f8da5216db3ffa04fbdbe52c2e137a90e7de5db47d77df8a1b77401979087c972de4c0e896f65e2de660517cbd379276a2ee34fe83ddbcdd6bbef74bda456cfc0b5f01dcdc3aefaa2dc5972809f3115448d034a762ee348e4568b9976c6587e37cea302744280a0d66a89a5fe78e34658fdb4aa58102740bfd81b5a55d9bfbe1a7ba58103739fffc21f1f52ed182c5e5f8b52f2018cf7ec8f2894a8c1b45bfe70c4e1acc9204cfbf6efdf4507f87794a95030762c8006f531aa91444f9ad45a7aa977ccdb72e5e4579002192bd3858daf140aafc466c0bc9dbe1ad628495db86639ae9a6f0b37f7d10695d78a6a6e96eba56f983ff51680da461e550e1bbb3cefcd07febd102ba1e3a3220d375d2b3fefb632dc20be1e2aa65ccccf17574be56b704e3e046334319015d95e3d9b5fe1b9498617c393795c9f427a16df2f437c6bfce40488f71102ab41849087a7ec83ce06dbdf5ee5142f7987133e6a28dcd562d5c31119698aa56c566e8716e9c3f4a8a85c9c97fa0dde3b628f2cf967b874b7cbccd6e5182ea06d22face6a76e32a22674b8a66e8c76f86db4350a3296fc841e2ebafffd51227603877281430e83d8102c2fc14bf23db73c7ae7abddb1666c750bc496a7cdc674576420dbf04c7f36d0f4327e9789c78b6ce9446bcd941a82fda4726004338b979d77959902e8a3df57e4536ef20ffab28a33e459494c746785a54ee8db91c63b5355f25cca1e40c8892ec0a4db571c980adca2d014aa62902b1ed5cfede841088f351fcafb1bd16ac273ba66f3ae856a374127334f2b01e0d6250f515c007107916b92fa6cb6c9e6fb00636a476c29b1574195b7f964e8f06f28dd9ed4741069545896cccb6b2aafb973353b4af511b3397d9d14652436a4ad8ee56e898842a8c3f79c8298e8ec23d88e1633debcd8cea9ae9d3e17db2877a8f7ba4b572d5f8252abde13ffa4b83fe32e2effef25924264f470e4b258145b7beb872a3e2e15df9499c4f273f0c75d5c3ba1a9b63575e9d291cd6e0ad3cfb16923a8b4f40977b6f3708d015bcc226eaf6b93e82836f24676002089acd9aec48be677048633ef10c4986eb2dcc64007dbcf03bfa3348b0f977e60a3cc9c201501e27a2639bfeb62563afb25280f0e05b0759dc6e0ef585d826a92ac914cef35d50c48d80e373c5212398796020a77fdfe8fc7c47722dbbe20a92f57198f289df92e7a1c534d5ce09f0b8ac58b57eac71834fcdff1350736ada72f94a5c6612b3e79d50d6591622e4178138ea96ca2f674c3ef99c67b06fb59243bb07443ae0e4d25e5f254d0cbcefa30c63f965238db1b8d6668902f414175a92486c70856f5eab21024e646adf9d9082e54250e0c066c89124dbcf0f8692437a126ccf0d3b370697c4cdf83d8567f29dddc36feafaf1041037eb1c39cc57f22ec0cddeb59b9afb50e776f2224fc89d0e0511f621e531169406e63a5a0d3d85e1ee08d2be8e6cba3c39d30192da829b4df7261464a1da4533e3df088584c31930e98fc22137258ddecfba42d3b8e9ddc67c719a5e36b29d24c3e7e915a5cd6f7af2f7ac96bd5d1947c1e96aa562e131ff9ef4ea0d82a2e6861f6c78ad3c10414778f5fd297f6939eb31de95a1ba3a588d7a0d761e24396bd4a9507544d8da82e4e2d4b00855146e8585466a5c266845551be744cc60d9ba175a4c4fda8502be4d820","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
