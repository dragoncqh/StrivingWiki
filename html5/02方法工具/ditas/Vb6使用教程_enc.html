<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6ed5b1734f8f6d8c617d14329ac89db3222219b83bd2a5bf15ed302ecfd55845200a264b6ca9613d540e364c982ab558df5b6df2ccd0e2c6ff7291e95568f5113257b1c8758bf67aae81f36150800f257c3f97142dfca7ffa05bb54ba8ab47643b0562386e365fa4cf1123af87d961a557826fb34766384fb68f9fa4b87e8bedfc3a30e76285dbf4417c664a9481facfa4cbad7c898335ea6ccd8a268a821a21252825ea94efd89d3afeac5bc529a071a3b64a5ddb9c2cfa6df0f2331df9f34b04ab4ab5b76f037d6de810be68474121aac2b51c1f82428e48671772300bbb7dc614cef1ef56740f1177bc141b3837ba92ddd638fc5ed23e18f6556d830231dad026adb803e76597257711f913aa7efd7d9c2fa94e692e6135bbc287d8c635862d8443f5ff74ed67a9e5183d05e8f79d4d1f941c82ef7251c2d16b43e47551f48e624b874b8abc663b076678444b99b9ef887f41a43c49da7cb212ab89f738e60daf5957dbe59c1cca7b07808d50bd2af338d4b9f3f199788063ba1f2aff6123b37ae6206a981e8801cfec09ad5daa6788b78e8672202143023b9fc8e1745fd94265d892feb284cbcaf96462749077de22a3ae18f2dc4666b57c88efde6bc7123e8056438ebcba6fb205479273927d099f3fbbcd3e6815a99229caef0032a4055e703f628b394ed6e20b2e259f036ae80e89692404202633ed224670db401de8f40841fa07c86b652a9f157b204099fb22c66b603f419ad7b3950c2c536094a6bf8fa084c7f87bde3f23d566f434b82eee3fd70a2bc6f7418501080d3ffadf822a6ffd821ef3a0f4a4f227914322537032405b30840c4bf00f433d476394d65ccf46f39996bd001ea9347d41c7ad4f627b8311b088f793753233137ac7ce38580547c21349a465621f79ff025457175248027cac547bf88ec429ee55576f7edffaaf41b5c22fb2c766c852050569088867274b5374c01d237c7b60f93f75f19d4b9e8a6e9630665a11e4874c0d040feebafcaf5517431535a9c0bb1019b945cf0419e01ef320009a1fa0091d11f74e45209abfe85247554dd4405634e72e8d8bc9ead99db0ded4ee5076ae6858ce26de304c4669d5bfd27a616eb77ade7b0b89544b5e74202424a4544bdd9c7326256f166d6713ae53ed0e44c38be01504211b713cb3cb38de2546b2aee5e2cedd8695040ec87a3e423e43fa73cf4f3f809b98f4d26874346abcf14ebeef94ac17705029d4e0d003ac1d3c17a8215ed67581f7b82830f6d6a41f77fce8f80107d91627757658b2109548403cb5801fb936f018583757f15f7717d18f61d84299302afa04129208414f29a92374c8cd7e1612fbd7a5373d6e4c9d4b892bf9fbe9e242828794f32293ac06de072ae9d4be19b11b0868096d78fe6a32764319d991d690d7fb0a4d94fd0c851dd01599797f2366f5f0897feba62b1cc16561e7c06e46f5e53168fe55de646255c62582c6395bcbbb803c03af94a952a78215c1957bb9349a4b0b7aa138ad8d2801e1ede2f48174dc99284b70f9651297a81e4c0c2a734f54c1623758167e841237f517417dc87030aa56b225064f6290acd3f73aa005d19de526bce179736a94f362b9716795b92db562ecd025a3ebca688ec34be2d6cdc2dd905208ebd6cd69a8b80b45905045e659548d44fd042ff3864ab9e9d6849ac29b54236f7b03ff7144ad6c40572455e62d3b33654ba3798f3b7a63cae197c11361601569089dcb22f5dd76b1e5f6bddd6bf763cfac549313e5384f75a2cb536e18c635b643ed77f858d38b15710219a3cdd1bb3fb6ae2ae02f9ce345d6b1c5d123a01b613723b34a79021e130322027208afa57d90feceff8a930342ee45af66ef465f49b7cd6ba2867d8942181637a7d1de7f442b847d2afa46de3ac7393094f7b64d9e2c4251612fdac00384bb549b5d30a070cd365ed9c9ae8912f029d19dc97c22c232593a7359cb0d60015b4cd945f3989209de480048a01c4ee972cc16d218ec80f261eafd3ccd6789a9a86ec56748e0741bfffdb0f677f723dfcf028559e60b96a905ad8ff6ff6ee7144efbd96a995503dd73b8a2f91ad75bb423201fee669a9f44525e6fd68191901bc999169a6cea3141249f97df91e3c1691b65a544c0f3fb1ce7252cc1d3aaf31ef1cfd666121c9cd82d3b8d35a77b86e0df9aae71680c811f83f3836112462222d2bf26868c767eb46066bb769418f299c5b2e69e09a9adfb2eea9e83ca20c3dc7cfffb69dcbb15947c285bfc021c528b3b15c75ee53de3cafe9b6e95883a7c6b71313702b964bb40c3ea2c5bd93012b97eacb40fe765db912c92db42033c4386f62e781ff983a89756762e09caf53ee1519e34c061d76ef73ecbba4eb832087fcb3a2191c6126ee3276e693629378566d7614b3fe980b10e6bff12ee4bf4e50f40e4b72fc593b6a7e941271ef02930a1f6e05a4df25cfb672a9ff8a708a45f217b45f711a9856462d4f370fa9815cf24b8cbaac6b272ba3ecf362078a6142085f6a69301cf800690f8c51929c66fd41d2a4a95caeed7d115b333c87e422d92c6587981233ad2c9b76b60198eaa71e9d67ebf67aa846267b139a07c6f4f93ec2ea95a5de1e4a48bc6f326d4c5f30879674eb2eabe62a1d35590838d1b92c807114a689ace06f3be8ab372e48c8a6e917704dabf83cd9d673426659b4da664807444f3067ab51c914ca3124533faadc4670b2d6b210b1d1a4993ddc31bbaf6e4d181a76cb95a10cf4aeaa12291d00c682c4b1edc031bbd77c9c9439f51a29bc35f85af93910e62a1618c092fd176b7445e5b202209d2fd98ea90a56082de6c24ea037783d5032a7f81c0f086f9c6a2ad88dc923e33eb44a31a1758ed7cf296d6f032d9554d96c3b7b0cc932a44cd19f4c346980f93c6ce54e48da36a2999f71f2f7f44bea54423724bb6d9ab81f69f9d3b214f0dc1b2435f9284d416f9ee4dd46f79df035b280cbdafc101faf60851a4f89e950b30583d118b56b43f526632873008ab0ff3e468de45f6893d79a4990362f9b89c660f26568c523a64fc832048c31e9b852ee88b7f8e2e547ab9d788913c685a1839bb825d93e28c31ecc76c592387a819daa125c7f127bb374252e0214699a72a253f2af92fd7901eed3367bb2a567ede5acac557d64765f4fd5d6be140aa23bfa7e6ea4dd7ad5546235f6d0db567f772cf5ee7c1d1e053f29765602064f15f48c678b3f556310bfb3b5112173d1b5b0472acdabab9e470949663c2083d7677f299069352c51a35e4b23f5548b3800a64e27794a5f8d9201cf17c26614853fc2c1161ee543b4baec3affbc86bd4eaf34ce67e5c709559ac93e61fce34c42044ae2f53b7251d63876189059bc73fd900eaf4a29884efd850bfbf1ceccb3b100ffec774f8c7836636b35cdac02184501b9958ffd6ebe00610ecafd9c70bf59cd4bffc77e7fe88fc642eca7016503c15c25dceba653a94a9dec69d2ec8a150626f194476d00c3bf8aef8ba31bb01ffdf3a47a3811603adc2874607462be68db6d6034f27a75ad3eda1a237bcf9982970a58daf386fcffba1853c2a99b32b0b55483267f33bd881bc55f387ebd828d18a84865a4b8a17038f9bf5f58fcc455ec8753208aa00d55d044d21cbd260686b0480ee63f6cd0976cd0d0ca00fbbfe6030c353efb5ca2e6bba16c0785c02ab8a69de0346ce5f6b76d02f1197f7158c6a2105b03f72e65277b94532d27af763daecba6ce1137f63e5efe5a0fb6149707b68e6403a26e9ffee3c6c689cd745f078ad31b105a354c29015a96629d166a1ae929b17f21136d0180eb71958c24ac3cd060ea9be823ff58db6414385dca5cc570f43c9a0b96bdcde99f22fe86fc2be3e54231367e61d76e7098aa898e55bc6059daaf66c729289834cbeb6827daa15e28791a183218ab7660bbd5f453ef3d71da8e166f861240feaf0921b66bef2f1bee66f7800e3622773b26be3f123357b4c797b4eaa74a21cdd772ebc519c8dc16d4e83a70d10bc24f3fa8dfaa8c112f667ce082f7c215e14b3d037e5a097c593fd5d1b22681e1762a4b5b2025094a3aea449768c998e621df396c70ac3a03c180775368e73bcb7042ee05be4690cc9afbe906ff9b2f02fbd1959a03d1be4f7c00cf7e5f0e650d0dbadde15313add4c7b4a0a60cc043d12b3a93d5c290e19a87a98a8dfc435eb6d3d22d0ec770d41b3d7d9a0c6c328a974a445f2c81308857f55ee74ab9f6d78ce4d173a0bf21d66a1c53fa9b902eb58afcd43caeda14158e5369859bc1947df809b1cacd5c6e2daf11722fa9812e855accde9711559ca0a89b2ee69e7b0b2b3a2db8f7d4e074829c7f411a2436cc50d5731a37bd1e9cdc09616847b450057fa720d7d9c2d03ad2bc5428e978c33c69b90dc469121eb69b10af7937b4885f839f87bd2816491e93ac626680cf5f67ae2b5c951af8cffa63a066377295eb6919d6bb9d5a81b9b0efb3e2811717d50c11595c2aecd2f18b50e045dd827d283a60a1b3dde72ced860cfcd4da41cb66ca11dc5ce342cda073f5b454d209726cce510ae25fd9b89a432df076f99ff0ac7d77519c7a42df14ccb05c380de7b8a181df171ff3a7f67303dc930c703e79d89c736166b85dba46f8e2744bc297434e904a5d74f4cef9f9992e116409f442475a58efe2fd68003dd4b92026e6a0701b201cef785a4f5fc6fc2a0d233631fa256aeccf018fcae47659eba68e9b85481b91b770bf6f05fd48f48c369070417fec9089f3b8d0126938c01fa6589eb96cc8bbe9c17cb1938ee469ad247ce3028d158fd526cf9a2f25f3c8c4fb18abf54c221a514bcfe24f2470cdd27865239881a62665c39b4d957ed66efe294ee73406173e913b0a0289ff9abbbb5bde24e50d37a1bc5c3474a1a1978e6c6d0008d8f409d77e2285ffaa779addc31911c363fdda86db5d6de01ff92e8d944bbb3de6da2c594cd5032ab9456d850274e3dd7feca5823c4882637436aebbeacb5124d5cdb25569df8c1f9cec9e6d845150f9f449eedeb44ec60ec836a4e796851b9c69af13bb60c15f8db9f1dcb6d9f337f8d2e6e9bcf3930c3224a3b97ac12b4d213bf71a524a56cc998c18cbbe7f18fe029fdd78f0a7af3f4f61123b198c53f1002d64ae02af5825a5ce8fa0f5f16af9344da47cd4752d9524e4729e64c56035bb2707093febe3f6cd95e9ec3abc30ae4e83fbb2e77119ab817366164998413b154a0ae4ab4fa9aaddc1c5edd8a7ae3c551ef10935f14298fa9ad05e9176f2fc8733ac46518c2273c80e0b35287aea4b97e48636df964bf53b2b9c0718e607f519e0e301b70033ed8b5f33ee8f6cfb6149ed01239eaf1de158b884fcfb56c852fc1ef30b7009f7b048e5399778e674d391e61a418843dbfe899acb7048e52a651bbe42450cb31e77b8b915644d747984a106bc71f8ab8980563ad16952832176a0897921ff4040268e5966d6f9c9226826cdc18508f803dacd374cdcbcba3d684263687876adc5e7620ae019ac3ac03c99a0b8d2fa4bf59d3ab1b6a66174b9a9999e62eea040756061e37ceb92404c013f50bbfb9285a83902ef910707d657a41291f934549cd8b630c891f13de2731e6075a4b5c058a9e78e637b1be79163f3053cc207fc0d43171cb92bd7f0fef12e0b4b53e913095529d3afcc4a86f2f8af5734f7a223033fac5e2b15ed68e27bdcd920831872aef09c19504f92791dd98bfa53b6df9101809f2a7f3bf0a2578d9dbf496dff6e89790285d3aa0b91818f1fd3b272c73efaad715d40293acf6126275fbfdcfa233e60d9e9be49c7e3b732c098222265af7f1a9f054347a392ab020adfe9097ac7f1bb9a05ae7248e511d774a68aea292d708cf8bb137724f34f9d8480fb77d3c176281540068ed8b1ebacd4057f3cd6543521799b3b906b2b6bf5dd0b8a10b582ecb8522ad15e90bbe6a1f4879aff37e97d9eb2b34e9833860e03dbc2f7485eb8abd5783a2464ffb2000ffeb7bbb3d132d610ad0e96c405698aa082a41dd4c5f8c49a7966a9fd7e2e48bb4e8ec01e468d82f81a0061081e7d933fac507ee3f8bacdac8d9086e0fd34447168248c8491376c80596c2e522099e549858fe2b5f18bac357795eac66477a840e4326b04b9ee0e9ff1d564494dbe26c0ff9e2ebcceac821964823e13f781baa054c0273df1256a1f3ff7c88f8d2a886e3c95d7d2dbfb75b88c1dea4c8da7d51eb0c36f1118b894d02699420a2fb7448241ee1f521d7cc28854b702abd146cd74b32f9910483556b937688c5460269ecd9f461cbb1dc90f6432d83731839872d9aad693cd0487d1f911377bd69b51ddd7015cf6d63281558a79f2e0fdf48635ae067b7a760327923bd11ad99b1e7c8d141ae88b691fc004a8e42cd8f7ae781b657b308d5c818e3010afb37e2346f425c3bd24a788130d031a81fccc7d06b6a86a96eb60f2386caacaae123d73fb0ada973e3d275cd6cf251b6a54ded91f08fb372d27e25a348dc77386d744bcba4fa7b7da441ed027ded8159feab0e53e57ed08e0ac3c4db0ee2936fc35fd74641774b073e5e5f3d0149aa228521a1f98166ff70a7b5864c3b76405efdd4575272af11bab688b299a8c361b1fe840bc84b462a2c132fd5f88c03127439117fc985c82152abc9a4b8e8c319b475b7b2e7298734aed1b7efb0881492859f231d91ba5d83ea1cbbaf35c2c45159680404790d857d38fb2582409de476eec82d5b00053ee821d589601541bdbf057225e7e31ff7a19282fdb0eeed2c714d3519221641d3fe428690a9cc75c99b91a07e12a1bcdcb3304f50acafcf2fa8876dc54e6ae2a04a403783f6e12da1704134fdf16c5d93cf2698f7cc4c758e541b93d2151f12585aecd3ac56c5fde0b7f91d044087e1c890facb1a5ce03ca5e1348daff7cfed1da1e43b69b50b3c26762ba8c1f79e466950cf7ca47234baac5c195b4dfb362317e9658391d9c875bf9c38178c2e0f21004937fba368cc5a46aeb69eeff440e8bf685749f12d7a02d1a8cb38f94a08608ef573253e95252c375ab76bf0619352b93b5a263a34eedc5b1024aeffbee8e0a4c155e7f0f42f5f1ddda0edcdb4d3902151105958742da97fef3dd3be6b5ed8e6dea67183e61212feb2963edd767a5005c488c5abfd2b3f9fb842f3554b794a131bf2aed87367aa7132ca9310856d6ce19922c12b4a0224807ed2842ae0e7ecb75bed1f457e6b49ee5021565dc977781be1853b6bd7cec062bb2b9b0c5155f776afb28e96e1f0e909911ef49c30ad0c1051f5c029846185b31c11f1368f216c0fc7409b4d0a3318d61c70330f814e6477a72887f2571866411be8ae663ee6e1e19f6ef8c68889d5a9037dba920f925c477eaec50516429c000815a124c4789f988c491427659fa2b22a505fb5fc8ea279506f685e54506b8300e2fcd50286d910f2dae69ecebc6e97487f1a216b5ad0f44533d7bb9fef86a5db67513264ca63bd7f3ea65ecefaa2968c55af51a75cc5dab0208b2b4909bea4eb0387c949e281e753755d044e60085ab57f05b94f8e1f969d0d1a67ae4a69f906758123f06f9dc8dc2dd1a3dcb7913de4ed0c9f124302335d0032f7cf7c69d722234ff85b16250a717794c780880765730a5b613ebfe11c606cd5c1a2944e0dcd27cde450941ff8f9abcb5d51a4915c41ddc294b3532bf10a24538ee8e0acc613a9caf0fff7470580421f16a6066b3c06f5fb5c2649a373ff854d7e322ff491e88cd93a8b254b83e253f9c2e304dbacd5b0ebe575cc55d98709340eb555fcc5e9ac17cddc322155976d4ceb0d0c1b526f7bb47c371eb037f25c934c946cfce9d7e26a9058da0ec7ddad9b6177ff0a2251a8825b77f8136e776ecccd60d92","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
