<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf0cbec1ec76d06f522e5af4ff79813f11cd278948208d526cbed888c150ce2d57e9e0013ce34beec049c91195152d6d3d268760ede3ed14b99418fbc67b37ef301f1d8849f0c13fb6aac7775c4c39eba43c663829159b8e8f31bb6c88e2a438833a1f8321df3023d6eb6d887b8556fc01024272f9cb97f388b600fbbfc1dc650a3e4331f58d46eb9004dad4587d1a4eff68a261eab39d5cc4746240e01a932683ad3c9fa75cf8abadec9ed96d06f005e153f54cd4898fb505dd71005b0caeb11a46ed96cdada6039492ceae5dbd80152e7205f86bc72fcfe4b47a65fce4b14a7482d7ea07335a72fe3710652791e2c2a4b46815678269b45e83912c0226ec174cbbc675606b47559bb0221e98f31445b9df9b106f72d1c5c0f19ed60f88986d50719894898bc45f7bec3cc647ba4c26887827135a184ca264afa55fec769d106afc0ffba58c0bc1e2cf183b9b4fdffd3792e33bf9f5f82474f63d39fc3ed28799f0115e2cf53347884f0fa69dce8401f7e338f9f714306c969f20443430ca12f2d5e23848760268c2fba634b3351c85862c1d31640fdbe554ef1f56f770908e7700a7cc081a71b7ae488530cadaeedf3f1e1fd8d321f8b1038f24bb02f34ecd1688a61cae69bd4af4aa298af8c06fd1c3d0571ef4c54a15cde542aefc3e625cee744fb059caa195d6861337fc9f72832f804309dac8df038a5523924678fe58a147c98c1ea1cdf86241620d89f3d1eede579a2946ad3099c8b643e0dbf99c445ffd7c0d8f6b051e84a12f058c5e498d553633f23169967ab4ecd35e837c782a4def9fc7fda47a8b40e4cd044584ed136adb914ae61dcc40929948e26e9ccab157c69e1abda87036277bafa3453b5615446457d8153016081e82a4030bd144e789d282bdf7b39f53b30e1a7b6ac7e06dcd6f7e1c9aa1ed907dbba3edbc178b5913ade00f810a17cdda3b07e08f1f31a172f66c1425b36d328f3e55f98700baaf156e9ab18aed4c32e7ce704eb0911c1679fc6193956167d1ee23250c97ebe1633e766580ff0879f7219fbd34b6d100552233054ecb3942626b1349f71874e6aa0a6e11327191e0136eb75d3c6780e3139fa4f0cca280c9e1b45d9fe5d25a58cb4bf8f0b3c085524036d9f97736ef49b215ca2c595bff3abdfd0a94c8985c08a6da29d0b7e70dcaf2634d5af20b18736fc28d260f24e2ef72a2878d303709f600a5c24c363a3e39edadd111bc3aa95235e8cb10e2937b293da9e0760cd3fed4f55cb7ecdc9fee35cf11be0f83d6abd19798e24ebc3f0968cc3428611f56f04e8eea130653a815a94429f33378afc7689d987a61b3c4a10b78c480bc3d6171943845a1bf6b9ba4a8f2e47235e7c382445aa0f9bc946fc4e3959d45fbb4451c53e7168d8b94ed3505f170a20f34bfeebf4c8d90b65156b3b1902503b8790ddef1c83ad06259c8f5003e9f882c937eceb74f811b7cb65c72a0b2e3933531dec217e9d8c260ba0eb813fde6f58e627b9106ac5a6baa36f9b730b863d8c73a43b9bc6a5035d02d86ae67378c97bba0ec31adbda191826c6a01fcb582b5df7e9bc4390b146ca73bba9b4716a3de7d7d73dde2ed54e92ba95fcac224dd5e5df17ed2103bcc3808b2debccbc2e34cf68e62083c393e1bc1a075a54aa00099f0cd27e73189940bf8ebd38b4555f5e3914029185f933cdeb6203f9b716c93581951a65b87432e4b39dc477a300963670ee2618a6a4c19b20ba7e32d24488f275c8881f9cf849ab07789e0310b32209f777f078f8a7bfe37fb1bd062dbf62c3f32b3a57093a04186778bb9824b5f7c6ec3971d10e5d460e2946eb3b24d1c8f3d3f59d75a09c1da9d85050bd5d53fbe5adc316d132187e471698cb6127553d3a294f5c6ebcfd13598ae34bec0f62ce1fb71d41d0d9389827111ff5ff726a153c4ff0184932ecf175992e86bec17d9b82689c0f6a625850345b4ec36ad604373d51908b3b39bbe652dd922a9fb9d77867b70a8c734f7ea5cf09f3a77e2d3cf1c1d765cca63043bb77e991eeadb9dfa427b153a649864ed3893fbdb0091f79aa6efd717d2d1b878a4a7464fe9b7e710eca67d11744e8ceb251df8219df4e2c6a09eae03361c8a7f8f397c0ac5f032fa247bc965dcd4d6aa343eb208a96a4a2ea1e79ba9ef827cc2b28754476a01960dfd73eb310752b348296d743d4430e99c67c10a3cde54449ce4ebd9c7a6782200c89eacebf21d9773580450d094839431f13e5850d8ee28b6ddd8f87107bf6b01ec26e208721381a364d22714f3d26312473368b1b0e9842fcd87921e07483c73ae456f83f971ac285ad2f6e73773b7ae1c0949714836799b48e6da68ed59eb37627a70f250443c0ca3ea78f0d3af609be61e56b49a77a02a7900fbfb2d229721e9f2b6ad4ed2454e2769ce620badff26416acf74539e1396e0992729cb0ef8d13ac9a650eb43476f0fcfbe8e9dae0709aa4acb88331646414e70c48c9cf0140b0e4a52f3bf918a32ad8664abe8730a88c6833a92c557af2b0c395eddb8330d8918d255ec009b6e31f3d0026d80cf429cff0aa6b3a6b86c877e2f0be72d8a343b841a2484dc6734ca65554f0c95255765f335e342c6469b70008c961547750734c5cc3ce377f5cdff7492cc1612ea176986b35888decbcdc12e10b1b38df66312e9e3827b53c338c2c77f20cab0facffa37d94469ece4b51fc279bcd591fb836cd0512a47cea9c389c543f1e25eeb6edbce25687503c841fc628adda29da8e3f1241b73a3c404aaf9578784eeeb63433f5a244259ed3d1fc2f3243b1f2810346dea66084a1ef2b4dcb81196ad2b24cd2b2410fe1aa3ebcaf8b32874c4b3f7f740ca8d04141410369a0f5d3cb0e223584af02ef2cfa95b5c683d00d1a7d123007c8b588244870c1356fc2ab7caeb3fd94e7f453666719de3fd9f3fae5296d0ffa372bf70fa8ac007f4ca136f0f96182192a989a016aad7aebeeedd79ea6e25a423836668e9d11bfc6a720eacd64a32192d7eb95a8fa4cb385d72bd018e00f46b998bfa3ee6d60b3972d68ae81b5cdfe87b13c10ef66fdf3dc59680572cc49264bb38d60a03f31fea4d3900d8c457e83a2f095f4590859df07ee311c1dff1e1e14ec39774c2e08cd522310bb180a0bc3168b7a1861866503bd09a518eab2b7d674bde0c8bc3d69b076f7f81d448b97e89b781352a40809f589c6a158c07d9cab38cc6303f75e6339158805f46570ee96f0cf62423899a5be7710b86027eb0c02ac419ebf42f2b4fcee25e3cb202bc7b60faa8b982c7d65317d55a0aadc6fd3612d734aac6a20de7872e4944ffbbbed9bcd7cdf1297cc6a3486663621d1e407cf369316bd1851bc824066ed1d046961a64861bcde2055dcb344e063f4383c7000217a1486c30309b9d8913952b6c7b193256484f37c4b5993c1310cdf982e3d2f12c90f6ce2a46c29790c71c28d8de9d1977c30f3e67b47026229b23b07fa14aa50f7c8ee10175d1c98ab4a0c3644bcf10946b13e63d20be904686251c3de670383ba39168bb4dbc68c1f3161e482a37c96b6c0d22b465c1898097bd9857412de5098fb299b83dd9ce9392c5daf7e607ab2c0806ed64a6c343deb04c59adb3bfe033bae79e3262fc451c53d957fe9610627bd5784e1c661646077bf08d9cbd0715e9c800c9bc5da35b01e87826cc05eec8678b8d0a65bf32b4a6c757914278b2cecb136a3a2337a2f5f01bc0d2ce40e536101db65c71d3714ec88155874165b6f314bb7284a2882e489fd5dab6bdb279bc3e38b9e2900634317d56c70e74d94bdb58c47e691fb2b940ee5be1e75f216855f1676f580bda15ec545ce7f9ed993fec21054384f93cf8e9e638cef141061f5ceb026f87adce5add8899a7e051026aaa7f276ffd6676bdff53d59b957ee5475e9af15eb4ab42ee68ae1cd47b50c742524d7035bbe46ca28215f65dbf33905355e9a1c127f5ababe9c53744f7ff81a02ddf0d18cfe42de07682cf3f9920ce6ee0c87e13ef1b519563ed22c8c9229c56ff1b7748064fe69a9c01167ccbd796b23564b595bb54aa403ef49d5a1e207eb5ba7909164a9a1fd5c68780f3783463f524da9a4c68cbecd5c38bea29466a10e90e03a5ff576197d6281b64ebe3dec550c45cd121b63b33b5d90f74153dba4efe77469c0571eb684e71d20b9c7db9b430996c474d60865982eacbe07815f8b5aa0b6559536042b18ac1749299531eb0bea54cf0b97a1c6130ef254bb1b844bd1552a08f1cda9653e0b3489f7c40a63f8cd4a0dc0529f4745eeca0fb144397cee94101b3fd474830c9ac2110175e2eee868185fa771a721fe94150617cb0f42a3d8a9d43762b6aa25f7571af6f448f33bdac82ab9be84aa810eddad34357bc71b05107a43d87346afdf2de34afc4121313a8bc7ca18ce8e245bd90f575137f06535baad7a8059b39453eb01363b807e8d6fcfc5703f57fd01217dd663c7385bd58d27de695194928949aec8673e8adbdb846ea58310ef972ead6d7d0e27c40506fa5161320b1b8cc9bb8546c180429bb5e99a3d3dbd10c534ab1c9a9a7ff86cad7bca7a4b5a53fc905e350eb87893a4e9abe1102a9e7417a72b80d17f47d07595ad56243ebf1f854bb88d7f05d00fbc351127aaa3e78a6740132fed5f3b33e9ceb3c82f4a90982b9f37be86912e7625e92e5256ea1afaa46d61ce5650ea63acaf116e8376a3af5442c43f299659695a82f431548ea0f1c6923d8bf826e4ea9d09c426512d68dd16ee0d644d795d4a30b2f557c095f6a98d6a6cde78ae5560f9d5573d4864c2dbba31af8a5d7cbdea7cdda0135f07b551fe62aeabefb5f955e4634e89d5edfa5ab1b993974a0c3b04c58d6e005144ab7bd7ee93a2a8f462f83b74e9fc1db7c8c55f28bda23d84397ce20063af3d2ff97192ace69f112a6c185b6efc5072e853fba7d658bce7ffd1bd2c4adabb328ec248ba9bdcb888c0647488d056d418d26649383a93ba979f372cd7a79fb9c0a1daeaf7b824a5ec93b10c9b72b8364eb0b90bf89eb6d0a629d5c3a3e31c903fa3189971ecd75a2280fbf173682dad0370cc6efb459ae3a131c3b4b5435269220ec3f99295dfe05e2862c8a8679f0798f8bc4caaa597c04630199f464218df351f315f907a2449895ad7b2d90a0725ff72db7091f5c3fe6f27176885e67824855930964bdfe385a56a64669f48a924cc0d926a0604739c9c35fb6f4912640a7760763fc016ebf6b16b55f75913cf92962a6a7d520b3d2eae4dc88786b2aada9cda5d352fb778586a2ffc992f96dc9132df9f19563003f1603efba4269b0d04ef794499c09b0184cdcba997964ba1cd166d8443f79dc21564cf8e8b61d82cb365c65c832aaca0b2362f6309e464abcac2c7b0c7123adc03d480f740af01ef4a780f816092a44e358b2123da28df9f444d9d1a851e1b7a57719f8b5c710c2cd9f356b0f0b09ba3911f6a901e584e86670161aa1541a26eba178f6b22944fc4231eb9cdb9d80c76115911fb77493aaa24d8b222b74222f3870c954795281b5187e90f663a14b2bbc326d7d2b5f1df66a8df63633c145b2cd77ff6853145725809087d7d2e2aede6bcd0d88e10af4b95821582be6d51c2264caa4e72c2bfb0552c4ce16305a8cef0b49a7f9997c3db4becdf0079fae2aa30b9c26fb765feef361f9e68bd7d2e4eac5fc00f82e26905f93a45485dd2ce42ad10c4961f062356f01d2223a5ce380ffb7758a781e5e248b06ac318307e64ca19df41fb420624f2f29ffb7548557febdafc3a0f914daa07c4ec9caf3810874f4c88b23d0cf998ccd342a9f15e29b2e593ec40079aba7bef4e648b36518980779042c006562c23d03d757f4a3f8ea82663fcdde83a44396f95263b0624575266cd2e9330098a1dc38d46575588752470a1e7e5fd6d3c286af56154aff7eff8a2572a8494b20e74bab3391468c45a9a0c736fc015934fde359ffb6a0924925de73467a05004b24995c82b872f291b5bfca660b342aee05691fad05555a07b0a563b04c4f92a68b9abad2cd23cc669a1c9d4dc74b1a0755881944bd029e5cf0d32352e780e1e093799910e622420aa97918f9b40c61342553061ee7e55a4c2e46148e3e139c4eccb94b1554b1a13be129fc6f65b4ba749f5a78a22c11e0d6b4f352baaaf9b00de6123e5a0f4e9f918b923b6699cce6727179127c5213397076ea002b04b319235ee188ba4a44a754989b73fc287c2247e8b8b7e7eb58d7f2eb4a5cce935806c44f27103d8a145d2ac8ee69c010c8703d8902a38f7fb2ea882bc427b2928de217a33d429b112a40f561439e0dcfe35093164181bee03415a492f8aedc6b304e754d5f05b819eaa051771aef0464746026346d945b138cffc4441ee2cffa33a578f3d3523e473e0a4c78e60fce89c31fd5982c5425d087976f98510eb1fe2949d4f744a88aec0fd0b5556ed7421892ba665213d1a7c4ca74786a04daf4bc78848958849f72d222c24472b93a2e573d7cd0ace84f891089334d0c06bd27772f7e32cc9ff919e950520f6fb165c3c2b0cc04b98a8b2cafb601ab2bd2e4ceb75b12d030259568f0c35d776f948e38318cdb1de54a9615f4c48c671f34029ce0653ae1be6dd49f434a4fdb68c08f15f4edc94c8a6ed925662a0859bffe891feb23623998b1718129af9d6caeb317e30fce754530acd9792066da7ff174cbac83d220d99afd4a8cd3d75c919e2373d78baf4a252e0a684f950e84e4dce70ef99a4fb5112f82b3102af8cf0a7abde2c5677996d654b2e729bba4171a13affe4d6fd930737b90edc15e9297c510e84a731f9fd7de8e377e3f49b5c4a55693f711acbfe8505ad557c8927c5d5a2a614b02ce605b63aad11b4b53ce12f3b2394ceab1ac9299066ce5605a3b2495e2b3ba834fd8d56d99414bdb35c4d754853c9c5d9fb8683269ac57e4146b094b1d975bc825593a0831aa1c3fa9dc9a22b355870d75da8c914f9e46890567a3cc6c1de6e4a9bb6e66b218610c058115c1135ab9c61a61390338604ef738820cd41a6a7305d701261e84fee24e079e5823f3f1fd40f978756172dedbb3a55727fb4305dce9d814c9934d691dadb64adb6b79a6242e60b1f9495268dbda674404e67f19ff9a35d8833189d33e9fd375829d86b1981ab26b12b709d59149cf5bcd7074dace2648ee62f16c7b7a0439335db8e4369f54661d62ffa044fa8cb2e3bfe16e3fab42372cbaa255c532bb5d9c6d71e65d0cb7cafc4d85c9a55bf7845095351e653b5c409f0505467516c1e840dcb6b717e69f56ad72427c82e8f10f5a225b7dd396b625c849ff8eda970936fca883732cbe69d7364ee179ce1feea7fa8ed1c8ac1b5e8b5dbdb7f4ded8b0b88e5fc6854af54c4d2dacc573227e7240795b7d8800292ffb019c018702a4f135b829fff0f2a4bf0a999adcc3ab7551d6036883e010e380ba3811e77ea977ebd1f995b945b0aa0d19599f91897f8b592fa6df409de6b4db079d9e0db1941e56369f1e8f1934c094ace2bfb32108b0bc77c34903e2af51494e30205cb27b98c4d93002cee20ee6ef9cf829080dd4084ec1143a49b11e7c879768257091bc14e666663f76c45dc462113ea8456127c191e8183e9dcbeb71e85ebe0cd416327754e58a7ea30d20b1a8552edc3ed0d8de266277c7b581cea9fc83a836de89be4e87b8c58810594f802cbdb9fda501d4b64c43e3315032d925ba162cfc23d3897f276fd39f27e364c0e19608194a6ffe59aaaba1aae773213d64efa838b1966dcf950020c88a8cd95bd9fdab4bd423252d3cf3c92d74b43528344b67dc4145667bde60d04bac2e9cc4556b3c4435a554d35a63b7f8a8487ccd3a9d7088ac37290d9e81c4e7b9e301d4f8e4ece55ec7c4a1ce5bb095b2ec32c8c0996fac0684133367700b8422d564985f9a9072723f1065cc964dff88065501a4de6e9bbee8a6b4c037a97dd075043013669d1eb79581a8058af2267f38cd23c6011da3c0a14800f64f4d0049fc64cd0c1810ce1018e758902e616970c41bad174f15bcb6f119c927aafe1062242fc37d0bc9b5a550cf4da1e584a838aa092a486654254ada8f263214c1ce164a6c685826310b6794ed34966d04b25a97a70000e41af7fd1450a29ce92701e43b0848fe66ccec1feae11b0a2a42521eeb7f18c4c54ccd9c8731618cbe9b8af9b8f0a49490db82a33a8f62152cfdb5e8bb4db086c710500c4e7946eda6f2f0a7494e4659312a917df689a20a36cb34b5c5a2f9d17bc1a73e3765d70fff12ac7f8ac9b8cfe48b41579e910a07b1f77424aa611b5e56fdbed0bf9ffcc1f7149bd0aa69ee9204eaa1284629660616d170f40037a219fa91863f128c8359f728e8efe4b3cb5f2da128d2632aec5d876e2c37b98a9fdcde4be820a2130fcddc3809db8a0c64355aa15506e9dc2f2f23880bd270dbe39a39869708945d6d412a3b4008b8b6ee51a29419fbeb7e18fb87dbe677f6a2385960e8b09c836761e8c67c733fc74f2160e7c5645d9d85e091d2e86f49d6cf0843983106beacf3332a9abdf061ecf8cbf003fb74336d11ba2d6a2527994aaa47a797992cfa00b8177e83bf783281d259e419fb60ef13bb526bc27c335b63d85a1536b4ce93753267f0c911f01a942fcba6d7b6a23cab358e85c5cbf5f31d39cea78bd2f04f7ae738e04f4b9d59446c1bbffa3a4f3c95185f0bd69ac7c71f5a54b30f6f222c951e28a556b4d5e502fa94e9bc82012e58638727d86165eb6e92d930aa7b4a2f7fb323b5e3766333f65a56ce1502220adb84fe5d4f34aab7b2128e3d4bfcfa7e3ad83b0c823e605f6da1ebf306d18ad195fa2d93bb9116b118ea12164e92d082c8e88c0907e99c8aaafa3b346d9b77f1e345d8bfd19246cc91aa492c0e5c76f3fca5a8a4190b3ab35bc9b898202019514278c980f76dd2a96668ad7433e787961feb218a3f2a96f1621fc981a0df5e29ea829cd098c95ed243f3e8d0d693c07718a4e56b2f8e2e11279c5383e300bd6e1c345c816401cf79d8db1b441266ac0df68da9d71f0b524d4362e102421c9019ab71bd43edda1b6bd6e487b64d9f5d48d844ac56271ae5efb4151a2ee99274cdd9f7aadbb06bc50a5d648bd1b6ec29ecd19878435120677ece64aaf13987b385752dcc16d6b6d8660445b96368cd8a124548202bb9b8ef8e12ede7c34fbf747e1581eb1c52acea9eff9eff154f6f11816ac2b6e40e94a9db91695c9f670d0d1f3e3f303dea493cf23d949fbf31812686de1ee42bf67affb875d8ab786bff244e955e9ba3170bf47515c62fc6895ec2a0ecea8129d27dae8d8cece19a1b0fc36ca73174b89871a12f1a18f6a76edcb74c1e389362dc9ff6b9872c47655e479acba2a4da9244ef393f9c96b80bd723340c31905d48dea03e082f45ee668fb0ae7ffcee95a1a15c243069c7c77ca678cf20a28ab4b0a7c8b9aa76cdf49ea5bf2531b2a52d3fd031bb403ab0ae8dcc1a3492d35e2e9e5c6c5f6e10e196a42aacf78a78f28eff4480b0d83d2ba849941d418cdef94ef0482848fcc41d09791c22ca528d91c0ecfce9872f5902f8efb399e470ee6e834617d5c760b6b6f6761b656f21de3f20ce867bd3efc57059f0e57cf6b2fc609e4ae14d581da93e4e4de6f929a7ed528bb350db658cfdadc3f919758b770df8849e837fbf0a69f4c8b623979498cec06eaca34bebf9b73f6883ec197467af9fe8fdc29f016a820452847aa367f8373c57e5fd522707525e25f3eb7d8cdbc63c52748adf28e8a31ab580d5ca45eec20367076d346071c488b815a4a779a7fd35e43245d83f0b4a61ad66c3027af0fafdb9422f95db10d983eb167ef8dadd6ea52c0b64d384011fa46b2096eccc5736ec2be3b94b45ef4d5d640e6feb5eb4e052dc614ca72ea60df08e2c7960623e220aa512e73503da547cf50f6890b53b528e56310424b97ef19f3842adcfc963a6eb80f9e7bcf64c666b5154eee813519181160b4a1f05a80122c976b1b0cd6564a9cbc24af3bfbc3ff23603e318a6433c954be75fe562aee72c60d755defa92d0da72a30a5278d53ab59db3d5cdb216b3155bd0b626bb9a4ac1c1a5d0b41fb9a82356f4595b934b64bf0b91754a922607398436a4c9fbe87047455c87397c02f5c643ae5e6cd3de9a99017ab68f1473345b1f52c46724d3f40491dea9d9137c6568c22df3cc10781b51aa76f38d226f32e43bdec216d5362f2f48af6497518ae7341ce3bacccb6a30338c5ff48e0fc5265b7a258c88e0c010737c1584cd26664eb5329627dc6253f9b36c75c9898bee0619f0ad6e924b984e4647b46969126648cf488e209b1d4a73457d54c0a9d5f2c6eefa949ed11ba789fed4d678a67eec2dabaf33ba56c758c78243bd0c33a9701f8af4394da52456df8cf9930c6ef850547932ff82cd4585a0acdf15ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
