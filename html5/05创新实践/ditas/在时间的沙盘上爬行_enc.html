<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13ad10336ce8430aafede0026e629cb2639201458ed31816053f764dd445324941b926c566a64117dc6f53c5dfa8666cfdaf77ae3d99e10d93b9ae318c302634363ce227ef94888cebcc7419aeee0190f6353a6ccbcdffcb263e2b0338e450c8579a787c187efc6c49e2619f17e4847b6a81ba8fb4f735ce8024c3fa3b5d9caf7e98ab66edb25ace502999886d382a0759e2a100636e353a19b77458deffbe8e677a1c2a42ef2b9b537ecc83c0f753594fb78b1de82536403dbedfa652737594236c58a3ca4e793d806dab10d1f36a5e75489a7fb0daa29353275ae95214c10fb585635d3c5273cc663e91baf277b717a2c0dba779bdd874045f23ef06e9ba16275e1263df75e5953ce89d60970cb8681841d6a9046f8ce4d459eecbb3c5b91fcb728af37b5bba28e6c59403719bf7ae65d5b52067df46ab59e9a761b080b98db5e02c610835c24484283a6abe7631ccf7d65f3e1813ab3eb7110f0a1adeabeebb0bac2dff71073e349d1ca8de21c00bb2a27e7ff570ea1403906b155b3e34bdbda2d1a61135b1720d7a210da0e404576187fdf744a2fe9aac4a5df0b6dcc0ca4e87d6fb6861cd9b74c2dee85b993135c427d0bfa2dfd4354103468848f165da166ea30770066fa85851891e7e06d13a23bf2f1a791b0063f579f1ff1833afa243981560f051f83fd844907d93aabbc686952b3fff08d7f6dc5717376f13f9c6ab19cf0f67cffec296af9ca1972be528dfaea6e26e6e1935a3a94ef524eb45cec964f315de068b920faff268eae49066383a75552e903c5f8454c3dd67e7c069686f199904c31087d0fae221e3077ed5b17c630b68cf6dcf1974dc3b169971b2da4711b20d0406da51496f3ff19c3babdad81698d9de91e90bde189e543e4d54ee73a6dd4dc518389ac7bb2d51b4efc4e91b6e17a415b1728e95362616380870a4c07f64a1f2f81e0f4fc1c7d0e4047e9e1e7bb8102c1024454c118386e34ff258b616d2111f78387eee762878920280403c7279213042e4f21f8e6760d6b221fe5a08dbae173ecdc08588eb19f245ff67fef634147a4b5e361a5e81c193ac313198f524f9a9e85de761cff0c11e2790b425055a4fcf619bc4d5bb9d57ffd6bf8cfc64c3f1efebe417bf17d7d31f75f355fe3cd17d317659bc7dd469b27b38048f18fd1a83939e486d758c28cebe5378134e5f769246dea18209daecb8aea50ddf22b2b5410e5670644701e8e5928588bf4c624b65a12f12023c6ada830c498cf981f35f375437d379572d2ba1908863bc9cc69fdaac6768c67f0807fe30f9d46e8aaa5a5f16f653d11751de7c7a042e4981e0be5941f78a3cc2ce3371bbd7f0e4e62aaba80cbd4a0f98f95448769b94107ed32a9b97516004aea7b4272b9558ff51a993b7027da73d941785cb73d7abba03efb7244404c92d9db569b5c7dda4866901c9fcef749b105974f03f35f425d4d0316d93bef194962072ab0a8458ccec87bb7d29d59b29e9132b2a2caa87ccfa9bfbda5d97a943a7cc6d150992a29bf3e2890ce65724072ca3f73853f3531e6c9610db86e3b3aff87a874b549c3e6eaf90497ade7a27d307c95da60115bbb28e75734879be11ffb8b46468fb74dadd0ae1adc780b1eab05745a0214f7510ce9ff1750983a12cd1b688f0c5924c4cc3d86f4c5cd05dc7548dae96467206891e3b6f0a8e1bf399417c2682f2116abc90f672ce3a0a679cafdf85eb6af80654f87c7fd9596427fe6cfffb84e6dbe8f385174ef58049502058913b6f57b108df32f3bae3a5df9085b0a4caa787380f24555926dc6f9767c7508ebc63a9dbaaf95b166a18a74d6c1e8e79156920d8c4790dd1987f16acc94b086f32a34d8001dc2fea0919656f5cad788c0cabd39edbe12c6152e16d2597bfa87e0eb4fef704038e0c81a388e6956cd87a3f6cb11f1bf5d11c20d82bfad2ce5fe55723fa94f3c415c3d89e423a4eeaaaa8da5d421fc8ede35c97092362a2891e6fc4f50eb2ce24b4865bd0dbeeb1dd2d38e96dc52d50280e9bd883b95e23ea6ece352efaab871b0862a54f0a6586288231512ff82ea9d4ddc0d221302ebdaa030071f1211d4216788187f9625074cf8189cd1fe082ab34de1266ee2ec9e89f8f8f2d6f1531f8a5567c0a3f6e81964b21715d422e80704b85b6c249b5bede80a3ccafc12e60efe06d934eb7afc1d780aa7e8e271251fdfe75e7344dd343f128d198a1f64499c77906a0a0f0542baf9ce4e34021b92a8bb86ca1c9846c022790f71a788711d5b9b6732f3ec9756281b88d852515d72b80219fe93d59ee876e15ec5a43b42d3e8bffb1697e634e5eb4562c969a4cde7ec4cfaea78b594b7a26906e9601e10c911ad156b46de7c3fbee6370b3e05a812f9b39cea7ae4b8eac20acf5341c00f24dc42f0ae328d4340adfae623fe6dada4888a6f4768a2e7b08417d5c0ddae00fefcf17a11f3adaff35cd83b0ef5f25fdeb709c395e49ee35e5ce0f8858f68e6c4227162b5f00e491967de2f259f4214cc7cfb82bc315cc030e02925258749e5cee3b7ab88d00bc394f4439c7afa33202e9aed68ba4b2cf3be4ac3862c826e2fa10cfb99d0ccb82da3d72387b5e782910e6979a3c3cf25f4f09c00723467db401fdb175df7e1d0cdd1775b33f63a0168e39f9ce60b607d45c043dc8dbc41f47a5b2390895a0a512a8a9bfa4c987d992300042dc2c9ae604ad78abfbadc11dc3e055c839f7d84e97eed3864948e792a33cd16b4b7cd5fefa86be1e94c01a49174f7c740d7ad90dbd127f2167c430126bc0e7383f407f5f1c452f75cf5c32e11fefe17657f4241fbd991f59159f098fa55efa84021a8cae133b6e5f419dedb3308c440f830e0233bcbaf5b9c4b5b90c16fd704058c947f51837e6e62b287ae72b5d03b1d6db0b6ef41453596ee38e1e4505da4a1b0e66ad292ce8fbca0598952ebc95bf869efa7ba284cbb3ed3145ab3e16303eada266215c7bcd1efe0cf5b04ffa1ec75928cbd027598336aaccfa86d507b663e9120a78f7f1928e592ce7737067c2fe365a65778762feee55b362a2e1c0e9fc78cfc117c0b5f10b87efb5b70cadc1eaa759321052b85fe9ab96a3c24358559819daea7b751a542c540f80dff4a475f26e485b4c8d553976aef7c1348f8f4cf74e5f7f7fdef0539cffc049dc81021e1f095486c997e0ec46090899e9a3c6be12fc27e4373d49ae7b55cff506abd37e46e3340180c2816fa255d79a4a24cf6654bb0ad896d79cfd854dea548a489f402ab5e7c506ce12fb439f8ecc48d3121a007c892000f684be82a42a996a683fad78854d11db587a441f2281f6a4024d7bd40872c49c3ba12e9c149f31f554860010286fe721939a12578696589e5d466e38dfc9cad4abd278ddd0760387c4b0f7123ad16a39b82df4103f83b2f65e5bec2a7b341741ef926e8c016f037b0bc0b99b2dd80688fba51d7033419b9b0f0fa3a9822206d5d1f6fdab27a6469756015e65700d548a0cab5b579c9739fbd8480c065553ab72dcd030228a72ff1f3883ccb0fe842d78112ef6af441525b7a0a82b5b7b4c8cdcfbddc89f26ff8e5f0782c819c245e1830a857f7efd9b9d41f9e75dce3b5435052d85042088a719875c7a5c299718f40517c7b967d9bf93ce928f8ba1d0ffc43d7917aecc20f8adb04262c5e29b51da6bfa3e8b440bb56c354024ccc047a715bbd1ec7657d4cd2fbc5c03b9f25a5f0d02b07239a1301cf725b63f05a39de654c3eb5d9e048228b15d02eeeee33842a724d2359c202fa0df6913cf1bd964ac31a6afdebf1d741bf55f72d114b0b96e8efd03734bd1c8b36b4ee724048402bfe5db669566456d744df1d4b7625537421e6a01746b567bfc7bb209cb75934ffe3112ef81dd84482c8a853ed3ffe9e1104f28625168563bfa714e5b30b05f7b603240c34afff63e4b4d426ef7f6b5dcfeb38b03c4ce99de417274c8f576b853b025c81202ab7b3a4449b567aaab01a1bb68ec56a9d51463a8fb424917d244f2853e6488868c6fb92f77f8b5cc912a16ddf1f63f78b7c4d27d5c7811964eb1e98fe848291eae96d783982b5fc9fd14901067d80951a32f8ad1f822af23265736c0d8dedd059e695cdfb4ae432e4393e14724e71cf28641fb27d26034996fc4dcb5974e661a94b4fb3f4fb94d5fc0794ae48c7bda5ea67997bc657623e523d56f1a162e51db4c3863bc92080f4b0f3f79e560958040c4fe1765be98651a5af111eab99559fa0543a27613022e357008254185e6db43db60df6a3fac897b3596af3746d54b3b87e9b0518a9731d0427774b5c5f6a1babc09e09a31ddddb498728fba34e2733fff10b72ab3385a685de25abe7c105fc9b34a1c09bf017f0ab3932f6b80bc9f87e6682498554adee0fa284efa3757ffab5584d11cd7ced77a8962b62210f198ecbf2cb41107bc0715d3975417bc5aebdc59bd951b91a89b7e8cd81d8d5d840cd307c176edc730e4e786081dcb761ce850447564d619ef77234cc03db9187ba913d3082b46d8e0281e4127c7fb3b02eb9a344aa76770f77de27c50109528ef7a57013119ab3d65bc69c84d17ec902cf0e3502e3912ac9c67d177a9ed7d12d8fa8579a6468c2f7f9302c71380bf4e1e50120f9926517a07558d4d2aef3d573cba9220b53ab33cda6d83522dc378a2dccebe81375ea40180f71a3ff41fa02d7353c8a8770820d027c7127a2e9dfcde58a3421eec68aeb236c3f5dc9b7e6c6206ebcc2d2e9313cd3b4de79ff0ec6d55ecca5e27e33bb5ab8a152dabe31a26c451745a629ef05bc390146a3a57ec322d36932945853f979e0166f25d519c086459c558a9e1bb7200c411c75cf383900250c4312c74d3ea962afbe598af6906378a8412c0a40fc6f3e981f69ec2fe6c97d5ff75a9f45b8da43c183b869beaffccb59e55feb5ef7b65b3dce75561ef0824b91f87cf32a571437a3941ae26f722f7c31191d4e2c096e7b0090d4512c6c310095032020668e188b5d07a433441864828a376bfed66a65f952910aa50976ad1e024b21e92794e802d194b4a0d621cadb4a95a52c76fe5fa38bbb64fed3c2f6eb25394bbb537059cd19e1c43de9c90f954b78426f1d7208d16b036b518065a1b15c2d4739e9bb5c455f7cdbf72c8ba992301a580e23c3cbd6e60d1b3ca5e3e6bf4cf8be3290b8b1604a6951e69fc77cf81dc403e57e93d4c715606f2e8e4d4baa829be361922cc1c873eda2b98d0849d45b7bf8591da8a0cc772159fa0b3beaa6027ffe3b85901f09a7f06f55746136b49fb8817543d31462542822cf1194646d07f1b690cc094bc93496ca7f37c2c15321b03e90bacc2403a980a69a78260c9af50432bf25522db8e9812a7ceca00e91ca53e256fadc6003e9e12d532bb98e901f6409fd72adfb86bea4f59ea9567d8dab1c3478ef808cafdb0d222a271f61ad80df62c79cb6c2efa8a68d75be08db5c11de100af1bfa0dc6359209046221f77d3bedf0caa281ccd071206b2b6fd03404f05a29e71c34006cfc3ef39e9a9f4509552aa079de7f523c465a7fbca6d6566f6c33c734d2b58d1e43274f86b84d11a61d3b7206486233be0811ba5ae4032e2fd8bd5659b9e5c4e722aa876f3ea4ea9be122d0a8a6c63788c708df7d07afbf53c4ba61078bbc651b9bccd05cf4c9e146769607e96a865024ad26b9fc0386f8014b69efc9f44f18f6887fe319727b9cafa995c035219b6db5ef67f24c5a689f32391e544e8d504d4a380520f380df983aa44e1aaa25ea47eb35734a5024e405225f46bf3eab1265b0495eaf099fa329dde651da4bd7111c1ef24c5c415ad64146533fcfdc6a73f46705f01686c28ede74899beebc34e0f501fc7074bbf004b72472426c8ff2a770d29e307dc095ed18790cbf2d959dd88de4178c1bdce0e0e105c1e3c1f4a1a70dd53efb0fae6341df8d924e8e0b5caf86e15700d153b916c7e5b17d67f0484aeafc87fe1fa0d0bd7335acceda9bbecf5427123878b9037307598056e65a17814058a644b83ea03616c5d136fba3d8a5cd9b987b98963cf0ea24bc4b950c3e35ad7ffe4aff8493bbba9ea34f5e01c8093f4ed69a2e3c0be23842d44f9074e71fb5c2d038c7431b3a955687ac5eb498393c1389fe31f1fce3cf389a1486fa11b3ed7dc85b2b5a85d2546295e2a983447be656a043aa1257b46beb436289ef70d01b15e076697db44569d9bd994ca47cd13570d7f95a5c5ac9b4278f41b3affb63e5d767fb8d67623ca5052b632bed20c326872435d2ec98303a9992d130051baa7de272865ae184abbb48a33a298c2d62f153fe95d4fb7a01644717320c322424814e25c93286da5c9515d77a3a06387216b54e513cd6b4404c5cba606bed686aa30e45b592b7b098b96eb3cf042cf91f1f0a929cddbbe67acb0c8d6d67e0b65aa0fc89c50fc6aa904cc995df17e163559fa431d86683ccf272ecd410fe2c1c7ffdc2670d8273d8bc15221fea8018bf13014f6a08167dd4dff76900466cdeb69efe46b19ea3c75325a76931e5e9101e36af576da28668ff33f4d0b36b4a51cca10ee98c408d8aa3992df07a48cba5306307e101dec4abda3702a3180afecb71cfd35bdad49ae7084e7c638adbe49d0b972620e672c3bf8013df9446cb6efce986945659ace95e2dcb39e5c36d3326ee871f599a69f223776ffe955119250504f602245090d3ac981f39158619265c8396d6f67bd2b1c60f1f9fa56be95bc76eb6ec128aa886cecce831591597bc2f456dfaf43eb639c4d9d1abf9ca234c56fc2bf0df1fd91ba550640d20e6e640ac6e056d6d2470ea3a273b2110726fdfc945a77d2a177b2425d7cb687c50603a5ffa904d858cca89b375354d65e3da88d2aa154a45cc0b9541824de839e68aa3fd13850e56156cf3f06a6632bda29e66c8502645d2ba4cde26766ce11a38bf8cb14e2ba255ac32707264447e9ce46468870515bd744f1add4c575ed93d0c3ce40a2593b05c700277c163ae22b1d8349c8f62aa5dfb201a13f46602ecfea86756b53615e4a863e87a191390a88b0557ee3cd5705426c66d44c3cf31325be7cbb1342e2e82a746dfdc7a1a1330a71d4a09382c6321495eb81d6c233af1fe84ec4a014c7ac1871b5a0f0d63804f09c2c13248d594484940dce64c6890507e08d71e5bee6fe979d4751ba338c522e255c498a9bfc35a7347c3d379321913302b758fba2d14a4d8aa4fd6726614d9c6a9cf65d82cf9a5367b9624cbaf31287c2a3e369d8fb787d38f72b61d9ec86cfa8299fc3488966e1e6a59f8d1d88368584581e68b1cd33c300884b51826b282f1e53457766607ed0a564591cb19fa115c6352563fbc2a1d2f39a876e95df4dee14f5b23b62a0350062489e8c85bd66e63d053b47daa597f2263fbfceaf4c5ebd997f3b120a0aae1f95a9c2eb192fe40d1e809623835cb70f2f75e5be496603a5335a427e75c7557654566da19037d8e0b7e02305a6be9e3129c362bc5c30b96f64db48368ea9cc6605467f1d2039f66ed834d40e8ae486830ef5f29cb10a297e018222f4d4f19e425ee66f9030b03aa307bf10c91425ae2efed674221459d55c0ac486707775c4a69ac020a276aa0ca55cb4e027af8608d1d5721880fe172dc4ed35376aad213490134085fb7ec30a4f093c478ef8c6d1b50e775b8d3d81bfeb36584055cd0924a2fd8527b2d69fa0a48f252336fd127d6d91bb8caf63270101fc79ce659b20c12397063ee54b420685cbc2b84b68d525b8975bb8d5052d68eb1d94b6a77f108d754f206e8da2e6bf43f31478cc4526f017ceeb3b39028a7193802564b458421a40a204c8dfd5827059394f1465638827a3afdeb74ab4fcf5170125c3f30f850fe476c7007ea3ac59dd947055a5a4064b89de679ba014d414ea988e9d2384dd18c0f09245792555eda0fbac5daa4fe5eb78ec16b6f926ebd9205ced5e4cd4259b1a242af277fe9a79c18ca52e11931964b51f72029eac7827b86e93ee7dbcdf16a84ef64295a96ab39da0990c801eeb21aa76d8631c4a8cd64c8029c4d7736533fe328ec39841627","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
