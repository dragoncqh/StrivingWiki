<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25f9ba87b11b5138b32c5f4a43f8ef0a3c7237842c25702abc46c5dd7e3f0bb49135b56fbcfcbb8966d28cb15f3c9b678939e497c8ce1761b1c3f2a942bd54c6a10d02052b86d959123498794b29d183bca39c1f1ce203dba3860d05034823cd6ae044d2422c59ebad52f5d549a92ac697d838b8bb7e94076cf05c734c9d62e7230b6ca71d5d719f04326d7f79e06b4fca7cffa73be33145337b5eaadf8676d7ed6d8c0f39d21d9138b022c758cf5704759fbd69994329d424dccf1b68330b90e26bba0d801bafc36f46c137ccd167336ce97a9ec0c538540238d9fa0c29bed0f5efea993ee34af8b4aed063ec378911e19ecc86dd0376f92c434256616e24a4d35a82b5956b68956b13b5b8c2ceceacdf38346ce94c9be14e6f95190da27dfcdb98779e233d1e989bc1aa1f548ec18c244c4b61053656f2f741b947085b17f2322f8e42a3f39454e29165de6ff63d1e669c290592963666de7e6e1e24cc4f8ff48359c12af94cc4c2b3fa96456488102dff3a5f43fc4c53717e618120db372297f0f3d51e73fa076a0fc5dc92b5fe3bd923cd49f12dd840ba431e11eb91ede718d7fcb71016abfa855d5c8d91a8e7d5ad3872cdf27d634e4377ca3a2ca6a3548325207ef091969f919288b0ae322c9daf9387e97d5ca75c040021977c208145a6867198e6b4664894a8b03675c56178168a64fdf3210825e6c96ed657ed3270fbf101d5a8f44f96851501d337b5600d13b1be0d450533d5a006f867036cd123189e64ce4dd844bd2beb4639e9414c00cb2ff2e5bf4cc2dc5bdab771f45bb5c5cb0d843d5101d9ad31c1a24b37b7390e0e1ad2fff106ea7effe0fc7e7e80dd1698aaf3e10930cea48338668b7672166a5b6af47ba265a831cbb22ea46c3f13bd09092025eb34dbd533ad2857e40ba8141fbe58af49fc8c6fdaf3667150e6a5406db0c028fff65153de5c19a9475aefdf3b88de3d094d6205294c616cf10e9ce279e21abcd8df43da69cee7e4f210d1d9ad8967bebf9fbefb4953ed03ce91ea8b92ca3be033dc4235f709a548d5095ad107d66845138f5437ae41e37754ad61df0b09d1853d2991290732e2887fe07ce8c266131e538e6ab9ac03d23cd3cbec45119cc1b20487fa401d62e5815a93f51652af6ceaeaaf07bb1b932823d51ace6ecd1ef92dd7613ee01906838b7c24b5f09603743878a53e3b825b548f769dc233bb100d0d5ac6744a0876b921b98e1e943f5e668ef6aad54d21acf970692b4a1f6f9e04ff5d9492a48586a88010c195041909b63b7786639a258b959dc442f53b229d06e731a3ad0699ae0bc23dc58172026ed18f20c27d96c8b4537dd6b2b300f2f3c812e6949b6b3c420f0e82225794177343433974e7d07b41d13a1a3007f48829220f15ce70960a4db59d3ea69668f1d4c019c26f8bdc0102e629d5305fd0f0686810b57985d084b2dffcec2003f37cc81d87876b39cd7edfbb722e09e88300551657af6667a0e287d180fe4a5877e945e8b7ec1c5062d866a9c95ffdd9b7e08731b68e8da3d1c36bff01e3ebaf7482ad1c266b88d4ee6965e684a77cd45e0e092a1bde2c1a5c6e3b556131cf64ee4c55a0e0f26f3941843e4be4afec0f56a0b6e235113d62c6ff096e9a7558973058c661577f0196b157259f654bbb1dcd772d1e4c65aef7c2cb347349640397a28189a87e5e6199201fcc40ce00b1ae4d20705b733765037931ccf94a4b9d670a0c3c1b91258da29a7b589a611221744b1eb7a6042945d9114739833c82082a9af9d0c4ab36e9dc497f2e74c2a644e017502d2ec9bf5077ae4aad2041ef888c8d561a0684a985b7ab72ddf3286a0e737a4c0e6fa484c3fc18b16bef775b1ad00805f286147e79196ad8eebb957b57833004d5becbdd318b898d53adc3998e4e09e01dce1c9716776c059430d24c7e40862c37efb2c0ab4b0d3a0f527ad06ad54d8f8f9bb80e6b1f261b97ae72bcb38360a4525ba04035baa81e6fb838c4a7c5fbab3568a1fc4de1526af79663e479730757f5df1c12c9fc4f76582f9a1dc004a16f19511379071f5328e2ac330259104146269ebadc8ddc5fa722557554bb23fc5e401acc9c809e97813c99fe6d0d545103a1bcb7ea5ee2cd7d89b6bae723b7de98a13c9413a77f556523ee4082eb9a1cb58437fd39e77cd068d8c5da4bc34bea155cad5c7bdc8edbfefded157be2ef3d4129e3a869da01048cbcbdcf9570b4d3ca0dd1b1dee3308239e8b707bd983ba6e345c4b3eb6b9b8d9af0e85c5ffed6eba754fcbf53d50ee36ca1e0fdb78f3d36563d4b77ee4e7aa0a4e8d2b0e35f7049547e7e6895ae7dbe2a3081b4b2e895cf91ef8673a398c1bbda1edb68cfb50fb53928c4c9267815aa38f5e4f0d439a08080b851d37befb24f08e259fd47a394793066c02e554a0e5f8f5b1cf820ea9d8f5ef3e043faece266114251b31dd299a5a13f2983fdad1219bccfe75d018e958e15c28906a1d48960468f520d7ca9bc72ef022a7ec132cbf384ef34ec3f1eef087215249e8ee89994c71ebef26bd06bb8289de08741341b782b787080278cb9585018ba72ef4ecdaab8c2886749ff0bd175ceca330b62252adc0617cbfc6b3e01ca262acd73b18e45d04076e97e7c6a150c10033e80e0d0227c45d3187f99d4d1b9816b09c4c8b9a38b51c86f6de1e29160f51c67803d9519ddf73f99227afdd56cccc121b3398832d1118919ff7518652ea8c44fccea42cec57eee1b0cd786d3012d936dd78d79e6d104a043bd5aded48a96d747abe0881aa86ff587530ad2a6353d6a1fde75993b4f61ad3429651c0cddd89703486591b9dbf85e658e04b1aa5d44aa538aa337fb1f3ed620cff46cd350d21624bcb35794e865882a1f03c9af4d76b5c93b62a7aa95f88990404ecaa7e7dc0aea9f9b07e82e161fed50c9de222176661c05346cd98df522fce7472fcd2472a944d44c38890aca1ff8709de72da045054c13d9781b2de935b987294ab18ff63fd9bed631c7b62ec71884a093a4c71dcd864e4e21a3f4ad47e8f43a796299778b4151869b73ffb0985f9dda14b974ad300d6fbd96bd5d709f65e5878e33d05e16c35347bd4a4f0d5d33811bdc3dbbfb09fea827630ca2234c5dbc28c92a70468217efee28233c88f1212f34dae1b7d1e8753851e925982e46a3c3eca3b77f4490d0aced6c6c7312fce563cd4a149e29b9b3f68f8e013a635e1c8ea8cc9ad91930f5ff590b2222e598fdef5ec40abfc2b36e946377a5d3c592bb1cd12663da75873543b1792952de8ab52806c452b9594133dc2fb290c2755e4fffd47fa91dc7d1a7027faf8694cd5d99449b271dd5d302dc6f436765ed93238d13ff4008e54d341a8b84468b1ac67e47183f5fc3f562df8f56751bf353bdaf0b2cbced50705d13f823396d37a92685a7340fb7c17efbf7f8660f0e49389dab17b67bd94ec5015c56bfec7080cc6501e184fdb407af88927eecb0621ac6e44ab0f9e83794040bfff697d2bb2eb7721da2974f4196ab05a094cb8e8527a4a363e4eed4778e6eae2ed8b9fc62ca063235562a544ca2c7eef042a52853039aa1a3aa6981a973d185c0423b02d7d854d49d154b527c2e7f5a1736a62f1b865d095886297042a60171e8d3565479fa833ccf39983cbe0ac29ebd01be085b87c1259c746db4fab91a6ea4f2225779ab00ba30a511671ee041b7f071302d3edc08f37daa31961c9bb124d659ca8f2e195da34a28db86862765705f0a69206ad45699fada7cf7ad165b71bdabcd59302ee6b0a53ebacb4e15b8140e81fe43c0bed944ddc6c841034112be865ba6540495af0dd489af89c40158fdf48a5e5ea50c18397e5848c9ec5fe517d9c566eab556cc29b774e91b3a08829a15eee436182ad2969f81203d3fbaa76d4636e985ff82a344f8e7114b875451fcecdb8edb24c0ec15cb2895ad0235d08285b3c23b60b588843a2947babe46dc47a80c966d842e3d40059d9d44c70d9bfdd3128765bba99f38266d3c3338bddc662b1a5534785279b1033890ff3dcb0c6d06a76c8bfd5bdb78eba78521e00d6eaa64a24c811e9cf74ae7b5d9bfb6b65e47a29657ce562183f6f20e280f36fc1c13896c524b4671d4b58d532a35289fa2b01bdcc99b47c9a4ceeaf6899ad994437ad007921d0fdbd6fad7c83e2f6a62e8f42a377ef0a11a14e2ef5bd9928608e9f8b65fe27c2616b6674b85a392cd5b683481f2bc2485bc17009abcd453bcbc3e77bd1b064caa4b77e248331c39128737ad207280e2a57aaf99395d6b305bd278d25718fb3ee344410c9620f84f3f11a113b010e890308a93872366c6e4e0159ba6a02e5369c446f8a76d13232bc3ccc84096abbb72beaeb790c6ec5d5b336b6d238d61b0a60e6f5af77d6ee9d8ff2c4c42e29ed8ffbe661a4891e539afb5d6bd3feca003bae023a9bca4659ed458eeb821f76d143bd37813ac503de3108a3ec3a3cd098e517feb86c7dae112a95b7a8752e38fe8a4e5164b1e6604f4e5caa433d22249171609cba16741cebefe5231d2b5414991ee600794ae49a0c7d4a3cdd156cf5d01fa42e45563d8bc5e28b5e23908fc13465b0fe8c578d210e9f4600c9461083bb1df0cb0009d89a7f248df07e8480a90c324b3605f0a0572821456665e5e9eefd51959a45cc30b8efe4ecac3abe07a9f2d07e976a4ee8467b60822c9c87c7b1e48ada662977c2edb9b6ebef9cfa763fbda1ec24a163168cbaf29548db06732912626fd7697c2a256c7e10eff61587097a3bc03b10a03d3cdbbb9b2fe51b95d271da2ce5b90e4273a546e1c2c86f45fd93b69c1b4f4349c4f18d597d170b33b517010662d628a6bd77e5e04cc91c2b872578dd3c0cb145bdfdf071325e1f0bd7190cc2afb2270c6faf3170d76d96abc1b8d8f1647a5328c62c865cf23890dfa90a5d50bc1cc570ac0bae44e4c7925d7fb4c04ed85adaa85a8e885b45eb2a0a5228a87a0cf12f568bf18225ebf4bb605463fbad1832ade79c7bb3e94367ef0cfd6adca9f0f20352948cbaefaf860a22ad0e56d2d138732ec9417aac212d6633791b00e46ad8a7a65a65fb0cddd934beff7da45da986e91348de2488921397e46ca0d58d8697acd9ed62ca39a9303e8ea67d505e230b2b44ea4dff3571812a1e38461ffdfe171431a3be506df598a0b9636bb07d4c79721c1fac2113c0dd236b925ec52a8c87bd25d4affb8e783577d1e34fc952dc2571fd6d4a6fec5ccbfd0b5265f4f24e5b9a90d975f7b4d4477aa50d55fbe0a7578b3e34e70f2da117fa8ae0525dede9b437bb3bd3e9d7f85264f1304d01ceaa4018a5cc4d919cf99c5df5db8ee627e8b6245e6bdaa66a8c006d802940c4a728f673a37171d6276c0ef7dcdbe8e32f410da30eb353fa24cf501a1dcebedf7dc9ead502db8a1f1998700f5912a6cdd50b7fdd04f209921d4f190ac6ca6c20384b83915470dece1d6444c546ed77e18f7852e4505fb4b3f48fad61901e8036a416980acab200bcf29a0835a92e07ab631f2e4573126f3c0f79dd2fb9a595deae1576c90e12a7b5df5e567a584a3e2c47d033d6e3e7e0188d96f3c76b353750521f08f56d957a354dc7592ddfea57208093facc946ac344d3a8596c4b3ef3962f5ca812414799a93749648a1216b85c1386909f257a453d064eedce55412e240190d96d5b3d4744266692cf9f0e7e6313f8e53b450d8fee93be9fcb0b9bc06f90ccc6f3d12c0b428ce966854ea0e5a9154d4588454d07140d154cffda8a52ac20fd91fa0f89013a7e496ad1a2d10e66b4f0e092a0f6fff01851462bad02761d20553a8338daf5854c7847ae87fbeff649382e7a3e3b00288c761d4868db7b4d45d61de7776105aa413eca275430ba790b85e9828654fde7e7309e95d6e33afd15fe4540dab47fcd526e08900a2279d2642cbf2f1fb1932e841156682dec198e78daac128a0229ba198447e4809b8686253b3a8283aa582b72f7981e161c36fe645142cd1dd8d42ac0bb3abd6f5e1d5cdc76bd83d3bc3cb0f45971a49fe659074fc71e90e03da4d9b24a4dfdde322d5a6446badd28be9911903f4c18be108c123bcaff2a86ad62cf33d40f2bd1bae5ed46728d8748207d5cc948ef7f00990b359025b8a6b946a0066ed3431511875ed97d0a70784d32240e6e99a208e6d40e8b8fa875e05c30054c66e33722c26945493efa3547a6b75955c6ea2b3347b82cec64ef03ae46e922d9b3b2e1c7790296e262c192da2e890514eee07168b31dca86e2cdc4e1d3b75d826ecd39b9206abc2991e90d66f1cc74704957348ddddb78c0258eb3c42c0144085d417d20c465da324cfd0c92e7135efbec992d4423afff5ccfbc2bfca1858b8ce980a1224698881c893d233ff7827c33efeaf82cca991c30530cb58c5f97601306817a8f20d34b44b01eedfc90cfa9e440075a9b96b82651dd547fdab490647e1a0ad6bb077d0632ff59e720c4a2570c49dd92c462471c2332cea83ae3754ad458a096d1633651c5d4630d1dfbbaef487b1b1763d96fe588ed2362648732d584665a129a86e8c9b2743180d396481be93a03607d976eaa6189f38e0f425e8c9c7a5f1cc3278029885377bb7e5b6c94b8d5f946c0d0d145df2e1a59e9b4f34e395522eb8b0e9271c875b5e419035b76ece69b96f08b585d99b41a91ae2e60fa9818dba73ca5fa25cfb681e559a4cee1493e9549d9b16c3bdabf55cbac16efb2a04703145716db77dfeeef8017b3959cd9f0fd01d9a3555081e1d3677304add6ea5104fa1b2bfd73a0e3fa12e8477b8816146d22a4cecd07a9a2ba38c3d7612e8fd63c3fe9058e1fdd0eb864c6036040cd220ffa9275fd5e0121dd6d5ab639aa34fc358fb85e3d6e66f982deef8024c41969f92edd11f3f6aecf86e84196d39886a42f7cda644e40bebb79d6e60b286bc14495066b8ab25c68c9b61ee84c6bc2df99fd39a2a3c8156f056b87d2f7e9b35566777c3cb72652bf5192fef7442770c77b7f63e4a2a1a355f84875ac521c3a90a231b07805eebf6e638b40c65b0ea31c34a3d661335996e47da25ed8c68dbbfb885924452eb51173ffccab2c7abba96dfeb79de3d755ee925f971dd182031c54cf6ec0cbf5dc192d94adcd8115271e576540fb940eab6a6ab97bc8cf8e13dd9f1800ee48a599e0f2f60eb248c5ed748dae6996acddf188c5022f3ca639fa9c6b85c9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
